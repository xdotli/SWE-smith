{
    "cost": 0.40249450000000003,
    "rewrites": {
        "pylint-dev__astroid.b114f6b5/astroid/nodes/node_classes.py": {
            "output": "# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n# For details: https://github.com/pylint-dev/astroid/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/astroid/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Module for some node classes. More nodes in scoped_nodes.py\"\"\"\n\nfrom __future__ import annotations\n\nimport abc\nimport ast\nimport itertools\nimport operator\nimport sys\nimport typing\nimport warnings\nfrom collections.abc import Callable, Generator, Iterable, Iterator, Mapping\nfrom functools import cached_property\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    ClassVar,\n    Literal,\n    Optional,\n    Union,\n)\n\nfrom astroid import decorators, protocols, util\nfrom astroid.bases import Instance, _infer_stmts\nfrom astroid.const import _EMPTY_OBJECT_MARKER, Context\nfrom astroid.context import CallContext, InferenceContext, copy_context\nfrom astroid.exceptions import (\n    AstroidBuildingError,\n    AstroidError,\n    AstroidIndexError,\n    AstroidTypeError,\n    AstroidValueError,\n    AttributeInferenceError,\n    InferenceError,\n    NameInferenceError,\n    NoDefault,\n    ParentMissingError,\n    _NonDeducibleTypeHierarchy,\n)\nfrom astroid.interpreter import dunder_lookup\nfrom astroid.manager import AstroidManager\nfrom astroid.nodes import _base_nodes\nfrom astroid.nodes.const import OP_PRECEDENCE\nfrom astroid.nodes.node_ng import NodeNG\nfrom astroid.nodes.scoped_nodes import SYNTHETIC_ROOT\nfrom astroid.typing import (\n    ConstFactoryResult,\n    InferenceErrorInfo,\n    InferenceResult,\n    SuccessfulInferenceResult,\n)\n\nif sys.version_info >= (3, 11):\n    from typing import Self\nelse:\n    from typing_extensions import Self\n\nif TYPE_CHECKING:\n    from astroid import nodes\n    from astroid.nodes import LocalsDictNodeNG\n\n\ndef _is_const(value) -> bool:\n    return isinstance(value, tuple(CONST_CLS))\n\n\n_NodesT = typing.TypeVar(\"_NodesT\", bound=NodeNG)\n_BadOpMessageT = typing.TypeVar(\"_BadOpMessageT\", bound=util.BadOperationMessage)\n\nAssignedStmtsPossibleNode = Union[\"List\", \"Tuple\", \"AssignName\", \"AssignAttr\", None]\nAssignedStmtsCall = Callable[\n    [\n        _NodesT,\n        AssignedStmtsPossibleNode,\n        Optional[InferenceContext],\n        Optional[list[int]],\n    ],\n    Any,\n]\nInferBinaryOperation = Callable[\n    [_NodesT, Optional[InferenceContext]],\n    Generator[Union[InferenceResult, _BadOpMessageT]],\n]\nInferLHS = Callable[\n    [_NodesT, Optional[InferenceContext]],\n    Generator[InferenceResult, None, Optional[InferenceErrorInfo]],\n]\nInferUnaryOp = Callable[[_NodesT, str], ConstFactoryResult]\n\n\n@decorators.raise_if_nothing_inferred\ndef unpack_infer(stmt, context: InferenceContext | None = None):\n    \"\"\"recursively generate nodes inferred by the given statement.\n    If the inferred value is a list or a tuple, recurse on the elements\n    \"\"\"\n    if isinstance(stmt, (List, Tuple)):\n        for elt in stmt.elts:\n            if elt is util.Uninferable:\n                yield elt\n                continue\n            yield from unpack_infer(elt, context)\n        return {\"node\": stmt, \"context\": context}\n    # if inferred is a final node, return it and stop\n    inferred = next(stmt.infer(context), util.Uninferable)\n    if inferred is stmt:\n        yield inferred\n        return {\"node\": stmt, \"context\": context}\n    # else, infer recursively, except Uninferable object that should be returned as is\n    for inferred in stmt.infer(context):\n        if isinstance(inferred, util.UninferableBase):\n            yield inferred\n        else:\n            yield from unpack_infer(inferred, context)\n\n    return {\"node\": stmt, \"context\": context}\n\n\ndef are_exclusive(stmt1, stmt2, exceptions: list[str] | None = None) -> bool:\n    \"\"\"return true if the two given statements are mutually exclusive\n\n    `exceptions` may be a list of exception names. If specified, discard If\n    branches and check one of the statement is in an exception handler catching\n    one of the given exceptions.\n\n    algorithm :\n     1) index stmt1's parents\n     2) climb among stmt2's parents until we find a common parent\n     3) if the common parent is a If or Try statement, look if nodes are\n        in exclusive branches\n    \"\"\"\n    # index stmt1's parents\n    stmt1_parents = {}\n    children = {}\n    previous = stmt1\n    for node in stmt1.node_ancestors():\n        stmt1_parents[node] = 1\n        children[node] = previous\n        previous = node\n    # climb among stmt2's parents until we find a common parent\n    previous = stmt2\n    for node in stmt2.node_ancestors():\n        if node in stmt1_parents:\n            # if the common parent is a If or Try statement, look if\n            # nodes are in exclusive branches\n            if isinstance(node, If) and exceptions is None:\n                c2attr, c2node = node.locate_child(previous)\n                c1attr, c1node = node.locate_child(children[node])\n                if \"test\" in (c1attr, c2attr):\n                    # If any node is `If.test`, then it must be inclusive with\n                    # the other node (`If.body` and `If.orelse`)\n                    return False\n                if c1attr != c2attr:\n                    # different `If` branches (`If.body` and `If.orelse`)\n                    return True\n            elif isinstance(node, Try):\n                c2attr, c2node = node.locate_child(previous)\n                c1attr, c1node = node.locate_child(children[node])\n                if c1node is not c2node:\n                    first_in_body_caught_by_handlers = (\n                        c2attr == \"handlers\"\n                        and c1attr == \"body\"\n                        and previous.catch(exceptions)\n                    )\n                    second_in_body_caught_by_handlers = (\n                        c2attr == \"body\"\n                        and c1attr == \"handlers\"\n                        and children[node].catch(exceptions)\n                    )\n                    first_in_else_other_in_handlers = (\n                        c2attr == \"handlers\" and c1attr == \"orelse\"\n                    )\n                    second_in_else_other_in_handlers = (\n                        c2attr == \"orelse\" and c1attr == \"handlers\"\n                    )\n                    if any(\n                        (\n                            first_in_body_caught_by_handlers,\n                            second_in_body_caught_by_handlers,\n                            first_in_else_other_in_handlers,\n                            second_in_else_other_in_handlers,\n                        )\n                    ):\n                        return True\n                elif c2attr == \"handlers\" and c1attr == \"handlers\":\n                    return previous is not children[node]\n            return False\n        previous = node\n    return False\n\n\n# getitem() helpers.\n\n_SLICE_SENTINEL = object()\n\n\ndef _slice_value(index, context: InferenceContext | None = None):\n    \"\"\"Get the value of the given slice index.\"\"\"\n\n    if isinstance(index, Const):\n        if isinstance(index.value, (int, type(None))):\n            return index.value\n    elif index is None:\n        return None\n    else:\n        # Try to infer what the index actually is.\n        # Since we can't return all the possible values,\n        # we'll stop at the first possible value.\n        try:\n            inferred = next(index.infer(context=context))\n        except (InferenceError, StopIteration):\n            pass\n        else:\n            if isinstance(inferred, Const):\n                if isinstance(inferred.value, (int, type(None))):\n                    return inferred.value\n\n    # Use a sentinel, because None can be a valid\n    # value that this function can return,\n    # as it is the case for unspecified bounds.\n    return _SLICE_SENTINEL\n\n\ndef _infer_slice(node, context: InferenceContext | None = None):\n    lower = _slice_value(node.lower, context)\n    upper = _slice_value(node.upper, context)\n    step = _slice_value(node.step, context)\n    if all(elem is not _SLICE_SENTINEL for elem in (lower, upper, step)):\n        return slice(lower, upper, step)\n\n    raise AstroidTypeError(\n        message=\"Could not infer slice used in subscript\",\n        node=node,\n        index=node.parent,\n        context=context,\n    )\n\n\ndef _container_getitem(instance, elts, index, context: InferenceContext | None = None):\n    \"\"\"Get a slice or an item, using the given *index*, for the given sequence.\"\"\"\n    try:\n        if isinstance(index, Slice):\n            index_slice = _infer_slice(index, context=context)\n            new_cls = instance.__class__()\n            new_cls.elts = elts[index_slice]\n            new_cls.parent = instance.parent\n            return new_cls\n        if isinstance(index, Const):\n            return elts[index.value]\n    except ValueError as exc:\n        raise AstroidValueError(\n            message=\"Slice {index!r} cannot index container\",\n            node=instance,\n            index=index,\n            context=context,\n        ) from exc\n    except IndexError as exc:\n        raise AstroidIndexError(\n            message=\"Index {index!s} out of range\",\n            node=instance,\n            index=index,\n            context=context,\n        ) from exc\n    except TypeError as exc:\n        raise AstroidTypeError(\n            message=\"Type error {error!r}\", node=instance, index=index, context=context\n        ) from exc\n\n    raise AstroidTypeError(f\"Could not use {index} as subscript index\")\n\n\nclass BaseContainer(_base_nodes.ParentAssignNode, Instance, metaclass=abc.ABCMeta):\n    \"\"\"Base class for Set, FrozenSet, Tuple and List.\"\"\"\n\n    _astroid_fields = (\"elts\",)\n\n    def __init__(\n        self,\n        lineno: int | None,\n        col_offset: int | None,\n        parent: NodeNG | None,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.elts: list[SuccessfulInferenceResult] = []\n        \"\"\"The elements in the node.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, elts: list[SuccessfulInferenceResult]) -> None:\n        self.elts = elts\n\n    @classmethod\n    def from_elements(cls, elts: Iterable[Any]) -> Self:\n        \"\"\"Create a node of this type from the given list of elements.\n\n        :param elts: The list of elements that the node should contain.\n\n        :returns: A new node containing the given elements.\n        \"\"\"\n        node = cls(\n            lineno=None,\n            col_offset=None,\n            parent=None,\n            end_lineno=None,\n            end_col_offset=None,\n        )\n        node.elts = [const_factory(e) if _is_const(e) else e for e in elts]\n        return node\n\n    def itered(self):\n        \"\"\"An iterator over the elements this node contains.\n\n        :returns: The contents of this node.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        return self.elts\n\n    def bool_value(self, context: InferenceContext | None = None) -> bool:\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n        \"\"\"\n        return bool(self.elts)\n\n    @abc.abstractmethod\n    def pytype(self) -> str:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n\n    def get_children(self):\n        yield from self.elts\n\n    @decorators.raise_if_nothing_inferred\n    def _infer(\n        self,\n        context: InferenceContext | None = None,\n        **kwargs: Any,\n    ) -> Iterator[Self]:\n        has_starred_named_expr = any(\n            isinstance(e, (Starred, NamedExpr)) for e in self.elts\n        )\n        if has_starred_named_expr:\n            values = self._infer_sequence_helper(context)\n            new_seq = type(self)(\n                lineno=self.lineno,\n                col_offset=self.col_offset,\n                parent=self.parent,\n                end_lineno=self.end_lineno,\n                end_col_offset=self.end_col_offset,\n            )\n            new_seq.postinit(values)\n\n            yield new_seq\n        else:\n            yield self\n\n    def _infer_sequence_helper(\n        self, context: InferenceContext | None = None\n    ) -> list[SuccessfulInferenceResult]:\n        \"\"\"Infer all values based on BaseContainer.elts.\"\"\"\n        values = []\n\n        for elt in self.elts:\n            if isinstance(elt, Starred):\n                starred = util.safe_infer(elt.value, context)\n                if not starred:\n                    raise InferenceError(node=self, context=context)\n                if not hasattr(starred, \"elts\"):\n                    raise InferenceError(node=self, context=context)\n                # TODO: fresh context?\n                values.extend(starred._infer_sequence_helper(context))\n            elif isinstance(elt, NamedExpr):\n                value = util.safe_infer(elt.value, context)\n                if not value:\n                    raise InferenceError(node=self, context=context)\n                values.append(value)\n            else:\n                values.append(elt)\n        return values\n\n\n# Name classes\n\n\nclass AssignName(\n    _base_nodes.NoChildrenNode,\n    _base_nodes.LookupMixIn,\n    _base_nodes.ParentAssignNode,\n):\n    \"\"\"Variation of :class:`ast.Assign` representing assignment to a name.\n\n    An :class:`AssignName` is the name of something that is assigned to.\n    This includes variables defined in a function signature or in a loop.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('variable = range(10)')\n    >>> node\n    <Assign l.1 at 0x7effe1db8550>\n    >>> list(node.get_children())\n    [<AssignName.variable l.1 at 0x7effe1db8748>, <Call l.1 at 0x7effe1db8630>]\n    >>> list(node.get_children())[0].as_string()\n    'variable'\n    \"\"\"\n\n    _other_fields = (\"name\",)\n\n    def __init__(\n        self,\n        name: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.name = name\n        \"\"\"The name that is assigned to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    assigned_stmts = protocols.assend_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Infer an AssignName: need to inspect the RHS part of the\n        assign node.\n        \"\"\"\n        if isinstance(self.parent, AugAssign):\n            return self.parent.infer(context)\n\n        stmts = list(self.assigned_stmts(context=context))\n        return _infer_stmts(stmts, context)\n\n    @decorators.raise_if_nothing_inferred\n    def infer_lhs(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Infer a Name: use name lookup rules.\n\n        Same implementation as Name._infer.\"\"\"\n        # pylint: disable=import-outside-toplevel\n        from astroid.constraint import get_constraints\n        from astroid.helpers import _higher_function_scope\n\n        frame, stmts = self.lookup(self.name)\n        if not stmts:\n            # Try to see if the name is enclosed in a nested function\n            # and use the higher (first function) scope for searching.\n            parent_function = _higher_function_scope(self.scope())\n            if parent_function:\n                _, stmts = parent_function.lookup(self.name)\n\n            if not stmts:\n                raise NameInferenceError(\n                    name=self.name, scope=self.scope(), context=context\n                )\n        context = copy_context(context)\n        context.lookupname = self.name\n        context.constraints[self.name] = get_constraints(self, frame)\n\n        return _infer_stmts(stmts, context, frame)\n\n\nclass DelName(\n    _base_nodes.NoChildrenNode, _base_nodes.LookupMixIn, _base_nodes.ParentAssignNode\n):\n    \"\"\"Variation of :class:`ast.Delete` representing deletion of a name.\n\n    A :class:`DelName` is the name of something that is deleted.\n\n    >>> import astroid\n    >>> node = astroid.extract_node(\"del variable #@\")\n    >>> list(node.get_children())\n    [<DelName.variable l.1 at 0x7effe1da4d30>]\n    >>> list(node.get_children())[0].as_string()\n    'variable'\n    \"\"\"\n\n    _other_fields = (\"name\",)\n\n    def __init__(\n        self,\n        name: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.name = name\n        \"\"\"The name that is being deleted.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n\nclass Name(_base_nodes.LookupMixIn, _base_nodes.NoChildrenNode):\n    \"\"\"Class representing an :class:`ast.Name` node.\n\n    A :class:`Name` node is something that is named, but not covered by\n    :class:`AssignName` or :class:`DelName`.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('range(10)')\n    >>> node\n    <Call l.1 at 0x7effe1db8710>\n    >>> list(node.get_children())\n    [<Name.range l.1 at 0x7effe1db86a0>, <Const.int l.1 at 0x7effe1db8518>]\n    >>> list(node.get_children())[0].as_string()\n    'range'\n    \"\"\"\n\n    _other_fields = (\"name\",)\n\n    def __init__(\n        self,\n        name: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.name = name\n        \"\"\"The name that this node refers to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def _get_name_nodes(self):\n        yield self\n\n        for child_node in self.get_children():\n            yield from child_node._get_name_nodes()\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Infer a Name: use name lookup rules\n\n        Same implementation as AssignName._infer_lhs.\"\"\"\n        # pylint: disable=import-outside-toplevel\n        from astroid.constraint import get_constraints\n        from astroid.helpers import _higher_function_scope\n\n        frame, stmts = self.lookup(self.name)\n        if not stmts:\n            # Try to see if the name is enclosed in a nested function\n            # and use the higher (first function) scope for searching.\n            parent_function = _higher_function_scope(self.scope())\n            if parent_function:\n                _, stmts = parent_function.lookup(self.name)\n\n            if not stmts:\n                raise NameInferenceError(\n                    name=self.name, scope=self.scope(), context=context\n                )\n        context = copy_context(context)\n        context.lookupname = self.name\n        context.constraints[self.name] = get_constraints(self, frame)\n\n        return _infer_stmts(stmts, context, frame)\n\n\nDEPRECATED_ARGUMENT_DEFAULT = \"DEPRECATED_ARGUMENT_DEFAULT\"\n\n\nclass Arguments(\n    _base_nodes.AssignTypeNode\n):  # pylint: disable=too-many-instance-attributes\n    \"\"\"Class representing an :class:`ast.arguments` node.\n\n    An :class:`Arguments` node represents that arguments in a\n    function definition.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('def foo(bar): pass')\n    >>> node\n    <FunctionDef.foo l.1 at 0x7effe1db8198>\n    >>> node.args\n    <Arguments l.1 at 0x7effe1db82e8>\n    \"\"\"\n\n    # Python 3.4+ uses a different approach regarding annotations,\n    # each argument is a new class, _ast.arg, which exposes an\n    # 'annotation' attribute. In astroid though, arguments are exposed\n    # as is in the Arguments node and the only way to expose annotations\n    # is by using something similar with Python 3.3:\n    #  - we expose 'varargannotation' and 'kwargannotation' of annotations\n    #    of varargs and kwargs.\n    #  - we expose 'annotation', a list with annotations for\n    #    for each normal argument. If an argument doesn't have an\n    #    annotation, its value will be None.\n    _astroid_fields = (\n        \"args\",\n        \"defaults\",\n        \"kwonlyargs\",\n        \"posonlyargs\",\n        \"posonlyargs_annotations\",\n        \"kw_defaults\",\n        \"annotations\",\n        \"varargannotation\",\n        \"kwargannotation\",\n        \"kwonlyargs_annotations\",\n        \"type_comment_args\",\n        \"type_comment_kwonlyargs\",\n        \"type_comment_posonlyargs\",\n    )\n\n    _other_fields = (\"vararg\", \"kwarg\")\n\n    args: list[AssignName] | None\n    \"\"\"The names of the required arguments.\n\n    Can be None if the associated function does not have a retrievable\n    signature and the arguments are therefore unknown.\n    This can happen with (builtin) functions implemented in C that have\n    incomplete signature information.\n    \"\"\"\n\n    defaults: list[NodeNG] | None\n    \"\"\"The default values for arguments that can be passed positionally.\"\"\"\n\n    kwonlyargs: list[AssignName]\n    \"\"\"The keyword arguments that cannot be passed positionally.\"\"\"\n\n    posonlyargs: list[AssignName]\n    \"\"\"The arguments that can only be passed positionally.\"\"\"\n\n    kw_defaults: list[NodeNG | None] | None\n    \"\"\"The default values for keyword arguments that cannot be passed positionally.\"\"\"\n\n    annotations: list[NodeNG | None]\n    \"\"\"The type annotations of arguments that can be passed positionally.\"\"\"\n\n    posonlyargs_annotations: list[NodeNG | None]\n    \"\"\"The type annotations of arguments that can only be passed positionally.\"\"\"\n\n    kwonlyargs_annotations: list[NodeNG | None]\n    \"\"\"The type annotations of arguments that cannot be passed positionally.\"\"\"\n\n    type_comment_args: list[NodeNG | None]\n    \"\"\"The type annotation, passed by a type comment, of each argument.\n\n    If an argument does not have a type comment,\n    the value for that argument will be None.\n    \"\"\"\n\n    type_comment_kwonlyargs: list[NodeNG | None]\n    \"\"\"The type annotation, passed by a type comment, of each keyword only argument.\n\n    If an argument does not have a type comment,\n    the value for that argument will be None.\n    \"\"\"\n\n    type_comment_posonlyargs: list[NodeNG | None]\n    \"\"\"The type annotation, passed by a type comment, of each positional argument.\n\n    If an argument does not have a type comment,\n    the value for that argument will be None.\n    \"\"\"\n\n    varargannotation: NodeNG | None\n    \"\"\"The type annotation for the variable length arguments.\"\"\"\n\n    kwargannotation: NodeNG | None\n    \"\"\"The type annotation for the variable length keyword arguments.\"\"\"\n\n    vararg_node: AssignName | None\n    \"\"\"The node for variable length arguments\"\"\"\n\n    kwarg_node: AssignName | None\n    \"\"\"The node for variable keyword arguments\"\"\"\n\n    def __init__(\n        self,\n        vararg: str | None,\n        kwarg: str | None,\n        parent: NodeNG,\n        vararg_node: AssignName | None = None,\n        kwarg_node: AssignName | None = None,\n    ) -> None:\n        \"\"\"Almost all attributes can be None for living objects where introspection failed.\"\"\"\n        super().__init__(\n            parent=parent,\n            lineno=None,\n            col_offset=None,\n            end_lineno=None,\n            end_col_offset=None,\n        )\n\n        self.vararg = vararg\n        \"\"\"The name of the variable length arguments.\"\"\"\n\n        self.kwarg = kwarg\n        \"\"\"The name of the variable length keyword arguments.\"\"\"\n\n        self.vararg_node = vararg_node\n        self.kwarg_node = kwarg_node\n\n    # pylint: disable=too-many-arguments, too-many-positional-arguments\n    def postinit(\n        self,\n        args: list[AssignName] | None,\n        defaults: list[NodeNG] | None,\n        kwonlyargs: list[AssignName],\n        kw_defaults: list[NodeNG | None] | None,\n        annotations: list[NodeNG | None],\n        posonlyargs: list[AssignName],\n        kwonlyargs_annotations: list[NodeNG | None],\n        posonlyargs_annotations: list[NodeNG | None],\n        varargannotation: NodeNG | None = None,\n        kwargannotation: NodeNG | None = None,\n        type_comment_args: list[NodeNG | None] | None = None,\n        type_comment_kwonlyargs: list[NodeNG | None] | None = None,\n        type_comment_posonlyargs: list[NodeNG | None] | None = None,\n    ) -> None:\n        self.args = args\n        self.defaults = defaults\n        self.kwonlyargs = kwonlyargs\n        self.posonlyargs = posonlyargs\n        self.kw_defaults = kw_defaults\n        self.annotations = annotations\n        self.kwonlyargs_annotations = kwonlyargs_annotations\n        self.posonlyargs_annotations = posonlyargs_annotations\n\n        # Parameters that got added later and need a default\n        self.varargannotation = varargannotation\n        self.kwargannotation = kwargannotation\n        if type_comment_args is None:\n            type_comment_args = []\n        self.type_comment_args = type_comment_args\n        if type_comment_kwonlyargs is None:\n            type_comment_kwonlyargs = []\n        self.type_comment_kwonlyargs = type_comment_kwonlyargs\n        if type_comment_posonlyargs is None:\n            type_comment_posonlyargs = []\n        self.type_comment_posonlyargs = type_comment_posonlyargs\n\n    assigned_stmts = protocols.arguments_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def _infer_name(self, frame, name):\n        if self.parent is frame:\n            return name\n        return None\n\n    @cached_property\n    def fromlineno(self) -> int:\n        \"\"\"The first line that this node appears on in the source code.\n\n        Can also return 0 if the line can not be determined.\n        \"\"\"\n        lineno = super().fromlineno\n        return max(lineno, self.parent.fromlineno or 0)\n\n    @cached_property\n    def arguments(self):\n        \"\"\"Get all the arguments for this node. This includes:\n        * Positional only arguments\n        * Positional arguments\n        * Keyword arguments\n        * Variable arguments (.e.g *args)\n        * Variable keyword arguments (e.g **kwargs)\n        \"\"\"\n        retval = list(itertools.chain((self.posonlyargs or ()), (self.args or ())))\n        if self.vararg_node:\n            retval.append(self.vararg_node)\n        retval += self.kwonlyargs or ()\n        if self.kwarg_node:\n            retval.append(self.kwarg_node)\n\n        return retval\n\n    def format_args(self, *, skippable_names: set[str] | None = None) -> str:\n        \"\"\"Get the arguments formatted as string.\n\n        :returns: The formatted arguments.\n        :rtype: str\n        \"\"\"\n        result = []\n        positional_only_defaults = []\n        positional_or_keyword_defaults = self.defaults\n        if self.defaults:\n            args = self.args or []\n            positional_or_keyword_defaults = self.defaults[-len(args) :]\n            positional_only_defaults = self.defaults[: len(self.defaults) - len(args)]\n\n        if self.posonlyargs:\n            result.append(\n                _format_args(\n                    self.posonlyargs,\n                    positional_only_defaults,\n                    self.posonlyargs_annotations,\n                    skippable_names=skippable_names,\n                )\n            )\n            result.append(\"/\")\n        if self.args:\n            result.append(\n                _format_args(\n                    self.args,\n                    positional_or_keyword_defaults,\n                    getattr(self, \"annotations\", None),\n                    skippable_names=skippable_names,\n                )\n            )\n        if self.vararg:\n            result.append(f\"*{self.vararg}\")\n        if self.kwonlyargs:\n            if not self.vararg:\n                result.append(\"*\")\n            result.append(\n                _format_args(\n                    self.kwonlyargs,\n                    self.kw_defaults,\n                    self.kwonlyargs_annotations,\n                    skippable_names=skippable_names,\n                )\n            )\n        if self.kwarg:\n            result.append(f\"**{self.kwarg}\")\n        return \", \".join(result)\n\n    def _get_arguments_data(\n        self,\n    ) -> tuple[\n        dict[str, tuple[str | None, str | None]],\n        dict[str, tuple[str | None, str | None]],\n    ]:\n        \"\"\"Get the arguments as dictionary with information about typing and defaults.\n\n        The return tuple contains a dictionary for positional and keyword arguments with their typing\n        and their default value, if any.\n        The method follows a similar order as format_args but instead of formatting into a string it\n        returns the data that is used to do so.\n        \"\"\"\n        pos_only: dict[str, tuple[str | None, str | None]] = {}\n        kw_only: dict[str, tuple[str | None, str | None]] = {}\n\n        # Setup and match defaults with arguments\n        positional_only_defaults = []\n        positional_or_keyword_defaults = self.defaults\n        if self.defaults:\n            args = self.args or []\n            positional_or_keyword_defaults = self.defaults[-len(args) :]\n            positional_only_defaults = self.defaults[: len(self.defaults) - len(args)]\n\n        for index, posonly in enumerate(self.posonlyargs):\n            annotation, default = self.posonlyargs_annotations[index], None\n            if annotation is not None:\n                annotation = annotation.as_string()\n            if positional_only_defaults:\n                default = positional_only_defaults[index].as_string()\n            pos_only[posonly.name] = (annotation, default)\n\n        for index, arg in enumerate(self.args):\n            annotation, default = self.annotations[index], None\n            if annotation is not None:\n                annotation = annotation.as_string()\n            if positional_or_keyword_defaults:\n                defaults_offset = len(self.args) - len(positional_or_keyword_defaults)\n                default_index = index - defaults_offset\n                if (\n                    default_index > -1\n                    and positional_or_keyword_defaults[default_index] is not None\n                ):\n                    default = positional_or_keyword_defaults[default_index].as_string()\n            pos_only[arg.name] = (annotation, default)\n\n        if self.vararg:\n            annotation = self.varargannotation\n            if annotation is not None:\n                annotation = annotation.as_string()\n            pos_only[self.vararg] = (annotation, None)\n\n        for index, kwarg in enumerate(self.kwonlyargs):\n            annotation = self.kwonlyargs_annotations[index]\n            if annotation is not None:\n                annotation = annotation.as_string()\n            default = self.kw_defaults[index]\n            if default is not None:\n                default = default.as_string()\n            kw_only[kwarg.name] = (annotation, default)\n\n        if self.kwarg:\n            annotation = self.kwargannotation\n            if annotation is not None:\n                annotation = annotation.as_string()\n            kw_only[self.kwarg] = (annotation, None)\n\n        return pos_only, kw_only\n\n    def default_value(self, argname):\n        \"\"\"Get the default value for an argument.\n\n        :param argname: The name of the argument to get the default value for.\n        :type argname: str\n\n        :raises NoDefault: If there is no default value defined for the\n            given argument.\n        \"\"\"\n        args = [\n            arg for arg in self.arguments if arg.name not in [self.vararg, self.kwarg]\n        ]\n\n        index = _find_arg(argname, self.kwonlyargs)[0]\n        if (index is not None) and (len(self.kw_defaults) > index):\n            if self.kw_defaults[index] is not None:\n                return self.kw_defaults[index]\n            raise NoDefault(func=self.parent, name=argname)\n\n        index = _find_arg(argname, args)[0]\n        if index is not None:\n            idx = index - (len(args) - len(self.defaults) - len(self.kw_defaults))\n            if idx >= 0:\n                return self.defaults[idx]\n\n        raise NoDefault(func=self.parent, name=argname)\n\n    def is_argument(self, name) -> bool:\n        \"\"\"Check if the given name is defined in the arguments.\n\n        :param name: The name to check for.\n        :type name: str\n\n        :returns: Whether the given name is defined in the arguments,\n        \"\"\"\n        if name == self.vararg:\n            return True\n        if name == self.kwarg:\n            return True\n        return self.find_argname(name)[1] is not None\n\n    def find_argname(self, argname, rec=DEPRECATED_ARGUMENT_DEFAULT):\n        \"\"\"Get the index and :class:`AssignName` node for given name.\n\n        :param argname: The name of the argument to search for.\n        :type argname: str\n\n        :returns: The index and node for the argument.\n        :rtype: tuple(str or None, AssignName or None)\n        \"\"\"\n        if rec != DEPRECATED_ARGUMENT_DEFAULT:  # pragma: no cover\n            warnings.warn(\n                \"The rec argument will be removed in astroid 3.1.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        if self.arguments:\n            index, argument = _find_arg(argname, self.arguments)\n            if argument:\n                return index, argument\n        return None, None\n\n    def get_children(self):\n        yield from self.posonlyargs or ()\n\n        for elt in self.posonlyargs_annotations:\n            if elt is not None:\n                yield elt\n\n        yield from self.args or ()\n\n        if self.defaults is not None:\n            yield from self.defaults\n        yield from self.kwonlyargs\n\n        for elt in self.kw_defaults or ():\n            if elt is not None:\n                yield elt\n\n        for elt in self.annotations:\n            if elt is not None:\n                yield elt\n\n        if self.varargannotation is not None:\n            yield self.varargannotation\n\n        if self.kwargannotation is not None:\n            yield self.kwargannotation\n\n        for elt in self.kwonlyargs_annotations:\n            if elt is not None:\n                yield elt\n\n    @decorators.raise_if_nothing_inferred\n    def _infer(\n        self: nodes.Arguments, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        # pylint: disable-next=import-outside-toplevel\n        from astroid.protocols import _arguments_infer_argname\n\n        if context is None or context.lookupname is None:\n            raise InferenceError(node=self, context=context)\n        return _arguments_infer_argname(self, context.lookupname, context)\n\n\ndef _find_arg(argname, args):\n    for i, arg in enumerate(args):\n        if arg.name == argname:\n            return i, arg\n    return None, None\n\n\ndef _format_args(\n    args, defaults=None, annotations=None, skippable_names: set[str] | None = None\n) -> str:\n    if skippable_names is None:\n        skippable_names = set()\n    values = []\n    if args is None:\n        return \"\"\n    if annotations is None:\n        annotations = []\n    if defaults is not None:\n        default_offset = len(args) - len(defaults)\n    else:\n        default_offset = None\n    packed = itertools.zip_longest(args, annotations)\n    for i, (arg, annotation) in enumerate(packed):\n        if arg.name in skippable_names:\n            continue\n        if isinstance(arg, Tuple):\n            values.append(f\"({_format_args(arg.elts)})\")\n        else:\n            argname = arg.name\n            default_sep = \"=\"\n            if annotation is not None:\n                argname += \": \" + annotation.as_string()\n                default_sep = \" = \"\n            values.append(argname)\n\n            if default_offset is not None and i >= default_offset:\n                if defaults[i - default_offset] is not None:\n                    values[-1] += default_sep + defaults[i - default_offset].as_string()\n    return \", \".join(values)\n\n\ndef _infer_attribute(\n    node: nodes.AssignAttr | nodes.Attribute,\n    context: InferenceContext | None = None,\n    **kwargs: Any,\n) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n    \"\"\"Infer an AssignAttr/Attribute node by using getattr on the associated object.\"\"\"\n    # pylint: disable=import-outside-toplevel\n    from astroid.constraint import get_constraints\n    from astroid.nodes import ClassDef\n\n    for owner in node.expr.infer(context):\n        if isinstance(owner, util.UninferableBase):\n            yield owner\n            continue\n\n        context = copy_context(context)\n        old_boundnode = context.boundnode\n        try:\n            context.boundnode = owner\n            if isinstance(owner, (ClassDef, Instance)):\n                frame = owner if isinstance(owner, ClassDef) else owner._proxied\n                context.constraints[node.attrname] = get_constraints(node, frame=frame)\n            if node.attrname == \"argv\" and owner.name == \"sys\":\n                # sys.argv will never be inferable during static analysis\n                # It's value would be the args passed to the linter itself\n                yield util.Uninferable\n            else:\n                yield from owner.igetattr(node.attrname, context)\n        except (\n            AttributeInferenceError,\n            InferenceError,\n            AttributeError,\n        ):\n            pass\n        finally:\n            context.boundnode = old_boundnode\n    return InferenceErrorInfo(node=node, context=context)\n\n\nclass AssignAttr(_base_nodes.LookupMixIn, _base_nodes.ParentAssignNode):\n    \"\"\"Variation of :class:`ast.Assign` representing assignment to an attribute.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('self.attribute = range(10)')\n    >>> node\n    <Assign l.1 at 0x7effe1d521d0>\n    >>> list(node.get_children())\n    [<AssignAttr.attribute l.1 at 0x7effe1d52320>, <Call l.1 at 0x7effe1d522e8>]\n    >>> list(node.get_children())[0].as_string()\n    'self.attribute'\n    \"\"\"\n\n    expr: NodeNG\n\n    _astroid_fields = (\"expr\",)\n    _other_fields = (\"attrname\",)\n\n    def __init__(\n        self,\n        attrname: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.attrname = attrname\n        \"\"\"The name of the attribute being assigned to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, expr: NodeNG) -> None:\n        self.expr = expr\n\n    assigned_stmts = protocols.assend_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def get_children(self):\n        yield self.expr\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Infer an AssignAttr: need to inspect the RHS part of the\n        assign node.\n        \"\"\"\n        if isinstance(self.parent, AugAssign):\n            return self.parent.infer(context)\n\n        stmts = list(self.assigned_stmts(context=context))\n        return _infer_stmts(stmts, context)\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def infer_lhs(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        return _infer_attribute(self, context, **kwargs)\n\n\nclass Assert(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Assert` node.\n\n    An :class:`Assert` node represents an assert statement.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('assert len(things) == 10, \"Not enough things\"')\n    >>> node\n    <Assert l.1 at 0x7effe1d527b8>\n    \"\"\"\n\n    _astroid_fields = (\"test\", \"fail\")\n\n    test: NodeNG\n    \"\"\"The test that passes or fails the assertion.\"\"\"\n\n    fail: NodeNG | None\n    \"\"\"The message shown when the assertion fails.\"\"\"\n\n    def postinit(self, test: NodeNG, fail: NodeNG | None) -> None:\n        self.fail = fail\n        self.test = test\n\n    def get_children(self):\n        yield self.test\n\n        if self.fail is not None:\n            yield self.fail\n\n\nclass Assign(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Assign` node.\n\n    An :class:`Assign` is a statement where something is explicitly\n    asssigned to.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('variable = range(10)')\n    >>> node\n    <Assign l.1 at 0x7effe1db8550>\n    \"\"\"\n\n    targets: list[NodeNG]\n    \"\"\"What is being assigned to.\"\"\"\n\n    value: NodeNG\n    \"\"\"The value being assigned to the variables.\"\"\"\n\n    type_annotation: NodeNG | None\n    \"\"\"If present, this will contain the type annotation passed by a type comment\"\"\"\n\n    _astroid_fields = (\"targets\", \"value\")\n    _other_other_fields = (\"type_annotation\",)\n\n    def postinit(\n        self,\n        targets: list[NodeNG],\n        value: NodeNG,\n        type_annotation: NodeNG | None,\n    ) -> None:\n        self.targets = targets\n        self.value = value\n        self.type_annotation = type_annotation\n\n    assigned_stmts = protocols.assign_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def get_children(self):\n        yield from self.targets\n\n        yield self.value\n\n    @cached_property\n    def _assign_nodes_in_scope(self) -> list[nodes.Assign]:\n        return [self, *self.value._assign_nodes_in_scope]\n\n    def _get_yield_nodes_skip_functions(self):\n        yield from self.value._get_yield_nodes_skip_functions()\n\n    def _get_yield_nodes_skip_lambdas(self):\n        yield from self.value._get_yield_nodes_skip_lambdas()\n\n\nclass AnnAssign(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.AnnAssign` node.\n\n    An :class:`AnnAssign` is an assignment with a type annotation.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('variable: List[int] = range(10)')\n    >>> node\n    <AnnAssign l.1 at 0x7effe1d4c630>\n    \"\"\"\n\n    _astroid_fields = (\"target\", \"annotation\", \"value\")\n    _other_fields = (\"simple\",)\n\n    target: Name | Attribute | Subscript\n    \"\"\"What is being assigned to.\"\"\"\n\n    annotation: NodeNG\n    \"\"\"The type annotation of what is being assigned to.\"\"\"\n\n    value: NodeNG | None\n    \"\"\"The value being assigned to the variables.\"\"\"\n\n    simple: int\n    \"\"\"Whether :attr:`target` is a pure name or a complex statement.\"\"\"\n\n    def postinit(\n        self,\n        target: Name | Attribute | Subscript,\n        annotation: NodeNG,\n        simple: int,\n        value: NodeNG | None,\n    ) -> None:\n        self.target = target\n        self.annotation = annotation\n        self.value = value\n        self.simple = simple\n\n    assigned_stmts = protocols.assign_annassigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def get_children(self):\n        yield self.target\n        yield self.annotation\n\n        if self.value is not None:\n            yield self.value\n\n\nclass AugAssign(\n    _base_nodes.AssignTypeNode, _base_nodes.OperatorNode, _base_nodes.Statement\n):\n    \"\"\"Class representing an :class:`ast.AugAssign` node.\n\n    An :class:`AugAssign` is an assignment paired with an operator.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('variable += 1')\n    >>> node\n    <AugAssign l.1 at 0x7effe1db4d68>\n    \"\"\"\n\n    _astroid_fields = (\"target\", \"value\")\n    _other_fields = (\"op\",)\n\n    target: Name | Attribute | Subscript\n    \"\"\"What is being assigned to.\"\"\"\n\n    value: NodeNG\n    \"\"\"The value being assigned to the variable.\"\"\"\n\n    def __init__(\n        self,\n        op: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.op = op\n        \"\"\"The operator that is being combined with the assignment.\n\n        This includes the equals sign.\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, target: Name | Attribute | Subscript, value: NodeNG) -> None:\n        self.target = target\n        self.value = value\n\n    assigned_stmts = protocols.assign_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def type_errors(\n        self, context: InferenceContext | None = None\n    ) -> list[util.BadBinaryOperationMessage]:\n        \"\"\"Get a list of type errors which can occur during inference.\n\n        Each TypeError is represented by a :class:`BadBinaryOperationMessage` ,\n        which holds the original exception.\n\n        If any inferred result is uninferable, an empty list is returned.\n        \"\"\"\n        bad = []\n        try:\n            for result in self._infer_augassign(context=context):\n                if result is util.Uninferable:\n                    raise InferenceError\n                if isinstance(result, util.BadBinaryOperationMessage):\n                    bad.append(result)\n        except InferenceError:\n            return []\n        return bad\n\n    def get_children(self):\n        yield self.target\n        yield self.value\n\n    def _get_yield_nodes_skip_functions(self):\n        \"\"\"An AugAssign node can contain a Yield node in the value\"\"\"\n        yield from self.value._get_yield_nodes_skip_functions()\n        yield from super()._get_yield_nodes_skip_functions()\n\n    def _get_yield_nodes_skip_lambdas(self):\n        \"\"\"An AugAssign node can contain a Yield node in the value\"\"\"\n        yield from self.value._get_yield_nodes_skip_lambdas()\n        yield from super()._get_yield_nodes_skip_lambdas()\n\n    def _infer_augassign(\n        self, context: InferenceContext | None = None\n    ) -> Generator[InferenceResult | util.BadBinaryOperationMessage]:\n        \"\"\"Inference logic for augmented binary operations.\"\"\"\n        context = context or InferenceContext()\n\n        rhs_context = context.clone()\n\n        lhs_iter = self.target.infer_lhs(context=context)\n        rhs_iter = self.value.infer(context=rhs_context)\n\n        for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n            if any(isinstance(value, util.UninferableBase) for value in (rhs, lhs)):\n                # Don't know how to process this.\n                yield util.Uninferable\n                return\n\n            try:\n                yield from self._infer_binary_operation(\n                    left=lhs,\n                    right=rhs,\n                    binary_opnode=self,\n                    context=context,\n                    flow_factory=self._get_aug_flow,\n                )\n            except _NonDeducibleTypeHierarchy:\n                yield util.Uninferable\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self: nodes.AugAssign, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        return self._filter_operation_errors(\n            self._infer_augassign, context, util.BadBinaryOperationMessage\n        )\n\n\nclass BinOp(_base_nodes.OperatorNode):\n    \"\"\"Class representing an :class:`ast.BinOp` node.\n\n    A :class:`BinOp` node is an application of a binary operator.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('a + b')\n    >>> node\n    <BinOp l.1 at 0x7f23b2e8cfd0>\n    \"\"\"\n\n    _astroid_fields = (\"left\", \"right\")\n    _other_fields = (\"op\",)\n\n    left: NodeNG\n    \"\"\"What is being applied to the operator on the left side.\"\"\"\n\n    right: NodeNG\n    \"\"\"What is being applied to the operator on the right side.\"\"\"\n\n    def __init__(\n        self,\n        op: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.op = op\n        \"\"\"The operator.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, left: NodeNG, right: NodeNG) -> None:\n        self.left = left\n        self.right = right\n\n    def type_errors(\n        self, context: InferenceContext | None = None\n    ) -> list[util.BadBinaryOperationMessage]:\n        \"\"\"Get a list of type errors which can occur during inference.\n\n        Each TypeError is represented by a :class:`BadBinaryOperationMessage`,\n        which holds the original exception.\n\n        If any inferred result is uninferable, an empty list is returned.\n        \"\"\"\n        bad = []\n        try:\n            for result in self._infer_binop(context=context):\n                if result is util.Uninferable:\n                    raise InferenceError\n                if isinstance(result, util.BadBinaryOperationMessage):\n                    bad.append(result)\n        except InferenceError:\n            return []\n        return bad\n\n    def get_children(self):\n        yield self.left\n        yield self.right\n\n    def op_precedence(self) -> int:\n        return OP_PRECEDENCE[self.op]\n\n    def op_left_associative(self) -> bool:\n        # 2**3**4 == 2**(3**4)\n        return self.op != \"**\"\n\n    def _infer_binop(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        \"\"\"Binary operation inference logic.\"\"\"\n        left = self.left\n        right = self.right\n\n        # we use two separate contexts for evaluating lhs and rhs because\n        # 1. evaluating lhs may leave some undesired entries in context.path\n        #    which may not let us infer right value of rhs\n        context = context or InferenceContext()\n        lhs_context = copy_context(context)\n        rhs_context = copy_context(context)\n        lhs_iter = left.infer(context=lhs_context)\n        rhs_iter = right.infer(context=rhs_context)\n        for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n            if any(isinstance(value, util.UninferableBase) for value in (rhs, lhs)):\n                # Don't know how to process this.\n                yield util.Uninferable\n                return\n\n            try:\n                yield from self._infer_binary_operation(\n                    lhs, rhs, self, context, self._get_binop_flow\n                )\n            except _NonDeducibleTypeHierarchy:\n                yield util.Uninferable\n\n    @decorators.yes_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self: nodes.BinOp, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        return self._filter_operation_errors(\n            self._infer_binop, context, util.BadBinaryOperationMessage\n        )\n\n\nclass BoolOp(NodeNG):\n    \"\"\"Class representing an :class:`ast.BoolOp` node.\n\n    A :class:`BoolOp` is an application of a boolean operator.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('a and b')\n    >>> node\n    <BinOp l.1 at 0x7f23b2e71c50>\n    \"\"\"\n\n    _astroid_fields = (\"values\",)\n    _other_fields = (\"op\",)\n\n    def __init__(\n        self,\n        op: str,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param op: The operator.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.op: str = op\n        \"\"\"The operator.\"\"\"\n\n        self.values: list[NodeNG] = []\n        \"\"\"The values being applied to the operator.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, values: list[NodeNG] | None = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param values: The values being applied to the operator.\n        \"\"\"\n        if values is not None:\n            self.values = values\n\n    def get_children(self):\n        yield from self.values\n\n    def op_precedence(self) -> int:\n        return OP_PRECEDENCE[self.op]\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self: nodes.BoolOp, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Infer a boolean operation (and / or / not).\n\n        The function will calculate the boolean operation\n        for all pairs generated through inference for each component\n        node.\n        \"\"\"\n        values = self.values\n        if self.op == \"or\":\n            predicate = operator.truth\n        else:\n            predicate = operator.not_\n\n        try:\n            inferred_values = [value.infer(context=context) for value in values]\n        except InferenceError:\n            yield util.Uninferable\n            return None\n\n        for pair in itertools.product(*inferred_values):\n            if any(isinstance(item, util.UninferableBase) for item in pair):\n                # Can't infer the final result, just yield Uninferable.\n                yield util.Uninferable\n                continue\n\n            bool_values = [item.bool_value() for item in pair]\n            if any(isinstance(item, util.UninferableBase) for item in bool_values):\n                # Can't infer the final result, just yield Uninferable.\n                yield util.Uninferable\n                continue\n\n            # Since the boolean operations are short circuited operations,\n            # this code yields the first value for which the predicate is True\n            # and if no value respected the predicate, then the last value will\n            # be returned (or Uninferable if there was no last value).\n            # This is conforming to the semantics of `and` and `or`:\n            #   1 and 0 -> 1\n            #   0 and 1 -> 0\n            #   1 or 0 -> 1\n            #   0 or 1 -> 1\n            value = util.Uninferable\n            for value, bool_value in zip(pair, bool_values):\n                if predicate(bool_value):\n                    yield value\n                    break\n            else:\n                yield value\n\n        return InferenceErrorInfo(node=self, context=context)\n\n\nclass Break(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Break` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('break')\n    >>> node\n    <Break l.1 at 0x7f23b2e9e5c0>\n    \"\"\"\n\n\nclass Call(NodeNG):\n    \"\"\"Class representing an :class:`ast.Call` node.\n\n    A :class:`Call` node is a call to a function, method, etc.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('function()')\n    >>> node\n    <Call l.1 at 0x7f23b2e71eb8>\n    \"\"\"\n\n    _astroid_fields = (\"func\", \"args\", \"keywords\")\n\n    func: NodeNG\n    \"\"\"What is being called.\"\"\"\n\n    args: list[NodeNG]\n    \"\"\"The positional arguments being given to the call.\"\"\"\n\n    keywords: list[Keyword]\n    \"\"\"The keyword arguments being given to the call.\"\"\"\n\n    def postinit(\n        self, func: NodeNG, args: list[NodeNG], keywords: list[Keyword]\n    ) -> None:\n        self.func = func\n        self.args = args\n        self.keywords = keywords\n\n    @property\n    def starargs(self) -> list[Starred]:\n        \"\"\"The positional arguments that unpack something.\"\"\"\n        return [arg for arg in self.args if isinstance(arg, Starred)]\n\n    @property\n    def kwargs(self) -> list[Keyword]:\n        \"\"\"The keyword arguments that unpack something.\"\"\"\n        return [keyword for keyword in self.keywords if keyword.arg is None]\n\n    def get_children(self):\n        yield self.func\n\n        yield from self.args\n\n        yield from self.keywords\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n        \"\"\"Infer a Call node by trying to guess what the function returns.\"\"\"\n        callcontext = copy_context(context)\n        callcontext.boundnode = None\n        if context is not None:\n            callcontext.extra_context = self._populate_context_lookup(context.clone())\n\n        for callee in self.func.infer(context):\n            if isinstance(callee, util.UninferableBase):\n                yield callee\n                continue\n            try:\n                if hasattr(callee, \"infer_call_result\"):\n                    callcontext.callcontext = CallContext(\n                        args=self.args, keywords=self.keywords, callee=callee\n                    )\n                    yield from callee.infer_call_result(\n                        caller=self, context=callcontext\n                    )\n            except InferenceError:\n                continue\n        return InferenceErrorInfo(node=self, context=context)\n\n    def _populate_context_lookup(self, context: InferenceContext | None):\n        \"\"\"Allows context to be saved for later for inference inside a function.\"\"\"\n        context_lookup: dict[InferenceResult, InferenceContext] = {}\n        if context is None:\n            return context_lookup\n        for arg in self.args:\n            if isinstance(arg, Starred):\n                context_lookup[arg.value] = context\n            else:\n                context_lookup[arg] = context\n        keywords = self.keywords if self.keywords is not None else []\n        for keyword in keywords:\n            context_lookup[keyword.value] = context\n        return context_lookup\n\n\nCOMPARE_OPS: dict[str, Callable[[Any, Any], bool]] = {\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \">\": operator.gt,\n    \">=\": operator.ge,\n    \"in\": lambda a, b: a in b,\n    \"not in\": lambda a, b: a not in b,\n}\nUNINFERABLE_OPS = {\n    \"is\",\n    \"is not\",\n}\n\n\nclass Compare(NodeNG):\n    \"\"\"Class representing an :class:`ast.Compare` node.\n\n    A :class:`Compare` node indicates a comparison.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('a <= b <= c')\n    >>> node\n    <Compare l.1 at 0x7f23b2e9e6d8>\n    >>> node.ops\n    [('<=', <Name.b l.1 at 0x7f23b2e9e2b0>), ('<=', <Name.c l.1 at 0x7f23b2e9e390>)]\n    \"\"\"\n\n    _astroid_fields = (\"left\", \"ops\")\n\n    left: NodeNG\n    \"\"\"The value at the left being applied to a comparison operator.\"\"\"\n\n    ops: list[tuple[str, NodeNG]]\n    \"\"\"The remainder of the operators and their relevant right hand value.\"\"\"\n\n    def postinit(self, left: NodeNG, ops: list[tuple[str, NodeNG]]) -> None:\n        self.left = left\n        self.ops = ops\n\n    def get_children(self):\n        \"\"\"Get the child nodes below this node.\n\n        Overridden to handle the tuple fields and skip returning the operator\n        strings.\n\n        :returns: The children.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        yield self.left\n        for _, comparator in self.ops:\n            yield comparator  # we don't want the 'op'\n\n    def last_child(self):\n        \"\"\"An optimized version of list(get_children())[-1]\n\n        :returns: The last child.\n        :rtype: NodeNG\n        \"\"\"\n        # XXX maybe if self.ops:\n        return self.ops[-1][1]\n        # return self.left\n\n    # TODO: move to util?\n    @staticmethod\n    def _to_literal(node: SuccessfulInferenceResult) -> Any:\n        # Can raise SyntaxError or ValueError from ast.literal_eval\n        # Can raise AttributeError from node.as_string() as not all nodes have a visitor\n        # Is this the stupidest idea or the simplest idea?\n        return ast.literal_eval(node.as_string())\n\n    def _do_compare(\n        self,\n        left_iter: Iterable[InferenceResult],\n        op: str,\n        right_iter: Iterable[InferenceResult],\n    ) -> bool | util.UninferableBase:\n        \"\"\"\n        If all possible combinations are either True or False, return that:\n        >>> _do_compare([1, 2], '<=', [3, 4])\n        True\n        >>> _do_compare([1, 2], '==', [3, 4])\n        False\n\n        If any item is uninferable, or if some combinations are True and some\n        are False, return Uninferable:\n        >>> _do_compare([1, 3], '<=', [2, 4])\n        util.Uninferable\n        \"\"\"\n        retval: bool | None = None\n        if op in UNINFERABLE_OPS:\n            return util.Uninferable\n        op_func = COMPARE_OPS[op]\n\n        for left, right in itertools.product(left_iter, right_iter):\n            if isinstance(left, util.UninferableBase) or isinstance(\n                right, util.UninferableBase\n            ):\n                return util.Uninferable\n\n            try:\n                left, right = self._to_literal(left), self._to_literal(right)\n            except (SyntaxError, ValueError, AttributeError):\n                return util.Uninferable\n\n            try:\n                expr = op_func(left, right)\n            except TypeError as exc:\n                raise AstroidTypeError from exc\n\n            if retval is None:\n                retval = expr\n            elif retval != expr:\n                return util.Uninferable\n                # (or both, but \"True | False\" is basically the same)\n\n        assert retval is not None\n        return retval  # it was all the same value\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[nodes.Const | util.UninferableBase]:\n        \"\"\"Chained comparison inference logic.\"\"\"\n        retval: bool | util.UninferableBase = True\n\n        ops = self.ops\n        left_node = self.left\n        lhs = list(left_node.infer(context=context))\n        # should we break early if first element is uninferable?\n        for op, right_node in ops:\n            # eagerly evaluate rhs so that values can be re-used as lhs\n            rhs = list(right_node.infer(context=context))\n            try:\n                retval = self._do_compare(lhs, op, rhs)\n            except AstroidTypeError:\n                retval = util.Uninferable\n                break\n            if retval is not True:\n                break  # short-circuit\n            lhs = rhs  # continue\n        if retval is util.Uninferable:\n            yield retval  # type: ignore[misc]\n        else:\n            yield Const(retval)\n\n\nclass Comprehension(NodeNG):\n    \"\"\"Class representing an :class:`ast.comprehension` node.\n\n    A :class:`Comprehension` indicates the loop inside any type of\n    comprehension including generator expressions.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('[x for x in some_values]')\n    >>> list(node.get_children())\n    [<Name.x l.1 at 0x7f23b2e352b0>, <Comprehension l.1 at 0x7f23b2e35320>]\n    >>> list(node.get_children())[1].as_string()\n    'for x in some_values'\n    \"\"\"\n\n    _astroid_fields = (\"target\", \"iter\", \"ifs\")\n    _other_fields = (\"is_async\",)\n\n    optional_assign = True\n    \"\"\"Whether this node optionally assigns a variable.\"\"\"\n\n    target: NodeNG\n    \"\"\"What is assigned to by the comprehension.\"\"\"\n\n    iter: NodeNG\n    \"\"\"What is iterated over by the comprehension.\"\"\"\n\n    ifs: list[NodeNG]\n    \"\"\"The contents of any if statements that filter the comprehension.\"\"\"\n\n    is_async: bool\n    \"\"\"Whether this is an asynchronous comprehension or not.\"\"\"\n\n    def postinit(\n        self,\n        target: NodeNG,\n        iter: NodeNG,  # pylint: disable = redefined-builtin\n        ifs: list[NodeNG],\n        is_async: bool,\n    ) -> None:\n        self.target = target\n        self.iter = iter\n        self.ifs = ifs\n        self.is_async = is_async\n\n    assigned_stmts = protocols.for_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def assign_type(self):\n        \"\"\"The type of assignment that this node performs.\n\n        :returns: The assignment type.\n        :rtype: NodeNG\n        \"\"\"\n        return self\n\n    def _get_filtered_stmts(\n        self, lookup_node, node, stmts, mystmt: _base_nodes.Statement | None\n    ):\n        \"\"\"method used in filter_stmts\"\"\"\n        if self is mystmt:\n            if isinstance(lookup_node, (Const, Name)):\n                return [lookup_node], True\n\n        elif self.statement() is mystmt:\n            # original node's statement is the assignment, only keeps\n            # current node (gen exp, list comp)\n\n            return [node], True\n\n        return stmts, False\n\n    def get_children(self):\n        yield self.target\n        yield self.iter\n\n        yield from self.ifs\n\n\nclass Const(_base_nodes.NoChildrenNode, Instance):\n    \"\"\"Class representing any constant including num, str, bool, None, bytes.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('(5, \"This is a string.\", True, None, b\"bytes\")')\n    >>> node\n    <Tuple.tuple l.1 at 0x7f23b2e358d0>\n    >>> list(node.get_children())\n    [<Const.int l.1 at 0x7f23b2e35940>,\n    <Const.str l.1 at 0x7f23b2e35978>,\n    <Const.bool l.1 at 0x7f23b2e359b0>,\n    <Const.NoneType l.1 at 0x7f23b2e359e8>,\n    <Const.bytes l.1 at 0x7f23b2e35a20>]\n    \"\"\"\n\n    _other_fields = (\"value\", \"kind\")\n\n    def __init__(\n        self,\n        value: Any,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG = SYNTHETIC_ROOT,\n        kind: str | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param value: The value that the constant represents.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param kind: The string prefix. \"u\" for u-prefixed strings and ``None`` otherwise. Python 3.8+ only.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        if getattr(value, \"__name__\", None) == \"__doc__\":\n            warnings.warn(  # pragma: no cover\n                \"You have most likely called a __doc__ field of some object \"\n                \"and it didn't return a string. \"\n                \"That happens to some symbols from the standard library. \"\n                \"Check for isinstance(<X>.__doc__, str).\",\n                RuntimeWarning,\n                stacklevel=0,\n            )\n        self.value = value\n        \"\"\"The value that the constant represents.\"\"\"\n\n        self.kind: str | None = kind  # can be None\n        \"\"\"\"The string prefix. \"u\" for u-prefixed strings and ``None`` otherwise. Python 3.8+ only.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n        Instance.__init__(self, None)\n\n    infer_unary_op = protocols.const_infer_unary_op\n    infer_binary_op = protocols.const_infer_binary_op\n\n    def __getattr__(self, name):\n        # This is needed because of Proxy's __getattr__ method.\n        # Calling object.__new__ on this class without calling\n        # __init__ would result in an infinite loop otherwise\n        # since __getattr__ is called when an attribute doesn't\n        # exist and self._proxied indirectly calls self.value\n        # and Proxy __getattr__ calls self.value\n        if name == \"value\":\n            raise AttributeError\n        return super().__getattr__(name)\n\n    def getitem(self, index, context: InferenceContext | None = None):\n        \"\"\"Get an item from this node if subscriptable.\n\n        :param index: The node to use as a subscript index.\n        :type index: Const or Slice\n\n        :raises AstroidTypeError: When the given index cannot be used as a\n            subscript index, or if this node is not subscriptable.\n        \"\"\"\n        if isinstance(index, Const):\n            index_value = index.value\n        elif isinstance(index, Slice):\n            index_value = _infer_slice(index, context=context)\n\n        else:\n            raise AstroidTypeError(\n                f\"Could not use type {type(index)} as subscript index\"\n            )\n\n        try:\n            if isinstance(self.value, (str, bytes)):\n                return Const(self.value[index_value])\n        except ValueError as exc:\n            raise AstroidValueError(\n                f\"Could not index {self.value!r} with {index_value!r}\"\n            ) from exc\n        except IndexError as exc:\n            raise AstroidIndexError(\n                message=\"Index {index!r} out of range\",\n                node=self,\n                index=index,\n                context=context,\n            ) from exc\n        except TypeError as exc:\n            raise AstroidTypeError(\n                message=\"Type error {error!r}\", node=self, index=index, context=context\n            ) from exc\n\n        raise AstroidTypeError(f\"{self!r} (value={self.value})\")\n\n    def has_dynamic_getattr(self) -> bool:\n        \"\"\"Check if the node has a custom __getattr__ or __getattribute__.\n\n        :returns: Whether the class has a custom __getattr__ or __getattribute__.\n            For a :class:`Const` this is always ``False``.\n        \"\"\"\n        return False\n\n    def itered(self):\n        \"\"\"An iterator over the elements this node contains.\n\n        :returns: The contents of this node.\n        :rtype: iterable(Const)\n\n        :raises TypeError: If this node does not represent something that is iterable.\n        \"\"\"\n        if isinstance(self.value, str):\n            return [const_factory(elem) for elem in self.value]\n        raise TypeError(f\"Cannot iterate over type {type(self.value)!r}\")\n\n    def pytype(self) -> str:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return self._proxied.qname()\n\n    def bool_value(self, context: InferenceContext | None = None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n        :rtype: bool\n        \"\"\"\n        return bool(self.value)\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[Const]:\n        yield self\n\n\nclass Continue(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Continue` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('continue')\n    >>> node\n    <Continue l.1 at 0x7f23b2e35588>\n    \"\"\"\n\n\nclass Decorators(NodeNG):\n    \"\"\"A node representing a list of decorators.\n\n    A :class:`Decorators` is the decorators that are applied to\n    a method or function.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    @property\n    def my_property(self):\n        return 3\n    ''')\n    >>> node\n    <FunctionDef.my_property l.2 at 0x7f23b2e35d30>\n    >>> list(node.get_children())[0]\n    <Decorators l.1 at 0x7f23b2e35d68>\n    \"\"\"\n\n    _astroid_fields = (\"nodes\",)\n\n    nodes: list[NodeNG]\n    \"\"\"The decorators that this node contains.\"\"\"\n\n    def postinit(self, nodes: list[NodeNG]) -> None:\n        self.nodes = nodes\n\n    def scope(self) -> LocalsDictNodeNG:\n        \"\"\"The first parent node defining a new scope.\n        These can be Module, FunctionDef, ClassDef, Lambda, or GeneratorExp nodes.\n\n        :returns: The first parent scope node.\n        \"\"\"\n        # skip the function node to go directly to the upper level scope\n        if not self.parent:\n            raise ParentMissingError(target=self)\n        if not self.parent.parent:\n            raise ParentMissingError(target=self.parent)\n        return self.parent.parent.scope()\n\n    def get_children(self):\n        yield from self.nodes\n\n\nclass DelAttr(_base_nodes.ParentAssignNode):\n    \"\"\"Variation of :class:`ast.Delete` representing deletion of an attribute.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('del self.attr')\n    >>> node\n    <Delete l.1 at 0x7f23b2e35f60>\n    >>> list(node.get_children())[0]\n    <DelAttr.attr l.1 at 0x7f23b2e411d0>\n    \"\"\"\n\n    _astroid_fields = (\"expr\",)\n    _other_fields = (\"attrname\",)\n\n    expr: NodeNG\n    \"\"\"The name that this node represents.\"\"\"\n\n    def __init__(\n        self,\n        attrname: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.attrname = attrname\n        \"\"\"The name of the attribute that is being deleted.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, expr: NodeNG) -> None:\n        self.expr = expr\n\n    def get_children(self):\n        yield self.expr\n\n\nclass Delete(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Delete` node.\n\n    A :class:`Delete` is a ``del`` statement this is deleting something.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('del self.attr')\n    >>> node\n    <Delete l.1 at 0x7f23b2e35f60>\n    \"\"\"\n\n    _astroid_fields = (\"targets\",)\n\n    def __init__(\n        self,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.targets: list[NodeNG] = []\n        \"\"\"What is being deleted.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, targets: list[NodeNG]) -> None:\n        self.targets = targets\n\n    def get_children(self):\n        yield from self.targets\n\n\nclass Dict(NodeNG, Instance):\n    \"\"\"Class representing an :class:`ast.Dict` node.\n\n    A :class:`Dict` is a dictionary that is created with ``{}`` syntax.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('{1: \"1\"}')\n    >>> node\n    <Dict.dict l.1 at 0x7f23b2e35cc0>\n    \"\"\"\n\n    _astroid_fields = (\"items\",)\n\n    def __init__(\n        self,\n        lineno: int | None,\n        col_offset: int | None,\n        parent: NodeNG | None,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.items: list[tuple[InferenceResult, InferenceResult]] = []\n        \"\"\"The key-value pairs contained in the dictionary.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, items: list[tuple[InferenceResult, InferenceResult]]) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param items: The key-value pairs contained in the dictionary.\n        \"\"\"\n        self.items = items\n\n    infer_unary_op = protocols.dict_infer_unary_op\n\n    def pytype(self) -> Literal[\"builtins.dict\"]:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return \"builtins.dict\"\n\n    def get_children(self):\n        \"\"\"Get the key and value nodes below this node.\n\n        Children are returned in the order that they are defined in the source\n        code, key first then the value.\n\n        :returns: The children.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        for key, value in self.items:\n            yield key\n            yield value\n\n    def last_child(self):\n        \"\"\"An optimized version of list(get_children())[-1]\n\n        :returns: The last child, or None if no children exist.\n        :rtype: NodeNG or None\n        \"\"\"\n        if self.items:\n            return self.items[-1][1]\n        return None\n\n    def itered(self):\n        \"\"\"An iterator over the keys this node contains.\n\n        :returns: The keys of this node.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        return [key for (key, _) in self.items]\n\n    def getitem(\n        self, index: Const | Slice, context: InferenceContext | None = None\n    ) -> NodeNG:\n        \"\"\"Get an item from this node.\n\n        :param index: The node to use as a subscript index.\n\n        :raises AstroidTypeError: When the given index cannot be used as a\n            subscript index, or if this node is not subscriptable.\n        :raises AstroidIndexError: If the given index does not exist in the\n            dictionary.\n        \"\"\"\n        for key, value in self.items:\n            # TODO(cpopa): no support for overriding yet, {1:2, **{1: 3}}.\n            if isinstance(key, DictUnpack):\n                inferred_value = util.safe_infer(value, context)\n                if not isinstance(inferred_value, Dict):\n                    continue\n\n                try:\n                    return inferred_value.getitem(index, context)\n                except (AstroidTypeError, AstroidIndexError):\n                    continue\n\n            for inferredkey in key.infer(context):\n                if isinstance(inferredkey, util.UninferableBase):\n                    continue\n                if isinstance(inferredkey, Const) and isinstance(index, Const):\n                    if inferredkey.value == index.value:\n                        return value\n\n        raise AstroidIndexError(index)\n\n    def bool_value(self, context: InferenceContext | None = None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n        :rtype: bool\n        \"\"\"\n        return bool(self.items)\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[nodes.Dict]:\n        if not any(isinstance(k, DictUnpack) for k, _ in self.items):\n            yield self\n        else:\n            items = self._infer_map(context)\n            new_seq = type(self)(\n                lineno=self.lineno,\n                col_offset=self.col_offset,\n                parent=self.parent,\n                end_lineno=self.end_lineno,\n                end_col_offset=self.end_col_offset,\n            )\n            new_seq.postinit(list(items.items()))\n            yield new_seq\n\n    @staticmethod\n    def _update_with_replacement(\n        lhs_dict: dict[SuccessfulInferenceResult, SuccessfulInferenceResult],\n        rhs_dict: dict[SuccessfulInferenceResult, SuccessfulInferenceResult],\n    ) -> dict[SuccessfulInferenceResult, SuccessfulInferenceResult]:\n        \"\"\"Delete nodes that equate to duplicate keys.\n\n        Since an astroid node doesn't 'equal' another node with the same value,\n        this function uses the as_string method to make sure duplicate keys\n        don't get through\n\n        Note that both the key and the value are astroid nodes\n\n        Fixes issue with DictUnpack causing duplicate keys\n        in inferred Dict items\n\n        :param lhs_dict: Dictionary to 'merge' nodes into\n        :param rhs_dict: Dictionary with nodes to pull from\n        :return : merged dictionary of nodes\n        \"\"\"\n        combined_dict = itertools.chain(lhs_dict.items(), rhs_dict.items())\n        # Overwrite keys which have the same string values\n        string_map = {key.as_string(): (key, value) for key, value in combined_dict}\n        # Return to dictionary\n        return dict(string_map.values())\n\n    def _infer_map(\n        self, context: InferenceContext | None\n    ) -> dict[SuccessfulInferenceResult, SuccessfulInferenceResult]:\n        \"\"\"Infer all values based on Dict.items.\"\"\"\n        values: dict[SuccessfulInferenceResult, SuccessfulInferenceResult] = {}\n        for name, value in self.items:\n            if isinstance(name, DictUnpack):\n                double_starred = util.safe_infer(value, context)\n                if not double_starred:\n                    raise InferenceError\n                if not isinstance(double_starred, Dict):\n                    raise InferenceError(node=self, context=context)\n                unpack_items = double_starred._infer_map(context)\n                values = self._update_with_replacement(values, unpack_items)\n            else:\n                key = util.safe_infer(name, context=context)\n                safe_value = util.safe_infer(value, context=context)\n                if any(not elem for elem in (key, safe_value)):\n                    raise InferenceError(node=self, context=context)\n                # safe_value is SuccessfulInferenceResult as bool(Uninferable) == False\n                values = self._update_with_replacement(values, {key: safe_value})\n        return values\n\n\nclass Expr(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Expr` node.\n\n    An :class:`Expr` is any expression that does not have its value used or\n    stored.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('method()')\n    >>> node\n    <Call l.1 at 0x7f23b2e352b0>\n    >>> node.parent\n    <Expr l.1 at 0x7f23b2e35278>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n\n    value: NodeNG\n    \"\"\"What the expression does.\"\"\"\n\n    def postinit(self, value: NodeNG) -> None:\n        self.value = value\n\n    def get_children(self):\n        yield self.value\n\n    def _get_yield_nodes_skip_functions(self):\n        if not self.value.is_function:\n            yield from self.value._get_yield_nodes_skip_functions()\n\n    def _get_yield_nodes_skip_lambdas(self):\n        if not self.value.is_lambda:\n            yield from self.value._get_yield_nodes_skip_lambdas()\n\n\nclass EmptyNode(_base_nodes.NoChildrenNode):\n    \"\"\"Holds an arbitrary object in the :attr:`LocalsDictNodeNG.locals`.\"\"\"\n\n    object = None\n\n    def __init__(\n        self,\n        lineno: None = None,\n        col_offset: None = None,\n        parent: NodeNG = SYNTHETIC_ROOT,\n        *,\n        end_lineno: None = None,\n        end_col_offset: None = None,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def has_underlying_object(self) -> bool:\n        return self.object is not None and self.object is not _EMPTY_OBJECT_MARKER\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        if not self.has_underlying_object():\n            yield util.Uninferable\n        else:\n            try:\n                yield from AstroidManager().infer_ast_from_something(\n                    self.object, context=context\n                )\n            except AstroidError:\n                yield util.Uninferable\n\n\nclass ExceptHandler(\n    _base_nodes.MultiLineBlockNode, _base_nodes.AssignTypeNode, _base_nodes.Statement\n):\n    \"\"\"Class representing an :class:`ast.ExceptHandler`. node.\n\n    An :class:`ExceptHandler` is an ``except`` block on a try-except.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n        try:\n            do_something()\n        except Exception as error:\n            print(\"Error!\")\n        ''')\n    >>> node\n    <Try l.2 at 0x7f23b2e9d908>\n    >>> node.handlers\n    [<ExceptHandler l.4 at 0x7f23b2e9e860>]\n    \"\"\"\n\n    _astroid_fields = (\"type\", \"name\", \"body\")\n    _multi_line_block_fields = (\"body\",)\n\n    type: NodeNG | None\n    \"\"\"The types that the block handles.\"\"\"\n\n    name: AssignName | None\n    \"\"\"The name that the caught exception is assigned to.\"\"\"\n\n    body: list[NodeNG]\n    \"\"\"The contents of the block.\"\"\"\n\n    assigned_stmts = protocols.excepthandler_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def postinit(\n        self,\n        type: NodeNG | None,  # pylint: disable = redefined-builtin\n        name: AssignName | None,\n        body: list[NodeNG],\n    ) -> None:\n        self.type = type\n        self.name = name\n        self.body = body\n\n    def get_children(self):\n        if self.type is not None:\n            yield self.type\n\n        if self.name is not None:\n            yield self.name\n\n        yield from self.body\n\n    @cached_property\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        if self.name:\n            return self.name.tolineno\n        if self.type:\n            return self.type.tolineno\n        return self.lineno\n\n    def catch(self, exceptions: list[str] | None) -> bool:\n        \"\"\"Check if this node handles any of the given\n\n        :param exceptions: The names of the exceptions to check for.\n        \"\"\"\n        if self.type is None or exceptions is None:\n            return True\n        return any(node.name in exceptions for node in self.type._get_name_nodes())\n\n\nclass For(\n    _base_nodes.MultiLineWithElseBlockNode,\n    _base_nodes.AssignTypeNode,\n    _base_nodes.Statement,\n):\n    \"\"\"Class representing an :class:`ast.For` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('for thing in things: print(thing)')\n    >>> node\n    <For l.1 at 0x7f23b2e8cf28>\n    \"\"\"\n\n    _astroid_fields = (\"target\", \"iter\", \"body\", \"orelse\")\n    _other_other_fields = (\"type_annotation\",)\n    _multi_line_block_fields = (\"body\", \"orelse\")\n\n    optional_assign = True\n    \"\"\"Whether this node optionally assigns a variable.\n\n    This is always ``True`` for :class:`For` nodes.\n    \"\"\"\n\n    target: NodeNG\n    \"\"\"What the loop assigns to.\"\"\"\n\n    iter: NodeNG\n    \"\"\"What the loop iterates over.\"\"\"\n\n    body: list[NodeNG]\n    \"\"\"The contents of the body of the loop.\"\"\"\n\n    orelse: list[NodeNG]\n    \"\"\"The contents of the ``else`` block of the loop.\"\"\"\n\n    type_annotation: NodeNG | None\n    \"\"\"If present, this will contain the type annotation passed by a type comment\"\"\"\n\n    def postinit(\n        self,\n        target: NodeNG,\n        iter: NodeNG,  # pylint: disable = redefined-builtin\n        body: list[NodeNG],\n        orelse: list[NodeNG],\n        type_annotation: NodeNG | None,\n    ) -> None:\n        self.target = target\n        self.iter = iter\n        self.body = body\n        self.orelse = orelse\n        self.type_annotation = type_annotation\n\n    assigned_stmts = protocols.for_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    @cached_property\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.iter.tolineno\n\n    def get_children(self):\n        yield self.target\n        yield self.iter\n\n        yield from self.body\n        yield from self.orelse\n\n\nclass AsyncFor(For):\n    \"\"\"Class representing an :class:`ast.AsyncFor` node.\n\n    An :class:`AsyncFor` is an asynchronous :class:`For` built with\n    the ``async`` keyword.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    async def func(things):\n        async for thing in things:\n            print(thing)\n    ''')\n    >>> node\n    <AsyncFunctionDef.func l.2 at 0x7f23b2e416d8>\n    >>> node.body[0]\n    <AsyncFor l.3 at 0x7f23b2e417b8>\n    \"\"\"\n\n\nclass Await(NodeNG):\n    \"\"\"Class representing an :class:`ast.Await` node.\n\n    An :class:`Await` is the ``await`` keyword.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    async def func(things):\n        await other_func()\n    ''')\n    >>> node\n    <AsyncFunctionDef.func l.2 at 0x7f23b2e41748>\n    >>> node.body[0]\n    <Expr l.3 at 0x7f23b2e419e8>\n    >>> list(node.body[0].get_children())[0]\n    <Await l.3 at 0x7f23b2e41a20>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n\n    value: NodeNG\n    \"\"\"What to wait for.\"\"\"\n\n    def postinit(self, value: NodeNG) -> None:\n        self.value = value\n\n    def get_children(self):\n        yield self.value\n\n\nclass ImportFrom(_base_nodes.ImportNode):\n    \"\"\"Class representing an :class:`ast.ImportFrom` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('from my_package import my_module')\n    >>> node\n    <ImportFrom l.1 at 0x7f23b2e415c0>\n    \"\"\"\n\n    _other_fields = (\"modname\", \"names\", \"level\")\n\n    def __init__(\n        self,\n        fromname: str | None,\n        names: list[tuple[str, str | None]],\n        level: int | None = 0,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param fromname: The module that is being imported from.\n\n        :param names: What is being imported from the module.\n\n        :param level: The level of relative import.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.modname: str | None = fromname  # can be None\n        \"\"\"The module that is being imported from.\n\n        This is ``None`` for relative imports.\n        \"\"\"\n\n        self.names: list[tuple[str, str | None]] = names\n        \"\"\"What is being imported from the module.\n\n        Each entry is a :class:`tuple` of the name being imported,\n        and the alias that the name is assigned to (if any).\n        \"\"\"\n\n        # TODO When is 'level' None?\n        self.level: int | None = level  # can be None\n        \"\"\"The level of relative import.\n\n        Essentially this is the number of dots in the import.\n        This is always 0 for absolute imports.\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self,\n        context: InferenceContext | None = None,\n        asname: bool = True,\n        **kwargs: Any,\n    ) -> Generator[InferenceResult]:\n        \"\"\"Infer a ImportFrom node: return the imported module/object.\"\"\"\n        context = context or InferenceContext()\n        name = context.lookupname\n        if name is None:\n            raise InferenceError(node=self, context=context)\n        if asname:\n            try:\n                name = self.real_name(name)\n            except AttributeInferenceError as exc:\n                # See https://github.com/pylint-dev/pylint/issues/4692\n                raise InferenceError(node=self, context=context) from exc\n        try:\n            module = self.do_import_module()\n        except AstroidBuildingError as exc:\n            raise InferenceError(node=self, context=context) from exc\n\n        try:\n            context = copy_context(context)\n            context.lookupname = name\n            stmts = module.getattr(name, ignore_locals=module is self.root())\n            return _infer_stmts(stmts, context)\n        except AttributeInferenceError as error:\n            raise InferenceError(\n                str(error), target=self, attribute=name, context=context\n            ) from error\n\n\nclass Attribute(NodeNG):\n    \"\"\"Class representing an :class:`ast.Attribute` node.\"\"\"\n\n    expr: NodeNG\n\n    _astroid_fields = (\"expr\",)\n    _other_fields = (\"attrname\",)\n\n    def __init__(\n        self,\n        attrname: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.attrname = attrname\n        \"\"\"The name of the attribute.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, expr: NodeNG) -> None:\n        self.expr = expr\n\n    def get_children(self):\n        yield self.expr\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n        return _infer_attribute(self, context, **kwargs)\n\n\nclass Global(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Global` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('global a_global')\n    >>> node\n    <Global l.1 at 0x7f23b2e9de10>\n    \"\"\"\n\n    _other_fields = (\"names\",)\n\n    def __init__(\n        self,\n        names: list[str],\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param names: The names being declared as global.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.names: list[str] = names\n        \"\"\"The names being declared as global.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def _infer_name(self, frame, name):\n        return name\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        if context is None or context.lookupname is None:\n            raise InferenceError(node=self, context=context)\n        try:\n            # pylint: disable-next=no-member\n            return _infer_stmts(self.root().getattr(context.lookupname), context)\n        except AttributeInferenceError as error:\n            raise InferenceError(\n                str(error), target=self, attribute=context.lookupname, context=context\n            ) from error\n\n\nclass If(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.If` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('if condition: print(True)')\n    >>> node\n    <If l.1 at 0x7f23b2e9dd30>\n    \"\"\"\n\n    _astroid_fields = (\"test\", \"body\", \"orelse\")\n    _multi_line_block_fields = (\"body\", \"orelse\")\n\n    test: NodeNG\n    \"\"\"The condition that the statement tests.\"\"\"\n\n    body: list[NodeNG]\n    \"\"\"The contents of the block.\"\"\"\n\n    orelse: list[NodeNG]\n    \"\"\"The contents of the ``else`` block.\"\"\"\n\n    def postinit(self, test: NodeNG, body: list[NodeNG], orelse: list[NodeNG]) -> None:\n        self.test = test\n        self.body = body\n        self.orelse = orelse\n\n    @cached_property\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.test.tolineno\n\n    def block_range(self, lineno: int) -> tuple[int, int]:\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: The line number to start the range at.\n\n        :returns: The range of line numbers that this node belongs to,\n            starting at the given line number.\n        \"\"\"\n        if lineno == self.body[0].fromlineno:\n            return lineno, lineno\n        if lineno <= self.body[-1].tolineno:\n            return lineno, self.body[-1].tolineno\n        return self._elsed_block_range(lineno, self.orelse, self.body[0].fromlineno - 1)\n\n    def get_children(self):\n        yield self.test\n\n        yield from self.body\n        yield from self.orelse\n\n    def has_elif_block(self) -> bool:\n        return len(self.orelse) == 1 and isinstance(self.orelse[0], If)\n\n    def _get_yield_nodes_skip_functions(self):\n        \"\"\"An If node can contain a Yield node in the test\"\"\"\n        yield from self.test._get_yield_nodes_skip_functions()\n        yield from super()._get_yield_nodes_skip_functions()\n\n    def _get_yield_nodes_skip_lambdas(self):\n        \"\"\"An If node can contain a Yield node in the test\"\"\"\n        yield from self.test._get_yield_nodes_skip_lambdas()\n        yield from super()._get_yield_nodes_skip_lambdas()\n\n\nclass IfExp(NodeNG):\n    \"\"\"Class representing an :class:`ast.IfExp` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('value if condition else other')\n    >>> node\n    <IfExp l.1 at 0x7f23b2e9dbe0>\n    \"\"\"\n\n    _astroid_fields = (\"test\", \"body\", \"orelse\")\n\n    test: NodeNG\n    \"\"\"The condition that the statement tests.\"\"\"\n\n    body: NodeNG\n    \"\"\"The contents of the block.\"\"\"\n\n    orelse: NodeNG\n    \"\"\"The contents of the ``else`` block.\"\"\"\n\n    def postinit(self, test: NodeNG, body: NodeNG, orelse: NodeNG) -> None:\n        self.test = test\n        self.body = body\n        self.orelse = orelse\n\n    def get_children(self):\n        yield self.test\n        yield self.body\n        yield self.orelse\n\n    def op_left_associative(self) -> Literal[False]:\n        # `1 if True else 2 if False else 3` is parsed as\n        # `1 if True else (2 if False else 3)`\n        return False\n\n    @decorators.raise_if_nothing_inferred\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        \"\"\"Support IfExp inference.\n\n        If we can't infer the truthiness of the condition, we default\n        to inferring both branches. Otherwise, we infer either branch\n        depending on the condition.\n        \"\"\"\n        both_branches = False\n        # We use two separate contexts for evaluating lhs and rhs because\n        # evaluating lhs may leave some undesired entries in context.path\n        # which may not let us infer right value of rhs.\n\n        context = context or InferenceContext()\n        lhs_context = copy_context(context)\n        rhs_context = copy_context(context)\n        try:\n            test = next(self.test.infer(context=context.clone()))\n        except (InferenceError, StopIteration):\n            both_branches = True\n        else:\n            if not isinstance(test, util.UninferableBase):\n                if test.bool_value():\n                    yield from self.body.infer(context=lhs_context)\n                else:\n                    yield from self.orelse.infer(context=rhs_context)\n            else:\n                both_branches = True\n        if both_branches:\n            yield from self.body.infer(context=lhs_context)\n            yield from self.orelse.infer(context=rhs_context)\n\n\nclass Import(_base_nodes.ImportNode):\n    \"\"\"Class representing an :class:`ast.Import` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('import astroid')\n    >>> node\n    <Import l.1 at 0x7f23b2e4e5c0>\n    \"\"\"\n\n    _other_fields = (\"names\",)\n\n    def __init__(\n        self,\n        names: list[tuple[str, str | None]],\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param names: The names being imported.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.names: list[tuple[str, str | None]] = names\n        \"\"\"The names being imported.\n\n        Each entry is a :class:`tuple` of the name being imported,\n        and the alias that the name is assigned to (if any).\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self,\n        context: InferenceContext | None = None,\n        asname: bool = True,\n        **kwargs: Any,\n    ) -> Generator[nodes.Module]:\n        \"\"\"Infer an Import node: return the imported module/object.\"\"\"\n        context = context or InferenceContext()\n        name = context.lookupname\n        if name is None:\n            raise InferenceError(node=self, context=context)\n\n        try:\n            if asname:\n                yield self.do_import_module(self.real_name(name))\n            else:\n                yield self.do_import_module(name)\n        except AstroidBuildingError as exc:\n            raise InferenceError(node=self, context=context) from exc\n\n\nclass Keyword(NodeNG):\n    \"\"\"Class representing an :class:`ast.keyword` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('function(a_kwarg=True)')\n    >>> node\n    <Call l.1 at 0x7f23b2e9e320>\n    >>> node.keywords\n    [<Keyword l.1 at 0x7f23b2e9e9b0>]\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n    _other_fields = (\"arg\",)\n\n    value: NodeNG\n    \"\"\"The value being assigned to the keyword argument.\"\"\"\n\n    def __init__(\n        self,\n        arg: str | None,\n        lineno: int | None,\n        col_offset: int | None,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.arg = arg\n        \"\"\"The argument being assigned to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, value: NodeNG) -> None:\n        self.value = value\n\n    def get_children(self):\n        yield self.value\n\n\nclass List(BaseContainer):\n    \"\"\"Class representing an :class:`ast.List` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('[1, 2, 3]')\n    >>> node\n    <List.list l.1 at 0x7f23b2e9e128>\n    \"\"\"\n\n    _other_fields = (\"ctx\",)\n\n    def __init__(\n        self,\n        ctx: Context | None = None,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param ctx: Whether the list is assigned to or loaded from.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.ctx: Context | None = ctx\n        \"\"\"Whether the list is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    assigned_stmts = protocols.sequence_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    infer_unary_op = protocols.list_infer_unary_op\n    infer_binary_op = protocols.tl_infer_binary_op\n\n    def pytype(self) -> Literal[\"builtins.list\"]:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return \"builtins.list\"\n\n    def getitem(self, index, context: InferenceContext | None = None):\n        \"\"\"Get an item from this node.\n\n        :param index: The node to use as a subscript index.\n        :type index: Const or Slice\n        \"\"\"\n        return _container_getitem(self, self.elts, index, context=context)\n\n\nclass Nonlocal(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Nonlocal` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    def function():\n        nonlocal var\n    ''')\n    >>> node\n    <FunctionDef.function l.2 at 0x7f23b2e9e208>\n    >>> node.body[0]\n    <Nonlocal l.3 at 0x7f23b2e9e908>\n    \"\"\"\n\n    _other_fields = (\"names\",)\n\n    def __init__(\n        self,\n        names: list[str],\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param names: The names being declared as not local.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.names: list[str] = names\n        \"\"\"The names being declared as not local.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def _infer_name(self, frame, name):\n        return name\n\n\nclass ParamSpec(_base_nodes.AssignTypeNode):\n    \"\"\"Class representing a :class:`ast.ParamSpec` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('type Alias[**P] = Callable[P, int]')\n    >>> node.type_params[0]\n    <ParamSpec l.1 at 0x7f23b2e4e198>\n    \"\"\"\n\n    _astroid_fields = (\"name\",)\n\n    name: AssignName\n\n    def __init__(\n        self,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int,\n        end_col_offset: int,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, name: AssignName) -> None:\n        self.name = name\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[ParamSpec]:\n        yield self\n\n    assigned_stmts = protocols.generic_type_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nclass Pass(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Pass` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('pass')\n    >>> node\n    <Pass l.1 at 0x7f23b2e9e748>\n    \"\"\"\n\n\nclass Raise(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Raise` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('raise RuntimeError(\"Something bad happened!\")')\n    >>> node\n    <Raise l.1 at 0x7f23b2e9e828>\n    \"\"\"\n\n    _astroid_fields = (\"exc\", \"cause\")\n\n    exc: NodeNG | None\n    \"\"\"What is being raised.\"\"\"\n\n    cause: NodeNG | None\n    \"\"\"The exception being used to raise this one.\"\"\"\n\n    def postinit(\n        self,\n        exc: NodeNG | None,\n        cause: NodeNG | None,\n    ) -> None:\n        self.exc = exc\n        self.cause = cause\n\n    def raises_not_implemented(self) -> bool:\n        \"\"\"Check if this node raises a :class:`NotImplementedError`.\n\n        :returns: Whether this node raises a :class:`NotImplementedError`.\n        \"\"\"\n        if not self.exc:\n            return False\n        return any(\n            name.name == \"NotImplementedError\" for name in self.exc._get_name_nodes()\n        )\n\n    def get_children(self):\n        if self.exc is not None:\n            yield self.exc\n\n        if self.cause is not None:\n            yield self.cause\n\n\nclass Return(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Return` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('return True')\n    >>> node\n    <Return l.1 at 0x7f23b8211908>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n\n    value: NodeNG | None\n    \"\"\"The value being returned.\"\"\"\n\n    def postinit(self, value: NodeNG | None) -> None:\n        self.value = value\n\n    def get_children(self):\n        if self.value is not None:\n            yield self.value\n\n    def is_tuple_return(self) -> bool:\n        return isinstance(self.value, Tuple)\n\n    def _get_return_nodes_skip_functions(self):\n        yield self\n\n\nclass Set(BaseContainer):\n    \"\"\"Class representing an :class:`ast.Set` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('{1, 2, 3}')\n    >>> node\n    <Set.set l.1 at 0x7f23b2e71d68>\n    \"\"\"\n\n    infer_unary_op = protocols.set_infer_unary_op\n\n    def pytype(self) -> Literal[\"builtins.set\"]:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return \"builtins.set\"\n\n\nclass Slice(NodeNG):\n    \"\"\"Class representing an :class:`ast.Slice` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('things[1:3]')\n    >>> node\n    <Subscript l.1 at 0x7f23b2e71f60>\n    >>> node.slice\n    <Slice l.1 at 0x7f23b2e71e80>\n    \"\"\"\n\n    _astroid_fields = (\"lower\", \"upper\", \"step\")\n\n    lower: NodeNG | None\n    \"\"\"The lower index in the slice.\"\"\"\n\n    upper: NodeNG | None\n    \"\"\"The upper index in the slice.\"\"\"\n\n    step: NodeNG | None\n    \"\"\"The step to take between indexes.\"\"\"\n\n    def postinit(\n        self,\n        lower: NodeNG | None,\n        upper: NodeNG | None,\n        step: NodeNG | None,\n    ) -> None:\n        self.lower = lower\n        self.upper = upper\n        self.step = step\n\n    def _wrap_attribute(self, attr):\n        \"\"\"Wrap the empty attributes of the Slice in a Const node.\"\"\"\n        if not attr:\n            const = const_factory(attr)\n            const.parent = self\n            return const\n        return attr\n\n    @cached_property\n    def _proxied(self) -> nodes.ClassDef:\n        builtins = AstroidManager().builtins_module\n        return builtins.getattr(\"slice\")[0]\n\n    def pytype(self) -> Literal[\"builtins.slice\"]:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return \"builtins.slice\"\n\n    def display_type(self) -> Literal[\"Slice\"]:\n        \"\"\"A human readable type of this node.\n\n        :returns: The type of this node.\n        \"\"\"\n        return \"Slice\"\n\n    def igetattr(\n        self, attrname: str, context: InferenceContext | None = None\n    ) -> Iterator[SuccessfulInferenceResult]:\n        \"\"\"Infer the possible values of the given attribute on the slice.\n\n        :param attrname: The name of the attribute to infer.\n\n        :returns: The inferred possible values.\n        \"\"\"\n        if attrname == \"start\":\n            yield self._wrap_attribute(self.lower)\n        elif attrname == \"stop\":\n            yield self._wrap_attribute(self.upper)\n        elif attrname == \"step\":\n            yield self._wrap_attribute(self.step)\n        else:\n            yield from self.getattr(attrname, context=context)\n\n    def getattr(self, attrname, context: InferenceContext | None = None):\n        return self._proxied.getattr(attrname, context)\n\n    def get_children(self):\n        if self.lower is not None:\n            yield self.lower\n\n        if self.upper is not None:\n            yield self.upper\n\n        if self.step is not None:\n            yield self.step\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[Slice]:\n        yield self\n\n\nclass Starred(_base_nodes.ParentAssignNode):\n    \"\"\"Class representing an :class:`ast.Starred` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('*args')\n    >>> node\n    <Starred l.1 at 0x7f23b2e41978>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n    _other_fields = (\"ctx\",)\n\n    value: NodeNG\n    \"\"\"What is being unpacked.\"\"\"\n\n    def __init__(\n        self,\n        ctx: Context,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.ctx = ctx\n        \"\"\"Whether the starred item is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, value: NodeNG) -> None:\n        self.value = value\n\n    assigned_stmts = protocols.starred_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def get_children(self):\n        yield self.value\n\n\nclass Subscript(NodeNG):\n    \"\"\"Class representing an :class:`ast.Subscript` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('things[1:3]')\n    >>> node\n    <Subscript l.1 at 0x7f23b2e71f60>\n    \"\"\"\n\n    _SUBSCRIPT_SENTINEL = object()\n    _astroid_fields = (\"value\", \"slice\")\n    _other_fields = (\"ctx\",)\n\n    value: NodeNG\n    \"\"\"What is being indexed.\"\"\"\n\n    slice: NodeNG\n    \"\"\"The slice being used to lookup.\"\"\"\n\n    def __init__(\n        self,\n        ctx: Context,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.ctx = ctx\n        \"\"\"Whether the subscripted item is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    # pylint: disable=redefined-builtin; had to use the same name as builtin ast module.\n    def postinit(self, value: NodeNG, slice: NodeNG) -> None:\n        self.value = value\n        self.slice = slice\n\n    def get_children(self):\n        yield self.value\n        yield self.slice\n\n    def _infer_subscript(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Inference for subscripts.\n\n        We're understanding if the index is a Const\n        or a slice, passing the result of inference\n        to the value's `getitem` method, which should\n        handle each supported index type accordingly.\n        \"\"\"\n        from astroid import helpers  # pylint: disable=import-outside-toplevel\n\n        found_one = False\n        for value in self.value.infer(context):\n            if isinstance(value, util.UninferableBase):\n                yield util.Uninferable\n                return None\n            for index in self.slice.infer(context):\n                if isinstance(index, util.UninferableBase):\n                    yield util.Uninferable\n                    return None\n\n                # Try to deduce the index value.\n                index_value = self._SUBSCRIPT_SENTINEL\n                if value.__class__ == Instance:\n                    index_value = index\n                elif index.__class__ == Instance:\n                    instance_as_index = helpers.class_instance_as_index(index)\n                    if instance_as_index:\n                        index_value = instance_as_index\n                else:\n                    index_value = index\n\n                if index_value is self._SUBSCRIPT_SENTINEL:\n                    raise InferenceError(node=self, context=context)\n\n                try:\n                    assigned = value.getitem(index_value, context)\n                except (\n                    AstroidTypeError,\n                    AstroidIndexError,\n                    AstroidValueError,\n                    AttributeInferenceError,\n                    AttributeError,\n                ) as exc:\n                    raise InferenceError(node=self, context=context) from exc\n\n                # Prevent inferring if the inferred subscript\n                # is the same as the original subscripted object.\n                if self is assigned or isinstance(assigned, util.UninferableBase):\n                    yield util.Uninferable\n                    return None\n                yield from assigned.infer(context)\n                found_one = True\n\n        if found_one:\n            return InferenceErrorInfo(node=self, context=context)\n        return None\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(self, context: InferenceContext | None = None, **kwargs: Any):\n        return self._infer_subscript(context, **kwargs)\n\n    @decorators.raise_if_nothing_inferred\n    def infer_lhs(self, context: InferenceContext | None = None, **kwargs: Any):\n        return self._infer_subscript(context, **kwargs)\n\n\nclass Try(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing a :class:`ast.Try` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n        try:\n            do_something()\n        except Exception as error:\n            print(\"Error!\")\n        finally:\n            print(\"Cleanup!\")\n        ''')\n    >>> node\n    <Try l.2 at 0x7f23b2e41d68>\n    \"\"\"\n\n    _astroid_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n    _multi_line_block_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n\n    def __init__(\n        self,\n        *,\n        lineno: int,\n        col_offset: int,\n        end_lineno: int,\n        end_col_offset: int,\n        parent: NodeNG,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.body: list[NodeNG] = []\n        \"\"\"The contents of the block to catch exceptions from.\"\"\"\n\n        self.handlers: list[ExceptHandler] = []\n        \"\"\"The exception handlers.\"\"\"\n\n        self.orelse: list[NodeNG] = []\n        \"\"\"The contents of the ``else`` block.\"\"\"\n\n        self.finalbody: list[NodeNG] = []\n        \"\"\"The contents of the ``finally`` block.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        body: list[NodeNG],\n        handlers: list[ExceptHandler],\n        orelse: list[NodeNG],\n        finalbody: list[NodeNG],\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param body: The contents of the block to catch exceptions from.\n\n        :param handlers: The exception handlers.\n\n        :param orelse: The contents of the ``else`` block.\n\n        :param finalbody: The contents of the ``finally`` block.\n        \"\"\"\n        self.body = body\n        self.handlers = handlers\n        self.orelse = orelse\n        self.finalbody = finalbody\n\n    def _infer_name(self, frame, name):\n        return name\n\n    def block_range(self, lineno: int) -> tuple[int, int]:\n        \"\"\"Get a range from a given line number to where this node ends.\"\"\"\n        if lineno == self.fromlineno:\n            return lineno, lineno\n        if self.body and self.body[0].fromlineno <= lineno <= self.body[-1].tolineno:\n            # Inside try body - return from lineno till end of try body\n            return lineno, self.body[-1].tolineno\n        for exhandler in self.handlers:\n            if exhandler.type and lineno == exhandler.type.fromlineno:\n                return lineno, lineno\n            if exhandler.body[0].fromlineno <= lineno <= exhandler.body[-1].tolineno:\n                return lineno, exhandler.body[-1].tolineno\n        if self.orelse:\n            if self.orelse[0].fromlineno - 1 == lineno:\n                return lineno, lineno\n            if self.orelse[0].fromlineno <= lineno <= self.orelse[-1].tolineno:\n                return lineno, self.orelse[-1].tolineno\n        if self.finalbody:\n            if self.finalbody[0].fromlineno - 1 == lineno:\n                return lineno, lineno\n            if self.finalbody[0].fromlineno <= lineno <= self.finalbody[-1].tolineno:\n                return lineno, self.finalbody[-1].tolineno\n        return lineno, self.tolineno\n\n    def get_children(self):\n        yield from self.body\n        yield from self.handlers\n        yield from self.orelse\n        yield from self.finalbody\n\n\nclass TryStar(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.TryStar` node.\"\"\"\n\n    _astroid_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n    _multi_line_block_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n\n    def __init__(\n        self,\n        *,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n        parent: NodeNG | None = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n        :param col_offset: The column that this node appears on in the\n            source code.\n        :param parent: The parent node in the syntax tree.\n        :param end_lineno: The last line this node appears on in the source code.\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.body: list[NodeNG] = []\n        \"\"\"The contents of the block to catch exceptions from.\"\"\"\n\n        self.handlers: list[ExceptHandler] = []\n        \"\"\"The exception handlers.\"\"\"\n\n        self.orelse: list[NodeNG] = []\n        \"\"\"The contents of the ``else`` block.\"\"\"\n\n        self.finalbody: list[NodeNG] = []\n        \"\"\"The contents of the ``finally`` block.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        body: list[NodeNG] | None = None,\n        handlers: list[ExceptHandler] | None = None,\n        orelse: list[NodeNG] | None = None,\n        finalbody: list[NodeNG] | None = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n        :param body: The contents of the block to catch exceptions from.\n        :param handlers: The exception handlers.\n        :param orelse: The contents of the ``else`` block.\n        :param finalbody: The contents of the ``finally`` block.\n        \"\"\"\n        if body:\n            self.body = body\n        if handlers:\n            self.handlers = handlers\n        if orelse:\n            self.orelse = orelse\n        if finalbody:\n            self.finalbody = finalbody\n\n    def _infer_name(self, frame, name):\n        return name\n\n    def block_range(self, lineno: int) -> tuple[int, int]:\n        \"\"\"Get a range from a given line number to where this node ends.\"\"\"\n        if lineno == self.fromlineno:\n            return lineno, lineno\n        if self.body and self.body[0].fromlineno <= lineno <= self.body[-1].tolineno:\n            # Inside try body - return from lineno till end of try body\n            return lineno, self.body[-1].tolineno\n        for exhandler in self.handlers:\n            if exhandler.type and lineno == exhandler.type.fromlineno:\n                return lineno, lineno\n            if exhandler.body[0].fromlineno <= lineno <= exhandler.body[-1].tolineno:\n                return lineno, exhandler.body[-1].tolineno\n        if self.orelse:\n            if self.orelse[0].fromlineno - 1 == lineno:\n                return lineno, lineno\n            if self.orelse[0].fromlineno <= lineno <= self.orelse[-1].tolineno:\n                return lineno, self.orelse[-1].tolineno\n        if self.finalbody:\n            if self.finalbody[0].fromlineno - 1 == lineno:\n                return lineno, lineno\n            if self.finalbody[0].fromlineno <= lineno <= self.finalbody[-1].tolineno:\n                return lineno, self.finalbody[-1].tolineno\n        return lineno, self.tolineno\n\n    def get_children(self):\n        yield from self.body\n        yield from self.handlers\n        yield from self.orelse\n        yield from self.finalbody\n\n\nclass Tuple(BaseContainer):\n    \"\"\"Class representing an :class:`ast.Tuple` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('(1, 2, 3)')\n    >>> node\n    <Tuple.tuple l.1 at 0x7f23b2e41780>\n    \"\"\"\n\n    _other_fields = (\"ctx\",)\n\n    def __init__(\n        self,\n        ctx: Context | None = None,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param ctx: Whether the tuple is assigned to or loaded from.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.ctx: Context | None = ctx\n        \"\"\"Whether the tuple is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    assigned_stmts = protocols.sequence_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    infer_unary_op = protocols.tuple_infer_unary_op\n    infer_binary_op = protocols.tl_infer_binary_op\n\n    def pytype(self) -> Literal[\"builtins.tuple\"]:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return \"builtins.tuple\"\n\n    def getitem(self, index, context: InferenceContext | None = None):\n        \"\"\"Get an item from this node.\n\n        :param index: The node to use as a subscript index.\n        :type index: Const or Slice\n        \"\"\"\n        return _container_getitem(self, self.elts, index, context=context)\n\n\nclass TypeAlias(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing a :class:`ast.TypeAlias` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('type Point = tuple[float, float]')\n    >>> node\n    <TypeAlias l.1 at 0x7f23b2e4e198>\n    \"\"\"\n\n    _astroid_fields = (\"name\", \"type_params\", \"value\")\n\n    name: AssignName\n    type_params: list[TypeVar | ParamSpec | TypeVarTuple]\n    value: NodeNG\n\n    def __init__(\n        self,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int,\n        end_col_offset: int,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        name: AssignName,\n        type_params: list[TypeVar | ParamSpec | TypeVarTuple],\n        value: NodeNG,\n    ) -> None:\n        self.name = name\n        self.type_params = type_params\n        self.value = value\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[TypeAlias]:\n        yield self\n\n    assigned_stmts: ClassVar[\n        Callable[\n            [\n                TypeAlias,\n                AssignName,\n                InferenceContext | None,\n                None,\n            ],\n            Generator[NodeNG],\n        ]\n    ] = protocols.assign_assigned_stmts\n\n\nclass TypeVar(_base_nodes.AssignTypeNode):\n    \"\"\"Class representing a :class:`ast.TypeVar` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('type Point[T] = tuple[float, float]')\n    >>> node.type_params[0]\n    <TypeVar l.1 at 0x7f23b2e4e198>\n    \"\"\"\n\n    _astroid_fields = (\"name\", \"bound\")\n\n    name: AssignName\n    bound: NodeNG | None\n\n    def __init__(\n        self,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int,\n        end_col_offset: int,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, name: AssignName, bound: NodeNG | None) -> None:\n        self.name = name\n        self.bound = bound\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[TypeVar]:\n        yield self\n\n    assigned_stmts = protocols.generic_type_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nclass TypeVarTuple(_base_nodes.AssignTypeNode):\n    \"\"\"Class representing a :class:`ast.TypeVarTuple` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('type Alias[*Ts] = tuple[*Ts]')\n    >>> node.type_params[0]\n    <TypeVarTuple l.1 at 0x7f23b2e4e198>\n    \"\"\"\n\n    _astroid_fields = (\"name\",)\n\n    name: AssignName\n\n    def __init__(\n        self,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int,\n        end_col_offset: int,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, name: AssignName) -> None:\n        self.name = name\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[TypeVarTuple]:\n        yield self\n\n    assigned_stmts = protocols.generic_type_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nUNARY_OP_METHOD = {\n    \"+\": \"__pos__\",\n    \"-\": \"__neg__\",\n    \"~\": \"__invert__\",\n    \"not\": None,  # XXX not '__nonzero__'\n}\n\n\nclass UnaryOp(_base_nodes.OperatorNode):\n    \"\"\"Class representing an :class:`ast.UnaryOp` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('-5')\n    >>> node\n    <UnaryOp l.1 at 0x7f23b2e4e198>\n    \"\"\"\n\n    _astroid_fields = (\"operand\",)\n    _other_fields = (\"op\",)\n\n    operand: NodeNG\n    \"\"\"What the unary operator is applied to.\"\"\"\n\n    def __init__(\n        self,\n        op: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.op = op\n        \"\"\"The operator.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, operand: NodeNG) -> None:\n        self.operand = operand\n\n    def type_errors(\n        self, context: InferenceContext | None = None\n    ) -> list[util.BadUnaryOperationMessage]:\n        \"\"\"Get a list of type errors which can occur during inference.\n\n        Each TypeError is represented by a :class:`BadUnaryOperationMessage`,\n        which holds the original exception.\n\n        If any inferred result is uninferable, an empty list is returned.\n        \"\"\"\n        bad = []\n        try:\n            for result in self._infer_unaryop(context=context):\n                if result is util.Uninferable:\n                    raise InferenceError\n                if isinstance(result, util.BadUnaryOperationMessage):\n                    bad.append(result)\n        except InferenceError:\n            return []\n        return bad\n\n    def get_children(self):\n        yield self.operand\n\n    def op_precedence(self) -> int:\n        if self.op == \"not\":\n            return OP_PRECEDENCE[self.op]\n\n        return super().op_precedence()\n\n    def _infer_unaryop(\n        self: nodes.UnaryOp, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[\n        InferenceResult | util.BadUnaryOperationMessage, None, InferenceErrorInfo\n    ]:\n        \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n        from astroid.nodes import ClassDef  # pylint: disable=import-outside-toplevel\n\n        for operand in self.operand.infer(context):\n            try:\n                yield operand.infer_unary_op(self.op)\n            except TypeError as exc:\n                # The operand doesn't support this operation.\n                yield util.BadUnaryOperationMessage(operand, self.op, exc)\n            except AttributeError as exc:\n                meth = UNARY_OP_METHOD[self.op]\n                if meth is None:\n                    # `not node`. Determine node's boolean\n                    # value and negate its result, unless it is\n                    # Uninferable, which will be returned as is.\n                    bool_value = operand.bool_value()\n                    if not isinstance(bool_value, util.UninferableBase):\n                        yield const_factory(not bool_value)\n                    else:\n                        yield util.Uninferable\n                else:\n                    if not isinstance(operand, (Instance, ClassDef)):\n                        # The operation was used on something which\n                        # doesn't support it.\n                        yield util.BadUnaryOperationMessage(operand, self.op, exc)\n                        continue\n\n                    try:\n                        try:\n                            methods = dunder_lookup.lookup(operand, meth)\n                        except AttributeInferenceError:\n                            yield util.BadUnaryOperationMessage(operand, self.op, exc)\n                            continue\n\n                        meth = methods[0]\n                        inferred = next(meth.infer(context=context), None)\n                        if (\n                            isinstance(inferred, util.UninferableBase)\n                            or not inferred.callable()\n                        ):\n                            continue\n\n                        context = copy_context(context)\n                        context.boundnode = operand\n                        context.callcontext = CallContext(args=[], callee=inferred)\n\n                        call_results = inferred.infer_call_result(self, context=context)\n                        result = next(call_results, None)\n                        if result is None:\n                            # Failed to infer, return the same type.\n                            yield operand\n                        else:\n                            yield result\n                    except AttributeInferenceError as inner_exc:\n                        # The unary operation special method was not found.\n                        yield util.BadUnaryOperationMessage(operand, self.op, inner_exc)\n                    except InferenceError:\n                        yield util.Uninferable\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self: nodes.UnaryOp, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n        \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n        yield from self._filter_operation_errors(\n            self._infer_unaryop, context, util.BadUnaryOperationMessage\n        )\n        return InferenceErrorInfo(node=self, context=context)\n\n\nclass While(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.While` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    while condition():\n        print(\"True\")\n    ''')\n    >>> node\n    <While l.2 at 0x7f23b2e4e390>\n    \"\"\"\n\n    _astroid_fields = (\"test\", \"body\", \"orelse\")\n    _multi_line_block_fields = (\"body\", \"orelse\")\n\n    test: NodeNG\n    \"\"\"The condition that the loop tests.\"\"\"\n\n    body: list[NodeNG]\n    \"\"\"The contents of the loop.\"\"\"\n\n    orelse: list[NodeNG]\n    \"\"\"The contents of the ``else`` block.\"\"\"\n\n    def postinit(\n        self,\n        test: NodeNG,\n        body: list[NodeNG],\n        orelse: list[NodeNG],\n    ) -> None:\n        self.test = test\n        self.body = body\n        self.orelse = orelse\n\n    @cached_property\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.test.tolineno\n\n    def block_range(self, lineno: int) -> tuple[int, int]:\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: The line number to start the range at.\n\n        :returns: The range of line numbers that this node belongs to,\n            starting at the given line number.\n        \"\"\"\n        return self._elsed_block_range(lineno, self.orelse)\n\n    def get_children(self):\n        yield self.test\n\n        yield from self.body\n        yield from self.orelse\n\n    def _get_yield_nodes_skip_functions(self):\n        \"\"\"A While node can contain a Yield node in the test\"\"\"\n        yield from self.test._get_yield_nodes_skip_functions()\n        yield from super()._get_yield_nodes_skip_functions()\n\n    def _get_yield_nodes_skip_lambdas(self):\n        \"\"\"A While node can contain a Yield node in the test\"\"\"\n        yield from self.test._get_yield_nodes_skip_lambdas()\n        yield from super()._get_yield_nodes_skip_lambdas()\n\n\nclass With(\n    _base_nodes.MultiLineWithElseBlockNode,\n    _base_nodes.AssignTypeNode,\n    _base_nodes.Statement,\n):\n    \"\"\"Class representing an :class:`ast.With` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    with open(file_path) as file_:\n        print(file_.read())\n    ''')\n    >>> node\n    <With l.2 at 0x7f23b2e4e710>\n    \"\"\"\n\n    _astroid_fields = (\"items\", \"body\")\n    _other_other_fields = (\"type_annotation\",)\n    _multi_line_block_fields = (\"body\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.items: list[tuple[NodeNG, NodeNG | None]] = []\n        \"\"\"The pairs of context managers and the names they are assigned to.\"\"\"\n\n        self.body: list[NodeNG] = []\n        \"\"\"The contents of the ``with`` block.\"\"\"\n\n        self.type_annotation: NodeNG | None = None  # can be None\n        \"\"\"If present, this will contain the type annotation passed by a type comment\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        items: list[tuple[NodeNG, NodeNG | None]] | None = None,\n        body: list[NodeNG] | None = None,\n        type_annotation: NodeNG | None = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param items: The pairs of context managers and the names\n            they are assigned to.\n\n        :param body: The contents of the ``with`` block.\n        \"\"\"\n        if items is not None:\n            self.items = items\n        if body is not None:\n            self.body = body\n        self.type_annotation = type_annotation\n\n    assigned_stmts = protocols.with_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    @cached_property\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.items[-1][0].tolineno\n\n    def get_children(self):\n        \"\"\"Get the child nodes below this node.\n\n        :returns: The children.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        for expr, var in self.items:\n            yield expr\n            if var:\n                yield var\n        yield from self.body\n\n\nclass AsyncWith(With):\n    \"\"\"Asynchronous ``with`` built with the ``async`` keyword.\"\"\"\n\n\nclass Yield(NodeNG):\n    \"\"\"Class representing an :class:`ast.Yield` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('yield True')\n    >>> node\n    <Yield l.1 at 0x7f23b2e4e5f8>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n\n    value: NodeNG | None\n    \"\"\"The value to yield.\"\"\"\n\n    def postinit(self, value: NodeNG | None) -> None:\n        self.value = value\n\n    def get_children(self):\n        if self.value is not None:\n            yield self.value\n\n    def _get_yield_nodes_skip_functions(self):\n        yield self\n\n    def _get_yield_nodes_skip_lambdas(self):\n        yield self\n\n\nclass YieldFrom(Yield):  # TODO value is required, not optional\n    \"\"\"Class representing an :class:`ast.YieldFrom` node.\"\"\"\n\n\nclass DictUnpack(_base_nodes.NoChildrenNode):\n    \"\"\"Represents the unpacking of dicts into dicts using :pep:`448`.\"\"\"\n\n\nclass FormattedValue(NodeNG):\n    \"\"\"Class representing an :class:`ast.FormattedValue` node.\n\n    Represents a :pep:`498` format string.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('f\"Format {type_}\"')\n    >>> node\n    <JoinedStr l.1 at 0x7f23b2e4ed30>\n    >>> node.values\n    [<Const.str l.1 at 0x7f23b2e4eda0>, <FormattedValue l.1 at 0x7f23b2e4edd8>]\n    \"\"\"\n\n    _astroid_fields = (\"value\", \"format_spec\")\n    _other_fields = (\"conversion\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.value: NodeNG\n        \"\"\"The value to be formatted into the string.\"\"\"\n\n        self.conversion: int\n        \"\"\"The type of formatting to be applied to the value.\n\n        .. seealso::\n            :class:`ast.FormattedValue`\n        \"\"\"\n\n        self.format_spec: JoinedStr | None = None\n        \"\"\"The formatting to be applied to the value.\n\n        .. seealso::\n            :class:`ast.FormattedValue`\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        value: NodeNG,\n        conversion: int,\n        format_spec: JoinedStr | None = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: The value to be formatted into the string.\n\n        :param conversion: The type of formatting to be applied to the value.\n\n        :param format_spec: The formatting to be applied to the value.\n        :type format_spec: JoinedStr or None\n        \"\"\"\n        self.value = value\n        self.conversion = conversion\n        self.format_spec = format_spec\n\n    def get_children(self):\n        yield self.value\n\n        if self.format_spec is not None:\n            yield self.format_spec\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        format_specs = Const(\"\") if self.format_spec is None else self.format_spec\n        uninferable_already_generated = False\n        for format_spec in format_specs.infer(context, **kwargs):\n            if not isinstance(format_spec, Const):\n                if not uninferable_already_generated:\n                    yield util.Uninferable\n                    uninferable_already_generated = True\n                continue\n            for value in self.value.infer(context, **kwargs):\n                if not isinstance(value, Const):\n                    if not uninferable_already_generated:\n                        yield util.Uninferable\n                        uninferable_already_generated = True\n                    continue\n                formatted = format(value.value, format_spec.value)\n                yield Const(\n                    formatted,\n                    lineno=self.lineno,\n                    col_offset=self.col_offset,\n                    end_lineno=self.end_lineno,\n                    end_col_offset=self.end_col_offset,\n                )\n                continue\n\n\nMISSING_VALUE = \"{MISSING_VALUE}\"\n\n\nclass JoinedStr(NodeNG):\n    \"\"\"Represents a list of string expressions to be joined.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('f\"Format {type_}\"')\n    >>> node\n    <JoinedStr l.1 at 0x7f23b2e4ed30>\n    \"\"\"\n\n    _astroid_fields = (\"values\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.values: list[NodeNG] = []\n        \"\"\"The string expressions to be joined.\n\n        :type: list(FormattedValue or Const)\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, values: list[NodeNG] | None = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: The string expressions to be joined.\n\n        :type: list(FormattedValue or Const)\n        \"\"\"\n        if values is not None:\n            self.values = values\n\n    def get_children(self):\n        yield from self.values\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        yield from self._infer_from_values(self.values, context)\n\n    @classmethod\n    def _infer_from_values(\n        cls, nodes: list[NodeNG], context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        if not nodes:\n            yield\n            return\n        if len(nodes) == 1:\n            yield from nodes[0]._infer(context, **kwargs)\n            return\n        uninferable_already_generated = False\n        for prefix in nodes[0]._infer(context, **kwargs):\n            for suffix in cls._infer_from_values(nodes[1:], context, **kwargs):\n                result = \"\"\n                for node in (prefix, suffix):\n                    if isinstance(node, Const):\n                        result += str(node.value)\n                        continue\n                    result += MISSING_VALUE\n                if MISSING_VALUE in result:\n                    if not uninferable_already_generated:\n                        uninferable_already_generated = True\n                        yield util.Uninferable\n                else:\n                    yield Const(result)\n\n\nclass NamedExpr(_base_nodes.AssignTypeNode):\n    \"\"\"Represents the assignment from the assignment expression\n\n    >>> import astroid\n    >>> module = astroid.parse('if a := 1: pass')\n    >>> module.body[0].test\n    <NamedExpr l.1 at 0x7f23b2e4ed30>\n    \"\"\"\n\n    _astroid_fields = (\"target\", \"value\")\n\n    optional_assign = True\n    \"\"\"Whether this node optionally assigns a variable.\n\n    Since NamedExpr are not always called they do not always assign.\"\"\"\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.target: NodeNG\n        \"\"\"The assignment target\n\n        :type: Name\n        \"\"\"\n\n        self.value: NodeNG\n        \"\"\"The value that gets assigned in the expression\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, target: NodeNG, value: NodeNG) -> None:\n        self.target = target\n        self.value = value\n\n    assigned_stmts = protocols.named_expr_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def frame(\n        self, *, future: Literal[None, True] = None\n    ) -> nodes.FunctionDef | nodes.Module | nodes.ClassDef | nodes.Lambda:\n        \"\"\"The first parent frame node.\n\n        A frame node is a :class:`Module`, :class:`FunctionDef`,\n        or :class:`ClassDef`.\n\n        :returns: The first parent frame node.\n        \"\"\"\n        if future is not None:\n            warnings.warn(\n                \"The future arg will be removed in astroid 4.0.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        if not self.parent:\n            raise ParentMissingError(target=self)\n\n        # For certain parents NamedExpr evaluate to the scope of the parent\n        if isinstance(self.parent, (Arguments, Keyword, Comprehension)):\n            if not self.parent.parent:\n                raise ParentMissingError(target=self.parent)\n            if not self.parent.parent.parent:\n                raise ParentMissingError(target=self.parent.parent)\n            return self.parent.parent.parent.frame()\n\n        return self.parent.frame()\n\n    def scope(self) -> LocalsDictNodeNG:\n        \"\"\"The first parent node defining a new scope.\n        These can be Module, FunctionDef, ClassDef, Lambda, or GeneratorExp nodes.\n\n        :returns: The first parent scope node.\n        \"\"\"\n        if not self.parent:\n            raise ParentMissingError(target=self)\n\n        # For certain parents NamedExpr evaluate to the scope of the parent\n        if isinstance(self.parent, (Arguments, Keyword, Comprehension)):\n            if not self.parent.parent:\n                raise ParentMissingError(target=self.parent)\n            if not self.parent.parent.parent:\n                raise ParentMissingError(target=self.parent.parent)\n            return self.parent.parent.parent.scope()\n\n        return self.parent.scope()\n\n    def set_local(self, name: str, stmt: NodeNG) -> None:\n        \"\"\"Define that the given name is declared in the given statement node.\n        NamedExpr's in Arguments, Keyword or Comprehension are evaluated in their\n        parent's parent scope. So we add to their frame's locals.\n\n        .. seealso:: :meth:`scope`\n\n        :param name: The name that is being defined.\n\n        :param stmt: The statement that defines the given name.\n        \"\"\"\n        self.frame().set_local(name, stmt)\n\n\nclass Unknown(_base_nodes.AssignTypeNode):\n    \"\"\"This node represents a node in a constructed AST where\n    introspection is not possible.  At the moment, it's only used in\n    the args attribute of FunctionDef nodes where function signature\n    introspection failed.\n    \"\"\"\n\n    name = \"Unknown\"\n\n    def __init__(\n        self,\n        lineno: None = None,\n        col_offset: None = None,\n        parent: None = None,\n        *,\n        end_lineno: None = None,\n        end_col_offset: None = None,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def qname(self) -> Literal[\"Unknown\"]:\n        return \"Unknown\"\n\n    def _infer(self, context: InferenceContext | None = None, **kwargs):\n        \"\"\"Inference on an Unknown node immediately terminates.\"\"\"\n        yield util.Uninferable\n\n\nclass EvaluatedObject(NodeNG):\n    \"\"\"Contains an object that has already been inferred\n\n    This class is useful to pre-evaluate a particular node,\n    with the resulting class acting as the non-evaluated node.\n    \"\"\"\n\n    name = \"EvaluatedObject\"\n    _astroid_fields = (\"original\",)\n    _other_fields = (\"value\",)\n\n    def __init__(\n        self, original: SuccessfulInferenceResult, value: InferenceResult\n    ) -> None:\n        self.original: SuccessfulInferenceResult = original\n        \"\"\"The original node that has already been evaluated\"\"\"\n\n        self.value: InferenceResult = value\n        \"\"\"The inferred value\"\"\"\n\n        super().__init__(\n            lineno=self.original.lineno,\n            col_offset=self.original.col_offset,\n            parent=self.original.parent,\n            end_lineno=self.original.end_lineno,\n            end_col_offset=self.original.end_col_offset,\n        )\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[NodeNG | util.UninferableBase]:\n        yield self.value\n\n\n# Pattern matching #######################################################\n\n\nclass Match(_base_nodes.Statement, _base_nodes.MultiLineBlockNode):\n    \"\"\"Class representing a :class:`ast.Match` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 200:\n            ...\n        case _:\n            ...\n    ''')\n    >>> node\n    <Match l.2 at 0x10c24e170>\n    \"\"\"\n\n    _astroid_fields = (\"subject\", \"cases\")\n    _multi_line_block_fields = (\"cases\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.subject: NodeNG\n        self.cases: list[MatchCase]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        subject: NodeNG,\n        cases: list[MatchCase],\n    ) -> None:\n        self.subject = subject\n        self.cases = cases\n\n\nclass Pattern(NodeNG):\n    \"\"\"Base class for all Pattern nodes.\"\"\"\n\n\nclass MatchCase(_base_nodes.MultiLineBlockNode):\n    \"\"\"Class representing a :class:`ast.match_case` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 200:\n            ...\n    ''')\n    >>> node.cases[0]\n    <MatchCase l.3 at 0x10c24e590>\n    \"\"\"\n\n    _astroid_fields = (\"pattern\", \"guard\", \"body\")\n    _multi_line_block_fields = (\"body\",)\n\n    lineno: None\n    col_offset: None\n    end_lineno: None\n    end_col_offset: None\n\n    def __init__(self, *, parent: NodeNG | None = None) -> None:\n        self.pattern: Pattern\n        self.guard: NodeNG | None\n        self.body: list[NodeNG]\n        super().__init__(\n            parent=parent,\n            lineno=None,\n            col_offset=None,\n            end_lineno=None,\n            end_col_offset=None,\n        )\n\n    def postinit(\n        self,\n        *,\n        pattern: Pattern,\n        guard: NodeNG | None,\n        body: list[NodeNG],\n    ) -> None:\n        self.pattern = pattern\n        self.guard = guard\n        self.body = body\n\n\nclass MatchValue(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchValue` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 200:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchValue l.3 at 0x10c24e200>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.value: NodeNG\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, value: NodeNG) -> None:\n        self.value = value\n\n\nclass MatchSingleton(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchSingleton` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case True:\n            ...\n        case False:\n            ...\n        case None:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchSingleton l.3 at 0x10c2282e0>\n    >>> node.cases[1].pattern\n    <MatchSingleton l.5 at 0x10c228af0>\n    >>> node.cases[2].pattern\n    <MatchSingleton l.7 at 0x10c229f90>\n    \"\"\"\n\n    _other_fields = (\"value\",)\n\n    def __init__(\n        self,\n        *,\n        value: Literal[True, False, None],\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n        parent: NodeNG | None = None,\n    ) -> None:\n        self.value = value\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n\nclass MatchSequence(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchSequence` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case [1, 2]:\n            ...\n        case (1, 2, *_):\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchSequence l.3 at 0x10ca80d00>\n    >>> node.cases[1].pattern\n    <MatchSequence l.5 at 0x10ca80b20>\n    \"\"\"\n\n    _astroid_fields = (\"patterns\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.patterns: list[Pattern]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, patterns: list[Pattern]) -> None:\n        self.patterns = patterns\n\n\nclass MatchMapping(_base_nodes.AssignTypeNode, Pattern):\n    \"\"\"Class representing a :class:`ast.MatchMapping` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case {1: \"Hello\", 2: \"World\", 3: _, **rest}:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchMapping l.3 at 0x10c8a8850>\n    \"\"\"\n\n    _astroid_fields = (\"keys\", \"patterns\", \"rest\")\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.keys: list[NodeNG]\n        self.patterns: list[Pattern]\n        self.rest: AssignName | None\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        keys: list[NodeNG],\n        patterns: list[Pattern],\n        rest: AssignName | None,\n    ) -> None:\n        self.keys = keys\n        self.patterns = patterns\n        self.rest = rest\n\n    assigned_stmts = protocols.match_mapping_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nclass MatchClass(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchClass` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case Point2D(0, 0):\n            ...\n        case Point3D(x=0, y=0, z=0):\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchClass l.3 at 0x10ca83940>\n    >>> node.cases[1].pattern\n    <MatchClass l.5 at 0x10ca80880>\n    \"\"\"\n\n    _astroid_fields = (\"cls\", \"patterns\", \"kwd_patterns\")\n    _other_fields = (\"kwd_attrs\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.cls: NodeNG\n        self.patterns: list[Pattern]\n        self.kwd_attrs: list[str]\n        self.kwd_patterns: list[Pattern]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        cls: NodeNG,\n        patterns: list[Pattern],\n        kwd_attrs: list[str],\n        kwd_patterns: list[Pattern],\n    ) -> None:\n        self.cls = cls\n        self.patterns = patterns\n        self.kwd_attrs = kwd_attrs\n        self.kwd_patterns = kwd_patterns\n\n\nclass MatchStar(_base_nodes.AssignTypeNode, Pattern):\n    \"\"\"Class representing a :class:`ast.MatchStar` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case [1, *_]:\n            ...\n    ''')\n    >>> node.cases[0].pattern.patterns[1]\n    <MatchStar l.3 at 0x10ca809a0>\n    \"\"\"\n\n    _astroid_fields = (\"name\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.name: AssignName | None\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, name: AssignName | None) -> None:\n        self.name = name\n\n    assigned_stmts = protocols.match_star_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nclass MatchAs(_base_nodes.AssignTypeNode, Pattern):\n    \"\"\"Class representing a :class:`ast.MatchAs` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case [1, a]:\n            ...\n        case {'key': b}:\n            ...\n        case Point2D(0, 0) as c:\n            ...\n        case d:\n            ...\n    ''')\n    >>> node.cases[0].pattern.patterns[1]\n    <MatchAs l.3 at 0x10d0b2da0>\n    >>> node.cases[1].pattern.patterns[0]\n    <MatchAs l.5 at 0x10d0b2920>\n    >>> node.cases[2].pattern\n    <MatchAs l.7 at 0x10d0b06a0>\n    >>> node.cases[3].pattern\n    <MatchAs l.9 at 0x10d09b880>\n    \"\"\"\n\n    _astroid_fields = (\"pattern\", \"name\")\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.pattern: Pattern | None\n        self.name: AssignName | None\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        pattern: Pattern | None,\n        name: AssignName | None,\n    ) -> None:\n        self.pattern = pattern\n        self.name = name\n\n    assigned_stmts = protocols.match_as_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nclass MatchOr(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchOr` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 400 | 401 | 402:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchOr l.3 at 0x10d0b0b50>\n    \"\"\"\n\n    _astroid_fields = (\"patterns\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.patterns: list[Pattern]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, patterns: list[Pattern]) -> None:\n        self.patterns = patterns\n\n\n# constants ##############################################################\n\n# The _proxied attribute of all container types (List, Tuple, etc.)\n# are set during bootstrapping by _astroid_bootstrapping().\nCONST_CLS: dict[type, type[NodeNG]] = {\n    list: List,\n    tuple: Tuple,\n    dict: Dict,\n    set: Set,\n    type(None): Const,\n    type(NotImplemented): Const,\n    type(...): Const,\n    bool: Const,\n    int: Const,\n    float: Const,\n    complex: Const,\n    str: Const,\n    bytes: Const,\n}\n\n\ndef _create_basic_elements(\n    value: Iterable[Any], node: List | Set | Tuple\n) -> list[NodeNG]:\n    \"\"\"Create a list of nodes to function as the elements of a new node.\"\"\"\n    elements: list[NodeNG] = []\n    for element in value:\n        element_node = const_factory(element)\n        element_node.parent = node\n        elements.append(element_node)\n    return elements\n\n\ndef _create_dict_items(\n    values: Mapping[Any, Any], node: Dict\n) -> list[tuple[SuccessfulInferenceResult, SuccessfulInferenceResult]]:\n    \"\"\"Create a list of node pairs to function as the items of a new dict node.\"\"\"\n    elements: list[tuple[SuccessfulInferenceResult, SuccessfulInferenceResult]] = []\n    for key, value in values.items():\n        key_node = const_factory(key)\n        key_node.parent = node\n        value_node = const_factory(value)\n        value_node.parent = node\n        elements.append((key_node, value_node))\n    return elements\n\n\ndef const_factory(value: Any) -> ConstFactoryResult:\n    \"\"\"Return an astroid node for a python value.\"\"\"\n    assert not isinstance(value, NodeNG)\n\n    # This only handles instances of the CONST types. Any\n    # subclasses get inferred as EmptyNode.\n    # TODO: See if we should revisit these with the normal builder.\n    if value.__class__ not in CONST_CLS:\n        node = EmptyNode()\n        node.object = value\n        return node\n\n    instance: List | Set | Tuple | Dict\n    initializer_cls = CONST_CLS[value.__class__]\n    if issubclass(initializer_cls, (List, Set, Tuple)):\n        instance = initializer_cls(\n            lineno=None,\n            col_offset=None,\n            parent=SYNTHETIC_ROOT,\n            end_lineno=None,\n            end_col_offset=None,\n        )\n        instance.postinit(_create_basic_elements(value, instance))\n        return instance\n    if issubclass(initializer_cls, Dict):\n        instance = initializer_cls(\n            lineno=None,\n            col_offset=None,\n            parent=SYNTHETIC_ROOT,\n            end_lineno=None,\n            end_col_offset=None,\n        )\n        instance.postinit(_create_dict_items(value, instance))\n        return instance\n    return Const(value)",
            "output_extracted": "# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html\n# For details: https://github.com/pylint-dev/astroid/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/astroid/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Module for some node classes. More nodes in scoped_nodes.py\"\"\"\n\nfrom __future__ import annotations\n\nimport abc\nimport ast\nimport itertools\nimport operator\nimport sys\nimport typing\nimport warnings\nfrom collections.abc import Callable, Generator, Iterable, Iterator, Mapping\nfrom functools import cached_property\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    ClassVar,\n    Literal,\n    Optional,\n    Union,\n)\n\nfrom astroid import decorators, protocols, util\nfrom astroid.bases import Instance, _infer_stmts\nfrom astroid.const import _EMPTY_OBJECT_MARKER, Context\nfrom astroid.context import CallContext, InferenceContext, copy_context\nfrom astroid.exceptions import (\n    AstroidBuildingError,\n    AstroidError,\n    AstroidIndexError,\n    AstroidTypeError,\n    AstroidValueError,\n    AttributeInferenceError,\n    InferenceError,\n    NameInferenceError,\n    NoDefault,\n    ParentMissingError,\n    _NonDeducibleTypeHierarchy,\n)\nfrom astroid.interpreter import dunder_lookup\nfrom astroid.manager import AstroidManager\nfrom astroid.nodes import _base_nodes\nfrom astroid.nodes.const import OP_PRECEDENCE\nfrom astroid.nodes.node_ng import NodeNG\nfrom astroid.nodes.scoped_nodes import SYNTHETIC_ROOT\nfrom astroid.typing import (\n    ConstFactoryResult,\n    InferenceErrorInfo,\n    InferenceResult,\n    SuccessfulInferenceResult,\n)\n\nif sys.version_info >= (3, 11):\n    from typing import Self\nelse:\n    from typing_extensions import Self\n\nif TYPE_CHECKING:\n    from astroid import nodes\n    from astroid.nodes import LocalsDictNodeNG\n\n\ndef _is_const(value) -> bool:\n    return isinstance(value, tuple(CONST_CLS))\n\n\n_NodesT = typing.TypeVar(\"_NodesT\", bound=NodeNG)\n_BadOpMessageT = typing.TypeVar(\"_BadOpMessageT\", bound=util.BadOperationMessage)\n\nAssignedStmtsPossibleNode = Union[\"List\", \"Tuple\", \"AssignName\", \"AssignAttr\", None]\nAssignedStmtsCall = Callable[\n    [\n        _NodesT,\n        AssignedStmtsPossibleNode,\n        Optional[InferenceContext],\n        Optional[list[int]],\n    ],\n    Any,\n]\nInferBinaryOperation = Callable[\n    [_NodesT, Optional[InferenceContext]],\n    Generator[Union[InferenceResult, _BadOpMessageT]],\n]\nInferLHS = Callable[\n    [_NodesT, Optional[InferenceContext]],\n    Generator[InferenceResult, None, Optional[InferenceErrorInfo]],\n]\nInferUnaryOp = Callable[[_NodesT, str], ConstFactoryResult]\n\n\n@decorators.raise_if_nothing_inferred\ndef unpack_infer(stmt, context: InferenceContext | None = None):\n    \"\"\"recursively generate nodes inferred by the given statement.\n    If the inferred value is a list or a tuple, recurse on the elements\n    \"\"\"\n    if isinstance(stmt, (List, Tuple)):\n        for elt in stmt.elts:\n            if elt is util.Uninferable:\n                yield elt\n                continue\n            yield from unpack_infer(elt, context)\n        return {\"node\": stmt, \"context\": context}\n    # if inferred is a final node, return it and stop\n    inferred = next(stmt.infer(context), util.Uninferable)\n    if inferred is stmt:\n        yield inferred\n        return {\"node\": stmt, \"context\": context}\n    # else, infer recursively, except Uninferable object that should be returned as is\n    for inferred in stmt.infer(context):\n        if isinstance(inferred, util.UninferableBase):\n            yield inferred\n        else:\n            yield from unpack_infer(inferred, context)\n\n    return {\"node\": stmt, \"context\": context}\n\n\ndef are_exclusive(stmt1, stmt2, exceptions: list[str] | None = None) -> bool:\n    \"\"\"return true if the two given statements are mutually exclusive\n\n    `exceptions` may be a list of exception names. If specified, discard If\n    branches and check one of the statement is in an exception handler catching\n    one of the given exceptions.\n\n    algorithm :\n     1) index stmt1's parents\n     2) climb among stmt2's parents until we find a common parent\n     3) if the common parent is a If or Try statement, look if nodes are\n        in exclusive branches\n    \"\"\"\n    # index stmt1's parents\n    stmt1_parents = {}\n    children = {}\n    previous = stmt1\n    for node in stmt1.node_ancestors():\n        stmt1_parents[node] = 1\n        children[node] = previous\n        previous = node\n    # climb among stmt2's parents until we find a common parent\n    previous = stmt2\n    for node in stmt2.node_ancestors():\n        if node in stmt1_parents:\n            # if the common parent is a If or Try statement, look if\n            # nodes are in exclusive branches\n            if isinstance(node, If) and exceptions is None:\n                c2attr, c2node = node.locate_child(previous)\n                c1attr, c1node = node.locate_child(children[node])\n                if \"test\" in (c1attr, c2attr):\n                    # If any node is `If.test`, then it must be inclusive with\n                    # the other node (`If.body` and `If.orelse`)\n                    return False\n                if c1attr != c2attr:\n                    # different `If` branches (`If.body` and `If.orelse`)\n                    return True\n            elif isinstance(node, Try):\n                c2attr, c2node = node.locate_child(previous)\n                c1attr, c1node = node.locate_child(children[node])\n                if c1node is not c2node:\n                    first_in_body_caught_by_handlers = (\n                        c2attr == \"handlers\"\n                        and c1attr == \"body\"\n                        and previous.catch(exceptions)\n                    )\n                    second_in_body_caught_by_handlers = (\n                        c2attr == \"body\"\n                        and c1attr == \"handlers\"\n                        and children[node].catch(exceptions)\n                    )\n                    first_in_else_other_in_handlers = (\n                        c2attr == \"handlers\" and c1attr == \"orelse\"\n                    )\n                    second_in_else_other_in_handlers = (\n                        c2attr == \"orelse\" and c1attr == \"handlers\"\n                    )\n                    if any(\n                        (\n                            first_in_body_caught_by_handlers,\n                            second_in_body_caught_by_handlers,\n                            first_in_else_other_in_handlers,\n                            second_in_else_other_in_handlers,\n                        )\n                    ):\n                        return True\n                elif c2attr == \"handlers\" and c1attr == \"handlers\":\n                    return previous is not children[node]\n            return False\n        previous = node\n    return False\n\n\n# getitem() helpers.\n\n_SLICE_SENTINEL = object()\n\n\ndef _slice_value(index, context: InferenceContext | None = None):\n    \"\"\"Get the value of the given slice index.\"\"\"\n\n    if isinstance(index, Const):\n        if isinstance(index.value, (int, type(None))):\n            return index.value\n    elif index is None:\n        return None\n    else:\n        # Try to infer what the index actually is.\n        # Since we can't return all the possible values,\n        # we'll stop at the first possible value.\n        try:\n            inferred = next(index.infer(context=context))\n        except (InferenceError, StopIteration):\n            pass\n        else:\n            if isinstance(inferred, Const):\n                if isinstance(inferred.value, (int, type(None))):\n                    return inferred.value\n\n    # Use a sentinel, because None can be a valid\n    # value that this function can return,\n    # as it is the case for unspecified bounds.\n    return _SLICE_SENTINEL\n\n\ndef _infer_slice(node, context: InferenceContext | None = None):\n    lower = _slice_value(node.lower, context)\n    upper = _slice_value(node.upper, context)\n    step = _slice_value(node.step, context)\n    if all(elem is not _SLICE_SENTINEL for elem in (lower, upper, step)):\n        return slice(lower, upper, step)\n\n    raise AstroidTypeError(\n        message=\"Could not infer slice used in subscript\",\n        node=node,\n        index=node.parent,\n        context=context,\n    )\n\n\ndef _container_getitem(instance, elts, index, context: InferenceContext | None = None):\n    \"\"\"Get a slice or an item, using the given *index*, for the given sequence.\"\"\"\n    try:\n        if isinstance(index, Slice):\n            index_slice = _infer_slice(index, context=context)\n            new_cls = instance.__class__()\n            new_cls.elts = elts[index_slice]\n            new_cls.parent = instance.parent\n            return new_cls\n        if isinstance(index, Const):\n            return elts[index.value]\n    except ValueError as exc:\n        raise AstroidValueError(\n            message=\"Slice {index!r} cannot index container\",\n            node=instance,\n            index=index,\n            context=context,\n        ) from exc\n    except IndexError as exc:\n        raise AstroidIndexError(\n            message=\"Index {index!s} out of range\",\n            node=instance,\n            index=index,\n            context=context,\n        ) from exc\n    except TypeError as exc:\n        raise AstroidTypeError(\n            message=\"Type error {error!r}\", node=instance, index=index, context=context\n        ) from exc\n\n    raise AstroidTypeError(f\"Could not use {index} as subscript index\")\n\n\nclass BaseContainer(_base_nodes.ParentAssignNode, Instance, metaclass=abc.ABCMeta):\n    \"\"\"Base class for Set, FrozenSet, Tuple and List.\"\"\"\n\n    _astroid_fields = (\"elts\",)\n\n    def __init__(\n        self,\n        lineno: int | None,\n        col_offset: int | None,\n        parent: NodeNG | None,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.elts: list[SuccessfulInferenceResult] = []\n        \"\"\"The elements in the node.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, elts: list[SuccessfulInferenceResult]) -> None:\n        self.elts = elts\n\n    @classmethod\n    def from_elements(cls, elts: Iterable[Any]) -> Self:\n        \"\"\"Create a node of this type from the given list of elements.\n\n        :param elts: The list of elements that the node should contain.\n\n        :returns: A new node containing the given elements.\n        \"\"\"\n        node = cls(\n            lineno=None,\n            col_offset=None,\n            parent=None,\n            end_lineno=None,\n            end_col_offset=None,\n        )\n        node.elts = [const_factory(e) if _is_const(e) else e for e in elts]\n        return node\n\n    def itered(self):\n        \"\"\"An iterator over the elements this node contains.\n\n        :returns: The contents of this node.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        return self.elts\n\n    def bool_value(self, context: InferenceContext | None = None) -> bool:\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n        \"\"\"\n        return bool(self.elts)\n\n    @abc.abstractmethod\n    def pytype(self) -> str:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n\n    def get_children(self):\n        yield from self.elts\n\n    @decorators.raise_if_nothing_inferred\n    def _infer(\n        self,\n        context: InferenceContext | None = None,\n        **kwargs: Any,\n    ) -> Iterator[Self]:\n        has_starred_named_expr = any(\n            isinstance(e, (Starred, NamedExpr)) for e in self.elts\n        )\n        if has_starred_named_expr:\n            values = self._infer_sequence_helper(context)\n            new_seq = type(self)(\n                lineno=self.lineno,\n                col_offset=self.col_offset,\n                parent=self.parent,\n                end_lineno=self.end_lineno,\n                end_col_offset=self.end_col_offset,\n            )\n            new_seq.postinit(values)\n\n            yield new_seq\n        else:\n            yield self\n\n    def _infer_sequence_helper(\n        self, context: InferenceContext | None = None\n    ) -> list[SuccessfulInferenceResult]:\n        \"\"\"Infer all values based on BaseContainer.elts.\"\"\"\n        values = []\n\n        for elt in self.elts:\n            if isinstance(elt, Starred):\n                starred = util.safe_infer(elt.value, context)\n                if not starred:\n                    raise InferenceError(node=self, context=context)\n                if not hasattr(starred, \"elts\"):\n                    raise InferenceError(node=self, context=context)\n                # TODO: fresh context?\n                values.extend(starred._infer_sequence_helper(context))\n            elif isinstance(elt, NamedExpr):\n                value = util.safe_infer(elt.value, context)\n                if not value:\n                    raise InferenceError(node=self, context=context)\n                values.append(value)\n            else:\n                values.append(elt)\n        return values\n\n\n# Name classes\n\n\nclass AssignName(\n    _base_nodes.NoChildrenNode,\n    _base_nodes.LookupMixIn,\n    _base_nodes.ParentAssignNode,\n):\n    \"\"\"Variation of :class:`ast.Assign` representing assignment to a name.\n\n    An :class:`AssignName` is the name of something that is assigned to.\n    This includes variables defined in a function signature or in a loop.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('variable = range(10)')\n    >>> node\n    <Assign l.1 at 0x7effe1db8550>\n    >>> list(node.get_children())\n    [<AssignName.variable l.1 at 0x7effe1db8748>, <Call l.1 at 0x7effe1db8630>]\n    >>> list(node.get_children())[0].as_string()\n    'variable'\n    \"\"\"\n\n    _other_fields = (\"name\",)\n\n    def __init__(\n        self,\n        name: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.name = name\n        \"\"\"The name that is assigned to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    assigned_stmts = protocols.assend_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Infer an AssignName: need to inspect the RHS part of the\n        assign node.\n        \"\"\"\n        if isinstance(self.parent, AugAssign):\n            return self.parent.infer(context)\n\n        stmts = list(self.assigned_stmts(context=context))\n        return _infer_stmts(stmts, context)\n\n    @decorators.raise_if_nothing_inferred\n    def infer_lhs(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Infer a Name: use name lookup rules.\n\n        Same implementation as Name._infer.\"\"\"\n        # pylint: disable=import-outside-toplevel\n        from astroid.constraint import get_constraints\n        from astroid.helpers import _higher_function_scope\n\n        frame, stmts = self.lookup(self.name)\n        if not stmts:\n            # Try to see if the name is enclosed in a nested function\n            # and use the higher (first function) scope for searching.\n            parent_function = _higher_function_scope(self.scope())\n            if parent_function:\n                _, stmts = parent_function.lookup(self.name)\n\n            if not stmts:\n                raise NameInferenceError(\n                    name=self.name, scope=self.scope(), context=context\n                )\n        context = copy_context(context)\n        context.lookupname = self.name\n        context.constraints[self.name] = get_constraints(self, frame)\n\n        return _infer_stmts(stmts, context, frame)\n\n\nclass DelName(\n    _base_nodes.NoChildrenNode, _base_nodes.LookupMixIn, _base_nodes.ParentAssignNode\n):\n    \"\"\"Variation of :class:`ast.Delete` representing deletion of a name.\n\n    A :class:`DelName` is the name of something that is deleted.\n\n    >>> import astroid\n    >>> node = astroid.extract_node(\"del variable #@\")\n    >>> list(node.get_children())\n    [<DelName.variable l.1 at 0x7effe1da4d30>]\n    >>> list(node.get_children())[0].as_string()\n    'variable'\n    \"\"\"\n\n    _other_fields = (\"name\",)\n\n    def __init__(\n        self,\n        name: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.name = name\n        \"\"\"The name that is being deleted.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n\nclass Name(_base_nodes.LookupMixIn, _base_nodes.NoChildrenNode):\n    \"\"\"Class representing an :class:`ast.Name` node.\n\n    A :class:`Name` node is something that is named, but not covered by\n    :class:`AssignName` or :class:`DelName`.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('range(10)')\n    >>> node\n    <Call l.1 at 0x7effe1db8710>\n    >>> list(node.get_children())\n    [<Name.range l.1 at 0x7effe1db86a0>, <Const.int l.1 at 0x7effe1db8518>]\n    >>> list(node.get_children())[0].as_string()\n    'range'\n    \"\"\"\n\n    _other_fields = (\"name\",)\n\n    def __init__(\n        self,\n        name: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.name = name\n        \"\"\"The name that this node refers to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def _get_name_nodes(self):\n        yield self\n\n        for child_node in self.get_children():\n            yield from child_node._get_name_nodes()\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Infer a Name: use name lookup rules\n\n        Same implementation as AssignName._infer_lhs.\"\"\"\n        # pylint: disable=import-outside-toplevel\n        from astroid.constraint import get_constraints\n        from astroid.helpers import _higher_function_scope\n\n        frame, stmts = self.lookup(self.name)\n        if not stmts:\n            # Try to see if the name is enclosed in a nested function\n            # and use the higher (first function) scope for searching.\n            parent_function = _higher_function_scope(self.scope())\n            if parent_function:\n                _, stmts = parent_function.lookup(self.name)\n\n            if not stmts:\n                raise NameInferenceError(\n                    name=self.name, scope=self.scope(), context=context\n                )\n        context = copy_context(context)\n        context.lookupname = self.name\n        context.constraints[self.name] = get_constraints(self, frame)\n\n        return _infer_stmts(stmts, context, frame)\n\n\nDEPRECATED_ARGUMENT_DEFAULT = \"DEPRECATED_ARGUMENT_DEFAULT\"\n\n\nclass Arguments(\n    _base_nodes.AssignTypeNode\n):  # pylint: disable=too-many-instance-attributes\n    \"\"\"Class representing an :class:`ast.arguments` node.\n\n    An :class:`Arguments` node represents that arguments in a\n    function definition.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('def foo(bar): pass')\n    >>> node\n    <FunctionDef.foo l.1 at 0x7effe1db8198>\n    >>> node.args\n    <Arguments l.1 at 0x7effe1db82e8>\n    \"\"\"\n\n    # Python 3.4+ uses a different approach regarding annotations,\n    # each argument is a new class, _ast.arg, which exposes an\n    # 'annotation' attribute. In astroid though, arguments are exposed\n    # as is in the Arguments node and the only way to expose annotations\n    # is by using something similar with Python 3.3:\n    #  - we expose 'varargannotation' and 'kwargannotation' of annotations\n    #    of varargs and kwargs.\n    #  - we expose 'annotation', a list with annotations for\n    #    for each normal argument. If an argument doesn't have an\n    #    annotation, its value will be None.\n    _astroid_fields = (\n        \"args\",\n        \"defaults\",\n        \"kwonlyargs\",\n        \"posonlyargs\",\n        \"posonlyargs_annotations\",\n        \"kw_defaults\",\n        \"annotations\",\n        \"varargannotation\",\n        \"kwargannotation\",\n        \"kwonlyargs_annotations\",\n        \"type_comment_args\",\n        \"type_comment_kwonlyargs\",\n        \"type_comment_posonlyargs\",\n    )\n\n    _other_fields = (\"vararg\", \"kwarg\")\n\n    args: list[AssignName] | None\n    \"\"\"The names of the required arguments.\n\n    Can be None if the associated function does not have a retrievable\n    signature and the arguments are therefore unknown.\n    This can happen with (builtin) functions implemented in C that have\n    incomplete signature information.\n    \"\"\"\n\n    defaults: list[NodeNG] | None\n    \"\"\"The default values for arguments that can be passed positionally.\"\"\"\n\n    kwonlyargs: list[AssignName]\n    \"\"\"The keyword arguments that cannot be passed positionally.\"\"\"\n\n    posonlyargs: list[AssignName]\n    \"\"\"The arguments that can only be passed positionally.\"\"\"\n\n    kw_defaults: list[NodeNG | None] | None\n    \"\"\"The default values for keyword arguments that cannot be passed positionally.\"\"\"\n\n    annotations: list[NodeNG | None]\n    \"\"\"The type annotations of arguments that can be passed positionally.\"\"\"\n\n    posonlyargs_annotations: list[NodeNG | None]\n    \"\"\"The type annotations of arguments that can only be passed positionally.\"\"\"\n\n    kwonlyargs_annotations: list[NodeNG | None]\n    \"\"\"The type annotations of arguments that cannot be passed positionally.\"\"\"\n\n    type_comment_args: list[NodeNG | None]\n    \"\"\"The type annotation, passed by a type comment, of each argument.\n\n    If an argument does not have a type comment,\n    the value for that argument will be None.\n    \"\"\"\n\n    type_comment_kwonlyargs: list[NodeNG | None]\n    \"\"\"The type annotation, passed by a type comment, of each keyword only argument.\n\n    If an argument does not have a type comment,\n    the value for that argument will be None.\n    \"\"\"\n\n    type_comment_posonlyargs: list[NodeNG | None]\n    \"\"\"The type annotation, passed by a type comment, of each positional argument.\n\n    If an argument does not have a type comment,\n    the value for that argument will be None.\n    \"\"\"\n\n    varargannotation: NodeNG | None\n    \"\"\"The type annotation for the variable length arguments.\"\"\"\n\n    kwargannotation: NodeNG | None\n    \"\"\"The type annotation for the variable length keyword arguments.\"\"\"\n\n    vararg_node: AssignName | None\n    \"\"\"The node for variable length arguments\"\"\"\n\n    kwarg_node: AssignName | None\n    \"\"\"The node for variable keyword arguments\"\"\"\n\n    def __init__(\n        self,\n        vararg: str | None,\n        kwarg: str | None,\n        parent: NodeNG,\n        vararg_node: AssignName | None = None,\n        kwarg_node: AssignName | None = None,\n    ) -> None:\n        \"\"\"Almost all attributes can be None for living objects where introspection failed.\"\"\"\n        super().__init__(\n            parent=parent,\n            lineno=None,\n            col_offset=None,\n            end_lineno=None,\n            end_col_offset=None,\n        )\n\n        self.vararg = vararg\n        \"\"\"The name of the variable length arguments.\"\"\"\n\n        self.kwarg = kwarg\n        \"\"\"The name of the variable length keyword arguments.\"\"\"\n\n        self.vararg_node = vararg_node\n        self.kwarg_node = kwarg_node\n\n    # pylint: disable=too-many-arguments, too-many-positional-arguments\n    def postinit(\n        self,\n        args: list[AssignName] | None,\n        defaults: list[NodeNG] | None,\n        kwonlyargs: list[AssignName],\n        kw_defaults: list[NodeNG | None] | None,\n        annotations: list[NodeNG | None],\n        posonlyargs: list[AssignName],\n        kwonlyargs_annotations: list[NodeNG | None],\n        posonlyargs_annotations: list[NodeNG | None],\n        varargannotation: NodeNG | None = None,\n        kwargannotation: NodeNG | None = None,\n        type_comment_args: list[NodeNG | None] | None = None,\n        type_comment_kwonlyargs: list[NodeNG | None] | None = None,\n        type_comment_posonlyargs: list[NodeNG | None] | None = None,\n    ) -> None:\n        self.args = args\n        self.defaults = defaults\n        self.kwonlyargs = kwonlyargs\n        self.posonlyargs = posonlyargs\n        self.kw_defaults = kw_defaults\n        self.annotations = annotations\n        self.kwonlyargs_annotations = kwonlyargs_annotations\n        self.posonlyargs_annotations = posonlyargs_annotations\n\n        # Parameters that got added later and need a default\n        self.varargannotation = varargannotation\n        self.kwargannotation = kwargannotation\n        if type_comment_args is None:\n            type_comment_args = []\n        self.type_comment_args = type_comment_args\n        if type_comment_kwonlyargs is None:\n            type_comment_kwonlyargs = []\n        self.type_comment_kwonlyargs = type_comment_kwonlyargs\n        if type_comment_posonlyargs is None:\n            type_comment_posonlyargs = []\n        self.type_comment_posonlyargs = type_comment_posonlyargs\n\n    assigned_stmts = protocols.arguments_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def _infer_name(self, frame, name):\n        if self.parent is frame:\n            return name\n        return None\n\n    @cached_property\n    def fromlineno(self) -> int:\n        \"\"\"The first line that this node appears on in the source code.\n\n        Can also return 0 if the line can not be determined.\n        \"\"\"\n        lineno = super().fromlineno\n        return max(lineno, self.parent.fromlineno or 0)\n\n    @cached_property\n    def arguments(self):\n        \"\"\"Get all the arguments for this node. This includes:\n        * Positional only arguments\n        * Positional arguments\n        * Keyword arguments\n        * Variable arguments (.e.g *args)\n        * Variable keyword arguments (e.g **kwargs)\n        \"\"\"\n        retval = list(itertools.chain((self.posonlyargs or ()), (self.args or ())))\n        if self.vararg_node:\n            retval.append(self.vararg_node)\n        retval += self.kwonlyargs or ()\n        if self.kwarg_node:\n            retval.append(self.kwarg_node)\n\n        return retval\n\n    def format_args(self, *, skippable_names: set[str] | None = None) -> str:\n        \"\"\"Get the arguments formatted as string.\n\n        :returns: The formatted arguments.\n        :rtype: str\n        \"\"\"\n        result = []\n        positional_only_defaults = []\n        positional_or_keyword_defaults = self.defaults\n        if self.defaults:\n            args = self.args or []\n            positional_or_keyword_defaults = self.defaults[-len(args) :]\n            positional_only_defaults = self.defaults[: len(self.defaults) - len(args)]\n\n        if self.posonlyargs:\n            result.append(\n                _format_args(\n                    self.posonlyargs,\n                    positional_only_defaults,\n                    self.posonlyargs_annotations,\n                    skippable_names=skippable_names,\n                )\n            )\n            result.append(\"/\")\n        if self.args:\n            result.append(\n                _format_args(\n                    self.args,\n                    positional_or_keyword_defaults,\n                    getattr(self, \"annotations\", None),\n                    skippable_names=skippable_names,\n                )\n            )\n        if self.vararg:\n            result.append(f\"*{self.vararg}\")\n        if self.kwonlyargs:\n            if not self.vararg:\n                result.append(\"*\")\n            result.append(\n                _format_args(\n                    self.kwonlyargs,\n                    self.kw_defaults,\n                    self.kwonlyargs_annotations,\n                    skippable_names=skippable_names,\n                )\n            )\n        if self.kwarg:\n            result.append(f\"**{self.kwarg}\")\n        return \", \".join(result)\n\n    def _get_arguments_data(\n        self,\n    ) -> tuple[\n        dict[str, tuple[str | None, str | None]],\n        dict[str, tuple[str | None, str | None]],\n    ]:\n        \"\"\"Get the arguments as dictionary with information about typing and defaults.\n\n        The return tuple contains a dictionary for positional and keyword arguments with their typing\n        and their default value, if any.\n        The method follows a similar order as format_args but instead of formatting into a string it\n        returns the data that is used to do so.\n        \"\"\"\n        pos_only: dict[str, tuple[str | None, str | None]] = {}\n        kw_only: dict[str, tuple[str | None, str | None]] = {}\n\n        # Setup and match defaults with arguments\n        positional_only_defaults = []\n        positional_or_keyword_defaults = self.defaults\n        if self.defaults:\n            args = self.args or []\n            positional_or_keyword_defaults = self.defaults[-len(args) :]\n            positional_only_defaults = self.defaults[: len(self.defaults) - len(args)]\n\n        for index, posonly in enumerate(self.posonlyargs):\n            annotation, default = self.posonlyargs_annotations[index], None\n            if annotation is not None:\n                annotation = annotation.as_string()\n            if positional_only_defaults:\n                default = positional_only_defaults[index].as_string()\n            pos_only[posonly.name] = (annotation, default)\n\n        for index, arg in enumerate(self.args):\n            annotation, default = self.annotations[index], None\n            if annotation is not None:\n                annotation = annotation.as_string()\n            if positional_or_keyword_defaults:\n                defaults_offset = len(self.args) - len(positional_or_keyword_defaults)\n                default_index = index - defaults_offset\n                if (\n                    default_index > -1\n                    and positional_or_keyword_defaults[default_index] is not None\n                ):\n                    default = positional_or_keyword_defaults[default_index].as_string()\n            pos_only[arg.name] = (annotation, default)\n\n        if self.vararg:\n            annotation = self.varargannotation\n            if annotation is not None:\n                annotation = annotation.as_string()\n            pos_only[self.vararg] = (annotation, None)\n\n        for index, kwarg in enumerate(self.kwonlyargs):\n            annotation = self.kwonlyargs_annotations[index]\n            if annotation is not None:\n                annotation = annotation.as_string()\n            default = self.kw_defaults[index]\n            if default is not None:\n                default = default.as_string()\n            kw_only[kwarg.name] = (annotation, default)\n\n        if self.kwarg:\n            annotation = self.kwargannotation\n            if annotation is not None:\n                annotation = annotation.as_string()\n            kw_only[self.kwarg] = (annotation, None)\n\n        return pos_only, kw_only\n\n    def default_value(self, argname):\n        \"\"\"Get the default value for an argument.\n\n        :param argname: The name of the argument to get the default value for.\n        :type argname: str\n\n        :raises NoDefault: If there is no default value defined for the\n            given argument.\n        \"\"\"\n        args = [\n            arg for arg in self.arguments if arg.name not in [self.vararg, self.kwarg]\n        ]\n\n        index = _find_arg(argname, self.kwonlyargs)[0]\n        if (index is not None) and (len(self.kw_defaults) > index):\n            if self.kw_defaults[index] is not None:\n                return self.kw_defaults[index]\n            raise NoDefault(func=self.parent, name=argname)\n\n        index = _find_arg(argname, args)[0]\n        if index is not None:\n            idx = index - (len(args) - len(self.defaults) - len(self.kw_defaults))\n            if idx >= 0:\n                return self.defaults[idx]\n\n        raise NoDefault(func=self.parent, name=argname)\n\n    def is_argument(self, name) -> bool:\n        \"\"\"Check if the given name is defined in the arguments.\n\n        :param name: The name to check for.\n        :type name: str\n\n        :returns: Whether the given name is defined in the arguments,\n        \"\"\"\n        if name == self.vararg:\n            return True\n        if name == self.kwarg:\n            return True\n        return self.find_argname(name)[1] is not None\n\n    def find_argname(self, argname, rec=DEPRECATED_ARGUMENT_DEFAULT):\n        \"\"\"Get the index and :class:`AssignName` node for given name.\n\n        :param argname: The name of the argument to search for.\n        :type argname: str\n\n        :returns: The index and node for the argument.\n        :rtype: tuple(str or None, AssignName or None)\n        \"\"\"\n        if rec != DEPRECATED_ARGUMENT_DEFAULT:  # pragma: no cover\n            warnings.warn(\n                \"The rec argument will be removed in astroid 3.1.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        if self.arguments:\n            index, argument = _find_arg(argname, self.arguments)\n            if argument:\n                return index, argument\n        return None, None\n\n    def get_children(self):\n        yield from self.posonlyargs or ()\n\n        for elt in self.posonlyargs_annotations:\n            if elt is not None:\n                yield elt\n\n        yield from self.args or ()\n\n        if self.defaults is not None:\n            yield from self.defaults\n        yield from self.kwonlyargs\n\n        for elt in self.kw_defaults or ():\n            if elt is not None:\n                yield elt\n\n        for elt in self.annotations:\n            if elt is not None:\n                yield elt\n\n        if self.varargannotation is not None:\n            yield self.varargannotation\n\n        if self.kwargannotation is not None:\n            yield self.kwargannotation\n\n        for elt in self.kwonlyargs_annotations:\n            if elt is not None:\n                yield elt\n\n    @decorators.raise_if_nothing_inferred\n    def _infer(\n        self: nodes.Arguments, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        # pylint: disable-next=import-outside-toplevel\n        from astroid.protocols import _arguments_infer_argname\n\n        if context is None or context.lookupname is None:\n            raise InferenceError(node=self, context=context)\n        return _arguments_infer_argname(self, context.lookupname, context)\n\n\ndef _find_arg(argname, args):\n    for i, arg in enumerate(args):\n        if arg.name == argname:\n            return i, arg\n    return None, None\n\n\ndef _format_args(\n    args, defaults=None, annotations=None, skippable_names: set[str] | None = None\n) -> str:\n    if skippable_names is None:\n        skippable_names = set()\n    values = []\n    if args is None:\n        return \"\"\n    if annotations is None:\n        annotations = []\n    if defaults is not None:\n        default_offset = len(args) - len(defaults)\n    else:\n        default_offset = None\n    packed = itertools.zip_longest(args, annotations)\n    for i, (arg, annotation) in enumerate(packed):\n        if arg.name in skippable_names:\n            continue\n        if isinstance(arg, Tuple):\n            values.append(f\"({_format_args(arg.elts)})\")\n        else:\n            argname = arg.name\n            default_sep = \"=\"\n            if annotation is not None:\n                argname += \": \" + annotation.as_string()\n                default_sep = \" = \"\n            values.append(argname)\n\n            if default_offset is not None and i >= default_offset:\n                if defaults[i - default_offset] is not None:\n                    values[-1] += default_sep + defaults[i - default_offset].as_string()\n    return \", \".join(values)\n\n\ndef _infer_attribute(\n    node: nodes.AssignAttr | nodes.Attribute,\n    context: InferenceContext | None = None,\n    **kwargs: Any,\n) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n    \"\"\"Infer an AssignAttr/Attribute node by using getattr on the associated object.\"\"\"\n    # pylint: disable=import-outside-toplevel\n    from astroid.constraint import get_constraints\n    from astroid.nodes import ClassDef\n\n    for owner in node.expr.infer(context):\n        if isinstance(owner, util.UninferableBase):\n            yield owner\n            continue\n\n        context = copy_context(context)\n        old_boundnode = context.boundnode\n        try:\n            context.boundnode = owner\n            if isinstance(owner, (ClassDef, Instance)):\n                frame = owner if isinstance(owner, ClassDef) else owner._proxied\n                context.constraints[node.attrname] = get_constraints(node, frame=frame)\n            if node.attrname == \"argv\" and owner.name == \"sys\":\n                # sys.argv will never be inferable during static analysis\n                # It's value would be the args passed to the linter itself\n                yield util.Uninferable\n            else:\n                yield from owner.igetattr(node.attrname, context)\n        except (\n            AttributeInferenceError,\n            InferenceError,\n            AttributeError,\n        ):\n            pass\n        finally:\n            context.boundnode = old_boundnode\n    return InferenceErrorInfo(node=node, context=context)\n\n\nclass AssignAttr(_base_nodes.LookupMixIn, _base_nodes.ParentAssignNode):\n    \"\"\"Variation of :class:`ast.Assign` representing assignment to an attribute.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('self.attribute = range(10)')\n    >>> node\n    <Assign l.1 at 0x7effe1d521d0>\n    >>> list(node.get_children())\n    [<AssignAttr.attribute l.1 at 0x7effe1d52320>, <Call l.1 at 0x7effe1d522e8>]\n    >>> list(node.get_children())[0].as_string()\n    'self.attribute'\n    \"\"\"\n\n    expr: NodeNG\n\n    _astroid_fields = (\"expr\",)\n    _other_fields = (\"attrname\",)\n\n    def __init__(\n        self,\n        attrname: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.attrname = attrname\n        \"\"\"The name of the attribute being assigned to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, expr: NodeNG) -> None:\n        self.expr = expr\n\n    assigned_stmts = protocols.assend_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def get_children(self):\n        yield self.expr\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Infer an AssignAttr: need to inspect the RHS part of the\n        assign node.\n        \"\"\"\n        if isinstance(self.parent, AugAssign):\n            return self.parent.infer(context)\n\n        stmts = list(self.assigned_stmts(context=context))\n        return _infer_stmts(stmts, context)\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def infer_lhs(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        return _infer_attribute(self, context, **kwargs)\n\n\nclass Assert(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Assert` node.\n\n    An :class:`Assert` node represents an assert statement.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('assert len(things) == 10, \"Not enough things\"')\n    >>> node\n    <Assert l.1 at 0x7effe1d527b8>\n    \"\"\"\n\n    _astroid_fields = (\"test\", \"fail\")\n\n    test: NodeNG\n    \"\"\"The test that passes or fails the assertion.\"\"\"\n\n    fail: NodeNG | None\n    \"\"\"The message shown when the assertion fails.\"\"\"\n\n    def postinit(self, test: NodeNG, fail: NodeNG | None) -> None:\n        self.fail = fail\n        self.test = test\n\n    def get_children(self):\n        yield self.test\n\n        if self.fail is not None:\n            yield self.fail\n\n\nclass Assign(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Assign` node.\n\n    An :class:`Assign` is a statement where something is explicitly\n    asssigned to.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('variable = range(10)')\n    >>> node\n    <Assign l.1 at 0x7effe1db8550>\n    \"\"\"\n\n    targets: list[NodeNG]\n    \"\"\"What is being assigned to.\"\"\"\n\n    value: NodeNG\n    \"\"\"The value being assigned to the variables.\"\"\"\n\n    type_annotation: NodeNG | None\n    \"\"\"If present, this will contain the type annotation passed by a type comment\"\"\"\n\n    _astroid_fields = (\"targets\", \"value\")\n    _other_other_fields = (\"type_annotation\",)\n\n    def postinit(\n        self,\n        targets: list[NodeNG],\n        value: NodeNG,\n        type_annotation: NodeNG | None,\n    ) -> None:\n        self.targets = targets\n        self.value = value\n        self.type_annotation = type_annotation\n\n    assigned_stmts = protocols.assign_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def get_children(self):\n        yield from self.targets\n\n        yield self.value\n\n    @cached_property\n    def _assign_nodes_in_scope(self) -> list[nodes.Assign]:\n        return [self, *self.value._assign_nodes_in_scope]\n\n    def _get_yield_nodes_skip_functions(self):\n        yield from self.value._get_yield_nodes_skip_functions()\n\n    def _get_yield_nodes_skip_lambdas(self):\n        yield from self.value._get_yield_nodes_skip_lambdas()\n\n\nclass AnnAssign(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.AnnAssign` node.\n\n    An :class:`AnnAssign` is an assignment with a type annotation.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('variable: List[int] = range(10)')\n    >>> node\n    <AnnAssign l.1 at 0x7effe1d4c630>\n    \"\"\"\n\n    _astroid_fields = (\"target\", \"annotation\", \"value\")\n    _other_fields = (\"simple\",)\n\n    target: Name | Attribute | Subscript\n    \"\"\"What is being assigned to.\"\"\"\n\n    annotation: NodeNG\n    \"\"\"The type annotation of what is being assigned to.\"\"\"\n\n    value: NodeNG | None\n    \"\"\"The value being assigned to the variables.\"\"\"\n\n    simple: int\n    \"\"\"Whether :attr:`target` is a pure name or a complex statement.\"\"\"\n\n    def postinit(\n        self,\n        target: Name | Attribute | Subscript,\n        annotation: NodeNG,\n        simple: int,\n        value: NodeNG | None,\n    ) -> None:\n        self.target = target\n        self.annotation = annotation\n        self.value = value\n        self.simple = simple\n\n    assigned_stmts = protocols.assign_annassigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def get_children(self):\n        yield self.target\n        yield self.annotation\n\n        if self.value is not None:\n            yield self.value\n\n\nclass AugAssign(\n    _base_nodes.AssignTypeNode, _base_nodes.OperatorNode, _base_nodes.Statement\n):\n    \"\"\"Class representing an :class:`ast.AugAssign` node.\n\n    An :class:`AugAssign` is an assignment paired with an operator.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('variable += 1')\n    >>> node\n    <AugAssign l.1 at 0x7effe1db4d68>\n    \"\"\"\n\n    _astroid_fields = (\"target\", \"value\")\n    _other_fields = (\"op\",)\n\n    target: Name | Attribute | Subscript\n    \"\"\"What is being assigned to.\"\"\"\n\n    value: NodeNG\n    \"\"\"The value being assigned to the variable.\"\"\"\n\n    def __init__(\n        self,\n        op: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.op = op\n        \"\"\"The operator that is being combined with the assignment.\n\n        This includes the equals sign.\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, target: Name | Attribute | Subscript, value: NodeNG) -> None:\n        self.target = target\n        self.value = value\n\n    assigned_stmts = protocols.assign_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def type_errors(\n        self, context: InferenceContext | None = None\n    ) -> list[util.BadBinaryOperationMessage]:\n        \"\"\"Get a list of type errors which can occur during inference.\n\n        Each TypeError is represented by a :class:`BadBinaryOperationMessage` ,\n        which holds the original exception.\n\n        If any inferred result is uninferable, an empty list is returned.\n        \"\"\"\n        bad = []\n        try:\n            for result in self._infer_augassign(context=context):\n                if result is util.Uninferable:\n                    raise InferenceError\n                if isinstance(result, util.BadBinaryOperationMessage):\n                    bad.append(result)\n        except InferenceError:\n            return []\n        return bad\n\n    def get_children(self):\n        yield self.target\n        yield self.value\n\n    def _get_yield_nodes_skip_functions(self):\n        \"\"\"An AugAssign node can contain a Yield node in the value\"\"\"\n        yield from self.value._get_yield_nodes_skip_functions()\n        yield from super()._get_yield_nodes_skip_functions()\n\n    def _get_yield_nodes_skip_lambdas(self):\n        \"\"\"An AugAssign node can contain a Yield node in the value\"\"\"\n        yield from self.value._get_yield_nodes_skip_lambdas()\n        yield from super()._get_yield_nodes_skip_lambdas()\n\n    def _infer_augassign(\n        self, context: InferenceContext | None = None\n    ) -> Generator[InferenceResult | util.BadBinaryOperationMessage]:\n        \"\"\"Inference logic for augmented binary operations.\"\"\"\n        context = context or InferenceContext()\n\n        rhs_context = context.clone()\n\n        lhs_iter = self.target.infer_lhs(context=context)\n        rhs_iter = self.value.infer(context=rhs_context)\n\n        for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n            if any(isinstance(value, util.UninferableBase) for value in (rhs, lhs)):\n                # Don't know how to process this.\n                yield util.Uninferable\n                return\n\n            try:\n                yield from self._infer_binary_operation(\n                    left=lhs,\n                    right=rhs,\n                    binary_opnode=self,\n                    context=context,\n                    flow_factory=self._get_aug_flow,\n                )\n            except _NonDeducibleTypeHierarchy:\n                yield util.Uninferable\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self: nodes.AugAssign, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        return self._filter_operation_errors(\n            self._infer_augassign, context, util.BadBinaryOperationMessage\n        )\n\n\nclass BinOp(_base_nodes.OperatorNode):\n    \"\"\"Class representing an :class:`ast.BinOp` node.\n\n    A :class:`BinOp` node is an application of a binary operator.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('a + b')\n    >>> node\n    <BinOp l.1 at 0x7f23b2e8cfd0>\n    \"\"\"\n\n    _astroid_fields = (\"left\", \"right\")\n    _other_fields = (\"op\",)\n\n    left: NodeNG\n    \"\"\"What is being applied to the operator on the left side.\"\"\"\n\n    right: NodeNG\n    \"\"\"What is being applied to the operator on the right side.\"\"\"\n\n    def __init__(\n        self,\n        op: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.op = op\n        \"\"\"The operator.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, left: NodeNG, right: NodeNG) -> None:\n        self.left = left\n        self.right = right\n\n    def type_errors(\n        self, context: InferenceContext | None = None\n    ) -> list[util.BadBinaryOperationMessage]:\n        \"\"\"Get a list of type errors which can occur during inference.\n\n        Each TypeError is represented by a :class:`BadBinaryOperationMessage`,\n        which holds the original exception.\n\n        If any inferred result is uninferable, an empty list is returned.\n        \"\"\"\n        bad = []\n        try:\n            for result in self._infer_binop(context=context):\n                if result is util.Uninferable:\n                    raise InferenceError\n                if isinstance(result, util.BadBinaryOperationMessage):\n                    bad.append(result)\n        except InferenceError:\n            return []\n        return bad\n\n    def get_children(self):\n        yield self.left\n        yield self.right\n\n    def op_precedence(self) -> int:\n        return OP_PRECEDENCE[self.op]\n\n    def op_left_associative(self) -> bool:\n        # 2**3**4 == 2**(3**4)\n        return self.op != \"**\"\n\n    def _infer_binop(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        \"\"\"Binary operation inference logic.\"\"\"\n        left = self.left\n        right = self.right\n\n        # we use two separate contexts for evaluating lhs and rhs because\n        # 1. evaluating lhs may leave some undesired entries in context.path\n        #    which may not let us infer right value of rhs\n        context = context or InferenceContext()\n        lhs_context = copy_context(context)\n        rhs_context = copy_context(context)\n        lhs_iter = left.infer(context=lhs_context)\n        rhs_iter = right.infer(context=rhs_context)\n        for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n            if any(isinstance(value, util.UninferableBase) for value in (rhs, lhs)):\n                # Don't know how to process this.\n                yield util.Uninferable\n                return\n\n            try:\n                yield from self._infer_binary_operation(\n                    lhs, rhs, self, context, self._get_binop_flow\n                )\n            except _NonDeducibleTypeHierarchy:\n                yield util.Uninferable\n\n    @decorators.yes_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self: nodes.BinOp, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        return self._filter_operation_errors(\n            self._infer_binop, context, util.BadBinaryOperationMessage\n        )\n\n\nclass BoolOp(NodeNG):\n    \"\"\"Class representing an :class:`ast.BoolOp` node.\n\n    A :class:`BoolOp` is an application of a boolean operator.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('a and b')\n    >>> node\n    <BinOp l.1 at 0x7f23b2e71c50>\n    \"\"\"\n\n    _astroid_fields = (\"values\",)\n    _other_fields = (\"op\",)\n\n    def __init__(\n        self,\n        op: str,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param op: The operator.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.op: str = op\n        \"\"\"The operator.\"\"\"\n\n        self.values: list[NodeNG] = []\n        \"\"\"The values being applied to the operator.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, values: list[NodeNG] | None = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param values: The values being applied to the operator.\n        \"\"\"\n        if values is not None:\n            self.values = values\n\n    def get_children(self):\n        yield from self.values\n\n    def op_precedence(self) -> int:\n        return OP_PRECEDENCE[self.op]\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self: nodes.BoolOp, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Infer a boolean operation (and / or / not).\n\n        The function will calculate the boolean operation\n        for all pairs generated through inference for each component\n        node.\n        \"\"\"\n        values = self.values\n        if self.op == \"or\":\n            predicate = operator.truth\n        else:\n            predicate = operator.not_\n\n        try:\n            inferred_values = [value.infer(context=context) for value in values]\n        except InferenceError:\n            yield util.Uninferable\n            return None\n\n        for pair in itertools.product(*inferred_values):\n            if any(isinstance(item, util.UninferableBase) for item in pair):\n                # Can't infer the final result, just yield Uninferable.\n                yield util.Uninferable\n                continue\n\n            bool_values = [item.bool_value() for item in pair]\n            if any(isinstance(item, util.UninferableBase) for item in bool_values):\n                # Can't infer the final result, just yield Uninferable.\n                yield util.Uninferable\n                continue\n\n            # Since the boolean operations are short circuited operations,\n            # this code yields the first value for which the predicate is True\n            # and if no value respected the predicate, then the last value will\n            # be returned (or Uninferable if there was no last value).\n            # This is conforming to the semantics of `and` and `or`:\n            #   1 and 0 -> 1\n            #   0 and 1 -> 0\n            #   1 or 0 -> 1\n            #   0 or 1 -> 1\n            value = util.Uninferable\n            for value, bool_value in zip(pair, bool_values):\n                if predicate(bool_value):\n                    yield value\n                    break\n            else:\n                yield value\n\n        return InferenceErrorInfo(node=self, context=context)\n\n\nclass Break(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Break` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('break')\n    >>> node\n    <Break l.1 at 0x7f23b2e9e5c0>\n    \"\"\"\n\n\nclass Call(NodeNG):\n    \"\"\"Class representing an :class:`ast.Call` node.\n\n    A :class:`Call` node is a call to a function, method, etc.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('function()')\n    >>> node\n    <Call l.1 at 0x7f23b2e71eb8>\n    \"\"\"\n\n    _astroid_fields = (\"func\", \"args\", \"keywords\")\n\n    func: NodeNG\n    \"\"\"What is being called.\"\"\"\n\n    args: list[NodeNG]\n    \"\"\"The positional arguments being given to the call.\"\"\"\n\n    keywords: list[Keyword]\n    \"\"\"The keyword arguments being given to the call.\"\"\"\n\n    def postinit(\n        self, func: NodeNG, args: list[NodeNG], keywords: list[Keyword]\n    ) -> None:\n        self.func = func\n        self.args = args\n        self.keywords = keywords\n\n    @property\n    def starargs(self) -> list[Starred]:\n        \"\"\"The positional arguments that unpack something.\"\"\"\n        return [arg for arg in self.args if isinstance(arg, Starred)]\n\n    @property\n    def kwargs(self) -> list[Keyword]:\n        \"\"\"The keyword arguments that unpack something.\"\"\"\n        return [keyword for keyword in self.keywords if keyword.arg is None]\n\n    def get_children(self):\n        yield self.func\n\n        yield from self.args\n\n        yield from self.keywords\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n        \"\"\"Infer a Call node by trying to guess what the function returns.\"\"\"\n        callcontext = copy_context(context)\n        callcontext.boundnode = None\n        if context is not None:\n            callcontext.extra_context = self._populate_context_lookup(context.clone())\n\n        for callee in self.func.infer(context):\n            if isinstance(callee, util.UninferableBase):\n                yield callee\n                continue\n            try:\n                if hasattr(callee, \"infer_call_result\"):\n                    callcontext.callcontext = CallContext(\n                        args=self.args, keywords=self.keywords, callee=callee\n                    )\n                    yield from callee.infer_call_result(\n                        caller=self, context=callcontext\n                    )\n            except InferenceError:\n                continue\n        return InferenceErrorInfo(node=self, context=context)\n\n    def _populate_context_lookup(self, context: InferenceContext | None):\n        \"\"\"Allows context to be saved for later for inference inside a function.\"\"\"\n        context_lookup: dict[InferenceResult, InferenceContext] = {}\n        if context is None:\n            return context_lookup\n        for arg in self.args:\n            if isinstance(arg, Starred):\n                context_lookup[arg.value] = context\n            else:\n                context_lookup[arg] = context\n        keywords = self.keywords if self.keywords is not None else []\n        for keyword in keywords:\n            context_lookup[keyword.value] = context\n        return context_lookup\n\n\nCOMPARE_OPS: dict[str, Callable[[Any, Any], bool]] = {\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \">\": operator.gt,\n    \">=\": operator.ge,\n    \"in\": lambda a, b: a in b,\n    \"not in\": lambda a, b: a not in b,\n}\nUNINFERABLE_OPS = {\n    \"is\",\n    \"is not\",\n}\n\n\nclass Compare(NodeNG):\n    \"\"\"Class representing an :class:`ast.Compare` node.\n\n    A :class:`Compare` node indicates a comparison.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('a <= b <= c')\n    >>> node\n    <Compare l.1 at 0x7f23b2e9e6d8>\n    >>> node.ops\n    [('<=', <Name.b l.1 at 0x7f23b2e9e2b0>), ('<=', <Name.c l.1 at 0x7f23b2e9e390>)]\n    \"\"\"\n\n    _astroid_fields = (\"left\", \"ops\")\n\n    left: NodeNG\n    \"\"\"The value at the left being applied to a comparison operator.\"\"\"\n\n    ops: list[tuple[str, NodeNG]]\n    \"\"\"The remainder of the operators and their relevant right hand value.\"\"\"\n\n    def postinit(self, left: NodeNG, ops: list[tuple[str, NodeNG]]) -> None:\n        self.left = left\n        self.ops = ops\n\n    def get_children(self):\n        \"\"\"Get the child nodes below this node.\n\n        Overridden to handle the tuple fields and skip returning the operator\n        strings.\n\n        :returns: The children.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        yield self.left\n        for _, comparator in self.ops:\n            yield comparator  # we don't want the 'op'\n\n    def last_child(self):\n        \"\"\"An optimized version of list(get_children())[-1]\n\n        :returns: The last child.\n        :rtype: NodeNG\n        \"\"\"\n        # XXX maybe if self.ops:\n        return self.ops[-1][1]\n        # return self.left\n\n    # TODO: move to util?\n    @staticmethod\n    def _to_literal(node: SuccessfulInferenceResult) -> Any:\n        # Can raise SyntaxError or ValueError from ast.literal_eval\n        # Can raise AttributeError from node.as_string() as not all nodes have a visitor\n        # Is this the stupidest idea or the simplest idea?\n        return ast.literal_eval(node.as_string())\n\n    def _do_compare(\n        self,\n        left_iter: Iterable[InferenceResult],\n        op: str,\n        right_iter: Iterable[InferenceResult],\n    ) -> bool | util.UninferableBase:\n        \"\"\"\n        If all possible combinations are either True or False, return that:\n        >>> _do_compare([1, 2], '<=', [3, 4])\n        True\n        >>> _do_compare([1, 2], '==', [3, 4])\n        False\n\n        If any item is uninferable, or if some combinations are True and some\n        are False, return Uninferable:\n        >>> _do_compare([1, 3], '<=', [2, 4])\n        util.Uninferable\n        \"\"\"\n        retval: bool | None = None\n        if op in UNINFERABLE_OPS:\n            return util.Uninferable\n        op_func = COMPARE_OPS[op]\n\n        for left, right in itertools.product(left_iter, right_iter):\n            if isinstance(left, util.UninferableBase) or isinstance(\n                right, util.UninferableBase\n            ):\n                return util.Uninferable\n\n            try:\n                left, right = self._to_literal(left), self._to_literal(right)\n            except (SyntaxError, ValueError, AttributeError):\n                return util.Uninferable\n\n            try:\n                expr = op_func(left, right)\n            except TypeError as exc:\n                raise AstroidTypeError from exc\n\n            if retval is None:\n                retval = expr\n            elif retval != expr:\n                return util.Uninferable\n                # (or both, but \"True | False\" is basically the same)\n\n        assert retval is not None\n        return retval  # it was all the same value\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[nodes.Const | util.UninferableBase]:\n        \"\"\"Chained comparison inference logic.\"\"\"\n        retval: bool | util.UninferableBase = True\n\n        ops = self.ops\n        left_node = self.left\n        lhs = list(left_node.infer(context=context))\n        # should we break early if first element is uninferable?\n        for op, right_node in ops:\n            # eagerly evaluate rhs so that values can be re-used as lhs\n            rhs = list(right_node.infer(context=context))\n            try:\n                retval = self._do_compare(lhs, op, rhs)\n            except AstroidTypeError:\n                retval = util.Uninferable\n                break\n            if retval is not True:\n                break  # short-circuit\n            lhs = rhs  # continue\n        if retval is util.Uninferable:\n            yield retval  # type: ignore[misc]\n        else:\n            yield Const(retval)\n\n\nclass Comprehension(NodeNG):\n    \"\"\"Class representing an :class:`ast.comprehension` node.\n\n    A :class:`Comprehension` indicates the loop inside any type of\n    comprehension including generator expressions.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('[x for x in some_values]')\n    >>> list(node.get_children())\n    [<Name.x l.1 at 0x7f23b2e352b0>, <Comprehension l.1 at 0x7f23b2e35320>]\n    >>> list(node.get_children())[1].as_string()\n    'for x in some_values'\n    \"\"\"\n\n    _astroid_fields = (\"target\", \"iter\", \"ifs\")\n    _other_fields = (\"is_async\",)\n\n    optional_assign = True\n    \"\"\"Whether this node optionally assigns a variable.\"\"\"\n\n    target: NodeNG\n    \"\"\"What is assigned to by the comprehension.\"\"\"\n\n    iter: NodeNG\n    \"\"\"What is iterated over by the comprehension.\"\"\"\n\n    ifs: list[NodeNG]\n    \"\"\"The contents of any if statements that filter the comprehension.\"\"\"\n\n    is_async: bool\n    \"\"\"Whether this is an asynchronous comprehension or not.\"\"\"\n\n    def postinit(\n        self,\n        target: NodeNG,\n        iter: NodeNG,  # pylint: disable = redefined-builtin\n        ifs: list[NodeNG],\n        is_async: bool,\n    ) -> None:\n        self.target = target\n        self.iter = iter\n        self.ifs = ifs\n        self.is_async = is_async\n\n    assigned_stmts = protocols.for_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def assign_type(self):\n        \"\"\"The type of assignment that this node performs.\n\n        :returns: The assignment type.\n        :rtype: NodeNG\n        \"\"\"\n        return self\n\n    def _get_filtered_stmts(\n        self, lookup_node, node, stmts, mystmt: _base_nodes.Statement | None\n    ):\n        \"\"\"method used in filter_stmts\"\"\"\n        if self is mystmt:\n            if isinstance(lookup_node, (Const, Name)):\n                return [lookup_node], True\n\n        elif self.statement() is mystmt:\n            # original node's statement is the assignment, only keeps\n            # current node (gen exp, list comp)\n\n            return [node], True\n\n        return stmts, False\n\n    def get_children(self):\n        yield self.target\n        yield self.iter\n\n        yield from self.ifs\n\n\nclass Const(_base_nodes.NoChildrenNode, Instance):\n    \"\"\"Class representing any constant including num, str, bool, None, bytes.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('(5, \"This is a string.\", True, None, b\"bytes\")')\n    >>> node\n    <Tuple.tuple l.1 at 0x7f23b2e358d0>\n    >>> list(node.get_children())\n    [<Const.int l.1 at 0x7f23b2e35940>,\n    <Const.str l.1 at 0x7f23b2e35978>,\n    <Const.bool l.1 at 0x7f23b2e359b0>,\n    <Const.NoneType l.1 at 0x7f23b2e359e8>,\n    <Const.bytes l.1 at 0x7f23b2e35a20>]\n    \"\"\"\n\n    _other_fields = (\"value\", \"kind\")\n\n    def __init__(\n        self,\n        value: Any,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG = SYNTHETIC_ROOT,\n        kind: str | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param value: The value that the constant represents.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param kind: The string prefix. \"u\" for u-prefixed strings and ``None`` otherwise. Python 3.8+ only.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        if getattr(value, \"__name__\", None) == \"__doc__\":\n            warnings.warn(  # pragma: no cover\n                \"You have most likely called a __doc__ field of some object \"\n                \"and it didn't return a string. \"\n                \"That happens to some symbols from the standard library. \"\n                \"Check for isinstance(<X>.__doc__, str).\",\n                RuntimeWarning,\n                stacklevel=0,\n            )\n        self.value = value\n        \"\"\"The value that the constant represents.\"\"\"\n\n        self.kind: str | None = kind  # can be None\n        \"\"\"\"The string prefix. \"u\" for u-prefixed strings and ``None`` otherwise. Python 3.8+ only.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n        Instance.__init__(self, None)\n\n    infer_unary_op = protocols.const_infer_unary_op\n    infer_binary_op = protocols.const_infer_binary_op\n\n    def __getattr__(self, name):\n        # This is needed because of Proxy's __getattr__ method.\n        # Calling object.__new__ on this class without calling\n        # __init__ would result in an infinite loop otherwise\n        # since __getattr__ is called when an attribute doesn't\n        # exist and self._proxied indirectly calls self.value\n        # and Proxy __getattr__ calls self.value\n        if name == \"value\":\n            raise AttributeError\n        return super().__getattr__(name)\n\n    def getitem(self, index, context: InferenceContext | None = None):\n        \"\"\"Get an item from this node if subscriptable.\n\n        :param index: The node to use as a subscript index.\n        :type index: Const or Slice\n\n        :raises AstroidTypeError: When the given index cannot be used as a\n            subscript index, or if this node is not subscriptable.\n        \"\"\"\n        if isinstance(index, Const):\n            index_value = index.value\n        elif isinstance(index, Slice):\n            index_value = _infer_slice(index, context=context)\n\n        else:\n            raise AstroidTypeError(\n                f\"Could not use type {type(index)} as subscript index\"\n            )\n\n        try:\n            if isinstance(self.value, (str, bytes)):\n                return Const(self.value[index_value])\n        except ValueError as exc:\n            raise AstroidValueError(\n                f\"Could not index {self.value!r} with {index_value!r}\"\n            ) from exc\n        except IndexError as exc:\n            raise AstroidIndexError(\n                message=\"Index {index!r} out of range\",\n                node=self,\n                index=index,\n                context=context,\n            ) from exc\n        except TypeError as exc:\n            raise AstroidTypeError(\n                message=\"Type error {error!r}\", node=self, index=index, context=context\n            ) from exc\n\n        raise AstroidTypeError(f\"{self!r} (value={self.value})\")\n\n    def has_dynamic_getattr(self) -> bool:\n        \"\"\"Check if the node has a custom __getattr__ or __getattribute__.\n\n        :returns: Whether the class has a custom __getattr__ or __getattribute__.\n            For a :class:`Const` this is always ``False``.\n        \"\"\"\n        return False\n\n    def itered(self):\n        \"\"\"An iterator over the elements this node contains.\n\n        :returns: The contents of this node.\n        :rtype: iterable(Const)\n\n        :raises TypeError: If this node does not represent something that is iterable.\n        \"\"\"\n        if isinstance(self.value, str):\n            return [const_factory(elem) for elem in self.value]\n        raise TypeError(f\"Cannot iterate over type {type(self.value)!r}\")\n\n    def pytype(self) -> str:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return self._proxied.qname()\n\n    def bool_value(self, context: InferenceContext | None = None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n        :rtype: bool\n        \"\"\"\n        return bool(self.value)\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[Const]:\n        yield self\n\n\nclass Continue(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Continue` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('continue')\n    >>> node\n    <Continue l.1 at 0x7f23b2e35588>\n    \"\"\"\n\n\nclass Decorators(NodeNG):\n    \"\"\"A node representing a list of decorators.\n\n    A :class:`Decorators` is the decorators that are applied to\n    a method or function.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    @property\n    def my_property(self):\n        return 3\n    ''')\n    >>> node\n    <FunctionDef.my_property l.2 at 0x7f23b2e35d30>\n    >>> list(node.get_children())[0]\n    <Decorators l.1 at 0x7f23b2e35d68>\n    \"\"\"\n\n    _astroid_fields = (\"nodes\",)\n\n    nodes: list[NodeNG]\n    \"\"\"The decorators that this node contains.\"\"\"\n\n    def postinit(self, nodes: list[NodeNG]) -> None:\n        self.nodes = nodes\n\n    def scope(self) -> LocalsDictNodeNG:\n        \"\"\"The first parent node defining a new scope.\n        These can be Module, FunctionDef, ClassDef, Lambda, or GeneratorExp nodes.\n\n        :returns: The first parent scope node.\n        \"\"\"\n        # skip the function node to go directly to the upper level scope\n        if not self.parent:\n            raise ParentMissingError(target=self)\n        if not self.parent.parent:\n            raise ParentMissingError(target=self.parent)\n        return self.parent.parent.scope()\n\n    def get_children(self):\n        yield from self.nodes\n\n\nclass DelAttr(_base_nodes.ParentAssignNode):\n    \"\"\"Variation of :class:`ast.Delete` representing deletion of an attribute.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('del self.attr')\n    >>> node\n    <Delete l.1 at 0x7f23b2e35f60>\n    >>> list(node.get_children())[0]\n    <DelAttr.attr l.1 at 0x7f23b2e411d0>\n    \"\"\"\n\n    _astroid_fields = (\"expr\",)\n    _other_fields = (\"attrname\",)\n\n    expr: NodeNG\n    \"\"\"The name that this node represents.\"\"\"\n\n    def __init__(\n        self,\n        attrname: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.attrname = attrname\n        \"\"\"The name of the attribute that is being deleted.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, expr: NodeNG) -> None:\n        self.expr = expr\n\n    def get_children(self):\n        yield self.expr\n\n\nclass Delete(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Delete` node.\n\n    A :class:`Delete` is a ``del`` statement this is deleting something.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('del self.attr')\n    >>> node\n    <Delete l.1 at 0x7f23b2e35f60>\n    \"\"\"\n\n    _astroid_fields = (\"targets\",)\n\n    def __init__(\n        self,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.targets: list[NodeNG] = []\n        \"\"\"What is being deleted.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, targets: list[NodeNG]) -> None:\n        self.targets = targets\n\n    def get_children(self):\n        yield from self.targets\n\n\nclass Dict(NodeNG, Instance):\n    \"\"\"Class representing an :class:`ast.Dict` node.\n\n    A :class:`Dict` is a dictionary that is created with ``{}`` syntax.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('{1: \"1\"}')\n    >>> node\n    <Dict.dict l.1 at 0x7f23b2e35cc0>\n    \"\"\"\n\n    _astroid_fields = (\"items\",)\n\n    def __init__(\n        self,\n        lineno: int | None,\n        col_offset: int | None,\n        parent: NodeNG | None,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.items: list[tuple[InferenceResult, InferenceResult]] = []\n        \"\"\"The key-value pairs contained in the dictionary.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, items: list[tuple[InferenceResult, InferenceResult]]) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param items: The key-value pairs contained in the dictionary.\n        \"\"\"\n        self.items = items\n\n    infer_unary_op = protocols.dict_infer_unary_op\n\n    def pytype(self) -> Literal[\"builtins.dict\"]:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return \"builtins.dict\"\n\n    def get_children(self):\n        \"\"\"Get the key and value nodes below this node.\n\n        Children are returned in the order that they are defined in the source\n        code, key first then the value.\n\n        :returns: The children.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        for key, value in self.items:\n            yield key\n            yield value\n\n    def last_child(self):\n        \"\"\"An optimized version of list(get_children())[-1]\n\n        :returns: The last child, or None if no children exist.\n        :rtype: NodeNG or None\n        \"\"\"\n        if self.items:\n            return self.items[-1][1]\n        return None\n\n    def itered(self):\n        \"\"\"An iterator over the keys this node contains.\n\n        :returns: The keys of this node.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        return [key for (key, _) in self.items]\n\n    def getitem(\n        self, index: Const | Slice, context: InferenceContext | None = None\n    ) -> NodeNG:\n        \"\"\"Get an item from this node.\n\n        :param index: The node to use as a subscript index.\n\n        :raises AstroidTypeError: When the given index cannot be used as a\n            subscript index, or if this node is not subscriptable.\n        :raises AstroidIndexError: If the given index does not exist in the\n            dictionary.\n        \"\"\"\n        for key, value in self.items:\n            # TODO(cpopa): no support for overriding yet, {1:2, **{1: 3}}.\n            if isinstance(key, DictUnpack):\n                inferred_value = util.safe_infer(value, context)\n                if not isinstance(inferred_value, Dict):\n                    continue\n\n                try:\n                    return inferred_value.getitem(index, context)\n                except (AstroidTypeError, AstroidIndexError):\n                    continue\n\n            for inferredkey in key.infer(context):\n                if isinstance(inferredkey, util.UninferableBase):\n                    continue\n                if isinstance(inferredkey, Const) and isinstance(index, Const):\n                    if inferredkey.value == index.value:\n                        return value\n\n        raise AstroidIndexError(index)\n\n    def bool_value(self, context: InferenceContext | None = None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n        :rtype: bool\n        \"\"\"\n        return bool(self.items)\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[nodes.Dict]:\n        if not any(isinstance(k, DictUnpack) for k, _ in self.items):\n            yield self\n        else:\n            items = self._infer_map(context)\n            new_seq = type(self)(\n                lineno=self.lineno,\n                col_offset=self.col_offset,\n                parent=self.parent,\n                end_lineno=self.end_lineno,\n                end_col_offset=self.end_col_offset,\n            )\n            new_seq.postinit(list(items.items()))\n            yield new_seq\n\n    @staticmethod\n    def _update_with_replacement(\n        lhs_dict: dict[SuccessfulInferenceResult, SuccessfulInferenceResult],\n        rhs_dict: dict[SuccessfulInferenceResult, SuccessfulInferenceResult],\n    ) -> dict[SuccessfulInferenceResult, SuccessfulInferenceResult]:\n        \"\"\"Delete nodes that equate to duplicate keys.\n\n        Since an astroid node doesn't 'equal' another node with the same value,\n        this function uses the as_string method to make sure duplicate keys\n        don't get through\n\n        Note that both the key and the value are astroid nodes\n\n        Fixes issue with DictUnpack causing duplicate keys\n        in inferred Dict items\n\n        :param lhs_dict: Dictionary to 'merge' nodes into\n        :param rhs_dict: Dictionary with nodes to pull from\n        :return : merged dictionary of nodes\n        \"\"\"\n        combined_dict = itertools.chain(lhs_dict.items(), rhs_dict.items())\n        # Overwrite keys which have the same string values\n        string_map = {key.as_string(): (key, value) for key, value in combined_dict}\n        # Return to dictionary\n        return dict(string_map.values())\n\n    def _infer_map(\n        self, context: InferenceContext | None\n    ) -> dict[SuccessfulInferenceResult, SuccessfulInferenceResult]:\n        \"\"\"Infer all values based on Dict.items.\"\"\"\n        values: dict[SuccessfulInferenceResult, SuccessfulInferenceResult] = {}\n        for name, value in self.items:\n            if isinstance(name, DictUnpack):\n                double_starred = util.safe_infer(value, context)\n                if not double_starred:\n                    raise InferenceError\n                if not isinstance(double_starred, Dict):\n                    raise InferenceError(node=self, context=context)\n                unpack_items = double_starred._infer_map(context)\n                values = self._update_with_replacement(values, unpack_items)\n            else:\n                key = util.safe_infer(name, context=context)\n                safe_value = util.safe_infer(value, context=context)\n                if any(not elem for elem in (key, safe_value)):\n                    raise InferenceError(node=self, context=context)\n                # safe_value is SuccessfulInferenceResult as bool(Uninferable) == False\n                values = self._update_with_replacement(values, {key: safe_value})\n        return values\n\n\nclass Expr(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Expr` node.\n\n    An :class:`Expr` is any expression that does not have its value used or\n    stored.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('method()')\n    >>> node\n    <Call l.1 at 0x7f23b2e352b0>\n    >>> node.parent\n    <Expr l.1 at 0x7f23b2e35278>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n\n    value: NodeNG\n    \"\"\"What the expression does.\"\"\"\n\n    def postinit(self, value: NodeNG) -> None:\n        self.value = value\n\n    def get_children(self):\n        yield self.value\n\n    def _get_yield_nodes_skip_functions(self):\n        if not self.value.is_function:\n            yield from self.value._get_yield_nodes_skip_functions()\n\n    def _get_yield_nodes_skip_lambdas(self):\n        if not self.value.is_lambda:\n            yield from self.value._get_yield_nodes_skip_lambdas()\n\n\nclass EmptyNode(_base_nodes.NoChildrenNode):\n    \"\"\"Holds an arbitrary object in the :attr:`LocalsDictNodeNG.locals`.\"\"\"\n\n    object = None\n\n    def __init__(\n        self,\n        lineno: None = None,\n        col_offset: None = None,\n        parent: NodeNG = SYNTHETIC_ROOT,\n        *,\n        end_lineno: None = None,\n        end_col_offset: None = None,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def has_underlying_object(self) -> bool:\n        return self.object is not None and self.object is not _EMPTY_OBJECT_MARKER\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        if not self.has_underlying_object():\n            yield util.Uninferable\n        else:\n            try:\n                yield from AstroidManager().infer_ast_from_something(\n                    self.object, context=context\n                )\n            except AstroidError:\n                yield util.Uninferable\n\n\nclass ExceptHandler(\n    _base_nodes.MultiLineBlockNode, _base_nodes.AssignTypeNode, _base_nodes.Statement\n):\n    \"\"\"Class representing an :class:`ast.ExceptHandler`. node.\n\n    An :class:`ExceptHandler` is an ``except`` block on a try-except.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n        try:\n            do_something()\n        except Exception as error:\n            print(\"Error!\")\n        ''')\n    >>> node\n    <Try l.2 at 0x7f23b2e9d908>\n    >>> node.handlers\n    [<ExceptHandler l.4 at 0x7f23b2e9e860>]\n    \"\"\"\n\n    _astroid_fields = (\"type\", \"name\", \"body\")\n    _multi_line_block_fields = (\"body\",)\n\n    type: NodeNG | None\n    \"\"\"The types that the block handles.\"\"\"\n\n    name: AssignName | None\n    \"\"\"The name that the caught exception is assigned to.\"\"\"\n\n    body: list[NodeNG]\n    \"\"\"The contents of the block.\"\"\"\n\n    assigned_stmts = protocols.excepthandler_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def postinit(\n        self,\n        type: NodeNG | None,  # pylint: disable = redefined-builtin\n        name: AssignName | None,\n        body: list[NodeNG],\n    ) -> None:\n        self.type = type\n        self.name = name\n        self.body = body\n\n    def get_children(self):\n        if self.type is not None:\n            yield self.type\n\n        if self.name is not None:\n            yield self.name\n\n        yield from self.body\n\n    @cached_property\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        if self.name:\n            return self.name.tolineno\n        if self.type:\n            return self.type.tolineno\n        return self.lineno\n\n    def catch(self, exceptions: list[str] | None) -> bool:\n        \"\"\"Check if this node handles any of the given\n\n        :param exceptions: The names of the exceptions to check for.\n        \"\"\"\n        if self.type is None or exceptions is None:\n            return True\n        return any(node.name in exceptions for node in self.type._get_name_nodes())\n\n\nclass For(\n    _base_nodes.MultiLineWithElseBlockNode,\n    _base_nodes.AssignTypeNode,\n    _base_nodes.Statement,\n):\n    \"\"\"Class representing an :class:`ast.For` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('for thing in things: print(thing)')\n    >>> node\n    <For l.1 at 0x7f23b2e8cf28>\n    \"\"\"\n\n    _astroid_fields = (\"target\", \"iter\", \"body\", \"orelse\")\n    _other_other_fields = (\"type_annotation\",)\n    _multi_line_block_fields = (\"body\", \"orelse\")\n\n    optional_assign = True\n    \"\"\"Whether this node optionally assigns a variable.\n\n    This is always ``True`` for :class:`For` nodes.\n    \"\"\"\n\n    target: NodeNG\n    \"\"\"What the loop assigns to.\"\"\"\n\n    iter: NodeNG\n    \"\"\"What the loop iterates over.\"\"\"\n\n    body: list[NodeNG]\n    \"\"\"The contents of the body of the loop.\"\"\"\n\n    orelse: list[NodeNG]\n    \"\"\"The contents of the ``else`` block of the loop.\"\"\"\n\n    type_annotation: NodeNG | None\n    \"\"\"If present, this will contain the type annotation passed by a type comment\"\"\"\n\n    def postinit(\n        self,\n        target: NodeNG,\n        iter: NodeNG,  # pylint: disable = redefined-builtin\n        body: list[NodeNG],\n        orelse: list[NodeNG],\n        type_annotation: NodeNG | None,\n    ) -> None:\n        self.target = target\n        self.iter = iter\n        self.body = body\n        self.orelse = orelse\n        self.type_annotation = type_annotation\n\n    assigned_stmts = protocols.for_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    @cached_property\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.iter.tolineno\n\n    def get_children(self):\n        yield self.target\n        yield self.iter\n\n        yield from self.body\n        yield from self.orelse\n\n\nclass AsyncFor(For):\n    \"\"\"Class representing an :class:`ast.AsyncFor` node.\n\n    An :class:`AsyncFor` is an asynchronous :class:`For` built with\n    the ``async`` keyword.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    async def func(things):\n        async for thing in things:\n            print(thing)\n    ''')\n    >>> node\n    <AsyncFunctionDef.func l.2 at 0x7f23b2e416d8>\n    >>> node.body[0]\n    <AsyncFor l.3 at 0x7f23b2e417b8>\n    \"\"\"\n\n\nclass Await(NodeNG):\n    \"\"\"Class representing an :class:`ast.Await` node.\n\n    An :class:`Await` is the ``await`` keyword.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    async def func(things):\n        await other_func()\n    ''')\n    >>> node\n    <AsyncFunctionDef.func l.2 at 0x7f23b2e41748>\n    >>> node.body[0]\n    <Expr l.3 at 0x7f23b2e419e8>\n    >>> list(node.body[0].get_children())[0]\n    <Await l.3 at 0x7f23b2e41a20>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n\n    value: NodeNG\n    \"\"\"What to wait for.\"\"\"\n\n    def postinit(self, value: NodeNG) -> None:\n        self.value = value\n\n    def get_children(self):\n        yield self.value\n\n\nclass ImportFrom(_base_nodes.ImportNode):\n    \"\"\"Class representing an :class:`ast.ImportFrom` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('from my_package import my_module')\n    >>> node\n    <ImportFrom l.1 at 0x7f23b2e415c0>\n    \"\"\"\n\n    _other_fields = (\"modname\", \"names\", \"level\")\n\n    def __init__(\n        self,\n        fromname: str | None,\n        names: list[tuple[str, str | None]],\n        level: int | None = 0,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param fromname: The module that is being imported from.\n\n        :param names: What is being imported from the module.\n\n        :param level: The level of relative import.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.modname: str | None = fromname  # can be None\n        \"\"\"The module that is being imported from.\n\n        This is ``None`` for relative imports.\n        \"\"\"\n\n        self.names: list[tuple[str, str | None]] = names\n        \"\"\"What is being imported from the module.\n\n        Each entry is a :class:`tuple` of the name being imported,\n        and the alias that the name is assigned to (if any).\n        \"\"\"\n\n        # TODO When is 'level' None?\n        self.level: int | None = level  # can be None\n        \"\"\"The level of relative import.\n\n        Essentially this is the number of dots in the import.\n        This is always 0 for absolute imports.\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self,\n        context: InferenceContext | None = None,\n        asname: bool = True,\n        **kwargs: Any,\n    ) -> Generator[InferenceResult]:\n        \"\"\"Infer a ImportFrom node: return the imported module/object.\"\"\"\n        context = context or InferenceContext()\n        name = context.lookupname\n        if name is None:\n            raise InferenceError(node=self, context=context)\n        if asname:\n            try:\n                name = self.real_name(name)\n            except AttributeInferenceError as exc:\n                # See https://github.com/pylint-dev/pylint/issues/4692\n                raise InferenceError(node=self, context=context) from exc\n        try:\n            module = self.do_import_module()\n        except AstroidBuildingError as exc:\n            raise InferenceError(node=self, context=context) from exc\n\n        try:\n            context = copy_context(context)\n            context.lookupname = name\n            stmts = module.getattr(name, ignore_locals=module is self.root())\n            return _infer_stmts(stmts, context)\n        except AttributeInferenceError as error:\n            raise InferenceError(\n                str(error), target=self, attribute=name, context=context\n            ) from error\n\n\nclass Attribute(NodeNG):\n    \"\"\"Class representing an :class:`ast.Attribute` node.\"\"\"\n\n    expr: NodeNG\n\n    _astroid_fields = (\"expr\",)\n    _other_fields = (\"attrname\",)\n\n    def __init__(\n        self,\n        attrname: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.attrname = attrname\n        \"\"\"The name of the attribute.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, expr: NodeNG) -> None:\n        self.expr = expr\n\n    def get_children(self):\n        yield self.expr\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n        return _infer_attribute(self, context, **kwargs)\n\n\nclass Global(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Global` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('global a_global')\n    >>> node\n    <Global l.1 at 0x7f23b2e9de10>\n    \"\"\"\n\n    _other_fields = (\"names\",)\n\n    def __init__(\n        self,\n        names: list[str],\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param names: The names being declared as global.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.names: list[str] = names\n        \"\"\"The names being declared as global.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def _infer_name(self, frame, name):\n        return name\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        if context is None or context.lookupname is None:\n            raise InferenceError(node=self, context=context)\n        try:\n            # pylint: disable-next=no-member\n            return _infer_stmts(self.root().getattr(context.lookupname), context)\n        except AttributeInferenceError as error:\n            raise InferenceError(\n                str(error), target=self, attribute=context.lookupname, context=context\n            ) from error\n\n\nclass If(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.If` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('if condition: print(True)')\n    >>> node\n    <If l.1 at 0x7f23b2e9dd30>\n    \"\"\"\n\n    _astroid_fields = (\"test\", \"body\", \"orelse\")\n    _multi_line_block_fields = (\"body\", \"orelse\")\n\n    test: NodeNG\n    \"\"\"The condition that the statement tests.\"\"\"\n\n    body: list[NodeNG]\n    \"\"\"The contents of the block.\"\"\"\n\n    orelse: list[NodeNG]\n    \"\"\"The contents of the ``else`` block.\"\"\"\n\n    def postinit(self, test: NodeNG, body: list[NodeNG], orelse: list[NodeNG]) -> None:\n        self.test = test\n        self.body = body\n        self.orelse = orelse\n\n    @cached_property\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.test.tolineno\n\n    def block_range(self, lineno: int) -> tuple[int, int]:\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: The line number to start the range at.\n\n        :returns: The range of line numbers that this node belongs to,\n            starting at the given line number.\n        \"\"\"\n        if lineno == self.body[0].fromlineno:\n            return lineno, lineno\n        if lineno <= self.body[-1].tolineno:\n            return lineno, self.body[-1].tolineno\n        return self._elsed_block_range(lineno, self.orelse, self.body[0].fromlineno - 1)\n\n    def get_children(self):\n        yield self.test\n\n        yield from self.body\n        yield from self.orelse\n\n    def has_elif_block(self) -> bool:\n        return len(self.orelse) == 1 and isinstance(self.orelse[0], If)\n\n    def _get_yield_nodes_skip_functions(self):\n        \"\"\"An If node can contain a Yield node in the test\"\"\"\n        yield from self.test._get_yield_nodes_skip_functions()\n        yield from super()._get_yield_nodes_skip_functions()\n\n    def _get_yield_nodes_skip_lambdas(self):\n        \"\"\"An If node can contain a Yield node in the test\"\"\"\n        yield from self.test._get_yield_nodes_skip_lambdas()\n        yield from super()._get_yield_nodes_skip_lambdas()\n\n\nclass IfExp(NodeNG):\n    \"\"\"Class representing an :class:`ast.IfExp` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('value if condition else other')\n    >>> node\n    <IfExp l.1 at 0x7f23b2e9dbe0>\n    \"\"\"\n\n    _astroid_fields = (\"test\", \"body\", \"orelse\")\n\n    test: NodeNG\n    \"\"\"The condition that the statement tests.\"\"\"\n\n    body: NodeNG\n    \"\"\"The contents of the block.\"\"\"\n\n    orelse: NodeNG\n    \"\"\"The contents of the ``else`` block.\"\"\"\n\n    def postinit(self, test: NodeNG, body: NodeNG, orelse: NodeNG) -> None:\n        self.test = test\n        self.body = body\n        self.orelse = orelse\n\n    def get_children(self):\n        yield self.test\n        yield self.body\n        yield self.orelse\n\n    def op_left_associative(self) -> Literal[False]:\n        # `1 if True else 2 if False else 3` is parsed as\n        # `1 if True else (2 if False else 3)`\n        return False\n\n    @decorators.raise_if_nothing_inferred\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult]:\n        \"\"\"Support IfExp inference.\n\n        If we can't infer the truthiness of the condition, we default\n        to inferring both branches. Otherwise, we infer either branch\n        depending on the condition.\n        \"\"\"\n        both_branches = False\n        # We use two separate contexts for evaluating lhs and rhs because\n        # evaluating lhs may leave some undesired entries in context.path\n        # which may not let us infer right value of rhs.\n\n        context = context or InferenceContext()\n        lhs_context = copy_context(context)\n        rhs_context = copy_context(context)\n        try:\n            test = next(self.test.infer(context=context.clone()))\n        except (InferenceError, StopIteration):\n            both_branches = True\n        else:\n            if not isinstance(test, util.UninferableBase):\n                if test.bool_value():\n                    yield from self.body.infer(context=lhs_context)\n                else:\n                    yield from self.orelse.infer(context=rhs_context)\n            else:\n                both_branches = True\n        if both_branches:\n            yield from self.body.infer(context=lhs_context)\n            yield from self.orelse.infer(context=rhs_context)\n\n\nclass Import(_base_nodes.ImportNode):\n    \"\"\"Class representing an :class:`ast.Import` node.\n    >>> import astroid\n    >>> node = astroid.extract_node('import astroid')\n    >>> node\n    <Import l.1 at 0x7f23b2e4e5c0>\n    \"\"\"\n\n    _other_fields = (\"names\",)\n\n    def __init__(\n        self,\n        names: list[tuple[str, str | None]],\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param names: The names being imported.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.names: list[tuple[str, str | None]] = names\n        \"\"\"The names being imported.\n\n        Each entry is a :class:`tuple` of the name being imported,\n        and the alias that the name is assigned to (if any).\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self,\n        context: InferenceContext | None = None,\n        asname: bool = True,\n        **kwargs: Any,\n    ) -> Generator[nodes.Module]:\n        \"\"\"Infer an Import node: return the imported module/object.\"\"\"\n        context = context or InferenceContext()\n        name = context.lookupname\n        if name is None:\n            raise InferenceError(node=self, context=context)\n\n        try:\n            if asname:\n                yield self.do_import_module(self.real_name(name))\n            else:\n                yield self.do_import_module(name)\n        except AstroidBuildingError as exc:\n            raise InferenceError(node=self, context=context) from exc\n\n\nclass Keyword(NodeNG):\n    \"\"\"Class representing an :class:`ast.keyword` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('function(a_kwarg=True)')\n    >>> node\n    <Call l.1 at 0x7f23b2e9e320>\n    >>> node.keywords\n    [<Keyword l.1 at 0x7f23b2e9e9b0>]\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n    _other_fields = (\"arg\",)\n\n    value: NodeNG\n    \"\"\"The value being assigned to the keyword argument.\"\"\"\n\n    def __init__(\n        self,\n        arg: str | None,\n        lineno: int | None,\n        col_offset: int | None,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.arg = arg\n        \"\"\"The argument being assigned to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, value: NodeNG) -> None:\n        self.value = value\n\n    def get_children(self):\n        yield self.value\n\n\nclass List(BaseContainer):\n    \"\"\"Class representing an :class:`ast.List` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('[1, 2, 3]')\n    >>> node\n    <List.list l.1 at 0x7f23b2e9e128>\n    \"\"\"\n\n    _other_fields = (\"ctx\",)\n\n    def __init__(\n        self,\n        ctx: Context | None = None,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param ctx: Whether the list is assigned to or loaded from.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.ctx: Context | None = ctx\n        \"\"\"Whether the list is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    assigned_stmts = protocols.sequence_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    infer_unary_op = protocols.list_infer_unary_op\n    infer_binary_op = protocols.tl_infer_binary_op\n\n    def pytype(self) -> Literal[\"builtins.list\"]:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return \"builtins.list\"\n\n    def getitem(self, index, context: InferenceContext | None = None):\n        \"\"\"Get an item from this node.\n\n        :param index: The node to use as a subscript index.\n        :type index: Const or Slice\n        \"\"\"\n        return _container_getitem(self, self.elts, index, context=context)\n\n\nclass Nonlocal(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Nonlocal` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    def function():\n        nonlocal var\n    ''')\n    >>> node\n    <FunctionDef.function l.2 at 0x7f23b2e9e208>\n    >>> node.body[0]\n    <Nonlocal l.3 at 0x7f23b2e9e908>\n    \"\"\"\n\n    _other_fields = (\"names\",)\n\n    def __init__(\n        self,\n        names: list[str],\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param names: The names being declared as not local.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.names: list[str] = names\n        \"\"\"The names being declared as not local.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def _infer_name(self, frame, name):\n        return name\n\n\nclass ParamSpec(_base_nodes.AssignTypeNode):\n    \"\"\"Class representing a :class:`ast.ParamSpec` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('type Alias[**P] = Callable[P, int]')\n    >>> node.type_params[0]\n    <ParamSpec l.1 at 0x7f23b2e4e198>\n    \"\"\"\n\n    _astroid_fields = (\"name\",)\n\n    name: AssignName\n\n    def __init__(\n        self,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int,\n        end_col_offset: int,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, name: AssignName) -> None:\n        self.name = name\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[ParamSpec]:\n        yield self\n\n    assigned_stmts = protocols.generic_type_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nclass Pass(_base_nodes.NoChildrenNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Pass` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('pass')\n    >>> node\n    <Pass l.1 at 0x7f23b2e9e748>\n    \"\"\"\n\n\nclass Raise(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Raise` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('raise RuntimeError(\"Something bad happened!\")')\n    >>> node\n    <Raise l.1 at 0x7f23b2e9e828>\n    \"\"\"\n\n    _astroid_fields = (\"exc\", \"cause\")\n\n    exc: NodeNG | None\n    \"\"\"What is being raised.\"\"\"\n\n    cause: NodeNG | None\n    \"\"\"The exception being used to raise this one.\"\"\"\n\n    def postinit(\n        self,\n        exc: NodeNG | None,\n        cause: NodeNG | None,\n    ) -> None:\n        self.exc = exc\n        self.cause = cause\n\n    def raises_not_implemented(self) -> bool:\n        \"\"\"Check if this node raises a :class:`NotImplementedError`.\n\n        :returns: Whether this node raises a :class:`NotImplementedError`.\n        \"\"\"\n        if not self.exc:\n            return False\n        return any(\n            name.name == \"NotImplementedError\" for name in self.exc._get_name_nodes()\n        )\n\n    def get_children(self):\n        if self.exc is not None:\n            yield self.exc\n\n        if self.cause is not None:\n            yield self.cause\n\n\nclass Return(_base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.Return` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('return True')\n    >>> node\n    <Return l.1 at 0x7f23b8211908>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n\n    value: NodeNG | None\n    \"\"\"The value being returned.\"\"\"\n\n    def postinit(self, value: NodeNG | None) -> None:\n        self.value = value\n\n    def get_children(self):\n        if self.value is not None:\n            yield self.value\n\n    def is_tuple_return(self) -> bool:\n        return isinstance(self.value, Tuple)\n\n    def _get_return_nodes_skip_functions(self):\n        yield self\n\n\nclass Set(BaseContainer):\n    \"\"\"Class representing an :class:`ast.Set` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('{1, 2, 3}')\n    >>> node\n    <Set.set l.1 at 0x7f23b2e71d68>\n    \"\"\"\n\n    infer_unary_op = protocols.set_infer_unary_op\n\n    def pytype(self) -> Literal[\"builtins.set\"]:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return \"builtins.set\"\n\n\nclass Slice(NodeNG):\n    \"\"\"Class representing an :class:`ast.Slice` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('things[1:3]')\n    >>> node\n    <Subscript l.1 at 0x7f23b2e71f60>\n    >>> node.slice\n    <Slice l.1 at 0x7f23b2e71e80>\n    \"\"\"\n\n    _astroid_fields = (\"lower\", \"upper\", \"step\")\n\n    lower: NodeNG | None\n    \"\"\"The lower index in the slice.\"\"\"\n\n    upper: NodeNG | None\n    \"\"\"The upper index in the slice.\"\"\"\n\n    step: NodeNG | None\n    \"\"\"The step to take between indexes.\"\"\"\n\n    def postinit(\n        self,\n        lower: NodeNG | None,\n        upper: NodeNG | None,\n        step: NodeNG | None,\n    ) -> None:\n        self.lower = lower\n        self.upper = upper\n        self.step = step\n\n    def _wrap_attribute(self, attr):\n        \"\"\"Wrap the empty attributes of the Slice in a Const node.\"\"\"\n        if not attr:\n            const = const_factory(attr)\n            const.parent = self\n            return const\n        return attr\n\n    @cached_property\n    def _proxied(self) -> nodes.ClassDef:\n        builtins = AstroidManager().builtins_module\n        return builtins.getattr(\"slice\")[0]\n\n    def pytype(self) -> Literal[\"builtins.slice\"]:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return \"builtins.slice\"\n\n    def display_type(self) -> Literal[\"Slice\"]:\n        \"\"\"A human readable type of this node.\n\n        :returns: The type of this node.\n        \"\"\"\n        return \"Slice\"\n\n    def igetattr(\n        self, attrname: str, context: InferenceContext | None = None\n    ) -> Iterator[SuccessfulInferenceResult]:\n        \"\"\"Infer the possible values of the given attribute on the slice.\n\n        :param attrname: The name of the attribute to infer.\n\n        :returns: The inferred possible values.\n        \"\"\"\n        if attrname == \"start\":\n            yield self._wrap_attribute(self.lower)\n        elif attrname == \"stop\":\n            yield self._wrap_attribute(self.upper)\n        elif attrname == \"step\":\n            yield self._wrap_attribute(self.step)\n        else:\n            yield from self.getattr(attrname, context=context)\n\n    def getattr(self, attrname, context: InferenceContext | None = None):\n        return self._proxied.getattr(attrname, context)\n\n    def get_children(self):\n        if self.lower is not None:\n            yield self.lower\n\n        if self.upper is not None:\n            yield self.upper\n\n        if self.step is not None:\n            yield self.step\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[Slice]:\n        yield self\n\n\nclass Starred(_base_nodes.ParentAssignNode):\n    \"\"\"Class representing an :class:`ast.Starred` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('*args')\n    >>> node\n    <Starred l.1 at 0x7f23b2e41978>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n    _other_fields = (\"ctx\",)\n\n    value: NodeNG\n    \"\"\"What is being unpacked.\"\"\"\n\n    def __init__(\n        self,\n        ctx: Context,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.ctx = ctx\n        \"\"\"Whether the starred item is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, value: NodeNG) -> None:\n        self.value = value\n\n    assigned_stmts = protocols.starred_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def get_children(self):\n        yield self.value\n\n\nclass Subscript(NodeNG):\n    \"\"\"Class representing an :class:`ast.Subscript` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('things[1:3]')\n    >>> node\n    <Subscript l.1 at 0x7f23b2e71f60>\n    \"\"\"\n\n    _SUBSCRIPT_SENTINEL = object()\n    _astroid_fields = (\"value\", \"slice\")\n    _other_fields = (\"ctx\",)\n\n    value: NodeNG\n    \"\"\"What is being indexed.\"\"\"\n\n    slice: NodeNG\n    \"\"\"The slice being used to lookup.\"\"\"\n\n    def __init__(\n        self,\n        ctx: Context,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.ctx = ctx\n        \"\"\"Whether the subscripted item is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    # pylint: disable=redefined-builtin; had to use the same name as builtin ast module.\n    def postinit(self, value: NodeNG, slice: NodeNG) -> None:\n        self.value = value\n        self.slice = slice\n\n    def get_children(self):\n        yield self.value\n        yield self.slice\n\n    def _infer_subscript(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        \"\"\"Inference for subscripts.\n\n        We're understanding if the index is a Const\n        or a slice, passing the result of inference\n        to the value's `getitem` method, which should\n        handle each supported index type accordingly.\n        \"\"\"\n        from astroid import helpers  # pylint: disable=import-outside-toplevel\n\n        found_one = False\n        for value in self.value.infer(context):\n            if isinstance(value, util.UninferableBase):\n                yield util.Uninferable\n                return None\n            for index in self.slice.infer(context):\n                if isinstance(index, util.UninferableBase):\n                    yield util.Uninferable\n                    return None\n\n                # Try to deduce the index value.\n                index_value = self._SUBSCRIPT_SENTINEL\n                if value.__class__ == Instance:\n                    index_value = index\n                elif index.__class__ == Instance:\n                    instance_as_index = helpers.class_instance_as_index(index)\n                    if instance_as_index:\n                        index_value = instance_as_index\n                else:\n                    index_value = index\n\n                if index_value is self._SUBSCRIPT_SENTINEL:\n                    raise InferenceError(node=self, context=context)\n\n                try:\n                    assigned = value.getitem(index_value, context)\n                except (\n                    AstroidTypeError,\n                    AstroidIndexError,\n                    AstroidValueError,\n                    AttributeInferenceError,\n                    AttributeError,\n                ) as exc:\n                    raise InferenceError(node=self, context=context) from exc\n\n                # Prevent inferring if the inferred subscript\n                # is the same as the original subscripted object.\n                if self is assigned or isinstance(assigned, util.UninferableBase):\n                    yield util.Uninferable\n                    return None\n                yield from assigned.infer(context)\n                found_one = True\n\n        if found_one:\n            return InferenceErrorInfo(node=self, context=context)\n        return None\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(self, context: InferenceContext | None = None, **kwargs: Any):\n        return self._infer_subscript(context, **kwargs)\n\n    @decorators.raise_if_nothing_inferred\n    def infer_lhs(self, context: InferenceContext | None = None, **kwargs: Any):\n        return self._infer_subscript(context, **kwargs)\n\n\nclass Try(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing a :class:`ast.Try` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n        try:\n            do_something()\n        except Exception as error:\n            print(\"Error!\")\n        finally:\n            print(\"Cleanup!\")\n        ''')\n    >>> node\n    <Try l.2 at 0x7f23b2e41d68>\n    \"\"\"\n\n    _astroid_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n    _multi_line_block_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n\n    def __init__(\n        self,\n        *,\n        lineno: int,\n        col_offset: int,\n        end_lineno: int,\n        end_col_offset: int,\n        parent: NodeNG,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.body: list[NodeNG] = []\n        \"\"\"The contents of the block to catch exceptions from.\"\"\"\n\n        self.handlers: list[ExceptHandler] = []\n        \"\"\"The exception handlers.\"\"\"\n\n        self.orelse: list[NodeNG] = []\n        \"\"\"The contents of the ``else`` block.\"\"\"\n\n        self.finalbody: list[NodeNG] = []\n        \"\"\"The contents of the ``finally`` block.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        body: list[NodeNG],\n        handlers: list[ExceptHandler],\n        orelse: list[NodeNG],\n        finalbody: list[NodeNG],\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param body: The contents of the block to catch exceptions from.\n\n        :param handlers: The exception handlers.\n\n        :param orelse: The contents of the ``else`` block.\n\n        :param finalbody: The contents of the ``finally`` block.\n        \"\"\"\n        self.body = body\n        self.handlers = handlers\n        self.orelse = orelse\n        self.finalbody = finalbody\n\n    def _infer_name(self, frame, name):\n        return name\n\n    def block_range(self, lineno: int) -> tuple[int, int]:\n        \"\"\"Get a range from a given line number to where this node ends.\"\"\"\n        if lineno == self.fromlineno:\n            return lineno, lineno\n        if self.body and self.body[0].fromlineno <= lineno <= self.body[-1].tolineno:\n            # Inside try body - return from lineno till end of try body\n            return lineno, self.body[-1].tolineno\n        for exhandler in self.handlers:\n            if exhandler.type and lineno == exhandler.type.fromlineno:\n                return lineno, lineno\n            if exhandler.body[0].fromlineno <= lineno <= exhandler.body[-1].tolineno:\n                return lineno, exhandler.body[-1].tolineno\n        if self.orelse:\n            if self.orelse[0].fromlineno - 1 == lineno:\n                return lineno, lineno\n            if self.orelse[0].fromlineno <= lineno <= self.orelse[-1].tolineno:\n                return lineno, self.orelse[-1].tolineno\n        if self.finalbody:\n            if self.finalbody[0].fromlineno - 1 == lineno:\n                return lineno, lineno\n            if self.finalbody[0].fromlineno <= lineno <= self.finalbody[-1].tolineno:\n                return lineno, self.finalbody[-1].tolineno\n        return lineno, self.tolineno\n\n    def get_children(self):\n        yield from self.body\n        yield from self.handlers\n        yield from self.orelse\n        yield from self.finalbody\n\n\nclass TryStar(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.TryStar` node.\"\"\"\n\n    _astroid_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n    _multi_line_block_fields = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n\n    def __init__(\n        self,\n        *,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n        parent: NodeNG | None = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n        :param col_offset: The column that this node appears on in the\n            source code.\n        :param parent: The parent node in the syntax tree.\n        :param end_lineno: The last line this node appears on in the source code.\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.body: list[NodeNG] = []\n        \"\"\"The contents of the block to catch exceptions from.\"\"\"\n\n        self.handlers: list[ExceptHandler] = []\n        \"\"\"The exception handlers.\"\"\"\n\n        self.orelse: list[NodeNG] = []\n        \"\"\"The contents of the ``else`` block.\"\"\"\n\n        self.finalbody: list[NodeNG] = []\n        \"\"\"The contents of the ``finally`` block.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        body: list[NodeNG] | None = None,\n        handlers: list[ExceptHandler] | None = None,\n        orelse: list[NodeNG] | None = None,\n        finalbody: list[NodeNG] | None = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n        :param body: The contents of the block to catch exceptions from.\n        :param handlers: The exception handlers.\n        :param orelse: The contents of the ``else`` block.\n        :param finalbody: The contents of the ``finally`` block.\n        \"\"\"\n        if body:\n            self.body = body\n        if handlers:\n            self.handlers = handlers\n        if orelse:\n            self.orelse = orelse\n        if finalbody:\n            self.finalbody = finalbody\n\n    def _infer_name(self, frame, name):\n        return name\n\n    def block_range(self, lineno: int) -> tuple[int, int]:\n        \"\"\"Get a range from a given line number to where this node ends.\"\"\"\n        if lineno == self.fromlineno:\n            return lineno, lineno\n        if self.body and self.body[0].fromlineno <= lineno <= self.body[-1].tolineno:\n            # Inside try body - return from lineno till end of try body\n            return lineno, self.body[-1].tolineno\n        for exhandler in self.handlers:\n            if exhandler.type and lineno == exhandler.type.fromlineno:\n                return lineno, lineno\n            if exhandler.body[0].fromlineno <= lineno <= exhandler.body[-1].tolineno:\n                return lineno, exhandler.body[-1].tolineno\n        if self.orelse:\n            if self.orelse[0].fromlineno - 1 == lineno:\n                return lineno, lineno\n            if self.orelse[0].fromlineno <= lineno <= self.orelse[-1].tolineno:\n                return lineno, self.orelse[-1].tolineno\n        if self.finalbody:\n            if self.finalbody[0].fromlineno - 1 == lineno:\n                return lineno, lineno\n            if self.finalbody[0].fromlineno <= lineno <= self.finalbody[-1].tolineno:\n                return lineno, self.finalbody[-1].tolineno\n        return lineno, self.tolineno\n\n    def get_children(self):\n        yield from self.body\n        yield from self.handlers\n        yield from self.orelse\n        yield from self.finalbody\n\n\nclass Tuple(BaseContainer):\n    \"\"\"Class representing an :class:`ast.Tuple` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('(1, 2, 3)')\n    >>> node\n    <Tuple.tuple l.1 at 0x7f23b2e41780>\n    \"\"\"\n\n    _other_fields = (\"ctx\",)\n\n    def __init__(\n        self,\n        ctx: Context | None = None,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param ctx: Whether the tuple is assigned to or loaded from.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.ctx: Context | None = ctx\n        \"\"\"Whether the tuple is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    assigned_stmts = protocols.sequence_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    infer_unary_op = protocols.tuple_infer_unary_op\n    infer_binary_op = protocols.tl_infer_binary_op\n\n    def pytype(self) -> Literal[\"builtins.tuple\"]:\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        \"\"\"\n        return \"builtins.tuple\"\n\n    def getitem(self, index, context: InferenceContext | None = None):\n        \"\"\"Get an item from this node.\n\n        :param index: The node to use as a subscript index.\n        :type index: Const or Slice\n        \"\"\"\n        return _container_getitem(self, self.elts, index, context=context)\n\n\nclass TypeAlias(_base_nodes.AssignTypeNode, _base_nodes.Statement):\n    \"\"\"Class representing a :class:`ast.TypeAlias` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('type Point = tuple[float, float]')\n    >>> node\n    <TypeAlias l.1 at 0x7f23b2e4e198>\n    \"\"\"\n\n    _astroid_fields = (\"name\", \"type_params\", \"value\")\n\n    name: AssignName\n    type_params: list[TypeVar | ParamSpec | TypeVarTuple]\n    value: NodeNG\n\n    def __init__(\n        self,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int,\n        end_col_offset: int,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        name: AssignName,\n        type_params: list[TypeVar | ParamSpec | TypeVarTuple],\n        value: NodeNG,\n    ) -> None:\n        self.name = name\n        self.type_params = type_params\n        self.value = value\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[TypeAlias]:\n        yield self\n\n    assigned_stmts: ClassVar[\n        Callable[\n            [\n                TypeAlias,\n                AssignName,\n                InferenceContext | None,\n                None,\n            ],\n            Generator[NodeNG],\n        ]\n    ] = protocols.assign_assigned_stmts\n\n\nclass TypeVar(_base_nodes.AssignTypeNode):\n    \"\"\"Class representing a :class:`ast.TypeVar` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('type Point[T] = tuple[float, float]')\n    >>> node.type_params[0]\n    <TypeVar l.1 at 0x7f23b2e4e198>\n    \"\"\"\n\n    _astroid_fields = (\"name\", \"bound\")\n\n    name: AssignName\n    bound: NodeNG | None\n\n    def __init__(\n        self,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int,\n        end_col_offset: int,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, name: AssignName, bound: NodeNG | None) -> None:\n        self.name = name\n        self.bound = bound\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[TypeVar]:\n        yield self\n\n    assigned_stmts = protocols.generic_type_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nclass TypeVarTuple(_base_nodes.AssignTypeNode):\n    \"\"\"Class representing a :class:`ast.TypeVarTuple` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('type Alias[*Ts] = tuple[*Ts]')\n    >>> node.type_params[0]\n    <TypeVarTuple l.1 at 0x7f23b2e4e198>\n    \"\"\"\n\n    _astroid_fields = (\"name\",)\n\n    name: AssignName\n\n    def __init__(\n        self,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int,\n        end_col_offset: int,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, name: AssignName) -> None:\n        self.name = name\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Iterator[TypeVarTuple]:\n        yield self\n\n    assigned_stmts = protocols.generic_type_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nUNARY_OP_METHOD = {\n    \"+\": \"__pos__\",\n    \"-\": \"__neg__\",\n    \"~\": \"__invert__\",\n    \"not\": None,  # XXX not '__nonzero__'\n}\n\n\nclass UnaryOp(_base_nodes.OperatorNode):\n    \"\"\"Class representing an :class:`ast.UnaryOp` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('-5')\n    >>> node\n    <UnaryOp l.1 at 0x7f23b2e4e198>\n    \"\"\"\n\n    _astroid_fields = (\"operand\",)\n    _other_fields = (\"op\",)\n\n    operand: NodeNG\n    \"\"\"What the unary operator is applied to.\"\"\"\n\n    def __init__(\n        self,\n        op: str,\n        lineno: int,\n        col_offset: int,\n        parent: NodeNG,\n        *,\n        end_lineno: int | None,\n        end_col_offset: int | None,\n    ) -> None:\n        self.op = op\n        \"\"\"The operator.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, operand: NodeNG) -> None:\n        self.operand = operand\n\n    def type_errors(\n        self, context: InferenceContext | None = None\n    ) -> list[util.BadUnaryOperationMessage]:\n        \"\"\"Get a list of type errors which can occur during inference.\n\n        Each TypeError is represented by a :class:`BadUnaryOperationMessage`,\n        which holds the original exception.\n\n        If any inferred result is uninferable, an empty list is returned.\n        \"\"\"\n        bad = []\n        try:\n            for result in self._infer_unaryop(context=context):\n                if result is util.Uninferable:\n                    raise InferenceError\n                if isinstance(result, util.BadUnaryOperationMessage):\n                    bad.append(result)\n        except InferenceError:\n            return []\n        return bad\n\n    def get_children(self):\n        yield self.operand\n\n    def op_precedence(self) -> int:\n        if self.op == \"not\":\n            return OP_PRECEDENCE[self.op]\n\n        return super().op_precedence()\n\n    def _infer_unaryop(\n        self: nodes.UnaryOp, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[\n        InferenceResult | util.BadUnaryOperationMessage, None, InferenceErrorInfo\n    ]:\n        \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n        from astroid.nodes import ClassDef  # pylint: disable=import-outside-toplevel\n\n        for operand in self.operand.infer(context):\n            try:\n                yield operand.infer_unary_op(self.op)\n            except TypeError as exc:\n                # The operand doesn't support this operation.\n                yield util.BadUnaryOperationMessage(operand, self.op, exc)\n            except AttributeError as exc:\n                meth = UNARY_OP_METHOD[self.op]\n                if meth is None:\n                    # `not node`. Determine node's boolean\n                    # value and negate its result, unless it is\n                    # Uninferable, which will be returned as is.\n                    bool_value = operand.bool_value()\n                    if not isinstance(bool_value, util.UninferableBase):\n                        yield const_factory(not bool_value)\n                    else:\n                        yield util.Uninferable\n                else:\n                    if not isinstance(operand, (Instance, ClassDef)):\n                        # The operation was used on something which\n                        # doesn't support it.\n                        yield util.BadUnaryOperationMessage(operand, self.op, exc)\n                        continue\n\n                    try:\n                        try:\n                            methods = dunder_lookup.lookup(operand, meth)\n                        except AttributeInferenceError:\n                            yield util.BadUnaryOperationMessage(operand, self.op, exc)\n                            continue\n\n                        meth = methods[0]\n                        inferred = next(meth.infer(context=context), None)\n                        if (\n                            isinstance(inferred, util.UninferableBase)\n                            or not inferred.callable()\n                        ):\n                            continue\n\n                        context = copy_context(context)\n                        context.boundnode = operand\n                        context.callcontext = CallContext(args=[], callee=inferred)\n\n                        call_results = inferred.infer_call_result(self, context=context)\n                        result = next(call_results, None)\n                        if result is None:\n                            # Failed to infer, return the same type.\n                            yield operand\n                        else:\n                            yield result\n                    except AttributeInferenceError as inner_exc:\n                        # The unary operation special method was not found.\n                        yield util.BadUnaryOperationMessage(operand, self.op, inner_exc)\n                    except InferenceError:\n                        yield util.Uninferable\n\n    @decorators.raise_if_nothing_inferred\n    @decorators.path_wrapper\n    def _infer(\n        self: nodes.UnaryOp, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo]:\n        \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n        yield from self._filter_operation_errors(\n            self._infer_unaryop, context, util.BadUnaryOperationMessage\n        )\n        return InferenceErrorInfo(node=self, context=context)\n\n\nclass While(_base_nodes.MultiLineWithElseBlockNode, _base_nodes.Statement):\n    \"\"\"Class representing an :class:`ast.While` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    while condition():\n        print(\"True\")\n    ''')\n    >>> node\n    <While l.2 at 0x7f23b2e4e390>\n    \"\"\"\n\n    _astroid_fields = (\"test\", \"body\", \"orelse\")\n    _multi_line_block_fields = (\"body\", \"orelse\")\n\n    test: NodeNG\n    \"\"\"The condition that the loop tests.\"\"\"\n\n    body: list[NodeNG]\n    \"\"\"The contents of the loop.\"\"\"\n\n    orelse: list[NodeNG]\n    \"\"\"The contents of the ``else`` block.\"\"\"\n\n    def postinit(\n        self,\n        test: NodeNG,\n        body: list[NodeNG],\n        orelse: list[NodeNG],\n    ) -> None:\n        self.test = test\n        self.body = body\n        self.orelse = orelse\n\n    @cached_property\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.test.tolineno\n\n    def block_range(self, lineno: int) -> tuple[int, int]:\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: The line number to start the range at.\n\n        :returns: The range of line numbers that this node belongs to,\n            starting at the given line number.\n        \"\"\"\n        return self._elsed_block_range(lineno, self.orelse)\n\n    def get_children(self):\n        yield self.test\n\n        yield from self.body\n        yield from self.orelse\n\n    def _get_yield_nodes_skip_functions(self):\n        \"\"\"A While node can contain a Yield node in the test\"\"\"\n        yield from self.test._get_yield_nodes_skip_functions()\n        yield from super()._get_yield_nodes_skip_functions()\n\n    def _get_yield_nodes_skip_lambdas(self):\n        \"\"\"A While node can contain a Yield node in the test\"\"\"\n        yield from self.test._get_yield_nodes_skip_lambdas()\n        yield from super()._get_yield_nodes_skip_lambdas()\n\n\nclass With(\n    _base_nodes.MultiLineWithElseBlockNode,\n    _base_nodes.AssignTypeNode,\n    _base_nodes.Statement,\n):\n    \"\"\"Class representing an :class:`ast.With` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    with open(file_path) as file_:\n        print(file_.read())\n    ''')\n    >>> node\n    <With l.2 at 0x7f23b2e4e710>\n    \"\"\"\n\n    _astroid_fields = (\"items\", \"body\")\n    _other_other_fields = (\"type_annotation\",)\n    _multi_line_block_fields = (\"body\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.items: list[tuple[NodeNG, NodeNG | None]] = []\n        \"\"\"The pairs of context managers and the names they are assigned to.\"\"\"\n\n        self.body: list[NodeNG] = []\n        \"\"\"The contents of the ``with`` block.\"\"\"\n\n        self.type_annotation: NodeNG | None = None  # can be None\n        \"\"\"If present, this will contain the type annotation passed by a type comment\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        items: list[tuple[NodeNG, NodeNG | None]] | None = None,\n        body: list[NodeNG] | None = None,\n        type_annotation: NodeNG | None = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param items: The pairs of context managers and the names\n            they are assigned to.\n\n        :param body: The contents of the ``with`` block.\n        \"\"\"\n        if items is not None:\n            self.items = items\n        if body is not None:\n            self.body = body\n        self.type_annotation = type_annotation\n\n    assigned_stmts = protocols.with_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    @cached_property\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.items[-1][0].tolineno\n\n    def get_children(self):\n        \"\"\"Get the child nodes below this node.\n\n        :returns: The children.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        for expr, var in self.items:\n            yield expr\n            if var:\n                yield var\n        yield from self.body\n\n\nclass AsyncWith(With):\n    \"\"\"Asynchronous ``with`` built with the ``async`` keyword.\"\"\"\n\n\nclass Yield(NodeNG):\n    \"\"\"Class representing an :class:`ast.Yield` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('yield True')\n    >>> node\n    <Yield l.1 at 0x7f23b2e4e5f8>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n\n    value: NodeNG | None\n    \"\"\"The value to yield.\"\"\"\n\n    def postinit(self, value: NodeNG | None) -> None:\n        self.value = value\n\n    def get_children(self):\n        if self.value is not None:\n            yield self.value\n\n    def _get_yield_nodes_skip_functions(self):\n        yield self\n\n    def _get_yield_nodes_skip_lambdas(self):\n        yield self\n\n\nclass YieldFrom(Yield):  # TODO value is required, not optional\n    \"\"\"Class representing an :class:`ast.YieldFrom` node.\"\"\"\n\n\nclass DictUnpack(_base_nodes.NoChildrenNode):\n    \"\"\"Represents the unpacking of dicts into dicts using :pep:`448`.\"\"\"\n\n\nclass FormattedValue(NodeNG):\n    \"\"\"Class representing an :class:`ast.FormattedValue` node.\n\n    Represents a :pep:`498` format string.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('f\"Format {type_}\"')\n    >>> node\n    <JoinedStr l.1 at 0x7f23b2e4ed30>\n    >>> node.values\n    [<Const.str l.1 at 0x7f23b2e4eda0>, <FormattedValue l.1 at 0x7f23b2e4edd8>]\n    \"\"\"\n\n    _astroid_fields = (\"value\", \"format_spec\")\n    _other_fields = (\"conversion\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.value: NodeNG\n        \"\"\"The value to be formatted into the string.\"\"\"\n\n        self.conversion: int\n        \"\"\"The type of formatting to be applied to the value.\n\n        .. seealso::\n            :class:`ast.FormattedValue`\n        \"\"\"\n\n        self.format_spec: JoinedStr | None = None\n        \"\"\"The formatting to be applied to the value.\n\n        .. seealso::\n            :class:`ast.FormattedValue`\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        value: NodeNG,\n        conversion: int,\n        format_spec: JoinedStr | None = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: The value to be formatted into the string.\n\n        :param conversion: The type of formatting to be applied to the value.\n\n        :param format_spec: The formatting to be applied to the value.\n        :type format_spec: JoinedStr or None\n        \"\"\"\n        self.value = value\n        self.conversion = conversion\n        self.format_spec = format_spec\n\n    def get_children(self):\n        yield self.value\n\n        if self.format_spec is not None:\n            yield self.format_spec\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        format_specs = Const(\"\") if self.format_spec is None else self.format_spec\n        uninferable_already_generated = False\n        for format_spec in format_specs.infer(context, **kwargs):\n            if not isinstance(format_spec, Const):\n                if not uninferable_already_generated:\n                    yield util.Uninferable\n                    uninferable_already_generated = True\n                continue\n            for value in self.value.infer(context, **kwargs):\n                if not isinstance(value, Const):\n                    if not uninferable_already_generated:\n                        yield util.Uninferable\n                        uninferable_already_generated = True\n                    continue\n                formatted = format(value.value, format_spec.value)\n                yield Const(\n                    formatted,\n                    lineno=self.lineno,\n                    col_offset=self.col_offset,\n                    end_lineno=self.end_lineno,\n                    end_col_offset=self.end_col_offset,\n                )\n                continue\n\n\nMISSING_VALUE = \"{MISSING_VALUE}\"\n\n\nclass JoinedStr(NodeNG):\n    \"\"\"Represents a list of string expressions to be joined.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('f\"Format {type_}\"')\n    >>> node\n    <JoinedStr l.1 at 0x7f23b2e4ed30>\n    \"\"\"\n\n    _astroid_fields = (\"values\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.values: list[NodeNG] = []\n        \"\"\"The string expressions to be joined.\n\n        :type: list(FormattedValue or Const)\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, values: list[NodeNG] | None = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: The string expressions to be joined.\n\n        :type: list(FormattedValue or Const)\n        \"\"\"\n        if values is not None:\n            self.values = values\n\n    def get_children(self):\n        yield from self.values\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        yield from self._infer_from_values(self.values, context)\n\n    @classmethod\n    def _infer_from_values(\n        cls, nodes: list[NodeNG], context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[InferenceResult, None, InferenceErrorInfo | None]:\n        if not nodes:\n            yield\n            return\n        if len(nodes) == 1:\n            yield from nodes[0]._infer(context, **kwargs)\n            return\n        uninferable_already_generated = False\n        for prefix in nodes[0]._infer(context, **kwargs):\n            for suffix in cls._infer_from_values(nodes[1:], context, **kwargs):\n                result = \"\"\n                for node in (prefix, suffix):\n                    if isinstance(node, Const):\n                        result += str(node.value)\n                        continue\n                    result += MISSING_VALUE\n                if MISSING_VALUE in result:\n                    if not uninferable_already_generated:\n                        uninferable_already_generated = True\n                        yield util.Uninferable\n                else:\n                    yield Const(result)\n\n\nclass NamedExpr(_base_nodes.AssignTypeNode):\n    \"\"\"Represents the assignment from the assignment expression\n\n    >>> import astroid\n    >>> module = astroid.parse('if a := 1: pass')\n    >>> module.body[0].test\n    <NamedExpr l.1 at 0x7f23b2e4ed30>\n    \"\"\"\n\n    _astroid_fields = (\"target\", \"value\")\n\n    optional_assign = True\n    \"\"\"Whether this node optionally assigns a variable.\n\n    Since NamedExpr are not always called they do not always assign.\"\"\"\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.target: NodeNG\n        \"\"\"The assignment target\n\n        :type: Name\n        \"\"\"\n\n        self.value: NodeNG\n        \"\"\"The value that gets assigned in the expression\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, target: NodeNG, value: NodeNG) -> None:\n        self.target = target\n        self.value = value\n\n    assigned_stmts = protocols.named_expr_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n    def frame(\n        self, *, future: Literal[None, True] = None\n    ) -> nodes.FunctionDef | nodes.Module | nodes.ClassDef | nodes.Lambda:\n        \"\"\"The first parent frame node.\n\n        A frame node is a :class:`Module`, :class:`FunctionDef`,\n        or :class:`ClassDef`.\n\n        :returns: The first parent frame node.\n        \"\"\"\n        if future is not None:\n            warnings.warn(\n                \"The future arg will be removed in astroid 4.0.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        if not self.parent:\n            raise ParentMissingError(target=self)\n\n        # For certain parents NamedExpr evaluate to the scope of the parent\n        if isinstance(self.parent, (Arguments, Keyword, Comprehension)):\n            if not self.parent.parent:\n                raise ParentMissingError(target=self.parent)\n            if not self.parent.parent.parent:\n                raise ParentMissingError(target=self.parent.parent)\n            return self.parent.parent.parent.frame()\n\n        return self.parent.frame()\n\n    def scope(self) -> LocalsDictNodeNG:\n        \"\"\"The first parent node defining a new scope.\n        These can be Module, FunctionDef, ClassDef, Lambda, or GeneratorExp nodes.\n\n        :returns: The first parent scope node.\n        \"\"\"\n        if not self.parent:\n            raise ParentMissingError(target=self)\n\n        # For certain parents NamedExpr evaluate to the scope of the parent\n        if isinstance(self.parent, (Arguments, Keyword, Comprehension)):\n            if not self.parent.parent:\n                raise ParentMissingError(target=self.parent)\n            if not self.parent.parent.parent:\n                raise ParentMissingError(target=self.parent.parent)\n            return self.parent.parent.parent.scope()\n\n        return self.parent.scope()\n\n    def set_local(self, name: str, stmt: NodeNG) -> None:\n        \"\"\"Define that the given name is declared in the given statement node.\n        NamedExpr's in Arguments, Keyword or Comprehension are evaluated in their\n        parent's parent scope. So we add to their frame's locals.\n\n        .. seealso:: :meth:`scope`\n\n        :param name: The name that is being defined.\n\n        :param stmt: The statement that defines the given name.\n        \"\"\"\n        self.frame().set_local(name, stmt)\n\n\nclass Unknown(_base_nodes.AssignTypeNode):\n    \"\"\"This node represents a node in a constructed AST where\n    introspection is not possible.  At the moment, it's only used in\n    the args attribute of FunctionDef nodes where function signature\n    introspection failed.\n    \"\"\"\n\n    name = \"Unknown\"\n\n    def __init__(\n        self,\n        lineno: None = None,\n        col_offset: None = None,\n        parent: None = None,\n        *,\n        end_lineno: None = None,\n        end_col_offset: None = None,\n    ) -> None:\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def qname(self) -> Literal[\"Unknown\"]:\n        return \"Unknown\"\n\n    def _infer(self, context: InferenceContext | None = None, **kwargs):\n        \"\"\"Inference on an Unknown node immediately terminates.\"\"\"\n        yield util.Uninferable\n\n\nclass EvaluatedObject(NodeNG):\n    \"\"\"Contains an object that has already been inferred\n\n    This class is useful to pre-evaluate a particular node,\n    with the resulting class acting as the non-evaluated node.\n    \"\"\"\n\n    name = \"EvaluatedObject\"\n    _astroid_fields = (\"original\",)\n    _other_fields = (\"value\",)\n\n    def __init__(\n        self, original: SuccessfulInferenceResult, value: InferenceResult\n    ) -> None:\n        self.original: SuccessfulInferenceResult = original\n        \"\"\"The original node that has already been evaluated\"\"\"\n\n        self.value: InferenceResult = value\n        \"\"\"The inferred value\"\"\"\n\n        super().__init__(\n            lineno=self.original.lineno,\n            col_offset=self.original.col_offset,\n            parent=self.original.parent,\n            end_lineno=self.original.end_lineno,\n            end_col_offset=self.original.end_col_offset,\n        )\n\n    def _infer(\n        self, context: InferenceContext | None = None, **kwargs: Any\n    ) -> Generator[NodeNG | util.UninferableBase]:\n        yield self.value\n\n\n# Pattern matching #######################################################\n\n\nclass Match(_base_nodes.Statement, _base_nodes.MultiLineBlockNode):\n    \"\"\"Class representing a :class:`ast.Match` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 200:\n            ...\n        case _:\n            ...\n    ''')\n    >>> node\n    <Match l.2 at 0x10c24e170>\n    \"\"\"\n\n    _astroid_fields = (\"subject\", \"cases\")\n    _multi_line_block_fields = (\"cases\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.subject: NodeNG\n        self.cases: list[MatchCase]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        subject: NodeNG,\n        cases: list[MatchCase],\n    ) -> None:\n        self.subject = subject\n        self.cases = cases\n\n\nclass Pattern(NodeNG):\n    \"\"\"Base class for all Pattern nodes.\"\"\"\n\n\nclass MatchCase(_base_nodes.MultiLineBlockNode):\n    \"\"\"Class representing a :class:`ast.match_case` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 200:\n            ...\n    ''')\n    >>> node.cases[0]\n    <MatchCase l.3 at 0x10c24e590>\n    \"\"\"\n\n    _astroid_fields = (\"pattern\", \"guard\", \"body\")\n    _multi_line_block_fields = (\"body\",)\n\n    lineno: None\n    col_offset: None\n    end_lineno: None\n    end_col_offset: None\n\n    def __init__(self, *, parent: NodeNG | None = None) -> None:\n        self.pattern: Pattern\n        self.guard: NodeNG | None\n        self.body: list[NodeNG]\n        super().__init__(\n            parent=parent,\n            lineno=None,\n            col_offset=None,\n            end_lineno=None,\n            end_col_offset=None,\n        )\n\n    def postinit(\n        self,\n        *,\n        pattern: Pattern,\n        guard: NodeNG | None,\n        body: list[NodeNG],\n    ) -> None:\n        self.pattern = pattern\n        self.guard = guard\n        self.body = body\n\n\nclass MatchValue(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchValue` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 200:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchValue l.3 at 0x10c24e200>\n    \"\"\"\n\n    _astroid_fields = (\"value\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.value: NodeNG\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, value: NodeNG) -> None:\n        self.value = value\n\n\nclass MatchSingleton(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchSingleton` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case True:\n            ...\n        case False:\n            ...\n        case None:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchSingleton l.3 at 0x10c2282e0>\n    >>> node.cases[1].pattern\n    <MatchSingleton l.5 at 0x10c228af0>\n    >>> node.cases[2].pattern\n    <MatchSingleton l.7 at 0x10c229f90>\n    \"\"\"\n\n    _other_fields = (\"value\",)\n\n    def __init__(\n        self,\n        *,\n        value: Literal[True, False, None],\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n        parent: NodeNG | None = None,\n    ) -> None:\n        self.value = value\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n\nclass MatchSequence(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchSequence` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case [1, 2]:\n            ...\n        case (1, 2, *_):\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchSequence l.3 at 0x10ca80d00>\n    >>> node.cases[1].pattern\n    <MatchSequence l.5 at 0x10ca80b20>\n    \"\"\"\n\n    _astroid_fields = (\"patterns\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.patterns: list[Pattern]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, patterns: list[Pattern]) -> None:\n        self.patterns = patterns\n\n\nclass MatchMapping(_base_nodes.AssignTypeNode, Pattern):\n    \"\"\"Class representing a :class:`ast.MatchMapping` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case {1: \"Hello\", 2: \"World\", 3: _, **rest}:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchMapping l.3 at 0x10c8a8850>\n    \"\"\"\n\n    _astroid_fields = (\"keys\", \"patterns\", \"rest\")\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.keys: list[NodeNG]\n        self.patterns: list[Pattern]\n        self.rest: AssignName | None\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        keys: list[NodeNG],\n        patterns: list[Pattern],\n        rest: AssignName | None,\n    ) -> None:\n        self.keys = keys\n        self.patterns = patterns\n        self.rest = rest\n\n    assigned_stmts = protocols.match_mapping_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nclass MatchClass(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchClass` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case Point2D(0, 0):\n            ...\n        case Point3D(x=0, y=0, z=0):\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchClass l.3 at 0x10ca83940>\n    >>> node.cases[1].pattern\n    <MatchClass l.5 at 0x10ca80880>\n    \"\"\"\n\n    _astroid_fields = (\"cls\", \"patterns\", \"kwd_patterns\")\n    _other_fields = (\"kwd_attrs\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.cls: NodeNG\n        self.patterns: list[Pattern]\n        self.kwd_attrs: list[str]\n        self.kwd_patterns: list[Pattern]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        cls: NodeNG,\n        patterns: list[Pattern],\n        kwd_attrs: list[str],\n        kwd_patterns: list[Pattern],\n    ) -> None:\n        self.cls = cls\n        self.patterns = patterns\n        self.kwd_attrs = kwd_attrs\n        self.kwd_patterns = kwd_patterns\n\n\nclass MatchStar(_base_nodes.AssignTypeNode, Pattern):\n    \"\"\"Class representing a :class:`ast.MatchStar` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case [1, *_]:\n            ...\n    ''')\n    >>> node.cases[0].pattern.patterns[1]\n    <MatchStar l.3 at 0x10ca809a0>\n    \"\"\"\n\n    _astroid_fields = (\"name\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.name: AssignName | None\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, name: AssignName | None) -> None:\n        self.name = name\n\n    assigned_stmts = protocols.match_star_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nclass MatchAs(_base_nodes.AssignTypeNode, Pattern):\n    \"\"\"Class representing a :class:`ast.MatchAs` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case [1, a]:\n            ...\n        case {'key': b}:\n            ...\n        case Point2D(0, 0) as c:\n            ...\n        case d:\n            ...\n    ''')\n    >>> node.cases[0].pattern.patterns[1]\n    <MatchAs l.3 at 0x10d0b2da0>\n    >>> node.cases[1].pattern.patterns[0]\n    <MatchAs l.5 at 0x10d0b2920>\n    >>> node.cases[2].pattern\n    <MatchAs l.7 at 0x10d0b06a0>\n    >>> node.cases[3].pattern\n    <MatchAs l.9 at 0x10d09b880>\n    \"\"\"\n\n    _astroid_fields = (\"pattern\", \"name\")\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.pattern: Pattern | None\n        self.name: AssignName | None\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(\n        self,\n        *,\n        pattern: Pattern | None,\n        name: AssignName | None,\n    ) -> None:\n        self.pattern = pattern\n        self.name = name\n\n    assigned_stmts = protocols.match_as_assigned_stmts\n    \"\"\"Returns the assigned statement (non inferred) according to the assignment type.\n    See astroid/protocols.py for actual implementation.\n    \"\"\"\n\n\nclass MatchOr(Pattern):\n    \"\"\"Class representing a :class:`ast.MatchOr` node.\n\n    >>> import astroid\n    >>> node = astroid.extract_node('''\n    match x:\n        case 400 | 401 | 402:\n            ...\n    ''')\n    >>> node.cases[0].pattern\n    <MatchOr l.3 at 0x10d0b0b50>\n    \"\"\"\n\n    _astroid_fields = (\"patterns\",)\n\n    def __init__(\n        self,\n        lineno: int | None = None,\n        col_offset: int | None = None,\n        parent: NodeNG | None = None,\n        *,\n        end_lineno: int | None = None,\n        end_col_offset: int | None = None,\n    ) -> None:\n        self.patterns: list[Pattern]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n\n    def postinit(self, *, patterns: list[Pattern]) -> None:\n        self.patterns = patterns\n\n\n# constants ##############################################################\n\n# The _proxied attribute of all container types (List, Tuple, etc.)\n# are set during bootstrapping by _astroid_bootstrapping().\nCONST_CLS: dict[type, type[NodeNG]] = {\n    list: List,\n    tuple: Tuple,\n    dict: Dict,\n    set: Set,\n    type(None): Const,\n    type(NotImplemented): Const,\n    type(...): Const,\n    bool: Const,\n    int: Const,\n    float: Const,\n    complex: Const,\n    str: Const,\n    bytes: Const,\n}\n\n\ndef _create_basic_elements(\n    value: Iterable[Any], node: List | Set | Tuple\n) -> list[NodeNG]:\n    \"\"\"Create a list of nodes to function as the elements of a new node.\"\"\"\n    elements: list[NodeNG] = []\n    for element in value:\n        element_node = const_factory(element)\n        element_node.parent = node\n        elements.append(element_node)\n    return elements\n\n\ndef _create_dict_items(\n    values: Mapping[Any, Any], node: Dict\n) -> list[tuple[SuccessfulInferenceResult, SuccessfulInferenceResult]]:\n    \"\"\"Create a list of node pairs to function as the items of a new dict node.\"\"\"\n    elements: list[tuple[SuccessfulInferenceResult, SuccessfulInferenceResult]] = []\n    for key, value in values.items():\n        key_node = const_factory(key)\n        key_node.parent = node\n        value_node = const_factory(value)\n        value_node.parent = node\n        elements.append((key_node, value_node))\n    return elements\n\n\ndef const_factory(value: Any) -> ConstFactoryResult:\n    \"\"\"Return an astroid node for a python value.\"\"\"\n    assert not isinstance(value, NodeNG)\n\n    # This only handles instances of the CONST types. Any\n    # subclasses get inferred as EmptyNode.\n    # TODO: See if we should revisit these with the normal builder.\n    if value.__class__ not in CONST_CLS:\n        node = EmptyNode()\n        node.object = value\n        return node\n\n    instance: List | Set | Tuple | Dict\n    initializer_cls = CONST_CLS[value.__class__]\n    if issubclass(initializer_cls, (List, Set, Tuple)):\n        instance = initializer_cls(\n            lineno=None,\n            col_offset=None,\n            parent=SYNTHETIC_ROOT,\n            end_lineno=None,\n            end_col_offset=None,\n        )\n        instance.postinit(_create_basic_elements(value, instance))\n        return instance\n    if issubclass(initializer_cls, Dict):\n        instance = initializer_cls(\n            lineno=None,\n            col_offset=None,\n            parent=SYNTHETIC_ROOT,\n            end_lineno=None,\n            end_col_offset=None,\n        )\n        instance.postinit(_create_dict_items(value, instance))\n        return instance\n    return Const(value)",
            "cost": 0.40249450000000003
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "pylint-dev/astroid",
        "pull_number": 2496,
        "instance_id": "pylint-dev__astroid.b114f6b5.2496",
        "patch": "diff --git a/ChangeLog b/ChangeLog\nindex 4560e5d2b7..c08b1cbf2c 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -13,6 +13,9 @@ What's New in astroid 3.3.1?\n ============================\n Release date: TBA\n \n+* Fix a crash introduced in 3.3.0 involving invalid format strings.\n+\n+  Closes #2492\n \n \n What's New in astroid 3.3.0?\ndiff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex c1c7af36da..1924c78eba 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -4687,19 +4687,24 @@ def _infer(\n                     uninferable_already_generated = True\n                 continue\n             for value in self.value.infer(context, **kwargs):\n-                if not isinstance(value, Const):\n-                    if not uninferable_already_generated:\n-                        yield util.Uninferable\n-                        uninferable_already_generated = True\n-                    continue\n-                formatted = format(value.value, format_spec.value)\n-                yield Const(\n-                    formatted,\n-                    lineno=self.lineno,\n-                    col_offset=self.col_offset,\n-                    end_lineno=self.end_lineno,\n-                    end_col_offset=self.end_col_offset,\n-                )\n+                if isinstance(value, Const):\n+                    try:\n+                        formatted = format(value.value, format_spec.value)\n+                        yield Const(\n+                            formatted,\n+                            lineno=self.lineno,\n+                            col_offset=self.col_offset,\n+                            end_lineno=self.end_lineno,\n+                            end_col_offset=self.end_col_offset,\n+                        )\n+                        continue\n+                    except (ValueError, TypeError):\n+                        # happens when format_spec.value is invalid\n+                        pass  # fall through\n+                if not uninferable_already_generated:\n+                    yield util.Uninferable\n+                    uninferable_already_generated = True\n+                continue\n \n \n MISSING_VALUE = \"{MISSING_VALUE}\"\n",
        "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 61378043c3..a8b11b1614 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -666,21 +666,6 @@ def test_fstring_inference(self) -> None:\n         self.assertIsInstance(value_node, Const)\n         self.assertEqual(value_node.value, \"Hello John!\")\n \n-    def test_formatted_fstring_inference(self) -> None:\n-        code = \"\"\"\n-            width = 10\n-            precision = 4\n-            value = 12.34567\n-            result = f\"result: {value:{width}.{precision}}!\"\n-            \"\"\"\n-        ast = parse(code, __name__)\n-        node = ast[\"result\"]\n-        inferred = node.inferred()\n-        self.assertEqual(len(inferred), 1)\n-        value_node = inferred[0]\n-        self.assertIsInstance(value_node, Const)\n-        self.assertEqual(value_node.value, \"result:      12.35!\")\n-\n     def test_float_complex_ambiguity(self) -> None:\n         code = '''\n             def no_conjugate_member(magic_flag):  #@\n@@ -5517,6 +5502,51 @@ class instance(object):\n         self.assertIsInstance(inferred, Instance)\n \n \n+@pytest.mark.parametrize(\n+    \"code, result\",\n+    [\n+        # regular f-string\n+        (\n+            \"\"\"width = 10\n+precision = 4\n+value = 12.34567\n+result = f\"result: {value:{width}.{precision}}!\"\n+\"\"\",\n+            \"result:      12.35!\",\n+        ),\n+        # unsupported format\n+        (\n+            \"\"\"width = None\n+precision = 4\n+value = 12.34567\n+result = f\"result: {value:{width}.{precision}}!\"\n+\"\"\",\n+            None,\n+        ),\n+        # unsupported value\n+        (\n+            \"\"\"width = 10\n+precision = 4\n+value = None\n+result = f\"result: {value:{width}.{precision}}!\"\n+\"\"\",\n+            None,\n+        ),\n+    ],\n+)\n+def test_formatted_fstring_inference(code, result) -> None:\n+    ast = parse(code, __name__)\n+    node = ast[\"result\"]\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    value_node = inferred[0]\n+    if result is None:\n+        assert value_node is util.Uninferable\n+    else:\n+        assert isinstance(value_node, Const)\n+        assert value_node.value == result\n+\n+\n def test_augassign_recursion() -> None:\n     \"\"\"Make sure inference doesn't throw a RecursionError.\n \n",
        "base_commit": "b114f6b5",
        "pr_mirror": "pylint-dev__astroid.b114f6b5"
    }
}