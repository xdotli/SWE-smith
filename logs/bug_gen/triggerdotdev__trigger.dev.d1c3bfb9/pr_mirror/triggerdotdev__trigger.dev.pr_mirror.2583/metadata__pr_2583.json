{
    "cost": 0.6748400000000001,
    "rewrites": {
        "triggerdotdev__trigger.dev.d1c3bfb9/apps/webapp/app/runEngine/concerns/idempotencyKeys.server.ts": {
            "output": "import { RunId } from \"@trigger.dev/core/v3/isomorphic\";\nimport type { PrismaClientOrTransaction, TaskRun } from \"@trigger.dev/database\";\nimport { logger } from \"~/services/logger.server\";\nimport { resolveIdempotencyKeyTTL } from \"~/utils/idempotencyKeys.server\";\nimport type { RunEngine } from \"~/v3/runEngine.server\";\nimport { shouldIdempotencyKeyBeCleared } from \"~/v3/taskStatus\";\nimport type { TraceEventConcern, TriggerTaskRequest } from \"../types\";\n\nexport type IdempotencyKeyConcernResult =\n  | { isCached: true; run: TaskRun }\n  | { isCached: false; idempotencyKey?: string; idempotencyKeyExpiresAt?: Date };\n\nexport class IdempotencyKeyConcern {\n  constructor(\n    private readonly prisma: PrismaClientOrTransaction,\n    private readonly engine: RunEngine,\n    private readonly traceEventConcern: TraceEventConcern\n  ) {}\n\n  async handleTriggerRequest(request: TriggerTaskRequest): Promise<IdempotencyKeyConcernResult> {\n    const idempotencyKey = request.options?.idempotencyKey ?? request.body.options?.idempotencyKey;\n    const idempotencyKeyExpiresAt =\n      request.options?.idempotencyKeyExpiresAt ??\n      resolveIdempotencyKeyTTL(request.body.options?.idempotencyKeyTTL) ??\n      new Date(Date.now() + 24 * 60 * 60 * 1000 * 30); // 30 days\n\n    if (!idempotencyKey) {\n      return { isCached: false, idempotencyKey, idempotencyKeyExpiresAt };\n    }\n\n    const existingRun = idempotencyKey\n      ? await this.prisma.taskRun.findFirst({\n          where: {\n            runtimeEnvironmentId: request.environment.id,\n            idempotencyKey,\n            taskIdentifier: request.taskId,\n          },\n          include: {\n            associatedWaitpoint: true,\n          },\n        })\n      : undefined;\n\n    if (existingRun) {\n      // The idempotency key has expired\n      if (existingRun.idempotencyKeyExpiresAt && existingRun.idempotencyKeyExpiresAt < new Date()) {\n        logger.debug(\"[TriggerTaskService][call] Idempotency key has expired\", {\n          idempotencyKey: request.options?.idempotencyKey,\n          run: existingRun,\n        });\n\n        // Update the existing run to remove the idempotency key\n        await this.prisma.taskRun.updateMany({\n          where: { id: existingRun.id, idempotencyKey },\n          data: { idempotencyKey: null, idempotencyKeyExpiresAt: null },\n        });\n\n        return { isCached: false, idempotencyKey, idempotencyKeyExpiresAt };\n      }\n\n      // If the existing run failed or was expired, we clear the key and do a new run\n      if (shouldIdempotencyKeyBeCleared(existingRun.status)) {\n        logger.debug(\"[TriggerTaskService][call] Idempotency key should be cleared\", {\n          idempotencyKey: request.options?.idempotencyKey,\n          runStatus: existingRun.status,\n          runId: existingRun.id,\n        });\n\n        // Update the existing run to remove the idempotency key\n        await this.prisma.taskRun.updateMany({\n          where: { id: existingRun.id, idempotencyKey },\n          data: { idempotencyKey: null, idempotencyKeyExpiresAt: null },\n        });\n\n        return { isCached: false, idempotencyKey, idempotencyKeyExpiresAt };\n      }\n\n      // We have an idempotent run, so we return it\n      const associatedWaitpoint = existingRun.associatedWaitpoint;\n      const parentRunId = request.body.options?.parentRunId;\n      const resumeParentOnCompletion = request.body.options?.resumeParentOnCompletion;\n      //We're using `andWait` so we need to block the parent run with a waitpoint\n      if (associatedWaitpoint && resumeParentOnCompletion && parentRunId) {\n        await this.traceEventConcern.traceIdempotentRun(\n          request,\n          {\n            existingRun,\n            idempotencyKey,\n            incomplete: associatedWaitpoint.status === \"PENDING\",\n            isError: associatedWaitpoint.outputIsError,\n          },\n          async (event) => {\n            const spanId =\n              request.options?.parentAsLinkType === \"replay\"\n                ? event.spanId\n                : event.traceparent?.spanId\n                ? `${event.traceparent.spanId}:${event.spanId}`\n                : event.spanId;\n\n            //block run with waitpoint\n            await this.engine.blockRunWithWaitpoint({\n              runId: RunId.fromFriendlyId(parentRunId),\n              waitpoints: associatedWaitpoint.id,\n              spanIdToComplete: spanId,\n              batch: request.options?.batchId\n                ? {\n                    id: request.options.batchId,\n                    index: request.options.batchIndex ?? 0,\n                  }\n                : undefined,\n              projectId: request.environment.projectId,\n              organizationId: request.environment.organizationId,\n              tx: this.prisma,\n            });\n          }\n        );\n      }\n\n      return { isCached: true, run: existingRun };\n    }\n\n    return { isCached: false, idempotencyKey, idempotencyKeyExpiresAt };\n  }\n}",
            "output_extracted": "import { RunId } from \"@trigger.dev/core/v3/isomorphic\";\nimport type { PrismaClientOrTransaction, TaskRun } from \"@trigger.dev/database\";\nimport { logger } from \"~/services/logger.server\";\nimport { resolveIdempotencyKeyTTL } from \"~/utils/idempotencyKeys.server\";\nimport type { RunEngine } from \"~/v3/runEngine.server\";\nimport { shouldIdempotencyKeyBeCleared } from \"~/v3/taskStatus\";\nimport type { TraceEventConcern, TriggerTaskRequest } from \"../types\";\n\nexport type IdempotencyKeyConcernResult =\n  | { isCached: true; run: TaskRun }\n  | { isCached: false; idempotencyKey?: string; idempotencyKeyExpiresAt?: Date };\n\nexport class IdempotencyKeyConcern {\n  constructor(\n    private readonly prisma: PrismaClientOrTransaction,\n    private readonly engine: RunEngine,\n    private readonly traceEventConcern: TraceEventConcern\n  ) {}\n\n  async handleTriggerRequest(request: TriggerTaskRequest): Promise<IdempotencyKeyConcernResult> {\n    const idempotencyKey = request.options?.idempotencyKey ?? request.body.options?.idempotencyKey;\n    const idempotencyKeyExpiresAt =\n      request.options?.idempotencyKeyExpiresAt ??\n      resolveIdempotencyKeyTTL(request.body.options?.idempotencyKeyTTL) ??\n      new Date(Date.now() + 24 * 60 * 60 * 1000 * 30); // 30 days\n\n    if (!idempotencyKey) {\n      return { isCached: false, idempotencyKey, idempotencyKeyExpiresAt };\n    }\n\n    const existingRun = idempotencyKey\n      ? await this.prisma.taskRun.findFirst({\n          where: {\n            runtimeEnvironmentId: request.environment.id,\n            idempotencyKey,\n            taskIdentifier: request.taskId,\n          },\n          include: {\n            associatedWaitpoint: true,\n          },\n        })\n      : undefined;\n\n    if (existingRun) {\n      // The idempotency key has expired\n      if (existingRun.idempotencyKeyExpiresAt && existingRun.idempotencyKeyExpiresAt < new Date()) {\n        logger.debug(\"[TriggerTaskService][call] Idempotency key has expired\", {\n          idempotencyKey: request.options?.idempotencyKey,\n          run: existingRun,\n        });\n\n        // Update the existing run to remove the idempotency key\n        await this.prisma.taskRun.updateMany({\n          where: { id: existingRun.id, idempotencyKey },\n          data: { idempotencyKey: null, idempotencyKeyExpiresAt: null },\n        });\n\n        return { isCached: false, idempotencyKey, idempotencyKeyExpiresAt };\n      }\n\n      // If the existing run failed or was expired, we clear the key and do a new run\n      if (shouldIdempotencyKeyBeCleared(existingRun.status)) {\n        logger.debug(\"[TriggerTaskService][call] Idempotency key should be cleared\", {\n          idempotencyKey: request.options?.idempotencyKey,\n          runStatus: existingRun.status,\n          runId: existingRun.id,\n        });\n\n        // Update the existing run to remove the idempotency key\n        await this.prisma.taskRun.updateMany({\n          where: { id: existingRun.id, idempotencyKey },\n          data: { idempotencyKey: null, idempotencyKeyExpiresAt: null },\n        });\n\n        return { isCached: false, idempotencyKey, idempotencyKeyExpiresAt };\n      }\n\n      // We have an idempotent run, so we return it\n      const associatedWaitpoint = existingRun.associatedWaitpoint;\n      const parentRunId = request.body.options?.parentRunId;\n      const resumeParentOnCompletion = request.body.options?.resumeParentOnCompletion;\n      //We're using `andWait` so we need to block the parent run with a waitpoint\n      if (associatedWaitpoint && resumeParentOnCompletion && parentRunId) {\n        await this.traceEventConcern.traceIdempotentRun(\n          request,\n          {\n            existingRun,\n            idempotencyKey,\n            incomplete: associatedWaitpoint.status === \"PENDING\",\n            isError: associatedWaitpoint.outputIsError,\n          },\n          async (event) => {\n            const spanId =\n              request.options?.parentAsLinkType === \"replay\"\n                ? event.spanId\n                : event.traceparent?.spanId\n                ? `${event.traceparent.spanId}:${event.spanId}`\n                : event.spanId;\n\n            //block run with waitpoint\n            await this.engine.blockRunWithWaitpoint({\n              runId: RunId.fromFriendlyId(parentRunId),\n              waitpoints: associatedWaitpoint.id,\n              spanIdToComplete: spanId,\n              batch: request.options?.batchId\n                ? {\n                    id: request.options.batchId,\n                    index: request.options.batchIndex ?? 0,\n                  }\n                : undefined,\n              projectId: request.environment.projectId,\n              organizationId: request.environment.organizationId,\n              tx: this.prisma,\n            });\n          }\n        );\n      }\n\n      return { isCached: true, run: existingRun };\n    }\n\n    return { isCached: false, idempotencyKey, idempotencyKeyExpiresAt };\n  }\n}",
            "cost": 0.05052
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/apps/webapp/app/runEngine/concerns/traceEvents.server.ts": {
            "output": "import { EventRepository } from \"~/v3/eventRepository/eventRepository.server\";\nimport { TracedEventSpan, TraceEventConcern, TriggerTaskRequest } from \"../types\";\nimport { SemanticInternalAttributes } from \"@trigger.dev/core/v3/semanticInternalAttributes\";\nimport { TaskRun } from \"@trigger.dev/database\";\nimport { getTaskEventStore } from \"~/v3/taskEventStore.server\";\nimport { ClickhouseEventRepository } from \"~/v3/eventRepository/clickhouseEventRepository.server\";\nimport { IEventRepository } from \"~/v3/eventRepository/eventRepository.types\";\nimport { FEATURE_FLAG, flags } from \"~/v3/featureFlags.server\";\nimport { env } from \"~/env.server\";\nimport { getEventRepository } from \"~/v3/eventRepository/index.server\";\n\nexport class DefaultTraceEventsConcern implements TraceEventConcern {\n  private readonly eventRepository: EventRepository;\n  private readonly clickhouseEventRepository: ClickhouseEventRepository;\n\n  constructor(\n    eventRepository: EventRepository,\n    clickhouseEventRepository: ClickhouseEventRepository\n  ) {\n    this.eventRepository = eventRepository;\n    this.clickhouseEventRepository = clickhouseEventRepository;\n  }\n\n  async #getEventRepository(\n    request: TriggerTaskRequest\n  ): Promise<{ repository: IEventRepository; store: string }> {\n    return await getEventRepository(\n      request.environment.organization.featureFlags as Record<string, unknown>\n    );\n  }\n\n  async traceRun<T>(\n    request: TriggerTaskRequest,\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T> {\n    const { repository, store } = await this.#getEventRepository(request);\n\n    return await repository.traceEvent(\n      request.taskId,\n      {\n        context: request.options?.traceContext,\n        spanParentAsLink: request.options?.spanParentAsLink,\n        kind: \"SERVER\",\n        environment: request.environment,\n        taskSlug: request.taskId,\n        attributes: {\n          properties: {},\n          style: {\n            icon: request.options?.customIcon ?? \"task\",\n          },\n        },\n        incomplete: true,\n        immediate: true,\n        startTime: request.options?.overrideCreatedAt\n          ? BigInt(request.options.overrideCreatedAt.getTime()) * BigInt(1000000)\n          : undefined,\n      },\n      async (event, traceContext, traceparent) => {\n        return await callback(\n          {\n            traceId: event.traceId,\n            spanId: event.spanId,\n            traceContext,\n            traceparent,\n            setAttribute: (key, value) => event.setAttribute(key as any, value),\n            failWithError: event.failWithError.bind(event),\n          },\n          store\n        );\n      }\n    );\n  }\n\n  async traceIdempotentRun<T>(\n    request: TriggerTaskRequest,\n    options: {\n      existingRun: TaskRun;\n      idempotencyKey: string;\n      incomplete: boolean;\n      isError: boolean;\n    },\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T> {\n    const { existingRun, idempotencyKey, incomplete, isError } = options;\n    const { repository, store } = await this.#getEventRepository(request);\n\n    return await repository.traceEvent(\n      `${request.taskId} (cached)`,\n      {\n        context: request.options?.traceContext,\n        spanParentAsLink: request.options?.spanParentAsLink,\n        kind: \"SERVER\",\n        environment: request.environment,\n        taskSlug: request.taskId,\n        attributes: {\n          properties: {\n            [SemanticInternalAttributes.ORIGINAL_RUN_ID]: existingRun.friendlyId,\n          },\n          style: {\n            icon: \"task-cached\",\n          },\n          runId: existingRun.friendlyId,\n        },\n        incomplete,\n        isError,\n        immediate: true,\n      },\n      async (event, traceContext, traceparent) => {\n        //log a message\n        await this.eventRepository.recordEvent(\n          `There's an existing run for idempotencyKey: ${idempotencyKey}`,\n          {\n            taskSlug: request.taskId,\n            environment: request.environment,\n            attributes: {\n              runId: existingRun.friendlyId,\n            },\n            context: request.options?.traceContext,\n            parentId: event.spanId,\n          }\n        );\n\n        return await callback(\n          {\n            traceId: event.traceId,\n            spanId: event.spanId,\n            traceContext,\n            traceparent,\n            setAttribute: (key, value) => event.setAttribute(key as any, value),\n            failWithError: event.failWithError.bind(event),\n          },\n          store\n        );\n      }\n    );\n  }\n}",
            "output_extracted": "import { EventRepository } from \"~/v3/eventRepository/eventRepository.server\";\nimport { TracedEventSpan, TraceEventConcern, TriggerTaskRequest } from \"../types\";\nimport { SemanticInternalAttributes } from \"@trigger.dev/core/v3/semanticInternalAttributes\";\nimport { TaskRun } from \"@trigger.dev/database\";\nimport { getTaskEventStore } from \"~/v3/taskEventStore.server\";\nimport { ClickhouseEventRepository } from \"~/v3/eventRepository/clickhouseEventRepository.server\";\nimport { IEventRepository } from \"~/v3/eventRepository/eventRepository.types\";\nimport { FEATURE_FLAG, flags } from \"~/v3/featureFlags.server\";\nimport { env } from \"~/env.server\";\nimport { getEventRepository } from \"~/v3/eventRepository/index.server\";\n\nexport class DefaultTraceEventsConcern implements TraceEventConcern {\n  private readonly eventRepository: EventRepository;\n  private readonly clickhouseEventRepository: ClickhouseEventRepository;\n\n  constructor(\n    eventRepository: EventRepository,\n    clickhouseEventRepository: ClickhouseEventRepository\n  ) {\n    this.eventRepository = eventRepository;\n    this.clickhouseEventRepository = clickhouseEventRepository;\n  }\n\n  async #getEventRepository(\n    request: TriggerTaskRequest\n  ): Promise<{ repository: IEventRepository; store: string }> {\n    return await getEventRepository(\n      request.environment.organization.featureFlags as Record<string, unknown>\n    );\n  }\n\n  async traceRun<T>(\n    request: TriggerTaskRequest,\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T> {\n    const { repository, store } = await this.#getEventRepository(request);\n\n    return await repository.traceEvent(\n      request.taskId,\n      {\n        context: request.options?.traceContext,\n        spanParentAsLink: request.options?.spanParentAsLink,\n        kind: \"SERVER\",\n        environment: request.environment,\n        taskSlug: request.taskId,\n        attributes: {\n          properties: {},\n          style: {\n            icon: request.options?.customIcon ?? \"task\",\n          },\n        },\n        incomplete: true,\n        immediate: true,\n        startTime: request.options?.overrideCreatedAt\n          ? BigInt(request.options.overrideCreatedAt.getTime()) * BigInt(1000000)\n          : undefined,\n      },\n      async (event, traceContext, traceparent) => {\n        return await callback(\n          {\n            traceId: event.traceId,\n            spanId: event.spanId,\n            traceContext,\n            traceparent,\n            setAttribute: (key, value) => event.setAttribute(key as any, value),\n            failWithError: event.failWithError.bind(event),\n          },\n          store\n        );\n      }\n    );\n  }\n\n  async traceIdempotentRun<T>(\n    request: TriggerTaskRequest,\n    options: {\n      existingRun: TaskRun;\n      idempotencyKey: string;\n      incomplete: boolean;\n      isError: boolean;\n    },\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T> {\n    const { existingRun, idempotencyKey, incomplete, isError } = options;\n    const { repository, store } = await this.#getEventRepository(request);\n\n    return await repository.traceEvent(\n      `${request.taskId} (cached)`,\n      {\n        context: request.options?.traceContext,\n        spanParentAsLink: request.options?.spanParentAsLink,\n        kind: \"SERVER\",\n        environment: request.environment,\n        taskSlug: request.taskId,\n        attributes: {\n          properties: {\n            [SemanticInternalAttributes.ORIGINAL_RUN_ID]: existingRun.friendlyId,\n          },\n          style: {\n            icon: \"task-cached\",\n          },\n          runId: existingRun.friendlyId,\n        },\n        incomplete,\n        isError,\n        immediate: true,\n      },\n      async (event, traceContext, traceparent) => {\n        //log a message\n        await this.eventRepository.recordEvent(\n          `There's an existing run for idempotencyKey: ${idempotencyKey}`,\n          {\n            taskSlug: request.taskId,\n            environment: request.environment,\n            attributes: {\n              runId: existingRun.friendlyId,\n            },\n            context: request.options?.traceContext,\n            parentId: event.spanId,\n          }\n        );\n\n        return await callback(\n          {\n            traceId: event.traceId,\n            spanId: event.spanId,\n            traceContext,\n            traceparent,\n            setAttribute: (key, value) => event.setAttribute(key as any, value),\n            failWithError: event.failWithError.bind(event),\n          },\n          store\n        );\n      }\n    );\n  }\n}",
            "cost": 0.046715000000000007
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/apps/webapp/app/runEngine/services/triggerTask.server.ts": {
            "output": "import {\n  RunDuplicateIdempotencyKeyError,\n  RunEngine,\n  RunOneTimeUseTokenError,\n} from \"@internal/run-engine\";\nimport { Tracer } from \"@opentelemetry/api\";\nimport { tryCatch } from \"@trigger.dev/core/utils\";\nimport {\n  TaskRunError,\n  taskRunErrorEnhancer,\n  taskRunErrorToString,\n  TriggerTaskRequestBody,\n  TriggerTraceContext,\n} from \"@trigger.dev/core/v3\";\nimport {\n  parseTraceparent,\n  RunId,\n  serializeTraceparent,\n  stringifyDuration,\n} from \"@trigger.dev/core/v3/isomorphic\";\nimport type { PrismaClientOrTransaction } from \"@trigger.dev/database\";\nimport { createTags } from \"~/models/taskRunTag.server\";\nimport type { AuthenticatedEnvironment } from \"~/services/apiAuth.server\";\nimport { logger } from \"~/services/logger.server\";\nimport { parseDelay } from \"~/utils/delays\";\nimport { handleMetadataPacket } from \"~/utils/packets\";\nimport { startSpan } from \"~/v3/tracing.server\";\nimport type {\n  TriggerTaskServiceOptions,\n  TriggerTaskServiceResult,\n} from \"../../v3/services/triggerTask.server\";\nimport { clampMaxDuration } from \"../../v3/utils/maxDuration\";\nimport { IdempotencyKeyConcern } from \"../concerns/idempotencyKeys.server\";\nimport type {\n  PayloadProcessor,\n  QueueManager,\n  RunNumberIncrementer,\n  TraceEventConcern,\n  TriggerRacepoints,\n  TriggerRacepointSystem,\n  TriggerTaskRequest,\n  TriggerTaskValidator,\n} from \"../types\";\nimport { ServiceValidationError } from \"~/v3/services/common.server\";\n\nclass NoopTriggerRacepointSystem implements TriggerRacepointSystem {\n  async waitForRacepoint(options: { racepoint: TriggerRacepoints; id: string }): Promise<void> {\n    return;\n  }\n}\n\nexport class RunEngineTriggerTaskService {\n  private readonly queueConcern: QueueManager;\n  private readonly validator: TriggerTaskValidator;\n  private readonly payloadProcessor: PayloadProcessor;\n  private readonly idempotencyKeyConcern: IdempotencyKeyConcern;\n  private readonly runNumberIncrementer: RunNumberIncrementer;\n  private readonly prisma: PrismaClientOrTransaction;\n  private readonly engine: RunEngine;\n  private readonly tracer: Tracer;\n  private readonly traceEventConcern: TraceEventConcern;\n  private readonly triggerRacepointSystem: TriggerRacepointSystem;\n  private readonly metadataMaximumSize: number;\n\n  constructor(opts: {\n    prisma: PrismaClientOrTransaction;\n    engine: RunEngine;\n    queueConcern: QueueManager;\n    validator: TriggerTaskValidator;\n    payloadProcessor: PayloadProcessor;\n    idempotencyKeyConcern: IdempotencyKeyConcern;\n    runNumberIncrementer: RunNumberIncrementer;\n    traceEventConcern: TraceEventConcern;\n    tracer: Tracer;\n    metadataMaximumSize: number;\n    triggerRacepointSystem?: TriggerRacepointSystem;\n  }) {\n    this.prisma = opts.prisma;\n    this.engine = opts.engine;\n    this.queueConcern = opts.queueConcern;\n    this.validator = opts.validator;\n    this.payloadProcessor = opts.payloadProcessor;\n    this.idempotencyKeyConcern = opts.idempotencyKeyConcern;\n    this.runNumberIncrementer = opts.runNumberIncrementer;\n    this.tracer = opts.tracer;\n    this.traceEventConcern = opts.traceEventConcern;\n    this.metadataMaximumSize = opts.metadataMaximumSize;\n    this.triggerRacepointSystem = opts.triggerRacepointSystem ?? new NoopTriggerRacepointSystem();\n  }\n\n  public async call({\n    taskId,\n    environment,\n    body,\n    options = {},\n    attempt = 0,\n  }: {\n    taskId: string;\n    environment: AuthenticatedEnvironment;\n    body: TriggerTaskRequestBody;\n    options?: TriggerTaskServiceOptions;\n    attempt?: number;\n  }): Promise<TriggerTaskServiceResult | undefined> {\n    return await startSpan(this.tracer, \"RunEngineTriggerTaskService.call()\", async (span) => {\n      span.setAttribute(\"taskId\", taskId);\n      span.setAttribute(\"attempt\", attempt);\n\n      const runFriendlyId = options?.runFriendlyId ?? RunId.generate().friendlyId;\n      const triggerRequest = {\n        taskId,\n        friendlyId: runFriendlyId,\n        environment,\n        body,\n        options,\n      } satisfies TriggerTaskRequest;\n\n      // Validate max attempts\n      const maxAttemptsValidation = this.validator.validateMaxAttempts({\n        taskId,\n        attempt,\n      });\n\n      if (!maxAttemptsValidation.ok) {\n        throw maxAttemptsValidation.error;\n      }\n\n      // Validate tags\n      const tagValidation = this.validator.validateTags({\n        tags: body.options?.tags,\n      });\n\n      if (!tagValidation.ok) {\n        throw tagValidation.error;\n      }\n\n      // Validate entitlement (unless skipChecks is enabled)\n      let planType: string | undefined;\n\n      if (!options.skipChecks) {\n        const entitlementValidation = await this.validator.validateEntitlement({\n          environment,\n        });\n\n        if (!entitlementValidation.ok) {\n          throw entitlementValidation.error;\n        }\n\n        // Extract plan type from entitlement response\n        planType = entitlementValidation.plan?.type;\n      } else {\n        // When skipChecks is enabled, planType should be passed via options\n        planType = options.planType;\n\n        if (!planType) {\n          logger.warn(\"Plan type not set but skipChecks is enabled\", {\n            taskId,\n            environment: {\n              id: environment.id,\n              type: environment.type,\n              projectId: environment.projectId,\n              organizationId: environment.organizationId,\n            },\n          });\n        }\n      }\n\n      const [parseDelayError, delayUntil] = await tryCatch(parseDelay(body.options?.delay));\n\n      if (parseDelayError) {\n        throw new ServiceValidationError(`Invalid delay ${body.options?.delay}`);\n      }\n\n      const ttl =\n        typeof body.options?.ttl === \"number\"\n          ? stringifyDuration(body.options?.ttl)\n          : body.options?.ttl ?? (environment.type === \"DEVELOPMENT\" ? \"10m\" : undefined);\n\n      // Get parent run if specified\n      const parentRun = body.options?.parentRunId\n        ? await this.prisma.taskRun.findFirst({\n            where: {\n              id: RunId.fromFriendlyId(body.options.parentRunId),\n              runtimeEnvironmentId: environment.id,\n            },\n          })\n        : undefined;\n\n      // Validate parent run\n      const parentRunValidation = this.validator.validateParentRun({\n        taskId,\n        parentRun: parentRun ?? undefined,\n        resumeParentOnCompletion: body.options?.resumeParentOnCompletion,\n      });\n\n      if (!parentRunValidation.ok) {\n        throw parentRunValidation.error;\n      }\n\n      const idempotencyKeyConcernResult = await this.idempotencyKeyConcern.handleTriggerRequest(\n        triggerRequest\n      );\n\n      if (idempotencyKeyConcernResult.isCached) {\n        return idempotencyKeyConcernResult;\n      }\n\n      const { idempotencyKey, idempotencyKeyExpiresAt } = idempotencyKeyConcernResult;\n\n      if (idempotencyKey) {\n        await this.triggerRacepointSystem.waitForRacepoint({\n          racepoint: \"idempotencyKey\",\n          id: idempotencyKey,\n        });\n      }\n\n      if (!options.skipChecks) {\n        const queueSizeGuard = await this.queueConcern.validateQueueLimits(environment);\n\n        if (!queueSizeGuard.ok) {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the queue size limit for this environment has been reached. The maximum size is ${queueSizeGuard.maximumSize}`\n          );\n        }\n      }\n\n      const metadataPacket = body.options?.metadata\n        ? handleMetadataPacket(\n            body.options?.metadata,\n            body.options?.metadataType ?? \"application/json\",\n            this.metadataMaximumSize\n          )\n        : undefined;\n\n      const lockedToBackgroundWorker = body.options?.lockToVersion\n        ? await this.prisma.backgroundWorker.findFirst({\n            where: {\n              projectId: environment.projectId,\n              runtimeEnvironmentId: environment.id,\n              version: body.options?.lockToVersion,\n            },\n            select: {\n              id: true,\n              version: true,\n              sdkVersion: true,\n              cliVersion: true,\n            },\n          })\n        : undefined;\n\n      const { queueName, lockedQueueId } = await this.queueConcern.resolveQueueProperties(\n        triggerRequest,\n        lockedToBackgroundWorker ?? undefined\n      );\n\n      //upsert tags\n      const tags = await createTags(\n        {\n          tags: body.options?.tags,\n          projectId: environment.projectId,\n        },\n        this.prisma\n      );\n\n      const depth = parentRun ? parentRun.depth + 1 : 0;\n\n      const workerQueue = await this.queueConcern.getWorkerQueue(environment, body.options?.region);\n\n      try {\n        return await this.traceEventConcern.traceRun(triggerRequest, async (event, store) => {\n          const result = await this.runNumberIncrementer.incrementRunNumber(\n            triggerRequest,\n            async (num) => {\n              event.setAttribute(\"queueName\", queueName);\n              span.setAttribute(\"queueName\", queueName);\n              event.setAttribute(\"runId\", runFriendlyId);\n              span.setAttribute(\"runId\", runFriendlyId);\n\n              const payloadPacket = await this.payloadProcessor.process(triggerRequest);\n\n              const taskRun = await this.engine.trigger(\n                {\n                  number: num,\n                  friendlyId: runFriendlyId,\n                  environment: environment,\n                  idempotencyKey,\n                  idempotencyKeyExpiresAt: idempotencyKey ? idempotencyKeyExpiresAt : undefined,\n                  taskIdentifier: taskId,\n                  payload: payloadPacket.data ?? \"\",\n                  payloadType: payloadPacket.dataType,\n                  context: body.context,\n                  traceContext: this.#propagateExternalTraceContext(\n                    event.traceContext,\n                    parentRun?.traceContext,\n                    event.traceparent?.spanId\n                  ),\n                  traceId: event.traceId,\n                  spanId: event.spanId,\n                  parentSpanId:\n                    options.parentAsLinkType === \"replay\" ? undefined : event.traceparent?.spanId,\n                  replayedFromTaskRunFriendlyId: options.replayedFromTaskRunFriendlyId,\n                  lockedToVersionId: lockedToBackgroundWorker?.id,\n                  taskVersion: lockedToBackgroundWorker?.version,\n                  sdkVersion: lockedToBackgroundWorker?.sdkVersion,\n                  cliVersion: lockedToBackgroundWorker?.cliVersion,\n                  concurrencyKey: body.options?.concurrencyKey,\n                  queue: queueName,\n                  lockedQueueId,\n                  workerQueue,\n                  isTest: body.options?.test ?? false,\n                  delayUntil,\n                  queuedAt: delayUntil ? undefined : new Date(),\n                  maxAttempts: body.options?.maxAttempts,\n                  taskEventStore: store,\n                  ttl,\n                  tags,\n                  oneTimeUseToken: options.oneTimeUseToken,\n                  parentTaskRunId: parentRun?.id,\n                  rootTaskRunId: parentRun?.rootTaskRunId ?? parentRun?.id,\n                  batch: options?.batchId\n                    ? {\n                        id: options.batchId,\n                        index: options.batchIndex ?? 0,\n                      }\n                    : undefined,\n                  resumeParentOnCompletion: body.options?.resumeParentOnCompletion,\n                  depth,\n                  metadata: metadataPacket?.data,\n                  metadataType: metadataPacket?.dataType,\n                  seedMetadata: metadataPacket?.data,\n                  seedMetadataType: metadataPacket?.dataType,\n                  maxDurationInSeconds: body.options?.maxDuration\n                    ? clampMaxDuration(body.options.maxDuration)\n                    : undefined,\n                  machine: body.options?.machine,\n                  priorityMs: body.options?.priority ? body.options.priority * 1_000 : undefined,\n                  queueTimestamp:\n                    options.queueTimestamp ??\n                    (parentRun && body.options?.resumeParentOnCompletion\n                      ? parentRun.queueTimestamp ?? undefined\n                      : undefined),\n                  scheduleId: options.scheduleId,\n                  scheduleInstanceId: options.scheduleInstanceId,\n                  createdAt: options.overrideCreatedAt,\n                  bulkActionId: body.options?.bulkActionId,\n                  planType,\n                },\n                this.prisma\n              );\n\n              const error = taskRun.error ? TaskRunError.parse(taskRun.error) : undefined;\n\n              if (error) {\n                event.failWithError(error);\n              }\n\n              return { run: taskRun, error, isCached: false };\n            }\n          );\n\n          if (result?.error) {\n            throw new ServiceValidationError(\n              taskRunErrorToString(taskRunErrorEnhancer(result.error))\n            );\n          }\n\n          return result;\n        });\n      } catch (error) {\n        if (error instanceof RunDuplicateIdempotencyKeyError) {\n          //retry calling this function, because this time it will return the idempotent run\n          return await this.call({ taskId, environment, body, options, attempt: attempt + 1 });\n        }\n\n        if (error instanceof RunOneTimeUseTokenError) {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} with a one-time use token as it has already been used.`\n          );\n        }\n\n        throw error;\n      }\n    });\n  }\n\n  #propagateExternalTraceContext(\n    traceContext: Record<string, unknown>,\n    parentRunTraceContext: unknown,\n    parentSpanId: string | undefined\n  ): TriggerTraceContext {\n    if (!parentRunTraceContext) {\n      return traceContext;\n    }\n\n    const parsedParentRunTraceContext = TriggerTraceContext.safeParse(parentRunTraceContext);\n\n    if (!parsedParentRunTraceContext.success) {\n      return traceContext;\n    }\n\n    const { external } = parsedParentRunTraceContext.data;\n\n    if (!external) {\n      return traceContext;\n    }\n\n    if (!external.traceparent) {\n      return traceContext;\n    }\n\n    const parsedTraceparent = parseTraceparent(external.traceparent);\n\n    if (!parsedTraceparent) {\n      return traceContext;\n    }\n\n    const newExternalTraceparent =",
            "output_extracted": "import {\n  RunDuplicateIdempotencyKeyError,\n  RunEngine,\n  RunOneTimeUseTokenError,\n} from \"@internal/run-engine\";\nimport { Tracer } from \"@opentelemetry/api\";\nimport { tryCatch } from \"@trigger.dev/core/utils\";\nimport {\n  TaskRunError,\n  taskRunErrorEnhancer,\n  taskRunErrorToString,\n  TriggerTaskRequestBody,\n  TriggerTraceContext,\n} from \"@trigger.dev/core/v3\";\nimport {\n  parseTraceparent,\n  RunId,\n  serializeTraceparent,\n  stringifyDuration,\n} from \"@trigger.dev/core/v3/isomorphic\";\nimport type { PrismaClientOrTransaction } from \"@trigger.dev/database\";\nimport { createTags } from \"~/models/taskRunTag.server\";\nimport type { AuthenticatedEnvironment } from \"~/services/apiAuth.server\";\nimport { logger } from \"~/services/logger.server\";\nimport { parseDelay } from \"~/utils/delays\";\nimport { handleMetadataPacket } from \"~/utils/packets\";\nimport { startSpan } from \"~/v3/tracing.server\";\nimport type {\n  TriggerTaskServiceOptions,\n  TriggerTaskServiceResult,\n} from \"../../v3/services/triggerTask.server\";\nimport { clampMaxDuration } from \"../../v3/utils/maxDuration\";\nimport { IdempotencyKeyConcern } from \"../concerns/idempotencyKeys.server\";\nimport type {\n  PayloadProcessor,\n  QueueManager,\n  RunNumberIncrementer,\n  TraceEventConcern,\n  TriggerRacepoints,\n  TriggerRacepointSystem,\n  TriggerTaskRequest,\n  TriggerTaskValidator,\n} from \"../types\";\nimport { ServiceValidationError } from \"~/v3/services/common.server\";\n\nclass NoopTriggerRacepointSystem implements TriggerRacepointSystem {\n  async waitForRacepoint(options: { racepoint: TriggerRacepoints; id: string }): Promise<void> {\n    return;\n  }\n}\n\nexport class RunEngineTriggerTaskService {\n  private readonly queueConcern: QueueManager;\n  private readonly validator: TriggerTaskValidator;\n  private readonly payloadProcessor: PayloadProcessor;\n  private readonly idempotencyKeyConcern: IdempotencyKeyConcern;\n  private readonly runNumberIncrementer: RunNumberIncrementer;\n  private readonly prisma: PrismaClientOrTransaction;\n  private readonly engine: RunEngine;\n  private readonly tracer: Tracer;\n  private readonly traceEventConcern: TraceEventConcern;\n  private readonly triggerRacepointSystem: TriggerRacepointSystem;\n  private readonly metadataMaximumSize: number;\n\n  constructor(opts: {\n    prisma: PrismaClientOrTransaction;\n    engine: RunEngine;\n    queueConcern: QueueManager;\n    validator: TriggerTaskValidator;\n    payloadProcessor: PayloadProcessor;\n    idempotencyKeyConcern: IdempotencyKeyConcern;\n    runNumberIncrementer: RunNumberIncrementer;\n    traceEventConcern: TraceEventConcern;\n    tracer: Tracer;\n    metadataMaximumSize: number;\n    triggerRacepointSystem?: TriggerRacepointSystem;\n  }) {\n    this.prisma = opts.prisma;\n    this.engine = opts.engine;\n    this.queueConcern = opts.queueConcern;\n    this.validator = opts.validator;\n    this.payloadProcessor = opts.payloadProcessor;\n    this.idempotencyKeyConcern = opts.idempotencyKeyConcern;\n    this.runNumberIncrementer = opts.runNumberIncrementer;\n    this.tracer = opts.tracer;\n    this.traceEventConcern = opts.traceEventConcern;\n    this.metadataMaximumSize = opts.metadataMaximumSize;\n    this.triggerRacepointSystem = opts.triggerRacepointSystem ?? new NoopTriggerRacepointSystem();\n  }\n\n  public async call({\n    taskId,\n    environment,\n    body,\n    options = {},\n    attempt = 0,\n  }: {\n    taskId: string;\n    environment: AuthenticatedEnvironment;\n    body: TriggerTaskRequestBody;\n    options?: TriggerTaskServiceOptions;\n    attempt?: number;\n  }): Promise<TriggerTaskServiceResult | undefined> {\n    return await startSpan(this.tracer, \"RunEngineTriggerTaskService.call()\", async (span) => {\n      span.setAttribute(\"taskId\", taskId);\n      span.setAttribute(\"attempt\", attempt);\n\n      const runFriendlyId = options?.runFriendlyId ?? RunId.generate().friendlyId;\n      const triggerRequest = {\n        taskId,\n        friendlyId: runFriendlyId,\n        environment,\n        body,\n        options,\n      } satisfies TriggerTaskRequest;\n\n      // Validate max attempts\n      const maxAttemptsValidation = this.validator.validateMaxAttempts({\n        taskId,\n        attempt,\n      });\n\n      if (!maxAttemptsValidation.ok) {\n        throw maxAttemptsValidation.error;\n      }\n\n      // Validate tags\n      const tagValidation = this.validator.validateTags({\n        tags: body.options?.tags,\n      });\n\n      if (!tagValidation.ok) {\n        throw tagValidation.error;\n      }\n\n      // Validate entitlement (unless skipChecks is enabled)\n      let planType: string | undefined;\n\n      if (!options.skipChecks) {\n        const entitlementValidation = await this.validator.validateEntitlement({\n          environment,\n        });\n\n        if (!entitlementValidation.ok) {\n          throw entitlementValidation.error;\n        }\n\n        // Extract plan type from entitlement response\n        planType = entitlementValidation.plan?.type;\n      } else {\n        // When skipChecks is enabled, planType should be passed via options\n        planType = options.planType;\n\n        if (!planType) {\n          logger.warn(\"Plan type not set but skipChecks is enabled\", {\n            taskId,\n            environment: {\n              id: environment.id,\n              type: environment.type,\n              projectId: environment.projectId,\n              organizationId: environment.organizationId,\n            },\n          });\n        }\n      }\n\n      const [parseDelayError, delayUntil] = await tryCatch(parseDelay(body.options?.delay));\n\n      if (parseDelayError) {\n        throw new ServiceValidationError(`Invalid delay ${body.options?.delay}`);\n      }\n\n      const ttl =\n        typeof body.options?.ttl === \"number\"\n          ? stringifyDuration(body.options?.ttl)\n          : body.options?.ttl ?? (environment.type === \"DEVELOPMENT\" ? \"10m\" : undefined);\n\n      // Get parent run if specified\n      const parentRun = body.options?.parentRunId\n        ? await this.prisma.taskRun.findFirst({\n            where: {\n              id: RunId.fromFriendlyId(body.options.parentRunId),\n              runtimeEnvironmentId: environment.id,\n            },\n          })\n        : undefined;\n\n      // Validate parent run\n      const parentRunValidation = this.validator.validateParentRun({\n        taskId,\n        parentRun: parentRun ?? undefined,\n        resumeParentOnCompletion: body.options?.resumeParentOnCompletion,\n      });\n\n      if (!parentRunValidation.ok) {\n        throw parentRunValidation.error;\n      }\n\n      const idempotencyKeyConcernResult = await this.idempotencyKeyConcern.handleTriggerRequest(\n        triggerRequest\n      );\n\n      if (idempotencyKeyConcernResult.isCached) {\n        return idempotencyKeyConcernResult;\n      }\n\n      const { idempotencyKey, idempotencyKeyExpiresAt } = idempotencyKeyConcernResult;\n\n      if (idempotencyKey) {\n        await this.triggerRacepointSystem.waitForRacepoint({\n          racepoint: \"idempotencyKey\",\n          id: idempotencyKey,\n        });\n      }\n\n      if (!options.skipChecks) {\n        const queueSizeGuard = await this.queueConcern.validateQueueLimits(environment);\n\n        if (!queueSizeGuard.ok) {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the queue size limit for this environment has been reached. The maximum size is ${queueSizeGuard.maximumSize}`\n          );\n        }\n      }\n\n      const metadataPacket = body.options?.metadata\n        ? handleMetadataPacket(\n            body.options?.metadata,\n            body.options?.metadataType ?? \"application/json\",\n            this.metadataMaximumSize\n          )\n        : undefined;\n\n      const lockedToBackgroundWorker = body.options?.lockToVersion\n        ? await this.prisma.backgroundWorker.findFirst({\n            where: {\n              projectId: environment.projectId,\n              runtimeEnvironmentId: environment.id,\n              version: body.options?.lockToVersion,\n            },\n            select: {\n              id: true,\n              version: true,\n              sdkVersion: true,\n              cliVersion: true,\n            },\n          })\n        : undefined;\n\n      const { queueName, lockedQueueId } = await this.queueConcern.resolveQueueProperties(\n        triggerRequest,\n        lockedToBackgroundWorker ?? undefined\n      );\n\n      //upsert tags\n      const tags = await createTags(\n        {\n          tags: body.options?.tags,\n          projectId: environment.projectId,\n        },\n        this.prisma\n      );\n\n      const depth = parentRun ? parentRun.depth + 1 : 0;\n\n      const workerQueue = await this.queueConcern.getWorkerQueue(environment, body.options?.region);\n\n      try {\n        return await this.traceEventConcern.traceRun(triggerRequest, async (event, store) => {\n          const result = await this.runNumberIncrementer.incrementRunNumber(\n            triggerRequest,\n            async (num) => {\n              event.setAttribute(\"queueName\", queueName);\n              span.setAttribute(\"queueName\", queueName);\n              event.setAttribute(\"runId\", runFriendlyId);\n              span.setAttribute(\"runId\", runFriendlyId);\n\n              const payloadPacket = await this.payloadProcessor.process(triggerRequest);\n\n              const taskRun = await this.engine.trigger(\n                {\n                  number: num,\n                  friendlyId: runFriendlyId,\n                  environment: environment,\n                  idempotencyKey,\n                  idempotencyKeyExpiresAt: idempotencyKey ? idempotencyKeyExpiresAt : undefined,\n                  taskIdentifier: taskId,\n                  payload: payloadPacket.data ?? \"\",\n                  payloadType: payloadPacket.dataType,\n                  context: body.context,\n                  traceContext: this.#propagateExternalTraceContext(\n                    event.traceContext,\n                    parentRun?.traceContext,\n                    event.traceparent?.spanId\n                  ),\n                  traceId: event.traceId,\n                  spanId: event.spanId,\n                  parentSpanId:\n                    options.parentAsLinkType === \"replay\" ? undefined : event.traceparent?.spanId,\n                  replayedFromTaskRunFriendlyId: options.replayedFromTaskRunFriendlyId,\n                  lockedToVersionId: lockedToBackgroundWorker?.id,\n                  taskVersion: lockedToBackgroundWorker?.version,\n                  sdkVersion: lockedToBackgroundWorker?.sdkVersion,\n                  cliVersion: lockedToBackgroundWorker?.cliVersion,\n                  concurrencyKey: body.options?.concurrencyKey,\n                  queue: queueName,\n                  lockedQueueId,\n                  workerQueue,\n                  isTest: body.options?.test ?? false,\n                  delayUntil,\n                  queuedAt: delayUntil ? undefined : new Date(),\n                  maxAttempts: body.options?.maxAttempts,\n                  taskEventStore: store,\n                  ttl,\n                  tags,\n                  oneTimeUseToken: options.oneTimeUseToken,\n                  parentTaskRunId: parentRun?.id,\n                  rootTaskRunId: parentRun?.rootTaskRunId ?? parentRun?.id,\n                  batch: options?.batchId\n                    ? {\n                        id: options.batchId,\n                        index: options.batchIndex ?? 0,\n                      }\n                    : undefined,\n                  resumeParentOnCompletion: body.options?.resumeParentOnCompletion,\n                  depth,\n                  metadata: metadataPacket?.data,\n                  metadataType: metadataPacket?.dataType,\n                  seedMetadata: metadataPacket?.data,\n                  seedMetadataType: metadataPacket?.dataType,\n                  maxDurationInSeconds: body.options?.maxDuration\n                    ? clampMaxDuration(body.options.maxDuration)\n                    : undefined,\n                  machine: body.options?.machine,\n                  priorityMs: body.options?.priority ? body.options.priority * 1_000 : undefined,\n                  queueTimestamp:\n                    options.queueTimestamp ??\n                    (parentRun && body.options?.resumeParentOnCompletion\n                      ? parentRun.queueTimestamp ?? undefined\n                      : undefined),\n                  scheduleId: options.scheduleId,\n                  scheduleInstanceId: options.scheduleInstanceId,\n                  createdAt: options.overrideCreatedAt,\n                  bulkActionId: body.options?.bulkActionId,\n                  planType,\n                },\n                this.prisma\n              );\n\n              const error = taskRun.error ? TaskRunError.parse(taskRun.error) : undefined;\n\n              if (error) {\n                event.failWithError(error);\n              }\n\n              return { run: taskRun, error, isCached: false };\n            }\n          );\n\n          if (result?.error) {\n            throw new ServiceValidationError(\n              taskRunErrorToString(taskRunErrorEnhancer(result.error))\n            );\n          }\n\n          return result;\n        });\n      } catch (error) {\n        if (error instanceof RunDuplicateIdempotencyKeyError) {\n          //retry calling this function, because this time it will return the idempotent run\n          return await this.call({ taskId, environment, body, options, attempt: attempt + 1 });\n        }\n\n        if (error instanceof RunOneTimeUseTokenError) {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} with a one-time use token as it has already been used.`\n          );\n        }\n\n        throw error;\n      }\n    });\n  }\n\n  #propagateExternalTraceContext(\n    traceContext: Record<string, unknown>,\n    parentRunTraceContext: unknown,\n    parentSpanId: string | undefined\n  ): TriggerTraceContext {\n    if (!parentRunTraceContext) {\n      return traceContext;\n    }\n\n    const parsedParentRunTraceContext = TriggerTraceContext.safeParse(parentRunTraceContext);\n\n    if (!parsedParentRunTraceContext.success) {\n      return traceContext;\n    }\n\n    const { external } = parsedParentRunTraceContext.data;\n\n    if (!external) {\n      return traceContext;\n    }\n\n    if (!external.traceparent) {\n      return traceContext;\n    }\n\n    const parsedTraceparent = parseTraceparent(external.traceparent);\n\n    if (!parsedTraceparent) {\n      return traceContext;\n    }\n\n    const newExternalTraceparent =",
            "cost": 0.14133500000000002
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/apps/webapp/app/runEngine/types.ts": {
            "output": "import type { BackgroundWorker, TaskRun } from \"@trigger.dev/database\";\nimport type { IOPacket, TaskRunError, TriggerTaskRequestBody } from \"@trigger.dev/core/v3\";\nimport type { AuthenticatedEnvironment } from \"~/services/apiAuth.server\";\nimport type { ReportUsagePlan } from \"@trigger.dev/platform\";\n\nexport type TriggerTaskServiceOptions = {\n  idempotencyKey?: string;\n  idempotencyKeyExpiresAt?: Date;\n  triggerVersion?: string;\n  traceContext?: Record<string, unknown>;\n  spanParentAsLink?: boolean;\n  parentAsLinkType?: \"replay\" | \"trigger\";\n  batchId?: string;\n  batchIndex?: number;\n  customIcon?: string;\n  runFriendlyId?: string;\n  skipChecks?: boolean;\n  oneTimeUseToken?: string;\n  overrideCreatedAt?: Date;\n  planType?: string;\n};\n\n// domain/triggerTask.ts\nexport type TriggerTaskRequest = {\n  taskId: string;\n  friendlyId: string;\n  environment: AuthenticatedEnvironment;\n  body: TriggerTaskRequestBody;\n  options?: TriggerTaskServiceOptions;\n};\n\nexport type TriggerTaskResult = {\n  run: TaskRun;\n  isCached: boolean;\n  error?: TaskRunError;\n};\n\nexport type QueueValidationResult =\n  | {\n      ok: true;\n    }\n  | {\n      ok: false;\n      maximumSize: number;\n      queueSize: number;\n    };\n\nexport type QueueProperties = {\n  queueName: string;\n  lockedQueueId?: string;\n};\n\nexport type LockedBackgroundWorker = Pick<\n  BackgroundWorker,\n  \"id\" | \"version\" | \"sdkVersion\" | \"cliVersion\"\n>;\n\n// Core domain interfaces\nexport interface QueueManager {\n  resolveQueueProperties(\n    request: TriggerTaskRequest,\n    lockedBackgroundWorker?: LockedBackgroundWorker\n  ): Promise<QueueProperties>;\n  getQueueName(request: TriggerTaskRequest): Promise<string>;\n  validateQueueLimits(\n    env: AuthenticatedEnvironment,\n    itemsToAdd?: number\n  ): Promise<QueueValidationResult>;\n  getWorkerQueue(\n    env: AuthenticatedEnvironment,\n    regionOverride?: string\n  ): Promise<string | undefined>;\n}\n\nexport interface PayloadProcessor {\n  process(request: TriggerTaskRequest): Promise<IOPacket>;\n}\n\nexport interface RunNumberIncrementer {\n  incrementRunNumber<T>(\n    request: TriggerTaskRequest,\n    callback: (num: number) => Promise<T>\n  ): Promise<T | undefined>;\n}\n\nexport interface TagValidationParams {\n  tags?: string[] | string;\n}\n\nexport interface EntitlementValidationParams {\n  environment: AuthenticatedEnvironment;\n}\n\nexport interface MaxAttemptsValidationParams {\n  taskId: string;\n  attempt: number;\n}\n\nexport interface ParentRunValidationParams {\n  taskId: string;\n  parentRun?: TaskRun;\n  resumeParentOnCompletion?: boolean;\n}\n\nexport type ValidationResult =\n  | {\n      ok: true;\n    }\n  | {\n      ok: false;\n      error: Error;\n    };\n\nexport type EntitlementValidationResult =\n  | {\n      ok: true;\n      plan?: ReportUsagePlan;\n    }\n  | {\n      ok: false;\n      error: Error;\n    };\n\nexport interface TriggerTaskValidator {\n  validateTags(params: TagValidationParams): ValidationResult;\n  validateEntitlement(params: EntitlementValidationParams): Promise<EntitlementValidationResult>;\n  validateMaxAttempts(params: MaxAttemptsValidationParams): ValidationResult;\n  validateParentRun(params: ParentRunValidationParams): ValidationResult;\n}\n\nexport type TracedEventSpan = {\n  traceId: string;\n  spanId: string;\n  traceContext: Record<string, unknown>;\n  traceparent?: {\n    traceId: string;\n    spanId: string;\n  };\n  setAttribute: (key: string, value: string) => void;\n  failWithError: (error: TaskRunError) => void;\n};\n\nexport interface TraceEventConcern {\n  traceRun<T>(\n    request: TriggerTaskRequest,\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T>;\n  traceIdempotentRun<T>(\n    request: TriggerTaskRequest,\n    options: {\n      existingRun: TaskRun;\n      idempotencyKey: string;\n      incomplete: boolean;\n      isError: boolean;\n    },\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T>;\n}\n\nexport type TriggerRacepoints = \"idempotencyKey\";\n\nexport interface TriggerRacepointSystem {\n  waitForRacepoint(options: { racepoint: TriggerRacepoints; id: string }): Promise<void>;\n}",
            "output_extracted": "import type { BackgroundWorker, TaskRun } from \"@trigger.dev/database\";\nimport type { IOPacket, TaskRunError, TriggerTaskRequestBody } from \"@trigger.dev/core/v3\";\nimport type { AuthenticatedEnvironment } from \"~/services/apiAuth.server\";\nimport type { ReportUsagePlan } from \"@trigger.dev/platform\";\n\nexport type TriggerTaskServiceOptions = {\n  idempotencyKey?: string;\n  idempotencyKeyExpiresAt?: Date;\n  triggerVersion?: string;\n  traceContext?: Record<string, unknown>;\n  spanParentAsLink?: boolean;\n  parentAsLinkType?: \"replay\" | \"trigger\";\n  batchId?: string;\n  batchIndex?: number;\n  customIcon?: string;\n  runFriendlyId?: string;\n  skipChecks?: boolean;\n  oneTimeUseToken?: string;\n  overrideCreatedAt?: Date;\n  planType?: string;\n};\n\n// domain/triggerTask.ts\nexport type TriggerTaskRequest = {\n  taskId: string;\n  friendlyId: string;\n  environment: AuthenticatedEnvironment;\n  body: TriggerTaskRequestBody;\n  options?: TriggerTaskServiceOptions;\n};\n\nexport type TriggerTaskResult = {\n  run: TaskRun;\n  isCached: boolean;\n  error?: TaskRunError;\n};\n\nexport type QueueValidationResult =\n  | {\n      ok: true;\n    }\n  | {\n      ok: false;\n      maximumSize: number;\n      queueSize: number;\n    };\n\nexport type QueueProperties = {\n  queueName: string;\n  lockedQueueId?: string;\n};\n\nexport type LockedBackgroundWorker = Pick<\n  BackgroundWorker,\n  \"id\" | \"version\" | \"sdkVersion\" | \"cliVersion\"\n>;\n\n// Core domain interfaces\nexport interface QueueManager {\n  resolveQueueProperties(\n    request: TriggerTaskRequest,\n    lockedBackgroundWorker?: LockedBackgroundWorker\n  ): Promise<QueueProperties>;\n  getQueueName(request: TriggerTaskRequest): Promise<string>;\n  validateQueueLimits(\n    env: AuthenticatedEnvironment,\n    itemsToAdd?: number\n  ): Promise<QueueValidationResult>;\n  getWorkerQueue(\n    env: AuthenticatedEnvironment,\n    regionOverride?: string\n  ): Promise<string | undefined>;\n}\n\nexport interface PayloadProcessor {\n  process(request: TriggerTaskRequest): Promise<IOPacket>;\n}\n\nexport interface RunNumberIncrementer {\n  incrementRunNumber<T>(\n    request: TriggerTaskRequest,\n    callback: (num: number) => Promise<T>\n  ): Promise<T | undefined>;\n}\n\nexport interface TagValidationParams {\n  tags?: string[] | string;\n}\n\nexport interface EntitlementValidationParams {\n  environment: AuthenticatedEnvironment;\n}\n\nexport interface MaxAttemptsValidationParams {\n  taskId: string;\n  attempt: number;\n}\n\nexport interface ParentRunValidationParams {\n  taskId: string;\n  parentRun?: TaskRun;\n  resumeParentOnCompletion?: boolean;\n}\n\nexport type ValidationResult =\n  | {\n      ok: true;\n    }\n  | {\n      ok: false;\n      error: Error;\n    };\n\nexport type EntitlementValidationResult =\n  | {\n      ok: true;\n      plan?: ReportUsagePlan;\n    }\n  | {\n      ok: false;\n      error: Error;\n    };\n\nexport interface TriggerTaskValidator {\n  validateTags(params: TagValidationParams): ValidationResult;\n  validateEntitlement(params: EntitlementValidationParams): Promise<EntitlementValidationResult>;\n  validateMaxAttempts(params: MaxAttemptsValidationParams): ValidationResult;\n  validateParentRun(params: ParentRunValidationParams): ValidationResult;\n}\n\nexport type TracedEventSpan = {\n  traceId: string;\n  spanId: string;\n  traceContext: Record<string, unknown>;\n  traceparent?: {\n    traceId: string;\n    spanId: string;\n  };\n  setAttribute: (key: string, value: string) => void;\n  failWithError: (error: TaskRunError) => void;\n};\n\nexport interface TraceEventConcern {\n  traceRun<T>(\n    request: TriggerTaskRequest,\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T>;\n  traceIdempotentRun<T>(\n    request: TriggerTaskRequest,\n    options: {\n      existingRun: TaskRun;\n      idempotencyKey: string;\n      incomplete: boolean;\n      isError: boolean;\n    },\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T>;\n}\n\nexport type TriggerRacepoints = \"idempotencyKey\";\n\nexport interface TriggerRacepointSystem {\n  waitForRacepoint(options: { racepoint: TriggerRacepoints; id: string }): Promise<void>;\n}",
            "cost": 0.04408
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/apps/webapp/app/v3/eventRepository/index.server.ts": {
            "output": "import { env } from \"~/env.server\";\nimport { eventRepository } from \"./eventRepository.server\";\nimport {\n  clickhouseEventRepository,\n  clickhouseEventRepositoryV2,\n} from \"./clickhouseEventRepositoryInstance.server\";\nimport { IEventRepository, TraceEventOptions } from \"./eventRepository.types\";\nimport { $replica, prisma } from \"~/db.server\";\nimport { logger } from \"~/services/logger.server\";\nimport { FEATURE_FLAG, flags } from \"../featureFlags.server\";\nimport { getTaskEventStore } from \"../taskEventStore.server\";\n\nexport function resolveEventRepositoryForStore(store: string | undefined): IEventRepository {\n  const taskEventStore = store ?? env.EVENT_REPOSITORY_DEFAULT_STORE;\n\n  if (taskEventStore === \"clickhouse_v2\") {\n    return clickhouseEventRepositoryV2;\n  }\n\n  if (taskEventStore === \"clickhouse\") {\n    return clickhouseEventRepository;\n  }\n\n  return eventRepository;\n}\n\nexport async function getEventRepository(\n  featureFlags: Record<string, unknown> | undefined\n): Promise<{ repository: IEventRepository; store: string }> {\n  const taskEventRepository = await resolveTaskEventRepositoryFlag(featureFlags);\n\n  if (taskEventRepository === \"clickhouse_v2\") {\n    return { repository: clickhouseEventRepositoryV2, store: \"clickhouse_v2\" };\n  }\n\n  if (taskEventRepository === \"clickhouse\") {\n    return { repository: clickhouseEventRepository, store: \"clickhouse\" };\n  }\n\n  return { repository: eventRepository, store: getTaskEventStore() };\n}\n\nexport async function getV3EventRepository(\n  parentStore: string | undefined\n): Promise<{ repository: IEventRepository; store: string }> {\n  if (typeof parentStore === \"string\") {\n    if (parentStore === \"clickhouse_v2\") {\n      return { repository: clickhouseEventRepositoryV2, store: \"clickhouse_v2\" };\n    }\n    if (parentStore === \"clickhouse\") {\n      return { repository: clickhouseEventRepository, store: \"clickhouse\" };\n    } else {\n      return { repository: eventRepository, store: getTaskEventStore() };\n    }\n  }\n\n  if (env.EVENT_REPOSITORY_DEFAULT_STORE === \"clickhouse_v2\") {\n    return { repository: clickhouseEventRepositoryV2, store: \"clickhouse_v2\" };\n  } else if (env.EVENT_REPOSITORY_DEFAULT_STORE === \"clickhouse\") {\n    return { repository: clickhouseEventRepository, store: \"clickhouse\" };\n  } else {\n    return { repository: eventRepository, store: getTaskEventStore() };\n  }\n}\n\nasync function resolveTaskEventRepositoryFlag(\n  featureFlags: Record<string, unknown> | undefined\n): Promise<\"clickhouse\" | \"clickhouse_v2\" | \"postgres\"> {\n  const flag = await flags({\n    key: FEATURE_FLAG.taskEventRepository,\n    defaultValue: env.EVENT_REPOSITORY_DEFAULT_STORE,\n    overrides: featureFlags,\n  });\n\n  if (flag === \"clickhouse_v2\") {\n    return \"clickhouse_v2\";\n  }\n\n  if (flag === \"clickhouse\") {\n    return \"clickhouse\";\n  }\n\n  if (env.EVENT_REPOSITORY_CLICKHOUSE_ROLLOUT_PERCENT) {\n    const rolloutPercent = env.EVENT_REPOSITORY_CLICKHOUSE_ROLLOUT_PERCENT;\n\n    const randomNumber = Math.random();\n\n    if (randomNumber < rolloutPercent) {\n      // Use the default store when rolling out (could be clickhouse or clickhouse_v2)\n      if (env.EVENT_REPOSITORY_DEFAULT_STORE === \"clickhouse_v2\") {\n        return \"clickhouse_v2\";\n      }\n      return \"clickhouse\";\n    }\n  }\n\n  return flag;\n}\n\nexport async function recordRunDebugLog(\n  runId: string,\n  message: string,\n  options: Omit<TraceEventOptions, \"environment\" | \"taskSlug\" | \"startTime\"> & {\n    duration?: number;\n    parentId?: string;\n    startTime?: Date;\n  }\n): Promise<\n  | {\n      success: true;\n    }\n  | {\n      success: false;\n      code: \"RUN_NOT_FOUND\" | \"FAILED_TO_RECORD_EVENT\";\n      error?: unknown;\n    }\n> {\n  if (env.EVENT_REPOSITORY_DEBUG_LOGS_DISABLED) {\n    // drop debug events silently\n    return {\n      success: true,\n    };\n  }\n\n  return recordRunEvent(runId, message, {\n    ...options,\n    attributes: {\n      ...options?.attributes,\n      isDebug: true,\n    },\n  });\n}\n\nasync function recordRunEvent(\n  runId: string,\n  message: string,\n  options: Omit<TraceEventOptions, \"environment\" | \"taskSlug\" | \"startTime\"> & {\n    duration?: number;\n    parentId?: string;\n    startTime?: Date;\n  }\n): Promise<\n  | {\n      success: true;\n    }\n  | {\n      success: false;\n      code: \"RUN_NOT_FOUND\" | \"FAILED_TO_RECORD_EVENT\";\n      error?: unknown;\n    }\n> {\n  try {\n    const foundRun = await findRunForEventCreation(runId);\n\n    if (!foundRun) {\n      logger.error(\"Failed to find run for event creation\", { runId });\n      return {\n        success: false,\n        code: \"RUN_NOT_FOUND\",\n      };\n    }\n\n    const $eventRepository = resolveEventRepositoryForStore(foundRun.taskEventStore);\n\n    const { attributes, startTime, ...optionsRest } = options;\n\n    await $eventRepository.recordEvent(message, {\n      environment: foundRun.runtimeEnvironment,\n      taskSlug: foundRun.taskIdentifier,\n      context: foundRun.traceContext as Record<string, string | undefined>,\n      attributes: {\n        runId: foundRun.friendlyId,\n        ...attributes,\n      },\n      startTime: BigInt((startTime?.getTime() ?? Date.now()) * 1_000_000),\n      ...optionsRest,\n    });\n\n    return {\n      success: true,\n    };\n  } catch (error) {\n    logger.error(\"Failed to record event for run\", {\n      error: error instanceof Error ? error.message : error,\n      runId,\n    });\n\n    return {\n      success: false,\n      code: \"FAILED_TO_RECORD_EVENT\",\n      error,\n    };\n  }\n}\n\nasync function findRunForEventCreation(runId: string) {\n  return prisma.taskRun.findFirst({\n    where: {\n      id: runId,\n    },\n    select: {\n      friendlyId: true,\n      taskIdentifier: true,\n      traceContext: true,\n      taskEventStore: true,\n      runtimeEnvironment: {\n        select: {\n          id: true,\n          type: true,\n          organizationId: true,\n          projectId: true,\n          project: {\n            select: {\n              externalRef: true,\n            },\n          },\n        },\n      },\n    },\n  });\n}",
            "output_extracted": "import { env } from \"~/env.server\";\nimport { eventRepository } from \"./eventRepository.server\";\nimport {\n  clickhouseEventRepository,\n  clickhouseEventRepositoryV2,\n} from \"./clickhouseEventRepositoryInstance.server\";\nimport { IEventRepository, TraceEventOptions } from \"./eventRepository.types\";\nimport { $replica, prisma } from \"~/db.server\";\nimport { logger } from \"~/services/logger.server\";\nimport { FEATURE_FLAG, flags } from \"../featureFlags.server\";\nimport { getTaskEventStore } from \"../taskEventStore.server\";\n\nexport function resolveEventRepositoryForStore(store: string | undefined): IEventRepository {\n  const taskEventStore = store ?? env.EVENT_REPOSITORY_DEFAULT_STORE;\n\n  if (taskEventStore === \"clickhouse_v2\") {\n    return clickhouseEventRepositoryV2;\n  }\n\n  if (taskEventStore === \"clickhouse\") {\n    return clickhouseEventRepository;\n  }\n\n  return eventRepository;\n}\n\nexport async function getEventRepository(\n  featureFlags: Record<string, unknown> | undefined\n): Promise<{ repository: IEventRepository; store: string }> {\n  const taskEventRepository = await resolveTaskEventRepositoryFlag(featureFlags);\n\n  if (taskEventRepository === \"clickhouse_v2\") {\n    return { repository: clickhouseEventRepositoryV2, store: \"clickhouse_v2\" };\n  }\n\n  if (taskEventRepository === \"clickhouse\") {\n    return { repository: clickhouseEventRepository, store: \"clickhouse\" };\n  }\n\n  return { repository: eventRepository, store: getTaskEventStore() };\n}\n\nexport async function getV3EventRepository(\n  parentStore: string | undefined\n): Promise<{ repository: IEventRepository; store: string }> {\n  if (typeof parentStore === \"string\") {\n    if (parentStore === \"clickhouse_v2\") {\n      return { repository: clickhouseEventRepositoryV2, store: \"clickhouse_v2\" };\n    }\n    if (parentStore === \"clickhouse\") {\n      return { repository: clickhouseEventRepository, store: \"clickhouse\" };\n    } else {\n      return { repository: eventRepository, store: getTaskEventStore() };\n    }\n  }\n\n  if (env.EVENT_REPOSITORY_DEFAULT_STORE === \"clickhouse_v2\") {\n    return { repository: clickhouseEventRepositoryV2, store: \"clickhouse_v2\" };\n  } else if (env.EVENT_REPOSITORY_DEFAULT_STORE === \"clickhouse\") {\n    return { repository: clickhouseEventRepository, store: \"clickhouse\" };\n  } else {\n    return { repository: eventRepository, store: getTaskEventStore() };\n  }\n}\n\nasync function resolveTaskEventRepositoryFlag(\n  featureFlags: Record<string, unknown> | undefined\n): Promise<\"clickhouse\" | \"clickhouse_v2\" | \"postgres\"> {\n  const flag = await flags({\n    key: FEATURE_FLAG.taskEventRepository,\n    defaultValue: env.EVENT_REPOSITORY_DEFAULT_STORE,\n    overrides: featureFlags,\n  });\n\n  if (flag === \"clickhouse_v2\") {\n    return \"clickhouse_v2\";\n  }\n\n  if (flag === \"clickhouse\") {\n    return \"clickhouse\";\n  }\n\n  if (env.EVENT_REPOSITORY_CLICKHOUSE_ROLLOUT_PERCENT) {\n    const rolloutPercent = env.EVENT_REPOSITORY_CLICKHOUSE_ROLLOUT_PERCENT;\n\n    const randomNumber = Math.random();\n\n    if (randomNumber < rolloutPercent) {\n      // Use the default store when rolling out (could be clickhouse or clickhouse_v2)\n      if (env.EVENT_REPOSITORY_DEFAULT_STORE === \"clickhouse_v2\") {\n        return \"clickhouse_v2\";\n      }\n      return \"clickhouse\";\n    }\n  }\n\n  return flag;\n}\n\nexport async function recordRunDebugLog(\n  runId: string,\n  message: string,\n  options: Omit<TraceEventOptions, \"environment\" | \"taskSlug\" | \"startTime\"> & {\n    duration?: number;\n    parentId?: string;\n    startTime?: Date;\n  }\n): Promise<\n  | {\n      success: true;\n    }\n  | {\n      success: false;\n      code: \"RUN_NOT_FOUND\" | \"FAILED_TO_RECORD_EVENT\";\n      error?: unknown;\n    }\n> {\n  if (env.EVENT_REPOSITORY_DEBUG_LOGS_DISABLED) {\n    // drop debug events silently\n    return {\n      success: true,\n    };\n  }\n\n  return recordRunEvent(runId, message, {\n    ...options,\n    attributes: {\n      ...options?.attributes,\n      isDebug: true,\n    },\n  });\n}\n\nasync function recordRunEvent(\n  runId: string,\n  message: string,\n  options: Omit<TraceEventOptions, \"environment\" | \"taskSlug\" | \"startTime\"> & {\n    duration?: number;\n    parentId?: string;\n    startTime?: Date;\n  }\n): Promise<\n  | {\n      success: true;\n    }\n  | {\n      success: false;\n      code: \"RUN_NOT_FOUND\" | \"FAILED_TO_RECORD_EVENT\";\n      error?: unknown;\n    }\n> {\n  try {\n    const foundRun = await findRunForEventCreation(runId);\n\n    if (!foundRun) {\n      logger.error(\"Failed to find run for event creation\", { runId });\n      return {\n        success: false,\n        code: \"RUN_NOT_FOUND\",\n      };\n    }\n\n    const $eventRepository = resolveEventRepositoryForStore(foundRun.taskEventStore);\n\n    const { attributes, startTime, ...optionsRest } = options;\n\n    await $eventRepository.recordEvent(message, {\n      environment: foundRun.runtimeEnvironment,\n      taskSlug: foundRun.taskIdentifier,\n      context: foundRun.traceContext as Record<string, string | undefined>,\n      attributes: {\n        runId: foundRun.friendlyId,\n        ...attributes,\n      },\n      startTime: BigInt((startTime?.getTime() ?? Date.now()) * 1_000_000),\n      ...optionsRest,\n    });\n\n    return {\n      success: true,\n    };\n  } catch (error) {\n    logger.error(\"Failed to record event for run\", {\n      error: error instanceof Error ? error.message : error,\n      runId,\n    });\n\n    return {\n      success: false,\n      code: \"FAILED_TO_RECORD_EVENT\",\n      error,\n    };\n  }\n}\n\nasync function findRunForEventCreation(runId: string) {\n  return prisma.taskRun.findFirst({\n    where: {\n      id: runId,\n    },\n    select: {\n      friendlyId: true,\n      taskIdentifier: true,\n      traceContext: true,\n      taskEventStore: true,\n      runtimeEnvironment: {\n        select: {\n          id: true,\n          type: true,\n          organizationId: true,\n          projectId: true,\n          project: {\n            select: {\n              externalRef: true,\n            },\n          },\n        },\n      },\n    },\n  });\n}",
            "cost": 0.060785000000000006
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/apps/webapp/app/v3/services/triggerTask.server.ts": {
            "output": "import { TriggerTaskRequestBody } from \"@trigger.dev/core/v3\";\nimport { RunEngineVersion, TaskRun } from \"@trigger.dev/database\";\nimport { IdempotencyKeyConcern } from \"~/runEngine/concerns/idempotencyKeys.server\";\nimport { DefaultPayloadProcessor } from \"~/runEngine/concerns/payloads.server\";\nimport { DefaultQueueManager } from \"~/runEngine/concerns/queues.server\";\nimport { DefaultRunNumberIncrementer } from \"~/runEngine/concerns/runNumbers.server\";\nimport { DefaultTraceEventsConcern } from \"~/runEngine/concerns/traceEvents.server\";\nimport { RunEngineTriggerTaskService } from \"~/runEngine/services/triggerTask.server\";\nimport { DefaultTriggerTaskValidator } from \"~/runEngine/validators/triggerTaskValidator\";\nimport { AuthenticatedEnvironment } from \"~/services/apiAuth.server\";\nimport { determineEngineVersion } from \"../engineVersion.server\";\nimport { eventRepository } from \"../eventRepository/eventRepository.server\";\nimport { tracer } from \"../tracer.server\";\nimport { WithRunEngine } from \"./baseService.server\";\nimport { TriggerTaskServiceV1 } from \"./triggerTaskV1.server\";\nimport { env } from \"~/env.server\";\nimport { clickhouseEventRepository } from \"../eventRepository/clickhouseEventRepositoryInstance.server\";\n\nexport type TriggerTaskServiceOptions = {\n  idempotencyKey?: string;\n  idempotencyKeyExpiresAt?: Date;\n  triggerVersion?: string;\n  traceContext?: Record<string, unknown>;\n  spanParentAsLink?: boolean;\n  parentAsLinkType?: \"replay\" | \"trigger\";\n  batchId?: string;\n  batchIndex?: number;\n  customIcon?: string;\n  runFriendlyId?: string;\n  skipChecks?: boolean;\n  oneTimeUseToken?: string;\n  scheduleId?: string;\n  scheduleInstanceId?: string;\n  queueTimestamp?: Date;\n  overrideCreatedAt?: Date;\n  replayedFromTaskRunFriendlyId?: string;\n  planType?: string;\n  realtimeStreamsVersion?: \"v1\" | \"v2\";\n};\n\nexport class OutOfEntitlementError extends Error {\n  constructor() {\n    super(\"You can't trigger a task because you have run out of credits.\");\n  }\n}\n\nexport type TriggerTaskServiceResult = {\n  run: TaskRun;\n  isCached: boolean;\n};\n\nexport const MAX_ATTEMPTS = 2;\n\nexport class TriggerTaskService extends WithRunEngine {\n  public async call(\n    taskId: string,\n    environment: AuthenticatedEnvironment,\n    body: TriggerTaskRequestBody,\n    options: TriggerTaskServiceOptions = {},\n    version?: RunEngineVersion\n  ): Promise<TriggerTaskServiceResult | undefined> {\n    return await this.traceWithEnv(\"call()\", environment, async (span) => {\n      span.setAttribute(\"taskId\", taskId);\n\n      const v = await determineEngineVersion({\n        environment,\n        workerVersion: body.options?.lockToVersion,\n        engineVersion: version,\n      });\n\n      switch (v) {\n        case \"V1\": {\n          return await this.callV1(taskId, environment, body, options);\n        }\n        case \"V2\": {\n          return await this.callV2(taskId, environment, body, options);\n        }\n      }\n    });\n  }\n\n  private async callV1(\n    taskId: string,\n    environment: AuthenticatedEnvironment,\n    body: TriggerTaskRequestBody,\n    options: TriggerTaskServiceOptions = {}\n  ): Promise<TriggerTaskServiceResult | undefined> {\n    const service = new TriggerTaskServiceV1(this._prisma);\n    return await service.call(taskId, environment, body, options);\n  }\n\n  private async callV2(\n    taskId: string,\n    environment: AuthenticatedEnvironment,\n    body: TriggerTaskRequestBody,\n    options: TriggerTaskServiceOptions = {}\n  ): Promise<TriggerTaskServiceResult | undefined> {\n    const traceEventConcern = new DefaultTraceEventsConcern(\n      eventRepository,\n      clickhouseEventRepository\n    );\n\n    const service = new RunEngineTriggerTaskService({\n      prisma: this._prisma,\n      engine: this._engine,\n      queueConcern: new DefaultQueueManager(this._prisma, this._engine),\n      validator: new DefaultTriggerTaskValidator(),\n      payloadProcessor: new DefaultPayloadProcessor(),\n      idempotencyKeyConcern: new IdempotencyKeyConcern(\n        this._prisma,\n        this._engine,\n        traceEventConcern\n      ),\n      runNumberIncrementer: new DefaultRunNumberIncrementer(),\n      traceEventConcern,\n      tracer: tracer,\n      metadataMaximumSize: env.TASK_RUN_METADATA_MAXIMUM_SIZE,\n    });\n\n    return await service.call({\n      taskId,\n      environment,\n      body,\n      options,\n    });\n  }\n}",
            "output_extracted": "import { TriggerTaskRequestBody } from \"@trigger.dev/core/v3\";\nimport { RunEngineVersion, TaskRun } from \"@trigger.dev/database\";\nimport { IdempotencyKeyConcern } from \"~/runEngine/concerns/idempotencyKeys.server\";\nimport { DefaultPayloadProcessor } from \"~/runEngine/concerns/payloads.server\";\nimport { DefaultQueueManager } from \"~/runEngine/concerns/queues.server\";\nimport { DefaultRunNumberIncrementer } from \"~/runEngine/concerns/runNumbers.server\";\nimport { DefaultTraceEventsConcern } from \"~/runEngine/concerns/traceEvents.server\";\nimport { RunEngineTriggerTaskService } from \"~/runEngine/services/triggerTask.server\";\nimport { DefaultTriggerTaskValidator } from \"~/runEngine/validators/triggerTaskValidator\";\nimport { AuthenticatedEnvironment } from \"~/services/apiAuth.server\";\nimport { determineEngineVersion } from \"../engineVersion.server\";\nimport { eventRepository } from \"../eventRepository/eventRepository.server\";\nimport { tracer } from \"../tracer.server\";\nimport { WithRunEngine } from \"./baseService.server\";\nimport { TriggerTaskServiceV1 } from \"./triggerTaskV1.server\";\nimport { env } from \"~/env.server\";\nimport { clickhouseEventRepository } from \"../eventRepository/clickhouseEventRepositoryInstance.server\";\n\nexport type TriggerTaskServiceOptions = {\n  idempotencyKey?: string;\n  idempotencyKeyExpiresAt?: Date;\n  triggerVersion?: string;\n  traceContext?: Record<string, unknown>;\n  spanParentAsLink?: boolean;\n  parentAsLinkType?: \"replay\" | \"trigger\";\n  batchId?: string;\n  batchIndex?: number;\n  customIcon?: string;\n  runFriendlyId?: string;\n  skipChecks?: boolean;\n  oneTimeUseToken?: string;\n  scheduleId?: string;\n  scheduleInstanceId?: string;\n  queueTimestamp?: Date;\n  overrideCreatedAt?: Date;\n  replayedFromTaskRunFriendlyId?: string;\n  planType?: string;\n  realtimeStreamsVersion?: \"v1\" | \"v2\";\n};\n\nexport class OutOfEntitlementError extends Error {\n  constructor() {\n    super(\"You can't trigger a task because you have run out of credits.\");\n  }\n}\n\nexport type TriggerTaskServiceResult = {\n  run: TaskRun;\n  isCached: boolean;\n};\n\nexport const MAX_ATTEMPTS = 2;\n\nexport class TriggerTaskService extends WithRunEngine {\n  public async call(\n    taskId: string,\n    environment: AuthenticatedEnvironment,\n    body: TriggerTaskRequestBody,\n    options: TriggerTaskServiceOptions = {},\n    version?: RunEngineVersion\n  ): Promise<TriggerTaskServiceResult | undefined> {\n    return await this.traceWithEnv(\"call()\", environment, async (span) => {\n      span.setAttribute(\"taskId\", taskId);\n\n      const v = await determineEngineVersion({\n        environment,\n        workerVersion: body.options?.lockToVersion,\n        engineVersion: version,\n      });\n\n      switch (v) {\n        case \"V1\": {\n          return await this.callV1(taskId, environment, body, options);\n        }\n        case \"V2\": {\n          return await this.callV2(taskId, environment, body, options);\n        }\n      }\n    });\n  }\n\n  private async callV1(\n    taskId: string,\n    environment: AuthenticatedEnvironment,\n    body: TriggerTaskRequestBody,\n    options: TriggerTaskServiceOptions = {}\n  ): Promise<TriggerTaskServiceResult | undefined> {\n    const service = new TriggerTaskServiceV1(this._prisma);\n    return await service.call(taskId, environment, body, options);\n  }\n\n  private async callV2(\n    taskId: string,\n    environment: AuthenticatedEnvironment,\n    body: TriggerTaskRequestBody,\n    options: TriggerTaskServiceOptions = {}\n  ): Promise<TriggerTaskServiceResult | undefined> {\n    const traceEventConcern = new DefaultTraceEventsConcern(\n      eventRepository,\n      clickhouseEventRepository\n    );\n\n    const service = new RunEngineTriggerTaskService({\n      prisma: this._prisma,\n      engine: this._engine,\n      queueConcern: new DefaultQueueManager(this._prisma, this._engine),\n      validator: new DefaultTriggerTaskValidator(),\n      payloadProcessor: new DefaultPayloadProcessor(),\n      idempotencyKeyConcern: new IdempotencyKeyConcern(\n        this._prisma,\n        this._engine,\n        traceEventConcern\n      ),\n      runNumberIncrementer: new DefaultRunNumberIncrementer(),\n      traceEventConcern,\n      tracer: tracer,\n      metadataMaximumSize: env.TASK_RUN_METADATA_MAXIMUM_SIZE,\n    });\n\n    return await service.call({\n      taskId,\n      environment,\n      body,\n      options,\n    });\n  }\n}",
            "cost": 0.04531
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/apps/webapp/app/v3/services/triggerTaskV1.server.ts": {
            "output": "import {\n  IOPacket,\n  packetRequiresOffloading,\n  taskRunErrorEnhancer,\n  taskRunErrorToString,\n  TriggerTaskRequestBody,\n} from \"@trigger.dev/core/v3\";\nimport {\n  parseNaturalLanguageDuration,\n  sanitizeQueueName,\n  stringifyDuration,\n} from \"@trigger.dev/core/v3/isomorphic\";\nimport { Prisma } from \"@trigger.dev/database\";\nimport { z } from \"zod\";\nimport { env } from \"~/env.server\";\nimport { createTag, MAX_TAGS_PER_RUN } from \"~/models/taskRunTag.server\";\nimport { AuthenticatedEnvironment } from \"~/services/apiAuth.server\";\nimport { autoIncrementCounter } from \"~/services/autoIncrementCounter.server\";\nimport { logger } from \"~/services/logger.server\";\nimport { getEntitlement } from \"~/services/platform.v3.server\";\nimport { parseDelay } from \"~/utils/delays\";\nimport { resolveIdempotencyKeyTTL } from \"~/utils/idempotencyKeys.server\";\nimport { handleMetadataPacket } from \"~/utils/packets\";\nimport { marqs } from \"~/v3/marqs/index.server\";\nimport { getV3EventRepository } from \"../eventRepository/index.server\";\nimport { generateFriendlyId } from \"../friendlyIdentifiers\";\nimport { findCurrentWorkerFromEnvironment } from \"../models/workerDeployment.server\";\nimport { guardQueueSizeLimitsForEnv } from \"../queueSizeLimits.server\";\nimport { uploadPacketToObjectStore } from \"../r2.server\";\nimport { removeQueueConcurrencyLimits, updateQueueConcurrencyLimits } from \"../runQueue.server\";\nimport { isFinalAttemptStatus, isFinalRunStatus } from \"../taskStatus\";\nimport { startActiveSpan } from \"../tracer.server\";\nimport { clampMaxDuration } from \"../utils/maxDuration\";\nimport { BaseService, ServiceValidationError } from \"./baseService.server\";\nimport { EnqueueDelayedRunService } from \"./enqueueDelayedRun.server\";\nimport { enqueueRun } from \"./enqueueRun.server\";\nimport { ExpireEnqueuedRunService } from \"./expireEnqueuedRun.server\";\nimport {\n  MAX_ATTEMPTS,\n  OutOfEntitlementError,\n  TriggerTaskServiceOptions,\n  TriggerTaskServiceResult,\n} from \"./triggerTask.server\";\n\n// This is here for backwords compatibility for v3 users\nconst QueueOptions = z.object({\n  name: z.string(),\n  concurrencyLimit: z.number().int().optional(),\n});\n\n/** @deprecated Use TriggerTaskService in `triggerTask.server.ts` instead. */\nexport class TriggerTaskServiceV1 extends BaseService {\n  public async call(\n    taskId: string,\n    environment: AuthenticatedEnvironment,\n    body: TriggerTaskRequestBody,\n    options: TriggerTaskServiceOptions = {},\n    attempt: number = 0\n  ): Promise<TriggerTaskServiceResult | undefined> {\n    return await this.traceWithEnv(\"call()\", environment, async (span) => {\n      span.setAttribute(\"taskId\", taskId);\n      span.setAttribute(\"attempt\", attempt);\n\n      if (attempt > MAX_ATTEMPTS) {\n        throw new ServiceValidationError(\n          `Failed to trigger ${taskId} after ${MAX_ATTEMPTS} attempts.`\n        );\n      }\n\n      const idempotencyKey = options.idempotencyKey ?? body.options?.idempotencyKey;\n      const idempotencyKeyExpiresAt =\n        options.idempotencyKeyExpiresAt ??\n        resolveIdempotencyKeyTTL(body.options?.idempotencyKeyTTL) ??\n        new Date(Date.now() + 24 * 60 * 60 * 1000 * 30); // 30 days\n\n      const delayUntil = await parseDelay(body.options?.delay);\n\n      const ttl =\n        typeof body.options?.ttl === \"number\"\n          ? stringifyDuration(body.options?.ttl)\n          : body.options?.ttl ?? (environment.type === \"DEVELOPMENT\" ? \"10m\" : undefined);\n\n      const existingRun = idempotencyKey\n        ? await this._prisma.taskRun.findFirst({\n            where: {\n              runtimeEnvironmentId: environment.id,\n              idempotencyKey,\n              taskIdentifier: taskId,\n            },\n          })\n        : undefined;\n\n      if (existingRun) {\n        if (\n          existingRun.idempotencyKeyExpiresAt &&\n          existingRun.idempotencyKeyExpiresAt < new Date()\n        ) {\n          logger.debug(\"[TriggerTaskService][call] Idempotency key has expired\", {\n            idempotencyKey: options.idempotencyKey,\n            run: existingRun,\n          });\n\n          // Update the existing batch to remove the idempotency key\n          await this._prisma.taskRun.update({\n            where: { id: existingRun.id },\n            data: { idempotencyKey: null },\n          });\n        } else {\n          span.setAttribute(\"runId\", existingRun.friendlyId);\n\n          return { run: existingRun, isCached: true };\n        }\n      }\n\n      if (environment.type !== \"DEVELOPMENT\" && !options.skipChecks) {\n        const result = await getEntitlement(environment.organizationId);\n        if (result && result.hasAccess === false) {\n          throw new OutOfEntitlementError();\n        }\n      }\n\n      if (!options.skipChecks) {\n        const queueSizeGuard = await guardQueueSizeLimitsForEnv(environment, marqs);\n\n        logger.debug(\"Queue size guard result\", {\n          queueSizeGuard,\n          environment: {\n            id: environment.id,\n            type: environment.type,\n            organization: environment.organization,\n            project: environment.project,\n          },\n        });\n\n        if (!queueSizeGuard.isWithinLimits) {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the queue size limit for this environment has been reached. The maximum size is ${queueSizeGuard.maximumSize}`\n          );\n        }\n      }\n\n      if (\n        body.options?.tags &&\n        typeof body.options.tags !== \"string\" &&\n        body.options.tags.length > MAX_TAGS_PER_RUN\n      ) {\n        throw new ServiceValidationError(\n          `Runs can only have ${MAX_TAGS_PER_RUN} tags, you're trying to set ${body.options.tags.length}.`\n        );\n      }\n\n      const runFriendlyId = options?.runFriendlyId ?? generateFriendlyId(\"run\");\n\n      const payloadPacket = await this.#handlePayloadPacket(\n        body.payload,\n        body.options?.payloadType ?? \"application/json\",\n        runFriendlyId,\n        environment\n      );\n\n      const metadataPacket = body.options?.metadata\n        ? handleMetadataPacket(\n            body.options?.metadata,\n            body.options?.metadataType ?? \"application/json\",\n            env.TASK_RUN_METADATA_MAXIMUM_SIZE\n          )\n        : undefined;\n\n      const dependentAttempt = body.options?.dependentAttempt\n        ? await this._prisma.taskRunAttempt.findFirst({\n            where: { friendlyId: body.options.dependentAttempt },\n            include: {\n              taskRun: {\n                select: {\n                  id: true,\n                  status: true,\n                  taskIdentifier: true,\n                  rootTaskRunId: true,\n                  depth: true,\n                  queueTimestamp: true,\n                  queue: true,\n                },\n              },\n            },\n          })\n        : undefined;\n\n      if (\n        dependentAttempt &&\n        (isFinalAttemptStatus(dependentAttempt.status) ||\n          isFinalRunStatus(dependentAttempt.taskRun.status))\n      ) {\n        logger.debug(\"Dependent attempt or run is in a terminal state\", {\n          dependentAttempt: dependentAttempt,\n        });\n\n        if (isFinalAttemptStatus(dependentAttempt.status)) {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the parent attempt has a status of ${dependentAttempt.status}`\n          );\n        } else {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the parent run has a status of ${dependentAttempt.taskRun.status}`\n          );\n        }\n      }\n\n      const parentAttempt = body.options?.parentAttempt\n        ? await this._prisma.taskRunAttempt.findFirst({\n            where: { friendlyId: body.options.parentAttempt },\n            include: {\n              taskRun: {\n                select: {\n                  id: true,\n                  status: true,\n                  taskIdentifier: true,\n                  rootTaskRunId: true,\n                  depth: true,\n                },\n              },\n            },\n          })\n        : undefined;\n\n      const dependentBatchRun = body.options?.dependentBatch\n        ? await this._prisma.batchTaskRun.findFirst({\n            where: { friendlyId: body.options.dependentBatch },\n            include: {\n              dependentTaskAttempt: {\n                include: {\n                  taskRun: {\n                    select: {\n                      id: true,\n                      status: true,\n                      taskIdentifier: true,\n                      rootTaskRunId: true,\n                      depth: true,\n                      queueTimestamp: true,\n                      queue: true,\n                    },\n                  },\n                },\n              },\n            },\n          })\n        : undefined;\n\n      if (\n        dependentBatchRun &&\n        dependentBatchRun.dependentTaskAttempt &&\n        (isFinalAttemptStatus(dependentBatchRun.dependentTaskAttempt.status) ||\n          isFinalRunStatus(dependentBatchRun.dependentTaskAttempt.taskRun.status))\n      ) {\n        logger.debug(\"Dependent batch run task attempt or run has been canceled\", {\n          dependentBatchRunId: dependentBatchRun.id,\n          status: dependentBatchRun.status,\n          attempt: dependentBatchRun.dependentTaskAttempt,\n        });\n\n        if (isFinalAttemptStatus(dependentBatchRun.dependentTaskAttempt.status)) {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the parent attempt has a status of ${dependentBatchRun.dependentTaskAttempt.status}`\n          );\n        } else {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the parent run has a status of ${dependentBatchRun.dependentTaskAttempt.taskRun.status}`\n          );\n        }\n      }\n\n      const parentBatchRun = body.options?.parentBatch\n        ? await this._prisma.batchTaskRun.findFirst({\n            where: { friendlyId: body.options.parentBatch },\n            include: {\n              dependentTaskAttempt: {\n                include: {\n                  taskRun: {\n                    select: {\n                      id: true,\n                      status: true,\n                      taskIdentifier: true,\n                      rootTaskRunId: true,\n                    },\n                  },\n                },\n              },\n            },\n          })\n        : undefined;\n\n      const { repository, store } = await getEventRepository(\n        environment.organization.featureFlags as Record<string, unknown>\n      );\n\n      try {\n        const result = await repository.traceEvent(\n          taskId,\n          {\n            context: options.traceContext,\n            spanParentAsLink: options.spanParentAsLink,\n            kind: \"SERVER\",\n            environment,\n            taskSlug: taskId,\n            attributes: {\n              properties: {},\n              style: {\n                icon: options.customIcon ?? \"task\",\n              },\n            },\n            incomplete: true,\n            immediate: true,\n            startTime: options.overrideCreatedAt\n              ? BigInt(options.overrideCreatedAt.getTime()) * BigInt(1000000)\n              : undefined,\n          },\n          async (event, traceContext, traceparent) => {\n            const run = await autoIncrementCounter.incrementInTransaction(\n              `v3-run:${environment.id}:${taskId}`,\n              async (num, tx) => {\n                const lockedToBackgroundWorker = body.options?.lockToVersion\n                  ? await tx.backgroundWorker.findFirst({\n                      where: {\n                        projectId: environment.projectId,\n                        runtimeEnvironmentId: environment.id,\n                        version: body.options?.lockToVersion,\n                      },\n                    })\n                  : undefined;\n\n                let queueName = sanitizeQueueName(\n                  await this.#getQueueName(taskId, environment, body.options?.queue?.name)\n                );\n\n                // Check that the queuename is not an empty string\n                if (!queueName) {\n                  queueName = sanitizeQueueName(`task/${taskId}`);\n                }\n\n                span.setAttribute(\"queueName\", queueName);\n\n                //upsert tags\n                let tagIds: string[] = [];\n                const bodyTags =\n                  typeof body.options?.tags === \"string\" ? [body.options.tags] : body.options?.tags;\n                if (bodyTags && bodyTags.length > 0) {\n                  for (const tag of bodyTags) {\n                    const tagRecord = await createTag({\n                      tag,\n                      projectId: environment.projectId,\n                    });\n                    if (tagRecord) {\n                      tagIds.push(tagRecord.id);\n                    }\n                  }\n                }\n\n                const depth = dependentAttempt\n                  ? dependentAttempt.taskRun.depth + 1\n                  : parentAttempt\n                  ? parentAttempt.taskRun.depth + 1\n                  : dependentBatchRun?.dependentTaskAttempt\n                  ? dependentBatchRun.dependentTaskAttempt.taskRun.depth + 1\n                  : 0;\n\n                const queueTimestamp =\n                  options.queueTimestamp ??\n                  dependentAttempt?.taskRun.queueTimestamp ??\n                  dependentBatchRun?.dependentTaskAttempt?.taskRun.queueTimestamp ??\n                  delayUntil ??\n                  new Date();\n\n                const taskRun = await tx.taskRun.create({\n                  data: {\n                    status: delayUntil ? \"DELAYED\" : \"PENDING\",\n                    number: num,\n                    friendlyId: runFriendlyId,\n                    runtimeEnvironmentId: environment.id,\n                    environmentType: environment.type,\n                    organizationId: environment.organizationId,\n                    projectId: environment.projectId,\n                    idempotencyKey,\n                    idempotencyKeyExpiresAt: idempotencyKey ? idempotencyKeyExpiresAt : undefined,\n                    taskIdentifier: taskId,\n                    payload: payloadPacket.data ?? \"\",\n                    payloadType: payloadPacket.dataType,\n                    context: body.context,\n                    traceContext: traceContext,\n                    traceId: event.traceId,\n                    spanId: event.spanId,\n                    parentSpanId:\n                      options.parentAsLinkType === \"replay\" ? undefined : traceparent?.spanId,\n                    lockedToVersionId: lockedToBackgroundWorker?.id,\n                    taskVersion: lockedToBackgroundWorker?.version,\n                    sdkVersion: lockedToBackgroundWorker?.sdkVersion,\n                    cliVersion: lockedToBackgroundWorker?.cliVersion,\n                    concurrencyKey: body.options?.concurrencyKey,",
            "output_extracted": "import {\n  IOPacket,\n  packetRequiresOffloading,\n  taskRunErrorEnhancer,\n  taskRunErrorToString,\n  TriggerTaskRequestBody,\n} from \"@trigger.dev/core/v3\";\nimport {\n  parseNaturalLanguageDuration,\n  sanitizeQueueName,\n  stringifyDuration,\n} from \"@trigger.dev/core/v3/isomorphic\";\nimport { Prisma } from \"@trigger.dev/database\";\nimport { z } from \"zod\";\nimport { env } from \"~/env.server\";\nimport { createTag, MAX_TAGS_PER_RUN } from \"~/models/taskRunTag.server\";\nimport { AuthenticatedEnvironment } from \"~/services/apiAuth.server\";\nimport { autoIncrementCounter } from \"~/services/autoIncrementCounter.server\";\nimport { logger } from \"~/services/logger.server\";\nimport { getEntitlement } from \"~/services/platform.v3.server\";\nimport { parseDelay } from \"~/utils/delays\";\nimport { resolveIdempotencyKeyTTL } from \"~/utils/idempotencyKeys.server\";\nimport { handleMetadataPacket } from \"~/utils/packets\";\nimport { marqs } from \"~/v3/marqs/index.server\";\nimport { getV3EventRepository } from \"../eventRepository/index.server\";\nimport { generateFriendlyId } from \"../friendlyIdentifiers\";\nimport { findCurrentWorkerFromEnvironment } from \"../models/workerDeployment.server\";\nimport { guardQueueSizeLimitsForEnv } from \"../queueSizeLimits.server\";\nimport { uploadPacketToObjectStore } from \"../r2.server\";\nimport { removeQueueConcurrencyLimits, updateQueueConcurrencyLimits } from \"../runQueue.server\";\nimport { isFinalAttemptStatus, isFinalRunStatus } from \"../taskStatus\";\nimport { startActiveSpan } from \"../tracer.server\";\nimport { clampMaxDuration } from \"../utils/maxDuration\";\nimport { BaseService, ServiceValidationError } from \"./baseService.server\";\nimport { EnqueueDelayedRunService } from \"./enqueueDelayedRun.server\";\nimport { enqueueRun } from \"./enqueueRun.server\";\nimport { ExpireEnqueuedRunService } from \"./expireEnqueuedRun.server\";\nimport {\n  MAX_ATTEMPTS,\n  OutOfEntitlementError,\n  TriggerTaskServiceOptions,\n  TriggerTaskServiceResult,\n} from \"./triggerTask.server\";\n\n// This is here for backwords compatibility for v3 users\nconst QueueOptions = z.object({\n  name: z.string(),\n  concurrencyLimit: z.number().int().optional(),\n});\n\n/** @deprecated Use TriggerTaskService in `triggerTask.server.ts` instead. */\nexport class TriggerTaskServiceV1 extends BaseService {\n  public async call(\n    taskId: string,\n    environment: AuthenticatedEnvironment,\n    body: TriggerTaskRequestBody,\n    options: TriggerTaskServiceOptions = {},\n    attempt: number = 0\n  ): Promise<TriggerTaskServiceResult | undefined> {\n    return await this.traceWithEnv(\"call()\", environment, async (span) => {\n      span.setAttribute(\"taskId\", taskId);\n      span.setAttribute(\"attempt\", attempt);\n\n      if (attempt > MAX_ATTEMPTS) {\n        throw new ServiceValidationError(\n          `Failed to trigger ${taskId} after ${MAX_ATTEMPTS} attempts.`\n        );\n      }\n\n      const idempotencyKey = options.idempotencyKey ?? body.options?.idempotencyKey;\n      const idempotencyKeyExpiresAt =\n        options.idempotencyKeyExpiresAt ??\n        resolveIdempotencyKeyTTL(body.options?.idempotencyKeyTTL) ??\n        new Date(Date.now() + 24 * 60 * 60 * 1000 * 30); // 30 days\n\n      const delayUntil = await parseDelay(body.options?.delay);\n\n      const ttl =\n        typeof body.options?.ttl === \"number\"\n          ? stringifyDuration(body.options?.ttl)\n          : body.options?.ttl ?? (environment.type === \"DEVELOPMENT\" ? \"10m\" : undefined);\n\n      const existingRun = idempotencyKey\n        ? await this._prisma.taskRun.findFirst({\n            where: {\n              runtimeEnvironmentId: environment.id,\n              idempotencyKey,\n              taskIdentifier: taskId,\n            },\n          })\n        : undefined;\n\n      if (existingRun) {\n        if (\n          existingRun.idempotencyKeyExpiresAt &&\n          existingRun.idempotencyKeyExpiresAt < new Date()\n        ) {\n          logger.debug(\"[TriggerTaskService][call] Idempotency key has expired\", {\n            idempotencyKey: options.idempotencyKey,\n            run: existingRun,\n          });\n\n          // Update the existing batch to remove the idempotency key\n          await this._prisma.taskRun.update({\n            where: { id: existingRun.id },\n            data: { idempotencyKey: null },\n          });\n        } else {\n          span.setAttribute(\"runId\", existingRun.friendlyId);\n\n          return { run: existingRun, isCached: true };\n        }\n      }\n\n      if (environment.type !== \"DEVELOPMENT\" && !options.skipChecks) {\n        const result = await getEntitlement(environment.organizationId);\n        if (result && result.hasAccess === false) {\n          throw new OutOfEntitlementError();\n        }\n      }\n\n      if (!options.skipChecks) {\n        const queueSizeGuard = await guardQueueSizeLimitsForEnv(environment, marqs);\n\n        logger.debug(\"Queue size guard result\", {\n          queueSizeGuard,\n          environment: {\n            id: environment.id,\n            type: environment.type,\n            organization: environment.organization,\n            project: environment.project,\n          },\n        });\n\n        if (!queueSizeGuard.isWithinLimits) {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the queue size limit for this environment has been reached. The maximum size is ${queueSizeGuard.maximumSize}`\n          );\n        }\n      }\n\n      if (\n        body.options?.tags &&\n        typeof body.options.tags !== \"string\" &&\n        body.options.tags.length > MAX_TAGS_PER_RUN\n      ) {\n        throw new ServiceValidationError(\n          `Runs can only have ${MAX_TAGS_PER_RUN} tags, you're trying to set ${body.options.tags.length}.`\n        );\n      }\n\n      const runFriendlyId = options?.runFriendlyId ?? generateFriendlyId(\"run\");\n\n      const payloadPacket = await this.#handlePayloadPacket(\n        body.payload,\n        body.options?.payloadType ?? \"application/json\",\n        runFriendlyId,\n        environment\n      );\n\n      const metadataPacket = body.options?.metadata\n        ? handleMetadataPacket(\n            body.options?.metadata,\n            body.options?.metadataType ?? \"application/json\",\n            env.TASK_RUN_METADATA_MAXIMUM_SIZE\n          )\n        : undefined;\n\n      const dependentAttempt = body.options?.dependentAttempt\n        ? await this._prisma.taskRunAttempt.findFirst({\n            where: { friendlyId: body.options.dependentAttempt },\n            include: {\n              taskRun: {\n                select: {\n                  id: true,\n                  status: true,\n                  taskIdentifier: true,\n                  rootTaskRunId: true,\n                  depth: true,\n                  queueTimestamp: true,\n                  queue: true,\n                },\n              },\n            },\n          })\n        : undefined;\n\n      if (\n        dependentAttempt &&\n        (isFinalAttemptStatus(dependentAttempt.status) ||\n          isFinalRunStatus(dependentAttempt.taskRun.status))\n      ) {\n        logger.debug(\"Dependent attempt or run is in a terminal state\", {\n          dependentAttempt: dependentAttempt,\n        });\n\n        if (isFinalAttemptStatus(dependentAttempt.status)) {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the parent attempt has a status of ${dependentAttempt.status}`\n          );\n        } else {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the parent run has a status of ${dependentAttempt.taskRun.status}`\n          );\n        }\n      }\n\n      const parentAttempt = body.options?.parentAttempt\n        ? await this._prisma.taskRunAttempt.findFirst({\n            where: { friendlyId: body.options.parentAttempt },\n            include: {\n              taskRun: {\n                select: {\n                  id: true,\n                  status: true,\n                  taskIdentifier: true,\n                  rootTaskRunId: true,\n                  depth: true,\n                },\n              },\n            },\n          })\n        : undefined;\n\n      const dependentBatchRun = body.options?.dependentBatch\n        ? await this._prisma.batchTaskRun.findFirst({\n            where: { friendlyId: body.options.dependentBatch },\n            include: {\n              dependentTaskAttempt: {\n                include: {\n                  taskRun: {\n                    select: {\n                      id: true,\n                      status: true,\n                      taskIdentifier: true,\n                      rootTaskRunId: true,\n                      depth: true,\n                      queueTimestamp: true,\n                      queue: true,\n                    },\n                  },\n                },\n              },\n            },\n          })\n        : undefined;\n\n      if (\n        dependentBatchRun &&\n        dependentBatchRun.dependentTaskAttempt &&\n        (isFinalAttemptStatus(dependentBatchRun.dependentTaskAttempt.status) ||\n          isFinalRunStatus(dependentBatchRun.dependentTaskAttempt.taskRun.status))\n      ) {\n        logger.debug(\"Dependent batch run task attempt or run has been canceled\", {\n          dependentBatchRunId: dependentBatchRun.id,\n          status: dependentBatchRun.status,\n          attempt: dependentBatchRun.dependentTaskAttempt,\n        });\n\n        if (isFinalAttemptStatus(dependentBatchRun.dependentTaskAttempt.status)) {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the parent attempt has a status of ${dependentBatchRun.dependentTaskAttempt.status}`\n          );\n        } else {\n          throw new ServiceValidationError(\n            `Cannot trigger ${taskId} as the parent run has a status of ${dependentBatchRun.dependentTaskAttempt.taskRun.status}`\n          );\n        }\n      }\n\n      const parentBatchRun = body.options?.parentBatch\n        ? await this._prisma.batchTaskRun.findFirst({\n            where: { friendlyId: body.options.parentBatch },\n            include: {\n              dependentTaskAttempt: {\n                include: {\n                  taskRun: {\n                    select: {\n                      id: true,\n                      status: true,\n                      taskIdentifier: true,\n                      rootTaskRunId: true,\n                    },\n                  },\n                },\n              },\n            },\n          })\n        : undefined;\n\n      const { repository, store } = await getEventRepository(\n        environment.organization.featureFlags as Record<string, unknown>\n      );\n\n      try {\n        const result = await repository.traceEvent(\n          taskId,\n          {\n            context: options.traceContext,\n            spanParentAsLink: options.spanParentAsLink,\n            kind: \"SERVER\",\n            environment,\n            taskSlug: taskId,\n            attributes: {\n              properties: {},\n              style: {\n                icon: options.customIcon ?? \"task\",\n              },\n            },\n            incomplete: true,\n            immediate: true,\n            startTime: options.overrideCreatedAt\n              ? BigInt(options.overrideCreatedAt.getTime()) * BigInt(1000000)\n              : undefined,\n          },\n          async (event, traceContext, traceparent) => {\n            const run = await autoIncrementCounter.incrementInTransaction(\n              `v3-run:${environment.id}:${taskId}`,\n              async (num, tx) => {\n                const lockedToBackgroundWorker = body.options?.lockToVersion\n                  ? await tx.backgroundWorker.findFirst({\n                      where: {\n                        projectId: environment.projectId,\n                        runtimeEnvironmentId: environment.id,\n                        version: body.options?.lockToVersion,\n                      },\n                    })\n                  : undefined;\n\n                let queueName = sanitizeQueueName(\n                  await this.#getQueueName(taskId, environment, body.options?.queue?.name)\n                );\n\n                // Check that the queuename is not an empty string\n                if (!queueName) {\n                  queueName = sanitizeQueueName(`task/${taskId}`);\n                }\n\n                span.setAttribute(\"queueName\", queueName);\n\n                //upsert tags\n                let tagIds: string[] = [];\n                const bodyTags =\n                  typeof body.options?.tags === \"string\" ? [body.options.tags] : body.options?.tags;\n                if (bodyTags && bodyTags.length > 0) {\n                  for (const tag of bodyTags) {\n                    const tagRecord = await createTag({\n                      tag,\n                      projectId: environment.projectId,\n                    });\n                    if (tagRecord) {\n                      tagIds.push(tagRecord.id);\n                    }\n                  }\n                }\n\n                const depth = dependentAttempt\n                  ? dependentAttempt.taskRun.depth + 1\n                  : parentAttempt\n                  ? parentAttempt.taskRun.depth + 1\n                  : dependentBatchRun?.dependentTaskAttempt\n                  ? dependentBatchRun.dependentTaskAttempt.taskRun.depth + 1\n                  : 0;\n\n                const queueTimestamp =\n                  options.queueTimestamp ??\n                  dependentAttempt?.taskRun.queueTimestamp ??\n                  dependentBatchRun?.dependentTaskAttempt?.taskRun.queueTimestamp ??\n                  delayUntil ??\n                  new Date();\n\n                const taskRun = await tx.taskRun.create({\n                  data: {\n                    status: delayUntil ? \"DELAYED\" : \"PENDING\",\n                    number: num,\n                    friendlyId: runFriendlyId,\n                    runtimeEnvironmentId: environment.id,\n                    environmentType: environment.type,\n                    organizationId: environment.organizationId,\n                    projectId: environment.projectId,\n                    idempotencyKey,\n                    idempotencyKeyExpiresAt: idempotencyKey ? idempotencyKeyExpiresAt : undefined,\n                    taskIdentifier: taskId,\n                    payload: payloadPacket.data ?? \"\",\n                    payloadType: payloadPacket.dataType,\n                    context: body.context,\n                    traceContext: traceContext,\n                    traceId: event.traceId,\n                    spanId: event.spanId,\n                    parentSpanId:\n                      options.parentAsLinkType === \"replay\" ? undefined : traceparent?.spanId,\n                    lockedToVersionId: lockedToBackgroundWorker?.id,\n                    taskVersion: lockedToBackgroundWorker?.version,\n                    sdkVersion: lockedToBackgroundWorker?.sdkVersion,\n                    cliVersion: lockedToBackgroundWorker?.cliVersion,\n                    concurrencyKey: body.options?.concurrencyKey,",
            "cost": 0.14608500000000002
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/apps/webapp/test/engine/triggerTask.test.ts": {
            "output": "import { describe, expect, vi } from \"vitest\";\n\n// Mock the db prisma client\nvi.mock(\"~/db.server\", () => ({\n  prisma: {},\n  $replica: {},\n}));\n\nvi.mock(\"~/services/platform.v3.server\", async (importOriginal) => {\n  const actual = (await importOriginal()) as Record<string, unknown>;\n  return {\n    ...actual,\n    getEntitlement: vi.fn(),\n  };\n});\n\nimport { RunEngine } from \"@internal/run-engine\";\nimport { setupAuthenticatedEnvironment, setupBackgroundWorker } from \"@internal/run-engine/tests\";\nimport { assertNonNullable, containerTest } from \"@internal/testcontainers\";\nimport { trace } from \"@opentelemetry/api\";\nimport { IOPacket } from \"@trigger.dev/core/v3\";\nimport { TaskRun } from \"@trigger.dev/database\";\nimport { IdempotencyKeyConcern } from \"~/runEngine/concerns/idempotencyKeys.server\";\nimport { DefaultQueueManager } from \"~/runEngine/concerns/queues.server\";\nimport {\n  EntitlementValidationParams,\n  MaxAttemptsValidationParams,\n  ParentRunValidationParams,\n  PayloadProcessor,\n  RunNumberIncrementer,\n  TagValidationParams,\n  TracedEventSpan,\n  TraceEventConcern,\n  TriggerRacepoints,\n  TriggerRacepointSystem,\n  TriggerTaskRequest,\n  TriggerTaskValidator,\n  ValidationResult,\n} from \"~/runEngine/types\";\nimport { RunEngineTriggerTaskService } from \"../../app/runEngine/services/triggerTask.server\";\nimport { promiseWithResolvers } from \"@trigger.dev/core\";\nimport { setTimeout } from \"node:timers/promises\";\n\nvi.setConfig({ testTimeout: 30_000 }); // 30 seconds timeout\n\nclass MockRunNumberIncrementer implements RunNumberIncrementer {\n  async incrementRunNumber<T>(\n    request: TriggerTaskRequest,\n    callback: (num: number) => Promise<T>\n  ): Promise<T | undefined> {\n    return await callback(1);\n  }\n}\n\nclass MockPayloadProcessor implements PayloadProcessor {\n  async process(request: TriggerTaskRequest): Promise<IOPacket> {\n    return {\n      data: JSON.stringify(request.body.payload),\n      dataType: \"application/json\",\n    };\n  }\n}\n\nclass MockTriggerTaskValidator implements TriggerTaskValidator {\n  validateTags(params: TagValidationParams): ValidationResult {\n    return { ok: true };\n  }\n  validateEntitlement(params: EntitlementValidationParams): Promise<ValidationResult> {\n    return Promise.resolve({ ok: true });\n  }\n  validateMaxAttempts(params: MaxAttemptsValidationParams): ValidationResult {\n    return { ok: true };\n  }\n  validateParentRun(params: ParentRunValidationParams): ValidationResult {\n    return { ok: true };\n  }\n}\n\nclass MockTraceEventConcern implements TraceEventConcern {\n  async traceRun<T>(\n    request: TriggerTaskRequest,\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T> {\n    return await callback(\n      {\n        traceId: \"test\",\n        spanId: \"test\",\n        traceContext: {},\n        traceparent: undefined,\n        setAttribute: () => {},\n        failWithError: () => {},\n      },\n      \"test\"\n    );\n  }\n\n  async traceIdempotentRun<T>(\n    request: TriggerTaskRequest,\n    options: {\n      existingRun: TaskRun;\n      idempotencyKey: string;\n      incomplete: boolean;\n      isError: boolean;\n    },\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T> {\n    return await callback(\n      {\n        traceId: \"test\",\n        spanId: \"test\",\n        traceContext: {},\n        traceparent: undefined,\n        setAttribute: () => {},\n        failWithError: () => {},\n      },\n      \"test\"\n    );\n  }\n}\n\ntype TriggerRacepoint = { promise: Promise<void>; resolve: (value: void) => void };\n\nclass MockTriggerRacepointSystem implements TriggerRacepointSystem {\n  private racepoints: Record<string, TriggerRacepoint | undefined> = {};\n\n  async waitForRacepoint({ id }: { racepoint: TriggerRacepoints; id: string }): Promise<void> {\n    const racepoint = this.racepoints[id];\n\n    if (racepoint) {\n      return racepoint.promise;\n    }\n\n    return Promise.resolve();\n  }\n\n  registerRacepoint(racepoint: TriggerRacepoints, id: string): TriggerRacepoint {\n    const { promise, resolve } = promiseWithResolvers<void>();\n    this.racepoints[id] = { promise, resolve };\n\n    return { promise, resolve };\n  }\n}\n\ndescribe(\"RunEngineTriggerTaskService\", () => {\n  containerTest(\"should trigger a task with minimal options\", async ({ prisma, redisOptions }) => {\n    const engine = new RunEngine({\n      prisma,\n      worker: {\n        redis: redisOptions,\n        workers: 1,\n        tasksPerWorker: 10,\n        pollIntervalMs: 100,\n      },\n      queue: {\n        redis: redisOptions,\n      },\n      runLock: {\n        redis: redisOptions,\n      },\n      machines: {\n        defaultMachine: \"small-1x\",\n        machines: {\n          \"small-1x\": {\n            name: \"small-1x\" as const,\n            cpu: 0.5,\n            memory: 0.5,\n            centsPerMs: 0.0001,\n          },\n        },\n        baseCostInCents: 0.0005,\n      },\n      tracer: trace.getTracer(\"test\", \"0.0.0\"),\n    });\n\n    const authenticatedEnvironment = await setupAuthenticatedEnvironment(prisma, \"PRODUCTION\");\n\n    const taskIdentifier = \"test-task\";\n\n    //create background worker\n    await setupBackgroundWorker(engine, authenticatedEnvironment, taskIdentifier);\n\n    const queuesManager = new DefaultQueueManager(prisma, engine);\n\n    const idempotencyKeyConcern = new IdempotencyKeyConcern(\n      prisma,\n      engine,\n      new MockTraceEventConcern()\n    );\n\n    const triggerTaskService = new RunEngineTriggerTaskService({\n      engine,\n      prisma,\n      runNumberIncrementer: new MockRunNumberIncrementer(),\n      payloadProcessor: new MockPayloadProcessor(),\n      queueConcern: queuesManager,\n      idempotencyKeyConcern,\n      validator: new MockTriggerTaskValidator(),\n      traceEventConcern: new MockTraceEventConcern(),\n      tracer: trace.getTracer(\"test\", \"0.0.0\"),\n      metadataMaximumSize: 1024 * 1024 * 1, // 1MB\n    });\n\n    const result = await triggerTaskService.call({\n      taskId: taskIdentifier,\n      environment: authenticatedEnvironment,\n      body: { payload: { test: \"test\" } },\n    });\n\n    expect(result).toBeDefined();\n    expect(result?.run.friendlyId).toBeDefined();\n    expect(result?.run.status).toBe(\"PENDING\");\n    expect(result?.isCached).toBe(false);\n\n    const run = await prisma.taskRun.findUnique({\n      where: {\n        id: result?.run.id,\n      },\n    });\n\n    expect(run).toBeDefined();\n    expect(run?.friendlyId).toBe(result?.run.friendlyId);\n    expect(run?.engine).toBe(\"V2\");\n    expect(run?.queuedAt).toBeDefined();\n    expect(run?.queue).toBe(`task/${taskIdentifier}`);\n\n    // Lets make sure the task is in the queue\n    const queueLength = await engine.runQueue.lengthOfQueue(\n      authenticatedEnvironment,\n      `task/${taskIdentifier}`\n    );\n    expect(queueLength).toBe(1);\n\n    await engine.quit();\n  });\n\n  containerTest(\"should handle idempotency keys correctly\", async ({ prisma, redisOptions }) => {\n    const engine = new RunEngine({\n      prisma,\n      worker: {\n        redis: redisOptions,\n        workers: 1,\n        tasksPerWorker: 10,\n        pollIntervalMs: 100,\n      },\n      queue: {\n        redis: redisOptions,\n      },\n      runLock: {\n        redis: redisOptions,\n      },\n      machines: {\n        defaultMachine: \"small-1x\",\n        machines: {\n          \"small-1x\": {\n            name: \"small-1x\" as const,\n            cpu: 0.5,\n            memory: 0.5,\n            centsPerMs: 0.0001,\n          },\n        },\n        baseCostInCents: 0.0005,\n      },\n      tracer: trace.getTracer(\"test\", \"0.0.0\"),\n    });\n\n    const authenticatedEnvironment = await setupAuthenticatedEnvironment(prisma, \"PRODUCTION\");\n\n    const taskIdentifier = \"test-task\";\n\n    //create background worker\n    await setupBackgroundWorker(engine, authenticatedEnvironment, taskIdentifier);\n\n    const queuesManager = new DefaultQueueManager(prisma, engine);\n\n    const idempotencyKeyConcern = new IdempotencyKeyConcern(\n      prisma,\n      engine,\n      new MockTraceEventConcern()\n    );\n\n    const triggerTaskService = new RunEngineTriggerTaskService({\n      engine,\n      prisma,\n      runNumberIncrementer: new MockRunNumberIncrementer(),\n      payloadProcessor: new MockPayloadProcessor(),\n      queueConcern: queuesManager,\n      idempotencyKeyConcern,\n      validator: new MockTriggerTaskValidator(),\n      traceEventConcern: new MockTraceEventConcern(),\n      tracer: trace.getTracer(\"test\", \"0.0.0\"),\n      metadataMaximumSize: 1024 * 1024 * 1, // 1MB\n    });\n\n    const result = await triggerTaskService.call({\n      taskId: taskIdentifier,\n      environment: authenticatedEnvironment,\n      body: {\n        payload: { test: \"test\" },\n        options: {\n          idempotencyKey: \"test-idempotency-key\",\n        },\n      },\n    });\n\n    expect(result).toBeDefined();\n    expect(result?.run.friendlyId).toBeDefined();\n    expect(result?.run.status).toBe(\"PENDING\");\n    expect(result?.isCached).toBe(false);\n\n    const run = await prisma.taskRun.findUnique({\n      where: {\n        id: result?.run.id,\n      },\n    });\n\n    expect(run).toBeDefined();\n    expect(run?.friendlyId).toBe(result?.run.friendlyId);\n    expect(run?.engine).toBe(\"V2\");\n    expect(run?.queuedAt).toBeDefined();\n    expect(run?.queue).toBe(`task/${taskIdentifier}`);\n\n    // Lets make sure the task is in the queue\n    const queueLength = await engine.runQueue.lengthOfQueue(\n      authenticatedEnvironment,\n      `task/${taskIdentifier}`\n    );\n    expect(queueLength).toBe(1);\n\n    // Now lets try to trigger the same task with the same idempotency key\n    const cachedResult = await triggerTaskService.call({\n      taskId: taskIdentifier,\n      environment: authenticatedEnvironment,\n      body: {\n        payload: { test: \"test\" },\n        options: {\n          idempotencyKey: \"test-idempotency-key\",\n        },\n      },\n    });\n\n    expect(cachedResult).toBeDefined();\n    expect(cachedResult?.run.friendlyId).toBe(result?.run.friendlyId);\n    expect(cachedResult?.isCached).toBe(true);\n\n    await engine.quit();\n  });\n\n  containerTest(\n    \"should handle idempotency keys when the engine throws an RunDuplicateIdempotencyKeyError\",\n    async ({ prisma, redisOptions }) => {\n      const engine = new RunEngine({\n        prisma,\n        worker: {\n          redis: redisOptions,\n          workers: 1,\n          tasksPerWorker: 10,\n          pollIntervalMs: 100,\n        },\n        queue: {\n          redis: redisOptions,\n        },\n        runLock: {\n          redis: redisOptions,\n        },\n        machines: {\n          defaultMachine: \"small-1x\",\n          machines: {\n            \"small-1x\": {\n              name: \"small-1x\" as const,\n              cpu: 0.5,\n              memory: 0.5,\n              centsPerMs: 0.0001,\n            },\n          },\n          baseCostInCents: 0.0005,\n        },\n        tracer: trace.getTracer(\"test\", \"0.0.0\"),\n        logLevel: \"debug\",\n      });\n\n      const parentTask = \"parent-task\";\n\n      const authenticatedEnvironment = await setupAuthenticatedEnvironment(prisma, \"PRODUCTION\");\n\n      const taskIdentifier = \"test-task\";\n\n      //create background worker\n      await setupBackgroundWorker(engine, authenticatedEnvironment, [parentTask, taskIdentifier]);\n\n      const parentRun1 = await engine.trigger(\n        {\n          number: 1,\n          friendlyId: \"run_p1\",\n          environment: authenticatedEnvironment,\n          taskIdentifier: parentTask,\n          payload: \"{}\",\n          payloadType: \"application/json\",\n          context: {},\n          traceContext: {},\n          traceId: \"t12345\",\n          spanId: \"s12345\",\n          queue: `task/${parentTask}`,\n          isTest: false,\n          tags: [],\n          workerQueue: \"main\",\n        },\n        prisma\n      );\n\n      //dequeue parent and create the attempt\n      await setTimeout(500);\n      const dequeued = await engine.dequeueFromWorkerQueue({\n        consumerId: \"test_12345\",\n        workerQueue: \"main\",\n      });\n      await engine.startRunAttempt({\n        runId: parentRun1.id,\n        snapshotId: dequeued[0].snapshot.id,\n      });\n\n      const parentRun2 = await engine.trigger(\n        {\n          number: 2,\n          friendlyId: \"run_p2\",\n          environment: authenticatedEnvironment,\n          taskIdentifier: parentTask,\n          payload: \"{}\",\n          payloadType: \"application/json\",\n          context: {},\n          traceContext: {},\n          traceId: \"t12346\",\n          spanId: \"s12346\",\n          queue: `task/${parentTask}`,\n          isTest: false,\n          tags: [],\n          workerQueue: \"main\",\n        },\n        prisma\n      );\n\n      await setTimeout(500);\n      const dequeued2 = await engine.dequeueFromWorkerQueue({\n        consumerId: \"test_12345\",\n        workerQueue: \"main\",\n      });\n      await engine.startRunAttempt({\n        runId: parentRun2.id,\n        snapshotId: dequeued2[0].snapshot.id,\n      });\n\n      const queuesManager = new DefaultQueueManager(prisma, engine);\n\n      const idempotencyKeyConcern = new IdempotencyKeyConcern(\n        prisma,\n        engine,\n        new MockTraceEventConcern()\n      );\n\n      const triggerRacepointSystem = new MockTriggerRacepointSystem();\n\n      const triggerTaskService = new RunEngineTriggerTaskService({\n        engine,\n        prisma,\n        runNumberIncrementer: new MockRunNumberIncrementer(),\n        payloadProcessor: new MockPayloadProcessor(),",
            "output_extracted": "import { describe, expect, vi } from \"vitest\";\n\n// Mock the db prisma client\nvi.mock(\"~/db.server\", () => ({\n  prisma: {},\n  $replica: {},\n}));\n\nvi.mock(\"~/services/platform.v3.server\", async (importOriginal) => {\n  const actual = (await importOriginal()) as Record<string, unknown>;\n  return {\n    ...actual,\n    getEntitlement: vi.fn(),\n  };\n});\n\nimport { RunEngine } from \"@internal/run-engine\";\nimport { setupAuthenticatedEnvironment, setupBackgroundWorker } from \"@internal/run-engine/tests\";\nimport { assertNonNullable, containerTest } from \"@internal/testcontainers\";\nimport { trace } from \"@opentelemetry/api\";\nimport { IOPacket } from \"@trigger.dev/core/v3\";\nimport { TaskRun } from \"@trigger.dev/database\";\nimport { IdempotencyKeyConcern } from \"~/runEngine/concerns/idempotencyKeys.server\";\nimport { DefaultQueueManager } from \"~/runEngine/concerns/queues.server\";\nimport {\n  EntitlementValidationParams,\n  MaxAttemptsValidationParams,\n  ParentRunValidationParams,\n  PayloadProcessor,\n  RunNumberIncrementer,\n  TagValidationParams,\n  TracedEventSpan,\n  TraceEventConcern,\n  TriggerRacepoints,\n  TriggerRacepointSystem,\n  TriggerTaskRequest,\n  TriggerTaskValidator,\n  ValidationResult,\n} from \"~/runEngine/types\";\nimport { RunEngineTriggerTaskService } from \"../../app/runEngine/services/triggerTask.server\";\nimport { promiseWithResolvers } from \"@trigger.dev/core\";\nimport { setTimeout } from \"node:timers/promises\";\n\nvi.setConfig({ testTimeout: 30_000 }); // 30 seconds timeout\n\nclass MockRunNumberIncrementer implements RunNumberIncrementer {\n  async incrementRunNumber<T>(\n    request: TriggerTaskRequest,\n    callback: (num: number) => Promise<T>\n  ): Promise<T | undefined> {\n    return await callback(1);\n  }\n}\n\nclass MockPayloadProcessor implements PayloadProcessor {\n  async process(request: TriggerTaskRequest): Promise<IOPacket> {\n    return {\n      data: JSON.stringify(request.body.payload),\n      dataType: \"application/json\",\n    };\n  }\n}\n\nclass MockTriggerTaskValidator implements TriggerTaskValidator {\n  validateTags(params: TagValidationParams): ValidationResult {\n    return { ok: true };\n  }\n  validateEntitlement(params: EntitlementValidationParams): Promise<ValidationResult> {\n    return Promise.resolve({ ok: true });\n  }\n  validateMaxAttempts(params: MaxAttemptsValidationParams): ValidationResult {\n    return { ok: true };\n  }\n  validateParentRun(params: ParentRunValidationParams): ValidationResult {\n    return { ok: true };\n  }\n}\n\nclass MockTraceEventConcern implements TraceEventConcern {\n  async traceRun<T>(\n    request: TriggerTaskRequest,\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T> {\n    return await callback(\n      {\n        traceId: \"test\",\n        spanId: \"test\",\n        traceContext: {},\n        traceparent: undefined,\n        setAttribute: () => {},\n        failWithError: () => {},\n      },\n      \"test\"\n    );\n  }\n\n  async traceIdempotentRun<T>(\n    request: TriggerTaskRequest,\n    options: {\n      existingRun: TaskRun;\n      idempotencyKey: string;\n      incomplete: boolean;\n      isError: boolean;\n    },\n    callback: (span: TracedEventSpan, store: string) => Promise<T>\n  ): Promise<T> {\n    return await callback(\n      {\n        traceId: \"test\",\n        spanId: \"test\",\n        traceContext: {},\n        traceparent: undefined,\n        setAttribute: () => {},\n        failWithError: () => {},\n      },\n      \"test\"\n    );\n  }\n}\n\ntype TriggerRacepoint = { promise: Promise<void>; resolve: (value: void) => void };\n\nclass MockTriggerRacepointSystem implements TriggerRacepointSystem {\n  private racepoints: Record<string, TriggerRacepoint | undefined> = {};\n\n  async waitForRacepoint({ id }: { racepoint: TriggerRacepoints; id: string }): Promise<void> {\n    const racepoint = this.racepoints[id];\n\n    if (racepoint) {\n      return racepoint.promise;\n    }\n\n    return Promise.resolve();\n  }\n\n  registerRacepoint(racepoint: TriggerRacepoints, id: string): TriggerRacepoint {\n    const { promise, resolve } = promiseWithResolvers<void>();\n    this.racepoints[id] = { promise, resolve };\n\n    return { promise, resolve };\n  }\n}\n\ndescribe(\"RunEngineTriggerTaskService\", () => {\n  containerTest(\"should trigger a task with minimal options\", async ({ prisma, redisOptions }) => {\n    const engine = new RunEngine({\n      prisma,\n      worker: {\n        redis: redisOptions,\n        workers: 1,\n        tasksPerWorker: 10,\n        pollIntervalMs: 100,\n      },\n      queue: {\n        redis: redisOptions,\n      },\n      runLock: {\n        redis: redisOptions,\n      },\n      machines: {\n        defaultMachine: \"small-1x\",\n        machines: {\n          \"small-1x\": {\n            name: \"small-1x\" as const,\n            cpu: 0.5,\n            memory: 0.5,\n            centsPerMs: 0.0001,\n          },\n        },\n        baseCostInCents: 0.0005,\n      },\n      tracer: trace.getTracer(\"test\", \"0.0.0\"),\n    });\n\n    const authenticatedEnvironment = await setupAuthenticatedEnvironment(prisma, \"PRODUCTION\");\n\n    const taskIdentifier = \"test-task\";\n\n    //create background worker\n    await setupBackgroundWorker(engine, authenticatedEnvironment, taskIdentifier);\n\n    const queuesManager = new DefaultQueueManager(prisma, engine);\n\n    const idempotencyKeyConcern = new IdempotencyKeyConcern(\n      prisma,\n      engine,\n      new MockTraceEventConcern()\n    );\n\n    const triggerTaskService = new RunEngineTriggerTaskService({\n      engine,\n      prisma,\n      runNumberIncrementer: new MockRunNumberIncrementer(),\n      payloadProcessor: new MockPayloadProcessor(),\n      queueConcern: queuesManager,\n      idempotencyKeyConcern,\n      validator: new MockTriggerTaskValidator(),\n      traceEventConcern: new MockTraceEventConcern(),\n      tracer: trace.getTracer(\"test\", \"0.0.0\"),\n      metadataMaximumSize: 1024 * 1024 * 1, // 1MB\n    });\n\n    const result = await triggerTaskService.call({\n      taskId: taskIdentifier,\n      environment: authenticatedEnvironment,\n      body: { payload: { test: \"test\" } },\n    });\n\n    expect(result).toBeDefined();\n    expect(result?.run.friendlyId).toBeDefined();\n    expect(result?.run.status).toBe(\"PENDING\");\n    expect(result?.isCached).toBe(false);\n\n    const run = await prisma.taskRun.findUnique({\n      where: {\n        id: result?.run.id,\n      },\n    });\n\n    expect(run).toBeDefined();\n    expect(run?.friendlyId).toBe(result?.run.friendlyId);\n    expect(run?.engine).toBe(\"V2\");\n    expect(run?.queuedAt).toBeDefined();\n    expect(run?.queue).toBe(`task/${taskIdentifier}`);\n\n    // Lets make sure the task is in the queue\n    const queueLength = await engine.runQueue.lengthOfQueue(\n      authenticatedEnvironment,\n      `task/${taskIdentifier}`\n    );\n    expect(queueLength).toBe(1);\n\n    await engine.quit();\n  });\n\n  containerTest(\"should handle idempotency keys correctly\", async ({ prisma, redisOptions }) => {\n    const engine = new RunEngine({\n      prisma,\n      worker: {\n        redis: redisOptions,\n        workers: 1,\n        tasksPerWorker: 10,\n        pollIntervalMs: 100,\n      },\n      queue: {\n        redis: redisOptions,\n      },\n      runLock: {\n        redis: redisOptions,\n      },\n      machines: {\n        defaultMachine: \"small-1x\",\n        machines: {\n          \"small-1x\": {\n            name: \"small-1x\" as const,\n            cpu: 0.5,\n            memory: 0.5,\n            centsPerMs: 0.0001,\n          },\n        },\n        baseCostInCents: 0.0005,\n      },\n      tracer: trace.getTracer(\"test\", \"0.0.0\"),\n    });\n\n    const authenticatedEnvironment = await setupAuthenticatedEnvironment(prisma, \"PRODUCTION\");\n\n    const taskIdentifier = \"test-task\";\n\n    //create background worker\n    await setupBackgroundWorker(engine, authenticatedEnvironment, taskIdentifier);\n\n    const queuesManager = new DefaultQueueManager(prisma, engine);\n\n    const idempotencyKeyConcern = new IdempotencyKeyConcern(\n      prisma,\n      engine,\n      new MockTraceEventConcern()\n    );\n\n    const triggerTaskService = new RunEngineTriggerTaskService({\n      engine,\n      prisma,\n      runNumberIncrementer: new MockRunNumberIncrementer(),\n      payloadProcessor: new MockPayloadProcessor(),\n      queueConcern: queuesManager,\n      idempotencyKeyConcern,\n      validator: new MockTriggerTaskValidator(),\n      traceEventConcern: new MockTraceEventConcern(),\n      tracer: trace.getTracer(\"test\", \"0.0.0\"),\n      metadataMaximumSize: 1024 * 1024 * 1, // 1MB\n    });\n\n    const result = await triggerTaskService.call({\n      taskId: taskIdentifier,\n      environment: authenticatedEnvironment,\n      body: {\n        payload: { test: \"test\" },\n        options: {\n          idempotencyKey: \"test-idempotency-key\",\n        },\n      },\n    });\n\n    expect(result).toBeDefined();\n    expect(result?.run.friendlyId).toBeDefined();\n    expect(result?.run.status).toBe(\"PENDING\");\n    expect(result?.isCached).toBe(false);\n\n    const run = await prisma.taskRun.findUnique({\n      where: {\n        id: result?.run.id,\n      },\n    });\n\n    expect(run).toBeDefined();\n    expect(run?.friendlyId).toBe(result?.run.friendlyId);\n    expect(run?.engine).toBe(\"V2\");\n    expect(run?.queuedAt).toBeDefined();\n    expect(run?.queue).toBe(`task/${taskIdentifier}`);\n\n    // Lets make sure the task is in the queue\n    const queueLength = await engine.runQueue.lengthOfQueue(\n      authenticatedEnvironment,\n      `task/${taskIdentifier}`\n    );\n    expect(queueLength).toBe(1);\n\n    // Now lets try to trigger the same task with the same idempotency key\n    const cachedResult = await triggerTaskService.call({\n      taskId: taskIdentifier,\n      environment: authenticatedEnvironment,\n      body: {\n        payload: { test: \"test\" },\n        options: {\n          idempotencyKey: \"test-idempotency-key\",\n        },\n      },\n    });\n\n    expect(cachedResult).toBeDefined();\n    expect(cachedResult?.run.friendlyId).toBe(result?.run.friendlyId);\n    expect(cachedResult?.isCached).toBe(true);\n\n    await engine.quit();\n  });\n\n  containerTest(\n    \"should handle idempotency keys when the engine throws an RunDuplicateIdempotencyKeyError\",\n    async ({ prisma, redisOptions }) => {\n      const engine = new RunEngine({\n        prisma,\n        worker: {\n          redis: redisOptions,\n          workers: 1,\n          tasksPerWorker: 10,\n          pollIntervalMs: 100,\n        },\n        queue: {\n          redis: redisOptions,\n        },\n        runLock: {\n          redis: redisOptions,\n        },\n        machines: {\n          defaultMachine: \"small-1x\",\n          machines: {\n            \"small-1x\": {\n              name: \"small-1x\" as const,\n              cpu: 0.5,\n              memory: 0.5,\n              centsPerMs: 0.0001,\n            },\n          },\n          baseCostInCents: 0.0005,\n        },\n        tracer: trace.getTracer(\"test\", \"0.0.0\"),\n        logLevel: \"debug\",\n      });\n\n      const parentTask = \"parent-task\";\n\n      const authenticatedEnvironment = await setupAuthenticatedEnvironment(prisma, \"PRODUCTION\");\n\n      const taskIdentifier = \"test-task\";\n\n      //create background worker\n      await setupBackgroundWorker(engine, authenticatedEnvironment, [parentTask, taskIdentifier]);\n\n      const parentRun1 = await engine.trigger(\n        {\n          number: 1,\n          friendlyId: \"run_p1\",\n          environment: authenticatedEnvironment,\n          taskIdentifier: parentTask,\n          payload: \"{}\",\n          payloadType: \"application/json\",\n          context: {},\n          traceContext: {},\n          traceId: \"t12345\",\n          spanId: \"s12345\",\n          queue: `task/${parentTask}`,\n          isTest: false,\n          tags: [],\n          workerQueue: \"main\",\n        },\n        prisma\n      );\n\n      //dequeue parent and create the attempt\n      await setTimeout(500);\n      const dequeued = await engine.dequeueFromWorkerQueue({\n        consumerId: \"test_12345\",\n        workerQueue: \"main\",\n      });\n      await engine.startRunAttempt({\n        runId: parentRun1.id,\n        snapshotId: dequeued[0].snapshot.id,\n      });\n\n      const parentRun2 = await engine.trigger(\n        {\n          number: 2,\n          friendlyId: \"run_p2\",\n          environment: authenticatedEnvironment,\n          taskIdentifier: parentTask,\n          payload: \"{}\",\n          payloadType: \"application/json\",\n          context: {},\n          traceContext: {},\n          traceId: \"t12346\",\n          spanId: \"s12346\",\n          queue: `task/${parentTask}`,\n          isTest: false,\n          tags: [],\n          workerQueue: \"main\",\n        },\n        prisma\n      );\n\n      await setTimeout(500);\n      const dequeued2 = await engine.dequeueFromWorkerQueue({\n        consumerId: \"test_12345\",\n        workerQueue: \"main\",\n      });\n      await engine.startRunAttempt({\n        runId: parentRun2.id,\n        snapshotId: dequeued2[0].snapshot.id,\n      });\n\n      const queuesManager = new DefaultQueueManager(prisma, engine);\n\n      const idempotencyKeyConcern = new IdempotencyKeyConcern(\n        prisma,\n        engine,\n        new MockTraceEventConcern()\n      );\n\n      const triggerRacepointSystem = new MockTriggerRacepointSystem();\n\n      const triggerTaskService = new RunEngineTriggerTaskService({\n        engine,\n        prisma,\n        runNumberIncrementer: new MockRunNumberIncrementer(),\n        payloadProcessor: new MockPayloadProcessor(),",
            "cost": 0.14001000000000002
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "triggerdotdev__trigger.dev.pr_mirror.2583",
        "repo": "triggerdotdev/trigger.dev",
        "base_commit": "cdd1a8838cc24c489997ea50a294e60b1ed41c0b",
        "head_commit": "efe15f5804649ac233ad85dee5eff18ed624c94d",
        "title": "fix(otel): propagate the task event store to run descendants",
        "merged_at": "2025-10-04T14:28:17Z",
        "html_url": "https://github.com/triggerdotdev/trigger.dev/pull/2583",
        "test_files": [
            "apps/webapp/test/engine/triggerTask.test.ts"
        ],
        "code_files": [
            "apps/webapp/app/runEngine/concerns/idempotencyKeys.server.ts",
            "apps/webapp/app/runEngine/concerns/traceEvents.server.ts",
            "apps/webapp/app/runEngine/services/triggerTask.server.ts",
            "apps/webapp/app/runEngine/types.ts",
            "apps/webapp/app/v3/eventRepository/index.server.ts",
            "apps/webapp/app/v3/services/triggerTask.server.ts",
            "apps/webapp/app/v3/services/triggerTaskV1.server.ts"
        ],
        "total_changes": 265,
        "num_files": 8,
        "pull_number": 2583,
        "patch": "diff --git a/apps/webapp/app/runEngine/concerns/idempotencyKeys.server.ts b/apps/webapp/app/runEngine/concerns/idempotencyKeys.server.ts\nindex 3080ae871a..d22c8020d2 100644\n--- a/apps/webapp/app/runEngine/concerns/idempotencyKeys.server.ts\n+++ b/apps/webapp/app/runEngine/concerns/idempotencyKeys.server.ts\n@@ -17,7 +17,10 @@ export class IdempotencyKeyConcern {\n     private readonly traceEventConcern: TraceEventConcern\n   ) {}\n \n-  async handleTriggerRequest(request: TriggerTaskRequest): Promise<IdempotencyKeyConcernResult> {\n+  async handleTriggerRequest(\n+    request: TriggerTaskRequest,\n+    parentStore: string | undefined\n+  ): Promise<IdempotencyKeyConcernResult> {\n     const idempotencyKey = request.options?.idempotencyKey ?? request.body.options?.idempotencyKey;\n     const idempotencyKeyExpiresAt =\n       request.options?.idempotencyKeyExpiresAt ??\n@@ -83,6 +86,7 @@ export class IdempotencyKeyConcern {\n       if (associatedWaitpoint && resumeParentOnCompletion && parentRunId) {\n         await this.traceEventConcern.traceIdempotentRun(\n           request,\n+          parentStore,\n           {\n             existingRun,\n             idempotencyKey,\ndiff --git a/apps/webapp/app/runEngine/concerns/traceEvents.server.ts b/apps/webapp/app/runEngine/concerns/traceEvents.server.ts\nindex 7d880a5e57..634df34e4a 100644\n--- a/apps/webapp/app/runEngine/concerns/traceEvents.server.ts\n+++ b/apps/webapp/app/runEngine/concerns/traceEvents.server.ts\n@@ -1,39 +1,26 @@\n-import { EventRepository } from \"~/v3/eventRepository/eventRepository.server\";\n-import { TracedEventSpan, TraceEventConcern, TriggerTaskRequest } from \"../types\";\n import { SemanticInternalAttributes } from \"@trigger.dev/core/v3/semanticInternalAttributes\";\n import { TaskRun } from \"@trigger.dev/database\";\n-import { getTaskEventStore } from \"~/v3/taskEventStore.server\";\n-import { ClickhouseEventRepository } from \"~/v3/eventRepository/clickhouseEventRepository.server\";\n import { IEventRepository } from \"~/v3/eventRepository/eventRepository.types\";\n-import { FEATURE_FLAG, flags } from \"~/v3/featureFlags.server\";\n-import { env } from \"~/env.server\";\n import { getEventRepository } from \"~/v3/eventRepository/index.server\";\n+import { TracedEventSpan, TraceEventConcern, TriggerTaskRequest } from \"../types\";\n \n export class DefaultTraceEventsConcern implements TraceEventConcern {\n-  private readonly eventRepository: EventRepository;\n-  private readonly clickhouseEventRepository: ClickhouseEventRepository;\n-\n-  constructor(\n-    eventRepository: EventRepository,\n-    clickhouseEventRepository: ClickhouseEventRepository\n-  ) {\n-    this.eventRepository = eventRepository;\n-    this.clickhouseEventRepository = clickhouseEventRepository;\n-  }\n-\n   async #getEventRepository(\n-    request: TriggerTaskRequest\n+    request: TriggerTaskRequest,\n+    parentStore: string | undefined\n   ): Promise<{ repository: IEventRepository; store: string }> {\n     return await getEventRepository(\n-      request.environment.organization.featureFlags as Record<string, unknown>\n+      request.environment.organization.featureFlags as Record<string, unknown>,\n+      parentStore\n     );\n   }\n \n   async traceRun<T>(\n     request: TriggerTaskRequest,\n+    parentStore: string | undefined,\n     callback: (span: TracedEventSpan, store: string) => Promise<T>\n   ): Promise<T> {\n-    const { repository, store } = await this.#getEventRepository(request);\n+    const { repository, store } = await this.#getEventRepository(request, parentStore);\n \n     return await repository.traceEvent(\n       request.taskId,\n@@ -73,6 +60,7 @@ export class DefaultTraceEventsConcern implements TraceEventConcern {\n \n   async traceIdempotentRun<T>(\n     request: TriggerTaskRequest,\n+    parentStore: string | undefined,\n     options: {\n       existingRun: TaskRun;\n       idempotencyKey: string;\n@@ -82,7 +70,7 @@ export class DefaultTraceEventsConcern implements TraceEventConcern {\n     callback: (span: TracedEventSpan, store: string) => Promise<T>\n   ): Promise<T> {\n     const { existingRun, idempotencyKey, incomplete, isError } = options;\n-    const { repository, store } = await this.#getEventRepository(request);\n+    const { repository, store } = await this.#getEventRepository(request, parentStore);\n \n     return await repository.traceEvent(\n       `${request.taskId} (cached)`,\n@@ -107,7 +95,7 @@ export class DefaultTraceEventsConcern implements TraceEventConcern {\n       },\n       async (event, traceContext, traceparent) => {\n         //log a message\n-        await this.eventRepository.recordEvent(\n+        await repository.recordEvent(\n           `There's an existing run for idempotencyKey: ${idempotencyKey}`,\n           {\n             taskSlug: request.taskId,\ndiff --git a/apps/webapp/app/runEngine/services/triggerTask.server.ts b/apps/webapp/app/runEngine/services/triggerTask.server.ts\nindex 4916e237bb..144d9b3178 100644\n--- a/apps/webapp/app/runEngine/services/triggerTask.server.ts\n+++ b/apps/webapp/app/runEngine/services/triggerTask.server.ts\n@@ -197,7 +197,8 @@ export class RunEngineTriggerTaskService {\n       }\n \n       const idempotencyKeyConcernResult = await this.idempotencyKeyConcern.handleTriggerRequest(\n-        triggerRequest\n+        triggerRequest,\n+        parentRun?.taskEventStore\n       );\n \n       if (idempotencyKeyConcernResult.isCached) {\n@@ -266,105 +267,109 @@ export class RunEngineTriggerTaskService {\n       const workerQueue = await this.queueConcern.getWorkerQueue(environment, body.options?.region);\n \n       try {\n-        return await this.traceEventConcern.traceRun(triggerRequest, async (event, store) => {\n-          const result = await this.runNumberIncrementer.incrementRunNumber(\n-            triggerRequest,\n-            async (num) => {\n-              event.setAttribute(\"queueName\", queueName);\n-              span.setAttribute(\"queueName\", queueName);\n-              event.setAttribute(\"runId\", runFriendlyId);\n-              span.setAttribute(\"runId\", runFriendlyId);\n-\n-              const payloadPacket = await this.payloadProcessor.process(triggerRequest);\n-\n-              const taskRun = await this.engine.trigger(\n-                {\n-                  number: num,\n-                  friendlyId: runFriendlyId,\n-                  environment: environment,\n-                  idempotencyKey,\n-                  idempotencyKeyExpiresAt: idempotencyKey ? idempotencyKeyExpiresAt : undefined,\n-                  taskIdentifier: taskId,\n-                  payload: payloadPacket.data ?? \"\",\n-                  payloadType: payloadPacket.dataType,\n-                  context: body.context,\n-                  traceContext: this.#propagateExternalTraceContext(\n-                    event.traceContext,\n-                    parentRun?.traceContext,\n-                    event.traceparent?.spanId\n-                  ),\n-                  traceId: event.traceId,\n-                  spanId: event.spanId,\n-                  parentSpanId:\n-                    options.parentAsLinkType === \"replay\" ? undefined : event.traceparent?.spanId,\n-                  replayedFromTaskRunFriendlyId: options.replayedFromTaskRunFriendlyId,\n-                  lockedToVersionId: lockedToBackgroundWorker?.id,\n-                  taskVersion: lockedToBackgroundWorker?.version,\n-                  sdkVersion: lockedToBackgroundWorker?.sdkVersion,\n-                  cliVersion: lockedToBackgroundWorker?.cliVersion,\n-                  concurrencyKey: body.options?.concurrencyKey,\n-                  queue: queueName,\n-                  lockedQueueId,\n-                  workerQueue,\n-                  isTest: body.options?.test ?? false,\n-                  delayUntil,\n-                  queuedAt: delayUntil ? undefined : new Date(),\n-                  maxAttempts: body.options?.maxAttempts,\n-                  taskEventStore: store,\n-                  ttl,\n-                  tags,\n-                  oneTimeUseToken: options.oneTimeUseToken,\n-                  parentTaskRunId: parentRun?.id,\n-                  rootTaskRunId: parentRun?.rootTaskRunId ?? parentRun?.id,\n-                  batch: options?.batchId\n-                    ? {\n-                        id: options.batchId,\n-                        index: options.batchIndex ?? 0,\n-                      }\n-                    : undefined,\n-                  resumeParentOnCompletion: body.options?.resumeParentOnCompletion,\n-                  depth,\n-                  metadata: metadataPacket?.data,\n-                  metadataType: metadataPacket?.dataType,\n-                  seedMetadata: metadataPacket?.data,\n-                  seedMetadataType: metadataPacket?.dataType,\n-                  maxDurationInSeconds: body.options?.maxDuration\n-                    ? clampMaxDuration(body.options.maxDuration)\n-                    : undefined,\n-                  machine: body.options?.machine,\n-                  priorityMs: body.options?.priority ? body.options.priority * 1_000 : undefined,\n-                  queueTimestamp:\n-                    options.queueTimestamp ??\n-                    (parentRun && body.options?.resumeParentOnCompletion\n-                      ? parentRun.queueTimestamp ?? undefined\n-                      : undefined),\n-                  scheduleId: options.scheduleId,\n-                  scheduleInstanceId: options.scheduleInstanceId,\n-                  createdAt: options.overrideCreatedAt,\n-                  bulkActionId: body.options?.bulkActionId,\n-                  planType,\n-                },\n-                this.prisma\n-              );\n-\n-              const error = taskRun.error ? TaskRunError.parse(taskRun.error) : undefined;\n-\n-              if (error) {\n-                event.failWithError(error);\n+        return await this.traceEventConcern.traceRun(\n+          triggerRequest,\n+          parentRun?.taskEventStore,\n+          async (event, store) => {\n+            const result = await this.runNumberIncrementer.incrementRunNumber(\n+              triggerRequest,\n+              async (num) => {\n+                event.setAttribute(\"queueName\", queueName);\n+                span.setAttribute(\"queueName\", queueName);\n+                event.setAttribute(\"runId\", runFriendlyId);\n+                span.setAttribute(\"runId\", runFriendlyId);\n+\n+                const payloadPacket = await this.payloadProcessor.process(triggerRequest);\n+\n+                const taskRun = await this.engine.trigger(\n+                  {\n+                    number: num,\n+                    friendlyId: runFriendlyId,\n+                    environment: environment,\n+                    idempotencyKey,\n+                    idempotencyKeyExpiresAt: idempotencyKey ? idempotencyKeyExpiresAt : undefined,\n+                    taskIdentifier: taskId,\n+                    payload: payloadPacket.data ?? \"\",\n+                    payloadType: payloadPacket.dataType,\n+                    context: body.context,\n+                    traceContext: this.#propagateExternalTraceContext(\n+                      event.traceContext,\n+                      parentRun?.traceContext,\n+                      event.traceparent?.spanId\n+                    ),\n+                    traceId: event.traceId,\n+                    spanId: event.spanId,\n+                    parentSpanId:\n+                      options.parentAsLinkType === \"replay\" ? undefined : event.traceparent?.spanId,\n+                    replayedFromTaskRunFriendlyId: options.replayedFromTaskRunFriendlyId,\n+                    lockedToVersionId: lockedToBackgroundWorker?.id,\n+                    taskVersion: lockedToBackgroundWorker?.version,\n+                    sdkVersion: lockedToBackgroundWorker?.sdkVersion,\n+                    cliVersion: lockedToBackgroundWorker?.cliVersion,\n+                    concurrencyKey: body.options?.concurrencyKey,\n+                    queue: queueName,\n+                    lockedQueueId,\n+                    workerQueue,\n+                    isTest: body.options?.test ?? false,\n+                    delayUntil,\n+                    queuedAt: delayUntil ? undefined : new Date(),\n+                    maxAttempts: body.options?.maxAttempts,\n+                    taskEventStore: store,\n+                    ttl,\n+                    tags,\n+                    oneTimeUseToken: options.oneTimeUseToken,\n+                    parentTaskRunId: parentRun?.id,\n+                    rootTaskRunId: parentRun?.rootTaskRunId ?? parentRun?.id,\n+                    batch: options?.batchId\n+                      ? {\n+                          id: options.batchId,\n+                          index: options.batchIndex ?? 0,\n+                        }\n+                      : undefined,\n+                    resumeParentOnCompletion: body.options?.resumeParentOnCompletion,\n+                    depth,\n+                    metadata: metadataPacket?.data,\n+                    metadataType: metadataPacket?.dataType,\n+                    seedMetadata: metadataPacket?.data,\n+                    seedMetadataType: metadataPacket?.dataType,\n+                    maxDurationInSeconds: body.options?.maxDuration\n+                      ? clampMaxDuration(body.options.maxDuration)\n+                      : undefined,\n+                    machine: body.options?.machine,\n+                    priorityMs: body.options?.priority ? body.options.priority * 1_000 : undefined,\n+                    queueTimestamp:\n+                      options.queueTimestamp ??\n+                      (parentRun && body.options?.resumeParentOnCompletion\n+                        ? parentRun.queueTimestamp ?? undefined\n+                        : undefined),\n+                    scheduleId: options.scheduleId,\n+                    scheduleInstanceId: options.scheduleInstanceId,\n+                    createdAt: options.overrideCreatedAt,\n+                    bulkActionId: body.options?.bulkActionId,\n+                    planType,\n+                  },\n+                  this.prisma\n+                );\n+\n+                const error = taskRun.error ? TaskRunError.parse(taskRun.error) : undefined;\n+\n+                if (error) {\n+                  event.failWithError(error);\n+                }\n+\n+                return { run: taskRun, error, isCached: false };\n               }\n+            );\n \n-              return { run: taskRun, error, isCached: false };\n+            if (result?.error) {\n+              throw new ServiceValidationError(\n+                taskRunErrorToString(taskRunErrorEnhancer(result.error))\n+              );\n             }\n-          );\n \n-          if (result?.error) {\n-            throw new ServiceValidationError(\n-              taskRunErrorToString(taskRunErrorEnhancer(result.error))\n-            );\n+            return result;\n           }\n-\n-          return result;\n-        });\n+        );\n       } catch (error) {\n         if (error instanceof RunDuplicateIdempotencyKeyError) {\n           //retry calling this function, because this time it will return the idempotent run\ndiff --git a/apps/webapp/app/runEngine/types.ts b/apps/webapp/app/runEngine/types.ts\nindex 2324edc6b8..0aa52d0a40 100644\n--- a/apps/webapp/app/runEngine/types.ts\n+++ b/apps/webapp/app/runEngine/types.ts\n@@ -143,10 +143,12 @@ export type TracedEventSpan = {\n export interface TraceEventConcern {\n   traceRun<T>(\n     request: TriggerTaskRequest,\n+    parentStore: string | undefined,\n     callback: (span: TracedEventSpan, store: string) => Promise<T>\n   ): Promise<T>;\n   traceIdempotentRun<T>(\n     request: TriggerTaskRequest,\n+    parentStore: string | undefined,\n     options: {\n       existingRun: TaskRun;\n       idempotencyKey: string;\ndiff --git a/apps/webapp/app/v3/eventRepository/index.server.ts b/apps/webapp/app/v3/eventRepository/index.server.ts\nindex cda9e58940..3bf77fcd76 100644\n--- a/apps/webapp/app/v3/eventRepository/index.server.ts\n+++ b/apps/webapp/app/v3/eventRepository/index.server.ts\n@@ -18,8 +18,17 @@ export function resolveEventRepositoryForStore(store: string | undefined): IEven\n }\n \n export async function getEventRepository(\n-  featureFlags: Record<string, unknown> | undefined\n+  featureFlags: Record<string, unknown> | undefined,\n+  parentStore: string | undefined\n ): Promise<{ repository: IEventRepository; store: string }> {\n+  if (typeof parentStore === \"string\") {\n+    if (parentStore === \"clickhouse\") {\n+      return { repository: clickhouseEventRepository, store: \"clickhouse\" };\n+    } else {\n+      return { repository: eventRepository, store: getTaskEventStore() };\n+    }\n+  }\n+\n   const taskEventRepository = await resolveTaskEventRepositoryFlag(featureFlags);\n \n   if (taskEventRepository === \"clickhouse\") {\ndiff --git a/apps/webapp/app/v3/services/triggerTask.server.ts b/apps/webapp/app/v3/services/triggerTask.server.ts\nindex 5f56a35af2..235dddd7d6 100644\n--- a/apps/webapp/app/v3/services/triggerTask.server.ts\n+++ b/apps/webapp/app/v3/services/triggerTask.server.ts\n@@ -1,5 +1,6 @@\n import { TriggerTaskRequestBody } from \"@trigger.dev/core/v3\";\n import { RunEngineVersion, TaskRun } from \"@trigger.dev/database\";\n+import { env } from \"~/env.server\";\n import { IdempotencyKeyConcern } from \"~/runEngine/concerns/idempotencyKeys.server\";\n import { DefaultPayloadProcessor } from \"~/runEngine/concerns/payloads.server\";\n import { DefaultQueueManager } from \"~/runEngine/concerns/queues.server\";\n@@ -9,12 +10,9 @@ import { RunEngineTriggerTaskService } from \"~/runEngine/services/triggerTask.se\n import { DefaultTriggerTaskValidator } from \"~/runEngine/validators/triggerTaskValidator\";\n import { AuthenticatedEnvironment } from \"~/services/apiAuth.server\";\n import { determineEngineVersion } from \"../engineVersion.server\";\n-import { eventRepository } from \"../eventRepository/eventRepository.server\";\n import { tracer } from \"../tracer.server\";\n import { WithRunEngine } from \"./baseService.server\";\n import { TriggerTaskServiceV1 } from \"./triggerTaskV1.server\";\n-import { env } from \"~/env.server\";\n-import { clickhouseEventRepository } from \"../eventRepository/clickhouseEventRepositoryInstance.server\";\n \n export type TriggerTaskServiceOptions = {\n   idempotencyKey?: string;\n@@ -94,10 +92,7 @@ export class TriggerTaskService extends WithRunEngine {\n     body: TriggerTaskRequestBody,\n     options: TriggerTaskServiceOptions = {}\n   ): Promise<TriggerTaskServiceResult | undefined> {\n-    const traceEventConcern = new DefaultTraceEventsConcern(\n-      eventRepository,\n-      clickhouseEventRepository\n-    );\n+    const traceEventConcern = new DefaultTraceEventsConcern();\n \n     const service = new RunEngineTriggerTaskService({\n       prisma: this._prisma,\ndiff --git a/apps/webapp/app/v3/services/triggerTaskV1.server.ts b/apps/webapp/app/v3/services/triggerTaskV1.server.ts\nindex c193f142d6..5e6ac7c9f1 100644\n--- a/apps/webapp/app/v3/services/triggerTaskV1.server.ts\n+++ b/apps/webapp/app/v3/services/triggerTaskV1.server.ts\n@@ -179,6 +179,7 @@ export class TriggerTaskServiceV1 extends BaseService {\n                   depth: true,\n                   queueTimestamp: true,\n                   queue: true,\n+                  taskEventStore: true,\n                 },\n               },\n             },\n@@ -216,6 +217,7 @@ export class TriggerTaskServiceV1 extends BaseService {\n                   taskIdentifier: true,\n                   rootTaskRunId: true,\n                   depth: true,\n+                  taskEventStore: true,\n                 },\n               },\n             },\n@@ -237,6 +239,7 @@ export class TriggerTaskServiceV1 extends BaseService {\n                       depth: true,\n                       queueTimestamp: true,\n                       queue: true,\n+                      taskEventStore: true,\n                     },\n                   },\n                 },\n@@ -289,7 +292,10 @@ export class TriggerTaskServiceV1 extends BaseService {\n         : undefined;\n \n       const { repository, store } = await getEventRepository(\n-        environment.organization.featureFlags as Record<string, unknown>\n+        environment.organization.featureFlags as Record<string, unknown>,\n+        dependentAttempt?.taskRun.taskEventStore ??\n+          parentAttempt?.taskRun.taskEventStore ??\n+          dependentBatchRun?.dependentTaskAttempt?.taskRun.taskEventStore\n       );\n \n       try {\ndiff --git a/apps/webapp/test/engine/triggerTask.test.ts b/apps/webapp/test/engine/triggerTask.test.ts\nindex 36dabd008c..aa0e059156 100644\n--- a/apps/webapp/test/engine/triggerTask.test.ts\n+++ b/apps/webapp/test/engine/triggerTask.test.ts\n@@ -79,6 +79,7 @@ class MockTriggerTaskValidator implements TriggerTaskValidator {\n class MockTraceEventConcern implements TraceEventConcern {\n   async traceRun<T>(\n     request: TriggerTaskRequest,\n+    parentStore: string | undefined,\n     callback: (span: TracedEventSpan, store: string) => Promise<T>\n   ): Promise<T> {\n     return await callback(\n@@ -96,6 +97,7 @@ class MockTraceEventConcern implements TraceEventConcern {\n \n   async traceIdempotentRun<T>(\n     request: TriggerTaskRequest,\n+    parentStore: string | undefined,\n     options: {\n       existingRun: TaskRun;\n       idempotencyKey: string;\n",
        "test_patch": "",
        "problem_statement": "",
        "hints_text": "",
        "pr_mirror": "triggerdotdev__trigger.dev.d1c3bfb9"
    }
}