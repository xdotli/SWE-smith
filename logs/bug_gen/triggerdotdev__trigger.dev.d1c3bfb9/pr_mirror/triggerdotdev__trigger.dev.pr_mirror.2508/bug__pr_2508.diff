diff --git a/apps/webapp/app/routes/resources.taskruns.$runParam.replay.ts b/apps/webapp/app/routes/resources.taskruns.$runParam.replay.ts
index 57de763..0f45d9f 100644
--- a/apps/webapp/app/routes/resources.taskruns.$runParam.replay.ts
+++ b/apps/webapp/app/routes/resources.taskruns.$runParam.replay.ts
@@ -108,8 +108,6 @@ export async function loader({ request, params }: LoaderFunctionArgs) {
   const disableVersionSelection = environment.type === "DEVELOPMENT";
   const allowArbitraryQueues = backgroundWorkers.at(0)?.engine === "V1";
 
-  const payload = await prettyPrintPacket(run.payload, run.payloadType);
-
   return typedjson({
     concurrencyKey: run.concurrencyKey,
     maxAttempts: run.maxAttempts,
@@ -118,7 +116,7 @@ export async function loader({ request, params }: LoaderFunctionArgs) {
     ttlSeconds: run.ttl ? parseDuration(run.ttl, "s") ?? undefined : undefined,
     idempotencyKey: run.idempotencyKey,
     runTags: run.runTags,
-    payload,
+    payload: await prettyPrintPacket(run.payload, run.payloadType),
     payloadType: run.payloadType,
     queue: run.queue,
     metadata: run.seedMetadata
@@ -312,4 +310,4 @@ function listLatestBackgroundWorkers(environment: { id: string }, limit = 20) {
     },
     take: limit,
   });
-}
+}
\ No newline at end of file
diff --git a/apps/webapp/test/fairDequeuingStrategy.test.ts b/apps/webapp/test/fairDequeuingStrategy.test.ts
index 0d8b708..9f21988 100644
--- a/apps/webapp/test/fairDequeuingStrategy.test.ts
+++ b/apps/webapp/test/fairDequeuingStrategy.test.ts
@@ -270,8 +270,8 @@ describe("FairDequeuingStrategy", () => {
 
       console.log("Second distribution took", distribute2Duration, "ms");
 
-      // Make sure the second call is faster than the first
-      expect(distribute2Duration).toBeLessThan(distribute1Duration);
+      // Make sure the second call is more than 2 times faster than the first
+      expect(distribute2Duration).toBeLessThan(withTolerance(distribute1Duration / 2));
 
       const startDistribute3 = performance.now();
 
@@ -284,8 +284,8 @@ describe("FairDequeuingStrategy", () => {
 
       console.log("Third distribution took", distribute3Duration, "ms");
 
-      // Make sure the third call is faster than the second
-      expect(withTolerance(distribute3Duration)).toBeGreaterThan(distribute2Duration);
+      // Make sure the third call is more than 4 times the second
+      expect(withTolerance(distribute3Duration)).toBeGreaterThan(distribute2Duration * 4);
     }
   );
 
@@ -422,1054 +422,4 @@ describe("FairDequeuingStrategy", () => {
       // Verify that each org and env gets a fair chance at first position
       for (const [orgId, stats] of Object.entries(orgStats)) {
         const firstPositionPercentage = (stats.firstPosition / iterations) * 100;
-        expect(firstPositionPercentage).toBeGreaterThan(expectedFirstPositionPercentage * 0.7); // Within 30% of expected
-        expect(firstPositionPercentage).toBeLessThan(expectedFirstPositionPercentage * 1.3);
-      }
-
-      for (const [envId, stats] of Object.entries(envStats)) {
-        const firstPositionPercentage = (stats.firstPosition / iterations) * 100;
-        expect(firstPositionPercentage).toBeGreaterThan(expectedEnvFirstPositionPercentage * 0.7); // Within 30% of expected
-        expect(firstPositionPercentage).toBeLessThan(expectedEnvFirstPositionPercentage * 1.3);
-      }
-
-      // Verify average positions are reasonably distributed
-      const avgPositionsOrgs = Object.values(orgStats).map(
-        (stats) => stats.positionSums / stats.appearances
-      );
-      const avgPositionsEnvs = Object.values(envStats).map(
-        (stats) => stats.positionSums / stats.appearances
-      );
-
-      const avgPositionStdDevOrgs = calculateStandardDeviation(avgPositionsOrgs);
-      const avgPositionStdDevEnvs = calculateStandardDeviation(avgPositionsEnvs);
-
-      expect(avgPositionStdDevOrgs).toBeLessThan(1); // Average positions should be fairly consistent
-      expect(avgPositionStdDevEnvs).toBeLessThan(1);
-    }
-  );
-
-  redisTest(
-    "should shuffle environments while maintaining age order within environments",
-    async ({ redisOptions }) => {
-      const redis = createRedisClient(redisOptions);
-
-      const keyProducer = createKeyProducer("test");
-      const strategy = new FairDequeuingStrategy({
-        tracer,
-        redis,
-        keys: keyProducer,
-        defaultEnvConcurrency: 5,
-        parentQueueLimit: 100,
-        seed: "fixed-seed",
-      });
-
-      const now = Date.now();
-
-      // Setup three environments, each with two queues of different ages
-      await Promise.all([
-        // env-1: one old queue (3000ms old) and one new queue (1000ms old)
-        setupQueue({
-          redis,
-          keyProducer,
-          parentQueue: "parent-queue",
-          score: now - 3000,
-          queueId: "queue-1-old",
-          orgId: "org-1",
-          envId: "env-1",
-        }),
-        setupQueue({
-          redis,
-          keyProducer,
-          parentQueue: "parent-queue",
-          score: now - 1000,
-          queueId: "queue-1-new",
-          orgId: "org-1",
-          envId: "env-1",
-        }),
-
-        // env-2: same pattern
-        setupQueue({
-          redis,
-          keyProducer,
-          parentQueue: "parent-queue",
-          score: now - 3000,
-          queueId: "queue-2-old",
-          orgId: "org-1",
-          envId: "env-2",
-        }),
-        setupQueue({
-          redis,
-          keyProducer,
-          parentQueue: "parent-queue",
-          score: now - 1000,
-          queueId: "queue-2-new",
-          orgId: "org-1",
-          envId: "env-2",
-        }),
-      ]);
-
-      // Setup basic concurrency settings
-      await setupConcurrency({
-        redis,
-        keyProducer,
-        env: { id: "env-1", currentConcurrency: 0, limit: 5 },
-      });
-      await setupConcurrency({
-        redis,
-        keyProducer,
-        env: { id: "env-2", currentConcurrency: 0, limit: 5 },
-      });
-
-      const envResult = await strategy.distributeFairQueuesFromParentQueue(
-        "parent-queue",
-        "consumer-1"
-      );
-      const result = flattenResults(envResult);
-
-      // Group queues by environment
-      const queuesByEnv = result.reduce((acc, queueId) => {
-        const envId = keyProducer.envIdFromQueue(queueId);
-        if (!acc[envId]) {
-          acc[envId] = [];
-        }
-        acc[envId].push(queueId);
-        return acc;
-      }, {} as Record<string, string[]>);
-
-      // Verify that:
-      // 1. We got all queues
-      expect(result).toHaveLength(4);
-
-      // 2. Queues are grouped by environment
-      for (const envQueues of Object.values(queuesByEnv)) {
-        expect(envQueues).toHaveLength(2);
-
-        // 3. Within each environment, older queue comes before newer queue
-        const [firstQueue, secondQueue] = envQueues;
-        expect(firstQueue).toContain("old");
-        expect(secondQueue).toContain("new");
-      }
-    }
-  );
-
-  redisTest(
-    "should bias shuffling based on concurrency limits and available capacity",
-    async ({ redisOptions }) => {
-      const redis = createRedisClient(redisOptions);
-
-      const keyProducer = createKeyProducer("test");
-      const now = Date.now();
-
-      // Setup three environments with different concurrency settings
-      const envSetups = [
-        {
-          envId: "env-1",
-          limit: 100,
-          current: 20, // Lots of available capacity
-          queueCount: 3,
-        },
-        {
-          envId: "env-2",
-          limit: 50,
-          current: 40, // Less available capacity
-          queueCount: 3,
-        },
-        {
-          envId: "env-3",
-          limit: 10,
-          current: 5, // Some available capacity
-          queueCount: 3,
-        },
-      ];
-
-      // Setup queues and concurrency for each environment
-      for (const setup of envSetups) {
-        await setupConcurrency({
-          redis,
-          keyProducer,
-          env: {
-            id: setup.envId,
-            currentConcurrency: setup.current,
-            limit: setup.limit,
-          },
-        });
-
-        for (let i = 0; i < setup.queueCount; i++) {
-          await setupQueue({
-            redis,
-            keyProducer,
-            parentQueue: "parent-queue",
-            score: now - 1000 * (i + 1),
-            queueId: `queue-${i}`,
-            orgId: "org-1",
-            envId: setup.envId,
-          });
-        }
-      }
-
-      // Create multiple strategies with different seeds
-      const numStrategies = 5;
-      const strategies = Array.from(
-        { length: numStrategies },
-        (_, i) =>
-          new FairDequeuingStrategy({
-            tracer,
-            redis,
-            keys: keyProducer,
-            defaultEnvConcurrency: 5,
-            parentQueueLimit: 100,
-            seed: `test-seed-${i}`,
-            biases: {
-              concurrencyLimitBias: 0.8,
-              availableCapacityBias: 0.5,
-              queueAgeRandomization: 0.0,
-            },
-          })
-      );
-
-      // Run iterations across all strategies
-      const iterationsPerStrategy = 100;
-      const allResults: Record<string, number>[] = [];
-
-      for (const strategy of strategies) {
-        const firstPositionCounts: Record<string, number> = {};
-
-        for (let i = 0; i < iterationsPerStrategy; i++) {
-          const envResult = await strategy.distributeFairQueuesFromParentQueue(
-            "parent-queue",
-            `consumer-${i % 3}`
-          );
-          const result = flattenResults(envResult);
-
-          expect(result.length).toBeGreaterThan(0);
-
-          const firstEnv = keyProducer.envIdFromQueue(result[0]);
-          firstPositionCounts[firstEnv] = (firstPositionCounts[firstEnv] || 0) + 1;
-        }
-
-        allResults.push(firstPositionCounts);
-      }
-
-      // Calculate average distributions across all strategies
-      const avgDistribution: Record<string, number> = {};
-      const envIds = ["env-1", "env-2", "env-3"];
-
-      for (const envId of envIds) {
-        const sum = allResults.reduce((acc, result) => acc + (result[envId] || 0), 0);
-        avgDistribution[envId] = sum / numStrategies;
-      }
-
-      // Log individual strategy results and the average
-      console.log("\nResults by strategy:");
-      allResults.forEach((result, i) => {
-        console.log(`Strategy ${i + 1}:`, result);
-      });
-
-      console.log("\nAverage distribution:", avgDistribution);
-
-      // Calculate percentages from average distribution
-      const totalCount = Object.values(avgDistribution).reduce((sum, count) => sum + count, 0);
-      const highLimitPercentage = (avgDistribution["env-1"] / totalCount) * 100;
-      const lowLimitPercentage = (avgDistribution["env-3"] / totalCount) * 100;
-
-      console.log("\nPercentages:");
-      console.log("High limit percentage:", highLimitPercentage);
-      console.log("Low limit percentage:", lowLimitPercentage);
-
-      // Verify distribution across all strategies
-      expect(highLimitPercentage).toBeLessThan(60);
-      expect(lowLimitPercentage).toBeGreaterThan(10);
-      expect(highLimitPercentage).toBeGreaterThan(lowLimitPercentage);
-    }
-  );
-
-  redisTest(
-    "should respect ageInfluence parameter for queue ordering",
-    async ({ redisOptions }) => {
-      const redis = createRedisClient(redisOptions);
-
-      const keyProducer = createKeyProducer("test");
-      const now = Date.now();
-
-      // Setup queues with different ages in the same environment
-      const queueAges = [
-        { id: "queue-1", age: 5000 }, // oldest
-        { id: "queue-2", age: 3000 },
-        { id: "queue-3", age: 1000 }, // newest
-      ];
-
-      // Helper function to run iterations with a specific age influence
-      async function runWithQueueAgeRandomization(queueAgeRandomization: number) {
-        const strategy = new FairDequeuingStrategy({
-          tracer,
-          redis,
-          keys: keyProducer,
-          defaultEnvConcurrency: 5,
-          parentQueueLimit: 100,
-          seed: "fixed-seed",
-          biases: {
-            concurrencyLimitBias: 0,
-            availableCapacityBias: 0,
-            queueAgeRandomization,
-          },
-        });
-
-        const positionCounts: Record<string, number[]> = {
-          "queue-1": [0, 0, 0],
-          "queue-2": [0, 0, 0],
-          "queue-3": [0, 0, 0],
-        };
-
-        const iterations = 1000;
-        for (let i = 0; i < iterations; i++) {
-          const envResult = await strategy.distributeFairQueuesFromParentQueue(
-            "parent-queue",
-            "consumer-1"
-          );
-          const result = flattenResults(envResult);
-
-          result.forEach((queueId, position) => {
-            const baseQueueId = queueId.split(":").pop()!;
-            positionCounts[baseQueueId][position]++;
-          });
-        }
-
-        return positionCounts;
-      }
-
-      // Setup test data
-      for (const { id, age } of queueAges) {
-        await setupQueue({
-          redis,
-          keyProducer,
-          parentQueue: "parent-queue",
-          score: now - age,
-          queueId: id,
-          orgId: "org-1",
-          envId: "env-1",
-        });
-      }
-
-      await setupConcurrency({
-        redis,
-        keyProducer,
-        env: { id: "env-1", currentConcurrency: 0, limit: 5 },
-      });
-
-      // Test with different age influence values
-      const strictAge = await runWithQueueAgeRandomization(0); // Strict age-based ordering
-      const mixed = await runWithQueueAgeRandomization(0.5); // Mix of age and random
-      const fullyRandom = await runWithQueueAgeRandomization(1); // Completely random
-
-      console.log("Distribution with strict age ordering (0.0):", strictAge);
-      console.log("Distribution with mixed ordering (0.5):", mixed);
-      console.log("Distribution with random ordering (1.0):", fullyRandom);
-
-      // With strict age ordering (0.0), oldest should always be first
-      expect(strictAge["queue-1"][0]).toBe(1000); // Always in first position
-      expect(strictAge["queue-3"][0]).toBe(0); // Never in first position
-
-      // With fully random (1.0), positions should still allow for some age bias
-      const randomFirstPositionSpread = Math.abs(
-        fullyRandom["queue-1"][0] - fullyRandom["queue-3"][0]
-      );
-      expect(randomFirstPositionSpread).toBeLessThan(200); // Allow for larger spread in distribution
-
-      // With mixed (0.5), should show preference for age but not absolute
-      expect(mixed["queue-1"][0]).toBeGreaterThan(mixed["queue-3"][0]); // Older preferred
-      expect(mixed["queue-3"][0]).toBeGreaterThan(0); // But newer still gets chances
-    }
-  );
-
-  redisTest(
-    "should respect maximumEnvCount and select envs based on queue ages",
-    async ({ redisOptions }) => {
-      const redis = createRedisClient(redisOptions);
-
-      const keyProducer = createKeyProducer("test");
-      const strategy = new FairDequeuingStrategy({
-        tracer,
-        redis,
-        keys: keyProducer,
-        defaultEnvConcurrency: 5,
-        parentQueueLimit: 100,
-        seed: "test-seed-max-orgs",
-        maximumEnvCount: 2, // Only select top 2 orgs
-      });
-
-      const now = Date.now();
-
-      // Setup 4 envs with different queue age profiles
-      const envSetups = [
-        {
-          envId: "env-1",
-          queues: [
-            { age: 1000 }, // Average age: 1000
-          ],
-        },
-        {
-          envId: "env-2",
-          queues: [
-            { age: 5000 }, // Average age: 5000
-            { age: 5000 },
-          ],
-        },
-        {
-          envId: "env-3",
-          queues: [
-            { age: 2000 }, // Average age: 2000
-            { age: 2000 },
-          ],
-        },
-        {
-          envId: "env-4",
-          queues: [
-            { age: 500 }, // Average age: 500
-            { age: 500 },
-          ],
-        },
-      ];
-
-      // Setup queues and concurrency for each org
-      for (const setup of envSetups) {
-        await setupConcurrency({
-          redis,
-          keyProducer,
-          env: { id: setup.envId, currentConcurrency: 0, limit: 5 },
-        });
-
-        for (let i = 0; i < setup.queues.length; i++) {
-          await setupQueue({
-            redis,
-            keyProducer,
-            parentQueue: "parent-queue",
-            score: now - setup.queues[i].age,
-            queueId: `queue-${setup.envId}-${i}`,
-            orgId: `org-${setup.envId}`,
-            envId: setup.envId,
-          });
-        }
-      }
-
-      // Run multiple iterations to verify consistent behavior
-      const iterations = 100;
-      const selectedEnvCounts: Record<string, number> = {};
-
-      for (let i = 0; i < iterations; i++) {
-        const envResult = await strategy.distributeFairQueuesFromParentQueue(
-          "parent-queue",
-          `consumer-${i}`
-        );
-        const result = flattenResults(envResult);
-
-        // Track which orgs were included in the result
-        const selectedEnvs = new Set(result.map((queueId) => keyProducer.envIdFromQueue(queueId)));
-
-        // Verify we never get more than maximumOrgCount orgs
-        expect(selectedEnvs.size).toBeLessThanOrEqual(2);
-
-        for (const envId of selectedEnvs) {
-          selectedEnvCounts[envId] = (selectedEnvCounts[envId] || 0) + 1;
-        }
-      }
-
-      console.log("Environment selection counts:", selectedEnvCounts);
-
-      // org-2 should be selected most often (highest average age)
-      expect(selectedEnvCounts["env-2"]).toBeGreaterThan(selectedEnvCounts["env-4"] || 0);
-
-      // org-4 should be selected least often (lowest average age)
-      const env4Count = selectedEnvCounts["env-4"] || 0;
-      expect(env4Count).toBeLessThan(selectedEnvCounts["env-2"]);
-
-      // Verify that envs with higher average queue age are selected more frequently
-      const sortedEnvs = Object.entries(selectedEnvCounts).sort((a, b) => b[1] - a[1]);
-      console.log("Sorted environment frequencies:", sortedEnvs);
-
-      // The top 2 most frequently selected orgs should be env-2 and env-3
-      // as they have the highest average queue ages
-      const topTwoEnvs = new Set([sortedEnvs[0][0], sortedEnvs[1][0]]);
-      expect(topTwoEnvs).toContain("env-2"); // Highest average age
-      expect(topTwoEnvs).toContain("env-3"); // Second highest average age
-
-      // Calculate selection percentages
-      const totalSelections = Object.values(selectedEnvCounts).reduce((a, b) => a + b, 0);
-      const selectionPercentages = Object.entries(selectedEnvCounts).reduce(
-        (acc, [orgId, count]) => {
-          acc[orgId] = (count / totalSelections) * 100;
-          return acc;
-        },
-        {} as Record<string, number>
-      );
-
-      console.log("Environment selection percentages:", selectionPercentages);
-
-      // Verify that env-2 (highest average age) gets selected in at least 40% of iterations
-      expect(selectionPercentages["env-2"]).toBeGreaterThan(40);
-
-      // Verify that env-4 (lowest average age) gets selected in less than 20% of iterations
-      expect(selectionPercentages["env-4"] || 0).toBeLessThan(20);
-    }
-  );
-
-  redisTest(
-    "should not overly bias picking environments when queue have priority offset ages",
-    async ({ redisOptions }) => {
-      const redis = createRedisClient(redisOptions);
-
-      const keyProducer = createKeyProducer("test");
-      const strategy = new FairDequeuingStrategy({
-        tracer,
-        redis,
-        keys: keyProducer,
-        defaultEnvConcurrency: 5,
-        parentQueueLimit: 100,
-        seed: "test-seed-max-orgs",
-        maximumEnvCount: 2, // Only select top 2 orgs
-      });
-
-      const now = Date.now();
-
-      // Setup 4 envs with different queue age profiles
-      const envSetups = [
-        {
-          envId: "env-1",
-          queues: [
-            { age: 1000 }, // Average age: 1000
-          ],
-        },
-        {
-          envId: "env-2",
-          queues: [
-            { age: 5000 + MARQS_RESUME_PRIORITY_TIMESTAMP_OFFSET }, // Average age: 5000 + 1 year
-            { age: 5000 + MARQS_RESUME_PRIORITY_TIMESTAMP_OFFSET },
-          ],
-        },
-        {
-          envId: "env-3",
-          queues: [
-            { age: 2000 }, // Average age: 2000
-            { age: 2000 },
-          ],
-        },
-        {
-          envId: "env-4",
-          queues: [
-            { age: 500 }, // Average age: 500
-            { age: 500 },
-          ],
-        },
-      ];
-
-      // Setup queues and concurrency for each org
-      for (const setup of envSetups) {
-        await setupConcurrency({
-          redis,
-          keyProducer,
-          env: { id: setup.envId, currentConcurrency: 0, limit: 5 },
-        });
-
-        for (let i = 0; i < setup.queues.length; i++) {
-          await setupQueue({
-            redis,
-            keyProducer,
-            parentQueue: "parent-queue",
-            score: now - setup.queues[i].age,
-            queueId: `queue-${setup.envId}-${i}`,
-            orgId: `org-${setup.envId}`,
-            envId: setup.envId,
-          });
-        }
-      }
-
-      // Run multiple iterations to verify consistent behavior
-      const iterations = 100;
-      const selectedEnvCounts: Record<string, number> = {};
-
-      for (let i = 0; i < iterations; i++) {
-        const envResult = await strategy.distributeFairQueuesFromParentQueue(
-          "parent-queue",
-          `consumer-${i}`
-        );
-        const result = flattenResults(envResult);
-
-        // Track which orgs were included in the result
-        const selectedEnvs = new Set(result.map((queueId) => keyProducer.envIdFromQueue(queueId)));
-
-        // Verify we never get more than maximumOrgCount orgs
-        expect(selectedEnvs.size).toBeLessThanOrEqual(2);
-
-        for (const envId of selectedEnvs) {
-          selectedEnvCounts[envId] = (selectedEnvCounts[envId] || 0) + 1;
-        }
-      }
-
-      console.log("Environment selection counts:", selectedEnvCounts);
-
-      // org-2 should be selected most often (highest average age)
-      expect(selectedEnvCounts["env-2"]).toBeGreaterThan(selectedEnvCounts["env-4"] || 0);
-
-      // org-4 should be selected least often (lowest average age)
-      const env4Count = selectedEnvCounts["env-4"] || 0;
-      expect(env4Count).toBeLessThan(selectedEnvCounts["env-2"]);
-
-      // Verify that envs with higher average queue age are selected more frequently
-      const sortedEnvs = Object.entries(selectedEnvCounts).sort((a, b) => b[1] - a[1]);
-      console.log("Sorted environment frequencies:", sortedEnvs);
-
-      // The top 2 most frequently selected orgs should be env-2 and env-3
-      // as they have the highest average queue ages
-      const topTwoEnvs = new Set([sortedEnvs[0][0], sortedEnvs[1][0]]);
-      expect(topTwoEnvs).toContain("env-2"); // Highest average age
-      expect(topTwoEnvs).toContain("env-3"); // Second highest average age
-
-      // Calculate selection percentages
-      const totalSelections = Object.values(selectedEnvCounts).reduce((a, b) => a + b, 0);
-      const selectionPercentages = Object.entries(selectedEnvCounts).reduce(
-        (acc, [orgId, count]) => {
-          acc[orgId] = (count / totalSelections) * 100;
-          return acc;
-        },
-        {} as Record<string, number>
-      );
-
-      console.log("Environment selection percentages:", selectionPercentages);
-
-      // Verify that env-2 (highest average age) gets selected in at least 40% of iterations
-      expect(selectionPercentages["env-2"]).toBeGreaterThan(40);
-
-      // Verify that env-4 (lowest average age) gets selected in less than 20% of iterations
-      expect(selectionPercentages["env-4"] || 0).toBeLessThan(20);
-    }
-  );
-
-  redisTest(
-    "should respect maximumQueuePerEnvCount when distributing queues",
-    async ({ redisOptions }) => {
-      const redis = createRedisClient(redisOptions);
-
-      const keyProducer = createKeyProducer("test");
-      const strategy = new FairDequeuingStrategy({
-        tracer,
-        redis,
-        keys: keyProducer,
-        defaultEnvConcurrency: 5,
-        parentQueueLimit: 100,
-        seed: "test-seed-max-queues",
-        maximumQueuePerEnvCount: 2, // Only take 2 queues per env
-      });
-
-      const now = Date.now();
-
-      // Setup two environments with different numbers of queues
-      const envSetups = [
-        {
-          envId: "env-1",
-          queues: [
-            { age: 5000 }, // Oldest
-            { age: 4000 },
-            { age: 3000 }, // This should be excluded due to maximumQueuePerEnvCount
-          ],
-        },
-        {
-          envId: "env-2",
-          queues: [
-            { age: 2000 },
-            { age: 1000 }, // Newest
-          ],
-        },
-      ];
-
-      // Setup queues and concurrency for each env
-      for (const setup of envSetups) {
-        await setupConcurrency({
-          redis,
-          keyProducer,
-          env: { id: setup.envId, currentConcurrency: 0, limit: 5 },
-        });
-
-        for (let i = 0; i < setup.queues.length; i++) {
-          await setupQueue({
-            redis,
-            keyProducer,
-            parentQueue: "parent-queue",
-            score: now - setup.queues[i].age,
-            queueId: `queue-${setup.envId}-${i}`,
-            orgId: `org-${setup.envId}`,
-            envId: setup.envId,
-          });
-        }
-      }
-
-      const result = await strategy.distributeFairQueuesFromParentQueue(
-        "parent-queue",
-        "consumer-1"
-      );
-
-      // Verify that each environment has at most 2 queues
-      for (const envQueues of result) {
-        expect(envQueues.queues.length).toBeLessThanOrEqual(2);
-      }
-
-      // Get queues for env-1 (which had 3 queues originally)
-      const env1Queues = result.find((eq) => eq.envId === "env-1")?.queues ?? [];
-
-      // Should have exactly 2 queues
-      expect(env1Queues.length).toBe(2);
-
-      // The queues should be the two oldest ones (queue-env-1-0 and queue-env-1-1)
-      expect(env1Queues).toContain(keyProducer.queueKey("org-env-1", "env-1", "queue-env-1-0"));
-      expect(env1Queues).toContain(keyProducer.queueKey("org-env-1", "env-1", "queue-env-1-1"));
-      expect(env1Queues).not.toContain(keyProducer.queueKey("org-env-1", "env-1", "queue-env-1-2"));
-
-      // Get queues for env-2 (which had 2 queues originally)
-      const env2Queues = result.find((eq) => eq.envId === "env-2")?.queues ?? [];
-
-      // Should still have both queues since it was within the limit
-      expect(env2Queues.length).toBe(2);
-    }
-  );
-
-  redisTest(
-    "should fairly distribute queues when using maximumQueuePerEnvCount over time",
-    async ({ redisOptions }) => {
-      const redis = createRedisClient(redisOptions);
-
-      const keyProducer = createKeyProducer("test");
-      const strategy = new FairDequeuingStrategy({
-        tracer,
-        redis,
-        keys: keyProducer,
-        defaultEnvConcurrency: 5,
-        parentQueueLimit: 100,
-        seed: "test-seed-fair-distribution",
-        maximumQueuePerEnvCount: 2, // Only take 2 queues at a time
-        biases: {
-          concurrencyLimitBias: 0,
-          availableCapacityBias: 0,
-          queueAgeRandomization: 0.3, // Add some randomization to allow newer queues a chance
-        },
-      });
-
-      const now = Date.now();
-
-      // Setup one environment with 5 queues of different ages
-      const queues = [
-        { age: 5000, id: "queue-0" }, // Oldest
-        { age: 4000, id: "queue-1" },
-        { age: 3000, id: "queue-2" },
-        { age: 2000, id: "queue-3" },
-        { age: 1000, id: "queue-4" }, // Newest
-      ];
-
-      // Setup the environment and its queues
-      await setupConcurrency({
-        redis,
-        keyProducer,
-        env: { id: "env-1", currentConcurrency: 0, limit: 5 },
-      });
-
-      for (const queue of queues) {
-        await setupQueue({
-          redis,
-          keyProducer,
-          parentQueue: "parent-queue",
-          score: now - queue.age,
-          queueId: queue.id,
-          orgId: "org-1",
-          envId: "env-1",
-        });
-      }
-
-      // Run multiple iterations and track which queues are selected
-      const iterations = 1000;
-      const queueSelectionCounts: Record<string, number> = {};
-      const queuePairings: Record<string, number> = {};
-
-      for (let i = 0; i < iterations; i++) {
-        const result = await strategy.distributeFairQueuesFromParentQueue(
-          "parent-queue",
-          `consumer-${i}`
-        );
-
-        // There should be exactly one environment
-        expect(result.length).toBe(1);
-        const selectedQueues = result[0].queues;
-
-        // Should always get exactly 2 queues due to maximumQueuePerEnvCount
-        expect(selectedQueues.length).toBe(2);
-
-        // Track individual queue selections
-        for (const queueId of selectedQueues) {
-          const baseQueueId = queueId.split(":").pop()!;
-          queueSelectionCounts[baseQueueId] = (queueSelectionCounts[baseQueueId] || 0) + 1;
-        }
-
-        // Track queue pairings to ensure variety
-        const [first, second] = selectedQueues.map((qId) => qId.split(":").pop()!).sort();
-        const pairingKey = `${first}-${second}`;
-        queuePairings[pairingKey] = (queuePairings[pairingKey] || 0) + 1;
-      }
-
-      console.log("\nQueue Selection Statistics:");
-      for (const [queueId, count] of Object.entries(queueSelectionCounts)) {
-        const percentage = (count / (iterations * 2)) * 100; // Times 2 because we select 2 queues each time
-        console.log(`${queueId}: ${percentage.toFixed(2)}% (${count} times)`);
-      }
-
-      console.log("\nQueue Pairing Statistics:");
-      for (const [pair, count] of Object.entries(queuePairings)) {
-        const percentage = (count / iterations) * 100;
-        console.log(`${pair}: ${percentage.toFixed(2)}% (${count} times)`);
-      }
-
-      // Verify that all queues were selected at least once
-      for (const queue of queues) {
-        expect(queueSelectionCounts[queue.id]).toBeGreaterThan(0);
-      }
-
-      // Calculate standard deviation of selection percentages
-      const selectionPercentages = Object.values(queueSelectionCounts).map(
-        (count) => (count / (iterations * 2)) * 100
-      );
-      const stdDev = calculateStandardDeviation(selectionPercentages);
-
-      // The standard deviation should be reasonable given our age bias
-      // Higher stdDev means more bias towards older queues
-      // We expect some bias due to queueAgeRandomization being 0.3
-      expect(stdDev).toBeLessThan(15); // Allow for age-based bias but not extreme
-
-      // Verify we get different pairings of queues
-      const uniquePairings = Object.keys(queuePairings).length;
-      // With 5 queues, we can have 10 possible unique pairs
-      expect(uniquePairings).toBeGreaterThan(5); // Should see at least half of possible combinations
-    }
-  );
-
-  redisTest(
-    "should handle maximumQueuePerEnvCount larger than available queues",
-    async ({ redisOptions }) => {
-      const redis = createRedisClient(redisOptions);
-
-      const keyProducer = createKeyProducer("test");
-      const strategy = new FairDequeuingStrategy({
-        tracer,
-        redis,
-        keys: keyProducer,
-        defaultEnvConcurrency: 5,
-        parentQueueLimit: 100,
-        seed: "test-seed-max-larger",
-        maximumQueuePerEnvCount: 5, // Larger than the number of queues we'll create
-      });
-
-      const now = Date.now();
-
-      // Setup two environments with different numbers of queues
-      const envSetups = [
-        {
-          envId: "env-1",
-          queues: [{ age: 5000 }, { age: 4000 }],
-        },
-        {
-          envId: "env-2",
-          queues: [{ age: 3000 }],
-        },
-      ];
-
-      // Setup queues and concurrency for each env
-      for (const setup of envSetups) {
-        await setupConcurrency({
-          redis,
-          keyProducer,
-          env: { id: setup.envId, currentConcurrency: 0, limit: 5 },
-        });
-
-        for (let i = 0; i < setup.queues.length; i++) {
-          await setupQueue({
-            redis,
-            keyProducer,
-            parentQueue: "parent-queue",
-            score: now - setup.queues[i].age,
-            queueId: `queue-${setup.envId}-${i}`,
-            orgId: `org-${setup.envId}`,
-            envId: setup.envId,
-          });
-        }
-      }
-
-      const result = await strategy.distributeFairQueuesFromParentQueue(
-        "parent-queue",
-        "consumer-1"
-      );
-
-      // Should get all queues from both environments
-      const env1Queues = result.find((eq) => eq.envId === "env-1")?.queues ?? [];
-      const env2Queues = result.find((eq) => eq.envId === "env-2")?.queues ?? [];
-
-      // env-1 should have both its queues
-      expect(env1Queues.length).toBe(2);
-      // env-2 should have its single queue
-      expect(env2Queues.length).toBe(1);
-    }
-  );
-
-  redisTest(
-    "should handle empty environments with maximumQueuePerEnvCount",
-    async ({ redisOptions }) => {
-      const redis = createRedisClient(redisOptions);
-
-      const keyProducer = createKeyProducer("test");
-      const strategy = new FairDequeuingStrategy({
-        tracer,
-        redis,
-        keys: keyProducer,
-        defaultEnvConcurrency: 5,
-        parentQueueLimit: 100,
-        seed: "test-seed-empty-env",
-        maximumQueuePerEnvCount: 2,
-      });
-
-      const now = Date.now();
-
-      // Setup two environments, one with queues, one without
-      await setupConcurrency({
-        redis,
-        keyProducer,
-        env: { id: "env-1", currentConcurrency: 0, limit: 5 },
-      });
-
-      await setupConcurrency({
-        redis,
-        keyProducer,
-        env: { id: "env-2", currentConcurrency: 0, limit: 5 },
-      });
-
-      // Only add queues to env-1
-      await setupQueue({
-        redis,
-        keyProducer,
-        parentQueue: "parent-queue",
-        score: now - 5000,
-        queueId: "queue-1",
-        orgId: "org-1",
-        envId: "env-1",
-      });
-
-      await setupQueue({
-        redis,
-        keyProducer,
-        parentQueue: "parent-queue",
-        score: now - 4000,
-        queueId: "queue-2",
-        orgId: "org-1",
-        envId: "env-1",
-      });
-
-      const result = await strategy.distributeFairQueuesFromParentQueue(
-        "parent-queue",
-        "consumer-1"
-      );
-
-      // Should only get one environment in the result
-      expect(result.length).toBe(1);
-      expect(result[0].envId).toBe("env-1");
-      expect(result[0].queues.length).toBe(2);
-    }
-  );
-
-  redisTest(
-    "should respect maximumQueuePerEnvCount with priority offset queues",
-    async ({ redisOptions }) => {
-      const redis = createRedisClient(redisOptions);
-
-      const keyProducer = createKeyProducer("test");
-      const strategy = new FairDequeuingStrategy({
-        tracer,
-        redis,
-        keys: keyProducer,
-        defaultEnvConcurrency: 5,
-        parentQueueLimit: 100,
-        seed: "test-seed-priority",
-        maximumQueuePerEnvCount: 2,
-        biases: {
-          concurrencyLimitBias: 0,
-          availableCapacityBias: 0,
-          queueAgeRandomization: 0.3,
-        },
-      });
-
-      const now = Date.now();
-
-      // Setup queues with a mix of normal and priority offset ages
-      const queues = [
-        { age: 5000, id: "queue-0" }, // Normal age
-        { age: 4000 + MARQS_RESUME_PRIORITY_TIMESTAMP_OFFSET, id: "queue-1" }, // Priority
-        { age: 3000, id: "queue-2" }, // Normal age
-        { age: 2000 + MARQS_RESUME_PRIORITY_TIMESTAMP_OFFSET, id: "queue-3" }, // Priority
-        { age: 1000, id: "queue-4" }, // Normal age
-      ];
-
-      await setupConcurrency({
-        redis,
-        keyProducer,
-        env: { id: "env-1", currentConcurrency: 0, limit: 5 },
-      });
-
-      for (const queue of queues) {
-        await setupQueue({
-          redis,
-          keyProducer,
-          parentQueue: "parent-queue",
-          score: now - queue.age,
-          queueId: queue.id,
-          orgId: "org-1",
-          envId: "env-1",
-        });
-      }
-
-      // Run multiple iterations to check distribution
-      const iterations = 1000;
-      const queueSelectionCounts: Record<string, number> = {};
-
-      for (let i = 0; i < iterations; i++) {
-        const result = await strategy.distributeFairQueuesFromParentQueue(
-          "parent-queue",
-          `consumer-${i}`
-        );
-
-        const selectedQueues = result[0].queues;
-        for (const queueId of selectedQueues) {
-          const baseQueueId = queueId.split(":").pop()!;
-          queueSelectionCounts[baseQueueId] = (queueSelectionCounts[baseQueueId] || 0) + 1;
-        }
-      }
-
-      console.log("\nPriority Queue Selection Statistics:");
-      for (const [queueId, count] of Object.entries(queueSelectionCounts)) {
-        const percentage = (count / (iterations * 2)) * 100;
-        const isPriority =
-          queues.find((q) => q.id === queueId)?.age! > MARQS_RESUME_PRIORITY_TIMESTAMP_OFFSET;
-        console.log(
-          `${queueId}${isPriority ? " (priority)" : ""}: ${percentage.toFixed(2)}% (${count} times)`
-        );
-      }
-
-      // Verify all queues get selected
-      for (const queue of queues) {
-        expect(queueSelectionCounts[queue.id]).toBeGreaterThan(0);
-      }
-
-      // Even with priority queues, we should still see a reasonable distribution
-      const selectionPercentages = Object.values(queueSelectionCounts).map(
-        (count) => (count / (iterations * 2)) * 100
-      );
-      const stdDev = calculateStandardDeviation(selectionPercentages);
-      expect(stdDev).toBeLessThan(20); // Allow for slightly more variance due to priority queues
-    }
-  );
-});
-
-// Helper function to flatten results for counting
-function flattenResults(results: Array<EnvQueues>): string[] {
-  return results.flatMap((envQueue) => envQueue.queues);
-}
+        expect(firstPositionPercentage).to
\ No newline at end of file
diff --git a/packages/core/src/v3/utils/ioSerialization.ts b/packages/core/src/v3/utils/ioSerialization.ts
index 9bacc41..433e7da 100644
--- a/packages/core/src/v3/utils/ioSerialization.ts
+++ b/packages/core/src/v3/utils/ioSerialization.ts
@@ -1,4 +1,3 @@
-import { JSONHeroPath } from "@jsonhero/path";
 import { Attributes, Span } from "@opentelemetry/api";
 import { z } from "zod";
 import { ApiClient } from "../apiClient/index.js";
@@ -13,6 +12,7 @@ import { SemanticInternalAttributes } from "../semanticInternalAttributes.js";
 import { TriggerTracer } from "../tracer.js";
 import { zodfetch } from "../zodfetch.js";
 import { flattenAttributes } from "./flattenAttributes.js";
+import { JSONHeroPath } from "@jsonhero/path";
 
 export type IOPacket = {
   data?: string | undefined;
@@ -389,40 +389,16 @@ export async function prettyPrintPacket(
     if (typeof rawData === "string") {
       rawData = safeJsonParse(rawData);
     }
-
     const { deserialize } = await loadSuperJSON();
 
-    const hasCircularReferences = rawData && rawData.meta && hasCircularReference(rawData.meta);
-
-    if (hasCircularReferences) {
-      return await prettyPrintPacket(deserialize(rawData), "application/json", {
-        ...options,
-        cloneReferences: false,
-      });
-    }
-
-    return await prettyPrintPacket(deserialize(rawData), "application/json", {
-      ...options,
-      cloneReferences: true,
-    });
+    return await prettyPrintPacket(deserialize(rawData), "application/json");
   }
 
   if (dataType === "application/json") {
     if (typeof rawData === "string") {
       rawData = safeJsonParse(rawData);
     }
-
-    try {
-      return JSON.stringify(rawData, makeSafeReplacer(options), 2);
-    } catch (error) {
-      // If cloneReferences is true, it's possible if our hasCircularReference logic is incorrect that stringifying the data will fail with a circular reference error
-      // So we will try to stringify the data with cloneReferences set to false
-      if (options?.cloneReferences) {
-        return JSON.stringify(rawData, makeSafeReplacer({ ...options, cloneReferences: false }), 2);
-      }
-
-      throw error;
-    }
+    return JSON.stringify(rawData, makeSafeReplacer(options), 2);
   }
 
   if (typeof rawData === "string") {
@@ -434,7 +410,6 @@ export async function prettyPrintPacket(
 
 interface ReplacerOptions {
   filteredKeys?: string[];
-  cloneReferences?: boolean;
 }
 
 function makeSafeReplacer(options?: ReplacerOptions) {
@@ -443,10 +418,6 @@ function makeSafeReplacer(options?: ReplacerOptions) {
   return function replacer(key: string, value: any) {
     if (typeof value === "object" && value !== null) {
       if (seen.has(value)) {
-        if (options?.cloneReferences) {
-          return structuredClone(value);
-        }
-
         return "[Circular]";
       }
       seen.add(value);
@@ -564,102 +535,4 @@ export async function replaceSuperJsonPayload(original: string, newPayload: stri
       .filter(([, value]) => Array.isArray(value) && value.at(0) === "undefined")
       .map(([key]) => key);
 
-    const overridenUndefinedKeys = originalUndefinedKeys.filter(
-      (key) => getKeyFromObject(newPayloadObject, key) !== undefined
-    );
-
-    overridenUndefinedKeys.forEach((key) => {
-      delete (meta.values as Record<string, any>)[key];
-    });
-  }
-
-  const newSuperJson = {
-    json: newPayloadObject,
-    meta,
-  };
-
-  return superjson.deserialize(newSuperJson);
-}
-
-function getKeyFromObject(object: unknown, key: string) {
-  const jsonHeroPath = new JSONHeroPath(key);
-
-  return jsonHeroPath.first(object);
-}
-
-/**
- * Detects if a superjson serialization contains circular references
- * by analyzing the meta.referentialEqualities structure.
- *
- * Based on superjson's ReferentialEqualityAnnotations type:
- * Record<string, string[]> | [string[]] | [string[], Record<string, string[]>]
- *
- * Circular references are represented as:
- * - [string[]] where strings are paths that reference back to root or ancestors
- * - The first element in [string[], Record<string, string[]>] format
- */
-function hasCircularReference(meta: any): boolean {
-  if (!meta?.referentialEqualities) {
-    return false;
-  }
-
-  const re = meta.referentialEqualities;
-
-  // Case 1: [string[]] - array containing only circular references
-  if (Array.isArray(re) && re.length === 1 && Array.isArray(re[0])) {
-    return re[0].length > 0; // Has circular references
-  }
-
-  // Case 2: [string[], Record<string, string[]>] - mixed format
-  if (Array.isArray(re) && re.length === 2 && Array.isArray(re[0])) {
-    return re[0].length > 0; // First element contains circular references
-  }
-
-  // Case 3: Record<string, string[]> - check for circular patterns in shared references
-  if (!Array.isArray(re) && typeof re === "object") {
-    // Check if any reference path points to an ancestor path
-    for (const [targetPath, referencePaths] of Object.entries(re)) {
-      for (const refPath of referencePaths as string[]) {
-        if (isCircularPattern(targetPath, refPath)) {
-          return true;
-        }
-      }
-    }
-    return false;
-  }
-
-  return false;
-}
-
-/**
- * Checks if a reference pattern represents a circular reference
- * by analyzing if the reference path points back to an ancestor of the target path
- */
-function isCircularPattern(targetPath: string, referencePath: string): boolean {
-  const targetParts = targetPath.split(".");
-  const refParts = referencePath.split(".");
-
-  // For circular references, the reference path often contains the target path as a prefix
-  // Example: targetPath="user", referencePath="user.details.user"
-  // This means user.details.user points back to user (circular)
-
-  // Check if reference path starts with target path + additional segments that loop back
-  if (refParts.length > targetParts.length) {
-    // Check if reference path starts with target path
-    let isPrefix = true;
-    for (let i = 0; i < targetParts.length; i++) {
-      if (targetParts[i] !== refParts[i]) {
-        isPrefix = false;
-        break;
-      }
-    }
-
-    // If reference path starts with target path and ends with target path,
-    // it's likely a circular reference (e.g., "user" -> "user.details.user")
-    if (isPrefix && refParts[refParts.length - 1] === targetParts[targetParts.length - 1]) {
-      return true;
-    }
-  }
-
-  return false;
-}
+    const over
\ No newline at end of file
diff --git a/packages/core/test/ioSerialization.test.ts b/packages/core/test/ioSerialization.test.ts
index d7bd90a..81524b3 100644
--- a/packages/core/test/ioSerialization.test.ts
+++ b/packages/core/test/ioSerialization.test.ts
@@ -1,4 +1,4 @@
-import { replaceSuperJsonPayload, prettyPrintPacket } from "../src/v3/utils/ioSerialization.js";
+import { replaceSuperJsonPayload } from "../src/v3/utils/ioSerialization.js";
 
 describe("ioSerialization", () => {
   describe("replaceSuperJsonPayload", () => {
@@ -188,160 +188,4 @@ describe("ioSerialization", () => {
       await expect(replaceSuperJsonPayload(originalSerialized, invalidPayload)).rejects.toThrow();
     });
   });
-
-  describe("prettyPrintPacket", () => {
-    it("should return empty string for undefined data", async () => {
-      const result = await prettyPrintPacket(undefined);
-      expect(result).toBe("");
-    });
-
-    it("should return string data as-is", async () => {
-      const result = await prettyPrintPacket("Hello, World!");
-      expect(result).toBe("Hello, World!");
-    });
-
-    it("should pretty print JSON data with default options", async () => {
-      const data = { name: "John", age: 30, nested: { value: true } };
-      const result = await prettyPrintPacket(data, "application/json");
-
-      expect(result).toBe(JSON.stringify(data, null, 2));
-    });
-
-    it("should handle JSON data as string", async () => {
-      const data = { name: "John", age: 30 };
-      const jsonString = JSON.stringify(data);
-      const result = await prettyPrintPacket(jsonString, "application/json");
-
-      expect(result).toBe(JSON.stringify(data, null, 2));
-    });
-
-    it("should pretty print SuperJSON data", async () => {
-      const data = {
-        name: "John",
-        date: new Date("2023-01-01"),
-        bigInt: BigInt(123),
-        set: new Set(["a", "b"]),
-        map: new Map([["key", "value"]]),
-      };
-
-      const superjson = await import("superjson");
-      const serialized = superjson.stringify(data);
-
-      const result = await prettyPrintPacket(serialized, "application/super+json");
-
-      // Should deserialize and pretty print the data
-      expect(result).toContain('"name": "John"');
-      expect(result).toContain('"date": "2023-01-01T00:00:00.000Z"');
-      expect(result).toContain('"bigInt": "123"');
-      expect(result).toContain('"set": [\n    "a",\n    "b"\n  ]');
-      expect(result).toContain('"map": {\n    "key": "value"\n  }');
-    });
-
-    it("should handle circular references", async () => {
-      const data: any = { name: "John" };
-      data.self = data; // Create circular reference
-
-      // Create a SuperJSON serialized version to test the circular reference detection
-      const superjson = await import("superjson");
-      const serialized = superjson.stringify(data);
-
-      const result = await prettyPrintPacket(serialized, "application/super+json");
-
-      expect(result).toContain('"name": "John"');
-      expect(result).toContain('"self": "[Circular]"');
-    });
-
-    it("should handle regular non-circular references", async () => {
-      const person = { name: "John" };
-
-      const data: any = { person1: person, person2: person };
-
-      // Create a SuperJSON serialized version to test the circular reference detection
-      const superjson = await import("superjson");
-      const serialized = superjson.stringify(data);
-
-      const result = await prettyPrintPacket(serialized, "application/super+json");
-
-      expect(result).toContain('"person1": {');
-      expect(result).toContain('"person2": {');
-    });
-
-    it("should filter out specified keys", async () => {
-      const data = { name: "John", password: "secret", age: 30 };
-      const result = await prettyPrintPacket(data, "application/json", {
-        filteredKeys: ["password"],
-      });
-
-      expect(result).toContain('"name": "John"');
-      expect(result).toContain('"age": 30');
-      expect(result).not.toContain('"password"');
-    });
-
-    it("should handle BigInt values", async () => {
-      const data = { id: BigInt(123456789), name: "John" };
-      const result = await prettyPrintPacket(data, "application/json");
-
-      expect(result).toContain('"id": "123456789"');
-      expect(result).toContain('"name": "John"');
-    });
-
-    it("should handle RegExp values", async () => {
-      const data = { pattern: /test/gi, name: "John" };
-      const result = await prettyPrintPacket(data, "application/json");
-
-      expect(result).toContain('"pattern": "/test/gi"');
-      expect(result).toContain('"name": "John"');
-    });
-
-    it("should handle Set values", async () => {
-      const data = { tags: new Set(["tag1", "tag2"]), name: "John" };
-      const result = await prettyPrintPacket(data, "application/json");
-
-      expect(result).toContain('"tags": [\n    "tag1",\n    "tag2"\n  ]');
-      expect(result).toContain('"name": "John"');
-    });
-
-    it("should handle Map values", async () => {
-      const data = { mapping: new Map([["key1", "value1"]]), name: "John" };
-      const result = await prettyPrintPacket(data, "application/json");
-
-      expect(result).toContain('"mapping": {\n    "key1": "value1"\n  }');
-      expect(result).toContain('"name": "John"');
-    });
-
-    it("should handle complex nested data", async () => {
-      const data = {
-        user: {
-          id: BigInt(123),
-          createdAt: new Date("2023-01-01"),
-          settings: {
-            theme: "dark",
-            tags: new Set(["admin", "user"]),
-            config: new Map([["timeout", "30s"]]),
-          },
-        },
-        metadata: {
-          version: 1,
-          pattern: /^test$/,
-        },
-      };
-
-      const result = await prettyPrintPacket(data, "application/json");
-
-      expect(result).toContain('"id": "123"');
-      expect(result).toContain('"createdAt": "2023-01-01T00:00:00.000Z"');
-      expect(result).toContain('"theme": "dark"');
-      expect(result).toContain('"tags": [\n        "admin",\n        "user"\n      ]');
-      expect(result).toContain('"config": {\n        "timeout": "30s"\n      }');
-      expect(result).toContain('"version": 1');
-      expect(result).toContain('"pattern": "/^test$/"');
-    });
-
-    it("should handle data without dataType parameter", async () => {
-      const data = { name: "John", age: 30 };
-      const result = await prettyPrintPacket(data);
-
-      expect(result).toBe(JSON.stringify(data, null, 2));
-    });
-  });
-});
+});
\ No newline at end of file
diff --git a/references/hello-world/src/trigger/circularPayload.ts b/references/hello-world/src/trigger/circularPayload.ts
deleted file mode 100644
index 3e9d0a9..0000000
--- a/references/hello-world/src/trigger/circularPayload.ts
+++ /dev/null
@@ -1,149 +0,0 @@
-import { logger, schemaTask, task, tasks } from "@trigger.dev/sdk";
-import { z } from "zod/v3";
-
-export const referentialPayloadParentTask = task({
-  id: "referential-payload-parent",
-  run: async (payload: any) => {
-    // Shared objects
-    const workflowData = {
-      id: "workflow-123",
-      formName: "Contact Form",
-    };
-
-    const response = [
-      {
-        id: "q1_name",
-        answer: "John Doe",
-      },
-      {
-        id: "q2_consent",
-        answer: "yes",
-        leadAttribute: undefined, // Will be marked in meta
-      },
-    ];
-
-    const personAttributes = {
-      ip: "192.168.1.1",
-      visitedForm: 1,
-    };
-
-    // Main object with shared references
-    const originalObject = {
-      workflowData: workflowData, // Root reference
-      workflowContext: {
-        leadId: undefined, // Will be marked in meta
-        workflowJob: {
-          workflowData: workflowData, // Same reference as root
-          createdAt: new Date("2025-08-19T12:13:42.260Z"), // Date object
-        },
-        responseData: {
-          personAttributes: personAttributes, // Same reference as root
-        },
-        response: response, // Same reference as root
-      },
-      personAttributes: personAttributes, // Root reference
-      response: response, // Root reference
-      jobArgs: {
-        response: response, // Same reference as root
-        args: workflowData, // Same reference as root
-      },
-    };
-
-    await tasks.triggerAndWait<typeof referentialPayloadChildTask>(
-      "referential-payload-child",
-      originalObject
-    );
-
-    return {
-      message: "Hello, world!",
-    };
-  },
-});
-
-// Define the circular schema using z.lazy() for the recursive reference
-const WorkflowDataSchema = z.object({
-  id: z.string(),
-  formName: z.string(),
-});
-
-const ResponseItemSchema = z.object({
-  id: z.string(),
-  answer: z.string(),
-  leadAttribute: z.undefined().optional(),
-});
-
-const PersonAttributesSchema = z.object({
-  ip: z.string(),
-  visitedForm: z.number(),
-});
-
-const OriginalObjectSchema = z.object({
-  workflowData: WorkflowDataSchema,
-  workflowContext: z.object({
-    leadId: z.undefined(),
-    workflowJob: z.object({
-      workflowData: WorkflowDataSchema, // Same reference
-      createdAt: z.date(),
-    }),
-    responseData: z.object({
-      personAttributes: PersonAttributesSchema, // Same reference
-    }),
-    response: z.array(ResponseItemSchema), // Same reference
-  }),
-  personAttributes: PersonAttributesSchema, // Root reference
-  response: z.array(ResponseItemSchema), // Root reference
-  jobArgs: z.object({
-    response: z.array(ResponseItemSchema), // Same reference
-    args: WorkflowDataSchema, // Same reference
-  }),
-});
-
-export const referentialPayloadChildTask = schemaTask({
-  id: "referential-payload-child",
-  schema: OriginalObjectSchema,
-  run: async (payload) => {
-    logger.info("Received circular payload", { payload });
-
-    return {
-      message: "Hello, world!",
-    };
-  },
-});
-
-export const circularReferenceParentTask = task({
-  id: "circular-reference-parent",
-  run: async (payload: any) => {
-    const user = {
-      name: "Alice",
-      details: {
-        age: 30,
-        email: "alice@example.com",
-      },
-    };
-    // @ts-expect-error - This is a circular reference
-    user.details.user = user;
-
-    await tasks.triggerAndWait<typeof circularReferenceChildTask>("circular-reference-child", {
-      // @ts-expect-error - This is a circular reference
-      user,
-    });
-  },
-});
-
-type CircularReferencePayload = {
-  user: {
-    name: string;
-    details: {
-      age: number;
-      email: string;
-      user: CircularReferencePayload;
-    };
-  };
-};
-
-export const circularReferenceChildTask = task({
-  id: "circular-reference-child",
-  run: async (payload: CircularReferencePayload) => {
-    logger.info("Received circular payload", { payload });
-  },
-});
