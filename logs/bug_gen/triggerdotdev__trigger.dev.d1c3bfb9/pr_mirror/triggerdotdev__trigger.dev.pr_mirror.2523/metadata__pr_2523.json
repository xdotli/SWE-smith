{
    "cost": 0.76368,
    "rewrites": {
        "triggerdotdev__trigger.dev.d1c3bfb9/apps/supervisor/src/workloadServer/index.ts": {
            "output": "import { type Namespace, Server, type Socket } from \"socket.io\";\nimport { SimpleStructuredLogger } from \"@trigger.dev/core/v3/utils/structuredLogger\";\nimport EventEmitter from \"node:events\";\nimport { z } from \"zod\";\nimport {\n  type SupervisorHttpClient,\n  WORKLOAD_HEADERS,\n  type WorkloadClientSocketData,\n  type WorkloadClientToServerEvents,\n  type WorkloadContinueRunExecutionResponseBody,\n  WorkloadDebugLogRequestBody,\n  type WorkloadDequeueFromVersionResponseBody,\n  WorkloadHeartbeatRequestBody,\n  type WorkloadHeartbeatResponseBody,\n  WorkloadRunAttemptCompleteRequestBody,\n  type WorkloadRunAttemptCompleteResponseBody,\n  WorkloadRunAttemptStartRequestBody,\n  type WorkloadRunAttemptStartResponseBody,\n  WorkloadRunSnapshotsSinceResponseBody,\n  type WorkloadServerToClientEvents,\n  type WorkloadSuspendRunResponseBody,\n} from \"@trigger.dev/core/v3/workers\";\nimport { HttpServer, type CheckpointClient } from \"@trigger.dev/core/v3/serverOnly\";\nimport { type IncomingMessage } from \"node:http\";\nimport { register } from \"../metrics.js\";\nimport { env } from \"../env.js\";\n\n// Use the official export when upgrading to socket.io@4.8.0\ninterface DefaultEventsMap {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [event: string]: (...args: any[]) => void;\n}\n\nconst WorkloadActionParams = z.object({\n  runFriendlyId: z.string(),\n  snapshotFriendlyId: z.string(),\n});\n\ntype WorkloadServerEvents = {\n  runConnected: [\n    {\n      run: {\n        friendlyId: string;\n      };\n    },\n  ];\n  runDisconnected: [\n    {\n      run: {\n        friendlyId: string;\n      };\n    },\n  ];\n};\n\ntype WorkloadServerOptions = {\n  port: number;\n  host?: string;\n  workerClient: SupervisorHttpClient;\n  checkpointClient?: CheckpointClient;\n};\n\nexport class WorkloadServer extends EventEmitter<WorkloadServerEvents> {\n  private checkpointClient?: CheckpointClient;\n\n  private readonly logger = new SimpleStructuredLogger(\"workload-server\");\n\n  private readonly httpServer: HttpServer;\n  private readonly websocketServer: Namespace<\n    WorkloadClientToServerEvents,\n    WorkloadServerToClientEvents,\n    DefaultEventsMap,\n    WorkloadClientSocketData\n  >;\n\n  private readonly runSockets = new Map<\n    string,\n    Socket<\n      WorkloadClientToServerEvents,\n      WorkloadServerToClientEvents,\n      DefaultEventsMap,\n      WorkloadClientSocketData\n    >\n  >();\n\n  private readonly workerClient: SupervisorHttpClient;\n\n  constructor(opts: WorkloadServerOptions) {\n    super();\n\n    const host = opts.host ?? \"0.0.0.0\";\n    const port = opts.port;\n\n    this.workerClient = opts.workerClient;\n    this.checkpointClient = opts.checkpointClient;\n\n    this.httpServer = this.createHttpServer({ host, port });\n    this.websocketServer = this.createWebsocketServer();\n  }\n\n  private headerValueFromRequest(req: IncomingMessage, headerName: string): string | undefined {\n    const value = req.headers[headerName];\n\n    if (Array.isArray(value)) {\n      return value[0];\n    }\n\n    return value;\n  }\n\n  private runnerIdFromRequest(req: IncomingMessage): string | undefined {\n    return this.headerValueFromRequest(req, WORKLOAD_HEADERS.RUNNER_ID);\n  }\n\n  private deploymentIdFromRequest(req: IncomingMessage): string | undefined {\n    return this.headerValueFromRequest(req, WORKLOAD_HEADERS.DEPLOYMENT_ID);\n  }\n\n  private deploymentVersionFromRequest(req: IncomingMessage): string | undefined {\n    return this.headerValueFromRequest(req, WORKLOAD_HEADERS.DEPLOYMENT_VERSION);\n  }\n\n  private projectRefFromRequest(req: IncomingMessage): string | undefined {\n    return this.headerValueFromRequest(req, WORKLOAD_HEADERS.PROJECT_REF);\n  }\n\n  private createHttpServer({ host, port }: { host: string; port: number }) {\n    return new HttpServer({\n      port,\n      host,\n      metrics: {\n        register,\n        expose: false,\n      },\n    })\n      .route(\"/health\", \"GET\", {\n        handler: async ({ reply }) => {\n          reply.text(\"OK\");\n        },\n      })\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/:snapshotFriendlyId/attempts/start\",\n        \"POST\",\n        {\n          paramsSchema: WorkloadActionParams,\n          bodySchema: WorkloadRunAttemptStartRequestBody,\n          handler: async ({ req, reply, params, body }) => {\n            const startResponse = await this.workerClient.startRunAttempt(\n              params.runFriendlyId,\n              params.snapshotFriendlyId,\n              body,\n              this.runnerIdFromRequest(req)\n            );\n\n            if (!startResponse.success) {\n              this.logger.error(\"Failed to start run\", {\n                params,\n                error: startResponse.error,\n              });\n              reply.empty(500);\n              return;\n            }\n\n            reply.json(startResponse.data satisfies WorkloadRunAttemptStartResponseBody);\n            return;\n          },\n        }\n      )\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/:snapshotFriendlyId/attempts/complete\",\n        \"POST\",\n        {\n          paramsSchema: WorkloadActionParams,\n          bodySchema: WorkloadRunAttemptCompleteRequestBody,\n          handler: async ({ req, reply, params, body }) => {\n            const completeResponse = await this.workerClient.completeRunAttempt(\n              params.runFriendlyId,\n              params.snapshotFriendlyId,\n              body,\n              this.runnerIdFromRequest(req)\n            );\n\n            if (!completeResponse.success) {\n              this.logger.error(\"Failed to complete run\", {\n                params,\n                error: completeResponse.error,\n              });\n              reply.empty(500);\n              return;\n            }\n\n            reply.json(completeResponse.data satisfies WorkloadRunAttemptCompleteResponseBody);\n            return;\n          },\n        }\n      )\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/:snapshotFriendlyId/heartbeat\",\n        \"POST\",\n        {\n          paramsSchema: WorkloadActionParams,\n          bodySchema: WorkloadHeartbeatRequestBody,\n          handler: async ({ req, reply, params, body }) => {\n            const heartbeatResponse = await this.workerClient.heartbeatRun(\n              params.runFriendlyId,\n              params.snapshotFriendlyId,\n              body,\n              this.runnerIdFromRequest(req)\n            );\n\n            if (!heartbeatResponse.success) {\n              this.logger.error(\"Failed to heartbeat run\", {\n                params,\n                error: heartbeatResponse.error,\n              });\n              reply.empty(500);\n              return;\n            }\n\n            reply.json({\n              ok: true,\n            } satisfies WorkloadHeartbeatResponseBody);\n          },\n        }\n      )\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/:snapshotFriendlyId/suspend\",\n        \"GET\",\n        {\n          paramsSchema: WorkloadActionParams,\n          handler: async ({ reply, params, req }) => {\n            this.logger.debug(\"Suspend request\", { params, headers: req.headers });\n\n            if (!this.checkpointClient) {\n              reply.json(\n                {\n                  ok: false,\n                  error: \"Checkpoints disabled\",\n                } satisfies WorkloadSuspendRunResponseBody,\n                false,\n                400\n              );\n              return;\n            }\n\n            const runnerId = this.runnerIdFromRequest(req);\n            const deploymentVersion = this.deploymentVersionFromRequest(req);\n            const projectRef = this.projectRefFromRequest(req);\n\n            if (!runnerId || !deploymentVersion || !projectRef) {\n              this.logger.error(\"Invalid headers for suspend request\", {\n                ...params,\n                headers: req.headers,\n              });\n              reply.json(\n                {\n                  ok: false,\n                  error: \"Invalid headers\",\n                } satisfies WorkloadSuspendRunResponseBody,\n                false,\n                400\n              );\n              return;\n            }\n\n            reply.json(\n              {\n                ok: true,\n              } satisfies WorkloadSuspendRunResponseBody,\n              false,\n              202\n            );\n\n            const suspendResult = await this.checkpointClient.suspendRun({\n              runFriendlyId: params.runFriendlyId,\n              snapshotFriendlyId: params.snapshotFriendlyId,\n              body: {\n                runnerId,\n                runId: params.runFriendlyId,\n                snapshotId: params.snapshotFriendlyId,\n                projectRef,\n                deploymentVersion,\n              },\n            });\n\n            if (!suspendResult) {\n              this.logger.error(\"Failed to suspend run\", { params });\n              return;\n            }\n          },\n        }\n      )\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/:snapshotFriendlyId/continue\",\n        \"GET\",\n        {\n          paramsSchema: WorkloadActionParams,\n          handler: async ({ req, reply, params }) => {\n            this.logger.debug(\"Run continuation request\", { params });\n\n            const continuationResult = await this.workerClient.continueRunExecution(\n              params.runFriendlyId,\n              params.snapshotFriendlyId,\n              this.runnerIdFromRequest(req)\n            );\n\n            if (!continuationResult.success) {\n              this.logger.error(\"Failed to continue run execution\", { params });\n              reply.json(\n                {\n                  ok: false,\n                  error: \"Failed to continue run execution\",\n                },\n                false,\n                400\n              );\n              return;\n            }\n\n            reply.json(continuationResult.data as WorkloadContinueRunExecutionResponseBody);\n          },\n        }\n      )\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/since/:snapshotFriendlyId\",\n        \"GET\",\n        {\n          paramsSchema: WorkloadActionParams,\n          handler: async ({ req, reply, params }) => {\n            const sinceSnapshotResponse = await this.workerClient.getSnapshotsSince(\n              params.runFriendlyId,\n              params.snapshotFriendlyId,\n              this.runnerIdFromRequest(req)\n            );\n\n            if (!sinceSnapshotResponse.success) {\n              this.logger.error(\"Failed to get snapshots since\", {\n                runId: params.runFriendlyId,\n                error: sinceSnapshotResponse.error,\n              });\n              reply.empty(500);\n              return;\n            }\n\n            reply.json(sinceSnapshotResponse.data satisfies WorkloadRunSnapshotsSinceResponseBody);\n          },\n        }\n      )\n      .route(\"/api/v1/workload-actions/runs/:runFriendlyId/logs/debug\", \"POST\", {\n        paramsSchema: WorkloadActionParams.pick({ runFriendlyId: true }),\n        bodySchema: WorkloadDebugLogRequestBody,\n        handler: async ({ req, reply, params, body }) => {\n          reply.empty(204);\n\n          if (!env.SEND_RUN_DEBUG_LOGS) {\n            return;\n          }\n\n          await this.workerClient.sendDebugLog(\n            params.runFriendlyId,\n            body,\n            this.runnerIdFromRequest(req)\n          );\n        },\n      })\n      .route(\"/api/v1/workload-actions/deployments/:deploymentId/dequeue\", \"GET\", {\n        paramsSchema: z.object({\n          deploymentId: z.string(),\n        }),\n\n        handler: async ({ req, reply, params }) => {\n          const dequeueResponse = await this.workerClient.dequeueFromVersion(\n            params.deploymentId,\n            1,\n            this.runnerIdFromRequest(req)\n          );\n\n          if (!dequeueResponse.success) {\n            this.logger.error(\"Failed to get latest snapshot\", {\n              deploymentId: params.deploymentId,\n              error: dequeueResponse.error,\n            });\n            reply.empty(500);\n            return;\n          }\n\n          reply.json(dequeueResponse.data satisfies WorkloadDequeueFromVersionResponseBody);\n        },\n      });\n  }\n\n  private createWebsocketServer() {\n    const io = new Server(this.httpServer.server);\n\n    const websocketServer: Namespace<\n      WorkloadClientToServerEvents,\n      WorkloadServerToClientEvents,\n      DefaultEventsMap,\n      WorkloadClientSocketData\n    > = io.of(\"/workload\");\n\n    websocketServer.on(\"disconnect\", (socket) => {\n      this.logger.log(\"[WS] disconnect\", socket.id);\n    });\n    websocketServer.use(async (socket, next) => {\n      const setSocketDataFromHeader = (\n        dataKey: keyof typeof socket.data,\n        headerName: string,\n        required: boolean = true\n      ) => {\n        const value = socket.handshake.headers[headerName];\n\n        if (value) {\n          if (Array.isArray(value)) {\n            if (value[0]) {\n              socket.data[dataKey] = value[0];\n              return;\n            }\n          } else {\n            socket.data[dataKey] = value;\n            return;\n          }\n        }\n\n        if (required) {\n          this.logger.error(\"[WS] missing required header\", { headerName });\n          throw new Error(\"missing header\");\n        }\n      };\n\n      try {\n        setSocketDataFromHeader(\"deploymentId\", WORKLOAD_HEADERS.DEPLOYMENT_ID);\n        setSocketDataFromHeader(\"runnerId\", WORKLOAD_HEADERS.RUNNER_ID);\n      } catch (error) {\n        this.logger.error(\"[WS] setSocketDataFromHeader error\", { error });\n        socket.disconnect(true);\n        return;\n      }\n\n      this.logger.debug(\"[WS] auth success\", socket.data);\n\n      next();\n    });\n    websocketServer.on(\"connection\", (socket) => {\n      const socketLogger = this.logger.child({\n        socketId: socket.id,\n        socketData: socket.data,\n      });\n\n      const getSocketMetadata = () => {\n        return {\n          deploymentId: socket.data.deploymentId,\n          runId: socket.data.runFriendlyId,\n          snapshotId: socket.data.snapshotId,\n          runnerId: socket.data.runnerId,\n        };\n      };\n\n      const runConnected = (friendlyId: string) => {\n        socketLogger.debug(\"runConnected\", { ...getSocketMetadata() });\n\n        // If there's already a run ID set, we should \"disconnect\" it from this socket\n        if (socket.data.runFriendlyId && socket.data.runFriendlyId !== friendlyId) {\n          socketLogger.debug(\"runConnected: disconnecting existing run\", {\n            ...getSocketMetadata(),\n            newRunId: friendlyId,\n            oldRunId: socket.data.runFriendlyId,\n          });\n          runDisconnected(socket.data.runFriendlyId);\n        }\n\n        this.runSockets.set(friendlyId, socket);\n        this.emit(\"runConnected\", { run: { friendlyId } });\n        socket.",
            "output_extracted": "import { type Namespace, Server, type Socket } from \"socket.io\";\nimport { SimpleStructuredLogger } from \"@trigger.dev/core/v3/utils/structuredLogger\";\nimport EventEmitter from \"node:events\";\nimport { z } from \"zod\";\nimport {\n  type SupervisorHttpClient,\n  WORKLOAD_HEADERS,\n  type WorkloadClientSocketData,\n  type WorkloadClientToServerEvents,\n  type WorkloadContinueRunExecutionResponseBody,\n  WorkloadDebugLogRequestBody,\n  type WorkloadDequeueFromVersionResponseBody,\n  WorkloadHeartbeatRequestBody,\n  type WorkloadHeartbeatResponseBody,\n  WorkloadRunAttemptCompleteRequestBody,\n  type WorkloadRunAttemptCompleteResponseBody,\n  WorkloadRunAttemptStartRequestBody,\n  type WorkloadRunAttemptStartResponseBody,\n  WorkloadRunSnapshotsSinceResponseBody,\n  type WorkloadServerToClientEvents,\n  type WorkloadSuspendRunResponseBody,\n} from \"@trigger.dev/core/v3/workers\";\nimport { HttpServer, type CheckpointClient } from \"@trigger.dev/core/v3/serverOnly\";\nimport { type IncomingMessage } from \"node:http\";\nimport { register } from \"../metrics.js\";\nimport { env } from \"../env.js\";\n\n// Use the official export when upgrading to socket.io@4.8.0\ninterface DefaultEventsMap {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [event: string]: (...args: any[]) => void;\n}\n\nconst WorkloadActionParams = z.object({\n  runFriendlyId: z.string(),\n  snapshotFriendlyId: z.string(),\n});\n\ntype WorkloadServerEvents = {\n  runConnected: [\n    {\n      run: {\n        friendlyId: string;\n      };\n    },\n  ];\n  runDisconnected: [\n    {\n      run: {\n        friendlyId: string;\n      };\n    },\n  ];\n};\n\ntype WorkloadServerOptions = {\n  port: number;\n  host?: string;\n  workerClient: SupervisorHttpClient;\n  checkpointClient?: CheckpointClient;\n};\n\nexport class WorkloadServer extends EventEmitter<WorkloadServerEvents> {\n  private checkpointClient?: CheckpointClient;\n\n  private readonly logger = new SimpleStructuredLogger(\"workload-server\");\n\n  private readonly httpServer: HttpServer;\n  private readonly websocketServer: Namespace<\n    WorkloadClientToServerEvents,\n    WorkloadServerToClientEvents,\n    DefaultEventsMap,\n    WorkloadClientSocketData\n  >;\n\n  private readonly runSockets = new Map<\n    string,\n    Socket<\n      WorkloadClientToServerEvents,\n      WorkloadServerToClientEvents,\n      DefaultEventsMap,\n      WorkloadClientSocketData\n    >\n  >();\n\n  private readonly workerClient: SupervisorHttpClient;\n\n  constructor(opts: WorkloadServerOptions) {\n    super();\n\n    const host = opts.host ?? \"0.0.0.0\";\n    const port = opts.port;\n\n    this.workerClient = opts.workerClient;\n    this.checkpointClient = opts.checkpointClient;\n\n    this.httpServer = this.createHttpServer({ host, port });\n    this.websocketServer = this.createWebsocketServer();\n  }\n\n  private headerValueFromRequest(req: IncomingMessage, headerName: string): string | undefined {\n    const value = req.headers[headerName];\n\n    if (Array.isArray(value)) {\n      return value[0];\n    }\n\n    return value;\n  }\n\n  private runnerIdFromRequest(req: IncomingMessage): string | undefined {\n    return this.headerValueFromRequest(req, WORKLOAD_HEADERS.RUNNER_ID);\n  }\n\n  private deploymentIdFromRequest(req: IncomingMessage): string | undefined {\n    return this.headerValueFromRequest(req, WORKLOAD_HEADERS.DEPLOYMENT_ID);\n  }\n\n  private deploymentVersionFromRequest(req: IncomingMessage): string | undefined {\n    return this.headerValueFromRequest(req, WORKLOAD_HEADERS.DEPLOYMENT_VERSION);\n  }\n\n  private projectRefFromRequest(req: IncomingMessage): string | undefined {\n    return this.headerValueFromRequest(req, WORKLOAD_HEADERS.PROJECT_REF);\n  }\n\n  private createHttpServer({ host, port }: { host: string; port: number }) {\n    return new HttpServer({\n      port,\n      host,\n      metrics: {\n        register,\n        expose: false,\n      },\n    })\n      .route(\"/health\", \"GET\", {\n        handler: async ({ reply }) => {\n          reply.text(\"OK\");\n        },\n      })\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/:snapshotFriendlyId/attempts/start\",\n        \"POST\",\n        {\n          paramsSchema: WorkloadActionParams,\n          bodySchema: WorkloadRunAttemptStartRequestBody,\n          handler: async ({ req, reply, params, body }) => {\n            const startResponse = await this.workerClient.startRunAttempt(\n              params.runFriendlyId,\n              params.snapshotFriendlyId,\n              body,\n              this.runnerIdFromRequest(req)\n            );\n\n            if (!startResponse.success) {\n              this.logger.error(\"Failed to start run\", {\n                params,\n                error: startResponse.error,\n              });\n              reply.empty(500);\n              return;\n            }\n\n            reply.json(startResponse.data satisfies WorkloadRunAttemptStartResponseBody);\n            return;\n          },\n        }\n      )\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/:snapshotFriendlyId/attempts/complete\",\n        \"POST\",\n        {\n          paramsSchema: WorkloadActionParams,\n          bodySchema: WorkloadRunAttemptCompleteRequestBody,\n          handler: async ({ req, reply, params, body }) => {\n            const completeResponse = await this.workerClient.completeRunAttempt(\n              params.runFriendlyId,\n              params.snapshotFriendlyId,\n              body,\n              this.runnerIdFromRequest(req)\n            );\n\n            if (!completeResponse.success) {\n              this.logger.error(\"Failed to complete run\", {\n                params,\n                error: completeResponse.error,\n              });\n              reply.empty(500);\n              return;\n            }\n\n            reply.json(completeResponse.data satisfies WorkloadRunAttemptCompleteResponseBody);\n            return;\n          },\n        }\n      )\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/:snapshotFriendlyId/heartbeat\",\n        \"POST\",\n        {\n          paramsSchema: WorkloadActionParams,\n          bodySchema: WorkloadHeartbeatRequestBody,\n          handler: async ({ req, reply, params, body }) => {\n            const heartbeatResponse = await this.workerClient.heartbeatRun(\n              params.runFriendlyId,\n              params.snapshotFriendlyId,\n              body,\n              this.runnerIdFromRequest(req)\n            );\n\n            if (!heartbeatResponse.success) {\n              this.logger.error(\"Failed to heartbeat run\", {\n                params,\n                error: heartbeatResponse.error,\n              });\n              reply.empty(500);\n              return;\n            }\n\n            reply.json({\n              ok: true,\n            } satisfies WorkloadHeartbeatResponseBody);\n          },\n        }\n      )\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/:snapshotFriendlyId/suspend\",\n        \"GET\",\n        {\n          paramsSchema: WorkloadActionParams,\n          handler: async ({ reply, params, req }) => {\n            this.logger.debug(\"Suspend request\", { params, headers: req.headers });\n\n            if (!this.checkpointClient) {\n              reply.json(\n                {\n                  ok: false,\n                  error: \"Checkpoints disabled\",\n                } satisfies WorkloadSuspendRunResponseBody,\n                false,\n                400\n              );\n              return;\n            }\n\n            const runnerId = this.runnerIdFromRequest(req);\n            const deploymentVersion = this.deploymentVersionFromRequest(req);\n            const projectRef = this.projectRefFromRequest(req);\n\n            if (!runnerId || !deploymentVersion || !projectRef) {\n              this.logger.error(\"Invalid headers for suspend request\", {\n                ...params,\n                headers: req.headers,\n              });\n              reply.json(\n                {\n                  ok: false,\n                  error: \"Invalid headers\",\n                } satisfies WorkloadSuspendRunResponseBody,\n                false,\n                400\n              );\n              return;\n            }\n\n            reply.json(\n              {\n                ok: true,\n              } satisfies WorkloadSuspendRunResponseBody,\n              false,\n              202\n            );\n\n            const suspendResult = await this.checkpointClient.suspendRun({\n              runFriendlyId: params.runFriendlyId,\n              snapshotFriendlyId: params.snapshotFriendlyId,\n              body: {\n                runnerId,\n                runId: params.runFriendlyId,\n                snapshotId: params.snapshotFriendlyId,\n                projectRef,\n                deploymentVersion,\n              },\n            });\n\n            if (!suspendResult) {\n              this.logger.error(\"Failed to suspend run\", { params });\n              return;\n            }\n          },\n        }\n      )\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/:snapshotFriendlyId/continue\",\n        \"GET\",\n        {\n          paramsSchema: WorkloadActionParams,\n          handler: async ({ req, reply, params }) => {\n            this.logger.debug(\"Run continuation request\", { params });\n\n            const continuationResult = await this.workerClient.continueRunExecution(\n              params.runFriendlyId,\n              params.snapshotFriendlyId,\n              this.runnerIdFromRequest(req)\n            );\n\n            if (!continuationResult.success) {\n              this.logger.error(\"Failed to continue run execution\", { params });\n              reply.json(\n                {\n                  ok: false,\n                  error: \"Failed to continue run execution\",\n                },\n                false,\n                400\n              );\n              return;\n            }\n\n            reply.json(continuationResult.data as WorkloadContinueRunExecutionResponseBody);\n          },\n        }\n      )\n      .route(\n        \"/api/v1/workload-actions/runs/:runFriendlyId/snapshots/since/:snapshotFriendlyId\",\n        \"GET\",\n        {\n          paramsSchema: WorkloadActionParams,\n          handler: async ({ req, reply, params }) => {\n            const sinceSnapshotResponse = await this.workerClient.getSnapshotsSince(\n              params.runFriendlyId,\n              params.snapshotFriendlyId,\n              this.runnerIdFromRequest(req)\n            );\n\n            if (!sinceSnapshotResponse.success) {\n              this.logger.error(\"Failed to get snapshots since\", {\n                runId: params.runFriendlyId,\n                error: sinceSnapshotResponse.error,\n              });\n              reply.empty(500);\n              return;\n            }\n\n            reply.json(sinceSnapshotResponse.data satisfies WorkloadRunSnapshotsSinceResponseBody);\n          },\n        }\n      )\n      .route(\"/api/v1/workload-actions/runs/:runFriendlyId/logs/debug\", \"POST\", {\n        paramsSchema: WorkloadActionParams.pick({ runFriendlyId: true }),\n        bodySchema: WorkloadDebugLogRequestBody,\n        handler: async ({ req, reply, params, body }) => {\n          reply.empty(204);\n\n          if (!env.SEND_RUN_DEBUG_LOGS) {\n            return;\n          }\n\n          await this.workerClient.sendDebugLog(\n            params.runFriendlyId,\n            body,\n            this.runnerIdFromRequest(req)\n          );\n        },\n      })\n      .route(\"/api/v1/workload-actions/deployments/:deploymentId/dequeue\", \"GET\", {\n        paramsSchema: z.object({\n          deploymentId: z.string(),\n        }),\n\n        handler: async ({ req, reply, params }) => {\n          const dequeueResponse = await this.workerClient.dequeueFromVersion(\n            params.deploymentId,\n            1,\n            this.runnerIdFromRequest(req)\n          );\n\n          if (!dequeueResponse.success) {\n            this.logger.error(\"Failed to get latest snapshot\", {\n              deploymentId: params.deploymentId,\n              error: dequeueResponse.error,\n            });\n            reply.empty(500);\n            return;\n          }\n\n          reply.json(dequeueResponse.data satisfies WorkloadDequeueFromVersionResponseBody);\n        },\n      });\n  }\n\n  private createWebsocketServer() {\n    const io = new Server(this.httpServer.server);\n\n    const websocketServer: Namespace<\n      WorkloadClientToServerEvents,\n      WorkloadServerToClientEvents,\n      DefaultEventsMap,\n      WorkloadClientSocketData\n    > = io.of(\"/workload\");\n\n    websocketServer.on(\"disconnect\", (socket) => {\n      this.logger.log(\"[WS] disconnect\", socket.id);\n    });\n    websocketServer.use(async (socket, next) => {\n      const setSocketDataFromHeader = (\n        dataKey: keyof typeof socket.data,\n        headerName: string,\n        required: boolean = true\n      ) => {\n        const value = socket.handshake.headers[headerName];\n\n        if (value) {\n          if (Array.isArray(value)) {\n            if (value[0]) {\n              socket.data[dataKey] = value[0];\n              return;\n            }\n          } else {\n            socket.data[dataKey] = value;\n            return;\n          }\n        }\n\n        if (required) {\n          this.logger.error(\"[WS] missing required header\", { headerName });\n          throw new Error(\"missing header\");\n        }\n      };\n\n      try {\n        setSocketDataFromHeader(\"deploymentId\", WORKLOAD_HEADERS.DEPLOYMENT_ID);\n        setSocketDataFromHeader(\"runnerId\", WORKLOAD_HEADERS.RUNNER_ID);\n      } catch (error) {\n        this.logger.error(\"[WS] setSocketDataFromHeader error\", { error });\n        socket.disconnect(true);\n        return;\n      }\n\n      this.logger.debug(\"[WS] auth success\", socket.data);\n\n      next();\n    });\n    websocketServer.on(\"connection\", (socket) => {\n      const socketLogger = this.logger.child({\n        socketId: socket.id,\n        socketData: socket.data,\n      });\n\n      const getSocketMetadata = () => {\n        return {\n          deploymentId: socket.data.deploymentId,\n          runId: socket.data.runFriendlyId,\n          snapshotId: socket.data.snapshotId,\n          runnerId: socket.data.runnerId,\n        };\n      };\n\n      const runConnected = (friendlyId: string) => {\n        socketLogger.debug(\"runConnected\", { ...getSocketMetadata() });\n\n        // If there's already a run ID set, we should \"disconnect\" it from this socket\n        if (socket.data.runFriendlyId && socket.data.runFriendlyId !== friendlyId) {\n          socketLogger.debug(\"runConnected: disconnecting existing run\", {\n            ...getSocketMetadata(),\n            newRunId: friendlyId,\n            oldRunId: socket.data.runFriendlyId,\n          });\n          runDisconnected(socket.data.runFriendlyId);\n        }\n\n        this.runSockets.set(friendlyId, socket);\n        this.emit(\"runConnected\", { run: { friendlyId } });\n        socket.",
            "cost": 0.135445
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/packages/cli-v3/src/entryPoints/managed/controller.ts": {
            "output": "import { WorkerManifest } from \"@trigger.dev/core/v3\";\nimport {\n  WarmStartClient,\n  WORKLOAD_HEADERS,\n  type WorkloadClientToServerEvents,\n  WorkloadHttpClient,\n  type WorkloadServerToClientEvents,\n} from \"@trigger.dev/core/v3/workers\";\nimport { io, type Socket } from \"socket.io-client\";\nimport { RunnerEnv } from \"./env.js\";\nimport { ManagedRunLogger, RunLogger, SendDebugLogOptions } from \"./logger.js\";\nimport { EnvObject } from \"std-env\";\nimport { RunExecution } from \"./execution.js\";\nimport { TaskRunProcessProvider } from \"./taskRunProcessProvider.js\";\nimport { tryCatch } from \"@trigger.dev/core/utils\";\n\ntype ManagedRunControllerOptions = {\n  workerManifest: WorkerManifest;\n  env: EnvObject;\n};\n\nexport type SupervisorSocket = Socket<WorkloadServerToClientEvents, WorkloadClientToServerEvents>;\n\nexport class ManagedRunController {\n  private readonly env: RunnerEnv;\n  private readonly workerManifest: WorkerManifest;\n  private readonly httpClient: WorkloadHttpClient;\n  private readonly warmStartClient: WarmStartClient | undefined;\n  private socket: SupervisorSocket;\n  private readonly logger: RunLogger;\n  private readonly taskRunProcessProvider: TaskRunProcessProvider;\n\n  private warmStartEnabled = true;\n  private warmStartCount = 0;\n\n  private restoreCount = 0;\n\n  private notificationCount = 0;\n  private lastNotificationAt: Date | null = null;\n\n  private currentExecution: RunExecution | null = null;\n\n  private processKeepAliveEnabled: boolean;\n  private processKeepAliveMaxExecutionCount: number;\n\n  constructor(opts: ManagedRunControllerOptions) {\n    const env = new RunnerEnv(opts.env);\n    this.env = env;\n\n    this.workerManifest = opts.workerManifest;\n    this.processKeepAliveEnabled = opts.workerManifest.processKeepAlive?.enabled ?? false;\n    this.processKeepAliveMaxExecutionCount =\n      opts.workerManifest.processKeepAlive?.maxExecutionsPerProcess ?? 100;\n\n    this.httpClient = new WorkloadHttpClient({\n      workerApiUrl: this.workerApiUrl,\n      runnerId: this.runnerId,\n      deploymentId: env.TRIGGER_DEPLOYMENT_ID,\n      deploymentVersion: env.TRIGGER_DEPLOYMENT_VERSION,\n      projectRef: env.TRIGGER_PROJECT_REF,\n    });\n\n    this.logger = new ManagedRunLogger({\n      httpClient: this.httpClient,\n      env,\n    });\n\n    // Create the TaskRunProcessProvider\n    this.taskRunProcessProvider = new TaskRunProcessProvider({\n      workerManifest: this.workerManifest,\n      env: this.env,\n      logger: this.logger,\n      processKeepAliveEnabled: this.processKeepAliveEnabled,\n      processKeepAliveMaxExecutionCount: this.processKeepAliveMaxExecutionCount,\n    });\n\n    const properties = {\n      ...env.raw,\n      TRIGGER_POD_SCHEDULED_AT_MS: env.TRIGGER_POD_SCHEDULED_AT_MS.toISOString(),\n      TRIGGER_DEQUEUED_AT_MS: env.TRIGGER_DEQUEUED_AT_MS.toISOString(),\n    };\n\n    this.sendDebugLog({\n      runId: env.TRIGGER_RUN_ID,\n      message: \"Creating run controller\",\n      properties,\n    });\n\n    if (env.TRIGGER_WARM_START_URL) {\n      this.warmStartClient = new WarmStartClient({\n        apiUrl: new URL(env.TRIGGER_WARM_START_URL),\n        controllerId: env.TRIGGER_WORKLOAD_CONTROLLER_ID,\n        deploymentId: env.TRIGGER_DEPLOYMENT_ID,\n        deploymentVersion: env.TRIGGER_DEPLOYMENT_VERSION,\n        machineCpu: env.TRIGGER_MACHINE_CPU,\n        machineMemory: env.TRIGGER_MACHINE_MEMORY,\n      });\n    }\n\n    // Websocket notifications are only an optimisation so we don't need to wait for a successful connection\n    this.socket = this.createSupervisorSocket();\n\n    process.on(\"SIGTERM\", async () => {\n      this.sendDebugLog({\n        runId: this.runFriendlyId,\n        message: \"Received SIGTERM, stopping worker\",\n      });\n\n      // Disable warm starts - prevents new warm start requests\n      this.warmStartEnabled = false;\n\n      // Abort any ongoing warm start long poll - immediately stops waiting for next run\n      // This prevents the scenario where:\n      // 1. SIGTERM kills a prepared child process\n      // 2. Warm start poll returns a new run\n      // 3. Controller tries to use the dead child process\n      this.warmStartClient?.abort();\n\n      // Now we wait for any active runs to finish gracefully\n      // SIGKILL will handle forced termination after termination grace period\n    });\n  }\n\n  get metrics() {\n    return {\n      warmStartCount: this.warmStartCount,\n      restoreCount: this.restoreCount,\n      notificationCount: this.notificationCount,\n      lastNotificationAt: this.lastNotificationAt,\n      ...this.taskRunProcessProvider.metrics,\n    };\n  }\n\n  get runnerId() {\n    return this.env.TRIGGER_RUNNER_ID;\n  }\n\n  get successExitCode() {\n    return this.env.TRIGGER_SUCCESS_EXIT_CODE;\n  }\n\n  get failureExitCode() {\n    return this.env.TRIGGER_FAILURE_EXIT_CODE;\n  }\n\n  get workerApiUrl() {\n    return this.env.TRIGGER_SUPERVISOR_API_URL;\n  }\n\n  get workerInstanceName() {\n    return this.env.TRIGGER_WORKER_INSTANCE_NAME;\n  }\n\n  private subscribeToRunNotifications(runFriendlyId: string, snapshotFriendlyId: string) {\n    this.socket.emit(\"run:start\", {\n      version: \"1\",\n      run: {\n        friendlyId: runFriendlyId,\n      },\n      snapshot: {\n        friendlyId: snapshotFriendlyId,\n      },\n    });\n  }\n\n  private unsubscribeFromRunNotifications(runFriendlyId: string, snapshotFriendlyId: string) {\n    this.socket.emit(\"run:stop\", {\n      version: \"1\",\n      run: {\n        friendlyId: runFriendlyId,\n      },\n      snapshot: {\n        friendlyId: snapshotFriendlyId,\n      },\n    });\n  }\n\n  private get runFriendlyId() {\n    return this.currentExecution?.runFriendlyId;\n  }\n\n  private get snapshotFriendlyId() {\n    return this.currentExecution?.currentSnapshotFriendlyId;\n  }\n\n  private lockedRunExecution: Promise<void> | null = null;\n\n  private async startRunExecution({\n    runFriendlyId,\n    snapshotFriendlyId,\n    dequeuedAt,\n    podScheduledAt,\n    isWarmStart,\n    previousRunId,\n  }: {\n    runFriendlyId: string;\n    snapshotFriendlyId: string;\n    dequeuedAt?: Date;\n    podScheduledAt?: Date;\n    isWarmStart?: boolean;\n    previousRunId?: string;\n  }) {\n    this.sendDebugLog({\n      runId: runFriendlyId,\n      message: \"startAndExecuteRunAttempt()\",\n      properties: { previousRunId },\n    });\n\n    if (this.lockedRunExecution) {\n      this.sendDebugLog({\n        runId: runFriendlyId,\n        message: \"startAndExecuteRunAttempt: execution already locked\",\n      });\n      return;\n    }\n\n    const execution = async () => {\n      // If we have an existing execution that isn't prepared for the next run, kill it\n      if (this.currentExecution && !this.currentExecution.canExecute) {\n        this.sendDebugLog({\n          runId: runFriendlyId,\n          message: \"killing existing execution before starting new run\",\n        });\n\n        await this.currentExecution.shutdown().catch((error) => {\n          this.sendDebugLog({\n            runId: runFriendlyId,\n            message: \"Error during execution shutdown\",\n            properties: { error: error instanceof Error ? error.message : String(error) },\n          });\n        });\n\n        this.currentExecution = null;\n      }\n\n      // Remove all run notification listeners just to be safe\n      this.socket.removeAllListeners(\"run:notify\");\n\n      if (!this.currentExecution || !this.currentExecution.canExecute) {\n        this.currentExecution = new RunExecution({\n          workerManifest: this.workerManifest,\n          env: this.env,\n          httpClient: this.httpClient,\n          logger: this.logger,\n          supervisorSocket: this.socket,\n          taskRunProcessProvider: this.taskRunProcessProvider,\n        });\n      }\n\n      // Subscribe to run notifications\n      this.subscribeToRunNotifications(runFriendlyId, snapshotFriendlyId);\n\n      // We're prepared for the next run so we can start executing\n      await this.currentExecution.execute({\n        runFriendlyId,\n        snapshotFriendlyId,\n        dequeuedAt,\n        podScheduledAt,\n        isWarmStart,\n      });\n    };\n\n    this.lockedRunExecution = execution();\n\n    const [error] = await tryCatch(this.lockedRunExecution);\n\n    if (error) {\n      this.sendDebugLog({\n        runId: runFriendlyId,\n        message: \"Error during execution\",\n        properties: { error: error.message },\n      });\n    }\n\n    const metrics = this.currentExecution?.metrics;\n\n    if (metrics?.execution?.restoreCount) {\n      this.restoreCount += metrics.execution.restoreCount;\n    }\n\n    this.lockedRunExecution = null;\n    this.unsubscribeFromRunNotifications(runFriendlyId, snapshotFriendlyId);\n    this.waitForNextRun();\n  }\n\n  private waitForNextRunLock = false;\n\n  /**\n   *  This will eagerly create a new run execution. It will never throw, but may exit\n   *  the process on any errors or when no runs are available after the configured duration.\n   */\n  private async waitForNextRun() {\n    if (!this.warmStartEnabled) {\n      this.sendDebugLog({\n        runId: this.runFriendlyId,\n        message: \"waitForNextRun: warm starts disabled, shutting down\",\n      });\n      this.exitProcess(this.successExitCode);\n    }\n\n    this.sendDebugLog({\n      runId: this.runFriendlyId,\n      message: \"waitForNextRun()\",\n    });\n\n    if (this.waitForNextRunLock) {\n      this.sendDebugLog({\n        runId: this.runFriendlyId,\n        message: \"waitForNextRun: already in progress, skipping\",\n      });\n      return;\n    }\n\n    if (this.lockedRunExecution) {\n      this.sendDebugLog({\n        runId: this.runFriendlyId,\n        message: \"waitForNextRun: execution locked, skipping\",\n      });\n      return;\n    }\n\n    this.waitForNextRunLock = true;\n\n    const previousRunId = this.runFriendlyId;\n\n    try {\n      if (!this.warmStartClient) {\n        this.sendDebugLog({\n          runId: this.runFriendlyId,\n          message: \"waitForNextRun: warm starts disabled, shutting down\",\n        });\n        this.exitProcess(this.successExitCode);\n      }\n\n      if (this.currentExecution?.taskRunEnv) {\n        this.sendDebugLog({\n          runId: this.runFriendlyId,\n          message: \"waitForNextRun: eagerly creating fresh execution for next run\",\n        });\n\n        const previousTaskRunEnv = this.currentExecution.taskRunEnv;\n\n        // Create a fresh execution for the next run\n        this.currentExecution = new RunExecution({\n          workerManifest: this.workerManifest,\n          env: this.env,\n          httpClient: this.httpClient,\n          logger: this.logger,\n          supervisorSocket: this.socket,\n          taskRunProcessProvider: this.taskRunProcessProvider,\n        });\n\n        await this.currentExecution.prepareForExecution({\n          taskRunEnv: previousTaskRunEnv,\n        });\n      }\n\n      // Check the service is up and get additional warm start config\n      const connect = await this.warmStartClient.connect();\n\n      if (!connect.success) {\n        this.sendDebugLog({\n          runId: this.runFriendlyId,\n          message: \"waitForNextRun: failed to connect to warm start service\",\n          properties: {\n            warmStartUrl: this.env.TRIGGER_WARM_START_URL,\n            error: connect.error,\n          },\n        });\n        this.exitProcess(this.successExitCode);\n      }\n\n      const connectionTimeoutMs =\n        connect.data.connectionTimeoutMs ?? this.env.TRIGGER_WARM_START_CONNECTION_TIMEOUT_MS;\n      const keepaliveMs = connect.data.keepaliveMs ?? this.env.TRIGGER_WARM_START_KEEPALIVE_MS;\n\n      const warmStartConfig = {\n        connectionTimeoutMs,\n        keepaliveMs,\n      };\n\n      this.sendDebugLog({\n        runId: previousRunId,\n        message: \"waitForNextRun: connected to warm start service\",\n        properties: warmStartConfig,\n      });\n\n      if (!connectionTimeoutMs || !keepaliveMs) {\n        this.sendDebugLog({\n          runId: previousRunId,\n          message: \"waitForNextRun: warm starts disabled after connect\",\n          properties: warmStartConfig,\n        });\n        this.exitProcess(this.successExitCode);\n      }\n\n      const nextRun = await this.warmStartClient.warmStart({\n        workerInstanceName: this.workerInstanceName,\n        connectionTimeoutMs,\n        keepaliveMs,\n      });\n\n      if (!nextRun) {\n        this.sendDebugLog({\n          runId: previousRunId,\n          message: \"waitForNextRun: warm start failed, shutting down\",\n          properties: warmStartConfig,\n        });\n        this.exitProcess(this.successExitCode);\n      }\n\n      this.warmStartCount++;\n\n      this.sendDebugLog({\n        runId: previousRunId,\n        message: \"waitForNextRun: got next run\",\n        properties: {\n          ...warmStartConfig,\n          nextRunId: nextRun.run.friendlyId,\n        },\n      });\n\n      this.startRunExecution({\n        runFriendlyId: nextRun.run.friendlyId,\n        snapshotFriendlyId: nextRun.snapshot.friendlyId,\n        dequeuedAt: nextRun.dequeuedAt,\n        isWarmStart: true,\n        previousRunId,\n      }).finally(() => {});\n    } catch (error) {\n      this.sendDebugLog({\n        runId: previousRunId,\n        message: \"waitForNextRun: unexpected error\",\n        properties: { error: error instanceof Error ? error.message : String(error) },\n      });\n      this.exitProcess(this.failureExitCode);\n    } finally {\n      this.waitForNextRunLock = false;\n    }\n  }\n\n  private exitProcess(code?: number): never {\n    this.sendDebugLog({\n      runId: this.runFriendlyId,\n      message: \"Exiting process\",\n      properties: { code },\n    });\n\n    this.currentExecution?.kill().catch(() => {});\n    this.taskRunProcessProvider.cleanup().catch(() => {});\n\n    process",
            "output_extracted": "import { WorkerManifest } from \"@trigger.dev/core/v3\";\nimport {\n  WarmStartClient,\n  WORKLOAD_HEADERS,\n  type WorkloadClientToServerEvents,\n  WorkloadHttpClient,\n  type WorkloadServerToClientEvents,\n} from \"@trigger.dev/core/v3/workers\";\nimport { io, type Socket } from \"socket.io-client\";\nimport { RunnerEnv } from \"./env.js\";\nimport { ManagedRunLogger, RunLogger, SendDebugLogOptions } from \"./logger.js\";\nimport { EnvObject } from \"std-env\";\nimport { RunExecution } from \"./execution.js\";\nimport { TaskRunProcessProvider } from \"./taskRunProcessProvider.js\";\nimport { tryCatch } from \"@trigger.dev/core/utils\";\n\ntype ManagedRunControllerOptions = {\n  workerManifest: WorkerManifest;\n  env: EnvObject;\n};\n\nexport type SupervisorSocket = Socket<WorkloadServerToClientEvents, WorkloadClientToServerEvents>;\n\nexport class ManagedRunController {\n  private readonly env: RunnerEnv;\n  private readonly workerManifest: WorkerManifest;\n  private readonly httpClient: WorkloadHttpClient;\n  private readonly warmStartClient: WarmStartClient | undefined;\n  private socket: SupervisorSocket;\n  private readonly logger: RunLogger;\n  private readonly taskRunProcessProvider: TaskRunProcessProvider;\n\n  private warmStartEnabled = true;\n  private warmStartCount = 0;\n\n  private restoreCount = 0;\n\n  private notificationCount = 0;\n  private lastNotificationAt: Date | null = null;\n\n  private currentExecution: RunExecution | null = null;\n\n  private processKeepAliveEnabled: boolean;\n  private processKeepAliveMaxExecutionCount: number;\n\n  constructor(opts: ManagedRunControllerOptions) {\n    const env = new RunnerEnv(opts.env);\n    this.env = env;\n\n    this.workerManifest = opts.workerManifest;\n    this.processKeepAliveEnabled = opts.workerManifest.processKeepAlive?.enabled ?? false;\n    this.processKeepAliveMaxExecutionCount =\n      opts.workerManifest.processKeepAlive?.maxExecutionsPerProcess ?? 100;\n\n    this.httpClient = new WorkloadHttpClient({\n      workerApiUrl: this.workerApiUrl,\n      runnerId: this.runnerId,\n      deploymentId: env.TRIGGER_DEPLOYMENT_ID,\n      deploymentVersion: env.TRIGGER_DEPLOYMENT_VERSION,\n      projectRef: env.TRIGGER_PROJECT_REF,\n    });\n\n    this.logger = new ManagedRunLogger({\n      httpClient: this.httpClient,\n      env,\n    });\n\n    // Create the TaskRunProcessProvider\n    this.taskRunProcessProvider = new TaskRunProcessProvider({\n      workerManifest: this.workerManifest,\n      env: this.env,\n      logger: this.logger,\n      processKeepAliveEnabled: this.processKeepAliveEnabled,\n      processKeepAliveMaxExecutionCount: this.processKeepAliveMaxExecutionCount,\n    });\n\n    const properties = {\n      ...env.raw,\n      TRIGGER_POD_SCHEDULED_AT_MS: env.TRIGGER_POD_SCHEDULED_AT_MS.toISOString(),\n      TRIGGER_DEQUEUED_AT_MS: env.TRIGGER_DEQUEUED_AT_MS.toISOString(),\n    };\n\n    this.sendDebugLog({\n      runId: env.TRIGGER_RUN_ID,\n      message: \"Creating run controller\",\n      properties,\n    });\n\n    if (env.TRIGGER_WARM_START_URL) {\n      this.warmStartClient = new WarmStartClient({\n        apiUrl: new URL(env.TRIGGER_WARM_START_URL),\n        controllerId: env.TRIGGER_WORKLOAD_CONTROLLER_ID,\n        deploymentId: env.TRIGGER_DEPLOYMENT_ID,\n        deploymentVersion: env.TRIGGER_DEPLOYMENT_VERSION,\n        machineCpu: env.TRIGGER_MACHINE_CPU,\n        machineMemory: env.TRIGGER_MACHINE_MEMORY,\n      });\n    }\n\n    // Websocket notifications are only an optimisation so we don't need to wait for a successful connection\n    this.socket = this.createSupervisorSocket();\n\n    process.on(\"SIGTERM\", async () => {\n      this.sendDebugLog({\n        runId: this.runFriendlyId,\n        message: \"Received SIGTERM, stopping worker\",\n      });\n\n      // Disable warm starts - prevents new warm start requests\n      this.warmStartEnabled = false;\n\n      // Abort any ongoing warm start long poll - immediately stops waiting for next run\n      // This prevents the scenario where:\n      // 1. SIGTERM kills a prepared child process\n      // 2. Warm start poll returns a new run\n      // 3. Controller tries to use the dead child process\n      this.warmStartClient?.abort();\n\n      // Now we wait for any active runs to finish gracefully\n      // SIGKILL will handle forced termination after termination grace period\n    });\n  }\n\n  get metrics() {\n    return {\n      warmStartCount: this.warmStartCount,\n      restoreCount: this.restoreCount,\n      notificationCount: this.notificationCount,\n      lastNotificationAt: this.lastNotificationAt,\n      ...this.taskRunProcessProvider.metrics,\n    };\n  }\n\n  get runnerId() {\n    return this.env.TRIGGER_RUNNER_ID;\n  }\n\n  get successExitCode() {\n    return this.env.TRIGGER_SUCCESS_EXIT_CODE;\n  }\n\n  get failureExitCode() {\n    return this.env.TRIGGER_FAILURE_EXIT_CODE;\n  }\n\n  get workerApiUrl() {\n    return this.env.TRIGGER_SUPERVISOR_API_URL;\n  }\n\n  get workerInstanceName() {\n    return this.env.TRIGGER_WORKER_INSTANCE_NAME;\n  }\n\n  private subscribeToRunNotifications(runFriendlyId: string, snapshotFriendlyId: string) {\n    this.socket.emit(\"run:start\", {\n      version: \"1\",\n      run: {\n        friendlyId: runFriendlyId,\n      },\n      snapshot: {\n        friendlyId: snapshotFriendlyId,\n      },\n    });\n  }\n\n  private unsubscribeFromRunNotifications(runFriendlyId: string, snapshotFriendlyId: string) {\n    this.socket.emit(\"run:stop\", {\n      version: \"1\",\n      run: {\n        friendlyId: runFriendlyId,\n      },\n      snapshot: {\n        friendlyId: snapshotFriendlyId,\n      },\n    });\n  }\n\n  private get runFriendlyId() {\n    return this.currentExecution?.runFriendlyId;\n  }\n\n  private get snapshotFriendlyId() {\n    return this.currentExecution?.currentSnapshotFriendlyId;\n  }\n\n  private lockedRunExecution: Promise<void> | null = null;\n\n  private async startRunExecution({\n    runFriendlyId,\n    snapshotFriendlyId,\n    dequeuedAt,\n    podScheduledAt,\n    isWarmStart,\n    previousRunId,\n  }: {\n    runFriendlyId: string;\n    snapshotFriendlyId: string;\n    dequeuedAt?: Date;\n    podScheduledAt?: Date;\n    isWarmStart?: boolean;\n    previousRunId?: string;\n  }) {\n    this.sendDebugLog({\n      runId: runFriendlyId,\n      message: \"startAndExecuteRunAttempt()\",\n      properties: { previousRunId },\n    });\n\n    if (this.lockedRunExecution) {\n      this.sendDebugLog({\n        runId: runFriendlyId,\n        message: \"startAndExecuteRunAttempt: execution already locked\",\n      });\n      return;\n    }\n\n    const execution = async () => {\n      // If we have an existing execution that isn't prepared for the next run, kill it\n      if (this.currentExecution && !this.currentExecution.canExecute) {\n        this.sendDebugLog({\n          runId: runFriendlyId,\n          message: \"killing existing execution before starting new run\",\n        });\n\n        await this.currentExecution.shutdown().catch((error) => {\n          this.sendDebugLog({\n            runId: runFriendlyId,\n            message: \"Error during execution shutdown\",\n            properties: { error: error instanceof Error ? error.message : String(error) },\n          });\n        });\n\n        this.currentExecution = null;\n      }\n\n      // Remove all run notification listeners just to be safe\n      this.socket.removeAllListeners(\"run:notify\");\n\n      if (!this.currentExecution || !this.currentExecution.canExecute) {\n        this.currentExecution = new RunExecution({\n          workerManifest: this.workerManifest,\n          env: this.env,\n          httpClient: this.httpClient,\n          logger: this.logger,\n          supervisorSocket: this.socket,\n          taskRunProcessProvider: this.taskRunProcessProvider,\n        });\n      }\n\n      // Subscribe to run notifications\n      this.subscribeToRunNotifications(runFriendlyId, snapshotFriendlyId);\n\n      // We're prepared for the next run so we can start executing\n      await this.currentExecution.execute({\n        runFriendlyId,\n        snapshotFriendlyId,\n        dequeuedAt,\n        podScheduledAt,\n        isWarmStart,\n      });\n    };\n\n    this.lockedRunExecution = execution();\n\n    const [error] = await tryCatch(this.lockedRunExecution);\n\n    if (error) {\n      this.sendDebugLog({\n        runId: runFriendlyId,\n        message: \"Error during execution\",\n        properties: { error: error.message },\n      });\n    }\n\n    const metrics = this.currentExecution?.metrics;\n\n    if (metrics?.execution?.restoreCount) {\n      this.restoreCount += metrics.execution.restoreCount;\n    }\n\n    this.lockedRunExecution = null;\n    this.unsubscribeFromRunNotifications(runFriendlyId, snapshotFriendlyId);\n    this.waitForNextRun();\n  }\n\n  private waitForNextRunLock = false;\n\n  /**\n   *  This will eagerly create a new run execution. It will never throw, but may exit\n   *  the process on any errors or when no runs are available after the configured duration.\n   */\n  private async waitForNextRun() {\n    if (!this.warmStartEnabled) {\n      this.sendDebugLog({\n        runId: this.runFriendlyId,\n        message: \"waitForNextRun: warm starts disabled, shutting down\",\n      });\n      this.exitProcess(this.successExitCode);\n    }\n\n    this.sendDebugLog({\n      runId: this.runFriendlyId,\n      message: \"waitForNextRun()\",\n    });\n\n    if (this.waitForNextRunLock) {\n      this.sendDebugLog({\n        runId: this.runFriendlyId,\n        message: \"waitForNextRun: already in progress, skipping\",\n      });\n      return;\n    }\n\n    if (this.lockedRunExecution) {\n      this.sendDebugLog({\n        runId: this.runFriendlyId,\n        message: \"waitForNextRun: execution locked, skipping\",\n      });\n      return;\n    }\n\n    this.waitForNextRunLock = true;\n\n    const previousRunId = this.runFriendlyId;\n\n    try {\n      if (!this.warmStartClient) {\n        this.sendDebugLog({\n          runId: this.runFriendlyId,\n          message: \"waitForNextRun: warm starts disabled, shutting down\",\n        });\n        this.exitProcess(this.successExitCode);\n      }\n\n      if (this.currentExecution?.taskRunEnv) {\n        this.sendDebugLog({\n          runId: this.runFriendlyId,\n          message: \"waitForNextRun: eagerly creating fresh execution for next run\",\n        });\n\n        const previousTaskRunEnv = this.currentExecution.taskRunEnv;\n\n        // Create a fresh execution for the next run\n        this.currentExecution = new RunExecution({\n          workerManifest: this.workerManifest,\n          env: this.env,\n          httpClient: this.httpClient,\n          logger: this.logger,\n          supervisorSocket: this.socket,\n          taskRunProcessProvider: this.taskRunProcessProvider,\n        });\n\n        await this.currentExecution.prepareForExecution({\n          taskRunEnv: previousTaskRunEnv,\n        });\n      }\n\n      // Check the service is up and get additional warm start config\n      const connect = await this.warmStartClient.connect();\n\n      if (!connect.success) {\n        this.sendDebugLog({\n          runId: this.runFriendlyId,\n          message: \"waitForNextRun: failed to connect to warm start service\",\n          properties: {\n            warmStartUrl: this.env.TRIGGER_WARM_START_URL,\n            error: connect.error,\n          },\n        });\n        this.exitProcess(this.successExitCode);\n      }\n\n      const connectionTimeoutMs =\n        connect.data.connectionTimeoutMs ?? this.env.TRIGGER_WARM_START_CONNECTION_TIMEOUT_MS;\n      const keepaliveMs = connect.data.keepaliveMs ?? this.env.TRIGGER_WARM_START_KEEPALIVE_MS;\n\n      const warmStartConfig = {\n        connectionTimeoutMs,\n        keepaliveMs,\n      };\n\n      this.sendDebugLog({\n        runId: previousRunId,\n        message: \"waitForNextRun: connected to warm start service\",\n        properties: warmStartConfig,\n      });\n\n      if (!connectionTimeoutMs || !keepaliveMs) {\n        this.sendDebugLog({\n          runId: previousRunId,\n          message: \"waitForNextRun: warm starts disabled after connect\",\n          properties: warmStartConfig,\n        });\n        this.exitProcess(this.successExitCode);\n      }\n\n      const nextRun = await this.warmStartClient.warmStart({\n        workerInstanceName: this.workerInstanceName,\n        connectionTimeoutMs,\n        keepaliveMs,\n      });\n\n      if (!nextRun) {\n        this.sendDebugLog({\n          runId: previousRunId,\n          message: \"waitForNextRun: warm start failed, shutting down\",\n          properties: warmStartConfig,\n        });\n        this.exitProcess(this.successExitCode);\n      }\n\n      this.warmStartCount++;\n\n      this.sendDebugLog({\n        runId: previousRunId,\n        message: \"waitForNextRun: got next run\",\n        properties: {\n          ...warmStartConfig,\n          nextRunId: nextRun.run.friendlyId,\n        },\n      });\n\n      this.startRunExecution({\n        runFriendlyId: nextRun.run.friendlyId,\n        snapshotFriendlyId: nextRun.snapshot.friendlyId,\n        dequeuedAt: nextRun.dequeuedAt,\n        isWarmStart: true,\n        previousRunId,\n      }).finally(() => {});\n    } catch (error) {\n      this.sendDebugLog({\n        runId: previousRunId,\n        message: \"waitForNextRun: unexpected error\",\n        properties: { error: error instanceof Error ? error.message : String(error) },\n      });\n      this.exitProcess(this.failureExitCode);\n    } finally {\n      this.waitForNextRunLock = false;\n    }\n  }\n\n  private exitProcess(code?: number): never {\n    this.sendDebugLog({\n      runId: this.runFriendlyId,\n      message: \"Exiting process\",\n      properties: { code },\n    });\n\n    this.currentExecution?.kill().catch(() => {});\n    this.taskRunProcessProvider.cleanup().catch(() => {});\n\n    process",
            "cost": 0.13870500000000002
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/packages/cli-v3/src/entryPoints/managed/execution.ts": {
            "output": "import {\n  type CompleteRunAttemptResult,\n  type RunExecutionData,\n  SuspendedProcessError,\n  type TaskRunExecutionMetrics,\n  type TaskRunExecutionResult,\n  TaskRunExecutionRetry,\n  TaskRunExecutionStatus,\n  type TaskRunFailedExecutionResult,\n  WorkerManifest,\n} from \"@trigger.dev/core/v3\";\nimport { type WorkloadRunAttemptStartResponseBody } from \"@trigger.dev/core/v3/workers\";\nimport { TaskRunProcess } from \"../../executions/taskRunProcess.js\";\nimport { RunLogger, SendDebugLogOptions } from \"./logger.js\";\nimport { RunnerEnv } from \"./env.js\";\nimport { WorkloadHttpClient } from \"@trigger.dev/core/v3/workers\";\nimport { setTimeout as sleep } from \"timers/promises\";\nimport { RunExecutionSnapshotPoller } from \"./poller.js\";\nimport { assertExhaustive, tryCatch } from \"@trigger.dev/core/utils\";\nimport { Metadata, MetadataClient } from \"./overrides.js\";\nimport { randomBytes } from \"node:crypto\";\nimport { SnapshotManager, SnapshotState } from \"./snapshot.js\";\nimport type { SupervisorSocket } from \"./controller.js\";\nimport { RunNotifier } from \"./notifier.js\";\nimport { TaskRunProcessProvider } from \"./taskRunProcessProvider.js\";\n\nclass ExecutionAbortError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ExecutionAbortError\";\n  }\n}\n\ntype RunExecutionOptions = {\n  workerManifest: WorkerManifest;\n  env: RunnerEnv;\n  httpClient: WorkloadHttpClient;\n  logger: RunLogger;\n  supervisorSocket: SupervisorSocket;\n  taskRunProcessProvider: TaskRunProcessProvider;\n};\n\ntype RunExecutionPrepareOptions = {\n  taskRunEnv: Record<string, string>;\n};\n\ntype RunExecutionRunOptions = {\n  runFriendlyId: string;\n  snapshotFriendlyId: string;\n  dequeuedAt?: Date;\n  podScheduledAt?: Date;\n  isWarmStart?: boolean;\n};\n\nexport class RunExecution {\n  private id: string;\n  private executionAbortController: AbortController;\n\n  private _runFriendlyId?: string;\n  private currentAttemptNumber?: number;\n  private currentTaskRunEnv?: Record<string, string>;\n  private snapshotManager?: SnapshotManager;\n\n  private dequeuedAt?: Date;\n  private podScheduledAt?: Date;\n  private readonly workerManifest: WorkerManifest;\n  private readonly env: RunnerEnv;\n  private readonly httpClient: WorkloadHttpClient;\n  private readonly logger: RunLogger;\n  private restoreCount: number;\n\n  private taskRunProcess?: TaskRunProcess;\n  private snapshotPoller?: RunExecutionSnapshotPoller;\n\n  private lastHeartbeat?: Date;\n  private isShuttingDown = false;\n  private shutdownReason?: string;\n\n  private isCompletingRun = false;\n  private ignoreSnapshotChanges = false;\n\n  private supervisorSocket: SupervisorSocket;\n  private notifier?: RunNotifier;\n  private metadataClient?: MetadataClient;\n  private taskRunProcessProvider: TaskRunProcessProvider;\n\n  constructor(opts: RunExecutionOptions) {\n    this.id = randomBytes(4).toString(\"hex\");\n    this.workerManifest = opts.workerManifest;\n    this.env = opts.env;\n    this.httpClient = opts.httpClient;\n    this.logger = opts.logger;\n    this.supervisorSocket = opts.supervisorSocket;\n    this.taskRunProcessProvider = opts.taskRunProcessProvider;\n\n    this.restoreCount = 0;\n    this.executionAbortController = new AbortController();\n\n    if (this.env.TRIGGER_METADATA_URL) {\n      this.metadataClient = new MetadataClient(this.env.TRIGGER_METADATA_URL);\n    }\n  }\n\n  /**\n   * Cancels the current execution.\n   */\n  public async cancel(): Promise<void> {\n    if (this.isShuttingDown) {\n      throw new Error(\"cancel called after execution shut down\");\n    }\n\n    this.sendDebugLog(\"cancelling attempt\", { runId: this.runFriendlyId });\n\n    await this.taskRunProcess?.cancel();\n  }\n\n  /**\n   * Kills the current execution.\n   */\n  public async kill({ exitExecution = true }: { exitExecution?: boolean } = {}) {\n    if (this.taskRunProcess) {\n      await this.taskRunProcessProvider.handleProcessAbort(this.taskRunProcess);\n    }\n\n    if (exitExecution) {\n      this.shutdownExecution(\"kill\");\n    }\n  }\n\n  public async shutdown() {\n    if (this.taskRunProcess) {\n      await this.taskRunProcessProvider.handleProcessAbort(this.taskRunProcess);\n    }\n\n    this.shutdownExecution(\"shutdown\");\n  }\n\n  /**\n   * Prepares the execution with task run environment variables.\n   * This should be called before executing, typically after a successful run to prepare for the next one.\n   */\n  public async prepareForExecution(opts: RunExecutionPrepareOptions) {\n    if (this.isShuttingDown) {\n      throw new Error(\"prepareForExecution called after execution shut down\");\n    }\n\n    if (this.taskRunProcess) {\n      throw new Error(\"prepareForExecution called after process was already created\");\n    }\n\n    // Set the task run environment so canExecute returns true\n    this.currentTaskRunEnv = opts.taskRunEnv;\n\n    this.taskRunProcess = await this.taskRunProcessProvider.getProcess({\n      taskRunEnv: opts.taskRunEnv,\n      isWarmStart: true,\n    });\n  }\n\n  private attachTaskRunProcessHandlers(taskRunProcess: TaskRunProcess): void {\n    taskRunProcess.unsafeDetachEvtHandlers();\n\n    taskRunProcess.onTaskRunHeartbeat.attach(async (runId) => {\n      if (!this.runFriendlyId) {\n        this.sendDebugLog(\"onTaskRunHeartbeat: missing run ID\", { heartbeatRunId: runId });\n        return;\n      }\n\n      if (runId !== this.runFriendlyId) {\n        this.sendDebugLog(\"onTaskRunHeartbeat: mismatched run ID\", {\n          heartbeatRunId: runId,\n          expectedRunId: this.runFriendlyId,\n        });\n        return;\n      }\n\n      const [error] = await tryCatch(this.onHeartbeat());\n\n      if (error) {\n        this.sendDebugLog(\"onTaskRunHeartbeat: failed\", { error: error.message });\n      }\n    });\n\n    taskRunProcess.onSendDebugLog.attach(async (debugLog) => {\n      this.sendRuntimeDebugLog(debugLog.message, debugLog.properties);\n    });\n\n    taskRunProcess.onSetSuspendable.attach(async ({ suspendable }) => {\n      this.suspendable = suspendable;\n    });\n  }\n\n  /**\n   * Returns true if no run has been started yet and we're prepared for the next run.\n   */\n  get canExecute(): boolean {\n    if (this.taskRunProcessProvider.hasPersistentProcess) {\n      return true;\n    }\n\n    // If we've ever had a run ID, this execution can't be reused\n    if (this._runFriendlyId) {\n      return false;\n    }\n\n    // We can execute if we have the task run environment ready\n    return !!this.currentTaskRunEnv;\n  }\n\n  /**\n   * Called by the RunController when it receives a websocket notification\n   * or when the snapshot poller detects a change.\n   *\n   * This is the main entry point for snapshot changes, but processing is deferred to the snapshot manager.\n   */\n  private async enqueueSnapshotChangesAndWait(snapshots: RunExecutionData[]): Promise<void> {\n    if (this.isShuttingDown) {\n      this.sendDebugLog(\"enqueueSnapshotChangeAndWait: shutting down, skipping\");\n      return;\n    }\n\n    if (!this.snapshotManager) {\n      this.sendDebugLog(\"enqueueSnapshotChangeAndWait: missing snapshot manager\");\n      return;\n    }\n\n    await this.snapshotManager.handleSnapshotChanges(snapshots);\n  }\n\n  private async processSnapshotChange(\n    runData: RunExecutionData,\n    deprecated: boolean\n  ): Promise<void> {\n    const { run, snapshot, completedWaitpoints } = runData;\n\n    const snapshotMetadata = {\n      incomingSnapshotId: snapshot.friendlyId,\n      completedWaitpoints: completedWaitpoints.length,\n    };\n\n    if (this.ignoreSnapshotChanges) {\n      this.sendDebugLog(\"processSnapshotChange: ignoring snapshot change\", {\n        incomingSnapshotId: snapshot.friendlyId,\n        completedWaitpoints: completedWaitpoints.length,\n        currentAttemptNumber: this.currentAttemptNumber,\n        newAttemptNumber: run.attemptNumber,\n      });\n      return;\n    }\n\n    if (!this.snapshotManager) {\n      this.sendDebugLog(\"handleSnapshotChange: missing snapshot manager\", snapshotMetadata);\n      return;\n    }\n\n    if (this.currentAttemptNumber && this.currentAttemptNumber !== run.attemptNumber) {\n      this.sendDebugLog(\"error: attempt number mismatch\", snapshotMetadata);\n      // This is a rogue execution, a new one will already have been created elsewhere\n      await this.exitTaskRunProcessWithoutFailingRun({\n        flush: false,\n        reason: \"attempt number mismatch\",\n      });\n      return;\n    }\n\n    // DO NOT REMOVE (very noisy, but helpful for debugging)\n    // this.sendDebugLog(`processing snapshot change: ${snapshot.executionStatus}`, snapshotMetadata);\n\n    // Reset the snapshot poll interval so we don't do unnecessary work\n    this.snapshotPoller?.updateSnapshotId(snapshot.friendlyId);\n    this.snapshotPoller?.resetCurrentInterval();\n\n    if (deprecated) {\n      this.sendDebugLog(\"run execution is deprecated\", { incomingSnapshot: snapshot });\n\n      await this.exitTaskRunProcessWithoutFailingRun({\n        flush: false,\n        reason: \"deprecated execution\",\n      });\n      return;\n    }\n\n    switch (snapshot.executionStatus) {\n      case \"PENDING_CANCEL\": {\n        this.sendDebugLog(\"run was cancelled\", snapshotMetadata);\n\n        const [error] = await tryCatch(this.cancel());\n\n        if (error) {\n          this.sendDebugLog(\"snapshot change: failed to cancel attempt\", {\n            ...snapshotMetadata,\n            error: error.message,\n          });\n        }\n\n        this.abortExecution();\n        return;\n      }\n      case \"QUEUED\": {\n        this.sendDebugLog(\"run was re-queued\", snapshotMetadata);\n\n        await this.exitTaskRunProcessWithoutFailingRun({ flush: true, reason: \"re-queued\" });\n        return;\n      }\n      case \"FINISHED\": {\n        this.sendDebugLog(\"run is finished\", snapshotMetadata);\n\n        // We are finishing the run in handleCompletionResult, so we don't need to do anything here\n        if (this.isCompletingRun) {\n          this.sendDebugLog(\"run is finished but we're completing it, skipping\", snapshotMetadata);\n          return;\n        }\n\n        await this.exitTaskRunProcessWithoutFailingRun({ flush: true, reason: \"already-finished\" });\n        return;\n      }\n      case \"QUEUED_EXECUTING\":\n      case \"EXECUTING_WITH_WAITPOINTS\": {\n        this.sendDebugLog(\"run is executing with waitpoints\", snapshotMetadata);\n\n        // Wait for next status change - suspension is handled by the snapshot manager\n        return;\n      }\n      case \"SUSPENDED\": {\n        this.sendDebugLog(\"run was suspended\", snapshotMetadata);\n\n        // This will kill the process and fail the execution with a SuspendedProcessError\n        // We don't flush because we already did before suspending\n        await this.exitTaskRunProcessWithoutFailingRun({ flush: false, reason: \"suspended\" });\n        return;\n      }\n      case \"PENDING_EXECUTING\": {\n        this.sendDebugLog(\"run is pending execution\", snapshotMetadata);\n\n        if (completedWaitpoints.length === 0) {\n          this.sendDebugLog(\"no waitpoints to complete, nothing to do\", snapshotMetadata);\n          return;\n        }\n\n        const [error] = await tryCatch(this.restore());\n\n        if (error) {\n          this.sendDebugLog(\"failed to restore execution\", {\n            ...snapshotMetadata,\n            error: error.message,\n          });\n\n          this.abortExecution();\n          return;\n        }\n\n        return;\n      }\n      case \"EXECUTING\": {\n        if (completedWaitpoints.length === 0) {\n          this.sendDebugLog(\"run is executing without completed waitpoints\", snapshotMetadata);\n          return;\n        }\n\n        this.sendDebugLog(\"run is executing with completed waitpoints\", snapshotMetadata);\n\n        if (!this.taskRunProcess) {\n          this.sendDebugLog(\"no task run process, ignoring completed waitpoints\", snapshotMetadata);\n\n          this.abortExecution();\n          return;\n        }\n\n        for (const waitpoint of completedWaitpoints) {\n          this.taskRunProcess.waitpointCompleted(waitpoint);\n        }\n\n        return;\n      }\n      case \"RUN_CREATED\": {\n        this.sendDebugLog(\n          \"aborting execution: invalid status change: RUN_CREATED\",\n          snapshotMetadata\n        );\n\n        this.abortExecution();\n        return;\n      }\n      default: {\n        assertExhaustive(snapshot.executionStatus);\n      }\n    }\n  }\n\n  private async startAttempt({\n    isWarmStart,\n  }: {\n    isWarmStart?: boolean;\n  }): Promise<WorkloadRunAttemptStartResponseBody & { metrics: TaskRunExecutionMetrics }> {\n    if (!this.runFriendlyId || !this.snapshotManager) {\n      throw new Error(\"Cannot start attempt: missing run or snapshot manager\");\n    }\n\n    // Reset this for the new attempt\n    this.isCompletingRun = false;\n\n    this.sendDebugLog(\"starting attempt\", { isWarmStart: String(isWarmStart) });\n\n    const attemptStartedAt = Date.now();\n\n    // Check for abort before each major async operation\n    if (this.executionAbortController.signal.aborted) {\n      throw new ExecutionAbortError(\"Execution aborted before start\");\n    }\n\n    const start = await this.httpClient.startRunAttempt(\n      this.runFriendlyId,\n      this.snapshotManager.snapshotId,\n      { isWarmStart }\n    );\n\n    if (this.executionAbortController.signal.aborted) {\n      throw new ExecutionAbortError(\"Execution aborted after start\");\n    }\n\n    if (!start.success) {\n      throw new Error(`Start API call failed: ${start.error}`);\n    }\n\n    // A snapshot was just created, so update the snapshot ID\n    this.snapshotManager.updateSnapshot(\n      start.data.snapshot.friendlyId,\n      start.data.snapshot.executionStatus\n    );\n\n    // Also set or update the attempt number - we do this to detect illegal attempt number changes, e.g. from stalled runners coming back online\n    const attemptNumber = start.data.run.attemptNumber;\n    if (attemptNumber && attemptNumber > 0) {\n      this.currentAttemptNumber = attemptNumber;\n    } else {\n      this.sendDebugLog(\"error: invalid attempt number returned from start attempt\", {\n        attemptNumber: String(attemptNumber),\n      });\n    }",
            "output_extracted": "import {\n  type CompleteRunAttemptResult,\n  type RunExecutionData,\n  SuspendedProcessError,\n  type TaskRunExecutionMetrics,\n  type TaskRunExecutionResult,\n  TaskRunExecutionRetry,\n  TaskRunExecutionStatus,\n  type TaskRunFailedExecutionResult,\n  WorkerManifest,\n} from \"@trigger.dev/core/v3\";\nimport { type WorkloadRunAttemptStartResponseBody } from \"@trigger.dev/core/v3/workers\";\nimport { TaskRunProcess } from \"../../executions/taskRunProcess.js\";\nimport { RunLogger, SendDebugLogOptions } from \"./logger.js\";\nimport { RunnerEnv } from \"./env.js\";\nimport { WorkloadHttpClient } from \"@trigger.dev/core/v3/workers\";\nimport { setTimeout as sleep } from \"timers/promises\";\nimport { RunExecutionSnapshotPoller } from \"./poller.js\";\nimport { assertExhaustive, tryCatch } from \"@trigger.dev/core/utils\";\nimport { Metadata, MetadataClient } from \"./overrides.js\";\nimport { randomBytes } from \"node:crypto\";\nimport { SnapshotManager, SnapshotState } from \"./snapshot.js\";\nimport type { SupervisorSocket } from \"./controller.js\";\nimport { RunNotifier } from \"./notifier.js\";\nimport { TaskRunProcessProvider } from \"./taskRunProcessProvider.js\";\n\nclass ExecutionAbortError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ExecutionAbortError\";\n  }\n}\n\ntype RunExecutionOptions = {\n  workerManifest: WorkerManifest;\n  env: RunnerEnv;\n  httpClient: WorkloadHttpClient;\n  logger: RunLogger;\n  supervisorSocket: SupervisorSocket;\n  taskRunProcessProvider: TaskRunProcessProvider;\n};\n\ntype RunExecutionPrepareOptions = {\n  taskRunEnv: Record<string, string>;\n};\n\ntype RunExecutionRunOptions = {\n  runFriendlyId: string;\n  snapshotFriendlyId: string;\n  dequeuedAt?: Date;\n  podScheduledAt?: Date;\n  isWarmStart?: boolean;\n};\n\nexport class RunExecution {\n  private id: string;\n  private executionAbortController: AbortController;\n\n  private _runFriendlyId?: string;\n  private currentAttemptNumber?: number;\n  private currentTaskRunEnv?: Record<string, string>;\n  private snapshotManager?: SnapshotManager;\n\n  private dequeuedAt?: Date;\n  private podScheduledAt?: Date;\n  private readonly workerManifest: WorkerManifest;\n  private readonly env: RunnerEnv;\n  private readonly httpClient: WorkloadHttpClient;\n  private readonly logger: RunLogger;\n  private restoreCount: number;\n\n  private taskRunProcess?: TaskRunProcess;\n  private snapshotPoller?: RunExecutionSnapshotPoller;\n\n  private lastHeartbeat?: Date;\n  private isShuttingDown = false;\n  private shutdownReason?: string;\n\n  private isCompletingRun = false;\n  private ignoreSnapshotChanges = false;\n\n  private supervisorSocket: SupervisorSocket;\n  private notifier?: RunNotifier;\n  private metadataClient?: MetadataClient;\n  private taskRunProcessProvider: TaskRunProcessProvider;\n\n  constructor(opts: RunExecutionOptions) {\n    this.id = randomBytes(4).toString(\"hex\");\n    this.workerManifest = opts.workerManifest;\n    this.env = opts.env;\n    this.httpClient = opts.httpClient;\n    this.logger = opts.logger;\n    this.supervisorSocket = opts.supervisorSocket;\n    this.taskRunProcessProvider = opts.taskRunProcessProvider;\n\n    this.restoreCount = 0;\n    this.executionAbortController = new AbortController();\n\n    if (this.env.TRIGGER_METADATA_URL) {\n      this.metadataClient = new MetadataClient(this.env.TRIGGER_METADATA_URL);\n    }\n  }\n\n  /**\n   * Cancels the current execution.\n   */\n  public async cancel(): Promise<void> {\n    if (this.isShuttingDown) {\n      throw new Error(\"cancel called after execution shut down\");\n    }\n\n    this.sendDebugLog(\"cancelling attempt\", { runId: this.runFriendlyId });\n\n    await this.taskRunProcess?.cancel();\n  }\n\n  /**\n   * Kills the current execution.\n   */\n  public async kill({ exitExecution = true }: { exitExecution?: boolean } = {}) {\n    if (this.taskRunProcess) {\n      await this.taskRunProcessProvider.handleProcessAbort(this.taskRunProcess);\n    }\n\n    if (exitExecution) {\n      this.shutdownExecution(\"kill\");\n    }\n  }\n\n  public async shutdown() {\n    if (this.taskRunProcess) {\n      await this.taskRunProcessProvider.handleProcessAbort(this.taskRunProcess);\n    }\n\n    this.shutdownExecution(\"shutdown\");\n  }\n\n  /**\n   * Prepares the execution with task run environment variables.\n   * This should be called before executing, typically after a successful run to prepare for the next one.\n   */\n  public async prepareForExecution(opts: RunExecutionPrepareOptions) {\n    if (this.isShuttingDown) {\n      throw new Error(\"prepareForExecution called after execution shut down\");\n    }\n\n    if (this.taskRunProcess) {\n      throw new Error(\"prepareForExecution called after process was already created\");\n    }\n\n    // Set the task run environment so canExecute returns true\n    this.currentTaskRunEnv = opts.taskRunEnv;\n\n    this.taskRunProcess = await this.taskRunProcessProvider.getProcess({\n      taskRunEnv: opts.taskRunEnv,\n      isWarmStart: true,\n    });\n  }\n\n  private attachTaskRunProcessHandlers(taskRunProcess: TaskRunProcess): void {\n    taskRunProcess.unsafeDetachEvtHandlers();\n\n    taskRunProcess.onTaskRunHeartbeat.attach(async (runId) => {\n      if (!this.runFriendlyId) {\n        this.sendDebugLog(\"onTaskRunHeartbeat: missing run ID\", { heartbeatRunId: runId });\n        return;\n      }\n\n      if (runId !== this.runFriendlyId) {\n        this.sendDebugLog(\"onTaskRunHeartbeat: mismatched run ID\", {\n          heartbeatRunId: runId,\n          expectedRunId: this.runFriendlyId,\n        });\n        return;\n      }\n\n      const [error] = await tryCatch(this.onHeartbeat());\n\n      if (error) {\n        this.sendDebugLog(\"onTaskRunHeartbeat: failed\", { error: error.message });\n      }\n    });\n\n    taskRunProcess.onSendDebugLog.attach(async (debugLog) => {\n      this.sendRuntimeDebugLog(debugLog.message, debugLog.properties);\n    });\n\n    taskRunProcess.onSetSuspendable.attach(async ({ suspendable }) => {\n      this.suspendable = suspendable;\n    });\n  }\n\n  /**\n   * Returns true if no run has been started yet and we're prepared for the next run.\n   */\n  get canExecute(): boolean {\n    if (this.taskRunProcessProvider.hasPersistentProcess) {\n      return true;\n    }\n\n    // If we've ever had a run ID, this execution can't be reused\n    if (this._runFriendlyId) {\n      return false;\n    }\n\n    // We can execute if we have the task run environment ready\n    return !!this.currentTaskRunEnv;\n  }\n\n  /**\n   * Called by the RunController when it receives a websocket notification\n   * or when the snapshot poller detects a change.\n   *\n   * This is the main entry point for snapshot changes, but processing is deferred to the snapshot manager.\n   */\n  private async enqueueSnapshotChangesAndWait(snapshots: RunExecutionData[]): Promise<void> {\n    if (this.isShuttingDown) {\n      this.sendDebugLog(\"enqueueSnapshotChangeAndWait: shutting down, skipping\");\n      return;\n    }\n\n    if (!this.snapshotManager) {\n      this.sendDebugLog(\"enqueueSnapshotChangeAndWait: missing snapshot manager\");\n      return;\n    }\n\n    await this.snapshotManager.handleSnapshotChanges(snapshots);\n  }\n\n  private async processSnapshotChange(\n    runData: RunExecutionData,\n    deprecated: boolean\n  ): Promise<void> {\n    const { run, snapshot, completedWaitpoints } = runData;\n\n    const snapshotMetadata = {\n      incomingSnapshotId: snapshot.friendlyId,\n      completedWaitpoints: completedWaitpoints.length,\n    };\n\n    if (this.ignoreSnapshotChanges) {\n      this.sendDebugLog(\"processSnapshotChange: ignoring snapshot change\", {\n        incomingSnapshotId: snapshot.friendlyId,\n        completedWaitpoints: completedWaitpoints.length,\n        currentAttemptNumber: this.currentAttemptNumber,\n        newAttemptNumber: run.attemptNumber,\n      });\n      return;\n    }\n\n    if (!this.snapshotManager) {\n      this.sendDebugLog(\"handleSnapshotChange: missing snapshot manager\", snapshotMetadata);\n      return;\n    }\n\n    if (this.currentAttemptNumber && this.currentAttemptNumber !== run.attemptNumber) {\n      this.sendDebugLog(\"error: attempt number mismatch\", snapshotMetadata);\n      // This is a rogue execution, a new one will already have been created elsewhere\n      await this.exitTaskRunProcessWithoutFailingRun({\n        flush: false,\n        reason: \"attempt number mismatch\",\n      });\n      return;\n    }\n\n    // DO NOT REMOVE (very noisy, but helpful for debugging)\n    // this.sendDebugLog(`processing snapshot change: ${snapshot.executionStatus}`, snapshotMetadata);\n\n    // Reset the snapshot poll interval so we don't do unnecessary work\n    this.snapshotPoller?.updateSnapshotId(snapshot.friendlyId);\n    this.snapshotPoller?.resetCurrentInterval();\n\n    if (deprecated) {\n      this.sendDebugLog(\"run execution is deprecated\", { incomingSnapshot: snapshot });\n\n      await this.exitTaskRunProcessWithoutFailingRun({\n        flush: false,\n        reason: \"deprecated execution\",\n      });\n      return;\n    }\n\n    switch (snapshot.executionStatus) {\n      case \"PENDING_CANCEL\": {\n        this.sendDebugLog(\"run was cancelled\", snapshotMetadata);\n\n        const [error] = await tryCatch(this.cancel());\n\n        if (error) {\n          this.sendDebugLog(\"snapshot change: failed to cancel attempt\", {\n            ...snapshotMetadata,\n            error: error.message,\n          });\n        }\n\n        this.abortExecution();\n        return;\n      }\n      case \"QUEUED\": {\n        this.sendDebugLog(\"run was re-queued\", snapshotMetadata);\n\n        await this.exitTaskRunProcessWithoutFailingRun({ flush: true, reason: \"re-queued\" });\n        return;\n      }\n      case \"FINISHED\": {\n        this.sendDebugLog(\"run is finished\", snapshotMetadata);\n\n        // We are finishing the run in handleCompletionResult, so we don't need to do anything here\n        if (this.isCompletingRun) {\n          this.sendDebugLog(\"run is finished but we're completing it, skipping\", snapshotMetadata);\n          return;\n        }\n\n        await this.exitTaskRunProcessWithoutFailingRun({ flush: true, reason: \"already-finished\" });\n        return;\n      }\n      case \"QUEUED_EXECUTING\":\n      case \"EXECUTING_WITH_WAITPOINTS\": {\n        this.sendDebugLog(\"run is executing with waitpoints\", snapshotMetadata);\n\n        // Wait for next status change - suspension is handled by the snapshot manager\n        return;\n      }\n      case \"SUSPENDED\": {\n        this.sendDebugLog(\"run was suspended\", snapshotMetadata);\n\n        // This will kill the process and fail the execution with a SuspendedProcessError\n        // We don't flush because we already did before suspending\n        await this.exitTaskRunProcessWithoutFailingRun({ flush: false, reason: \"suspended\" });\n        return;\n      }\n      case \"PENDING_EXECUTING\": {\n        this.sendDebugLog(\"run is pending execution\", snapshotMetadata);\n\n        if (completedWaitpoints.length === 0) {\n          this.sendDebugLog(\"no waitpoints to complete, nothing to do\", snapshotMetadata);\n          return;\n        }\n\n        const [error] = await tryCatch(this.restore());\n\n        if (error) {\n          this.sendDebugLog(\"failed to restore execution\", {\n            ...snapshotMetadata,\n            error: error.message,\n          });\n\n          this.abortExecution();\n          return;\n        }\n\n        return;\n      }\n      case \"EXECUTING\": {\n        if (completedWaitpoints.length === 0) {\n          this.sendDebugLog(\"run is executing without completed waitpoints\", snapshotMetadata);\n          return;\n        }\n\n        this.sendDebugLog(\"run is executing with completed waitpoints\", snapshotMetadata);\n\n        if (!this.taskRunProcess) {\n          this.sendDebugLog(\"no task run process, ignoring completed waitpoints\", snapshotMetadata);\n\n          this.abortExecution();\n          return;\n        }\n\n        for (const waitpoint of completedWaitpoints) {\n          this.taskRunProcess.waitpointCompleted(waitpoint);\n        }\n\n        return;\n      }\n      case \"RUN_CREATED\": {\n        this.sendDebugLog(\n          \"aborting execution: invalid status change: RUN_CREATED\",\n          snapshotMetadata\n        );\n\n        this.abortExecution();\n        return;\n      }\n      default: {\n        assertExhaustive(snapshot.executionStatus);\n      }\n    }\n  }\n\n  private async startAttempt({\n    isWarmStart,\n  }: {\n    isWarmStart?: boolean;\n  }): Promise<WorkloadRunAttemptStartResponseBody & { metrics: TaskRunExecutionMetrics }> {\n    if (!this.runFriendlyId || !this.snapshotManager) {\n      throw new Error(\"Cannot start attempt: missing run or snapshot manager\");\n    }\n\n    // Reset this for the new attempt\n    this.isCompletingRun = false;\n\n    this.sendDebugLog(\"starting attempt\", { isWarmStart: String(isWarmStart) });\n\n    const attemptStartedAt = Date.now();\n\n    // Check for abort before each major async operation\n    if (this.executionAbortController.signal.aborted) {\n      throw new ExecutionAbortError(\"Execution aborted before start\");\n    }\n\n    const start = await this.httpClient.startRunAttempt(\n      this.runFriendlyId,\n      this.snapshotManager.snapshotId,\n      { isWarmStart }\n    );\n\n    if (this.executionAbortController.signal.aborted) {\n      throw new ExecutionAbortError(\"Execution aborted after start\");\n    }\n\n    if (!start.success) {\n      throw new Error(`Start API call failed: ${start.error}`);\n    }\n\n    // A snapshot was just created, so update the snapshot ID\n    this.snapshotManager.updateSnapshot(\n      start.data.snapshot.friendlyId,\n      start.data.snapshot.executionStatus\n    );\n\n    // Also set or update the attempt number - we do this to detect illegal attempt number changes, e.g. from stalled runners coming back online\n    const attemptNumber = start.data.run.attemptNumber;\n    if (attemptNumber && attemptNumber > 0) {\n      this.currentAttemptNumber = attemptNumber;\n    } else {\n      this.sendDebugLog(\"error: invalid attempt number returned from start attempt\", {\n        attemptNumber: String(attemptNumber),\n      });\n    }",
            "cost": 0.16808
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/packages/cli-v3/src/entryPoints/managed/snapshot.test.ts": {
            "output": "import { SnapshotManager } from \"./snapshot.js\";\nimport { ConsoleRunLogger } from \"./logger.js\";\nimport { RunExecutionData, TaskRunExecutionStatus } from \"@trigger.dev/core/v3\";\nimport { setTimeout } from \"timers/promises\";\nimport { isCI } from \"std-env\";\n\ndescribe(\"SnapshotManager\", () => {\n  const mockLogger = new ConsoleRunLogger({ print: !isCI });\n  const mockSnapshotHandler = vi.fn();\n  const mockSuspendableHandler = vi.fn();\n\n  let manager: SnapshotManager;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: mockSnapshotHandler,\n      onSuspendable: mockSuspendableHandler,\n    });\n  });\n\n  it(\"should initialize with correct initial values\", () => {\n    expect(manager.snapshotId).toBe(\"snapshot-1\");\n    expect(manager.status).toBe(\"PENDING_EXECUTING\");\n    expect(manager.suspendable).toBe(false);\n  });\n\n  it(\"should update snapshot when newer snapshot ID is provided\", () => {\n    manager.updateSnapshot(\"snapshot-2\", \"EXECUTING\");\n    expect(manager.snapshotId).toBe(\"snapshot-2\");\n    expect(manager.status).toBe(\"EXECUTING\");\n  });\n\n  it(\"should not update snapshot when older snapshot ID is provided\", () => {\n    manager.updateSnapshot(\"snapshot-2\", \"EXECUTING\");\n    manager.updateSnapshot(\"snapshot-1\", \"FINISHED\");\n    expect(manager.snapshotId).toBe(\"snapshot-2\");\n    expect(manager.status).toBe(\"EXECUTING\");\n  });\n\n  it(\"should handle suspendable state changes\", async () => {\n    await manager.setSuspendable(true);\n    expect(manager.suspendable).toBe(true);\n    expect(mockSuspendableHandler).not.toHaveBeenCalled();\n\n    // When status changes to EXECUTING_WITH_WAITPOINTS, suspendable handler should be called\n    await manager.handleSnapshotChanges([\n      createRunExecutionData({\n        snapshotId: \"snapshot-2\",\n        executionStatus: \"EXECUTING_WITH_WAITPOINTS\",\n      }),\n    ]);\n\n    expect(mockSuspendableHandler).toHaveBeenCalledWith({\n      id: \"snapshot-2\",\n      status: \"EXECUTING_WITH_WAITPOINTS\",\n    });\n\n    // Reset mocks\n    vi.clearAllMocks();\n\n    // Test this the other way around\n    await manager.setSuspendable(false);\n    expect(manager.suspendable).toBe(false);\n    expect(mockSuspendableHandler).not.toHaveBeenCalled();\n\n    // We should still be EXECUTING_WITH_WAITPOINTS\n    expect(manager.status).toBe(\"EXECUTING_WITH_WAITPOINTS\");\n\n    // When we're suspendable again, the handler should be called\n    await manager.setSuspendable(true);\n    expect(manager.suspendable).toBe(true);\n    expect(mockSuspendableHandler).toHaveBeenCalledWith({\n      id: \"snapshot-2\",\n      status: \"EXECUTING_WITH_WAITPOINTS\",\n    });\n\n    // Reset mocks\n    vi.clearAllMocks();\n\n    // Check simple toggle\n    await manager.setSuspendable(false);\n    expect(manager.suspendable).toBe(false);\n    await manager.setSuspendable(true);\n    expect(manager.suspendable).toBe(true);\n    expect(mockSuspendableHandler).toHaveBeenCalledWith({\n      id: \"snapshot-2\",\n      status: \"EXECUTING_WITH_WAITPOINTS\",\n    });\n\n    // Reset mocks\n    vi.clearAllMocks();\n\n    // Transitioning to QUEUED_EXECUTING should call the handler again\n    await manager.handleSnapshotChanges([\n      createRunExecutionData({\n        snapshotId: \"snapshot-3\",\n        executionStatus: \"QUEUED_EXECUTING\",\n      }),\n    ]);\n    expect(mockSuspendableHandler).toHaveBeenCalledWith({\n      id: \"snapshot-3\",\n      status: \"QUEUED_EXECUTING\",\n    });\n  });\n\n  it(\"should process queue in correct order with suspendable changes at the back\", async () => {\n    const executionOrder: string[] = [];\n\n    // Create a manager with handlers that track execution order\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        executionOrder.push(`snapshot:${data.snapshot.friendlyId}`);\n        await setTimeout(10); // Small delay\n      },\n      onSuspendable: async (state) => {\n        executionOrder.push(`suspendable:${state.id}`);\n        await setTimeout(10); // Small delay\n      },\n    });\n\n    const promises = [\n      manager.setSuspendable(false),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.setSuspendable(true),\n      manager.handleSnapshotChanges([\n        createRunExecutionData({\n          snapshotId: \"snapshot-3\",\n          executionStatus: \"EXECUTING_WITH_WAITPOINTS\",\n        }),\n      ]),\n    ];\n\n    await Promise.all(promises);\n\n    // Verify execution order:\n    // 1. Snapshots should be processed in order (2 then 3)\n    // 2. Suspendable changes should be at the end\n    expect(executionOrder).toEqual([\n      \"snapshot:snapshot-2\",\n      \"snapshot:snapshot-3\",\n      \"suspendable:snapshot-3\",\n    ]);\n  });\n\n  it(\"should skip older snapshots\", async () => {\n    const executionOrder: string[] = [];\n\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        executionOrder.push(`snapshot:${data.snapshot.friendlyId}`);\n      },\n      onSuspendable: async () => {},\n    });\n\n    // Queue snapshots in reverse order\n    const promises = [\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-3\" })]),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-1\" })]),\n    ];\n\n    await Promise.all(promises);\n\n    // Should be processed in ID order\n    expect(executionOrder).toEqual([\"snapshot:snapshot-3\"]);\n  });\n\n  it(\"should skip duplicate snapshots\", async () => {\n    const executionOrder: string[] = [];\n\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        executionOrder.push(`snapshot:${data.snapshot.friendlyId}`);\n      },\n      onSuspendable: async () => {},\n    });\n\n    // Queue snapshots in reverse order\n    const promises = [\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n    ];\n\n    await Promise.all(promises);\n\n    // Should be processed in ID order\n    expect(executionOrder).toEqual([\"snapshot:snapshot-2\"]);\n  });\n\n  it(\"should prevent concurrent handler execution\", async () => {\n    const executionTimes: { start: number; end: number; type: string }[] = [];\n    let currentlyExecuting = false;\n\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        if (currentlyExecuting) {\n          throw new Error(\"Handler executed while another handler was running\");\n        }\n        currentlyExecuting = true;\n        const start = Date.now();\n        await setTimeout(20); // Deliberate delay to increase chance of catching concurrent execution\n        const end = Date.now();\n        executionTimes.push({ start, end, type: `snapshot:${data.snapshot.friendlyId}` });\n        currentlyExecuting = false;\n      },\n      onSuspendable: async (state) => {\n        if (currentlyExecuting) {\n          throw new Error(\"Handler executed while another handler was running\");\n        }\n        currentlyExecuting = true;\n        const start = Date.now();\n        await setTimeout(20); // Deliberate delay\n        const end = Date.now();\n        executionTimes.push({ start, end, type: `suspendable:${state.id}` });\n        currentlyExecuting = false;\n      },\n    });\n\n    // Create a mix of rapid changes\n    const promises = [\n      manager.setSuspendable(true),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.setSuspendable(false),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-3\" })]),\n      manager.setSuspendable(true),\n      manager.setSuspendable(true),\n      manager.setSuspendable(false),\n      manager.setSuspendable(false),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-4\" })]),\n      manager.setSuspendable(false),\n      manager.setSuspendable(true),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-1\" })]),\n      manager.setSuspendable(false),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-3\" })]),\n      manager.setSuspendable(true),\n      manager.setSuspendable(true),\n      manager.setSuspendable(false),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.setSuspendable(false),\n    ];\n\n    await Promise.all(promises);\n\n    // Verify no overlapping execution times\n    for (let i = 1; i < executionTimes.length; i++) {\n      const previous = executionTimes[i - 1]!;\n      const current = executionTimes[i]!;\n      expect(current.start).toBeGreaterThanOrEqual(previous.end);\n    }\n  });\n\n  it(\"should handle cleanup and error scenarios\", async () => {\n    const executionOrder: string[] = [];\n    let shouldThrowSnapshotError = false;\n    let shouldThrowSuspendableError = false;\n\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        if (shouldThrowSnapshotError) {\n          throw new Error(\"Snapshot handler error\");\n        }\n        executionOrder.push(`snapshot:${data.snapshot.friendlyId}`);\n        await setTimeout(10);\n      },\n      onSuspendable: async (state) => {\n        if (shouldThrowSuspendableError) {\n          throw new Error(\"Suspendable handler error\");\n        }\n        executionOrder.push(`suspendable:${state.id}`);\n        await setTimeout(10);\n      },\n    });\n\n    // Queue up some changes\n    const initialPromises = [\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.setSuspendable(true),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-3\" })]),\n    ];\n\n    expect(manager.queueLength).not.toBe(0);\n\n    // Dispose manager before any promises complete\n    manager.stop();\n\n    expect(manager.queueLength).toBe(0);\n\n    // These should complete without executing handlers\n    const results = await Promise.allSettled(initialPromises);\n\n    // Only the first snapshot should have been processed\n    expect(executionOrder).toEqual([\"snapshot:snapshot-2\"]);\n\n    // The last two promises should have been rejected\n    expect(results).toMatchObject([\n      { status: \"fulfilled\" },\n      { status: \"rejected\" },\n      { status: \"rejected\" },\n    ]);\n\n    // Now test error handling\n    shouldThrowSnapshotError = true;\n    await expect(\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-4\" })])\n    ).rejects.toThrow(\"Snapshot handler error\");\n\n    // Queue should continue processing after error\n    shouldThrowSnapshotError = false;\n    await manager.handleSnapshotChanges([\n      createRunExecutionData({\n        snapshotId: \"snapshot-5\",\n        executionStatus: \"EXECUTING_WITH_WAITPOINTS\",\n      }),\n    ]);\n    expect(executionOrder).toEqual([\"snapshot:snapshot-2\", \"snapshot:snapshot-5\"]);\n\n    // Test suspendable error\n    shouldThrowSuspendableError = true;\n    await expect(manager.setSuspendable(true)).rejects.toThrow(\"Suspendable handler error\");\n\n    // Queue should continue processing after suspendable error\n    shouldThrowSuspendableError = false;\n\n    // Toggle suspendable state to trigger handler\n    await manager.setSuspendable(false);\n    await manager.setSuspendable(true);\n\n    expect(executionOrder).toEqual([\n      \"snapshot:snapshot-2\",\n      \"snapshot:snapshot-5\",\n      \"suspendable:snapshot-5\",\n    ]);\n  });\n\n  it(\"should handle edge cases and high concurrency\", async () => {\n    const executionOrder: string[] = [];\n    const executionTimes: { start: number; end: number; type: string }[] = [];\n    let currentlyExecuting = false;\n    let handlerExecutionCount = 0;\n\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        if (currentlyExecuting) {\n          throw new Error(\"Handler executed while another handler was running\");\n        }\n        currentlyExecuting = true;\n        handlerExecutionCount++;\n\n        const start = Date.now();\n        executionOrder.push(`snapshot:${data.snapshot.friendlyId}`);\n        await setTimeout(Math.random() * 20); // Random delay to increase race condition chances\n        const end = Date.now();\n\n        executionTimes.push({ start, end, type: `snapshot:${data.snapshot.friendlyId}` });\n        currentlyExecuting = false;\n      },\n      on",
            "output_extracted": "import { SnapshotManager } from \"./snapshot.js\";\nimport { ConsoleRunLogger } from \"./logger.js\";\nimport { RunExecutionData, TaskRunExecutionStatus } from \"@trigger.dev/core/v3\";\nimport { setTimeout } from \"timers/promises\";\nimport { isCI } from \"std-env\";\n\ndescribe(\"SnapshotManager\", () => {\n  const mockLogger = new ConsoleRunLogger({ print: !isCI });\n  const mockSnapshotHandler = vi.fn();\n  const mockSuspendableHandler = vi.fn();\n\n  let manager: SnapshotManager;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: mockSnapshotHandler,\n      onSuspendable: mockSuspendableHandler,\n    });\n  });\n\n  it(\"should initialize with correct initial values\", () => {\n    expect(manager.snapshotId).toBe(\"snapshot-1\");\n    expect(manager.status).toBe(\"PENDING_EXECUTING\");\n    expect(manager.suspendable).toBe(false);\n  });\n\n  it(\"should update snapshot when newer snapshot ID is provided\", () => {\n    manager.updateSnapshot(\"snapshot-2\", \"EXECUTING\");\n    expect(manager.snapshotId).toBe(\"snapshot-2\");\n    expect(manager.status).toBe(\"EXECUTING\");\n  });\n\n  it(\"should not update snapshot when older snapshot ID is provided\", () => {\n    manager.updateSnapshot(\"snapshot-2\", \"EXECUTING\");\n    manager.updateSnapshot(\"snapshot-1\", \"FINISHED\");\n    expect(manager.snapshotId).toBe(\"snapshot-2\");\n    expect(manager.status).toBe(\"EXECUTING\");\n  });\n\n  it(\"should handle suspendable state changes\", async () => {\n    await manager.setSuspendable(true);\n    expect(manager.suspendable).toBe(true);\n    expect(mockSuspendableHandler).not.toHaveBeenCalled();\n\n    // When status changes to EXECUTING_WITH_WAITPOINTS, suspendable handler should be called\n    await manager.handleSnapshotChanges([\n      createRunExecutionData({\n        snapshotId: \"snapshot-2\",\n        executionStatus: \"EXECUTING_WITH_WAITPOINTS\",\n      }),\n    ]);\n\n    expect(mockSuspendableHandler).toHaveBeenCalledWith({\n      id: \"snapshot-2\",\n      status: \"EXECUTING_WITH_WAITPOINTS\",\n    });\n\n    // Reset mocks\n    vi.clearAllMocks();\n\n    // Test this the other way around\n    await manager.setSuspendable(false);\n    expect(manager.suspendable).toBe(false);\n    expect(mockSuspendableHandler).not.toHaveBeenCalled();\n\n    // We should still be EXECUTING_WITH_WAITPOINTS\n    expect(manager.status).toBe(\"EXECUTING_WITH_WAITPOINTS\");\n\n    // When we're suspendable again, the handler should be called\n    await manager.setSuspendable(true);\n    expect(manager.suspendable).toBe(true);\n    expect(mockSuspendableHandler).toHaveBeenCalledWith({\n      id: \"snapshot-2\",\n      status: \"EXECUTING_WITH_WAITPOINTS\",\n    });\n\n    // Reset mocks\n    vi.clearAllMocks();\n\n    // Check simple toggle\n    await manager.setSuspendable(false);\n    expect(manager.suspendable).toBe(false);\n    await manager.setSuspendable(true);\n    expect(manager.suspendable).toBe(true);\n    expect(mockSuspendableHandler).toHaveBeenCalledWith({\n      id: \"snapshot-2\",\n      status: \"EXECUTING_WITH_WAITPOINTS\",\n    });\n\n    // Reset mocks\n    vi.clearAllMocks();\n\n    // Transitioning to QUEUED_EXECUTING should call the handler again\n    await manager.handleSnapshotChanges([\n      createRunExecutionData({\n        snapshotId: \"snapshot-3\",\n        executionStatus: \"QUEUED_EXECUTING\",\n      }),\n    ]);\n    expect(mockSuspendableHandler).toHaveBeenCalledWith({\n      id: \"snapshot-3\",\n      status: \"QUEUED_EXECUTING\",\n    });\n  });\n\n  it(\"should process queue in correct order with suspendable changes at the back\", async () => {\n    const executionOrder: string[] = [];\n\n    // Create a manager with handlers that track execution order\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        executionOrder.push(`snapshot:${data.snapshot.friendlyId}`);\n        await setTimeout(10); // Small delay\n      },\n      onSuspendable: async (state) => {\n        executionOrder.push(`suspendable:${state.id}`);\n        await setTimeout(10); // Small delay\n      },\n    });\n\n    const promises = [\n      manager.setSuspendable(false),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.setSuspendable(true),\n      manager.handleSnapshotChanges([\n        createRunExecutionData({\n          snapshotId: \"snapshot-3\",\n          executionStatus: \"EXECUTING_WITH_WAITPOINTS\",\n        }),\n      ]),\n    ];\n\n    await Promise.all(promises);\n\n    // Verify execution order:\n    // 1. Snapshots should be processed in order (2 then 3)\n    // 2. Suspendable changes should be at the end\n    expect(executionOrder).toEqual([\n      \"snapshot:snapshot-2\",\n      \"snapshot:snapshot-3\",\n      \"suspendable:snapshot-3\",\n    ]);\n  });\n\n  it(\"should skip older snapshots\", async () => {\n    const executionOrder: string[] = [];\n\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        executionOrder.push(`snapshot:${data.snapshot.friendlyId}`);\n      },\n      onSuspendable: async () => {},\n    });\n\n    // Queue snapshots in reverse order\n    const promises = [\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-3\" })]),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-1\" })]),\n    ];\n\n    await Promise.all(promises);\n\n    // Should be processed in ID order\n    expect(executionOrder).toEqual([\"snapshot:snapshot-3\"]);\n  });\n\n  it(\"should skip duplicate snapshots\", async () => {\n    const executionOrder: string[] = [];\n\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        executionOrder.push(`snapshot:${data.snapshot.friendlyId}`);\n      },\n      onSuspendable: async () => {},\n    });\n\n    // Queue snapshots in reverse order\n    const promises = [\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n    ];\n\n    await Promise.all(promises);\n\n    // Should be processed in ID order\n    expect(executionOrder).toEqual([\"snapshot:snapshot-2\"]);\n  });\n\n  it(\"should prevent concurrent handler execution\", async () => {\n    const executionTimes: { start: number; end: number; type: string }[] = [];\n    let currentlyExecuting = false;\n\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        if (currentlyExecuting) {\n          throw new Error(\"Handler executed while another handler was running\");\n        }\n        currentlyExecuting = true;\n        const start = Date.now();\n        await setTimeout(20); // Deliberate delay to increase chance of catching concurrent execution\n        const end = Date.now();\n        executionTimes.push({ start, end, type: `snapshot:${data.snapshot.friendlyId}` });\n        currentlyExecuting = false;\n      },\n      onSuspendable: async (state) => {\n        if (currentlyExecuting) {\n          throw new Error(\"Handler executed while another handler was running\");\n        }\n        currentlyExecuting = true;\n        const start = Date.now();\n        await setTimeout(20); // Deliberate delay\n        const end = Date.now();\n        executionTimes.push({ start, end, type: `suspendable:${state.id}` });\n        currentlyExecuting = false;\n      },\n    });\n\n    // Create a mix of rapid changes\n    const promises = [\n      manager.setSuspendable(true),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.setSuspendable(false),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-3\" })]),\n      manager.setSuspendable(true),\n      manager.setSuspendable(true),\n      manager.setSuspendable(false),\n      manager.setSuspendable(false),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-4\" })]),\n      manager.setSuspendable(false),\n      manager.setSuspendable(true),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-1\" })]),\n      manager.setSuspendable(false),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-3\" })]),\n      manager.setSuspendable(true),\n      manager.setSuspendable(true),\n      manager.setSuspendable(false),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.setSuspendable(false),\n    ];\n\n    await Promise.all(promises);\n\n    // Verify no overlapping execution times\n    for (let i = 1; i < executionTimes.length; i++) {\n      const previous = executionTimes[i - 1]!;\n      const current = executionTimes[i]!;\n      expect(current.start).toBeGreaterThanOrEqual(previous.end);\n    }\n  });\n\n  it(\"should handle cleanup and error scenarios\", async () => {\n    const executionOrder: string[] = [];\n    let shouldThrowSnapshotError = false;\n    let shouldThrowSuspendableError = false;\n\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        if (shouldThrowSnapshotError) {\n          throw new Error(\"Snapshot handler error\");\n        }\n        executionOrder.push(`snapshot:${data.snapshot.friendlyId}`);\n        await setTimeout(10);\n      },\n      onSuspendable: async (state) => {\n        if (shouldThrowSuspendableError) {\n          throw new Error(\"Suspendable handler error\");\n        }\n        executionOrder.push(`suspendable:${state.id}`);\n        await setTimeout(10);\n      },\n    });\n\n    // Queue up some changes\n    const initialPromises = [\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-2\" })]),\n      manager.setSuspendable(true),\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-3\" })]),\n    ];\n\n    expect(manager.queueLength).not.toBe(0);\n\n    // Dispose manager before any promises complete\n    manager.stop();\n\n    expect(manager.queueLength).toBe(0);\n\n    // These should complete without executing handlers\n    const results = await Promise.allSettled(initialPromises);\n\n    // Only the first snapshot should have been processed\n    expect(executionOrder).toEqual([\"snapshot:snapshot-2\"]);\n\n    // The last two promises should have been rejected\n    expect(results).toMatchObject([\n      { status: \"fulfilled\" },\n      { status: \"rejected\" },\n      { status: \"rejected\" },\n    ]);\n\n    // Now test error handling\n    shouldThrowSnapshotError = true;\n    await expect(\n      manager.handleSnapshotChanges([createRunExecutionData({ snapshotId: \"snapshot-4\" })])\n    ).rejects.toThrow(\"Snapshot handler error\");\n\n    // Queue should continue processing after error\n    shouldThrowSnapshotError = false;\n    await manager.handleSnapshotChanges([\n      createRunExecutionData({\n        snapshotId: \"snapshot-5\",\n        executionStatus: \"EXECUTING_WITH_WAITPOINTS\",\n      }),\n    ]);\n    expect(executionOrder).toEqual([\"snapshot:snapshot-2\", \"snapshot:snapshot-5\"]);\n\n    // Test suspendable error\n    shouldThrowSuspendableError = true;\n    await expect(manager.setSuspendable(true)).rejects.toThrow(\"Suspendable handler error\");\n\n    // Queue should continue processing after suspendable error\n    shouldThrowSuspendableError = false;\n\n    // Toggle suspendable state to trigger handler\n    await manager.setSuspendable(false);\n    await manager.setSuspendable(true);\n\n    expect(executionOrder).toEqual([\n      \"snapshot:snapshot-2\",\n      \"snapshot:snapshot-5\",\n      \"suspendable:snapshot-5\",\n    ]);\n  });\n\n  it(\"should handle edge cases and high concurrency\", async () => {\n    const executionOrder: string[] = [];\n    const executionTimes: { start: number; end: number; type: string }[] = [];\n    let currentlyExecuting = false;\n    let handlerExecutionCount = 0;\n\n    const manager = new SnapshotManager({\n      runnerId: \"test-runner-1\",\n      runFriendlyId: \"test-run-1\",\n      initialSnapshotId: \"snapshot-1\",\n      initialStatus: \"PENDING_EXECUTING\",\n      logger: mockLogger,\n      onSnapshotChange: async (data) => {\n        if (currentlyExecuting) {\n          throw new Error(\"Handler executed while another handler was running\");\n        }\n        currentlyExecuting = true;\n        handlerExecutionCount++;\n\n        const start = Date.now();\n        executionOrder.push(`snapshot:${data.snapshot.friendlyId}`);\n        await setTimeout(Math.random() * 20); // Random delay to increase race condition chances\n        const end = Date.now();\n\n        executionTimes.push({ start, end, type: `snapshot:${data.snapshot.friendlyId}` });\n        currentlyExecuting = false;\n      },\n      on",
            "cost": 0.15239000000000003
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/packages/cli-v3/src/entryPoints/managed/snapshot.ts": {
            "output": "import { tryCatch } from \"@trigger.dev/core/utils\";\nimport { RunLogger, SendDebugLogOptions } from \"./logger.js\";\nimport { TaskRunExecutionStatus, type RunExecutionData } from \"@trigger.dev/core/v3\";\nimport { assertExhaustive } from \"@trigger.dev/core/utils\";\nimport { MetadataClient } from \"./overrides.js\";\n\nexport type SnapshotState = {\n  id: string;\n  status: TaskRunExecutionStatus;\n};\n\ntype SnapshotHandler = (runData: RunExecutionData, deprecated: boolean) => Promise<void>;\ntype SuspendableHandler = (suspendableSnapshot: SnapshotState) => Promise<void>;\n\ntype SnapshotManagerOptions = {\n  runFriendlyId: string;\n  runnerId: string;\n  initialSnapshotId: string;\n  initialStatus: TaskRunExecutionStatus;\n  logger: RunLogger;\n  metadataClient?: MetadataClient;\n  onSnapshotChange: SnapshotHandler;\n  onSuspendable: SuspendableHandler;\n};\n\ntype QueuedChange =\n  | { id: string; type: \"snapshot\"; snapshots: RunExecutionData[] }\n  | { id: string; type: \"suspendable\"; value: boolean };\n\ntype QueuedChangeItem = {\n  change: QueuedChange;\n  resolve: () => void;\n  reject: (error: Error) => void;\n};\n\nexport class SnapshotManager {\n  private runFriendlyId: string;\n  private runnerId: string;\n\n  private logger: RunLogger;\n  private metadataClient?: MetadataClient;\n\n  private state: SnapshotState;\n  private isSuspendable: boolean = false;\n\n  private readonly onSnapshotChange: SnapshotHandler;\n  private readonly onSuspendable: SuspendableHandler;\n\n  private changeQueue: QueuedChangeItem[] = [];\n  private isProcessingQueue = false;\n\n  constructor(opts: SnapshotManagerOptions) {\n    this.runFriendlyId = opts.runFriendlyId;\n    this.runnerId = opts.runnerId;\n\n    this.logger = opts.logger;\n    this.metadataClient = opts.metadataClient;\n\n    this.state = {\n      id: opts.initialSnapshotId,\n      status: opts.initialStatus,\n    };\n\n    this.onSnapshotChange = opts.onSnapshotChange;\n    this.onSuspendable = opts.onSuspendable;\n  }\n\n  public get snapshotId(): string {\n    return this.state.id;\n  }\n\n  public get status(): TaskRunExecutionStatus {\n    return this.state.status;\n  }\n\n  public get suspendable(): boolean {\n    return this.isSuspendable;\n  }\n\n  public async setSuspendable(suspendable: boolean): Promise<void> {\n    if (this.isSuspendable === suspendable) {\n      this.sendDebugLog(`skipping suspendable update, already ${suspendable}`);\n      return;\n    }\n\n    this.sendDebugLog(`setting suspendable to ${suspendable}`);\n\n    return this.enqueueSnapshotChange({\n      id: crypto.randomUUID(),\n      type: \"suspendable\",\n      value: suspendable,\n    });\n  }\n\n  /**\n   * Update the snapshot ID and status without invoking any handlers\n   *\n   * @param snapshotId - The ID of the snapshot to update to\n   * @param status - The status to update to\n   */\n  public updateSnapshot(snapshotId: string, status: TaskRunExecutionStatus) {\n    // Check if this is an old snapshot\n    if (snapshotId < this.state.id) {\n      this.sendDebugLog(\"skipping update for old snapshot\", {\n        incomingId: snapshotId,\n        currentId: this.state.id,\n      });\n      return;\n    }\n\n    this.state = { id: snapshotId, status };\n  }\n\n  public async handleSnapshotChanges(snapshots: RunExecutionData[]): Promise<void> {\n    if (!this.statusCheck(snapshots)) {\n      return;\n    }\n\n    return this.enqueueSnapshotChange({\n      id: crypto.randomUUID(),\n      type: \"snapshot\",\n      snapshots,\n    });\n  }\n\n  public get queueLength(): number {\n    return this.changeQueue.length;\n  }\n\n  private statusCheck(snapshots: RunExecutionData[]): boolean {\n    const latestSnapshot = snapshots[snapshots.length - 1];\n\n    if (!latestSnapshot) {\n      this.sendDebugLog(\"skipping status check for empty snapshots\", {\n        snapshots,\n      });\n      return false;\n    }\n\n    const { run, snapshot } = latestSnapshot;\n\n    const statusCheckData = {\n      incomingId: snapshot.friendlyId,\n      incomingStatus: snapshot.executionStatus,\n      currentId: this.state.id,\n      currentStatus: this.state.status,\n    };\n\n    // Ensure run ID matches\n    if (run.friendlyId !== this.runFriendlyId) {\n      this.sendDebugLog(\"skipping update for mismatched run ID\", {\n        statusCheckData,\n      });\n\n      return false;\n    }\n\n    // Skip if this is an old snapshot\n    if (snapshot.friendlyId < this.state.id) {\n      this.sendDebugLog(\"skipping update for old snapshot\", {\n        statusCheckData,\n      });\n\n      return false;\n    }\n\n    // Skip if this is the current snapshot\n    if (snapshot.friendlyId === this.state.id) {\n      // DO NOT REMOVE (very noisy, but helpful for debugging)\n      // this.sendDebugLog(\"skipping update for duplicate snapshot\", {\n      //   statusCheckData,\n      // });\n\n      return false;\n    }\n\n    return true;\n  }\n\n  private async enqueueSnapshotChange(change: QueuedChange): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      // For suspendable changes, resolve and remove any pending suspendable changes since only the last one matters\n      if (change.type === \"suspendable\") {\n        const pendingSuspendable = this.changeQueue.filter(\n          (item) => item.change.type === \"suspendable\"\n        );\n\n        // Resolve any pending suspendable changes - they're effectively done since we're superseding them\n        for (const item of pendingSuspendable) {\n          item.resolve();\n        }\n\n        // Remove the exact items we just resolved\n        const resolvedIds = new Set(pendingSuspendable.map((item) => item.change.id));\n        this.changeQueue = this.changeQueue.filter((item) => !resolvedIds.has(item.change.id));\n      }\n\n      this.changeQueue.push({ change, resolve, reject });\n\n      // Sort queue:\n      // 1. Suspendable changes always go to the back\n      // 2. Snapshot changes are ordered by creation time, with the latest snapshot last\n      this.changeQueue.sort((a, b) => {\n        if (a.change.type === \"suspendable\" && b.change.type === \"snapshot\") {\n          return 1; // a goes after b\n        }\n        if (a.change.type === \"snapshot\" && b.change.type === \"suspendable\") {\n          return -1; // a goes before b\n        }\n        if (a.change.type === \"snapshot\" && b.change.type === \"snapshot\") {\n          const snapshotA = a.change.snapshots[a.change.snapshots.length - 1];\n          const snapshotB = b.change.snapshots[b.change.snapshots.length - 1];\n\n          if (!snapshotA || !snapshotB) {\n            return 0;\n          }\n\n          // Sort snapshot changes by creation time, old -> new\n          return snapshotA.snapshot.createdAt.getTime() - snapshotB.snapshot.createdAt.getTime();\n        }\n        return 0; // both suspendable, maintain insertion order\n      });\n\n      // Start processing if not already running\n      this.processQueue().catch((error) => {\n        this.sendDebugLog(\"error processing queue\", { error: error.message });\n      });\n    });\n  }\n\n  private async processQueue() {\n    if (this.isProcessingQueue) {\n      return;\n    }\n\n    this.isProcessingQueue = true;\n\n    try {\n      while (this.queueLength > 0) {\n        // Remove first item from queue\n        const item = this.changeQueue.shift();\n        if (!item) {\n          break;\n        }\n\n        const [error] = await tryCatch(this.applyChange(item.change));\n\n        // Resolve/reject promise\n        if (error) {\n          item.reject(error);\n        } else {\n          item.resolve();\n        }\n      }\n    } finally {\n      const hasMoreItems = this.queueLength > 0;\n      this.isProcessingQueue = false;\n\n      if (hasMoreItems) {\n        this.processQueue().catch((error) => {\n          this.sendDebugLog(\"error processing queue (finally)\", { error: error.message });\n        });\n      }\n    }\n  }\n\n  private async applyChange(change: QueuedChange): Promise<void> {\n    switch (change.type) {\n      case \"snapshot\": {\n        const { snapshots } = change;\n\n        // Double check we should process this snapshot\n        if (!this.statusCheck(snapshots)) {\n          return;\n        }\n\n        const latestSnapshot = change.snapshots[change.snapshots.length - 1];\n        if (!latestSnapshot) {\n          return;\n        }\n\n        // These are the snapshots between the current and the latest one\n        const previousSnapshots = snapshots.slice(0, -1);\n\n        // Check if any previous snapshot is QUEUED or SUSPENDED\n        const deprecatedStatus: TaskRunExecutionStatus[] = [\"QUEUED\", \"SUSPENDED\"];\n        const deprecatedSnapshots = previousSnapshots.filter((snap) =>\n          deprecatedStatus.includes(snap.snapshot.executionStatus)\n        );\n\n        let deprecated = false;\n        if (deprecatedSnapshots.length > 0) {\n          const hasBeenRestored = await this.hasBeenRestored();\n\n          if (hasBeenRestored) {\n            // It's normal for a restored run to have deprecation markers, e.g. it will have been SUSPENDED\n            deprecated = false;\n          } else {\n            deprecated = true;\n          }\n        }\n\n        const { snapshot } = latestSnapshot;\n        const oldState = { ...this.state };\n\n        this.updateSnapshot(snapshot.friendlyId, snapshot.executionStatus);\n\n        this.sendDebugLog(`status changed to ${snapshot.executionStatus}`, {\n          oldId: oldState.id,\n          newId: snapshot.friendlyId,\n          oldStatus: oldState.status,\n          newStatus: snapshot.executionStatus,\n          deprecated,\n        });\n\n        // Execute handler\n        await this.onSnapshotChange(latestSnapshot, deprecated);\n\n        // Check suspendable state after snapshot change\n        await this.checkSuspendableState();\n        break;\n      }\n      case \"suspendable\": {\n        this.isSuspendable = change.value;\n\n        // Check suspendable state after suspendable change\n        await this.checkSuspendableState();\n        break;\n      }\n      default: {\n        assertExhaustive(change);\n      }\n    }\n  }\n\n  private async hasBeenRestored() {\n    if (!this.metadataClient) {\n      return false;\n    }\n\n    const [error, overrides] = await this.metadataClient.getEnvOverrides();\n\n    if (error) {\n      return false;\n    }\n\n    if (!overrides.TRIGGER_RUNNER_ID) {\n      return false;\n    }\n\n    if (overrides.TRIGGER_RUNNER_ID === this.runnerId) {\n      return false;\n    }\n\n    this.runnerId = overrides.TRIGGER_RUNNER_ID;\n\n    return true;\n  }\n\n  private async checkSuspendableState() {\n    if (\n      this.isSuspendable &&\n      (this.state.status === \"EXECUTING_WITH_WAITPOINTS\" ||\n        this.state.status === \"QUEUED_EXECUTING\")\n    ) {\n      // DO NOT REMOVE (very noisy, but helpful for debugging)\n      // this.sendDebugLog(\"run is now suspendable, executing handler\");\n      await this.onSuspendable(this.state);\n    }\n  }\n\n  public stop() {\n    this.sendDebugLog(\"stop\");\n\n    // Clear any pending changes\n    for (const item of this.changeQueue) {\n      item.reject(new Error(\"SnapshotManager stopped\"));\n    }\n    this.changeQueue = [];\n  }\n\n  protected sendDebugLog(message: string, properties?: SendDebugLogOptions[\"properties\"]) {\n    this.logger.sendDebugLog({\n      runId: this.runFriendlyId,\n      message: `[snapshot] ${message}`,\n      properties: {\n        ...properties,\n        snapshotId: this.state.id,\n        status: this.state.status,\n        suspendable: this.isSuspendable,\n        queueLength: this.queueLength,\n        isProcessingQueue: this.isProcessingQueue,\n      },\n    });\n  }\n}",
            "output_extracted": "import { tryCatch } from \"@trigger.dev/core/utils\";\nimport { RunLogger, SendDebugLogOptions } from \"./logger.js\";\nimport { TaskRunExecutionStatus, type RunExecutionData } from \"@trigger.dev/core/v3\";\nimport { assertExhaustive } from \"@trigger.dev/core/utils\";\nimport { MetadataClient } from \"./overrides.js\";\n\nexport type SnapshotState = {\n  id: string;\n  status: TaskRunExecutionStatus;\n};\n\ntype SnapshotHandler = (runData: RunExecutionData, deprecated: boolean) => Promise<void>;\ntype SuspendableHandler = (suspendableSnapshot: SnapshotState) => Promise<void>;\n\ntype SnapshotManagerOptions = {\n  runFriendlyId: string;\n  runnerId: string;\n  initialSnapshotId: string;\n  initialStatus: TaskRunExecutionStatus;\n  logger: RunLogger;\n  metadataClient?: MetadataClient;\n  onSnapshotChange: SnapshotHandler;\n  onSuspendable: SuspendableHandler;\n};\n\ntype QueuedChange =\n  | { id: string; type: \"snapshot\"; snapshots: RunExecutionData[] }\n  | { id: string; type: \"suspendable\"; value: boolean };\n\ntype QueuedChangeItem = {\n  change: QueuedChange;\n  resolve: () => void;\n  reject: (error: Error) => void;\n};\n\nexport class SnapshotManager {\n  private runFriendlyId: string;\n  private runnerId: string;\n\n  private logger: RunLogger;\n  private metadataClient?: MetadataClient;\n\n  private state: SnapshotState;\n  private isSuspendable: boolean = false;\n\n  private readonly onSnapshotChange: SnapshotHandler;\n  private readonly onSuspendable: SuspendableHandler;\n\n  private changeQueue: QueuedChangeItem[] = [];\n  private isProcessingQueue = false;\n\n  constructor(opts: SnapshotManagerOptions) {\n    this.runFriendlyId = opts.runFriendlyId;\n    this.runnerId = opts.runnerId;\n\n    this.logger = opts.logger;\n    this.metadataClient = opts.metadataClient;\n\n    this.state = {\n      id: opts.initialSnapshotId,\n      status: opts.initialStatus,\n    };\n\n    this.onSnapshotChange = opts.onSnapshotChange;\n    this.onSuspendable = opts.onSuspendable;\n  }\n\n  public get snapshotId(): string {\n    return this.state.id;\n  }\n\n  public get status(): TaskRunExecutionStatus {\n    return this.state.status;\n  }\n\n  public get suspendable(): boolean {\n    return this.isSuspendable;\n  }\n\n  public async setSuspendable(suspendable: boolean): Promise<void> {\n    if (this.isSuspendable === suspendable) {\n      this.sendDebugLog(`skipping suspendable update, already ${suspendable}`);\n      return;\n    }\n\n    this.sendDebugLog(`setting suspendable to ${suspendable}`);\n\n    return this.enqueueSnapshotChange({\n      id: crypto.randomUUID(),\n      type: \"suspendable\",\n      value: suspendable,\n    });\n  }\n\n  /**\n   * Update the snapshot ID and status without invoking any handlers\n   *\n   * @param snapshotId - The ID of the snapshot to update to\n   * @param status - The status to update to\n   */\n  public updateSnapshot(snapshotId: string, status: TaskRunExecutionStatus) {\n    // Check if this is an old snapshot\n    if (snapshotId < this.state.id) {\n      this.sendDebugLog(\"skipping update for old snapshot\", {\n        incomingId: snapshotId,\n        currentId: this.state.id,\n      });\n      return;\n    }\n\n    this.state = { id: snapshotId, status };\n  }\n\n  public async handleSnapshotChanges(snapshots: RunExecutionData[]): Promise<void> {\n    if (!this.statusCheck(snapshots)) {\n      return;\n    }\n\n    return this.enqueueSnapshotChange({\n      id: crypto.randomUUID(),\n      type: \"snapshot\",\n      snapshots,\n    });\n  }\n\n  public get queueLength(): number {\n    return this.changeQueue.length;\n  }\n\n  private statusCheck(snapshots: RunExecutionData[]): boolean {\n    const latestSnapshot = snapshots[snapshots.length - 1];\n\n    if (!latestSnapshot) {\n      this.sendDebugLog(\"skipping status check for empty snapshots\", {\n        snapshots,\n      });\n      return false;\n    }\n\n    const { run, snapshot } = latestSnapshot;\n\n    const statusCheckData = {\n      incomingId: snapshot.friendlyId,\n      incomingStatus: snapshot.executionStatus,\n      currentId: this.state.id,\n      currentStatus: this.state.status,\n    };\n\n    // Ensure run ID matches\n    if (run.friendlyId !== this.runFriendlyId) {\n      this.sendDebugLog(\"skipping update for mismatched run ID\", {\n        statusCheckData,\n      });\n\n      return false;\n    }\n\n    // Skip if this is an old snapshot\n    if (snapshot.friendlyId < this.state.id) {\n      this.sendDebugLog(\"skipping update for old snapshot\", {\n        statusCheckData,\n      });\n\n      return false;\n    }\n\n    // Skip if this is the current snapshot\n    if (snapshot.friendlyId === this.state.id) {\n      // DO NOT REMOVE (very noisy, but helpful for debugging)\n      // this.sendDebugLog(\"skipping update for duplicate snapshot\", {\n      //   statusCheckData,\n      // });\n\n      return false;\n    }\n\n    return true;\n  }\n\n  private async enqueueSnapshotChange(change: QueuedChange): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      // For suspendable changes, resolve and remove any pending suspendable changes since only the last one matters\n      if (change.type === \"suspendable\") {\n        const pendingSuspendable = this.changeQueue.filter(\n          (item) => item.change.type === \"suspendable\"\n        );\n\n        // Resolve any pending suspendable changes - they're effectively done since we're superseding them\n        for (const item of pendingSuspendable) {\n          item.resolve();\n        }\n\n        // Remove the exact items we just resolved\n        const resolvedIds = new Set(pendingSuspendable.map((item) => item.change.id));\n        this.changeQueue = this.changeQueue.filter((item) => !resolvedIds.has(item.change.id));\n      }\n\n      this.changeQueue.push({ change, resolve, reject });\n\n      // Sort queue:\n      // 1. Suspendable changes always go to the back\n      // 2. Snapshot changes are ordered by creation time, with the latest snapshot last\n      this.changeQueue.sort((a, b) => {\n        if (a.change.type === \"suspendable\" && b.change.type === \"snapshot\") {\n          return 1; // a goes after b\n        }\n        if (a.change.type === \"snapshot\" && b.change.type === \"suspendable\") {\n          return -1; // a goes before b\n        }\n        if (a.change.type === \"snapshot\" && b.change.type === \"snapshot\") {\n          const snapshotA = a.change.snapshots[a.change.snapshots.length - 1];\n          const snapshotB = b.change.snapshots[b.change.snapshots.length - 1];\n\n          if (!snapshotA || !snapshotB) {\n            return 0;\n          }\n\n          // Sort snapshot changes by creation time, old -> new\n          return snapshotA.snapshot.createdAt.getTime() - snapshotB.snapshot.createdAt.getTime();\n        }\n        return 0; // both suspendable, maintain insertion order\n      });\n\n      // Start processing if not already running\n      this.processQueue().catch((error) => {\n        this.sendDebugLog(\"error processing queue\", { error: error.message });\n      });\n    });\n  }\n\n  private async processQueue() {\n    if (this.isProcessingQueue) {\n      return;\n    }\n\n    this.isProcessingQueue = true;\n\n    try {\n      while (this.queueLength > 0) {\n        // Remove first item from queue\n        const item = this.changeQueue.shift();\n        if (!item) {\n          break;\n        }\n\n        const [error] = await tryCatch(this.applyChange(item.change));\n\n        // Resolve/reject promise\n        if (error) {\n          item.reject(error);\n        } else {\n          item.resolve();\n        }\n      }\n    } finally {\n      const hasMoreItems = this.queueLength > 0;\n      this.isProcessingQueue = false;\n\n      if (hasMoreItems) {\n        this.processQueue().catch((error) => {\n          this.sendDebugLog(\"error processing queue (finally)\", { error: error.message });\n        });\n      }\n    }\n  }\n\n  private async applyChange(change: QueuedChange): Promise<void> {\n    switch (change.type) {\n      case \"snapshot\": {\n        const { snapshots } = change;\n\n        // Double check we should process this snapshot\n        if (!this.statusCheck(snapshots)) {\n          return;\n        }\n\n        const latestSnapshot = change.snapshots[change.snapshots.length - 1];\n        if (!latestSnapshot) {\n          return;\n        }\n\n        // These are the snapshots between the current and the latest one\n        const previousSnapshots = snapshots.slice(0, -1);\n\n        // Check if any previous snapshot is QUEUED or SUSPENDED\n        const deprecatedStatus: TaskRunExecutionStatus[] = [\"QUEUED\", \"SUSPENDED\"];\n        const deprecatedSnapshots = previousSnapshots.filter((snap) =>\n          deprecatedStatus.includes(snap.snapshot.executionStatus)\n        );\n\n        let deprecated = false;\n        if (deprecatedSnapshots.length > 0) {\n          const hasBeenRestored = await this.hasBeenRestored();\n\n          if (hasBeenRestored) {\n            // It's normal for a restored run to have deprecation markers, e.g. it will have been SUSPENDED\n            deprecated = false;\n          } else {\n            deprecated = true;\n          }\n        }\n\n        const { snapshot } = latestSnapshot;\n        const oldState = { ...this.state };\n\n        this.updateSnapshot(snapshot.friendlyId, snapshot.executionStatus);\n\n        this.sendDebugLog(`status changed to ${snapshot.executionStatus}`, {\n          oldId: oldState.id,\n          newId: snapshot.friendlyId,\n          oldStatus: oldState.status,\n          newStatus: snapshot.executionStatus,\n          deprecated,\n        });\n\n        // Execute handler\n        await this.onSnapshotChange(latestSnapshot, deprecated);\n\n        // Check suspendable state after snapshot change\n        await this.checkSuspendableState();\n        break;\n      }\n      case \"suspendable\": {\n        this.isSuspendable = change.value;\n\n        // Check suspendable state after suspendable change\n        await this.checkSuspendableState();\n        break;\n      }\n      default: {\n        assertExhaustive(change);\n      }\n    }\n  }\n\n  private async hasBeenRestored() {\n    if (!this.metadataClient) {\n      return false;\n    }\n\n    const [error, overrides] = await this.metadataClient.getEnvOverrides();\n\n    if (error) {\n      return false;\n    }\n\n    if (!overrides.TRIGGER_RUNNER_ID) {\n      return false;\n    }\n\n    if (overrides.TRIGGER_RUNNER_ID === this.runnerId) {\n      return false;\n    }\n\n    this.runnerId = overrides.TRIGGER_RUNNER_ID;\n\n    return true;\n  }\n\n  private async checkSuspendableState() {\n    if (\n      this.isSuspendable &&\n      (this.state.status === \"EXECUTING_WITH_WAITPOINTS\" ||\n        this.state.status === \"QUEUED_EXECUTING\")\n    ) {\n      // DO NOT REMOVE (very noisy, but helpful for debugging)\n      // this.sendDebugLog(\"run is now suspendable, executing handler\");\n      await this.onSuspendable(this.state);\n    }\n  }\n\n  public stop() {\n    this.sendDebugLog(\"stop\");\n\n    // Clear any pending changes\n    for (const item of this.changeQueue) {\n      item.reject(new Error(\"SnapshotManager stopped\"));\n    }\n    this.changeQueue = [];\n  }\n\n  protected sendDebugLog(message: string, properties?: SendDebugLogOptions[\"properties\"]) {\n    this.logger.sendDebugLog({\n      runId: this.runFriendlyId,\n      message: `[snapshot] ${message}`,\n      properties: {\n        ...properties,\n        snapshotId: this.state.id,\n        status: this.state.status,\n        suspendable: this.isSuspendable,\n        queueLength: this.queueLength,\n        isProcessingQueue: this.isProcessingQueue,\n      },\n    });\n  }\n}",
            "cost": 0.10976
        },
        "triggerdotdev__trigger.dev.d1c3bfb9/packages/core/src/v3/runEngineWorker/workload/http.ts": {
            "output": "import { z } from \"zod\";\nimport {\n  WorkloadHeartbeatRequestBody,\n  WorkloadHeartbeatResponseBody,\n  WorkloadRunAttemptCompleteRequestBody,\n  WorkloadRunAttemptCompleteResponseBody,\n  WorkloadRunAttemptStartResponseBody,\n  WorkloadDequeueFromVersionResponseBody,\n  WorkloadRunAttemptStartRequestBody,\n  WorkloadSuspendRunResponseBody,\n  WorkloadContinueRunExecutionResponseBody,\n  WorkloadDebugLogRequestBody,\n  WorkloadRunSnapshotsSinceResponseBody,\n} from \"./schemas.js\";\nimport { WorkloadClientCommonOptions } from \"./types.js\";\nimport { getDefaultWorkloadHeaders } from \"./util.js\";\nimport { wrapZodFetch } from \"../../zodfetch.js\";\n\ntype WorkloadHttpClientOptions = WorkloadClientCommonOptions;\n\nexport class WorkloadHttpClient {\n  private apiUrl: string;\n  private runnerId: string;\n  private readonly deploymentId: string;\n\n  constructor(private opts: WorkloadHttpClientOptions) {\n    this.apiUrl = opts.workerApiUrl.replace(/\\/$/, \"\");\n    this.deploymentId = opts.deploymentId;\n    this.runnerId = opts.runnerId;\n\n    if (!this.apiUrl) {\n      throw new Error(\"apiURL is required and needs to be a non-empty string\");\n    }\n\n    if (!this.deploymentId) {\n      throw new Error(\"deploymentId is required and needs to be a non-empty string\");\n    }\n  }\n\n  updateApiUrl(apiUrl: string) {\n    this.apiUrl = apiUrl.replace(/\\/$/, \"\");\n  }\n\n  updateRunnerId(runnerId: string) {\n    this.runnerId = runnerId;\n  }\n\n  defaultHeaders(): Record<string, string> {\n    return getDefaultWorkloadHeaders({\n      ...this.opts,\n      runnerId: this.runnerId,\n    });\n  }\n\n  async heartbeatRun(runId: string, snapshotId: string, body?: WorkloadHeartbeatRequestBody) {\n    return wrapZodFetch(\n      WorkloadHeartbeatResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/heartbeat`,\n      {\n        method: \"POST\",\n        headers: {\n          ...this.defaultHeaders(),\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(body ?? {}),\n      }\n    );\n  }\n\n  async suspendRun(runId: string, snapshotId: string) {\n    return wrapZodFetch(\n      WorkloadSuspendRunResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/suspend`,\n      {\n        method: \"GET\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n      }\n    );\n  }\n\n  async continueRunExecution(runId: string, snapshotId: string) {\n    return wrapZodFetch(\n      WorkloadContinueRunExecutionResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/continue`,\n      {\n        method: \"GET\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n      }\n    );\n  }\n\n  async startRunAttempt(\n    runId: string,\n    snapshotId: string,\n    body: WorkloadRunAttemptStartRequestBody\n  ) {\n    return wrapZodFetch(\n      WorkloadRunAttemptStartResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/attempts/start`,\n      {\n        method: \"POST\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n        body: JSON.stringify(body),\n      }\n    );\n  }\n\n  async completeRunAttempt(\n    runId: string,\n    snapshotId: string,\n    body: WorkloadRunAttemptCompleteRequestBody\n  ) {\n    return wrapZodFetch(\n      WorkloadRunAttemptCompleteResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/attempts/complete`,\n      {\n        method: \"POST\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n        body: JSON.stringify(body),\n      }\n    );\n  }\n\n  async getSnapshotsSince(runId: string, snapshotId: string) {\n    return wrapZodFetch(\n      WorkloadRunSnapshotsSinceResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/since/${snapshotId}`,\n      {\n        method: \"GET\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n      }\n    );\n  }\n\n  async sendDebugLog(runId: string, body: WorkloadDebugLogRequestBody): Promise<void> {\n    try {\n      const res = await wrapZodFetch(\n        z.unknown(),\n        `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/logs/debug`,\n        {\n          method: \"POST\",\n          headers: {\n            ...this.defaultHeaders(),\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify(body),\n        }\n      );\n\n      if (!res.success) {\n        console.error(\"Failed to send debug log\", res);\n      }\n    } catch (error) {\n      console.error(\"Failed to send debug log\", { error });\n    }\n  }\n\n  /** @deprecated Not currently used */\n  async dequeue() {\n    return wrapZodFetch(\n      WorkloadDequeueFromVersionResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/deployments/${this.deploymentId}/dequeue`,\n      {\n        method: \"GET\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n      }\n    );\n  }\n}",
            "output_extracted": "import { z } from \"zod\";\nimport {\n  WorkloadHeartbeatRequestBody,\n  WorkloadHeartbeatResponseBody,\n  WorkloadRunAttemptCompleteRequestBody,\n  WorkloadRunAttemptCompleteResponseBody,\n  WorkloadRunAttemptStartResponseBody,\n  WorkloadDequeueFromVersionResponseBody,\n  WorkloadRunAttemptStartRequestBody,\n  WorkloadSuspendRunResponseBody,\n  WorkloadContinueRunExecutionResponseBody,\n  WorkloadDebugLogRequestBody,\n  WorkloadRunSnapshotsSinceResponseBody,\n} from \"./schemas.js\";\nimport { WorkloadClientCommonOptions } from \"./types.js\";\nimport { getDefaultWorkloadHeaders } from \"./util.js\";\nimport { wrapZodFetch } from \"../../zodfetch.js\";\n\ntype WorkloadHttpClientOptions = WorkloadClientCommonOptions;\n\nexport class WorkloadHttpClient {\n  private apiUrl: string;\n  private runnerId: string;\n  private readonly deploymentId: string;\n\n  constructor(private opts: WorkloadHttpClientOptions) {\n    this.apiUrl = opts.workerApiUrl.replace(/\\/$/, \"\");\n    this.deploymentId = opts.deploymentId;\n    this.runnerId = opts.runnerId;\n\n    if (!this.apiUrl) {\n      throw new Error(\"apiURL is required and needs to be a non-empty string\");\n    }\n\n    if (!this.deploymentId) {\n      throw new Error(\"deploymentId is required and needs to be a non-empty string\");\n    }\n  }\n\n  updateApiUrl(apiUrl: string) {\n    this.apiUrl = apiUrl.replace(/\\/$/, \"\");\n  }\n\n  updateRunnerId(runnerId: string) {\n    this.runnerId = runnerId;\n  }\n\n  defaultHeaders(): Record<string, string> {\n    return getDefaultWorkloadHeaders({\n      ...this.opts,\n      runnerId: this.runnerId,\n    });\n  }\n\n  async heartbeatRun(runId: string, snapshotId: string, body?: WorkloadHeartbeatRequestBody) {\n    return wrapZodFetch(\n      WorkloadHeartbeatResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/heartbeat`,\n      {\n        method: \"POST\",\n        headers: {\n          ...this.defaultHeaders(),\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(body ?? {}),\n      }\n    );\n  }\n\n  async suspendRun(runId: string, snapshotId: string) {\n    return wrapZodFetch(\n      WorkloadSuspendRunResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/suspend`,\n      {\n        method: \"GET\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n      }\n    );\n  }\n\n  async continueRunExecution(runId: string, snapshotId: string) {\n    return wrapZodFetch(\n      WorkloadContinueRunExecutionResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/continue`,\n      {\n        method: \"GET\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n      }\n    );\n  }\n\n  async startRunAttempt(\n    runId: string,\n    snapshotId: string,\n    body: WorkloadRunAttemptStartRequestBody\n  ) {\n    return wrapZodFetch(\n      WorkloadRunAttemptStartResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/attempts/start`,\n      {\n        method: \"POST\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n        body: JSON.stringify(body),\n      }\n    );\n  }\n\n  async completeRunAttempt(\n    runId: string,\n    snapshotId: string,\n    body: WorkloadRunAttemptCompleteRequestBody\n  ) {\n    return wrapZodFetch(\n      WorkloadRunAttemptCompleteResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/attempts/complete`,\n      {\n        method: \"POST\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n        body: JSON.stringify(body),\n      }\n    );\n  }\n\n  async getSnapshotsSince(runId: string, snapshotId: string) {\n    return wrapZodFetch(\n      WorkloadRunSnapshotsSinceResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/since/${snapshotId}`,\n      {\n        method: \"GET\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n      }\n    );\n  }\n\n  async sendDebugLog(runId: string, body: WorkloadDebugLogRequestBody): Promise<void> {\n    try {\n      const res = await wrapZodFetch(\n        z.unknown(),\n        `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/logs/debug`,\n        {\n          method: \"POST\",\n          headers: {\n            ...this.defaultHeaders(),\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify(body),\n        }\n      );\n\n      if (!res.success) {\n        console.error(\"Failed to send debug log\", res);\n      }\n    } catch (error) {\n      console.error(\"Failed to send debug log\", { error });\n    }\n  }\n\n  /** @deprecated Not currently used */\n  async dequeue() {\n    return wrapZodFetch(\n      WorkloadDequeueFromVersionResponseBody,\n      `${this.apiUrl}/api/v1/workload-actions/deployments/${this.deploymentId}/dequeue`,\n      {\n        method: \"GET\",\n        headers: {\n          ...this.defaultHeaders(),\n        },\n      }\n    );\n  }\n}",
            "cost": 0.059300000000000005
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "triggerdotdev__trigger.dev.pr_mirror.2523",
        "repo": "triggerdotdev/trigger.dev",
        "base_commit": "a3ef6ea2363a6617296d6132a76c6d9a595f3a3e",
        "head_commit": "97160380d1ad0d7d49bed7b1d41e235c821daf51",
        "title": "fix(runner): reduce restore recovery time and deprecated runner false positives",
        "merged_at": "2025-09-18T15:59:44Z",
        "html_url": "https://github.com/triggerdotdev/trigger.dev/pull/2523",
        "test_files": [
            "packages/cli-v3/src/entryPoints/managed/snapshot.test.ts"
        ],
        "code_files": [
            "apps/supervisor/src/workloadServer/index.ts",
            "packages/cli-v3/src/entryPoints/managed/controller.ts",
            "packages/cli-v3/src/entryPoints/managed/execution.ts",
            "packages/cli-v3/src/entryPoints/managed/snapshot.ts",
            "packages/core/src/v3/runEngineWorker/workload/http.ts"
        ],
        "total_changes": 341,
        "num_files": 7,
        "pull_number": 2523,
        "patch": "diff --git a/.changeset/six-cougars-play.md b/.changeset/six-cougars-play.md\nnew file mode 100644\nindex 0000000000..75d128dddd\n--- /dev/null\n+++ b/.changeset/six-cougars-play.md\n@@ -0,0 +1,6 @@\n+---\n+\"trigger.dev\": patch\n+\"@trigger.dev/core\": patch\n+---\n+\n+Reduce restore recovery time and fix deprecated runner false positives\n\\ No newline at end of file\ndiff --git a/apps/supervisor/src/workloadServer/index.ts b/apps/supervisor/src/workloadServer/index.ts\nindex 6b24ffcf33..35d53d3609 100644\n--- a/apps/supervisor/src/workloadServer/index.ts\n+++ b/apps/supervisor/src/workloadServer/index.ts\n@@ -125,7 +125,7 @@ export class WorkloadServer extends EventEmitter<WorkloadServerEvents> {\n   }\n \n   private createHttpServer({ host, port }: { host: string; port: number }) {\n-    return new HttpServer({\n+    const httpServer = new HttpServer({\n       port,\n       host,\n       metrics: {\n@@ -346,23 +346,6 @@ export class WorkloadServer extends EventEmitter<WorkloadServerEvents> {\n           },\n         }\n       )\n-      .route(\"/api/v1/workload-actions/runs/:runFriendlyId/logs/debug\", \"POST\", {\n-        paramsSchema: WorkloadActionParams.pick({ runFriendlyId: true }),\n-        bodySchema: WorkloadDebugLogRequestBody,\n-        handler: async ({ req, reply, params, body }) => {\n-          reply.empty(204);\n-\n-          if (!env.SEND_RUN_DEBUG_LOGS) {\n-            return;\n-          }\n-\n-          await this.workerClient.sendDebugLog(\n-            params.runFriendlyId,\n-            body,\n-            this.runnerIdFromRequest(req)\n-          );\n-        },\n-      })\n       .route(\"/api/v1/workload-actions/deployments/:deploymentId/dequeue\", \"GET\", {\n         paramsSchema: z.object({\n           deploymentId: z.string(),\n@@ -387,6 +370,31 @@ export class WorkloadServer extends EventEmitter<WorkloadServerEvents> {\n           reply.json(dequeueResponse.data satisfies WorkloadDequeueFromVersionResponseBody);\n         },\n       });\n+\n+    if (env.SEND_RUN_DEBUG_LOGS) {\n+      httpServer.route(\"/api/v1/workload-actions/runs/:runFriendlyId/logs/debug\", \"POST\", {\n+        paramsSchema: WorkloadActionParams.pick({ runFriendlyId: true }),\n+        bodySchema: WorkloadDebugLogRequestBody,\n+        handler: async ({ req, reply, params, body }) => {\n+          reply.empty(204);\n+\n+          await this.workerClient.sendDebugLog(\n+            params.runFriendlyId,\n+            body,\n+            this.runnerIdFromRequest(req)\n+          );\n+        },\n+      });\n+    } else {\n+      // Lightweight mock route without schemas\n+      httpServer.route(\"/api/v1/workload-actions/runs/:runFriendlyId/logs/debug\", \"POST\", {\n+        handler: async ({ reply }) => {\n+          reply.empty(204);\n+        },\n+      });\n+    }\n+\n+    return httpServer;\n   }\n \n   private createWebsocketServer() {\ndiff --git a/packages/cli-v3/src/entryPoints/managed/controller.ts b/packages/cli-v3/src/entryPoints/managed/controller.ts\nindex 80bd744dfa..c721cefc56 100644\n--- a/packages/cli-v3/src/entryPoints/managed/controller.ts\n+++ b/packages/cli-v3/src/entryPoints/managed/controller.ts\n@@ -461,19 +461,6 @@ export class ManagedRunController {\n         runId: this.runFriendlyId,\n         message: \"Socket connected to supervisor\",\n       });\n-\n-      // This should handle the case where we reconnect after being restored\n-      if (\n-        this.runFriendlyId &&\n-        this.snapshotFriendlyId &&\n-        this.runFriendlyId !== this.env.TRIGGER_RUN_ID\n-      ) {\n-        this.sendDebugLog({\n-          runId: this.runFriendlyId,\n-          message: \"Subscribing to notifications for in-progress run\",\n-        });\n-        this.subscribeToRunNotifications(this.runFriendlyId, this.snapshotFriendlyId);\n-      }\n     });\n \n     socket.on(\"connect_error\", (error) => {\n@@ -514,7 +501,7 @@ export class ManagedRunController {\n           supervisorApiUrl: this.env.TRIGGER_SUPERVISOR_API_URL,\n         };\n \n-        await this.currentExecution.processEnvOverrides(\"socket disconnected\", true);\n+        const result = await this.currentExecution.processEnvOverrides(\"socket disconnected\", true);\n \n         const newEnv = {\n           workerInstanceName: this.env.TRIGGER_WORKER_INSTANCE_NAME,\n@@ -528,6 +515,43 @@ export class ManagedRunController {\n           properties: { reason, ...parseDescription(), currentEnv, newEnv },\n         });\n \n+        if (!result) {\n+          return;\n+        }\n+\n+        // If runner ID changed, we detected a restore\n+        if (result.runnerIdChanged) {\n+          this.sendDebugLog({\n+            runId: this.runFriendlyId,\n+            message: \"Runner ID changed - restore detected\",\n+            properties: {\n+              supervisorChanged: result.supervisorChanged,\n+            },\n+          });\n+\n+          if (!result.supervisorChanged) {\n+            return;\n+          }\n+\n+          // Only reconnect WebSocket if supervisor URL actually changed\n+          this.sendDebugLog({\n+            runId: this.runFriendlyId,\n+            message: \"Supervisor URL changed - creating new socket connection\",\n+          });\n+\n+          // First disconnect the old socket to avoid conflicts\n+          socket.removeAllListeners();\n+          socket.disconnect();\n+\n+          // Create a new socket with the updated URL and headers\n+          this.socket = this.createSupervisorSocket();\n+\n+          // Re-subscribe to notifications if we have an active execution\n+          if (this.runFriendlyId && this.snapshotFriendlyId) {\n+            this.subscribeToRunNotifications(this.runFriendlyId, this.snapshotFriendlyId);\n+          }\n+        }\n+\n         return;\n       }\n \ndiff --git a/packages/cli-v3/src/entryPoints/managed/execution.ts b/packages/cli-v3/src/entryPoints/managed/execution.ts\nindex 2b9e0c9c08..2dd3e6838e 100644\n--- a/packages/cli-v3/src/entryPoints/managed/execution.ts\n+++ b/packages/cli-v3/src/entryPoints/managed/execution.ts\n@@ -873,7 +873,23 @@ export class RunExecution {\n     );\n \n     if (!continuationResult.success) {\n-      throw new Error(continuationResult.error);\n+      // Check if we need to refresh metadata due to connection error\n+      if (continuationResult.isConnectionError) {\n+        this.sendDebugLog(\"restore: connection error detected, refreshing metadata\");\n+        await this.processEnvOverrides(\"restore connection error\");\n+\n+        // Retry the continuation after refreshing metadata\n+        const retryResult = await this.httpClient.continueRunExecution(\n+          this.runFriendlyId,\n+          this.snapshotManager.snapshotId\n+        );\n+\n+        if (!retryResult.success) {\n+          throw new Error(retryResult.error);\n+        }\n+      } else {\n+        throw new Error(continuationResult.error);\n+      }\n     }\n \n     // Track restore count\n@@ -899,11 +915,18 @@ export class RunExecution {\n   public async processEnvOverrides(\n     reason?: string,\n     shouldPollForSnapshotChanges?: boolean\n-  ): Promise<{ overrides: Metadata } | null> {\n+  ): Promise<{\n+    overrides: Metadata;\n+    runnerIdChanged?: boolean;\n+    supervisorChanged?: boolean;\n+  } | null> {\n     if (!this.metadataClient) {\n       return null;\n     }\n \n+    const previousRunnerId = this.env.TRIGGER_RUNNER_ID;\n+    const previousSupervisorUrl = this.env.TRIGGER_SUPERVISOR_API_URL;\n+\n     const [error, overrides] = await this.metadataClient.getEnvOverrides();\n \n     if (error) {\n@@ -931,6 +954,14 @@ export class RunExecution {\n     // Override the env with the new values\n     this.env.override(overrides);\n \n+    // Check if runner ID changed\n+    const newRunnerId = this.env.TRIGGER_RUNNER_ID;\n+    const runnerIdChanged = previousRunnerId !== newRunnerId;\n+\n+    // Check if supervisor URL changed\n+    const newSupervisorUrl = this.env.TRIGGER_SUPERVISOR_API_URL;\n+    const supervisorChanged = previousSupervisorUrl !== newSupervisorUrl;\n+\n     // Update services with new values\n     if (overrides.TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS) {\n       this.snapshotPoller?.updateInterval(this.env.TRIGGER_SNAPSHOT_POLL_INTERVAL_SECONDS * 1000);\n@@ -954,6 +985,8 @@ export class RunExecution {\n \n     return {\n       overrides,\n+      runnerIdChanged,\n+      supervisorChanged,\n     };\n   }\n \n@@ -977,6 +1010,12 @@ export class RunExecution {\n \n     if (!response.success) {\n       this.sendDebugLog(\"heartbeat: failed\", { error: response.error });\n+\n+      // Check if we need to refresh metadata due to connection error\n+      if (response.isConnectionError) {\n+        this.sendDebugLog(\"heartbeat: connection error detected, refreshing metadata\");\n+        await this.processEnvOverrides(\"heartbeat connection error\");\n+      }\n     }\n \n     this.lastHeartbeat = new Date();\n@@ -1192,6 +1231,14 @@ export class RunExecution {\n         error: response.error,\n       });\n \n+      if (response.isConnectionError) {\n+        // Log this separately to make it more visible\n+        this.sendDebugLog(\n+          \"fetchAndProcessSnapshotChanges: connection error detected, refreshing metadata\"\n+        );\n+      }\n+\n+      // Always trigger metadata refresh on snapshot fetch errors\n       await this.processEnvOverrides(\"snapshots since error\");\n       return;\n     }\ndiff --git a/packages/cli-v3/src/entryPoints/managed/snapshot.test.ts b/packages/cli-v3/src/entryPoints/managed/snapshot.test.ts\nindex 05cba11f38..a3dbab3883 100644\n--- a/packages/cli-v3/src/entryPoints/managed/snapshot.test.ts\n+++ b/packages/cli-v3/src/entryPoints/managed/snapshot.test.ts\n@@ -697,6 +697,65 @@ describe(\"SnapshotManager\", () => {\n       true\n     );\n   });\n+\n+  it(\"should handle deprecated snapshot race condition - avoid false positives from stale polls\", async () => {\n+    const onSnapshotChange = vi.fn();\n+\n+    // Mock MetadataClient to simulate runner ID change (restore detected) on first call\n+    let isFirstCall = true;\n+    const mockMetadataClient = {\n+      getEnvOverrides: vi.fn().mockImplementation(() => {\n+        if (isFirstCall) {\n+          isFirstCall = false;\n+          return Promise.resolve([null, { TRIGGER_RUNNER_ID: \"test-runner-2\" }]); // Different runner ID = restore\n+        }\n+        return Promise.resolve([null, { TRIGGER_RUNNER_ID: \"test-runner-2\" }]); // Same runner ID afterward\n+      }),\n+    };\n+\n+    const manager = new SnapshotManager({\n+      runnerId: \"test-runner-1\",\n+      runFriendlyId: \"test-run-1\",\n+      initialSnapshotId: \"snapshot-1\",\n+      initialStatus: \"EXECUTING_WITH_WAITPOINTS\",\n+      logger: mockLogger,\n+      metadataClient: mockMetadataClient as any,\n+      onSnapshotChange,\n+      onSuspendable: mockSuspendableHandler,\n+    });\n+\n+    // First update: Process restore transition with deprecated statuses (normal case)\n+    // This simulates: EXECUTING_WITH_WAITPOINTS -> [SUSPENDED, QUEUED] -> PENDING_EXECUTING\n+    await manager.handleSnapshotChanges([\n+      createRunExecutionData({ snapshotId: \"snapshot-suspended\", executionStatus: \"SUSPENDED\" }),\n+      createRunExecutionData({ snapshotId: \"snapshot-queued\", executionStatus: \"QUEUED\" }),\n+      createRunExecutionData({ snapshotId: \"snapshot-2\", executionStatus: \"PENDING_EXECUTING\" }),\n+    ]);\n+\n+    // First call should be deprecated=false (restore detected)\n+    expect(onSnapshotChange).toHaveBeenCalledWith(\n+      expect.objectContaining({ snapshot: expect.objectContaining({ friendlyId: \"snapshot-2\" }) }),\n+      false\n+    );\n+\n+    onSnapshotChange.mockClear();\n+\n+    // Second update: Should only get new snapshot (race condition case)\n+    // This simulates a stale poll that returns: getSnapshotsSince(snapshot-1) -> [SUSPENDED, QUEUED, snapshot-2, snapshot-3]\n+    // The SUSPENDED/QUEUED should be ignored as already seen\n+    await manager.handleSnapshotChanges([\n+      createRunExecutionData({ snapshotId: \"snapshot-suspended\", executionStatus: \"SUSPENDED\" }), // Already seen\n+      createRunExecutionData({ snapshotId: \"snapshot-queued\", executionStatus: \"QUEUED\" }), // Already seen\n+      createRunExecutionData({ snapshotId: \"snapshot-2\", executionStatus: \"PENDING_EXECUTING\" }), // Already processed\n+      createRunExecutionData({ snapshotId: \"snapshot-3\", executionStatus: \"EXECUTING\" }), // New\n+    ]);\n+\n+    // Should call onSnapshotChange with deprecated = false (no new deprecated snapshots)\n+    expect(onSnapshotChange).toHaveBeenCalledWith(\n+      expect.objectContaining({ snapshot: expect.objectContaining({ friendlyId: \"snapshot-3\" }) }),\n+      false\n+    );\n+  });\n });\n \n // Helper to generate RunExecutionData with sensible defaults\ndiff --git a/packages/cli-v3/src/entryPoints/managed/snapshot.ts b/packages/cli-v3/src/entryPoints/managed/snapshot.ts\nindex 75d3d4b036..9703ea8f87 100644\n--- a/packages/cli-v3/src/entryPoints/managed/snapshot.ts\n+++ b/packages/cli-v3/src/entryPoints/managed/snapshot.ts\n@@ -49,6 +49,10 @@ export class SnapshotManager {\n   private changeQueue: QueuedChangeItem[] = [];\n   private isProcessingQueue = false;\n \n+  // Track seen deprecated snapshots to prevent false positives\n+  private seenDeprecatedSnapshotIds: string[] = [];\n+  private readonly maxSeenDeprecatedSnapshotIds = 50;\n+\n   constructor(opts: SnapshotManagerOptions) {\n     this.runFriendlyId = opts.runFriendlyId;\n     this.runnerId = opts.runnerId;\n@@ -284,9 +288,13 @@ export class SnapshotManager {\n \n         // Check if any previous snapshot is QUEUED or SUSPENDED\n         const deprecatedStatus: TaskRunExecutionStatus[] = [\"QUEUED\", \"SUSPENDED\"];\n-        const deprecatedSnapshots = previousSnapshots.filter((snap) =>\n-          deprecatedStatus.includes(snap.snapshot.executionStatus)\n-        );\n+        const deprecatedSnapshots = previousSnapshots.filter((snap) => {\n+          const isDeprecated = deprecatedStatus.includes(snap.snapshot.executionStatus);\n+          const previouslySeen = this.seenDeprecatedSnapshotIds.some(\n+            (s) => s === snap.snapshot.friendlyId\n+          );\n+          return isDeprecated && !previouslySeen;\n+        });\n \n         let deprecated = false;\n         if (deprecatedSnapshots.length > 0) {\n@@ -298,6 +306,18 @@ export class SnapshotManager {\n           } else {\n             deprecated = true;\n           }\n+\n+          // Add the deprecated snapshot IDs to the seen list\n+          this.seenDeprecatedSnapshotIds.push(\n+            ...deprecatedSnapshots.map((s) => s.snapshot.friendlyId)\n+          );\n+\n+          if (this.seenDeprecatedSnapshotIds.length > this.maxSeenDeprecatedSnapshotIds) {\n+            // Only keep the latest maxSeenDeprecatedSnapshotIds\n+            this.seenDeprecatedSnapshotIds = this.seenDeprecatedSnapshotIds.slice(\n+              -this.maxSeenDeprecatedSnapshotIds\n+            );\n+          }\n         }\n \n         const { snapshot } = latestSnapshot;\ndiff --git a/packages/core/src/v3/runEngineWorker/workload/http.ts b/packages/core/src/v3/runEngineWorker/workload/http.ts\nindex 57c7f06e35..93fa7bf03c 100644\n--- a/packages/core/src/v3/runEngineWorker/workload/http.ts\n+++ b/packages/core/src/v3/runEngineWorker/workload/http.ts\n@@ -52,18 +52,58 @@ export class WorkloadHttpClient {\n     });\n   }\n \n+  private isConnectionError(error: string): boolean {\n+    const connectionErrors = [\n+      \"Connection error\",\n+      \"ECONNREFUSED\",\n+      \"ETIMEDOUT\",\n+      \"ENOTFOUND\",\n+      \"ECONNRESET\",\n+      \"EHOSTUNREACH\",\n+      \"ENETUNREACH\",\n+      \"EPIPE\",\n+      \"ECONNABORTED\",\n+    ];\n+    return connectionErrors.some((errType) => error.includes(errType));\n+  }\n+\n+  private async withConnectionErrorDetection<T>(\n+    operation: () => Promise<{ success: true; data: T } | { success: false; error: string }>\n+  ): Promise<\n+    { success: true; data: T } | { success: false; error: string; isConnectionError?: boolean }\n+  > {\n+    const result = await operation();\n+\n+    if (result.success) {\n+      return result;\n+    }\n+\n+    // Check if this is a connection error\n+    if (this.isConnectionError(result.error)) {\n+      return {\n+        ...result,\n+        isConnectionError: true,\n+      };\n+    }\n+\n+    return result;\n+  }\n+\n   async heartbeatRun(runId: string, snapshotId: string, body?: WorkloadHeartbeatRequestBody) {\n-    return wrapZodFetch(\n-      WorkloadHeartbeatResponseBody,\n-      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/heartbeat`,\n-      {\n-        method: \"POST\",\n-        headers: {\n-          ...this.defaultHeaders(),\n-          \"Content-Type\": \"application/json\",\n-        },\n-        body: JSON.stringify(body ?? {}),\n-      }\n+    return this.withConnectionErrorDetection(() =>\n+      wrapZodFetch(\n+        WorkloadHeartbeatResponseBody,\n+        `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/heartbeat`,\n+        {\n+          method: \"POST\",\n+          headers: {\n+            ...this.defaultHeaders(),\n+            \"Content-Type\": \"application/json\",\n+          },\n+          body: JSON.stringify(body ?? {}),\n+          signal: AbortSignal.timeout(10_000), // 10 second timeout\n+        }\n+      )\n     );\n   }\n \n@@ -81,15 +121,17 @@ export class WorkloadHttpClient {\n   }\n \n   async continueRunExecution(runId: string, snapshotId: string) {\n-    return wrapZodFetch(\n-      WorkloadContinueRunExecutionResponseBody,\n-      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/continue`,\n-      {\n-        method: \"GET\",\n-        headers: {\n-          ...this.defaultHeaders(),\n-        },\n-      }\n+    return this.withConnectionErrorDetection(() =>\n+      wrapZodFetch(\n+        WorkloadContinueRunExecutionResponseBody,\n+        `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/${snapshotId}/continue`,\n+        {\n+          method: \"GET\",\n+          headers: {\n+            ...this.defaultHeaders(),\n+          },\n+        }\n+      )\n     );\n   }\n \n@@ -130,15 +172,18 @@ export class WorkloadHttpClient {\n   }\n \n   async getSnapshotsSince(runId: string, snapshotId: string) {\n-    return wrapZodFetch(\n-      WorkloadRunSnapshotsSinceResponseBody,\n-      `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/since/${snapshotId}`,\n-      {\n-        method: \"GET\",\n-        headers: {\n-          ...this.defaultHeaders(),\n-        },\n-      }\n+    return this.withConnectionErrorDetection(() =>\n+      wrapZodFetch(\n+        WorkloadRunSnapshotsSinceResponseBody,\n+        `${this.apiUrl}/api/v1/workload-actions/runs/${runId}/snapshots/since/${snapshotId}`,\n+        {\n+          method: \"GET\",\n+          headers: {\n+            ...this.defaultHeaders(),\n+          },\n+          signal: AbortSignal.timeout(10_000), // 10 second timeout\n+        }\n+      )\n     );\n   }\n \n",
        "test_patch": "",
        "problem_statement": "",
        "hints_text": "",
        "pr_mirror": "triggerdotdev__trigger.dev.d1c3bfb9"
    }
}