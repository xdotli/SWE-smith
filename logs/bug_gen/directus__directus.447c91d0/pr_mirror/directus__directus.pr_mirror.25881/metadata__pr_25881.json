{
    "cost": 0.20594,
    "rewrites": {
        "directus__directus.447c91d0/api/src/services/items.test.ts": {
            "output": "import { SchemaBuilder } from '@directus/schema-builder';\nimport { UserIntegrityCheckFlag } from '@directus/types';\nimport knex, { type Knex } from 'knex';\nimport { MockClient, Tracker, createTracker } from 'knex-mock-client';\nimport { afterEach, beforeAll, beforeEach, describe, expect, it, vi, type MockedFunction } from 'vitest';\nimport { validateUserCountIntegrity } from '../utils/validate-user-count-integrity.js';\nimport { ItemsService } from './index.js';\n\nvi.mock('../../src/database/index', () => ({\n\tdefault: vi.fn(),\n\tgetDatabaseClient: vi.fn().mockReturnValue('postgres'),\n}));\n\nvi.mock('../utils/validate-user-count-integrity.js');\n\nconst schema = new SchemaBuilder()\n\t.collection('test', (c) => {\n\t\tc.field('id').id();\n\t})\n\t.collection('directus_versions', (c) => {\n\t\tc.field('id').id();\n\t\tc.field('item').string();\n\t\tc.field('collection').string();\n\t\tc.field('key').string();\n\t})\n\t.build();\n\ndescribe('Integration Tests', () => {\n\tlet db: MockedFunction<Knex>;\n\tlet tracker: Tracker;\n\n\tbeforeAll(async () => {\n\t\tdb = vi.mocked(knex.default({ client: MockClient }));\n\t\ttracker = createTracker(db);\n\t});\n\n\tbeforeEach(() => {\n\t\ttracker.on.any('test').response({});\n\t});\n\n\tafterEach(() => {\n\t\ttracker.reset();\n\t});\n\n\tdescribe('Services / Items', () => {\n\t\tlet service: ItemsService;\n\n\t\tbeforeEach(() => {\n\t\t\tservice = new ItemsService('test', {\n\t\t\t\tknex: db,\n\t\t\t\tschema,\n\t\t\t});\n\t\t});\n\n\t\tafterEach(() => {\n\t\t\tvi.clearAllMocks();\n\t\t});\n\n\t\tdescribe('createOne', () => {\n\t\t\tit('should validate user count if requested', async () => {\n\t\t\t\tawait service.createOne({}, { userIntegrityCheckFlags: UserIntegrityCheckFlag.All });\n\n\t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('createMany', () => {\n\t\t\tit('should validate user count if requested', async () => {\n\t\t\t\tawait service.createMany([{}], { userIntegrityCheckFlags: UserIntegrityCheckFlag.All });\n\n\t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('updateBatch', () => {\n\t\t\tit('should validate user count if requested', async () => {\n\t\t\t\tawait service.updateBatch([{ id: 1 }], { userIntegrityCheckFlags: UserIntegrityCheckFlag.All });\n\n\t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('updateMany', () => {\n\t\t\tit('should validate user count if requested', async () => {\n\t\t\t\tawait service.updateMany([1], {}, { userIntegrityCheckFlags: UserIntegrityCheckFlag.All });\n\n\t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('deleteMany', () => {\n\t\t\tit('should validate user count if requested', async () => {\n\t\t\t\tawait service.deleteMany([1], { userIntegrityCheckFlags: UserIntegrityCheckFlag.All });\n\n\t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n\t\t\t});\n\t\t});\n\t});\n});",
            "output_extracted": "import { SchemaBuilder } from '@directus/schema-builder';\nimport { UserIntegrityCheckFlag } from '@directus/types';\nimport knex, { type Knex } from 'knex';\nimport { MockClient, Tracker, createTracker } from 'knex-mock-client';\nimport { afterEach, beforeAll, beforeEach, describe, expect, it, vi, type MockedFunction } from 'vitest';\nimport { validateUserCountIntegrity } from '../utils/validate-user-count-integrity.js';\nimport { ItemsService } from './index.js';\n\nvi.mock('../../src/database/index', () => ({\n\tdefault: vi.fn(),\n\tgetDatabaseClient: vi.fn().mockReturnValue('postgres'),\n}));\n\nvi.mock('../utils/validate-user-count-integrity.js');\n\nconst schema = new SchemaBuilder()\n\t.collection('test', (c) => {\n\t\tc.field('id').id();\n\t})\n\t.collection('directus_versions', (c) => {\n\t\tc.field('id').id();\n\t\tc.field('item').string();\n\t\tc.field('collection').string();\n\t\tc.field('key').string();\n\t})\n\t.build();\n\ndescribe('Integration Tests', () => {\n\tlet db: MockedFunction<Knex>;\n\tlet tracker: Tracker;\n\n\tbeforeAll(async () => {\n\t\tdb = vi.mocked(knex.default({ client: MockClient }));\n\t\ttracker = createTracker(db);\n\t});\n\n\tbeforeEach(() => {\n\t\ttracker.on.any('test').response({});\n\t});\n\n\tafterEach(() => {\n\t\ttracker.reset();\n\t});\n\n\tdescribe('Services / Items', () => {\n\t\tlet service: ItemsService;\n\n\t\tbeforeEach(() => {\n\t\t\tservice = new ItemsService('test', {\n\t\t\t\tknex: db,\n\t\t\t\tschema,\n\t\t\t});\n\t\t});\n\n\t\tafterEach(() => {\n\t\t\tvi.clearAllMocks();\n\t\t});\n\n\t\tdescribe('createOne', () => {\n\t\t\tit('should validate user count if requested', async () => {\n\t\t\t\tawait service.createOne({}, { userIntegrityCheckFlags: UserIntegrityCheckFlag.All });\n\n\t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('createMany', () => {\n\t\t\tit('should validate user count if requested', async () => {\n\t\t\t\tawait service.createMany([{}], { userIntegrityCheckFlags: UserIntegrityCheckFlag.All });\n\n\t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('updateBatch', () => {\n\t\t\tit('should validate user count if requested', async () => {\n\t\t\t\tawait service.updateBatch([{ id: 1 }], { userIntegrityCheckFlags: UserIntegrityCheckFlag.All });\n\n\t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('updateMany', () => {\n\t\t\tit('should validate user count if requested', async () => {\n\t\t\t\tawait service.updateMany([1], {}, { userIntegrityCheckFlags: UserIntegrityCheckFlag.All });\n\n\t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('deleteMany', () => {\n\t\t\tit('should validate user count if requested', async () => {\n\t\t\t\tawait service.deleteMany([1], { userIntegrityCheckFlags: UserIntegrityCheckFlag.All });\n\n\t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n\t\t\t});\n\t\t});\n\t});\n});",
            "cost": 0.03896
        },
        "directus__directus.447c91d0/api/src/services/items.ts": {
            "output": "import { Action } from '@directus/constants';\nimport { useEnv } from '@directus/env';\nimport { ErrorCode, ForbiddenError, InvalidPayloadError, isDirectusError } from '@directus/errors';\nimport { isSystemCollection } from '@directus/system-data';\nimport type {\n\tAbstractService,\n\tAbstractServiceOptions,\n\tAccountability,\n\tActionEventParams,\n\tItem as AnyItem,\n\tMutationOptions,\n\tMutationTracker,\n\tPrimaryKey,\n\tQuery,\n\tQueryOptions,\n\tSchemaOverview,\n} from '@directus/types';\nimport { UserIntegrityCheckFlag } from '@directus/types';\nimport type Keyv from 'keyv';\nimport type { Knex } from 'knex';\nimport { assign, clone, cloneDeep, omit, pick, without } from 'lodash-es';\nimport { getCache } from '../cache.js';\nimport { translateDatabaseError } from '../database/errors/translate.js';\nimport { getAstFromQuery } from '../database/get-ast-from-query/get-ast-from-query.js';\nimport { getHelpers } from '../database/helpers/index.js';\nimport getDatabase from '../database/index.js';\nimport { runAst } from '../database/run-ast/run-ast.js';\nimport emitter from '../emitter.js';\nimport { processAst } from '../permissions/modules/process-ast/process-ast.js';\nimport { processPayload } from '../permissions/modules/process-payload/process-payload.js';\nimport { validateAccess } from '../permissions/modules/validate-access/validate-access.js';\nimport { shouldClearCache } from '../utils/should-clear-cache.js';\nimport { transaction } from '../utils/transaction.js';\nimport { validateKeys } from '../utils/validate-keys.js';\nimport { validateUserCountIntegrity } from '../utils/validate-user-count-integrity.js';\nimport { handleVersion } from '../utils/versioning/handle-version.js';\nimport { PayloadService } from './payload.js';\n\nconst env = useEnv();\n\nexport class ItemsService<Item extends AnyItem = AnyItem, Collection extends string = string>\n\timplements AbstractService<Item>\n{\n\tcollection: Collection;\n\tknex: Knex;\n\taccountability: Accountability | null;\n\teventScope: string;\n\tschema: SchemaOverview;\n\tcache: Keyv<any> | null;\n\tnested: string[];\n\n\tconstructor(collection: Collection, options: AbstractServiceOptions) {\n\t\tthis.collection = collection;\n\t\tthis.knex = options.knex || getDatabase();\n\t\tthis.accountability = options.accountability || null;\n\t\tthis.eventScope = isSystemCollection(this.collection) ? this.collection.substring(9) : 'items';\n\t\tthis.schema = options.schema;\n\t\tthis.cache = getCache().cache;\n\t\tthis.nested = options.nested ?? [];\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Create a fork of the current service, allowing instantiation with different options.\n\t */\n\tprivate fork(options?: Partial<AbstractServiceOptions>): ItemsService<AnyItem> {\n\t\tconst Service = this.constructor;\n\n\t\t// ItemsService expects `collection` and `options` as parameters,\n\t\t// while the other services only expect `options`\n\t\tconst isItemsService = Service.length === 2;\n\n\t\tconst newOptions = {\n\t\t\tknex: this.knex,\n\t\t\taccountability: this.accountability,\n\t\t\tschema: this.schema,\n\t\t\tnested: this.nested,\n\t\t\t...options,\n\t\t};\n\n\t\tif (isItemsService) {\n\t\t\treturn new ItemsService(this.collection, newOptions);\n\t\t}\n\n\t\treturn new (Service as new (options: AbstractServiceOptions) => this)(newOptions);\n\t}\n\n\tcreateMutationTracker(initialCount = 0): MutationTracker {\n\t\tconst maxCount = Number(env['MAX_BATCH_MUTATION']);\n\t\tlet mutationCount = initialCount;\n\t\treturn {\n\t\t\ttrackMutations(count: number) {\n\t\t\t\tmutationCount += count;\n\n\t\t\t\tif (mutationCount > maxCount) {\n\t\t\t\t\tthrow new InvalidPayloadError({ reason: `Exceeded max batch mutation limit of ${maxCount}` });\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetCount() {\n\t\t\t\treturn mutationCount;\n\t\t\t},\n\t\t};\n\t}\n\n\tasync getKeysByQuery(query: Query): Promise<PrimaryKey[]> {\n\t\tconst primaryKeyField = this.schema.collections[this.collection]!.primary;\n\t\tconst readQuery = cloneDeep(query);\n\t\treadQuery.fields = [primaryKeyField];\n\n\t\t// Allow unauthenticated access\n\t\tconst itemsService = new ItemsService(this.collection, {\n\t\t\tknex: this.knex,\n\t\t\tschema: this.schema,\n\t\t});\n\n\t\t// We read the IDs of the items based on the query, and then run `updateMany`. `updateMany` does it's own\n\t\t// permissions check for the keys, so we don't have to make this an authenticated read\n\t\tconst items = await itemsService.readByQuery(readQuery);\n\t\treturn items.map((item: AnyItem) => item[primaryKeyField]).filter((pk) => pk);\n\t}\n\n\t/**\n\t * Create a single new item.\n\t */\n\tasync createOne(data: Partial<Item>, opts: MutationOptions = {}): Promise<PrimaryKey> {\n\t\tif (!opts.mutationTracker) opts.mutationTracker = this.createMutationTracker();\n\n\t\tif (!opts.bypassLimits) {\n\t\t\topts.mutationTracker.trackMutations(1);\n\t\t}\n\n\t\tconst primaryKeyField = this.schema.collections[this.collection]!.primary;\n\t\tconst fields = Object.keys(this.schema.collections[this.collection]!.fields);\n\n\t\tconst aliases = Object.values(this.schema.collections[this.collection]!.fields)\n\t\t\t.filter((field) => field.alias === true)\n\t\t\t.map((field) => field.field);\n\n\t\tconst payload: AnyItem = cloneDeep(data);\n\t\tlet actionHookPayload = payload;\n\t\tconst nestedActionEvents: ActionEventParams[] = [];\n\n\t\t/**\n\t\t * By wrapping the logic in a transaction, we make sure we automatically roll back all the\n\t\t * changes in the DB if any of the parts contained within throws an error. This also means\n\t\t * that any errors thrown in any nested relational changes will bubble up and cancel the whole\n\t\t * update tree\n\t\t */\n\t\tconst primaryKey: PrimaryKey = await transaction(this.knex, async (trx) => {\n\t\t\t// Run all hooks that are attached to this event so the end user has the chance to augment the\n\t\t\t// item that is about to be saved\n\t\t\tconst payloadAfterHooks =\n\t\t\t\topts.emitEvents !== false\n\t\t\t\t\t? await emitter.emitFilter(\n\t\t\t\t\t\t\tthis.eventScope === 'items'\n\t\t\t\t\t\t\t\t? ['items.create', `${this.collection}.items.create`]\n\t\t\t\t\t\t\t\t: `${this.eventScope}.create`,\n\t\t\t\t\t\t\tpayload,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcollection: this.collection,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdatabase: trx,\n\t\t\t\t\t\t\t\tschema: this.schema,\n\t\t\t\t\t\t\t\taccountability: this.accountability,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)\n\t\t\t\t\t: payload;\n\n\t\t\tconst payloadWithPresets = this.accountability\n\t\t\t\t? await processPayload(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taccountability: this.accountability,\n\t\t\t\t\t\t\taction: 'create',\n\t\t\t\t\t\t\tcollection: this.collection,\n\t\t\t\t\t\t\tpayload: payloadAfterHooks,\n\t\t\t\t\t\t\tnested: this.nested,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tknex: trx,\n\t\t\t\t\t\t\tschema: this.schema,\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t: payloadAfterHooks;\n\n\t\t\tif (opts.preMutationError) {\n\t\t\t\tthrow opts.preMutationError;\n\t\t\t}\n\n\t\t\t// Ensure the action hook payload has the post filter hook + preset changes\n\t\t\tactionHookPayload = payloadWithPresets;\n\n\t\t\t// We're creating new services instances so they can use the transaction as their Knex interface\n\t\t\tconst payloadService = new PayloadService(this.collection, {\n\t\t\t\taccountability: this.accountability,\n\t\t\t\tknex: trx,\n\t\t\t\tschema: this.schema,\n\t\t\t\tnested: this.nested,\n\t\t\t\toverwriteDefaults: opts.overwriteDefaults,\n\t\t\t});\n\n\t\t\tconst {\n\t\t\t\tpayload: payloadWithM2O,\n\t\t\t\trevisions: revisionsM2O,\n\t\t\t\tnestedActionEvents: nestedActionEventsM2O,\n\t\t\t\tuserIntegrityCheckFlags: userIntegrityCheckFlagsM2O,\n\t\t\t} = await payloadService.processM2O(payloadWithPresets, opts);\n\n\t\t\tconst {\n\t\t\t\tpayload: payloadWithA2O,\n\t\t\t\trevisions: revisionsA2O,\n\t\t\t\tnestedActionEvents: nestedActionEventsA2O,\n\t\t\t\tuserIntegrityCheckFlags: userIntegrityCheckFlagsA2O,\n\t\t\t} = await payloadService.processA2O(payloadWithM2O, opts);\n\n\t\t\tconst payloadWithoutAliases = pick(payloadWithA2O, without(fields, ...aliases));\n\t\t\tconst payloadWithTypeCasting = await payloadService.processValues('create', payloadWithoutAliases);\n\n\t\t\t// The primary key can already exist in the payload.\n\t\t\t// In case of manual string / UUID primary keys it's always provided at this point.\n\t\t\t// In case of an (big) integer primary key, it might be provided as the user can specify the value manually.\n\t\t\tlet primaryKey: undefined | PrimaryKey = payloadWithTypeCasting[primaryKeyField];\n\n\t\t\tif (primaryKey) {\n\t\t\t\tvalidateKeys(this.schema, this.collection, primaryKeyField, primaryKey);\n\t\t\t}\n\n\t\t\t// If a PK of type number was provided, although the PK is set the auto_increment,\n\t\t\t// depending on the database, the sequence might need to be reset to protect future PK collisions.\n\t\t\tlet autoIncrementSequenceNeedsToBeReset = false;\n\n\t\t\tconst pkField = this.schema.collections[this.collection]!.fields[primaryKeyField];\n\n\t\t\tif (\n\t\t\t\tprimaryKey &&\n\t\t\t\tpkField &&\n\t\t\t\t!opts.bypassAutoIncrementSequenceReset &&\n\t\t\t\t['integer', 'bigInteger'].includes(pkField.type) &&\n\t\t\t\tpkField.defaultValue === 'AUTO_INCREMENT'\n\t\t\t) {\n\t\t\t\tautoIncrementSequenceNeedsToBeReset = true;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst result = await trx\n\t\t\t\t\t.insert(payloadWithoutAliases)\n\t\t\t\t\t.into(this.collection)\n\t\t\t\t\t.returning(primaryKeyField)\n\t\t\t\t\t.then((result) => result[0]);\n\n\t\t\t\tconst returnedKey = typeof result === 'object' ? result[primaryKeyField] : result;\n\n\t\t\t\tif (pkField!.type === 'uuid') {\n\t\t\t\t\tprimaryKey = getHelpers(trx).schema.formatUUID(primaryKey ?? returnedKey);\n\t\t\t\t} else {\n\t\t\t\t\tprimaryKey = primaryKey ?? returnedKey;\n\t\t\t\t}\n\t\t\t} catch (err: any) {\n\t\t\t\tconst dbError = await translateDatabaseError(err, data);\n\n\t\t\t\tif (isDirectusError(dbError, ErrorCode.RecordNotUnique) && dbError.extensions.primaryKey) {\n\t\t\t\t\t// This is a MySQL specific thing we need to handle here, since MySQL does not return the field name\n\t\t\t\t\t// if the unique constraint is the primary key\n\t\t\t\t\tdbError.extensions.field = pkField?.field ?? null;\n\n\t\t\t\t\tdelete dbError.extensions.primaryKey;\n\t\t\t\t}\n\n\t\t\t\tthrow dbError;\n\t\t\t}\n\n\t\t\t// Most database support returning, those who don't tend to return the PK anyways\n\t\t\t// (MySQL/SQLite). In case the primary key isn't know yet, we'll do a best-attempt at\n\t\t\t// fetching it based on the last inserted row\n\t\t\tif (!primaryKey) {\n\t\t\t\t// Fetching it with max should be safe, as we're in the context of the current transaction\n\t\t\t\tconst result = await trx.max(primaryKeyField, { as: 'id' }).from(this.collection).first();\n\t\t\t\tprimaryKey = result.id;\n\n\t\t\t\t// Set the primary key on the input item, in order for the \"after\" event hook to be able\n\t\t\t\t// to read from it\n\t\t\t\tactionHookPayload[primaryKeyField] = primaryKey;\n\t\t\t}\n\n\t\t\t// At this point, the primary key is guaranteed to be set.\n\t\t\tprimaryKey = primaryKey as PrimaryKey;\n\n\t\t\tconst {\n\t\t\t\trevisions: revisionsO2M,\n\t\t\t\tnestedActionEvents: nestedActionEventsO2M,\n\t\t\t\tuserIntegrityCheckFlags: userIntegrityCheckFlagsO2M,\n\t\t\t} = await payloadService.processO2M(payloadWithPresets, primaryKey, opts);\n\n\t\t\tnestedActionEvents.push(...nestedActionEventsM2O);\n\t\t\tnestedActionEvents.push(...nestedActionEventsA2O);\n\t\t\tnestedActionEvents.push(...nestedActionEventsO2M);\n\n\t\t\tconst userIntegrityCheckFlags =\n\t\t\t\t(opts.userIntegrityCheckFlags ?? UserIntegrityCheckFlag.None) |\n\t\t\t\tuserIntegrityCheckFlagsM2O |\n\t\t\t\tuserIntegrityCheckFlagsA2O |\n\t\t\t\tuserIntegrityCheckFlagsO2M;\n\n\t\t\tif (userIntegrityCheckFlags) {\n\t\t\t\tif (opts.onRequireUserIntegrityCheck) {\n\t\t\t\t\topts.onRequireUserIntegrityCheck(userIntegrityCheckFlags);\n\t\t\t\t} else {\n\t\t\t\t\tawait validateUserCountIntegrity({ flags: userIntegrityCheckFlags, knex: trx });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this is an authenticated action, and accountability tracking is enabled, save activity row\n\t\t\tif (\n\t\t\t\topts.skipTracking !== true &&\n\t\t\t\tthis.accountability &&\n\t\t\t\tthis.schema.collections[this.collection]!.accountability !== null\n\t\t\t) {\n\t\t\t\tconst { ActivityService } = await import('./activity.js');\n\t\t\t\tconst { RevisionsService } = await import('./revisions.js');\n\n\t\t\t\tconst activityService = new ActivityService({\n\t\t\t\t\tknex: trx,\n\t\t\t\t\tschema: this.schema,\n\t\t\t\t});\n\n\t\t\t\tconst activity = await activityService.createOne({\n\t\t\t\t\taction: Action.CREATE,\n\t\t\t\t\tuser: this.accountability!.user,\n\t\t\t\t\tcollection: this.collection,\n\t\t\t\t\tip: this.accountability!.ip,\n\t\t\t\t\tuser_agent: this.accountability!.userAgent,\n\t\t\t\t\torigin: this.accountability!.origin,\n\t\t\t\t\titem: primaryKey,\n\t\t\t\t});\n\n\t\t\t\t// If revisions are tracked, create revisions record\n\t\t\t\tif (this.schema.collections[this.collection]!.accountability === 'all') {\n\t\t\t\t\tconst revisionsService = new RevisionsService({\n\t\t\t\t\t\tknex: trx,\n\t\t\t\t\t\tschema: this.schema,\n\t\t\t\t\t});\n\n\t\t\t\t\tconst revisionDelta = await payloadService.prepareDelta(payloadAfterHooks);\n\n\t\t\t\t\tconst revision = await revisionsService.createOne({\n\t\t\t\t\t\tactivity: activity,\n\t\t\t\t\t\tcollection: this.collection,\n\t\t\t\t\t\titem: primaryKey,\n\t\t\t\t\t\tdata: revisionDelta,\n\t\t\t\t\t\tdelta: revisionDelta,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Make sure to set the parent field of the child-revision rows\n\t\t\t\t\tconst childrenRevisions = [...revisionsM2O, ...revisionsA2O, ...revisionsO2M];\n\n\t\t\t\t\tif (childrenRevisions.length > 0) {\n\t\t\t\t\t\tawait revisionsService.updateMany(childrenRevisions, { parent: revision });\n\t\t\t\t\t}\n\n\t\t\t\t\tif (opts.onRevisionCreate) {\n\t\t\t\t\t\topts.onRevisionCreate(revision);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (autoIncrementSequenceNeedsToBeReset) {\n\t\t\t\tawait getHelpers(trx).sequence.resetAutoIncrementSequence(this.collection, primaryKeyField);\n\t\t\t}\n\n\t\t\tif (opts.onItemCreate) {\n\t\t\t\topts.onItemCreate(this.collection, primaryKey);\n\t\t\t}\n\n\t\t\treturn primaryKey;\n\t\t});\n\n\t\tif (opts.emitEvents !== false) {\n\t\t\tconst actionEvent = {\n\t\t\t\tevent:\n\t\t\t\t\tthis.eventScope === 'items'\n\t\t\t\t\t\t? ['items.create', `${this.collection}.items.create`]\n\t\t\t\t\t\t: `${this.eventScope}.create`,\n\t\t\t\tmeta: {\n\t\t\t\t\tpayload: actionHookPayload,\n\t\t\t\t\tkey: primaryKey,\n\t\t\t\t\tcollection: this.collection,\n\t\t\t\t},\n\t\t\t\tcontext: {\n\t\t\t\t\tdatabase: getDatabase(),\n\t\t\t\t\tschema: this.schema,\n\t\t\t\t\taccountability: this.accountability,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (opts.bypassEmitAction) {\n\t\t\t\topts.bypassEmitAction(actionEvent);\n\t\t\t} else {\n\t\t\t\temitter.emitAction(actionEvent.event, actionEvent.meta, actionEvent.context);\n\t\t\t}\n\n\t\t\tfor (const nestedActionEvent of nestedActionEvents) {\n\t\t\t\tif (opts",
            "output_extracted": "import { Action } from '@directus/constants';\nimport { useEnv } from '@directus/env';\nimport { ErrorCode, ForbiddenError, InvalidPayloadError, isDirectusError } from '@directus/errors';\nimport { isSystemCollection } from '@directus/system-data';\nimport type {\n\tAbstractService,\n\tAbstractServiceOptions,\n\tAccountability,\n\tActionEventParams,\n\tItem as AnyItem,\n\tMutationOptions,\n\tMutationTracker,\n\tPrimaryKey,\n\tQuery,\n\tQueryOptions,\n\tSchemaOverview,\n} from '@directus/types';\nimport { UserIntegrityCheckFlag } from '@directus/types';\nimport type Keyv from 'keyv';\nimport type { Knex } from 'knex';\nimport { assign, clone, cloneDeep, omit, pick, without } from 'lodash-es';\nimport { getCache } from '../cache.js';\nimport { translateDatabaseError } from '../database/errors/translate.js';\nimport { getAstFromQuery } from '../database/get-ast-from-query/get-ast-from-query.js';\nimport { getHelpers } from '../database/helpers/index.js';\nimport getDatabase from '../database/index.js';\nimport { runAst } from '../database/run-ast/run-ast.js';\nimport emitter from '../emitter.js';\nimport { processAst } from '../permissions/modules/process-ast/process-ast.js';\nimport { processPayload } from '../permissions/modules/process-payload/process-payload.js';\nimport { validateAccess } from '../permissions/modules/validate-access/validate-access.js';\nimport { shouldClearCache } from '../utils/should-clear-cache.js';\nimport { transaction } from '../utils/transaction.js';\nimport { validateKeys } from '../utils/validate-keys.js';\nimport { validateUserCountIntegrity } from '../utils/validate-user-count-integrity.js';\nimport { handleVersion } from '../utils/versioning/handle-version.js';\nimport { PayloadService } from './payload.js';\n\nconst env = useEnv();\n\nexport class ItemsService<Item extends AnyItem = AnyItem, Collection extends string = string>\n\timplements AbstractService<Item>\n{\n\tcollection: Collection;\n\tknex: Knex;\n\taccountability: Accountability | null;\n\teventScope: string;\n\tschema: SchemaOverview;\n\tcache: Keyv<any> | null;\n\tnested: string[];\n\n\tconstructor(collection: Collection, options: AbstractServiceOptions) {\n\t\tthis.collection = collection;\n\t\tthis.knex = options.knex || getDatabase();\n\t\tthis.accountability = options.accountability || null;\n\t\tthis.eventScope = isSystemCollection(this.collection) ? this.collection.substring(9) : 'items';\n\t\tthis.schema = options.schema;\n\t\tthis.cache = getCache().cache;\n\t\tthis.nested = options.nested ?? [];\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Create a fork of the current service, allowing instantiation with different options.\n\t */\n\tprivate fork(options?: Partial<AbstractServiceOptions>): ItemsService<AnyItem> {\n\t\tconst Service = this.constructor;\n\n\t\t// ItemsService expects `collection` and `options` as parameters,\n\t\t// while the other services only expect `options`\n\t\tconst isItemsService = Service.length === 2;\n\n\t\tconst newOptions = {\n\t\t\tknex: this.knex,\n\t\t\taccountability: this.accountability,\n\t\t\tschema: this.schema,\n\t\t\tnested: this.nested,\n\t\t\t...options,\n\t\t};\n\n\t\tif (isItemsService) {\n\t\t\treturn new ItemsService(this.collection, newOptions);\n\t\t}\n\n\t\treturn new (Service as new (options: AbstractServiceOptions) => this)(newOptions);\n\t}\n\n\tcreateMutationTracker(initialCount = 0): MutationTracker {\n\t\tconst maxCount = Number(env['MAX_BATCH_MUTATION']);\n\t\tlet mutationCount = initialCount;\n\t\treturn {\n\t\t\ttrackMutations(count: number) {\n\t\t\t\tmutationCount += count;\n\n\t\t\t\tif (mutationCount > maxCount) {\n\t\t\t\t\tthrow new InvalidPayloadError({ reason: `Exceeded max batch mutation limit of ${maxCount}` });\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetCount() {\n\t\t\t\treturn mutationCount;\n\t\t\t},\n\t\t};\n\t}\n\n\tasync getKeysByQuery(query: Query): Promise<PrimaryKey[]> {\n\t\tconst primaryKeyField = this.schema.collections[this.collection]!.primary;\n\t\tconst readQuery = cloneDeep(query);\n\t\treadQuery.fields = [primaryKeyField];\n\n\t\t// Allow unauthenticated access\n\t\tconst itemsService = new ItemsService(this.collection, {\n\t\t\tknex: this.knex,\n\t\t\tschema: this.schema,\n\t\t});\n\n\t\t// We read the IDs of the items based on the query, and then run `updateMany`. `updateMany` does it's own\n\t\t// permissions check for the keys, so we don't have to make this an authenticated read\n\t\tconst items = await itemsService.readByQuery(readQuery);\n\t\treturn items.map((item: AnyItem) => item[primaryKeyField]).filter((pk) => pk);\n\t}\n\n\t/**\n\t * Create a single new item.\n\t */\n\tasync createOne(data: Partial<Item>, opts: MutationOptions = {}): Promise<PrimaryKey> {\n\t\tif (!opts.mutationTracker) opts.mutationTracker = this.createMutationTracker();\n\n\t\tif (!opts.bypassLimits) {\n\t\t\topts.mutationTracker.trackMutations(1);\n\t\t}\n\n\t\tconst primaryKeyField = this.schema.collections[this.collection]!.primary;\n\t\tconst fields = Object.keys(this.schema.collections[this.collection]!.fields);\n\n\t\tconst aliases = Object.values(this.schema.collections[this.collection]!.fields)\n\t\t\t.filter((field) => field.alias === true)\n\t\t\t.map((field) => field.field);\n\n\t\tconst payload: AnyItem = cloneDeep(data);\n\t\tlet actionHookPayload = payload;\n\t\tconst nestedActionEvents: ActionEventParams[] = [];\n\n\t\t/**\n\t\t * By wrapping the logic in a transaction, we make sure we automatically roll back all the\n\t\t * changes in the DB if any of the parts contained within throws an error. This also means\n\t\t * that any errors thrown in any nested relational changes will bubble up and cancel the whole\n\t\t * update tree\n\t\t */\n\t\tconst primaryKey: PrimaryKey = await transaction(this.knex, async (trx) => {\n\t\t\t// Run all hooks that are attached to this event so the end user has the chance to augment the\n\t\t\t// item that is about to be saved\n\t\t\tconst payloadAfterHooks =\n\t\t\t\topts.emitEvents !== false\n\t\t\t\t\t? await emitter.emitFilter(\n\t\t\t\t\t\t\tthis.eventScope === 'items'\n\t\t\t\t\t\t\t\t? ['items.create', `${this.collection}.items.create`]\n\t\t\t\t\t\t\t\t: `${this.eventScope}.create`,\n\t\t\t\t\t\t\tpayload,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcollection: this.collection,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdatabase: trx,\n\t\t\t\t\t\t\t\tschema: this.schema,\n\t\t\t\t\t\t\t\taccountability: this.accountability,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)\n\t\t\t\t\t: payload;\n\n\t\t\tconst payloadWithPresets = this.accountability\n\t\t\t\t? await processPayload(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taccountability: this.accountability,\n\t\t\t\t\t\t\taction: 'create',\n\t\t\t\t\t\t\tcollection: this.collection,\n\t\t\t\t\t\t\tpayload: payloadAfterHooks,\n\t\t\t\t\t\t\tnested: this.nested,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tknex: trx,\n\t\t\t\t\t\t\tschema: this.schema,\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t: payloadAfterHooks;\n\n\t\t\tif (opts.preMutationError) {\n\t\t\t\tthrow opts.preMutationError;\n\t\t\t}\n\n\t\t\t// Ensure the action hook payload has the post filter hook + preset changes\n\t\t\tactionHookPayload = payloadWithPresets;\n\n\t\t\t// We're creating new services instances so they can use the transaction as their Knex interface\n\t\t\tconst payloadService = new PayloadService(this.collection, {\n\t\t\t\taccountability: this.accountability,\n\t\t\t\tknex: trx,\n\t\t\t\tschema: this.schema,\n\t\t\t\tnested: this.nested,\n\t\t\t\toverwriteDefaults: opts.overwriteDefaults,\n\t\t\t});\n\n\t\t\tconst {\n\t\t\t\tpayload: payloadWithM2O,\n\t\t\t\trevisions: revisionsM2O,\n\t\t\t\tnestedActionEvents: nestedActionEventsM2O,\n\t\t\t\tuserIntegrityCheckFlags: userIntegrityCheckFlagsM2O,\n\t\t\t} = await payloadService.processM2O(payloadWithPresets, opts);\n\n\t\t\tconst {\n\t\t\t\tpayload: payloadWithA2O,\n\t\t\t\trevisions: revisionsA2O,\n\t\t\t\tnestedActionEvents: nestedActionEventsA2O,\n\t\t\t\tuserIntegrityCheckFlags: userIntegrityCheckFlagsA2O,\n\t\t\t} = await payloadService.processA2O(payloadWithM2O, opts);\n\n\t\t\tconst payloadWithoutAliases = pick(payloadWithA2O, without(fields, ...aliases));\n\t\t\tconst payloadWithTypeCasting = await payloadService.processValues('create', payloadWithoutAliases);\n\n\t\t\t// The primary key can already exist in the payload.\n\t\t\t// In case of manual string / UUID primary keys it's always provided at this point.\n\t\t\t// In case of an (big) integer primary key, it might be provided as the user can specify the value manually.\n\t\t\tlet primaryKey: undefined | PrimaryKey = payloadWithTypeCasting[primaryKeyField];\n\n\t\t\tif (primaryKey) {\n\t\t\t\tvalidateKeys(this.schema, this.collection, primaryKeyField, primaryKey);\n\t\t\t}\n\n\t\t\t// If a PK of type number was provided, although the PK is set the auto_increment,\n\t\t\t// depending on the database, the sequence might need to be reset to protect future PK collisions.\n\t\t\tlet autoIncrementSequenceNeedsToBeReset = false;\n\n\t\t\tconst pkField = this.schema.collections[this.collection]!.fields[primaryKeyField];\n\n\t\t\tif (\n\t\t\t\tprimaryKey &&\n\t\t\t\tpkField &&\n\t\t\t\t!opts.bypassAutoIncrementSequenceReset &&\n\t\t\t\t['integer', 'bigInteger'].includes(pkField.type) &&\n\t\t\t\tpkField.defaultValue === 'AUTO_INCREMENT'\n\t\t\t) {\n\t\t\t\tautoIncrementSequenceNeedsToBeReset = true;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst result = await trx\n\t\t\t\t\t.insert(payloadWithoutAliases)\n\t\t\t\t\t.into(this.collection)\n\t\t\t\t\t.returning(primaryKeyField)\n\t\t\t\t\t.then((result) => result[0]);\n\n\t\t\t\tconst returnedKey = typeof result === 'object' ? result[primaryKeyField] : result;\n\n\t\t\t\tif (pkField!.type === 'uuid') {\n\t\t\t\t\tprimaryKey = getHelpers(trx).schema.formatUUID(primaryKey ?? returnedKey);\n\t\t\t\t} else {\n\t\t\t\t\tprimaryKey = primaryKey ?? returnedKey;\n\t\t\t\t}\n\t\t\t} catch (err: any) {\n\t\t\t\tconst dbError = await translateDatabaseError(err, data);\n\n\t\t\t\tif (isDirectusError(dbError, ErrorCode.RecordNotUnique) && dbError.extensions.primaryKey) {\n\t\t\t\t\t// This is a MySQL specific thing we need to handle here, since MySQL does not return the field name\n\t\t\t\t\t// if the unique constraint is the primary key\n\t\t\t\t\tdbError.extensions.field = pkField?.field ?? null;\n\n\t\t\t\t\tdelete dbError.extensions.primaryKey;\n\t\t\t\t}\n\n\t\t\t\tthrow dbError;\n\t\t\t}\n\n\t\t\t// Most database support returning, those who don't tend to return the PK anyways\n\t\t\t// (MySQL/SQLite). In case the primary key isn't know yet, we'll do a best-attempt at\n\t\t\t// fetching it based on the last inserted row\n\t\t\tif (!primaryKey) {\n\t\t\t\t// Fetching it with max should be safe, as we're in the context of the current transaction\n\t\t\t\tconst result = await trx.max(primaryKeyField, { as: 'id' }).from(this.collection).first();\n\t\t\t\tprimaryKey = result.id;\n\n\t\t\t\t// Set the primary key on the input item, in order for the \"after\" event hook to be able\n\t\t\t\t// to read from it\n\t\t\t\tactionHookPayload[primaryKeyField] = primaryKey;\n\t\t\t}\n\n\t\t\t// At this point, the primary key is guaranteed to be set.\n\t\t\tprimaryKey = primaryKey as PrimaryKey;\n\n\t\t\tconst {\n\t\t\t\trevisions: revisionsO2M,\n\t\t\t\tnestedActionEvents: nestedActionEventsO2M,\n\t\t\t\tuserIntegrityCheckFlags: userIntegrityCheckFlagsO2M,\n\t\t\t} = await payloadService.processO2M(payloadWithPresets, primaryKey, opts);\n\n\t\t\tnestedActionEvents.push(...nestedActionEventsM2O);\n\t\t\tnestedActionEvents.push(...nestedActionEventsA2O);\n\t\t\tnestedActionEvents.push(...nestedActionEventsO2M);\n\n\t\t\tconst userIntegrityCheckFlags =\n\t\t\t\t(opts.userIntegrityCheckFlags ?? UserIntegrityCheckFlag.None) |\n\t\t\t\tuserIntegrityCheckFlagsM2O |\n\t\t\t\tuserIntegrityCheckFlagsA2O |\n\t\t\t\tuserIntegrityCheckFlagsO2M;\n\n\t\t\tif (userIntegrityCheckFlags) {\n\t\t\t\tif (opts.onRequireUserIntegrityCheck) {\n\t\t\t\t\topts.onRequireUserIntegrityCheck(userIntegrityCheckFlags);\n\t\t\t\t} else {\n\t\t\t\t\tawait validateUserCountIntegrity({ flags: userIntegrityCheckFlags, knex: trx });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this is an authenticated action, and accountability tracking is enabled, save activity row\n\t\t\tif (\n\t\t\t\topts.skipTracking !== true &&\n\t\t\t\tthis.accountability &&\n\t\t\t\tthis.schema.collections[this.collection]!.accountability !== null\n\t\t\t) {\n\t\t\t\tconst { ActivityService } = await import('./activity.js');\n\t\t\t\tconst { RevisionsService } = await import('./revisions.js');\n\n\t\t\t\tconst activityService = new ActivityService({\n\t\t\t\t\tknex: trx,\n\t\t\t\t\tschema: this.schema,\n\t\t\t\t});\n\n\t\t\t\tconst activity = await activityService.createOne({\n\t\t\t\t\taction: Action.CREATE,\n\t\t\t\t\tuser: this.accountability!.user,\n\t\t\t\t\tcollection: this.collection,\n\t\t\t\t\tip: this.accountability!.ip,\n\t\t\t\t\tuser_agent: this.accountability!.userAgent,\n\t\t\t\t\torigin: this.accountability!.origin,\n\t\t\t\t\titem: primaryKey,\n\t\t\t\t});\n\n\t\t\t\t// If revisions are tracked, create revisions record\n\t\t\t\tif (this.schema.collections[this.collection]!.accountability === 'all') {\n\t\t\t\t\tconst revisionsService = new RevisionsService({\n\t\t\t\t\t\tknex: trx,\n\t\t\t\t\t\tschema: this.schema,\n\t\t\t\t\t});\n\n\t\t\t\t\tconst revisionDelta = await payloadService.prepareDelta(payloadAfterHooks);\n\n\t\t\t\t\tconst revision = await revisionsService.createOne({\n\t\t\t\t\t\tactivity: activity,\n\t\t\t\t\t\tcollection: this.collection,\n\t\t\t\t\t\titem: primaryKey,\n\t\t\t\t\t\tdata: revisionDelta,\n\t\t\t\t\t\tdelta: revisionDelta,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Make sure to set the parent field of the child-revision rows\n\t\t\t\t\tconst childrenRevisions = [...revisionsM2O, ...revisionsA2O, ...revisionsO2M];\n\n\t\t\t\t\tif (childrenRevisions.length > 0) {\n\t\t\t\t\t\tawait revisionsService.updateMany(childrenRevisions, { parent: revision });\n\t\t\t\t\t}\n\n\t\t\t\t\tif (opts.onRevisionCreate) {\n\t\t\t\t\t\topts.onRevisionCreate(revision);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (autoIncrementSequenceNeedsToBeReset) {\n\t\t\t\tawait getHelpers(trx).sequence.resetAutoIncrementSequence(this.collection, primaryKeyField);\n\t\t\t}\n\n\t\t\tif (opts.onItemCreate) {\n\t\t\t\topts.onItemCreate(this.collection, primaryKey);\n\t\t\t}\n\n\t\t\treturn primaryKey;\n\t\t});\n\n\t\tif (opts.emitEvents !== false) {\n\t\t\tconst actionEvent = {\n\t\t\t\tevent:\n\t\t\t\t\tthis.eventScope === 'items'\n\t\t\t\t\t\t? ['items.create', `${this.collection}.items.create`]\n\t\t\t\t\t\t: `${this.eventScope}.create`,\n\t\t\t\tmeta: {\n\t\t\t\t\tpayload: actionHookPayload,\n\t\t\t\t\tkey: primaryKey,\n\t\t\t\t\tcollection: this.collection,\n\t\t\t\t},\n\t\t\t\tcontext: {\n\t\t\t\t\tdatabase: getDatabase(),\n\t\t\t\t\tschema: this.schema,\n\t\t\t\t\taccountability: this.accountability,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (opts.bypassEmitAction) {\n\t\t\t\topts.bypassEmitAction(actionEvent);\n\t\t\t} else {\n\t\t\t\temitter.emitAction(actionEvent.event, actionEvent.meta, actionEvent.context);\n\t\t\t}\n\n\t\t\tfor (const nestedActionEvent of nestedActionEvents) {\n\t\t\t\tif (opts",
            "cost": 0.16698000000000002
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "directus/directus",
        "instance_id": "directus__directus.pr_mirror.25881",
        "base_commit": "e188b690fce5d01ef7ab0319be34536105bf00b2",
        "patch": "diff --git a/.changeset/chubby-papers-kiss.md b/.changeset/chubby-papers-kiss.md\nnew file mode 100644\nindex 0000000000000..4e5e517c0fe81\n--- /dev/null\n+++ b/.changeset/chubby-papers-kiss.md\n@@ -0,0 +1,5 @@\n+---\n+'@directus/api': patch\n+---\n+\n+Added support for MSSQL tables with triggers\ndiff --git a/api/src/services/items.test.ts b/api/src/services/items.test.ts\nindex 7fae6f0170f60..c7d9faf6126cc 100644\n--- a/api/src/services/items.test.ts\n+++ b/api/src/services/items.test.ts\n@@ -4,6 +4,7 @@ import knex, { type Knex } from 'knex';\n import { MockClient, Tracker, createTracker } from 'knex-mock-client';\n import { afterEach, beforeAll, beforeEach, describe, expect, it, vi, type MockedFunction } from 'vitest';\n import { validateUserCountIntegrity } from '../utils/validate-user-count-integrity.js';\n+import { getDatabaseClient } from '../database/index.js';\n import { ItemsService } from './index.js';\n \n vi.mock('../../src/database/index', () => ({\n@@ -56,6 +57,52 @@ describe('Integration Tests', () => {\n \n \t\t\t\texpect(validateUserCountIntegrity).toHaveBeenCalled();\n \t\t\t});\n+\n+\t\t\tit('should use includeTriggerModifications for MS SQL', async () => {\n+\t\t\t\tvi.mocked(getDatabaseClient).mockReturnValue('mssql');\n+\n+\t\t\t\tconst mockReturning = vi.fn().mockResolvedValue([{ id: 1 }]);\n+\n+\t\t\t\tconst mockQuery = {\n+\t\t\t\t\tinsert: vi.fn().mockReturnThis(),\n+\t\t\t\t\tinto: vi.fn().mockReturnThis(),\n+\t\t\t\t\treturning: mockReturning,\n+\t\t\t\t};\n+\n+\t\t\t\tconst transactionSpy = vi.spyOn(db, 'transaction').mockImplementation(async (callback) => {\n+\t\t\t\t\tconst trx = { ...db, ...mockQuery };\n+\t\t\t\t\treturn await callback(trx as any);\n+\t\t\t\t});\n+\n+\t\t\t\tawait service.createOne({ name: 'Test' });\n+\n+\t\t\t\texpect(mockReturning).toHaveBeenCalledWith('id', { includeTriggerModifications: true });\n+\n+\t\t\t\ttransactionSpy.mockRestore();\n+\t\t\t});\n+\n+\t\t\tit('should not use includeTriggerModifications for non-MS SQL', async () => {\n+\t\t\t\tvi.mocked(getDatabaseClient).mockReturnValue('postgres');\n+\n+\t\t\t\tconst mockReturning = vi.fn().mockResolvedValue([{ id: 1 }]);\n+\n+\t\t\t\tconst mockQuery = {\n+\t\t\t\t\tinsert: vi.fn().mockReturnThis(),\n+\t\t\t\t\tinto: vi.fn().mockReturnThis(),\n+\t\t\t\t\treturning: mockReturning,\n+\t\t\t\t};\n+\n+\t\t\t\tconst transactionSpy = vi.spyOn(db, 'transaction').mockImplementation(async (callback) => {\n+\t\t\t\t\tconst trx = { ...db, ...mockQuery };\n+\t\t\t\t\treturn await callback(trx as any);\n+\t\t\t\t});\n+\n+\t\t\t\tawait service.createOne({ name: 'Test' });\n+\n+\t\t\t\texpect(mockReturning).toHaveBeenCalledWith('id', undefined);\n+\n+\t\t\t\ttransactionSpy.mockRestore();\n+\t\t\t});\n \t\t});\n \n \t\tdescribe('createMany', () => {\ndiff --git a/api/src/services/items.ts b/api/src/services/items.ts\nindex 68abe56ebf58a..7147d1406d366 100644\n--- a/api/src/services/items.ts\n+++ b/api/src/services/items.ts\n@@ -23,7 +23,7 @@ import { getCache } from '../cache.js';\n import { translateDatabaseError } from '../database/errors/translate.js';\n import { getAstFromQuery } from '../database/get-ast-from-query/get-ast-from-query.js';\n import { getHelpers } from '../database/helpers/index.js';\n-import getDatabase from '../database/index.js';\n+import getDatabase, { getDatabaseClient } from '../database/index.js';\n import { runAst } from '../database/run-ast/run-ast.js';\n import emitter from '../emitter.js';\n import { processAst } from '../permissions/modules/process-ast/process-ast.js';\n@@ -243,10 +243,17 @@ export class ItemsService<Item extends AnyItem = AnyItem, Collection extends str\n \t\t\t}\n \n \t\t\ttry {\n+\t\t\t\tlet returningOptions = undefined;\n+\n+\t\t\t\t// Support MSSQL tables that have triggers.\n+\t\t\t\tif (getDatabaseClient(trx) === 'mssql') {\n+\t\t\t\t\treturningOptions = { includeTriggerModifications: true };\n+\t\t\t\t}\n+\n \t\t\t\tconst result = await trx\n \t\t\t\t\t.insert(payloadWithoutAliases)\n \t\t\t\t\t.into(this.collection)\n-\t\t\t\t\t.returning(primaryKeyField)\n+\t\t\t\t\t.returning(primaryKeyField, returningOptions)\n \t\t\t\t\t.then((result) => result[0]);\n \n \t\t\t\tconst returnedKey = typeof result === 'object' ? result[primaryKeyField] : result;\n",
        "test_patch": "",
        "problem_statement": "## Scope\r\n\r\nWhat's changed:\r\n\r\n- Added MS SQL trigger compatibility to `ItemsService.createOne()` method\r\n- Implemented conditional `includeTriggerModifications` flag for MS SQL database client\r\n- Added database client detection logic to handle MS SQL-specific requirements\r\n- Added comprehensive test coverage for MS SQL trigger scenarios\r\n\r\n## Potential Risks / Drawbacks\r\n\r\n- Very low risk as the change is conditional and only affects MS SQL databases\r\n- No impact on existing functionality for PostgreSQL, MySQL, SQLite, or other databases\r\n- The fix follows `Knex.js` best practices and official documentation\r\n\r\n## Tested Scenarios\r\n\r\n- MS SQL database client detection and `includeTriggerModifications` flag application\r\n- Non-MS SQL database clients continue to work without the flag (PostgreSQL, MySQL, etc.)\r\n- Existing `createOne()` functionality preserved across all database types\r\n\r\n## Review Notes / Questions\r\n\r\n- Special attention should be paid to the conditional logic that only applies the fix to MS SQL\r\n- The solution uses Knex's built-in `includeTriggerModifications` flag as recommended in their documentation\r\n\r\n## Checklist\r\n\r\n- [x] Added or updated tests\r\n- [ ] Documentation PR created [here](https://github.com/directus/docs) or not required\r\n\r\n---\r\nFixes: CMS-1352",
        "hints_text": "",
        "created_at": "2025-09-23T14:50:21Z",
        "pull_number": 25881,
        "test_files": [
            "api/src/services/items.test.ts"
        ],
        "code_files": [
            "api/src/services/items.ts"
        ],
        "title": "Add support for MSSQL tables with triggers",
        "additions": 0,
        "deletions": 0,
        "pr_mirror": "directus__directus.447c91d0"
    }
}