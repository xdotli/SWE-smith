{
    "cost": 0.042825,
    "rewrites": {
        "directus__directus.447c91d0/api/src/extensions/lib/installation/manager.ts": {
            "output": "import { useEnv } from '@directus/env';\nimport { ServiceUnavailableError } from '@directus/errors';\nimport { EXTENSION_PKG_KEY, ExtensionManifest } from '@directus/extensions';\nimport { download, type DownloadOptions } from '@directus/extensions-registry';\nimport DriverLocal from '@directus/storage-driver-local';\nimport { move, remove } from 'fs-extra';\nimport { mkdir, readFile, rm } from 'node:fs/promises';\nimport { Readable } from 'node:stream';\nimport Queue from 'p-queue';\nimport { join } from 'path';\nimport type { ReadableStream } from 'stream/web';\nimport { extract } from 'tar';\nimport { useLogger } from '../../../logger/index.js';\nimport { getStorage } from '../../../storage/index.js';\nimport { getExtensionsPath } from '../get-extensions-path.js';\n\nconst env = useEnv();\n\nexport class InstallationManager {\n\textensionPath = getExtensionsPath();\n\n\tasync install(versionId: string) {\n\t\tconst logger = useLogger();\n\t\tconst tempDir = join(env['TEMP_PATH'] as string, 'marketplace', versionId);\n\t\tconst tmpStorage = new DriverLocal({ root: tempDir });\n\n\t\ttry {\n\t\t\tawait mkdir(tempDir, { recursive: true });\n\n\t\t\tconst options: DownloadOptions = {};\n\n\t\t\tif (env['MARKETPLACE_REGISTRY'] && typeof env['MARKETPLACE_REGISTRY'] === 'string') {\n\t\t\t\toptions.registry = env['MARKETPLACE_REGISTRY'];\n\t\t\t}\n\n\t\t\tconst tarReadableStream = await download(versionId, env['MARKETPLACE_TRUST'] === 'sandbox', options);\n\n\t\t\tif (!tarReadableStream) {\n\t\t\t\tthrow new Error(`No readable stream returned from download`);\n\t\t\t}\n\n\t\t\tconst tarStream = Readable.fromWeb(tarReadableStream as ReadableStream);\n\t\t\tconst tarPath = join(tempDir, `bin.tar.tgz`);\n\t\t\tawait tmpStorage.write('bin.tar.tgz', tarStream);\n\n\t\t\t/**\n\t\t\t * NPM modules that are packed are always tarballed in a folder called \"package\"\n\t\t\t */\n\t\t\tconst extractedPath = 'package';\n\n\t\t\tawait extract({\n\t\t\t\tfile: tarPath,\n\t\t\t\tcwd: tempDir,\n\t\t\t});\n\n\t\t\tconst packageFile = JSON.parse(\n\t\t\t\tawait readFile(join(tempDir, extractedPath, 'package.json'), { encoding: 'utf-8' }),\n\t\t\t);\n\n\t\t\tconst extensionManifest = await ExtensionManifest.parseAsync(packageFile);\n\n\t\t\tif (!extensionManifest[EXTENSION_PKG_KEY]?.type) {\n\t\t\t\tthrow new Error(`Extension type not found in package.json`);\n\t\t\t}\n\n\t\t\tif (env['EXTENSIONS_LOCATION']) {\n\t\t\t\t// Upload the extension into the configured extensions location\n\t\t\t\tconst storage = await getStorage();\n\t\t\t\tconst remoteDisk = storage.location(env['EXTENSIONS_LOCATION'] as string);\n\n\t\t\t\tconst queue = new Queue({ concurrency: 1000 });\n\n\t\t\t\tfor await (const filepath of tmpStorage.list(extractedPath)) {\n\t\t\t\t\tconst readStream = await tmpStorage.read(filepath);\n\n\t\t\t\t\tconst remotePath = join(\n\t\t\t\t\t\tenv['EXTENSIONS_PATH'] as string,\n\t\t\t\t\t\t'.registry',\n\t\t\t\t\t\tversionId,\n\t\t\t\t\t\tfilepath.substring(extractedPath.length),\n\t\t\t\t\t);\n\n\t\t\t\t\tqueue.add(() => remoteDisk.write(remotePath, readStream));\n\t\t\t\t}\n\n\t\t\t\tawait queue.onIdle();\n\t\t\t} else {\n\t\t\t\t// No custom location, so save to regular local extensions folder\n\t\t\t\tconst dest = join(this.extensionPath, '.registry', versionId);\n\t\t\t\tawait move(join(tempDir, extractedPath), dest, { overwrite: true });\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.warn(err);\n\n\t\t\tthrow new ServiceUnavailableError(\n\t\t\t\t{ service: 'marketplace', reason: 'Could not download and extract the extension' },\n\t\t\t\t{ cause: err },\n\t\t\t);\n\t\t} finally {\n\t\t\tawait rm(tempDir, { recursive: true });\n\t\t}\n\t}\n\n\tasync uninstall(folder: string) {\n\t\tif (env['EXTENSIONS_LOCATION']) {\n\t\t\tconst storage = await getStorage();\n\t\t\tconst remoteDisk = storage.location(env['EXTENSIONS_LOCATION'] as string);\n\n\t\t\tconst queue = new Queue({ concurrency: 1000 });\n\n\t\t\tconst prefix = join(env['EXTENSIONS_PATH'] as string, '.registry', folder);\n\n\t\t\tfor await (const filepath of remoteDisk.list(prefix)) {\n\t\t\t\tqueue.add(() => remoteDisk.delete(filepath));\n\t\t\t}\n\n\t\t\tawait queue.onIdle();\n\t\t} else {\n\t\t\tconst path = join(this.extensionPath, '.registry', folder);\n\t\t\tawait remove(path);\n\t\t}\n\t}\n}",
            "output_extracted": "import { useEnv } from '@directus/env';\nimport { ServiceUnavailableError } from '@directus/errors';\nimport { EXTENSION_PKG_KEY, ExtensionManifest } from '@directus/extensions';\nimport { download, type DownloadOptions } from '@directus/extensions-registry';\nimport DriverLocal from '@directus/storage-driver-local';\nimport { move, remove } from 'fs-extra';\nimport { mkdir, readFile, rm } from 'node:fs/promises';\nimport { Readable } from 'node:stream';\nimport Queue from 'p-queue';\nimport { join } from 'path';\nimport type { ReadableStream } from 'stream/web';\nimport { extract } from 'tar';\nimport { useLogger } from '../../../logger/index.js';\nimport { getStorage } from '../../../storage/index.js';\nimport { getExtensionsPath } from '../get-extensions-path.js';\n\nconst env = useEnv();\n\nexport class InstallationManager {\n\textensionPath = getExtensionsPath();\n\n\tasync install(versionId: string) {\n\t\tconst logger = useLogger();\n\t\tconst tempDir = join(env['TEMP_PATH'] as string, 'marketplace', versionId);\n\t\tconst tmpStorage = new DriverLocal({ root: tempDir });\n\n\t\ttry {\n\t\t\tawait mkdir(tempDir, { recursive: true });\n\n\t\t\tconst options: DownloadOptions = {};\n\n\t\t\tif (env['MARKETPLACE_REGISTRY'] && typeof env['MARKETPLACE_REGISTRY'] === 'string') {\n\t\t\t\toptions.registry = env['MARKETPLACE_REGISTRY'];\n\t\t\t}\n\n\t\t\tconst tarReadableStream = await download(versionId, env['MARKETPLACE_TRUST'] === 'sandbox', options);\n\n\t\t\tif (!tarReadableStream) {\n\t\t\t\tthrow new Error(`No readable stream returned from download`);\n\t\t\t}\n\n\t\t\tconst tarStream = Readable.fromWeb(tarReadableStream as ReadableStream);\n\t\t\tconst tarPath = join(tempDir, `bin.tar.tgz`);\n\t\t\tawait tmpStorage.write('bin.tar.tgz', tarStream);\n\n\t\t\t/**\n\t\t\t * NPM modules that are packed are always tarballed in a folder called \"package\"\n\t\t\t */\n\t\t\tconst extractedPath = 'package';\n\n\t\t\tawait extract({\n\t\t\t\tfile: tarPath,\n\t\t\t\tcwd: tempDir,\n\t\t\t});\n\n\t\t\tconst packageFile = JSON.parse(\n\t\t\t\tawait readFile(join(tempDir, extractedPath, 'package.json'), { encoding: 'utf-8' }),\n\t\t\t);\n\n\t\t\tconst extensionManifest = await ExtensionManifest.parseAsync(packageFile);\n\n\t\t\tif (!extensionManifest[EXTENSION_PKG_KEY]?.type) {\n\t\t\t\tthrow new Error(`Extension type not found in package.json`);\n\t\t\t}\n\n\t\t\tif (env['EXTENSIONS_LOCATION']) {\n\t\t\t\t// Upload the extension into the configured extensions location\n\t\t\t\tconst storage = await getStorage();\n\t\t\t\tconst remoteDisk = storage.location(env['EXTENSIONS_LOCATION'] as string);\n\n\t\t\t\tconst queue = new Queue({ concurrency: 1000 });\n\n\t\t\t\tfor await (const filepath of tmpStorage.list(extractedPath)) {\n\t\t\t\t\tconst readStream = await tmpStorage.read(filepath);\n\n\t\t\t\t\tconst remotePath = join(\n\t\t\t\t\t\tenv['EXTENSIONS_PATH'] as string,\n\t\t\t\t\t\t'.registry',\n\t\t\t\t\t\tversionId,\n\t\t\t\t\t\tfilepath.substring(extractedPath.length),\n\t\t\t\t\t);\n\n\t\t\t\t\tqueue.add(() => remoteDisk.write(remotePath, readStream));\n\t\t\t\t}\n\n\t\t\t\tawait queue.onIdle();\n\t\t\t} else {\n\t\t\t\t// No custom location, so save to regular local extensions folder\n\t\t\t\tconst dest = join(this.extensionPath, '.registry', versionId);\n\t\t\t\tawait move(join(tempDir, extractedPath), dest, { overwrite: true });\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlogger.warn(err);\n\n\t\t\tthrow new ServiceUnavailableError(\n\t\t\t\t{ service: 'marketplace', reason: 'Could not download and extract the extension' },\n\t\t\t\t{ cause: err },\n\t\t\t);\n\t\t} finally {\n\t\t\tawait rm(tempDir, { recursive: true });\n\t\t}\n\t}\n\n\tasync uninstall(folder: string) {\n\t\tif (env['EXTENSIONS_LOCATION']) {\n\t\t\tconst storage = await getStorage();\n\t\t\tconst remoteDisk = storage.location(env['EXTENSIONS_LOCATION'] as string);\n\n\t\t\tconst queue = new Queue({ concurrency: 1000 });\n\n\t\t\tconst prefix = join(env['EXTENSIONS_PATH'] as string, '.registry', folder);\n\n\t\t\tfor await (const filepath of remoteDisk.list(prefix)) {\n\t\t\t\tqueue.add(() => remoteDisk.delete(filepath));\n\t\t\t}\n\n\t\t\tawait queue.onIdle();\n\t\t} else {\n\t\t\tconst path = join(this.extensionPath, '.registry', folder);\n\t\t\tawait remove(path);\n\t\t}\n\t}\n}",
            "cost": 0.042825
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "directus/directus",
        "instance_id": "directus__directus.pr_mirror.26193",
        "base_commit": "bbd4802f0e163906855a68724927ee4d944d4416",
        "patch": "diff --git a/.changeset/wet-cities-start.md b/.changeset/wet-cities-start.md\nnew file mode 100644\nindex 0000000000000..c6135cae6c4cc\n--- /dev/null\n+++ b/.changeset/wet-cities-start.md\n@@ -0,0 +1,5 @@\n+---\n+'@directus/api': patch\n+---\n+\n+Improved extension install error messages\ndiff --git a/api/src/extensions/lib/installation/manager.test.ts b/api/src/extensions/lib/installation/manager.test.ts\nnew file mode 100644\nindex 0000000000000..0597a4f8dcf31\n--- /dev/null\n+++ b/api/src/extensions/lib/installation/manager.test.ts\n@@ -0,0 +1,115 @@\n+import { download } from '@directus/extensions-registry';\n+import { mkdir, readFile, rm } from 'node:fs/promises';\n+import { beforeEach, describe, expect, test, vi } from 'vitest';\n+import { useLogger } from '../../../logger/index.js';\n+import { InstallationManager } from './manager.js';\n+\n+vi.mock('@directus/env', () => ({\n+\tuseEnv: vi.fn(() => ({\n+\t\tTEMP_PATH: '/tmp',\n+\t\tEXTENSIONS_PATH: '/extensions',\n+\t})),\n+}));\n+\n+vi.mock('@directus/extensions-registry', () => ({\n+\tdownload: vi.fn(),\n+}));\n+\n+vi.mock('@directus/storage-driver-local');\n+\n+vi.mock('fs-extra', () => ({\n+\tmove: vi.fn(),\n+\tremove: vi.fn(),\n+}));\n+\n+vi.mock('node:fs/promises', () => ({\n+\tmkdir: vi.fn(),\n+\treadFile: vi.fn(),\n+\trm: vi.fn(),\n+}));\n+\n+vi.mock('tar', () => ({\n+\textract: vi.fn(),\n+}));\n+\n+vi.mock('../../../logger/index.js', () => ({\n+\tuseLogger: vi.fn(() => ({ warn: vi.fn() })),\n+}));\n+\n+vi.mock('../../../storage/index.js', () => ({\n+\tgetStorage: vi.fn(),\n+}));\n+\n+vi.mock('../get-extensions-path.js', () => ({\n+\tgetExtensionsPath: vi.fn(() => '/extensions'),\n+}));\n+\n+describe('InstallationManager', () => {\n+\tlet manager: InstallationManager;\n+\tlet mockLogger: any;\n+\n+\tbeforeEach(async () => {\n+\t\tvi.clearAllMocks();\n+\n+\t\tmockLogger = {\n+\t\t\twarn: vi.fn(),\n+\t\t};\n+\n+\t\tvi.mocked(useLogger).mockReturnValue(mockLogger);\n+\t\tvi.mocked(mkdir).mockResolvedValue(undefined);\n+\n+\t\t// Setup successful mocks by default\n+\t\tconst mockReadableStream = {\n+\t\t\tgetReader: () => ({\n+\t\t\t\tread: vi.fn().mockResolvedValue({ done: true, value: undefined }),\n+\t\t\t}),\n+\t\t};\n+\n+\t\tvi.mocked(download).mockResolvedValue(mockReadableStream as any);\n+\n+\t\tvi.mocked(readFile).mockResolvedValue(\n+\t\t\tJSON.stringify({\n+\t\t\t\tname: 'test-extension',\n+\t\t\t\tdirectus: {\n+\t\t\t\t\ttype: 'interface',\n+\t\t\t\t},\n+\t\t\t}),\n+\t\t);\n+\n+\t\tmanager = new InstallationManager();\n+\t});\n+\n+\tdescribe('Errors', () => {\n+\t\ttest('should throw marketplace ServiceUnavailableError when download fails', async () => {\n+\t\t\tvi.mocked(download).mockRejectedValue(new Error('Network error'));\n+\n+\t\t\tawait expect(manager.install('test-version')).rejects.toThrowError(\n+\t\t\t\t'Service \"marketplace\" is unavailable. Could not download the extension.',\n+\t\t\t);\n+\t\t});\n+\n+\t\ttest('should throw extension ServiceUnavailableError for any non marketplace error', async () => {\n+\t\t\tvi.mocked(mkdir).mockRejectedValue(new Error());\n+\n+\t\t\tawait expect(manager.install('test-version')).rejects.toThrowError(\n+\t\t\t\t'Service \"extensions\" is unavailable. Failed to extract the extension or write it to storage.',\n+\t\t\t);\n+\t\t});\n+\n+\t\ttest('should always clean up temporary directory even when error occurs', async () => {\n+\t\t\tvi.mocked(mkdir).mockRejectedValue(new Error());\n+\n+\t\t\tawait expect(manager.install('test-version')).rejects.toThrow();\n+\n+\t\t\texpect(rm).toHaveBeenCalledWith('/tmp/marketplace/test-version', { recursive: true });\n+\t\t});\n+\n+\t\ttest('should log warning when error occurs', async () => {\n+\t\t\tvi.mocked(download).mockRejectedValue(new Error('Test error'));\n+\n+\t\t\tawait expect(manager.install('test-version')).rejects.toThrow();\n+\n+\t\t\texpect(mockLogger.warn).toHaveBeenCalled();\n+\t\t});\n+\t});\n+});\ndiff --git a/api/src/extensions/lib/installation/manager.ts b/api/src/extensions/lib/installation/manager.ts\nindex 227afd39243b4..689c6c0679ca0 100644\n--- a/api/src/extensions/lib/installation/manager.ts\n+++ b/api/src/extensions/lib/installation/manager.ts\n@@ -1,5 +1,5 @@\n import { useEnv } from '@directus/env';\n-import { ServiceUnavailableError } from '@directus/errors';\n+import { ErrorCode, isDirectusError, ServiceUnavailableError } from '@directus/errors';\n import { EXTENSION_PKG_KEY, ExtensionManifest } from '@directus/extensions';\n import { download, type DownloadOptions } from '@directus/extensions-registry';\n import DriverLocal from '@directus/storage-driver-local';\n@@ -33,7 +33,16 @@ export class InstallationManager {\n \t\t\t\toptions.registry = env['MARKETPLACE_REGISTRY'];\n \t\t\t}\n \n-\t\t\tconst tarReadableStream = await download(versionId, env['MARKETPLACE_TRUST'] === 'sandbox', options);\n+\t\t\tlet tarReadableStream;\n+\n+\t\t\ttry {\n+\t\t\t\ttarReadableStream = await download(versionId, env['MARKETPLACE_TRUST'] === 'sandbox', options);\n+\t\t\t} catch (error) {\n+\t\t\t\tthrow new ServiceUnavailableError(\n+\t\t\t\t\t{ service: 'marketplace', reason: 'Could not download the extension' },\n+\t\t\t\t\t{ cause: error },\n+\t\t\t\t);\n+\t\t\t}\n \n \t\t\tif (!tarReadableStream) {\n \t\t\t\tthrow new Error(`No readable stream returned from download`);\n@@ -92,8 +101,13 @@ export class InstallationManager {\n \t\t} catch (err) {\n \t\t\tlogger.warn(err);\n \n+\t\t\t// rethrow marketplace servic unavailable\n+\t\t\tif (isDirectusError(err, ErrorCode.ServiceUnavailable)) {\n+\t\t\t\tthrow err;\n+\t\t\t}\n+\n \t\t\tthrow new ServiceUnavailableError(\n-\t\t\t\t{ service: 'marketplace', reason: 'Could not download and extract the extension' },\n+\t\t\t\t{ service: 'extensions', reason: 'Failed to extract the extension or write it to storage' },\n \t\t\t\t{ cause: err },\n \t\t\t);\n \t\t} finally {\ndiff --git a/api/src/services/extensions.test.ts b/api/src/services/extensions.test.ts\nnew file mode 100644\nindex 0000000000000..7f88bc2917a91\n--- /dev/null\n+++ b/api/src/services/extensions.test.ts\n@@ -0,0 +1,92 @@\n+import { ServiceUnavailableError } from '@directus/errors';\n+import { describe as registryDescribe } from '@directus/extensions-registry';\n+import { beforeEach, describe, expect, test, vi } from 'vitest';\n+import { getExtensionManager } from '../extensions/index.js';\n+import { ExtensionsService } from './extensions.js';\n+import { ItemsService } from './items.js';\n+\n+// Mock dependencies at the top level\n+vi.mock('@directus/env', () => ({\n+\tuseEnv: vi.fn(() => ({})),\n+}));\n+\n+vi.mock('@directus/extensions-registry', () => ({\n+\tdescribe: vi.fn(),\n+}));\n+\n+vi.mock('../extensions/index.js', () => ({\n+\tgetExtensionManager: vi.fn(),\n+}));\n+\n+vi.mock('./items.js', () => ({\n+\tItemsService: vi.fn(),\n+}));\n+\n+vi.mock('../database/index.js', () => ({\n+\tdefault: vi.fn(),\n+}));\n+\n+describe('ExtensionsService', () => {\n+\tlet mockExtensionManager: any;\n+\tlet mockExtensionsItemService: any;\n+\n+\tbeforeEach(async () => {\n+\t\tvi.clearAllMocks();\n+\n+\t\tmockExtensionsItemService = {\n+\t\t\tcreateOne: vi.fn(),\n+\t\t\tcreateMany: vi.fn(),\n+\t\t\treadOne: vi.fn(),\n+\t\t\tupdateOne: vi.fn(),\n+\t\t\tdeleteOne: vi.fn(),\n+\t\t\tdeleteByQuery: vi.fn(),\n+\t\t\treadByQuery: vi.fn(),\n+\t\t};\n+\n+\t\tmockExtensionManager = {\n+\t\t\tinstall: vi.fn(),\n+\t\t\tuninstall: vi.fn(),\n+\t\t\textensions: [],\n+\t\t\tgetExtension: vi.fn(),\n+\t\t\treload: vi.fn(),\n+\t\t\tbroadcastReloadNotification: vi.fn(),\n+\t\t};\n+\n+\t\tvi.mocked(getExtensionManager).mockReturnValue(mockExtensionManager);\n+\n+\t\tvi.mocked(ItemsService).mockImplementation(() => mockExtensionsItemService);\n+\n+\t\tvi.mocked(registryDescribe).mockResolvedValue({\n+\t\t\tdata: {\n+\t\t\t\ttype: 'interface',\n+\t\t\t\tversions: [\n+\t\t\t\t\t{\n+\t\t\t\t\t\tid: 'test-version',\n+\t\t\t\t\t\tbundled: [],\n+\t\t\t\t\t},\n+\t\t\t\t],\n+\t\t\t},\n+\t\t} as any);\n+\t});\n+\n+\tdescribe('install', () => {\n+\t\ttest('should propagate extension manager install error', async () => {\n+\t\t\tmockExtensionManager.install.mockRejectedValue(\n+\t\t\t\tnew ServiceUnavailableError({\n+\t\t\t\t\tservice: 'marketplace',\n+\t\t\t\t\treason: 'Could not download the extension',\n+\t\t\t\t}),\n+\t\t\t);\n+\n+\t\t\tconst service = new ExtensionsService({\n+\t\t\t\tknex: {} as any,\n+\t\t\t\tschema: {} as any,\n+\t\t\t\taccountability: null,\n+\t\t\t});\n+\n+\t\t\tawait expect(service.install('test-extension', 'test-version')).rejects.toThrow(\n+\t\t\t\t'Could not download the extension',\n+\t\t\t);\n+\t\t});\n+\t});\n+});\n",
        "test_patch": "",
        "problem_statement": "## Scope\r\n\r\nBuilds upon #25810\r\n\r\nWhat's changed:\r\n\r\n- Splits the generic service error message into two independent messages\r\n- Improves clarity by being more explicit as to what stage the process failed\r\n\r\n### Extract/Save error\r\nhttps://github.com/user-attachments/assets/69e41532-8d4d-413a-ac37-ca5e8ecc7657\r\n### Fetch/Download error\r\nhttps://github.com/user-attachments/assets/34d56ae9-724a-4df0-a4f1-de2a3fdddb2f\r\n\r\n\r\n## Potential Risks / Drawbacks\r\n\r\n- Should be none\r\n\r\n## Tested Scenarios\r\n\r\n- [x] Expect registry failure to show registry unavailable\r\n- [x] Expect any other errors to result in extension service unavailable \r\n\r\n## Review Notes / Questions\r\n\r\n- I would like to lorem ipsum\r\n- Special attention should be paid to dolor sit amet\r\n\r\n## Checklist\r\n\r\n- [x] Added or updated tests\r\n- [ ] Documentation PR created [here](https://github.com/directus/docs) or not required\r\n- [ ] OpenAPI package PR created [here](https://github.com/directus/openapi) or not required\r\n\r\n---\r\n\r\nFixes #25807\r\nAlternate of: https://github.com/directus/directus/pull/25810\r\n",
        "hints_text": "",
        "created_at": "2025-11-14T19:33:59Z",
        "pull_number": 26193,
        "test_files": [
            "api/src/extensions/lib/installation/manager.test.ts",
            "api/src/services/extensions.test.ts"
        ],
        "code_files": [
            "api/src/extensions/lib/installation/manager.ts"
        ],
        "title": "Improve extension install error messages",
        "additions": 0,
        "deletions": 0,
        "pr_mirror": "directus__directus.447c91d0"
    }
}