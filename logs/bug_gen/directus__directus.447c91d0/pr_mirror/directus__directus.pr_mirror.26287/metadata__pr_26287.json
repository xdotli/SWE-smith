{
    "cost": 0.20574,
    "rewrites": {
        "directus__directus.447c91d0/app/src/composables/use-flows.test.ts": {
            "output": "import { describe, beforeEach, expect, test, vi, afterEach } from 'vitest';\nimport { createTestingPinia } from '@pinia/testing';\nimport { setActivePinia } from 'pinia';\nimport { useFlows } from './use-flows';\nimport { nextTick, ref } from 'vue';\nimport { useFlowsStore } from '@/stores/flows';\nimport api from '@/api';\n\nvi.mock('@/stores/flows');\n\nvi.mock('vue-i18n', () => ({\n\tuseI18n: () => ({\n\t\tt: vi.fn((key: string, params?: any) => {\n\t\t\tif (key === 'run_flow_on_current') return 'Run Flow on Current';\n\t\t\tif (key === 'run_flow_on_selected') return `Run Flow on Selected (${params})`;\n\t\t\tif (key === 'run_flow') return 'Run Flow';\n\t\t\tif (key === 'run_flow_on_current_collection') return 'Run Flow on Current Collection';\n\t\t\tif (key === 'trigger_flow_success') return `Flow ${params?.flow} triggered successfully`;\n\t\t\treturn key;\n\t\t}),\n\t}),\n\tcreateI18n: vi.fn(() => ({})),\n}));\n\nvi.mock('@directus/composables', () => ({\n\tuseCollection: () => ({\n\t\tprimaryKeyField: ref({ field: 'id', type: 'integer' }),\n\t}),\n}));\n\nvi.mock('@/utils/notify');\n\nvi.mock('@/utils/translate-object-values', () => ({\n\ttranslate: vi.fn((obj) => obj),\n}));\n\nvi.mock('@/utils/unexpected-error');\n\nvi.mock('@directus/format-title', () => ({\n\tdefault: vi.fn((str) => str),\n}));\n\nvi.mock('@/api');\n\nvi.mock('@/stores/notifications', () => ({\n\tuseNotificationsStore: () => ({\n\t\trefreshUnreadCount: vi.fn(),\n\t}),\n}));\n\nbeforeEach(() => {\n\tsetActivePinia(\n\t\tcreateTestingPinia({\n\t\t\tcreateSpy: vi.fn,\n\t\t\tstubActions: false,\n\t\t}),\n\t);\n});\n\nafterEach(() => {\n\tvi.clearAllMocks();\n});\n\nconst mockOnRefresh = vi.fn();\n\nconst useFlowsOptions = {\n\tcollection: ref('test_collection'),\n\tprimaryKey: 'item_1',\n\tlocation: 'collection' as const,\n\thasEdits: ref(true),\n\tonRefreshCallback: mockOnRefresh,\n};\n\nconst mockFlows = [\n\t{\n\t\tid: 'flow-1',\n\t\tname: 'Test Flow 1',\n\t\ttrigger: 'manual',\n\t\tstatus: 'active',\n\t\toptions: {\n\t\t\tcollections: ['test_collection'],\n\t\t\tlocation: 'collection',\n\t\t\trequireConfirmation: true,\n\t\t\tconfirmationDescription: 'test-description-1',\n\t\t\tfields: [{ name: 'field-1', meta: { required: true } }],\n\t\t},\n\t},\n\t{\n\t\tid: 'flow-2',\n\t\tname: 'Test Flow 2',\n\t\ttrigger: 'manual',\n\t\tstatus: 'active',\n\t\toptions: {\n\t\t\tcollections: ['test_collection'],\n\t\t\tlocation: 'item',\n\t\t\trequireConfirmation: false,\n\t\t\trequireSelection: false,\n\t\t},\n\t},\n\t{\n\t\tid: 'flow-3',\n\t\tname: 'Test Flow 3',\n\t\ttrigger: 'event',\n\t\tstatus: 'active',\n\t\toptions: {\n\t\t\tcollections: ['test_collection'],\n\t\t\tlocation: 'item',\n\t\t\trequireConfirmation: true,\n\t\t\tconfirmationDescription: 'test-description-3',\n\t\t\trequireSelection: false,\n\t\t},\n\t},\n\t{\n\t\tid: 'flow-4',\n\t\tname: 'Test Flow 4',\n\t\ttrigger: 'event',\n\t\tstatus: 'active',\n\t\toptions: {\n\t\t\tcollections: ['test_collection'],\n\t\t\tlocation: 'collection',\n\t\t\trequireConfirmation: false,\n\t\t\tfields: [{ name: 'field-1', meta: { required: false } }],\n\t\t},\n\t},\n\t{\n\t\tid: 'flow-5',\n\t\tname: 'Test',\n\t\ttrigger: 'manual',\n\t\tstatus: 'active',\n\t\toptions: {\n\t\t\tcollections: ['test_collection'],\n\t\t\tlocation: 'collection',\n\t\t\trequireSelection: false,\n\t\t},\n\t},\n];\n\ndescribe('manualFlows', () => {\n\ttest('returns empty array when no manual flows', () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([]),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tconst { manualFlows } = useFlows(useFlowsOptions);\n\n\t\texpect(manualFlows.value.length).toEqual(0);\n\t\texpect(mockFlowsStore.getManualFlowsForCollection).toHaveBeenCalledWith('test_collection');\n\t});\n\n\ttest('returns manual flows when some are found', () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tconst { manualFlows } = useFlows(useFlowsOptions);\n\n\t\texpect(manualFlows.value.length).toEqual(3);\n\t\texpect(mockFlowsStore.getManualFlowsForCollection).toHaveBeenCalledWith('test_collection');\n\t});\n\n\ttest('returns collection specific flows when changing collection', async () => {\n\t\tconst mockGetManualFlows = vi.fn();\n\n\t\tmockGetManualFlows.mockReturnValue(mockFlows);\n\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: mockGetManualFlows,\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tconst testCollection = ref('test_collection');\n\n\t\tconst { manualFlows } = useFlows({ ...useFlowsOptions, collection: testCollection });\n\n\t\texpect(manualFlows.value.length).toEqual(3);\n\t\texpect(mockGetManualFlows).toHaveBeenLastCalledWith('test_collection');\n\n\t\tmockGetManualFlows.mockReturnValue([]);\n\n\t\ttestCollection.value = 'test_collection_2';\n\n\t\tawait nextTick();\n\n\t\texpect(manualFlows.value.length).toEqual(0);\n\t\texpect(mockGetManualFlows).toHaveBeenLastCalledWith('test_collection_2');\n\t\texpect(mockGetManualFlows).toHaveBeenCalledTimes(2);\n\t});\n});\n\ndescribe('manualFlow.isFlowDisabled', () => {\n\tdescribe('false', () => {\n\t\ttest('location is \"item\"', () => {\n\t\t\tconst testUseFlowsOptions = {\n\t\t\t\t...useFlowsOptions,\n\t\t\t\tlocation: 'item' as const,\n\t\t\t};\n\n\t\t\tconst mockFlowsStore = {\n\t\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlows[0]]),\n\t\t\t};\n\n\t\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\t\tconst { manualFlows } = useFlows(testUseFlowsOptions);\n\n\t\t\tmanualFlows.value.forEach((manualFlow) => {\n\t\t\t\texpect(manualFlow.isFlowDisabled).toEqual(false);\n\t\t\t});\n\t\t});\n\n\t\ttest('manualFlow.options.requireSelection is false', () => {\n\t\t\tconst mockFlowsStore = {\n\t\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlows[0]]),\n\t\t\t};\n\n\t\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\t\tconst { manualFlows } = useFlows(useFlowsOptions);\n\n\t\t\tmanualFlows.value.forEach((manualFlow) => {\n\t\t\t\texpect(manualFlow.isFlowDisabled).toEqual(false);\n\t\t\t});\n\t\t});\n\n\t\ttest('location is \"collection\" but has primaryKey', () => {\n\t\t\tconst mockFlow = { ...mockFlows[0], options: {} };\n\n\t\t\tconst mockFlowsStore = {\n\t\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlow]),\n\t\t\t};\n\n\t\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\t\tconst { manualFlows } = useFlows(useFlowsOptions);\n\n\t\t\tmanualFlows.value.forEach((manualFlow) => {\n\t\t\t\texpect(manualFlow.isFlowDisabled).toEqual(false);\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('true', () => {\n\t\ttest('location is \"collection\", no primaryKey, no selection, requireSelection not false', () => {\n\t\t\tconst testUseFlowsOptions = {\n\t\t\t\t...useFlowsOptions,\n\t\t\t\tprimaryKey: undefined,\n\t\t\t};\n\n\t\t\tconst mockFlow = { ...mockFlows[0], options: { requireSelection: true } };\n\n\t\t\tconst mockFlowsStore = {\n\t\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlow]),\n\t\t\t};\n\n\t\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\t\tconst { manualFlows } = useFlows(testUseFlowsOptions);\n\n\t\t\tmanualFlows.value.forEach((manualFlow) => {\n\t\t\t\texpect(manualFlow.isFlowDisabled).toEqual(true);\n\t\t\t});\n\t\t});\n\t});\n});\n\ndescribe('runManualFlow', () => {\n\ttest('returns early when selectedFlow is not found', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst { runManualFlow } = useFlows(useFlowsOptions);\n\n\t\tawait runManualFlow('non-existent-flow');\n\n\t\texpect(api.post).not.toHaveBeenCalled();\n\t});\n\n\ttest('returns early when flow is not in manualFlows (filtered out)', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlows[1]]),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst { runManualFlow } = useFlows(useFlowsOptions);\n\n\t\tawait runManualFlow(mockFlows[1]!.id);\n\n\t\texpect(api.post).not.toHaveBeenCalled();\n\t});\n\n\ttest('successfully runs flow for collection with requireSelection false', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlows[4]]),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst { runManualFlow, flowDialogsContext } = useFlows(useFlowsOptions);\n\n\t\tconst { currentFlowId, confirmUnsavedChanges } = flowDialogsContext.value;\n\n\t\tconfirmUnsavedChanges(mockFlows[4]!.id);\n\n\t\tawait runManualFlow(mockFlows[4]!.id);\n\n\t\texpect(api.post).toHaveBeenCalledWith(`/flows/trigger/${mockFlows[4]!.id}`, {\n\t\t\tcollection: 'test_collection',\n\t\t});\n\n\t\texpect(currentFlowId).toBeNull();\n\t});\n\n\ttest('successfully runs flow with keys (primaryKey or selection)', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst testOptions = {\n\t\t\t...useFlowsOptions,\n\t\t\thasEdits: ref(false),\n\t\t};\n\n\t\tconst { runManualFlow, flowDialogsContext } = useFlows(testOptions);\n\n\t\tconst { currentFlowId } = flowDialogsContext.value;\n\n\t\tawait runManualFlow(mockFlows[4]!.id);\n\n\t\texpect(api.post).toHaveBeenCalledWith(`/flows/trigger/${mockFlows[4]!.id}`, {\n\t\t\tcollection: 'test_collection',\n\t\t});\n\n\t\texpect(currentFlowId).toBeNull();\n\t});\n\n\ttest('uses selection when no primaryKey is available', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst testOptions = {\n\t\t\t...useFlowsOptions,\n\t\t\tprimaryKey: undefined,\n\t\t\tselection: ref([{ id: 'item1' }, { id: 'item2' }]),\n\t\t\thasEdits: ref(false),\n\t\t};\n\n\t\tconst { runManualFlow } = useFlows(testOptions);\n\n\t\tawait runManualFlow(mockFlows[4]!.id);\n\n\t\texpect(api.post).toHaveBeenCalledWith(`/flows/trigger/${mockFlows[4]!.id}`, {\n\t\t\tcollection: 'test_collection',\n\t\t\tkeys: [{ id: 'item1' }, { id: 'item2' }],\n\t\t});\n\t});\n\n\ttest('calls onRefreshCallback', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n\t\t};\n\n\t\tconst testOptions = {\n\t\t\t...useFlowsOptions,\n\t\t\thasEdits: ref(false),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst { runManualFlow } = useFlows(testOptions);\n\n\t\tawait runManualFlow(mockFlows[3]!.id);\n\n\t\texpect(mockOnRefresh).toHaveBeenCalledOnce();\n\t});\n});",
            "output_extracted": "import { describe, beforeEach, expect, test, vi, afterEach } from 'vitest';\nimport { createTestingPinia } from '@pinia/testing';\nimport { setActivePinia } from 'pinia';\nimport { useFlows } from './use-flows';\nimport { nextTick, ref } from 'vue';\nimport { useFlowsStore } from '@/stores/flows';\nimport api from '@/api';\n\nvi.mock('@/stores/flows');\n\nvi.mock('vue-i18n', () => ({\n\tuseI18n: () => ({\n\t\tt: vi.fn((key: string, params?: any) => {\n\t\t\tif (key === 'run_flow_on_current') return 'Run Flow on Current';\n\t\t\tif (key === 'run_flow_on_selected') return `Run Flow on Selected (${params})`;\n\t\t\tif (key === 'run_flow') return 'Run Flow';\n\t\t\tif (key === 'run_flow_on_current_collection') return 'Run Flow on Current Collection';\n\t\t\tif (key === 'trigger_flow_success') return `Flow ${params?.flow} triggered successfully`;\n\t\t\treturn key;\n\t\t}),\n\t}),\n\tcreateI18n: vi.fn(() => ({})),\n}));\n\nvi.mock('@directus/composables', () => ({\n\tuseCollection: () => ({\n\t\tprimaryKeyField: ref({ field: 'id', type: 'integer' }),\n\t}),\n}));\n\nvi.mock('@/utils/notify');\n\nvi.mock('@/utils/translate-object-values', () => ({\n\ttranslate: vi.fn((obj) => obj),\n}));\n\nvi.mock('@/utils/unexpected-error');\n\nvi.mock('@directus/format-title', () => ({\n\tdefault: vi.fn((str) => str),\n}));\n\nvi.mock('@/api');\n\nvi.mock('@/stores/notifications', () => ({\n\tuseNotificationsStore: () => ({\n\t\trefreshUnreadCount: vi.fn(),\n\t}),\n}));\n\nbeforeEach(() => {\n\tsetActivePinia(\n\t\tcreateTestingPinia({\n\t\t\tcreateSpy: vi.fn,\n\t\t\tstubActions: false,\n\t\t}),\n\t);\n});\n\nafterEach(() => {\n\tvi.clearAllMocks();\n});\n\nconst mockOnRefresh = vi.fn();\n\nconst useFlowsOptions = {\n\tcollection: ref('test_collection'),\n\tprimaryKey: 'item_1',\n\tlocation: 'collection' as const,\n\thasEdits: ref(true),\n\tonRefreshCallback: mockOnRefresh,\n};\n\nconst mockFlows = [\n\t{\n\t\tid: 'flow-1',\n\t\tname: 'Test Flow 1',\n\t\ttrigger: 'manual',\n\t\tstatus: 'active',\n\t\toptions: {\n\t\t\tcollections: ['test_collection'],\n\t\t\tlocation: 'collection',\n\t\t\trequireConfirmation: true,\n\t\t\tconfirmationDescription: 'test-description-1',\n\t\t\tfields: [{ name: 'field-1', meta: { required: true } }],\n\t\t},\n\t},\n\t{\n\t\tid: 'flow-2',\n\t\tname: 'Test Flow 2',\n\t\ttrigger: 'manual',\n\t\tstatus: 'active',\n\t\toptions: {\n\t\t\tcollections: ['test_collection'],\n\t\t\tlocation: 'item',\n\t\t\trequireConfirmation: false,\n\t\t\trequireSelection: false,\n\t\t},\n\t},\n\t{\n\t\tid: 'flow-3',\n\t\tname: 'Test Flow 3',\n\t\ttrigger: 'event',\n\t\tstatus: 'active',\n\t\toptions: {\n\t\t\tcollections: ['test_collection'],\n\t\t\tlocation: 'item',\n\t\t\trequireConfirmation: true,\n\t\t\tconfirmationDescription: 'test-description-3',\n\t\t\trequireSelection: false,\n\t\t},\n\t},\n\t{\n\t\tid: 'flow-4',\n\t\tname: 'Test Flow 4',\n\t\ttrigger: 'event',\n\t\tstatus: 'active',\n\t\toptions: {\n\t\t\tcollections: ['test_collection'],\n\t\t\tlocation: 'collection',\n\t\t\trequireConfirmation: false,\n\t\t\tfields: [{ name: 'field-1', meta: { required: false } }],\n\t\t},\n\t},\n\t{\n\t\tid: 'flow-5',\n\t\tname: 'Test',\n\t\ttrigger: 'manual',\n\t\tstatus: 'active',\n\t\toptions: {\n\t\t\tcollections: ['test_collection'],\n\t\t\tlocation: 'collection',\n\t\t\trequireSelection: false,\n\t\t},\n\t},\n];\n\ndescribe('manualFlows', () => {\n\ttest('returns empty array when no manual flows', () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([]),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tconst { manualFlows } = useFlows(useFlowsOptions);\n\n\t\texpect(manualFlows.value.length).toEqual(0);\n\t\texpect(mockFlowsStore.getManualFlowsForCollection).toHaveBeenCalledWith('test_collection');\n\t});\n\n\ttest('returns manual flows when some are found', () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tconst { manualFlows } = useFlows(useFlowsOptions);\n\n\t\texpect(manualFlows.value.length).toEqual(3);\n\t\texpect(mockFlowsStore.getManualFlowsForCollection).toHaveBeenCalledWith('test_collection');\n\t});\n\n\ttest('returns collection specific flows when changing collection', async () => {\n\t\tconst mockGetManualFlows = vi.fn();\n\n\t\tmockGetManualFlows.mockReturnValue(mockFlows);\n\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: mockGetManualFlows,\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tconst testCollection = ref('test_collection');\n\n\t\tconst { manualFlows } = useFlows({ ...useFlowsOptions, collection: testCollection });\n\n\t\texpect(manualFlows.value.length).toEqual(3);\n\t\texpect(mockGetManualFlows).toHaveBeenLastCalledWith('test_collection');\n\n\t\tmockGetManualFlows.mockReturnValue([]);\n\n\t\ttestCollection.value = 'test_collection_2';\n\n\t\tawait nextTick();\n\n\t\texpect(manualFlows.value.length).toEqual(0);\n\t\texpect(mockGetManualFlows).toHaveBeenLastCalledWith('test_collection_2');\n\t\texpect(mockGetManualFlows).toHaveBeenCalledTimes(2);\n\t});\n});\n\ndescribe('manualFlow.isFlowDisabled', () => {\n\tdescribe('false', () => {\n\t\ttest('location is \"item\"', () => {\n\t\t\tconst testUseFlowsOptions = {\n\t\t\t\t...useFlowsOptions,\n\t\t\t\tlocation: 'item' as const,\n\t\t\t};\n\n\t\t\tconst mockFlowsStore = {\n\t\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlows[0]]),\n\t\t\t};\n\n\t\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\t\tconst { manualFlows } = useFlows(testUseFlowsOptions);\n\n\t\t\tmanualFlows.value.forEach((manualFlow) => {\n\t\t\t\texpect(manualFlow.isFlowDisabled).toEqual(false);\n\t\t\t});\n\t\t});\n\n\t\ttest('manualFlow.options.requireSelection is false', () => {\n\t\t\tconst mockFlowsStore = {\n\t\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlows[0]]),\n\t\t\t};\n\n\t\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\t\tconst { manualFlows } = useFlows(useFlowsOptions);\n\n\t\t\tmanualFlows.value.forEach((manualFlow) => {\n\t\t\t\texpect(manualFlow.isFlowDisabled).toEqual(false);\n\t\t\t});\n\t\t});\n\n\t\ttest('location is \"collection\" but has primaryKey', () => {\n\t\t\tconst mockFlow = { ...mockFlows[0], options: {} };\n\n\t\t\tconst mockFlowsStore = {\n\t\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlow]),\n\t\t\t};\n\n\t\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\t\tconst { manualFlows } = useFlows(useFlowsOptions);\n\n\t\t\tmanualFlows.value.forEach((manualFlow) => {\n\t\t\t\texpect(manualFlow.isFlowDisabled).toEqual(false);\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('true', () => {\n\t\ttest('location is \"collection\", no primaryKey, no selection, requireSelection not false', () => {\n\t\t\tconst testUseFlowsOptions = {\n\t\t\t\t...useFlowsOptions,\n\t\t\t\tprimaryKey: undefined,\n\t\t\t};\n\n\t\t\tconst mockFlow = { ...mockFlows[0], options: { requireSelection: true } };\n\n\t\t\tconst mockFlowsStore = {\n\t\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlow]),\n\t\t\t};\n\n\t\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\t\tconst { manualFlows } = useFlows(testUseFlowsOptions);\n\n\t\t\tmanualFlows.value.forEach((manualFlow) => {\n\t\t\t\texpect(manualFlow.isFlowDisabled).toEqual(true);\n\t\t\t});\n\t\t});\n\t});\n});\n\ndescribe('runManualFlow', () => {\n\ttest('returns early when selectedFlow is not found', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst { runManualFlow } = useFlows(useFlowsOptions);\n\n\t\tawait runManualFlow('non-existent-flow');\n\n\t\texpect(api.post).not.toHaveBeenCalled();\n\t});\n\n\ttest('returns early when flow is not in manualFlows (filtered out)', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlows[1]]),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst { runManualFlow } = useFlows(useFlowsOptions);\n\n\t\tawait runManualFlow(mockFlows[1]!.id);\n\n\t\texpect(api.post).not.toHaveBeenCalled();\n\t});\n\n\ttest('successfully runs flow for collection with requireSelection false', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue([mockFlows[4]]),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst { runManualFlow, flowDialogsContext } = useFlows(useFlowsOptions);\n\n\t\tconst { currentFlowId, confirmUnsavedChanges } = flowDialogsContext.value;\n\n\t\tconfirmUnsavedChanges(mockFlows[4]!.id);\n\n\t\tawait runManualFlow(mockFlows[4]!.id);\n\n\t\texpect(api.post).toHaveBeenCalledWith(`/flows/trigger/${mockFlows[4]!.id}`, {\n\t\t\tcollection: 'test_collection',\n\t\t});\n\n\t\texpect(currentFlowId).toBeNull();\n\t});\n\n\ttest('successfully runs flow with keys (primaryKey or selection)', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst testOptions = {\n\t\t\t...useFlowsOptions,\n\t\t\thasEdits: ref(false),\n\t\t};\n\n\t\tconst { runManualFlow, flowDialogsContext } = useFlows(testOptions);\n\n\t\tconst { currentFlowId } = flowDialogsContext.value;\n\n\t\tawait runManualFlow(mockFlows[4]!.id);\n\n\t\texpect(api.post).toHaveBeenCalledWith(`/flows/trigger/${mockFlows[4]!.id}`, {\n\t\t\tcollection: 'test_collection',\n\t\t});\n\n\t\texpect(currentFlowId).toBeNull();\n\t});\n\n\ttest('uses selection when no primaryKey is available', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst testOptions = {\n\t\t\t...useFlowsOptions,\n\t\t\tprimaryKey: undefined,\n\t\t\tselection: ref([{ id: 'item1' }, { id: 'item2' }]),\n\t\t\thasEdits: ref(false),\n\t\t};\n\n\t\tconst { runManualFlow } = useFlows(testOptions);\n\n\t\tawait runManualFlow(mockFlows[4]!.id);\n\n\t\texpect(api.post).toHaveBeenCalledWith(`/flows/trigger/${mockFlows[4]!.id}`, {\n\t\t\tcollection: 'test_collection',\n\t\t\tkeys: [{ id: 'item1' }, { id: 'item2' }],\n\t\t});\n\t});\n\n\ttest('calls onRefreshCallback', async () => {\n\t\tconst mockFlowsStore = {\n\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n\t\t};\n\n\t\tconst testOptions = {\n\t\t\t...useFlowsOptions,\n\t\t\thasEdits: ref(false),\n\t\t};\n\n\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n\n\t\tvi.mocked(api.post).mockResolvedValue({});\n\n\t\tconst { runManualFlow } = useFlows(testOptions);\n\n\t\tawait runManualFlow(mockFlows[3]!.id);\n\n\t\texpect(mockOnRefresh).toHaveBeenCalledOnce();\n\t});\n});",
            "cost": 0.1206
        },
        "directus__directus.447c91d0/app/src/composables/use-flows.ts": {
            "output": "import api from '@/api';\nimport { computed, ref, provide, inject, type Ref } from 'vue';\nimport { FlowRaw, Item, PrimaryKey } from '@directus/types';\nimport { notify } from '@/utils/notify';\nimport { translate } from '@/utils/translate-object-values';\nimport { unexpectedError } from '@/utils/unexpected-error';\nimport { useCollection } from '@directus/composables';\nimport { useFlowsStore } from '@/stores/flows';\nimport { useI18n } from 'vue-i18n';\nimport { useNotificationsStore } from '@/stores/notifications';\nimport formatTitle from '@directus/format-title';\n\ninterface UseFlowsOptions {\n\tcollection: Ref<string>;\n\tprimaryKey?: PrimaryKey | null;\n\tselection?: Ref<Item[]>;\n\tlocation: 'collection' | 'item';\n\thasEdits?: Ref<boolean>;\n\tonRefreshCallback: () => void;\n}\n\nexport type ManualFlow = FlowRaw & {\n\ttooltip: string;\n\tisFlowDisabled: boolean;\n};\n\nconst runManualFlowSymbol = 'runManualFlow';\n\nexport function useFlows(options: UseFlowsOptions) {\n\tconst { collection, hasEdits = ref(false), location, onRefreshCallback, primaryKey, selection = ref([]) } = options;\n\n\tconst { t } = useI18n();\n\tconst { primaryKeyField } = useCollection(collection);\n\tconst flowsStore = useFlowsStore();\n\tconst notificationStore = useNotificationsStore();\n\n\tconst runningFlows = ref<string[]>([]);\n\tconst confirmValues = ref<Record<string, any> | null>(null);\n\tconst confirmedUnsavedChanges = ref<boolean>(false);\n\tconst confirmedCustomDialog = ref<boolean>(false);\n\tconst currentFlowId = ref<string | null>(null);\n\n\tconst currentFlow = computed(() => {\n\t\tif (!currentFlowId.value) return null;\n\n\t\treturn manualFlows.value.find((flow) => flow.id === currentFlowId.value);\n\t});\n\n\tconst currentFlowConfirmations = computed(() => {\n\t\tif (!currentFlow.value) return null;\n\n\t\treturn {\n\t\t\tisUnsavedChangesConfirmationRequired: hasEdits.value,\n\t\t\tisUnsavedChangesConfirmed: confirmedUnsavedChanges.value,\n\t\t\tisCustomDialogConfirmationRequired: currentFlow.value.options?.requireConfirmation,\n\t\t\tisCustomDialogConfirmed: confirmedCustomDialog.value,\n\t\t};\n\t});\n\n\tconst flowDialogsContext = computed(() => ({\n\t\tconfirmButtonCTA: confirmButtonCTA.value,\n\t\tconfirmDialogDetails: confirmDialogDetails.value,\n\t\tconfirmUnsavedChanges,\n\t\tconfirmCustomDialog,\n\t\tconfirmValues: confirmValues.value,\n\t\tcurrentFlowId: currentFlowId.value,\n\t\tdisplayCustomConfirmDialog: displayCustomConfirmDialog.value,\n\t\tdisplayUnsavedChangesDialog: displayUnsavedChangesDialog.value,\n\t\tisConfirmButtonDisabled: isConfirmButtonDisabled.value,\n\t\tresetConfirm,\n\t\tupdateFieldValues,\n\t}));\n\n\tconst confirmButtonCTA = computed(() => {\n\t\tif (displayUnsavedChangesDialog.value) return t('run_flow_anyway');\n\t\tif (location === 'item') return t('run_flow_on_current');\n\t\tif (selection.value.length === 0) return t('run_flow');\n\t\treturn t('run_flow_on_selected', selection.value.length);\n\t});\n\n\tconst confirmDialogDetails = computed(() => {\n\t\tif (!currentFlow.value) return null;\n\n\t\tif (!currentFlow.value.options?.requireConfirmation) return null;\n\n\t\treturn {\n\t\t\tdescription: currentFlow.value.options.confirmationDescription,\n\t\t\tfields: (currentFlow.value.options.fields ?? []).map((field: Record<string, any>) => ({\n\t\t\t\t...field,\n\t\t\t\tname: !field.name && field.field ? formatTitle(field.field) : field.name,\n\t\t\t})),\n\t\t};\n\t});\n\n\tconst displayCustomConfirmDialog = computed(\n\t\t() =>\n\t\t\t!!currentFlowId.value &&\n\t\t\t!!confirmDialogDetails.value &&\n\t\t\t!!currentFlowConfirmations.value?.isCustomDialogConfirmationRequired &&\n\t\t\t!currentFlowConfirmations.value?.isCustomDialogConfirmed &&\n\t\t\t!displayUnsavedChangesDialog.value,\n\t);\n\n\tconst displayUnsavedChangesDialog = computed(\n\t\t() =>\n\t\t\t!!currentFlowId.value &&\n\t\t\t!!currentFlowConfirmations.value?.isUnsavedChangesConfirmationRequired &&\n\t\t\t!currentFlowConfirmations.value?.isUnsavedChangesConfirmed,\n\t);\n\n\tconst isConfirmButtonDisabled = computed(() => {\n\t\tif (!currentFlowId.value) return true;\n\n\t\tfor (const field of confirmDialogDetails.value?.fields || []) {\n\t\t\tif (\n\t\t\t\tfield.meta?.required &&\n\t\t\t\t(!confirmValues.value ||\n\t\t\t\t\tconfirmValues.value[field.field] === null ||\n\t\t\t\t\tconfirmValues.value[field.field] === undefined)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t});\n\n\tconst manualFlows = computed<ManualFlow[]>(() => {\n\t\tconst manualFlows = flowsStore\n\t\t\t.getManualFlowsForCollection(collection.value)\n\t\t\t.filter(\n\t\t\t\t(flow) => !flow.options?.location || flow.options?.location === 'both' || flow.options?.location === location,\n\t\t\t)\n\t\t\t.map((flow) => ({\n\t\t\t\t...flow,\n\t\t\t\toptions: flow.options ? translate(flow.options) : null,\n\t\t\t\ttooltip: getFlowTooltip(flow),\n\t\t\t\tisFlowDisabled: checkFlowDisabled(flow),\n\t\t\t}));\n\n\t\tfunction getFlowTooltip(manualFlow: FlowRaw) {\n\t\t\tif (location === 'item') return t('run_flow_on_current');\n\n\t\t\tif (manualFlow.options?.requireSelection === false && selection.value.length === 0) {\n\t\t\t\treturn t('run_flow_on_current_collection');\n\t\t\t}\n\n\t\t\treturn t('run_flow_on_selected', selection.value.length || 0);\n\t\t}\n\n\t\tfunction checkFlowDisabled(manualFlow: FlowRaw) {\n\t\t\tif (location === 'item' || manualFlow.options?.requireSelection === false) return false;\n\t\t\treturn !primaryKey && selection.value.length === 0;\n\t\t}\n\n\t\treturn manualFlows;\n\t});\n\n\tfunction isActiveFlow(flowId: string) {\n\t\tconst flow = manualFlows.value.find((flow) => flow.id === flowId);\n\n\t\treturn flow && flow.status === 'active';\n\t}\n\n\tfunction resetConfirm() {\n\t\tcurrentFlowId.value = null;\n\t\tconfirmValues.value = null;\n\t\tconfirmedUnsavedChanges.value = false;\n\t\tconfirmedCustomDialog.value = false;\n\t}\n\n\tfunction confirmUnsavedChanges(flowId: string) {\n\t\tconfirmedUnsavedChanges.value = true;\n\n\t\tif (!confirmDialogDetails.value) {\n\t\t\trunManualFlow(flowId);\n\t\t}\n\t}\n\n\tfunction confirmCustomDialog(flowId: string) {\n\t\tif (isConfirmButtonDisabled.value) return;\n\n\t\tconfirmedCustomDialog.value = true;\n\n\t\trunManualFlow(flowId);\n\t}\n\n\tfunction provideRunManualFlow() {\n\t\tprovide(runManualFlowSymbol, {\n\t\t\trunManualFlow,\n\t\t\trunningFlows,\n\t\t\tisActiveFlow,\n\t\t});\n\t}\n\n\tfunction updateFieldValues(event: Record<string, any>) {\n\t\tconfirmValues.value = event;\n\t}\n\n\tasync function runManualFlow(flowId: string) {\n\t\tcurrentFlowId.value = flowId;\n\n\t\tif (!currentFlowId.value || !currentFlow.value || !currentFlowConfirmations.value) return;\n\n\t\tconst {\n\t\t\tisUnsavedChangesConfirmationRequired,\n\t\t\tisUnsavedChangesConfirmed,\n\t\t\tisCustomDialogConfirmationRequired,\n\t\t\tisCustomDialogConfirmed,\n\t\t} = currentFlowConfirmations.value;\n\n\t\tif (\n\t\t\t(isUnsavedChangesConfirmationRequired && !isUnsavedChangesConfirmed) ||\n\t\t\t(isCustomDialogConfirmationRequired && !isCustomDialogConfirmed)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!primaryKeyField.value) return;\n\n\t\trunningFlows.value = [...runningFlows.value, flowId];\n\n\t\ttry {\n\t\t\tif (\n\t\t\t\tlocation === 'collection' &&\n\t\t\t\tcurrentFlow.value.options?.requireSelection === false &&\n\t\t\t\tselection.value.length === 0\n\t\t\t) {\n\t\t\t\tawait api.post(`/flows/trigger/${flowId}`, {\n\t\t\t\t\t...(confirmValues.value ?? {}),\n\t\t\t\t\tcollection: collection.value,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst keys = primaryKey ? [primaryKey] : selection.value || [];\n\n\t\t\t\tawait api.post(`/flows/trigger/${flowId}`, {\n\t\t\t\t\t...confirmValues.value,\n\t\t\t\t\tcollection: collection.value,\n\t\t\t\t\tkeys,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tonRefreshCallback();\n\n\t\t\tnotify({\n\t\t\t\ttitle: t('trigger_flow_success', { flow: currentFlow.value.name }),\n\t\t\t});\n\n\t\t\tawait notificationStore.refreshUnreadCount();\n\n\t\t\tresetConfirm();\n\t\t} catch (error) {\n\t\t\tunexpectedError(error);\n\t\t} finally {\n\t\t\trunningFlows.value = runningFlows.value.filter((runningFlow) => runningFlow !== flowId);\n\t\t}\n\t}\n\n\treturn {\n\t\tflowDialogsContext,\n\t\tmanualFlows,\n\t\tprovideRunManualFlow,\n\t\trunManualFlow,\n\t};\n}\n\n/**\n * In order to invoke useInjectRunManualFlow within a component, a parent component must first invoke `provideRunManualFlow()`.\n *\n * This parent component must also render the <flow-dialogs> component or the confirmation dialogs will not be reachable.\n */\nexport function useInjectRunManualFlow() {\n\treturn inject(runManualFlowSymbol, {\n\t\trunManualFlow: (_flowId: string) => {},\n\t\trunningFlows: ref<string[]>([]),\n\t\tisActiveFlow: (_flowId: string) => false,\n\t});\n}",
            "output_extracted": "import api from '@/api';\nimport { computed, ref, provide, inject, type Ref } from 'vue';\nimport { FlowRaw, Item, PrimaryKey } from '@directus/types';\nimport { notify } from '@/utils/notify';\nimport { translate } from '@/utils/translate-object-values';\nimport { unexpectedError } from '@/utils/unexpected-error';\nimport { useCollection } from '@directus/composables';\nimport { useFlowsStore } from '@/stores/flows';\nimport { useI18n } from 'vue-i18n';\nimport { useNotificationsStore } from '@/stores/notifications';\nimport formatTitle from '@directus/format-title';\n\ninterface UseFlowsOptions {\n\tcollection: Ref<string>;\n\tprimaryKey?: PrimaryKey | null;\n\tselection?: Ref<Item[]>;\n\tlocation: 'collection' | 'item';\n\thasEdits?: Ref<boolean>;\n\tonRefreshCallback: () => void;\n}\n\nexport type ManualFlow = FlowRaw & {\n\ttooltip: string;\n\tisFlowDisabled: boolean;\n};\n\nconst runManualFlowSymbol = 'runManualFlow';\n\nexport function useFlows(options: UseFlowsOptions) {\n\tconst { collection, hasEdits = ref(false), location, onRefreshCallback, primaryKey, selection = ref([]) } = options;\n\n\tconst { t } = useI18n();\n\tconst { primaryKeyField } = useCollection(collection);\n\tconst flowsStore = useFlowsStore();\n\tconst notificationStore = useNotificationsStore();\n\n\tconst runningFlows = ref<string[]>([]);\n\tconst confirmValues = ref<Record<string, any> | null>(null);\n\tconst confirmedUnsavedChanges = ref<boolean>(false);\n\tconst confirmedCustomDialog = ref<boolean>(false);\n\tconst currentFlowId = ref<string | null>(null);\n\n\tconst currentFlow = computed(() => {\n\t\tif (!currentFlowId.value) return null;\n\n\t\treturn manualFlows.value.find((flow) => flow.id === currentFlowId.value);\n\t});\n\n\tconst currentFlowConfirmations = computed(() => {\n\t\tif (!currentFlow.value) return null;\n\n\t\treturn {\n\t\t\tisUnsavedChangesConfirmationRequired: hasEdits.value,\n\t\t\tisUnsavedChangesConfirmed: confirmedUnsavedChanges.value,\n\t\t\tisCustomDialogConfirmationRequired: currentFlow.value.options?.requireConfirmation,\n\t\t\tisCustomDialogConfirmed: confirmedCustomDialog.value,\n\t\t};\n\t});\n\n\tconst flowDialogsContext = computed(() => ({\n\t\tconfirmButtonCTA: confirmButtonCTA.value,\n\t\tconfirmDialogDetails: confirmDialogDetails.value,\n\t\tconfirmUnsavedChanges,\n\t\tconfirmCustomDialog,\n\t\tconfirmValues: confirmValues.value,\n\t\tcurrentFlowId: currentFlowId.value,\n\t\tdisplayCustomConfirmDialog: displayCustomConfirmDialog.value,\n\t\tdisplayUnsavedChangesDialog: displayUnsavedChangesDialog.value,\n\t\tisConfirmButtonDisabled: isConfirmButtonDisabled.value,\n\t\tresetConfirm,\n\t\tupdateFieldValues,\n\t}));\n\n\tconst confirmButtonCTA = computed(() => {\n\t\tif (displayUnsavedChangesDialog.value) return t('run_flow_anyway');\n\t\tif (location === 'item') return t('run_flow_on_current');\n\t\tif (selection.value.length === 0) return t('run_flow');\n\t\treturn t('run_flow_on_selected', selection.value.length);\n\t});\n\n\tconst confirmDialogDetails = computed(() => {\n\t\tif (!currentFlow.value) return null;\n\n\t\tif (!currentFlow.value.options?.requireConfirmation) return null;\n\n\t\treturn {\n\t\t\tdescription: currentFlow.value.options.confirmationDescription,\n\t\t\tfields: (currentFlow.value.options.fields ?? []).map((field: Record<string, any>) => ({\n\t\t\t\t...field,\n\t\t\t\tname: !field.name && field.field ? formatTitle(field.field) : field.name,\n\t\t\t})),\n\t\t};\n\t});\n\n\tconst displayCustomConfirmDialog = computed(\n\t\t() =>\n\t\t\t!!currentFlowId.value &&\n\t\t\t!!confirmDialogDetails.value &&\n\t\t\t!!currentFlowConfirmations.value?.isCustomDialogConfirmationRequired &&\n\t\t\t!currentFlowConfirmations.value?.isCustomDialogConfirmed &&\n\t\t\t!displayUnsavedChangesDialog.value,\n\t);\n\n\tconst displayUnsavedChangesDialog = computed(\n\t\t() =>\n\t\t\t!!currentFlowId.value &&\n\t\t\t!!currentFlowConfirmations.value?.isUnsavedChangesConfirmationRequired &&\n\t\t\t!currentFlowConfirmations.value?.isUnsavedChangesConfirmed,\n\t);\n\n\tconst isConfirmButtonDisabled = computed(() => {\n\t\tif (!currentFlowId.value) return true;\n\n\t\tfor (const field of confirmDialogDetails.value?.fields || []) {\n\t\t\tif (\n\t\t\t\tfield.meta?.required &&\n\t\t\t\t(!confirmValues.value ||\n\t\t\t\t\tconfirmValues.value[field.field] === null ||\n\t\t\t\t\tconfirmValues.value[field.field] === undefined)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t});\n\n\tconst manualFlows = computed<ManualFlow[]>(() => {\n\t\tconst manualFlows = flowsStore\n\t\t\t.getManualFlowsForCollection(collection.value)\n\t\t\t.filter(\n\t\t\t\t(flow) => !flow.options?.location || flow.options?.location === 'both' || flow.options?.location === location,\n\t\t\t)\n\t\t\t.map((flow) => ({\n\t\t\t\t...flow,\n\t\t\t\toptions: flow.options ? translate(flow.options) : null,\n\t\t\t\ttooltip: getFlowTooltip(flow),\n\t\t\t\tisFlowDisabled: checkFlowDisabled(flow),\n\t\t\t}));\n\n\t\tfunction getFlowTooltip(manualFlow: FlowRaw) {\n\t\t\tif (location === 'item') return t('run_flow_on_current');\n\n\t\t\tif (manualFlow.options?.requireSelection === false && selection.value.length === 0) {\n\t\t\t\treturn t('run_flow_on_current_collection');\n\t\t\t}\n\n\t\t\treturn t('run_flow_on_selected', selection.value.length || 0);\n\t\t}\n\n\t\tfunction checkFlowDisabled(manualFlow: FlowRaw) {\n\t\t\tif (location === 'item' || manualFlow.options?.requireSelection === false) return false;\n\t\t\treturn !primaryKey && selection.value.length === 0;\n\t\t}\n\n\t\treturn manualFlows;\n\t});\n\n\tfunction isActiveFlow(flowId: string) {\n\t\tconst flow = manualFlows.value.find((flow) => flow.id === flowId);\n\n\t\treturn flow && flow.status === 'active';\n\t}\n\n\tfunction resetConfirm() {\n\t\tcurrentFlowId.value = null;\n\t\tconfirmValues.value = null;\n\t\tconfirmedUnsavedChanges.value = false;\n\t\tconfirmedCustomDialog.value = false;\n\t}\n\n\tfunction confirmUnsavedChanges(flowId: string) {\n\t\tconfirmedUnsavedChanges.value = true;\n\n\t\tif (!confirmDialogDetails.value) {\n\t\t\trunManualFlow(flowId);\n\t\t}\n\t}\n\n\tfunction confirmCustomDialog(flowId: string) {\n\t\tif (isConfirmButtonDisabled.value) return;\n\n\t\tconfirmedCustomDialog.value = true;\n\n\t\trunManualFlow(flowId);\n\t}\n\n\tfunction provideRunManualFlow() {\n\t\tprovide(runManualFlowSymbol, {\n\t\t\trunManualFlow,\n\t\t\trunningFlows,\n\t\t\tisActiveFlow,\n\t\t});\n\t}\n\n\tfunction updateFieldValues(event: Record<string, any>) {\n\t\tconfirmValues.value = event;\n\t}\n\n\tasync function runManualFlow(flowId: string) {\n\t\tcurrentFlowId.value = flowId;\n\n\t\tif (!currentFlowId.value || !currentFlow.value || !currentFlowConfirmations.value) return;\n\n\t\tconst {\n\t\t\tisUnsavedChangesConfirmationRequired,\n\t\t\tisUnsavedChangesConfirmed,\n\t\t\tisCustomDialogConfirmationRequired,\n\t\t\tisCustomDialogConfirmed,\n\t\t} = currentFlowConfirmations.value;\n\n\t\tif (\n\t\t\t(isUnsavedChangesConfirmationRequired && !isUnsavedChangesConfirmed) ||\n\t\t\t(isCustomDialogConfirmationRequired && !isCustomDialogConfirmed)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!primaryKeyField.value) return;\n\n\t\trunningFlows.value = [...runningFlows.value, flowId];\n\n\t\ttry {\n\t\t\tif (\n\t\t\t\tlocation === 'collection' &&\n\t\t\t\tcurrentFlow.value.options?.requireSelection === false &&\n\t\t\t\tselection.value.length === 0\n\t\t\t) {\n\t\t\t\tawait api.post(`/flows/trigger/${flowId}`, {\n\t\t\t\t\t...(confirmValues.value ?? {}),\n\t\t\t\t\tcollection: collection.value,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst keys = primaryKey ? [primaryKey] : selection.value || [];\n\n\t\t\t\tawait api.post(`/flows/trigger/${flowId}`, {\n\t\t\t\t\t...confirmValues.value,\n\t\t\t\t\tcollection: collection.value,\n\t\t\t\t\tkeys,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tonRefreshCallback();\n\n\t\t\tnotify({\n\t\t\t\ttitle: t('trigger_flow_success', { flow: currentFlow.value.name }),\n\t\t\t});\n\n\t\t\tawait notificationStore.refreshUnreadCount();\n\n\t\t\tresetConfirm();\n\t\t} catch (error) {\n\t\t\tunexpectedError(error);\n\t\t} finally {\n\t\t\trunningFlows.value = runningFlows.value.filter((runningFlow) => runningFlow !== flowId);\n\t\t}\n\t}\n\n\treturn {\n\t\tflowDialogsContext,\n\t\tmanualFlows,\n\t\tprovideRunManualFlow,\n\t\trunManualFlow,\n\t};\n}\n\n/**\n * In order to invoke useInjectRunManualFlow within a component, a parent component must first invoke `provideRunManualFlow()`.\n *\n * This parent component must also render the <flow-dialogs> component or the confirmation dialogs will not be reachable.\n */\nexport function useInjectRunManualFlow() {\n\treturn inject(runManualFlowSymbol, {\n\t\trunManualFlow: (_flowId: string) => {},\n\t\trunningFlows: ref<string[]>([]),\n\t\tisActiveFlow: (_flowId: string) => false,\n\t});\n}",
            "cost": 0.08514000000000001
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "directus/directus",
        "instance_id": "directus__directus.pr_mirror.26287",
        "base_commit": "b5b80b78b87f7f2dcfc38b495f7b966199c37b98",
        "patch": "diff --git a/.changeset/stale-onions-attend.md b/.changeset/stale-onions-attend.md\nnew file mode 100644\nindex 0000000000000..52af1e2e93ebc\n--- /dev/null\n+++ b/.changeset/stale-onions-attend.md\n@@ -0,0 +1,5 @@\n+---\n+'@directus/app': patch\n+---\n+\n+Added reactive primaryKey prop to useFlows composable\ndiff --git a/app/src/composables/use-flows.test.ts b/app/src/composables/use-flows.test.ts\nindex dea978def3f68..86531596b851e 100644\n--- a/app/src/composables/use-flows.test.ts\n+++ b/app/src/composables/use-flows.test.ts\n@@ -65,7 +65,7 @@ const mockOnRefresh = vi.fn();\n \n const useFlowsOptions = {\n \tcollection: ref('test_collection'),\n-\tprimaryKey: 'item_1',\n+\tprimaryKey: ref('item_1'),\n \tlocation: 'collection' as const,\n \thasEdits: ref(true),\n \tonRefreshCallback: mockOnRefresh,\n@@ -398,4 +398,39 @@ describe('runManualFlow', () => {\n \n \t\texpect(mockOnRefresh).toHaveBeenCalledOnce();\n \t});\n+\n+\ttest('calls runFlow with reactive primaryKey', async () => {\n+\t\tconst mockFlowsStore = {\n+\t\t\tgetManualFlowsForCollection: vi.fn().mockReturnValue(mockFlows),\n+\t\t};\n+\n+\t\tconst testOptions = {\n+\t\t\t...useFlowsOptions,\n+\t\t\tprimaryKey: ref('item_1'),\n+\t\t\thasEdits: ref(false),\n+\t\t\tlocation: 'item' as const,\n+\t\t};\n+\n+\t\tvi.mocked(useFlowsStore).mockReturnValue(mockFlowsStore as any);\n+\n+\t\tvi.mocked(api.post).mockResolvedValue({});\n+\n+\t\tconst { runManualFlow } = useFlows(testOptions);\n+\n+\t\tawait runManualFlow(mockFlows[1]!.id);\n+\n+\t\texpect(api.post).toHaveBeenCalledWith(`/flows/trigger/${mockFlows[1]!.id}`, {\n+\t\t\tcollection: 'test_collection',\n+\t\t\tkeys: ['item_1'],\n+\t\t});\n+\n+\t\ttestOptions.primaryKey.value = 'item_2';\n+\n+\t\tawait runManualFlow(mockFlows[1]!.id);\n+\n+\t\texpect(api.post).toHaveBeenCalledWith(`/flows/trigger/${mockFlows[1]!.id}`, {\n+\t\t\tcollection: 'test_collection',\n+\t\t\tkeys: ['item_2'],\n+\t\t});\n+\t});\n });\ndiff --git a/app/src/composables/use-flows.ts b/app/src/composables/use-flows.ts\nindex 5db04b47c5a25..09428d2fea657 100644\n--- a/app/src/composables/use-flows.ts\n+++ b/app/src/composables/use-flows.ts\n@@ -1,5 +1,5 @@\n import api from '@/api';\n-import { computed, ref, provide, inject, type Ref } from 'vue';\n+import { computed, ref, provide, inject, unref, type Ref } from 'vue';\n import { FlowRaw, Item, PrimaryKey } from '@directus/types';\n import { notify } from '@/utils/notify';\n import { translate } from '@/utils/translate-object-values';\n@@ -12,7 +12,7 @@ import formatTitle from '@directus/format-title';\n \n interface UseFlowsOptions {\n \tcollection: Ref<string>;\n-\tprimaryKey?: PrimaryKey | null;\n+\tprimaryKey?: Ref<PrimaryKey | null>;\n \tselection?: Ref<Item[]>;\n \tlocation: 'collection' | 'item';\n \thasEdits?: Ref<boolean>;\n@@ -150,7 +150,7 @@ export function useFlows(options: UseFlowsOptions) {\n \n \t\tfunction checkFlowDisabled(manualFlow: FlowRaw) {\n \t\t\tif (location === 'item' || manualFlow.options?.requireSelection === false) return false;\n-\t\t\treturn !primaryKey && selection.value.length === 0;\n+\t\t\treturn !unref(primaryKey) && selection.value.length === 0;\n \t\t}\n \n \t\treturn manualFlows;\n@@ -231,7 +231,8 @@ export function useFlows(options: UseFlowsOptions) {\n \t\t\t\t\tcollection: collection.value,\n \t\t\t\t});\n \t\t\t} else {\n-\t\t\t\tconst keys = primaryKey ? [primaryKey] : selection.value || [];\n+\t\t\t\tconst pk = unref(primaryKey);\n+\t\t\t\tconst keys = pk ? [pk] : selection.value || [];\n \n \t\t\t\tawait api.post(`/flows/trigger/${flowId}`, {\n \t\t\t\t\t...confirmValues.value,\ndiff --git a/app/src/modules/content/routes/item.vue b/app/src/modules/content/routes/item.vue\nindex e2805771de963..cbed86fcc16ae 100644\n--- a/app/src/modules/content/routes/item.vue\n+++ b/app/src/modules/content/routes/item.vue\n@@ -304,7 +304,7 @@ watch(\n \n const { flowDialogsContext, manualFlows, provideRunManualFlow } = useFlows({\n \tcollection,\n-\tprimaryKey: actualPrimaryKey.value,\n+\tprimaryKey: actualPrimaryKey,\n \tlocation: 'item',\n \thasEdits,\n \tonRefreshCallback: refresh,\ndiff --git a/app/src/views/private/components/overlay-item.vue b/app/src/views/private/components/overlay-item.vue\nindex 0f16dc55e6290..5afae6a4c3a4d 100644\n--- a/app/src/views/private/components/overlay-item.vue\n+++ b/app/src/views/private/components/overlay-item.vue\n@@ -244,7 +244,7 @@ const overlayItemContentProps = computed(() => {\n \n const { provideRunManualFlow } = useFlows({\n \tcollection,\n-\tprimaryKey: primaryKey.value,\n+\tprimaryKey: primaryKey,\n \tlocation: 'item',\n \thasEdits,\n \tonRefreshCallback: refresh,\n",
        "test_patch": "",
        "problem_statement": "## Scope\r\n\r\nWhat's changed:\r\n\r\n- Fixes issue where navigating from one item to another directly does not update the useFlows primaryKey because it was not reactive\r\n\r\n## Potential Risks / Drawbacks\r\n\r\n- Manually triggered flows stop working\r\n\r\n## Tested Scenarios\r\n\r\n- Tested running flow on item\r\n- Tested running flow on collection\r\n- Tested running flow on item in drawer\r\n- Tested running flow on item after direct navigation\r\n\r\n## Review Notes / Questions\r\n\r\n- Tests all still pass + added new test for this case\r\n\r\n## Checklist\r\n\r\n- [x] Added or updated tests\r\n- [x] Documentation PR created [here](https://github.com/directus/docs) or not required\r\n- [x] OpenAPI package PR created [here](https://github.com/directus/openapi) or not required\r\n\r\n---\r\n\r\nFixes CMS-1537\r\n",
        "hints_text": "",
        "created_at": "2025-12-01T22:17:39Z",
        "pull_number": 26287,
        "test_files": [
            "app/src/composables/use-flows.test.ts"
        ],
        "code_files": [
            "app/src/composables/use-flows.ts"
        ],
        "title": "Add reactive primaryKey prop to useFlows composable",
        "additions": 0,
        "deletions": 0,
        "pr_mirror": "directus__directus.447c91d0"
    }
}