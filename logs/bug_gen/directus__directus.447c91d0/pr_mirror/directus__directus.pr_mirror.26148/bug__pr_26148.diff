diff --git a/api/src/services/graphql/schema/parse-query.ts b/api/src/services/graphql/schema/parse-query.ts
index 86ac294..c92d031 100644
--- a/api/src/services/graphql/schema/parse-query.ts
+++ b/api/src/services/graphql/schema/parse-query.ts
@@ -138,13 +138,13 @@ export async function getQuery(
 
 	if (collection) {
 		if (query.filter) {
-			query.filter = filterReplaceM2A(query.filter, collection, schema, { aliasMap: query.alias });
+			query.filter = filterReplaceM2A(query.filter, collection, schema);
 		}
 
-		query.deep = filterReplaceM2ADeep(query.deep, collection, schema, { aliasMap: query.alias });
+		query.deep = filterReplaceM2ADeep(query.deep, collection, schema);
 	}
 
 	validateQuery(query);
 
 	return query;
-}
+}
\ No newline at end of file
diff --git a/api/src/services/graphql/utils/filter-replace-m2a.test.ts b/api/src/services/graphql/utils/filter-replace-m2a.test.ts
index 57a6ef0..d9728c2 100644
--- a/api/src/services/graphql/utils/filter-replace-m2a.test.ts
+++ b/api/src/services/graphql/utils/filter-replace-m2a.test.ts
@@ -1,5 +1,5 @@
 import { RelationBuilder, SchemaBuilder } from '@directus/schema-builder';
-import { describe, expect, test } from 'vitest';
+import { expect, test } from 'vitest';
 import { filterReplaceM2A, filterReplaceM2ADeep } from './filter-replace-m2a.js';
 
 const schema = new SchemaBuilder()
@@ -22,128 +22,87 @@ const schema = new SchemaBuilder()
 	})
 	.build();
 
-describe('filterReplaceM2A', () => {
-	test('empty filter', () => {
-		const result = filterReplaceM2A({}, 'article', { collections: {}, relations: [] });
+test('empty filter', () => {
+	const result = filterReplaceM2A({}, 'article', { collections: {}, relations: [] });
 
-		expect(result).toEqual({});
-	});
-
-	test('filter with aliases field', () => {
-		const result = filterReplaceM2A(
-			{
-				id: { _eq: 1 },
-				aliased_blocks: {
-					anyitem__text: {
-						id: { _eq: 1 },
-						content: { _eq: 'Hello World' },
-					},
-				},
-			},
-			'article',
-			schema,
-			{ aliasMap: { aliased_blocks: 'blocks' } },
-		);
-
-		expect(result).toEqual({
-			id: { _eq: 1 },
-			aliased_blocks: {
-				'anyitem:text': {
-					id: { _eq: 1 },
-					content: { _eq: 'Hello World' },
-				},
-			},
-		});
-	});
-
-	test('filter with no relations', () => {
-		const result = filterReplaceM2A(
-			{
-				id: {
-					_eq: 1,
-				},
-				some: {
-					_eq: 'value',
-				},
-			},
-			'article',
-			{ collections: {}, relations: [] },
-		);
+	expect(result).toEqual({});
+});
 
-		expect(result).toEqual({
+test('filter with no relations', () => {
+	const result = filterReplaceM2A(
+		{
 			id: {
 				_eq: 1,
 			},
 			some: {
 				_eq: 'value',
 			},
-		});
+		},
+		'article',
+		{ collections: {}, relations: [] },
+	);
+
+	expect(result).toEqual({
+		id: {
+			_eq: 1,
+		},
+		some: {
+			_eq: 'value',
+		},
 	});
+});
 
-	test('filter with a m2o relation', () => {
-		const result = filterReplaceM2A(
-			{
-				id: { _eq: 1 },
-				author: {
-					id: { _eq: 1 },
-					name: { _eq: 'John Doe' },
-				},
-			},
-			'article',
-			schema,
-		);
-
-		expect(result).toEqual({
+test('filter with a m2o relation', () => {
+	const result = filterReplaceM2A(
+		{
 			id: { _eq: 1 },
 			author: {
 				id: { _eq: 1 },
 				name: { _eq: 'John Doe' },
 			},
-		});
+		},
+		'article',
+		schema,
+	);
+
+	expect(result).toEqual({
+		id: { _eq: 1 },
+		author: {
+			id: { _eq: 1 },
+			name: { _eq: 'John Doe' },
+		},
 	});
+});
 
-	test('filter with a a2o relation', () => {
-		const result = filterReplaceM2A(
-			{
-				id: { _eq: 1 },
-				blocks: {
-					anyitem__text: {
-						id: { _eq: 1 },
-						content: { _eq: 'Hello World' },
-					},
-				},
-			},
-			'article',
-			schema,
-		);
-
-		expect(result).toEqual({
+test('filter with a a2o relation', () => {
+	const result = filterReplaceM2A(
+		{
 			id: { _eq: 1 },
 			blocks: {
-				'anyitem:text': {
+				anyitem__text: {
 					id: { _eq: 1 },
 					content: { _eq: 'Hello World' },
 				},
 			},
-		});
-	});
-
-	test('filter with a fake a2o relation', () => {
-		const result = filterReplaceM2A(
-			{
+		},
+		'article',
+		schema,
+	);
+
+	expect(result).toEqual({
+		id: { _eq: 1 },
+		blocks: {
+			'anyitem:text': {
 				id: { _eq: 1 },
-				blocks: {
-					item__text: {
-						id: { _eq: 1 },
-						content: { _eq: 'Hello World' },
-					},
-				},
+				content: { _eq: 'Hello World' },
 			},
-			'article',
-			schema,
-		);
+		},
+	});
+});
 
-		expect(result).toEqual({
+test('filter with a fake a2o relation', () => {
+	const result = filterReplaceM2A(
+		{
 			id: { _eq: 1 },
 			blocks: {
 				item__text: {
@@ -151,57 +110,57 @@ describe('filterReplaceM2A', () => {
 					content: { _eq: 'Hello World' },
 				},
 			},
-		});
-	});
-
-	test('filter with a a2o relation inside _and', () => {
-		const result = filterReplaceM2A(
-			{
-				_and: [
-					{
-						blocks: {
-							anyitem__text: {
-								id: { _eq: 1 },
-								content: { _eq: 'Hello World' },
-							},
-						},
-					},
-				],
+		},
+		'article',
+		schema,
+	);
+
+	expect(result).toEqual({
+		id: { _eq: 1 },
+		blocks: {
+			item__text: {
+				id: { _eq: 1 },
+				content: { _eq: 'Hello World' },
 			},
-			'article',
-			schema,
-		);
+		},
+	});
+});
 
-		expect(result).toEqual({
+test('filter with a a2o relation inside _and', () => {
+	const result = filterReplaceM2A(
+		{
 			_and: [
 				{
 					blocks: {
-						'anyitem:text': {
+						anyitem__text: {
 							id: { _eq: 1 },
 							content: { _eq: 'Hello World' },
 						},
 					},
 				},
 			],
-		});
-	});
+		},
+		'article',
+		schema,
+	);
 
-	test('filter with a a2o relation and wrong target collection', () => {
-		const result = filterReplaceM2A(
+	expect(result).toEqual({
+		_and: [
 			{
-				id: { _eq: 1 },
 				blocks: {
-					anyitem__wrong: {
+					'anyitem:text': {
 						id: { _eq: 1 },
 						content: { _eq: 'Hello World' },
 					},
 				},
 			},
-			'article',
-			schema,
-		);
+		],
+	});
+});
 
-		expect(result).toEqual({
+test('filter with a a2o relation and wrong target collection', () => {
+	const result = filterReplaceM2A(
+		{
 			id: { _eq: 1 },
 			blocks: {
 				anyitem__wrong: {
@@ -209,171 +168,79 @@ describe('filterReplaceM2A', () => {
 					content: { _eq: 'Hello World' },
 				},
 			},
-		});
+		},
+		'article',
+		schema,
+	);
+
+	expect(result).toEqual({
+		id: { _eq: 1 },
+		blocks: {
+			anyitem__wrong: {
+				id: { _eq: 1 },
+				content: { _eq: 'Hello World' },
+			},
+		},
 	});
 });
 
-describe('filterReplaceM2aDeep', () => {
-	test('empty filter', () => {
-		const result = filterReplaceM2ADeep({}, 'article', { collections: {}, relations: [] });
-
-		expect(result).toEqual({});
-	});
-
-	test('deep with filter', () => {
-		const result = filterReplaceM2ADeep(
-			{
-				blocks: {
-					_filter: {
-						id: { _eq: 1 },
-						content: { _eq: 'Hello World' },
-					},
-				},
-			},
-			'article',
-			schema,
-		);
-
-		expect(result).toEqual({
+test('deep with filter', () => {
+	const result = filterReplaceM2ADeep(
+		{
 			blocks: {
 				_filter: {
 					id: { _eq: 1 },
 					content: { _eq: 'Hello World' },
 				},
 			},
-		});
-	});
-
-	test('filter with aliased relation', () => {
-		const result = filterReplaceM2ADeep(
-			{
-				aliased_blocks: {
-					_filter: {
-						anyitem__text: {
-							id: { _eq: 1 },
-							content: { _eq: 'Hello World' },
-						},
-					},
-				},
-			},
-			'article',
-			schema,
-			{ aliasMap: { aliased_blocks: 'blocks' } },
-		);
-
-		expect(result).toEqual({
-			aliased_blocks: {
-				_filter: {
-					'anyitem:text': {
-						id: { _eq: 1 },
-						content: { _eq: 'Hello World' },
-					},
-				},
-			},
-		});
-	});
-
-	test('filter with nested aliased relation', () => {
-		const result = filterReplaceM2ADeep(
-			{
-				aliased_blocks: {
-					article_id: {
-						_alias: { aliased_blocks: 'blocks' },
-						aliased_blocks: {
-							_filter: {
-								anyitem__text: {
-									id: { _eq: 1 },
-									content: { _eq: 'Hello World' },
-								},
-							},
-						},
-					},
-					_filter: {
-						anyitem__text: {
-							id: { _eq: 1 },
-							content: { _eq: 'Hello World' },
-						},
-					},
-				},
-			},
-			'article',
-			schema,
-			{ aliasMap: { aliased_blocks: 'blocks' } },
-		);
-
-		expect(result).toEqual({
-			aliased_blocks: {
-				article_id: {
-					_alias: {
-						aliased_blocks: 'blocks',
-					},
-					aliased_blocks: {
-						_filter: {
-							'anyitem:text': {
-								id: { _eq: 1 },
-								content: { _eq: 'Hello World' },
-							},
-						},
-					},
-				},
-				_filter: {
-					'anyitem:text': {
-						id: { _eq: 1 },
-						content: { _eq: 'Hello World' },
-					},
-				},
+		},
+		'article',
+		schema,
+	);
+
+	expect(result).toEqual({
+		blocks: {
+			_filter: {
+				id: { _eq: 1 },
+				content: { _eq: 'Hello World' },
 			},
-		});
+		},
 	});
+});
 
-	test('deep with filter having a2o', () => {
-		const result = filterReplaceM2ADeep(
-			{
-				blocks: {
-					_filter: {
-						anyitem__text: {
-							id: { _eq: 1 },
-							content: { _eq: 'Hello World' },
-						},
-					},
-				},
-			},
-			'article',
-			schema,
-		);
-
-		expect(result).toEqual({
+test('deep with filter having a2o', () => {
+	const result = filterReplaceM2ADeep(
+		{
 			blocks: {
 				_filter: {
-					'anyitem:text': {
+					anyitem__text: {
 						id: { _eq: 1 },
 						content: { _eq: 'Hello World' },
 					},
 				},
 			},
-		});
-	});
-
-	test('deep with nested filter having a2o', () => {
-		const result = filterReplaceM2ADeep(
-			{
-				blocks: {
-					anyitem__text: {
-						blocks: {
-							_filter: {
-								id: { _eq: 1 },
-							},
-						},
-					},
+		},
+		'article',
+		schema,
+	);
+
+	expect(result).toEqual({
+		blocks: {
+			_filter: {
+				'anyitem:text': {
+					id: { _eq: 1 },
+					content: { _eq: 'Hello World' },
 				},
 			},
-			'article',
-			schema,
-		);
+		},
+	});
+});
 
-		expect(result).toEqual({
+test('deep with nested filter having a2o', () => {
+	const result = filterReplaceM2ADeep(
+		{
 			blocks: {
-				'anyitem:text': {
+				anyitem__text: {
 					blocks: {
 						_filter: {
 							id: { _eq: 1 },
@@ -381,26 +248,27 @@ describe('filterReplaceM2aDeep', () => {
 					},
 				},
 			},
-		});
-	});
-
-	test('deep with filter having a2o on wrong deep', () => {
-		const result = filterReplaceM2ADeep(
-			{
-				wrong: {
+		},
+		'article',
+		schema,
+	);
+
+	expect(result).toEqual({
+		blocks: {
+			'anyitem:text': {
+				blocks: {
 					_filter: {
-						anyitem__text: {
-							id: { _eq: 1 },
-							content: { _eq: 'Hello World' },
-						},
+						id: { _eq: 1 },
 					},
 				},
 			},
-			'article',
-			schema,
-		);
+		},
+	});
+});
 
-		expect(result).toEqual({
+test('deep with filter having a2o on wrong deep', () => {
+	const result = filterReplaceM2ADeep(
+		{
 			wrong: {
 				_filter: {
 					anyitem__text: {
@@ -409,6 +277,19 @@ describe('filterReplaceM2aDeep', () => {
 					},
 				},
 			},
-		});
+		},
+		'article',
+		schema,
+	);
+
+	expect(result).toEqual({
+		wrong: {
+			_filter: {
+				anyitem__text: {
+					id: { _eq: 1 },
+					content: { _eq: 'Hello World' },
+				},
+			},
+		},
 	});
-});
+});
\ No newline at end of file
diff --git a/api/src/services/graphql/utils/filter-replace-m2a.ts b/api/src/services/graphql/utils/filter-replace-m2a.ts
index a14ce0d..af6488b 100644
--- a/api/src/services/graphql/utils/filter-replace-m2a.ts
+++ b/api/src/services/graphql/utils/filter-replace-m2a.ts
@@ -1,43 +1,34 @@
-import type { DeepQuery, Filter, NestedDeepQuery, Query, SchemaOverview } from '@directus/types';
+import type { Filter, NestedDeepQuery, SchemaOverview } from '@directus/types';
 import { getRelation } from '@directus/utils';
 import { getRelationType } from '../../../utils/get-relation-type.js';
 
-export function filterReplaceM2A(
-	filter_arg: Filter,
-	collection: string,
-	schema: SchemaOverview,
-	options?: { aliasMap?: Query['alias'] },
-): any {
+export function filterReplaceM2A(filter_arg: Filter, collection: string, schema: SchemaOverview): any {
 	const filter: any = filter_arg;
 
 	for (const key in filter) {
-		const parts = key.split('__');
-		let field = parts[0];
-		const any_collection = parts[1];
+		const [field, any_collection] = key.split('__');
 
 		if (!field) continue;
 
-		field = options?.aliasMap?.[field] ?? field;
-
 		const relation = getRelation(schema.relations, collection, field);
 		const type = relation ? getRelationType({ relation, collection, field }) : null;
 
 		if (type === 'o2m' && relation) {
-			filter[key] = filterReplaceM2A(filter[key], relation.collection, schema, options);
+			filter[key] = filterReplaceM2A(filter[key], relation.collection, schema);
 		} else if (type === 'm2o' && relation) {
-			filter[key] = filterReplaceM2A(filter[key], relation.related_collection!, schema, options);
+			filter[key] = filterReplaceM2A(filter[key], relation.related_collection!, schema);
 		} else if (
 			type === 'a2o' &&
 			relation &&
 			any_collection &&
 			relation.meta?.one_allowed_collections?.includes(any_collection)
 		) {
-			filter[`${field}:${any_collection}`] = filterReplaceM2A(filter[key], any_collection, schema, options);
+			filter[`${field}:${any_collection}`] = filterReplaceM2A(filter[key], any_collection, schema);
 			delete filter[key];
 		} else if (Array.isArray(filter[key])) {
-			filter[key] = filter[key].map((item) => filterReplaceM2A(item, collection, schema, options));
+			filter[key] = filter[key].map((item) => filterReplaceM2A(item, collection, schema));
 		} else if (typeof filter[key] === 'object') {
-			filter[key] = filterReplaceM2A(filter[key], collection, schema, options);
+			filter[key] = filterReplaceM2A(filter[key], collection, schema);
 		}
 	}
 
@@ -48,20 +39,15 @@ export function filterReplaceM2ADeep(
 	deep_arg: NestedDeepQuery | null | undefined,
 	collection: string,
 	schema: SchemaOverview,
-	options?: { aliasMap?: Query['alias'] },
 ) {
 	const deep: any = deep_arg;
 
 	for (const key in deep) {
 		if (key.startsWith('_') === false) {
-			const parts = key.split('__');
-			let field = parts[0];
-			const any_collection = parts[1];
+			const [field, any_collection] = key.split('__');
 
 			if (!field) continue;
 
-			field = options?.aliasMap?.[field] || (deep as DeepQuery)._alias?.[field] || field;
-
 			const relation = getRelation(schema.relations, collection, field);
 
 			if (!relation) continue;
@@ -84,4 +70,4 @@ export function filterReplaceM2ADeep(
 	}
 
 	return deep;
-}
+}
\ No newline at end of file
diff --git a/packages/types/src/query.ts b/packages/types/src/query.ts
index 769d1ec..88215d7 100644
--- a/packages/types/src/query.ts
+++ b/packages/types/src/query.ts
@@ -19,7 +19,6 @@ export type Query = {
 };
 
 export type DeepQuery = {
-	_alias?: Record<string, string> | null;
 	_fields?: string[] | null;
 	_sort?: string[] | null;
 	_filter?: Filter | null;
@@ -46,4 +45,4 @@ export type Aggregate = {
 	min?: string[];
 	max?: string[];
 	countAll?: string[];
-};
+};
\ No newline at end of file
