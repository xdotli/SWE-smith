{
    "cost": 0.18506500000000004,
    "rewrites": {
        "directus__directus.447c91d0/api/src/services/graphql/schema/parse-query.ts": {
            "output": "import type { Accountability, Query, SchemaOverview } from '@directus/types';\nimport type { FieldNode, GraphQLResolveInfo, InlineFragmentNode, SelectionNode } from 'graphql';\nimport { get, mapKeys, merge, set, uniq } from 'lodash-es';\nimport { sanitizeQuery } from '../../../utils/sanitize-query.js';\nimport { validateQuery } from '../../../utils/validate-query.js';\nimport { filterReplaceM2A, filterReplaceM2ADeep } from '../utils/filter-replace-m2a.js';\nimport { replaceFuncs } from '../utils/replace-funcs.js';\nimport { parseArgs } from './parse-args.js';\n\n/**\n * Get a Directus Query object from the parsed arguments (rawQuery) and GraphQL AST selectionSet. Converts SelectionSet into\n * Directus' `fields` query for use in the resolver. Also applies variables where appropriate.\n */\nexport async function getQuery(\n\trawQuery: Query,\n\tschema: SchemaOverview,\n\tselections: readonly SelectionNode[],\n\tvariableValues: GraphQLResolveInfo['variableValues'],\n\taccountability?: Accountability | null,\n\tcollection?: string,\n): Promise<Query> {\n\tconst query: Query = await sanitizeQuery(rawQuery, schema, accountability);\n\n\tconst parseAliases = (selections: readonly SelectionNode[]) => {\n\t\tconst aliases: Record<string, string> = {};\n\n\t\tfor (const selection of selections) {\n\t\t\tif (selection.kind !== 'Field') continue;\n\n\t\t\tif (selection.alias?.value) {\n\t\t\t\taliases[selection.alias.value] = selection.name.value;\n\t\t\t}\n\t\t}\n\n\t\treturn aliases;\n\t};\n\n\tconst parseFields = async (selections: readonly SelectionNode[], parent?: string): Promise<string[]> => {\n\t\tconst fields: string[] = [];\n\n\t\tfor (let selection of selections) {\n\t\t\tif ((selection.kind === 'Field' || selection.kind === 'InlineFragment') !== true) continue;\n\n\t\t\tselection = selection as FieldNode | InlineFragmentNode;\n\n\t\t\tlet current: string;\n\t\t\tlet currentAlias: string | null = null;\n\n\t\t\t// Union type (Many-to-Any)\n\t\t\tif (selection.kind === 'InlineFragment') {\n\t\t\t\tif (selection.typeCondition!.name.value.startsWith('__')) continue;\n\n\t\t\t\tcurrent = `${parent}:${selection.typeCondition!.name.value}`;\n\t\t\t}\n\t\t\t// Any other field type\n\t\t\telse {\n\t\t\t\t// filter out graphql pointers, like __typename\n\t\t\t\tif (selection.name.value.startsWith('__')) continue;\n\n\t\t\t\tcurrent = selection.name.value;\n\n\t\t\t\tif (selection.alias) {\n\t\t\t\t\tcurrentAlias = selection.alias.value;\n\t\t\t\t}\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tcurrent = `${parent}.${current}`;\n\n\t\t\t\t\tif (currentAlias) {\n\t\t\t\t\t\tcurrentAlias = `${parent}.${currentAlias}`;\n\n\t\t\t\t\t\t// add nested aliases into deep query\n\t\t\t\t\t\tif (selection.selectionSet) {\n\t\t\t\t\t\t\tif (!query.deep) query.deep = {};\n\n\t\t\t\t\t\t\tconst path = parent.replaceAll(':', '__');\n\n\t\t\t\t\t\t\tset(\n\t\t\t\t\t\t\t\tquery.deep,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\tmerge({}, get(query.deep, parent), { _alias: { [selection.alias!.value]: selection.name.value } }),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (selection.selectionSet) {\n\t\t\t\tlet children: string[];\n\n\t\t\t\tif (current.endsWith('_func')) {\n\t\t\t\t\tchildren = [];\n\n\t\t\t\t\tconst rootField = current.slice(0, -5);\n\n\t\t\t\t\tfor (const subSelection of selection.selectionSet.selections) {\n\t\t\t\t\t\tif (subSelection.kind !== 'Field') continue;\n\t\t\t\t\t\tif (subSelection.name!.value.startsWith('__')) continue;\n\t\t\t\t\t\tchildren.push(`${subSelection.name!.value}(${rootField})`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tchildren = await parseFields(selection.selectionSet.selections, currentAlias ?? current);\n\t\t\t\t}\n\n\t\t\t\tfields.push(...children);\n\t\t\t} else {\n\t\t\t\tfields.push(current);\n\t\t\t}\n\n\t\t\tif (selection.kind === 'Field' && selection.arguments && selection.arguments.length > 0) {\n\t\t\t\tif (!query.deep) query.deep = {};\n\n\t\t\t\tconst args: Record<string, any> = parseArgs(selection.arguments, variableValues);\n\n\t\t\t\tconst path = (currentAlias ?? current).replaceAll(':', '__');\n\n\t\t\t\tset(\n\t\t\t\t\tquery.deep,\n\t\t\t\t\tpath,\n\t\t\t\t\tmerge(\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tget(query.deep, path),\n\t\t\t\t\t\tmapKeys(await sanitizeQuery(args, schema, accountability), (_value, key) => `_${key}`),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn uniq(fields);\n\t};\n\n\tquery.alias = parseAliases(selections);\n\tquery.fields = await parseFields(selections);\n\n\tif (query.filter) query.filter = replaceFuncs(query.filter);\n\n\tquery.deep = replaceFuncs(query.deep as any) as any;\n\n\tif (collection) {\n\t\tif (query.filter) {\n\t\t\tquery.filter = filterReplaceM2A(query.filter, collection, schema);\n\t\t}\n\n\t\tquery.deep = filterReplaceM2ADeep(query.deep, collection, schema);\n\t}\n\n\tvalidateQuery(query);\n\n\treturn query;\n}",
            "output_extracted": "import type { Accountability, Query, SchemaOverview } from '@directus/types';\nimport type { FieldNode, GraphQLResolveInfo, InlineFragmentNode, SelectionNode } from 'graphql';\nimport { get, mapKeys, merge, set, uniq } from 'lodash-es';\nimport { sanitizeQuery } from '../../../utils/sanitize-query.js';\nimport { validateQuery } from '../../../utils/validate-query.js';\nimport { filterReplaceM2A, filterReplaceM2ADeep } from '../utils/filter-replace-m2a.js';\nimport { replaceFuncs } from '../utils/replace-funcs.js';\nimport { parseArgs } from './parse-args.js';\n\n/**\n * Get a Directus Query object from the parsed arguments (rawQuery) and GraphQL AST selectionSet. Converts SelectionSet into\n * Directus' `fields` query for use in the resolver. Also applies variables where appropriate.\n */\nexport async function getQuery(\n\trawQuery: Query,\n\tschema: SchemaOverview,\n\tselections: readonly SelectionNode[],\n\tvariableValues: GraphQLResolveInfo['variableValues'],\n\taccountability?: Accountability | null,\n\tcollection?: string,\n): Promise<Query> {\n\tconst query: Query = await sanitizeQuery(rawQuery, schema, accountability);\n\n\tconst parseAliases = (selections: readonly SelectionNode[]) => {\n\t\tconst aliases: Record<string, string> = {};\n\n\t\tfor (const selection of selections) {\n\t\t\tif (selection.kind !== 'Field') continue;\n\n\t\t\tif (selection.alias?.value) {\n\t\t\t\taliases[selection.alias.value] = selection.name.value;\n\t\t\t}\n\t\t}\n\n\t\treturn aliases;\n\t};\n\n\tconst parseFields = async (selections: readonly SelectionNode[], parent?: string): Promise<string[]> => {\n\t\tconst fields: string[] = [];\n\n\t\tfor (let selection of selections) {\n\t\t\tif ((selection.kind === 'Field' || selection.kind === 'InlineFragment') !== true) continue;\n\n\t\t\tselection = selection as FieldNode | InlineFragmentNode;\n\n\t\t\tlet current: string;\n\t\t\tlet currentAlias: string | null = null;\n\n\t\t\t// Union type (Many-to-Any)\n\t\t\tif (selection.kind === 'InlineFragment') {\n\t\t\t\tif (selection.typeCondition!.name.value.startsWith('__')) continue;\n\n\t\t\t\tcurrent = `${parent}:${selection.typeCondition!.name.value}`;\n\t\t\t}\n\t\t\t// Any other field type\n\t\t\telse {\n\t\t\t\t// filter out graphql pointers, like __typename\n\t\t\t\tif (selection.name.value.startsWith('__')) continue;\n\n\t\t\t\tcurrent = selection.name.value;\n\n\t\t\t\tif (selection.alias) {\n\t\t\t\t\tcurrentAlias = selection.alias.value;\n\t\t\t\t}\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tcurrent = `${parent}.${current}`;\n\n\t\t\t\t\tif (currentAlias) {\n\t\t\t\t\t\tcurrentAlias = `${parent}.${currentAlias}`;\n\n\t\t\t\t\t\t// add nested aliases into deep query\n\t\t\t\t\t\tif (selection.selectionSet) {\n\t\t\t\t\t\t\tif (!query.deep) query.deep = {};\n\n\t\t\t\t\t\t\tconst path = parent.replaceAll(':', '__');\n\n\t\t\t\t\t\t\tset(\n\t\t\t\t\t\t\t\tquery.deep,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\tmerge({}, get(query.deep, parent), { _alias: { [selection.alias!.value]: selection.name.value } }),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (selection.selectionSet) {\n\t\t\t\tlet children: string[];\n\n\t\t\t\tif (current.endsWith('_func')) {\n\t\t\t\t\tchildren = [];\n\n\t\t\t\t\tconst rootField = current.slice(0, -5);\n\n\t\t\t\t\tfor (const subSelection of selection.selectionSet.selections) {\n\t\t\t\t\t\tif (subSelection.kind !== 'Field') continue;\n\t\t\t\t\t\tif (subSelection.name!.value.startsWith('__')) continue;\n\t\t\t\t\t\tchildren.push(`${subSelection.name!.value}(${rootField})`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tchildren = await parseFields(selection.selectionSet.selections, currentAlias ?? current);\n\t\t\t\t}\n\n\t\t\t\tfields.push(...children);\n\t\t\t} else {\n\t\t\t\tfields.push(current);\n\t\t\t}\n\n\t\t\tif (selection.kind === 'Field' && selection.arguments && selection.arguments.length > 0) {\n\t\t\t\tif (!query.deep) query.deep = {};\n\n\t\t\t\tconst args: Record<string, any> = parseArgs(selection.arguments, variableValues);\n\n\t\t\t\tconst path = (currentAlias ?? current).replaceAll(':', '__');\n\n\t\t\t\tset(\n\t\t\t\t\tquery.deep,\n\t\t\t\t\tpath,\n\t\t\t\t\tmerge(\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tget(query.deep, path),\n\t\t\t\t\t\tmapKeys(await sanitizeQuery(args, schema, accountability), (_value, key) => `_${key}`),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn uniq(fields);\n\t};\n\n\tquery.alias = parseAliases(selections);\n\tquery.fields = await parseFields(selections);\n\n\tif (query.filter) query.filter = replaceFuncs(query.filter);\n\n\tquery.deep = replaceFuncs(query.deep as any) as any;\n\n\tif (collection) {\n\t\tif (query.filter) {\n\t\t\tquery.filter = filterReplaceM2A(query.filter, collection, schema);\n\t\t}\n\n\t\tquery.deep = filterReplaceM2ADeep(query.deep, collection, schema);\n\t}\n\n\tvalidateQuery(query);\n\n\treturn query;\n}",
            "cost": 0.04514
        },
        "directus__directus.447c91d0/api/src/services/graphql/utils/filter-replace-m2a.test.ts": {
            "output": "import { RelationBuilder, SchemaBuilder } from '@directus/schema-builder';\nimport { expect, test } from 'vitest';\nimport { filterReplaceM2A, filterReplaceM2ADeep } from './filter-replace-m2a.js';\n\nconst schema = new SchemaBuilder()\n\t.collection('article', (c) => {\n\t\tc.field('id').id();\n\t\tc.field('author').m2o('user');\n\n\t\tc.field('blocks').m2a(['text', 'image'], () => ({\n\t\t\to2m_relation: new RelationBuilder('article', 'blocks').o2m('article_builder', 'article_id').options({\n\t\t\t\tmeta: {\n\t\t\t\t\tjunction_field: `anyitem`,\n\t\t\t\t},\n\t\t\t}),\n\t\t\ta2o_relation: new RelationBuilder('article_builder', 'anyitem').a2o(['text', 'image']).options({\n\t\t\t\tmeta: {\n\t\t\t\t\tjunction_field: `article_id`,\n\t\t\t\t},\n\t\t\t}),\n\t\t}));\n\t})\n\t.build();\n\ntest('empty filter', () => {\n\tconst result = filterReplaceM2A({}, 'article', { collections: {}, relations: [] });\n\n\texpect(result).toEqual({});\n});\n\ntest('filter with no relations', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\tid: {\n\t\t\t\t_eq: 1,\n\t\t\t},\n\t\t\tsome: {\n\t\t\t\t_eq: 'value',\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\t{ collections: {}, relations: [] },\n\t);\n\n\texpect(result).toEqual({\n\t\tid: {\n\t\t\t_eq: 1,\n\t\t},\n\t\tsome: {\n\t\t\t_eq: 'value',\n\t\t},\n\t});\n});\n\ntest('filter with a m2o relation', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\tid: { _eq: 1 },\n\t\t\tauthor: {\n\t\t\t\tid: { _eq: 1 },\n\t\t\t\tname: { _eq: 'John Doe' },\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tid: { _eq: 1 },\n\t\tauthor: {\n\t\t\tid: { _eq: 1 },\n\t\t\tname: { _eq: 'John Doe' },\n\t\t},\n\t});\n});\n\ntest('filter with a a2o relation', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\tid: { _eq: 1 },\n\t\t\tblocks: {\n\t\t\t\tanyitem__text: {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tid: { _eq: 1 },\n\t\tblocks: {\n\t\t\t'anyitem:text': {\n\t\t\t\tid: { _eq: 1 },\n\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('filter with a fake a2o relation', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\tid: { _eq: 1 },\n\t\t\tblocks: {\n\t\t\t\titem__text: {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tid: { _eq: 1 },\n\t\tblocks: {\n\t\t\titem__text: {\n\t\t\t\tid: { _eq: 1 },\n\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('filter with a a2o relation inside _and', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\t_and: [\n\t\t\t\t{\n\t\t\t\t\tblocks: {\n\t\t\t\t\t\tanyitem__text: {\n\t\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\t_and: [\n\t\t\t{\n\t\t\t\tblocks: {\n\t\t\t\t\t'anyitem:text': {\n\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t});\n});\n\ntest('filter with a a2o relation and wrong target collection', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\tid: { _eq: 1 },\n\t\t\tblocks: {\n\t\t\t\tanyitem__wrong: {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tid: { _eq: 1 },\n\t\tblocks: {\n\t\t\tanyitem__wrong: {\n\t\t\t\tid: { _eq: 1 },\n\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('deep with filter', () => {\n\tconst result = filterReplaceM2ADeep(\n\t\t{\n\t\t\tblocks: {\n\t\t\t\t_filter: {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tblocks: {\n\t\t\t_filter: {\n\t\t\t\tid: { _eq: 1 },\n\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('deep with filter having a2o', () => {\n\tconst result = filterReplaceM2ADeep(\n\t\t{\n\t\t\tblocks: {\n\t\t\t\t_filter: {\n\t\t\t\t\tanyitem__text: {\n\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tblocks: {\n\t\t\t_filter: {\n\t\t\t\t'anyitem:text': {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('deep with nested filter having a2o', () => {\n\tconst result = filterReplaceM2ADeep(\n\t\t{\n\t\t\tblocks: {\n\t\t\t\tanyitem__text: {\n\t\t\t\t\tblocks: {\n\t\t\t\t\t\t_filter: {\n\t\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tblocks: {\n\t\t\t'anyitem:text': {\n\t\t\t\tblocks: {\n\t\t\t\t\t_filter: {\n\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('deep with filter having a2o on wrong deep', () => {\n\tconst result = filterReplaceM2ADeep(\n\t\t{\n\t\t\twrong: {\n\t\t\t\t_filter: {\n\t\t\t\t\tanyitem__text: {\n\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\twrong: {\n\t\t\t_filter: {\n\t\t\t\tanyitem__text: {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t});\n});",
            "output_extracted": "import { RelationBuilder, SchemaBuilder } from '@directus/schema-builder';\nimport { expect, test } from 'vitest';\nimport { filterReplaceM2A, filterReplaceM2ADeep } from './filter-replace-m2a.js';\n\nconst schema = new SchemaBuilder()\n\t.collection('article', (c) => {\n\t\tc.field('id').id();\n\t\tc.field('author').m2o('user');\n\n\t\tc.field('blocks').m2a(['text', 'image'], () => ({\n\t\t\to2m_relation: new RelationBuilder('article', 'blocks').o2m('article_builder', 'article_id').options({\n\t\t\t\tmeta: {\n\t\t\t\t\tjunction_field: `anyitem`,\n\t\t\t\t},\n\t\t\t}),\n\t\t\ta2o_relation: new RelationBuilder('article_builder', 'anyitem').a2o(['text', 'image']).options({\n\t\t\t\tmeta: {\n\t\t\t\t\tjunction_field: `article_id`,\n\t\t\t\t},\n\t\t\t}),\n\t\t}));\n\t})\n\t.build();\n\ntest('empty filter', () => {\n\tconst result = filterReplaceM2A({}, 'article', { collections: {}, relations: [] });\n\n\texpect(result).toEqual({});\n});\n\ntest('filter with no relations', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\tid: {\n\t\t\t\t_eq: 1,\n\t\t\t},\n\t\t\tsome: {\n\t\t\t\t_eq: 'value',\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\t{ collections: {}, relations: [] },\n\t);\n\n\texpect(result).toEqual({\n\t\tid: {\n\t\t\t_eq: 1,\n\t\t},\n\t\tsome: {\n\t\t\t_eq: 'value',\n\t\t},\n\t});\n});\n\ntest('filter with a m2o relation', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\tid: { _eq: 1 },\n\t\t\tauthor: {\n\t\t\t\tid: { _eq: 1 },\n\t\t\t\tname: { _eq: 'John Doe' },\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tid: { _eq: 1 },\n\t\tauthor: {\n\t\t\tid: { _eq: 1 },\n\t\t\tname: { _eq: 'John Doe' },\n\t\t},\n\t});\n});\n\ntest('filter with a a2o relation', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\tid: { _eq: 1 },\n\t\t\tblocks: {\n\t\t\t\tanyitem__text: {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tid: { _eq: 1 },\n\t\tblocks: {\n\t\t\t'anyitem:text': {\n\t\t\t\tid: { _eq: 1 },\n\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('filter with a fake a2o relation', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\tid: { _eq: 1 },\n\t\t\tblocks: {\n\t\t\t\titem__text: {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tid: { _eq: 1 },\n\t\tblocks: {\n\t\t\titem__text: {\n\t\t\t\tid: { _eq: 1 },\n\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('filter with a a2o relation inside _and', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\t_and: [\n\t\t\t\t{\n\t\t\t\t\tblocks: {\n\t\t\t\t\t\tanyitem__text: {\n\t\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\t_and: [\n\t\t\t{\n\t\t\t\tblocks: {\n\t\t\t\t\t'anyitem:text': {\n\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t],\n\t});\n});\n\ntest('filter with a a2o relation and wrong target collection', () => {\n\tconst result = filterReplaceM2A(\n\t\t{\n\t\t\tid: { _eq: 1 },\n\t\t\tblocks: {\n\t\t\t\tanyitem__wrong: {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tid: { _eq: 1 },\n\t\tblocks: {\n\t\t\tanyitem__wrong: {\n\t\t\t\tid: { _eq: 1 },\n\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('deep with filter', () => {\n\tconst result = filterReplaceM2ADeep(\n\t\t{\n\t\t\tblocks: {\n\t\t\t\t_filter: {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tblocks: {\n\t\t\t_filter: {\n\t\t\t\tid: { _eq: 1 },\n\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('deep with filter having a2o', () => {\n\tconst result = filterReplaceM2ADeep(\n\t\t{\n\t\t\tblocks: {\n\t\t\t\t_filter: {\n\t\t\t\t\tanyitem__text: {\n\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tblocks: {\n\t\t\t_filter: {\n\t\t\t\t'anyitem:text': {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('deep with nested filter having a2o', () => {\n\tconst result = filterReplaceM2ADeep(\n\t\t{\n\t\t\tblocks: {\n\t\t\t\tanyitem__text: {\n\t\t\t\t\tblocks: {\n\t\t\t\t\t\t_filter: {\n\t\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\tblocks: {\n\t\t\t'anyitem:text': {\n\t\t\t\tblocks: {\n\t\t\t\t\t_filter: {\n\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t});\n});\n\ntest('deep with filter having a2o on wrong deep', () => {\n\tconst result = filterReplaceM2ADeep(\n\t\t{\n\t\t\twrong: {\n\t\t\t\t_filter: {\n\t\t\t\t\tanyitem__text: {\n\t\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t'article',\n\t\tschema,\n\t);\n\n\texpect(result).toEqual({\n\t\twrong: {\n\t\t\t_filter: {\n\t\t\t\tanyitem__text: {\n\t\t\t\t\tid: { _eq: 1 },\n\t\t\t\t\tcontent: { _eq: 'Hello World' },\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t});\n});",
            "cost": 0.089065
        },
        "directus__directus.447c91d0/api/src/services/graphql/utils/filter-replace-m2a.ts": {
            "output": "import type { Filter, NestedDeepQuery, SchemaOverview } from '@directus/types';\nimport { getRelation } from '@directus/utils';\nimport { getRelationType } from '../../../utils/get-relation-type.js';\n\nexport function filterReplaceM2A(filter_arg: Filter, collection: string, schema: SchemaOverview): any {\n\tconst filter: any = filter_arg;\n\n\tfor (const key in filter) {\n\t\tconst [field, any_collection] = key.split('__');\n\n\t\tif (!field) continue;\n\n\t\tconst relation = getRelation(schema.relations, collection, field);\n\t\tconst type = relation ? getRelationType({ relation, collection, field }) : null;\n\n\t\tif (type === 'o2m' && relation) {\n\t\t\tfilter[key] = filterReplaceM2A(filter[key], relation.collection, schema);\n\t\t} else if (type === 'm2o' && relation) {\n\t\t\tfilter[key] = filterReplaceM2A(filter[key], relation.related_collection!, schema);\n\t\t} else if (\n\t\t\ttype === 'a2o' &&\n\t\t\trelation &&\n\t\t\tany_collection &&\n\t\t\trelation.meta?.one_allowed_collections?.includes(any_collection)\n\t\t) {\n\t\t\tfilter[`${field}:${any_collection}`] = filterReplaceM2A(filter[key], any_collection, schema);\n\t\t\tdelete filter[key];\n\t\t} else if (Array.isArray(filter[key])) {\n\t\t\tfilter[key] = filter[key].map((item) => filterReplaceM2A(item, collection, schema));\n\t\t} else if (typeof filter[key] === 'object') {\n\t\t\tfilter[key] = filterReplaceM2A(filter[key], collection, schema);\n\t\t}\n\t}\n\n\treturn filter;\n}\n\nexport function filterReplaceM2ADeep(\n\tdeep_arg: NestedDeepQuery | null | undefined,\n\tcollection: string,\n\tschema: SchemaOverview,\n) {\n\tconst deep: any = deep_arg;\n\n\tfor (const key in deep) {\n\t\tif (key.startsWith('_') === false) {\n\t\t\tconst [field, any_collection] = key.split('__');\n\n\t\t\tif (!field) continue;\n\n\t\t\tconst relation = getRelation(schema.relations, collection, field);\n\n\t\t\tif (!relation) continue;\n\n\t\t\tconst type = getRelationType({ relation, collection, field });\n\n\t\t\tif (type === 'o2m') {\n\t\t\t\tdeep[key] = filterReplaceM2ADeep(deep[key], relation.collection, schema);\n\t\t\t} else if (type === 'm2o') {\n\t\t\t\tdeep[key] = filterReplaceM2ADeep(deep[key], relation.related_collection!, schema);\n\t\t\t} else if (type === 'a2o' && any_collection && relation.meta?.one_allowed_collections?.includes(any_collection)) {\n\t\t\t\tdeep[`${field}:${any_collection}`] = filterReplaceM2ADeep(deep[key], any_collection, schema);\n\t\t\t\tdelete deep[key];\n\t\t\t}\n\t\t}\n\n\t\tif (key === '_filter') {\n\t\t\tdeep[key] = filterReplaceM2A(deep[key], collection, schema);\n\t\t}\n\t}\n\n\treturn deep;\n}",
            "output_extracted": "import type { Filter, NestedDeepQuery, SchemaOverview } from '@directus/types';\nimport { getRelation } from '@directus/utils';\nimport { getRelationType } from '../../../utils/get-relation-type.js';\n\nexport function filterReplaceM2A(filter_arg: Filter, collection: string, schema: SchemaOverview): any {\n\tconst filter: any = filter_arg;\n\n\tfor (const key in filter) {\n\t\tconst [field, any_collection] = key.split('__');\n\n\t\tif (!field) continue;\n\n\t\tconst relation = getRelation(schema.relations, collection, field);\n\t\tconst type = relation ? getRelationType({ relation, collection, field }) : null;\n\n\t\tif (type === 'o2m' && relation) {\n\t\t\tfilter[key] = filterReplaceM2A(filter[key], relation.collection, schema);\n\t\t} else if (type === 'm2o' && relation) {\n\t\t\tfilter[key] = filterReplaceM2A(filter[key], relation.related_collection!, schema);\n\t\t} else if (\n\t\t\ttype === 'a2o' &&\n\t\t\trelation &&\n\t\t\tany_collection &&\n\t\t\trelation.meta?.one_allowed_collections?.includes(any_collection)\n\t\t) {\n\t\t\tfilter[`${field}:${any_collection}`] = filterReplaceM2A(filter[key], any_collection, schema);\n\t\t\tdelete filter[key];\n\t\t} else if (Array.isArray(filter[key])) {\n\t\t\tfilter[key] = filter[key].map((item) => filterReplaceM2A(item, collection, schema));\n\t\t} else if (typeof filter[key] === 'object') {\n\t\t\tfilter[key] = filterReplaceM2A(filter[key], collection, schema);\n\t\t}\n\t}\n\n\treturn filter;\n}\n\nexport function filterReplaceM2ADeep(\n\tdeep_arg: NestedDeepQuery | null | undefined,\n\tcollection: string,\n\tschema: SchemaOverview,\n) {\n\tconst deep: any = deep_arg;\n\n\tfor (const key in deep) {\n\t\tif (key.startsWith('_') === false) {\n\t\t\tconst [field, any_collection] = key.split('__');\n\n\t\t\tif (!field) continue;\n\n\t\t\tconst relation = getRelation(schema.relations, collection, field);\n\n\t\t\tif (!relation) continue;\n\n\t\t\tconst type = getRelationType({ relation, collection, field });\n\n\t\t\tif (type === 'o2m') {\n\t\t\t\tdeep[key] = filterReplaceM2ADeep(deep[key], relation.collection, schema);\n\t\t\t} else if (type === 'm2o') {\n\t\t\t\tdeep[key] = filterReplaceM2ADeep(deep[key], relation.related_collection!, schema);\n\t\t\t} else if (type === 'a2o' && any_collection && relation.meta?.one_allowed_collections?.includes(any_collection)) {\n\t\t\t\tdeep[`${field}:${any_collection}`] = filterReplaceM2ADeep(deep[key], any_collection, schema);\n\t\t\t\tdelete deep[key];\n\t\t\t}\n\t\t}\n\n\t\tif (key === '_filter') {\n\t\t\tdeep[key] = filterReplaceM2A(deep[key], collection, schema);\n\t\t}\n\t}\n\n\treturn deep;\n}",
            "cost": 0.034385
        },
        "directus__directus.447c91d0/packages/types/src/query.ts": {
            "output": "import type { Filter } from './filter.js';\n\nexport type Query = {\n\tfields?: string[] | null;\n\tsort?: string[] | null;\n\tfilter?: Filter | null;\n\tlimit?: number | null;\n\toffset?: number | null;\n\tpage?: number | null;\n\tsearch?: string | null;\n\tversion?: string | null;\n\tversionRaw?: boolean | null;\n\texport?: 'json' | 'csv' | 'csv_utf8' | 'xml' | 'yaml' | null;\n\tgroup?: string[] | null;\n\taggregate?: Aggregate | null;\n\tdeep?: NestedDeepQuery | null;\n\talias?: Record<string, string> | null;\n\tbacklink?: boolean;\n};\n\nexport type DeepQuery = {\n\t_fields?: string[] | null;\n\t_sort?: string[] | null;\n\t_filter?: Filter | null;\n\t_limit?: number | null;\n\t_offset?: number | null;\n\t_page?: number | null;\n\t_search?: string | null;\n\t_group?: string[] | null;\n\t_aggregate?: Aggregate | null;\n};\n\nexport type NestedDeepQuery = { [field: string]: DeepQuery | NestedDeepQuery };\n\n/**\n * Aggregate operation. Contains column name, and the field alias it should be returned as\n */\nexport type Aggregate = {\n\tavg?: string[];\n\tavgDistinct?: string[];\n\tcount?: string[];\n\tcountDistinct?: string[];\n\tsum?: string[];\n\tsumDistinct?: string[];\n\tmin?: string[];\n\tmax?: string[];\n\tcountAll?: string[];\n};",
            "output_extracted": "import type { Filter } from './filter.js';\n\nexport type Query = {\n\tfields?: string[] | null;\n\tsort?: string[] | null;\n\tfilter?: Filter | null;\n\tlimit?: number | null;\n\toffset?: number | null;\n\tpage?: number | null;\n\tsearch?: string | null;\n\tversion?: string | null;\n\tversionRaw?: boolean | null;\n\texport?: 'json' | 'csv' | 'csv_utf8' | 'xml' | 'yaml' | null;\n\tgroup?: string[] | null;\n\taggregate?: Aggregate | null;\n\tdeep?: NestedDeepQuery | null;\n\talias?: Record<string, string> | null;\n\tbacklink?: boolean;\n};\n\nexport type DeepQuery = {\n\t_fields?: string[] | null;\n\t_sort?: string[] | null;\n\t_filter?: Filter | null;\n\t_limit?: number | null;\n\t_offset?: number | null;\n\t_page?: number | null;\n\t_search?: string | null;\n\t_group?: string[] | null;\n\t_aggregate?: Aggregate | null;\n};\n\nexport type NestedDeepQuery = { [field: string]: DeepQuery | NestedDeepQuery };\n\n/**\n * Aggregate operation. Contains column name, and the field alias it should be returned as\n */\nexport type Aggregate = {\n\tavg?: string[];\n\tavgDistinct?: string[];\n\tcount?: string[];\n\tcountDistinct?: string[];\n\tsum?: string[];\n\tsumDistinct?: string[];\n\tmin?: string[];\n\tmax?: string[];\n\tcountAll?: string[];\n};",
            "cost": 0.016475000000000004
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "directus/directus",
        "instance_id": "directus__directus.pr_mirror.26148",
        "base_commit": "b98cca06b80860e6aa75d08668fb8a89c609c4a7",
        "patch": "diff --git a/.changeset/funny-months-wonder.md b/.changeset/funny-months-wonder.md\nnew file mode 100644\nindex 0000000000000..9e6f4194bb249\n--- /dev/null\n+++ b/.changeset/funny-months-wonder.md\n@@ -0,0 +1,6 @@\n+---\n+'@directus/types': patch\n+'@directus/api': patch\n+---\n+\n+Fixed aliases on GQL M2A filters\ndiff --git a/api/src/services/graphql/schema/parse-query.ts b/api/src/services/graphql/schema/parse-query.ts\nindex a31198738c7f2..86ac294030a5b 100644\n--- a/api/src/services/graphql/schema/parse-query.ts\n+++ b/api/src/services/graphql/schema/parse-query.ts\n@@ -138,10 +138,10 @@ export async function getQuery(\n \n \tif (collection) {\n \t\tif (query.filter) {\n-\t\t\tquery.filter = filterReplaceM2A(query.filter, collection, schema);\n+\t\t\tquery.filter = filterReplaceM2A(query.filter, collection, schema, { aliasMap: query.alias });\n \t\t}\n \n-\t\tquery.deep = filterReplaceM2ADeep(query.deep, collection, schema);\n+\t\tquery.deep = filterReplaceM2ADeep(query.deep, collection, schema, { aliasMap: query.alias });\n \t}\n \n \tvalidateQuery(query);\ndiff --git a/api/src/services/graphql/utils/filter-replace-m2a.test.ts b/api/src/services/graphql/utils/filter-replace-m2a.test.ts\nindex ecfb982c5ab20..57a6ef03afd16 100644\n--- a/api/src/services/graphql/utils/filter-replace-m2a.test.ts\n+++ b/api/src/services/graphql/utils/filter-replace-m2a.test.ts\n@@ -1,5 +1,5 @@\n import { RelationBuilder, SchemaBuilder } from '@directus/schema-builder';\n-import { expect, test } from 'vitest';\n+import { describe, expect, test } from 'vitest';\n import { filterReplaceM2A, filterReplaceM2ADeep } from './filter-replace-m2a.js';\n \n const schema = new SchemaBuilder()\n@@ -22,87 +22,128 @@ const schema = new SchemaBuilder()\n \t})\n \t.build();\n \n-test('empty filter', () => {\n-\tconst result = filterReplaceM2A({}, 'article', { collections: {}, relations: [] });\n+describe('filterReplaceM2A', () => {\n+\ttest('empty filter', () => {\n+\t\tconst result = filterReplaceM2A({}, 'article', { collections: {}, relations: [] });\n \n-\texpect(result).toEqual({});\n-});\n+\t\texpect(result).toEqual({});\n+\t});\n+\n+\ttest('filter with aliases field', () => {\n+\t\tconst result = filterReplaceM2A(\n+\t\t\t{\n+\t\t\t\tid: { _eq: 1 },\n+\t\t\t\taliased_blocks: {\n+\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t\t{ aliasMap: { aliased_blocks: 'blocks' } },\n+\t\t);\n \n-test('filter with no relations', () => {\n-\tconst result = filterReplaceM2A(\n-\t\t{\n+\t\texpect(result).toEqual({\n+\t\t\tid: { _eq: 1 },\n+\t\t\taliased_blocks: {\n+\t\t\t\t'anyitem:text': {\n+\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t},\n+\t\t\t},\n+\t\t});\n+\t});\n+\n+\ttest('filter with no relations', () => {\n+\t\tconst result = filterReplaceM2A(\n+\t\t\t{\n+\t\t\t\tid: {\n+\t\t\t\t\t_eq: 1,\n+\t\t\t\t},\n+\t\t\t\tsome: {\n+\t\t\t\t\t_eq: 'value',\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t'article',\n+\t\t\t{ collections: {}, relations: [] },\n+\t\t);\n+\n+\t\texpect(result).toEqual({\n \t\t\tid: {\n \t\t\t\t_eq: 1,\n \t\t\t},\n \t\t\tsome: {\n \t\t\t\t_eq: 'value',\n \t\t\t},\n-\t\t},\n-\t\t'article',\n-\t\t{ collections: {}, relations: [] },\n-\t);\n-\n-\texpect(result).toEqual({\n-\t\tid: {\n-\t\t\t_eq: 1,\n-\t\t},\n-\t\tsome: {\n-\t\t\t_eq: 'value',\n-\t\t},\n+\t\t});\n \t});\n-});\n \n-test('filter with a m2o relation', () => {\n-\tconst result = filterReplaceM2A(\n-\t\t{\n+\ttest('filter with a m2o relation', () => {\n+\t\tconst result = filterReplaceM2A(\n+\t\t\t{\n+\t\t\t\tid: { _eq: 1 },\n+\t\t\t\tauthor: {\n+\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\tname: { _eq: 'John Doe' },\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t);\n+\n+\t\texpect(result).toEqual({\n \t\t\tid: { _eq: 1 },\n \t\t\tauthor: {\n \t\t\t\tid: { _eq: 1 },\n \t\t\t\tname: { _eq: 'John Doe' },\n \t\t\t},\n-\t\t},\n-\t\t'article',\n-\t\tschema,\n-\t);\n-\n-\texpect(result).toEqual({\n-\t\tid: { _eq: 1 },\n-\t\tauthor: {\n-\t\t\tid: { _eq: 1 },\n-\t\t\tname: { _eq: 'John Doe' },\n-\t\t},\n+\t\t});\n \t});\n-});\n \n-test('filter with a a2o relation', () => {\n-\tconst result = filterReplaceM2A(\n-\t\t{\n+\ttest('filter with a a2o relation', () => {\n+\t\tconst result = filterReplaceM2A(\n+\t\t\t{\n+\t\t\t\tid: { _eq: 1 },\n+\t\t\t\tblocks: {\n+\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t);\n+\n+\t\texpect(result).toEqual({\n \t\t\tid: { _eq: 1 },\n \t\t\tblocks: {\n-\t\t\t\tanyitem__text: {\n+\t\t\t\t'anyitem:text': {\n \t\t\t\t\tid: { _eq: 1 },\n \t\t\t\t\tcontent: { _eq: 'Hello World' },\n \t\t\t\t},\n \t\t\t},\n-\t\t},\n-\t\t'article',\n-\t\tschema,\n-\t);\n-\n-\texpect(result).toEqual({\n-\t\tid: { _eq: 1 },\n-\t\tblocks: {\n-\t\t\t'anyitem:text': {\n+\t\t});\n+\t});\n+\n+\ttest('filter with a fake a2o relation', () => {\n+\t\tconst result = filterReplaceM2A(\n+\t\t\t{\n \t\t\t\tid: { _eq: 1 },\n-\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\tblocks: {\n+\t\t\t\t\titem__text: {\n+\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t},\n+\t\t\t\t},\n \t\t\t},\n-\t\t},\n-\t});\n-});\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t);\n \n-test('filter with a fake a2o relation', () => {\n-\tconst result = filterReplaceM2A(\n-\t\t{\n+\t\texpect(result).toEqual({\n \t\t\tid: { _eq: 1 },\n \t\t\tblocks: {\n \t\t\t\titem__text: {\n@@ -110,57 +151,57 @@ test('filter with a fake a2o relation', () => {\n \t\t\t\t\tcontent: { _eq: 'Hello World' },\n \t\t\t\t},\n \t\t\t},\n-\t\t},\n-\t\t'article',\n-\t\tschema,\n-\t);\n-\n-\texpect(result).toEqual({\n-\t\tid: { _eq: 1 },\n-\t\tblocks: {\n-\t\t\titem__text: {\n-\t\t\t\tid: { _eq: 1 },\n-\t\t\t\tcontent: { _eq: 'Hello World' },\n-\t\t\t},\n-\t\t},\n+\t\t});\n \t});\n-});\n \n-test('filter with a a2o relation inside _and', () => {\n-\tconst result = filterReplaceM2A(\n-\t\t{\n+\ttest('filter with a a2o relation inside _and', () => {\n+\t\tconst result = filterReplaceM2A(\n+\t\t\t{\n+\t\t\t\t_and: [\n+\t\t\t\t\t{\n+\t\t\t\t\t\tblocks: {\n+\t\t\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t],\n+\t\t\t},\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t);\n+\n+\t\texpect(result).toEqual({\n \t\t\t_and: [\n \t\t\t\t{\n \t\t\t\t\tblocks: {\n-\t\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t\t'anyitem:text': {\n \t\t\t\t\t\t\tid: { _eq: 1 },\n \t\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n \t\t\t\t\t\t},\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t],\n-\t\t},\n-\t\t'article',\n-\t\tschema,\n-\t);\n+\t\t});\n+\t});\n \n-\texpect(result).toEqual({\n-\t\t_and: [\n+\ttest('filter with a a2o relation and wrong target collection', () => {\n+\t\tconst result = filterReplaceM2A(\n \t\t\t{\n+\t\t\t\tid: { _eq: 1 },\n \t\t\t\tblocks: {\n-\t\t\t\t\t'anyitem:text': {\n+\t\t\t\t\tanyitem__wrong: {\n \t\t\t\t\t\tid: { _eq: 1 },\n \t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n-\t\t],\n-\t});\n-});\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t);\n \n-test('filter with a a2o relation and wrong target collection', () => {\n-\tconst result = filterReplaceM2A(\n-\t\t{\n+\t\texpect(result).toEqual({\n \t\t\tid: { _eq: 1 },\n \t\t\tblocks: {\n \t\t\t\tanyitem__wrong: {\n@@ -168,79 +209,171 @@ test('filter with a a2o relation and wrong target collection', () => {\n \t\t\t\t\tcontent: { _eq: 'Hello World' },\n \t\t\t\t},\n \t\t\t},\n-\t\t},\n-\t\t'article',\n-\t\tschema,\n-\t);\n-\n-\texpect(result).toEqual({\n-\t\tid: { _eq: 1 },\n-\t\tblocks: {\n-\t\t\tanyitem__wrong: {\n-\t\t\t\tid: { _eq: 1 },\n-\t\t\t\tcontent: { _eq: 'Hello World' },\n-\t\t\t},\n-\t\t},\n+\t\t});\n \t});\n });\n \n-test('deep with filter', () => {\n-\tconst result = filterReplaceM2ADeep(\n-\t\t{\n+describe('filterReplaceM2aDeep', () => {\n+\ttest('empty filter', () => {\n+\t\tconst result = filterReplaceM2ADeep({}, 'article', { collections: {}, relations: [] });\n+\n+\t\texpect(result).toEqual({});\n+\t});\n+\n+\ttest('deep with filter', () => {\n+\t\tconst result = filterReplaceM2ADeep(\n+\t\t\t{\n+\t\t\t\tblocks: {\n+\t\t\t\t\t_filter: {\n+\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t);\n+\n+\t\texpect(result).toEqual({\n \t\t\tblocks: {\n \t\t\t\t_filter: {\n \t\t\t\t\tid: { _eq: 1 },\n \t\t\t\t\tcontent: { _eq: 'Hello World' },\n \t\t\t\t},\n \t\t\t},\n-\t\t},\n-\t\t'article',\n-\t\tschema,\n-\t);\n-\n-\texpect(result).toEqual({\n-\t\tblocks: {\n-\t\t\t_filter: {\n-\t\t\t\tid: { _eq: 1 },\n-\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t});\n+\t});\n+\n+\ttest('filter with aliased relation', () => {\n+\t\tconst result = filterReplaceM2ADeep(\n+\t\t\t{\n+\t\t\t\taliased_blocks: {\n+\t\t\t\t\t_filter: {\n+\t\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n \t\t\t},\n-\t\t},\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t\t{ aliasMap: { aliased_blocks: 'blocks' } },\n+\t\t);\n+\n+\t\texpect(result).toEqual({\n+\t\t\taliased_blocks: {\n+\t\t\t\t_filter: {\n+\t\t\t\t\t'anyitem:text': {\n+\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t});\n \t});\n-});\n \n-test('deep with filter having a2o', () => {\n-\tconst result = filterReplaceM2ADeep(\n-\t\t{\n-\t\t\tblocks: {\n+\ttest('filter with nested aliased relation', () => {\n+\t\tconst result = filterReplaceM2ADeep(\n+\t\t\t{\n+\t\t\t\taliased_blocks: {\n+\t\t\t\t\tarticle_id: {\n+\t\t\t\t\t\t_alias: { aliased_blocks: 'blocks' },\n+\t\t\t\t\t\taliased_blocks: {\n+\t\t\t\t\t\t\t_filter: {\n+\t\t\t\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\t_filter: {\n+\t\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t\t{ aliasMap: { aliased_blocks: 'blocks' } },\n+\t\t);\n+\n+\t\texpect(result).toEqual({\n+\t\t\taliased_blocks: {\n+\t\t\t\tarticle_id: {\n+\t\t\t\t\t_alias: {\n+\t\t\t\t\t\taliased_blocks: 'blocks',\n+\t\t\t\t\t},\n+\t\t\t\t\taliased_blocks: {\n+\t\t\t\t\t\t_filter: {\n+\t\t\t\t\t\t\t'anyitem:text': {\n+\t\t\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n \t\t\t\t_filter: {\n-\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t'anyitem:text': {\n \t\t\t\t\t\tid: { _eq: 1 },\n \t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n-\t\t},\n-\t\t'article',\n-\t\tschema,\n-\t);\n-\n-\texpect(result).toEqual({\n-\t\tblocks: {\n-\t\t\t_filter: {\n-\t\t\t\t'anyitem:text': {\n-\t\t\t\t\tid: { _eq: 1 },\n-\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t});\n+\t});\n+\n+\ttest('deep with filter having a2o', () => {\n+\t\tconst result = filterReplaceM2ADeep(\n+\t\t\t{\n+\t\t\t\tblocks: {\n+\t\t\t\t\t_filter: {\n+\t\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n-\t\t},\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t);\n+\n+\t\texpect(result).toEqual({\n+\t\t\tblocks: {\n+\t\t\t\t_filter: {\n+\t\t\t\t\t'anyitem:text': {\n+\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t});\n \t});\n-});\n \n-test('deep with nested filter having a2o', () => {\n-\tconst result = filterReplaceM2ADeep(\n-\t\t{\n+\ttest('deep with nested filter having a2o', () => {\n+\t\tconst result = filterReplaceM2ADeep(\n+\t\t\t{\n+\t\t\t\tblocks: {\n+\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t\tblocks: {\n+\t\t\t\t\t\t\t_filter: {\n+\t\t\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t);\n+\n+\t\texpect(result).toEqual({\n \t\t\tblocks: {\n-\t\t\t\tanyitem__text: {\n+\t\t\t\t'anyitem:text': {\n \t\t\t\t\tblocks: {\n \t\t\t\t\t\t_filter: {\n \t\t\t\t\t\t\tid: { _eq: 1 },\n@@ -248,27 +381,26 @@ test('deep with nested filter having a2o', () => {\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n-\t\t},\n-\t\t'article',\n-\t\tschema,\n-\t);\n-\n-\texpect(result).toEqual({\n-\t\tblocks: {\n-\t\t\t'anyitem:text': {\n-\t\t\t\tblocks: {\n+\t\t});\n+\t});\n+\n+\ttest('deep with filter having a2o on wrong deep', () => {\n+\t\tconst result = filterReplaceM2ADeep(\n+\t\t\t{\n+\t\t\t\twrong: {\n \t\t\t\t\t_filter: {\n-\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\tanyitem__text: {\n+\t\t\t\t\t\t\tid: { _eq: 1 },\n+\t\t\t\t\t\t\tcontent: { _eq: 'Hello World' },\n+\t\t\t\t\t\t},\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n-\t\t},\n-\t});\n-});\n+\t\t\t'article',\n+\t\t\tschema,\n+\t\t);\n \n-test('deep with filter having a2o on wrong deep', () => {\n-\tconst result = filterReplaceM2ADeep(\n-\t\t{\n+\t\texpect(result).toEqual({\n \t\t\twrong: {\n \t\t\t\t_filter: {\n \t\t\t\t\tanyitem__text: {\n@@ -277,19 +409,6 @@ test('deep with filter having a2o on wrong deep', () => {\n \t\t\t\t\t},\n \t\t\t\t},\n \t\t\t},\n-\t\t},\n-\t\t'article',\n-\t\tschema,\n-\t);\n-\n-\texpect(result).toEqual({\n-\t\twrong: {\n-\t\t\t_filter: {\n-\t\t\t\tanyitem__text: {\n-\t\t\t\t\tid: { _eq: 1 },\n-\t\t\t\t\tcontent: { _eq: 'Hello World' },\n-\t\t\t\t},\n-\t\t\t},\n-\t\t},\n+\t\t});\n \t});\n });\ndiff --git a/api/src/services/graphql/utils/filter-replace-m2a.ts b/api/src/services/graphql/utils/filter-replace-m2a.ts\nindex 3b264402a4e40..a14ce0d7f2266 100644\n--- a/api/src/services/graphql/utils/filter-replace-m2a.ts\n+++ b/api/src/services/graphql/utils/filter-replace-m2a.ts\n@@ -1,34 +1,43 @@\n-import type { Filter, NestedDeepQuery, SchemaOverview } from '@directus/types';\n+import type { DeepQuery, Filter, NestedDeepQuery, Query, SchemaOverview } from '@directus/types';\n import { getRelation } from '@directus/utils';\n import { getRelationType } from '../../../utils/get-relation-type.js';\n \n-export function filterReplaceM2A(filter_arg: Filter, collection: string, schema: SchemaOverview): any {\n+export function filterReplaceM2A(\n+\tfilter_arg: Filter,\n+\tcollection: string,\n+\tschema: SchemaOverview,\n+\toptions?: { aliasMap?: Query['alias'] },\n+): any {\n \tconst filter: any = filter_arg;\n \n \tfor (const key in filter) {\n-\t\tconst [field, any_collection] = key.split('__');\n+\t\tconst parts = key.split('__');\n+\t\tlet field = parts[0];\n+\t\tconst any_collection = parts[1];\n \n \t\tif (!field) continue;\n \n+\t\tfield = options?.aliasMap?.[field] ?? field;\n+\n \t\tconst relation = getRelation(schema.relations, collection, field);\n \t\tconst type = relation ? getRelationType({ relation, collection, field }) : null;\n \n \t\tif (type === 'o2m' && relation) {\n-\t\t\tfilter[key] = filterReplaceM2A(filter[key], relation.collection, schema);\n+\t\t\tfilter[key] = filterReplaceM2A(filter[key], relation.collection, schema, options);\n \t\t} else if (type === 'm2o' && relation) {\n-\t\t\tfilter[key] = filterReplaceM2A(filter[key], relation.related_collection!, schema);\n+\t\t\tfilter[key] = filterReplaceM2A(filter[key], relation.related_collection!, schema, options);\n \t\t} else if (\n \t\t\ttype === 'a2o' &&\n \t\t\trelation &&\n \t\t\tany_collection &&\n \t\t\trelation.meta?.one_allowed_collections?.includes(any_collection)\n \t\t) {\n-\t\t\tfilter[`${field}:${any_collection}`] = filterReplaceM2A(filter[key], any_collection, schema);\n+\t\t\tfilter[`${field}:${any_collection}`] = filterReplaceM2A(filter[key], any_collection, schema, options);\n \t\t\tdelete filter[key];\n \t\t} else if (Array.isArray(filter[key])) {\n-\t\t\tfilter[key] = filter[key].map((item) => filterReplaceM2A(item, collection, schema));\n+\t\t\tfilter[key] = filter[key].map((item) => filterReplaceM2A(item, collection, schema, options));\n \t\t} else if (typeof filter[key] === 'object') {\n-\t\t\tfilter[key] = filterReplaceM2A(filter[key], collection, schema);\n+\t\t\tfilter[key] = filterReplaceM2A(filter[key], collection, schema, options);\n \t\t}\n \t}\n \n@@ -39,15 +48,20 @@ export function filterReplaceM2ADeep(\n \tdeep_arg: NestedDeepQuery | null | undefined,\n \tcollection: string,\n \tschema: SchemaOverview,\n+\toptions?: { aliasMap?: Query['alias'] },\n ) {\n \tconst deep: any = deep_arg;\n \n \tfor (const key in deep) {\n \t\tif (key.startsWith('_') === false) {\n-\t\t\tconst [field, any_collection] = key.split('__');\n+\t\t\tconst parts = key.split('__');\n+\t\t\tlet field = parts[0];\n+\t\t\tconst any_collection = parts[1];\n \n \t\t\tif (!field) continue;\n \n+\t\t\tfield = options?.aliasMap?.[field] || (deep as DeepQuery)._alias?.[field] || field;\n+\n \t\t\tconst relation = getRelation(schema.relations, collection, field);\n \n \t\t\tif (!relation) continue;\ndiff --git a/packages/types/src/query.ts b/packages/types/src/query.ts\nindex 36f5fcf250b2b..f7955e005abe5 100644\n--- a/packages/types/src/query.ts\n+++ b/packages/types/src/query.ts\n@@ -19,6 +19,7 @@ export type Query = {\n };\n \n export type DeepQuery = {\n+\t_alias?: Record<string, string> | null;\n \t_fields?: string[] | null;\n \t_sort?: string[] | null;\n \t_filter?: Filter | null;\n",
        "test_patch": "",
        "problem_statement": "## Scope\r\n\r\nWhat's changed:\r\n\r\n- Aliases are now accounted for when building m2a filters\r\n- Added missing `_alias` property in type `DeepQuery`\r\n\r\n## Potential Risks / Drawbacks\r\n\r\n- Some filter breaks\r\n\r\n## Tested Scenarios\r\n\r\n- [x] Expect m2a filter to support aliases\r\n- [x] Expect m2a deep filter to support aliases\r\n\r\n## Review Notes / Questions\r\n\r\n- N/A\r\n\r\n## Checklist\r\n\r\n- [x] Added or updated tests\r\n- [ ] Documentation PR created [here](https://github.com/directus/docs) or not required\r\n\r\n---\r\n\r\nFixes #26133\r\n",
        "hints_text": "",
        "created_at": "2025-11-07T20:34:44Z",
        "pull_number": 26148,
        "test_files": [
            "api/src/services/graphql/utils/filter-replace-m2a.test.ts"
        ],
        "code_files": [
            "api/src/services/graphql/schema/parse-query.ts",
            "api/src/services/graphql/utils/filter-replace-m2a.ts",
            "packages/types/src/query.ts"
        ],
        "title": "Fix aliases on GQL M2A filters",
        "additions": 0,
        "deletions": 0,
        "pr_mirror": "directus__directus.447c91d0"
    }
}