diff --git a/packages/storage-driver-supabase/src/index.test.ts b/packages/storage-driver-supabase/src/index.test.ts
index a039cd0..3a03acc 100644
--- a/packages/storage-driver-supabase/src/index.test.ts
+++ b/packages/storage-driver-supabase/src/index.test.ts
@@ -3,13 +3,13 @@ import {
 	randGitBranch as randBucket,
 	randDirectoryPath,
 	randDomainName,
-	randFileName,
 	randFilePath,
 	randFileType,
 	randNumber,
 	randPastDate,
 	randText,
 	randGitShortSha as randUnique,
+	randFileName,
 } from '@ngneat/falso';
 import { StorageClient } from '@supabase/storage-js';
 import { Readable } from 'node:stream';
@@ -52,7 +52,6 @@ beforeEach(() => {
 			projectId: randAlphaNumeric({ length: 10 }).join(''),
 			root: randUnique() + randDirectoryPath(),
 			endpoint: randDomainName(),
-			tus: { chunkSize: 1024 * 1024 },
 		},
 		path: {
 			input: randUnique() + randFilePath(),
@@ -435,282 +434,4 @@ describe('#move', () => {
 	});
 });
 
-describe('#copy', () => {
-	test('passes arguments to copy', async () => {
-		driver['bucket'] = {
-			copy: vi.fn(),
-		} as any;
-
-		await driver.copy(sample.path.input, 'new/path');
-		expect(driver['bucket'].copy).toHaveBeenCalledWith(sample.path.input, 'new/path');
-	});
-});
-
-describe('#write', () => {
-	beforeEach(() => {
-		driver['bucket'] = {
-			upload: vi.fn().mockResolvedValue({ data: null, error: null }),
-		} as any;
-	});
-
-	test('Passes streams to body as is', async () => {
-		await driver.write(sample.path.input, sample.stream);
-
-		expect(driver['bucket'].upload).toHaveBeenCalledWith(sample.path.input, sample.stream, {
-			cacheControl: '3600',
-			contentType: '',
-			duplex: 'half',
-			upsert: true,
-		});
-	});
-
-	test('Ensures input is passed to fullPath', async () => {
-		driver['fullPath'] = vi.fn();
-
-		await driver.write(sample.path.input, sample.stream);
-		expect(driver['fullPath']).toHaveBeenCalledWith(sample.path.input);
-	});
-
-	test('Optionally sets ContentType', async () => {
-		await driver.write(sample.path.input, sample.stream, sample.file.type);
-
-		expect(driver['bucket'].upload).toHaveBeenCalledWith(sample.path.input, sample.stream, {
-			cacheControl: '3600',
-			contentType: sample.file.type,
-			duplex: 'half',
-			upsert: true,
-		});
-	});
-
-	test('Throws error when upload fails', async () => {
-		const uploadError = new Error('Upload failed');
-
-		driver['bucket'] = {
-			upload: vi.fn().mockResolvedValue({ data: null, error: uploadError }),
-		} as any;
-
-		await expect(driver.write(sample.path.input, sample.stream)).rejects.toThrow(
-			new Error(`Error uploading file "${sample.path.input}"`, { cause: uploadError }),
-		);
-	});
-});
-
-describe('#delete', () => {
-	test('Ensures input is passed to fullPath', async () => {
-		driver['bucket'] = {
-			remove: vi.fn(),
-		} as any;
-
-		driver['fullPath'] = vi.fn();
-
-		await driver.delete(sample.path.input);
-		expect(driver['fullPath']).toHaveBeenCalledWith(sample.path.input);
-	});
-});
-
-describe('#list', () => {
-	test('Constructs list objects params based on input prefix', async () => {
-		const sampleFile = randFileName();
-		const sampleDirectory = randDirectoryPath();
-		const fullSample = `${sampleDirectory}/${sampleFile}`;
-
-		// TODO: Probably a better way to do this?
-		driver['bucket'] = {
-			list: vi.fn().mockReturnValue({ data: [], error: null }),
-		} as any;
-
-		await driver.list(fullSample)[Symbol.asyncIterator]().next();
-
-		expect(driver['bucket'].list).toHaveBeenCalledWith(sampleDirectory, {
-			search: sampleFile,
-			limit: 1000,
-			offset: 0,
-		});
-	});
-
-	test('Yields file name omitting root if prefix is the full file path', async () => {
-		const sampleRoot = randDirectoryPath();
-		const sampleFile = randFileName();
-		const sampleFull = `${sample.path.input}/${sampleFile}`;
-
-		driver['bucket'] = {
-			list: vi.fn().mockResolvedValueOnce({
-				data: [
-					{
-						name: sampleFile,
-						id: randUnique(),
-					},
-				],
-				error: null,
-			}),
-		} as any;
-
-		driver['config'].root = sampleRoot;
-
-		const iterator = driver.list(sampleFull);
-		const output: string[] = [];
-
-		for await (const filepath of iterator) {
-			output.push(filepath);
-		}
-
-		expect(output).toStrictEqual([sampleFull]);
-	});
-
-	test('Yields file name omitting root if prefix is the parent directory', async () => {
-		const sampleRoot = randDirectoryPath();
-		const sampleFile = randFileName();
-		const sampleParentDir = randUnique();
-		const sampleInput = `${sample.path.input}/${sampleParentDir}`;
-		const sampleFull = `${sampleInput}/${sampleFile}`;
-
-		driver['bucket'] = {
-			list: vi
-				.fn()
-				.mockResolvedValueOnce({
-					data: [
-						{
-							name: sampleParentDir,
-							id: null,
-						},
-					],
-					error: null,
-				})
-				.mockResolvedValueOnce({
-					data: [
-						{
-							name: sampleFile,
-							id: randUnique(),
-						},
-					],
-					error: null,
-				}),
-		} as any;
-
-		driver['config'].root = sampleRoot;
-
-		const iterator = driver.list(sampleInput);
-		const output: string[] = [];
-
-		for await (const filepath of iterator) {
-			output.push(filepath);
-		}
-
-		expect(driver['bucket'].list).toHaveBeenCalledTimes(2);
-		expect(output).toStrictEqual([sampleFull]);
-	});
-
-	test('Yields file name omitting root if prefix is part of the file name', async () => {
-		const sampleRoot = randDirectoryPath();
-		const sampleFilePrefix = randFileName();
-		const sampleFiles = [1, 2, 3].map((i) => `${sampleFilePrefix}_postfix${i}`);
-		const sampleInput = `${sample.path.input}/${sampleFilePrefix}`;
-		const sampleFilesFull = sampleFiles.map((name) => `${sample.path.input}/${name}`);
-
-		driver['bucket'] = {
-			list: vi.fn().mockResolvedValueOnce({
-				data: sampleFiles.map((name) => ({
-					name,
-					id: randUnique(),
-				})),
-				error: null,
-			}),
-		} as any;
-
-		driver['config'].root = sampleRoot;
-
-		const iterator = driver.list(sampleInput);
-		const output: string[] = [];
-
-		for await (const filepath of iterator) {
-			output.push(filepath);
-		}
-
-		expect(output).toStrictEqual(sampleFilesFull);
-	});
-
-	test('Recursively fetches all nested directories and yields only the files', async () => {
-		const sampleRoot = randUnique() + randDirectoryPath();
-		const samplePrefixBase = randUnique() + randDirectoryPath();
-		const samplePrefixLastDir = randUnique();
-		const samplePrefix = `${samplePrefixBase}/${samplePrefixLastDir}`;
-
-		/*
-		sampleFile
-		sampleDirectory/
-		├─ sampleFileNested
-		 */
-		const sampleDirectory = randUnique();
-		const sampleFile = randFileName();
-		const sampleFileNested = randFileName();
-
-		const fullSampleDirectory = `${samplePrefix}/${sampleDirectory}`;
-		const fullSampleFile = `${samplePrefix}/${sampleFile}`;
-		const fullSampleFileNested = `${fullSampleDirectory}/${sampleFileNested}`;
-
-		driver['bucket'] = {
-			list: vi.fn(async (path, options): Promise<any> => {
-				// query for parent dir, return the contained dir
-				if (path === `${sampleRoot}/${samplePrefixBase}` && options?.search === samplePrefixLastDir)
-					return { data: [{ name: samplePrefixLastDir, id: null }], error: null };
-				// query for the contents of the samplePrefix, return file and directory
-				if (path === `${sampleRoot}/${samplePrefix}/` && options?.search === '')
-					return {
-						data: [
-							{ name: sampleDirectory, id: null },
-							{ name: sampleFile, id: randUnique() },
-						],
-						error: null,
-					};
-				// query for the contents of the sampleDirectory, return the nested file
-				if (path === `${sampleRoot}/${fullSampleDirectory}/` && options?.search === '')
-					return {
-						data: [{ name: sampleFileNested, id: randUnique() }],
-						error: null,
-					};
-				throw Error();
-			}),
-		} as any;
-
-		driver['config'].root = sampleRoot;
-
-		const iterator = driver.list(samplePrefix);
-		const output: string[] = [];
-
-		for await (const filepath of iterator) {
-			output.push(filepath);
-		}
-
-		expect(driver['bucket'].list).toHaveBeenCalledTimes(3);
-		expect(output).toStrictEqual([fullSampleFileNested, fullSampleFile]);
-	});
-
-	test('Continuously fetches until all pages are returned', async () => {
-		const firstContents = Array.from({ length: 1000 }, () => ({ name: randFilePath() }));
-		const secondContents = Array.from({ length: 256 }, () => ({ name: randFilePath() }));
-
-		// TODO: Probably a better way to do this?
-		driver['bucket'] = {
-			list: vi
-				.fn()
-				.mockResolvedValueOnce({
-					data: firstContents,
-					error: null,
-				})
-				.mockResolvedValueOnce({
-					data: secondContents,
-					error: null,
-				}),
-		} as any;
-
-		const iterator = driver.list(sample.path.input);
-
-		const output: string[] = [];
-
-		for await (const filepath of iterator) {
-			output.push(filepath);
-		}
-
-		expect(output.length).toBe(1256);
-	});
-});
+describe('#copy', () => {
\ No newline at end of file
diff --git a/packages/storage-driver-supabase/src/index.ts b/packages/storage-driver-supabase/src/index.ts
index 8698bd3..a789656 100644
--- a/packages/storage-driver-supabase/src/index.ts
+++ b/packages/storage-driver-supabase/src/index.ts
@@ -139,16 +139,12 @@ export class DriverSupabase implements TusDriver {
 	}
 
 	async write(filepath: string, content: Readable, type?: string) {
-		const { error } = await this.bucket.upload(this.fullPath(filepath), content, {
+		await this.bucket.upload(this.fullPath(filepath), content, {
 			contentType: type ?? '',
 			cacheControl: '3600',
 			upsert: true,
 			duplex: 'half',
 		});
-
-		if (error) {
-			throw new Error(`Error uploading file "${filepath}"`, { cause: error });
-		}
 	}
 
 	async delete(filepath: string) {
@@ -323,4 +319,4 @@ class FileReader {
 		// @ts-expect-error
 		return new StreamSource(input);
 	}
-}
+}
\ No newline at end of file
