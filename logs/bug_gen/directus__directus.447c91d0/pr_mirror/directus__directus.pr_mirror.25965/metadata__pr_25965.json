{
    "cost": 0.20121,
    "rewrites": {
        "directus__directus.447c91d0/app/src/composables/use-item/index.ts": {
            "output": "import api from '@/api';\nimport { useNestedValidation } from '@/composables/use-nested-validation';\nimport { VALIDATION_TYPES } from '@/constants';\nimport { i18n } from '@/lang';\nimport { useFieldsStore } from '@/stores/fields';\nimport { useRelationsStore } from '@/stores/relations';\nimport { APIError } from '@/types/error';\nimport { getDefaultValuesFromFields } from '@/utils/get-default-values-from-fields';\nimport { notify } from '@/utils/notify';\nimport { pushGroupOptionsDown } from '@/utils/push-group-options-down';\nimport { translate } from '@/utils/translate-object-values';\nimport { unexpectedError } from '@/utils/unexpected-error';\nimport { validateItem } from '@/utils/validate-item';\nimport { getFieldsInGroup } from '@/utils/get-fields-in-group';\nimport { useCollection } from '@directus/composables';\nimport { isSystemCollection } from '@directus/system-data';\nimport { Alterations, Field, Item, PrimaryKey, Query, Relation } from '@directus/types';\nimport { getEndpoint, isObject } from '@directus/utils';\nimport { AxiosResponse } from 'axios';\nimport { jsonToGraphQLQuery } from 'json-to-graphql-query';\nimport { mergeWith, cloneDeep } from 'lodash';\nimport { ComputedRef, MaybeRef, Ref, computed, isRef, ref, unref, watch } from 'vue';\nimport { UsablePermissions, usePermissions } from '../use-permissions';\nimport { getGraphqlQueryFields } from './lib/get-graphql-query-fields';\nimport { applyConditions } from '@/utils/apply-conditions';\n\ntype UsableItem<T extends Item> = {\n\tedits: Ref<Item>;\n\thasEdits: ComputedRef<boolean>;\n\titem: Ref<T | null>;\n\tpermissions: UsablePermissions;\n\terror: Ref<any>;\n\tloading: ComputedRef<boolean>;\n\tsaving: Ref<boolean>;\n\trefresh: () => void;\n\tsave: () => Promise<T>;\n\tisNew: ComputedRef<boolean>;\n\tremove: () => Promise<void>;\n\tdeleting: Ref<boolean>;\n\tarchive: () => Promise<void>;\n\tisArchived: ComputedRef<boolean | null>;\n\tarchiving: Ref<boolean>;\n\tsaveAsCopy: () => Promise<PrimaryKey | null>;\n\tgetItem: () => Promise<void>;\n\tvalidationErrors: Ref<any[]>;\n};\n\nexport function useItem<T extends Item>(\n\tcollection: Ref<string>,\n\tprimaryKey: Ref<PrimaryKey | null>,\n\tquery: MaybeRef<Query> = {},\n): UsableItem<T> {\n\tconst { info: collectionInfo, primaryKeyField } = useCollection(collection);\n\tconst item: Ref<T | null> = ref(null);\n\tconst error = ref<any>(null);\n\tconst validationErrors = ref<any[]>([]);\n\tconst loadingItem = ref(false);\n\tconst saving = ref(false);\n\tconst deleting = ref(false);\n\tconst archiving = ref(false);\n\tconst edits = ref<Item>({});\n\tconst hasEdits = computed(() => Object.keys(edits.value).length > 0);\n\tconst isNew = computed(() => primaryKey.value === '+');\n\tconst isSingle = computed(() => !!collectionInfo.value?.meta?.singleton);\n\n\tconst isArchived = computed(() => {\n\t\tif (!collectionInfo.value?.meta?.archive_field) return null;\n\n\t\tif (collectionInfo.value.meta.archive_value === 'true') {\n\t\t\treturn item.value?.[collectionInfo.value.meta.archive_field] === true;\n\t\t}\n\n\t\treturn item.value?.[collectionInfo.value.meta.archive_field] === collectionInfo.value.meta.archive_value;\n\t});\n\n\tconst permissions = usePermissions(collection, primaryKey, isNew);\n\tconst fieldsWithPermissions = permissions.itemPermissions.fields;\n\n\tconst loading = computed(() => loadingItem.value || permissions.itemPermissions.loading.value);\n\n\tconst itemEndpoint = computed(() => {\n\t\tif (isSingle.value) {\n\t\t\treturn getEndpoint(collection.value);\n\t\t}\n\n\t\treturn `${getEndpoint(collection.value)}/${encodeURIComponent(primaryKey.value as string)}`;\n\t});\n\n\tconst defaultValues = getDefaultValuesFromFields(fieldsWithPermissions);\n\n\twatch([collection, primaryKey, ...(isRef(query) ? [query] : [])], refresh);\n\n\trefreshItem();\n\n\tconst { nestedValidationErrors } = useNestedValidation();\n\n\treturn {\n\t\tedits,\n\t\thasEdits,\n\t\titem,\n\t\tpermissions,\n\t\terror,\n\t\tloading,\n\t\tsaving,\n\t\trefresh,\n\t\tsave,\n\t\tisNew,\n\t\tremove,\n\t\tdeleting,\n\t\tarchive,\n\t\tisArchived,\n\t\tarchiving,\n\t\tsaveAsCopy,\n\t\tgetItem,\n\t\tvalidationErrors,\n\t};\n\n\tasync function getItem() {\n\t\tloadingItem.value = true;\n\t\terror.value = null;\n\n\t\ttry {\n\t\t\tconst response = await api.get(itemEndpoint.value, { params: unref(query) });\n\t\t\tsetItemValueToResponse(response);\n\t\t} catch (err) {\n\t\t\terror.value = err;\n\t\t} finally {\n\t\t\tloadingItem.value = false;\n\t\t}\n\t}\n\n\tfunction shouldClearField(field: Field, currentValues: Record<string, any>): boolean {\n\t\tif (!field.meta?.conditions) return false;\n\n\t\tconst fieldWithConditions = applyConditions(currentValues, field);\n\t\treturn !!fieldWithConditions.meta?.hidden && !!fieldWithConditions.meta?.clear_hidden_value_on_save;\n\t}\n\n\tfunction clearHiddenFieldsByCondition(edits: Item, fields: Field[], defaultValues: any, item: any): Item {\n\t\tconst currentValues = mergeItemData(defaultValues, item, edits);\n\n\t\tconst fieldsToClearMap: Map<string, any> = new Map();\n\n\t\tfunction addFieldToClear(field: Field) {\n\t\t\tconst defaultValue = field.schema?.default_value;\n\t\t\tfieldsToClearMap.set(field.field, defaultValue !== undefined ? defaultValue : null);\n\t\t}\n\n\t\tfor (const field of fields) {\n\t\t\tif (shouldClearField(field, currentValues)) {\n\t\t\t\t// If this is a group field that should be cleared, clear all fields within the group\n\t\t\t\tif (field.meta?.special?.includes('group')) {\n\t\t\t\t\tconst fieldsInGroup = getFieldsInGroup(field.field, fields);\n\n\t\t\t\t\tfor (const groupField of fieldsInGroup) {\n\t\t\t\t\t\taddFieldToClear(groupField);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// For non-group fields, add the field itself to be cleared\n\t\t\t\t\taddFieldToClear(field);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fieldsToClearMap.size === 0) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst editsWithClearedValues = cloneDeep(edits);\n\n\t\tfor (const [field, defaultValue] of fieldsToClearMap) {\n\t\t\teditsWithClearedValues[field] = defaultValue;\n\t\t}\n\n\t\treturn editsWithClearedValues;\n\t}\n\n\tasync function save() {\n\t\tsaving.value = true;\n\t\tvalidationErrors.value = [];\n\n\t\tconst fields = pushGroupOptionsDown(fieldsWithPermissions.value);\n\n\t\tconst editsWithClearedValues = clearHiddenFieldsByCondition(edits.value, fields, defaultValues.value, item.value);\n\n\t\tconst payloadToValidate = mergeItemData(defaultValues.value, item.value, editsWithClearedValues);\n\n\t\tconst errors = validateItem(payloadToValidate, fields, isNew.value);\n\t\tif (nestedValidationErrors.value?.length) errors.push(...nestedValidationErrors.value);\n\n\t\tif (errors.length > 0) {\n\t\t\tvalidationErrors.value = errors;\n\t\t\tsaving.value = false;\n\t\t\tthrow errors;\n\t\t}\n\n\t\ttry {\n\t\t\tlet response;\n\n\t\t\tif (isNew.value) {\n\t\t\t\tresponse = await api.post(getEndpoint(collection.value), editsWithClearedValues);\n\n\t\t\t\tnotify({\n\t\t\t\t\ttitle: i18n.global.t('item_create_success', 1),\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tresponse = await api.patch(itemEndpoint.value, editsWithClearedValues);\n\n\t\t\t\tnotify({\n\t\t\t\t\ttitle: i18n.global.t('item_update_success', 1),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsetItemValueToResponse(response);\n\t\t\tedits.value = {};\n\t\t\treturn response.data.data;\n\t\t} catch (error) {\n\t\t\tsaveErrorHandler(error);\n\t\t} finally {\n\t\t\tsaving.value = false;\n\t\t}\n\t}\n\n\tfunction mergeItemData(defaultValues: any, item: any, edits: any) {\n\t\treturn mergeWith({}, defaultValues, item, edits, function (_from: any, to: any) {\n\t\t\tif (typeof to !== 'undefined') {\n\t\t\t\treturn to;\n\t\t\t}\n\t\t});\n\t}\n\n\tasync function saveAsCopy() {\n\t\tsaving.value = true;\n\t\tvalidationErrors.value = [];\n\n\t\tconst fields = collectionInfo.value?.meta?.item_duplication_fields ?? [];\n\n\t\tconst queryFields = getGraphqlQueryFields(fields, collection.value);\n\t\tconst alias = isSystemCollection(collection.value) ? collection.value.substring(9) : collection.value;\n\n\t\tconst query = jsonToGraphQLQuery({\n\t\t\tquery: {\n\t\t\t\titem: {\n\t\t\t\t\t__aliasFor: `${alias}_by_id`,\n\t\t\t\t\t__args: {\n\t\t\t\t\t\tid: primaryKey.value,\n\t\t\t\t\t},\n\t\t\t\t\t...queryFields,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\tconst graphqlEndpoint = isSystemCollection(collection.value) ? '/graphql/system' : '/graphql';\n\t\tlet response;\n\n\t\ttry {\n\t\t\tresponse = await api.post(graphqlEndpoint, { query });\n\t\t} catch (error) {\n\t\t\tsaving.value = false;\n\t\t\tunexpectedError(error);\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst itemData = response.data.data.item;\n\n\t\tconst newItem: Item = {\n\t\t\t...(itemData || {}),\n\t\t\t...cloneDeep(edits.value),\n\t\t};\n\n\t\tclearPrimaryKey(primaryKeyField.value, newItem);\n\n\t\tconst fieldsStore = useFieldsStore();\n\t\tconst relationsStore = useRelationsStore();\n\t\tconst relations = relationsStore.getRelationsForCollection(collection.value);\n\n\t\tfor (const relation of relations) {\n\t\t\tconst oneField = relation.meta?.one_field;\n\t\t\tif (!oneField || !(oneField in newItem)) continue;\n\n\t\t\tconst relatedPrimaryKeyField = fieldsStore.getPrimaryKeyFieldForCollection(relation.collection);\n\t\t\tif (!relatedPrimaryKeyField) continue;\n\n\t\t\tconst existsJunctionRelated = relationsStore.relations.find(\n\t\t\t\t(r) => r.collection === relation.collection && r.meta?.many_field === relation.meta?.junction_field,\n\t\t\t);\n\n\t\t\tif (Array.isArray(newItem[oneField])) {\n\t\t\t\tconst existingItems = await findExistingRelatedItems(relation, relatedPrimaryKeyField);\n\n\t\t\t\tif (existingItems.length > 0) {\n\t\t\t\t\tnewItem[oneField] = newItem[oneField].map((relatedItem: Item | PrimaryKey) => {\n\t\t\t\t\t\tconst existingItem = existingItems.find(\n\t\t\t\t\t\t\t(existingItem) =>\n\t\t\t\t\t\t\t\t// Loose equality because GraphQL always returns primary key as string\n\t\t\t\t\t\t\t\texistingItem[relatedPrimaryKeyField.field] ==\n\t\t\t\t\t\t\t\t(isObject(relatedItem) ? relatedItem[relatedPrimaryKeyField.field] : relatedItem),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (existingItem) {\n\t\t\t\t\t\t\tclearPrimaryKey(primaryKeyField.value, existingItem);\n\t\t\t\t\t\t\tclearJunctionRelatedKey(relation, existsJunctionRelated, existingItem);\n\t\t\t\t\t\t\trelatedItem = existingItem;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn relatedItem;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (isObject(newItem[oneField])) {\n\t\t\t\tconst newRelatedItem = newItem[oneField] as Alterations;\n\n\t\t\t\tconst existingItems = (await findExistingRelatedItems(relation, relatedPrimaryKeyField)).filter(\n\t\t\t\t\t(item) => !newRelatedItem.delete.includes(item[relatedPrimaryKeyField.field]),\n\t\t\t\t);\n\n\t\t\t\tfor (const item of newRelatedItem.update) {\n\t\t\t\t\tlet data;\n\n\t\t\t\t\tconst existingItemIndex = existingItems.findIndex(\n\t\t\t\t\t\t(existingItem) => existingItem[relatedPrimaryKeyField.field] === item[relatedPrimaryKeyField.field],\n\t\t\t\t\t);\n\n\t\t\t\t\tif (existingItemIndex > -1) {\n\t\t\t\t\t\tdata = mergeWith(existingItems[existingItemIndex], item, (objValue) => {\n\t\t\t\t\t\t\tif (Array.isArray(objValue)) return objValue;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\texistingItems.splice(existingItemIndex, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata = item;\n\t\t\t\t\t}\n\n\t\t\t\t\tclearPrimaryKey(relatedPrimaryKeyField, data);\n\t\t\t\t\tclearJunctionRelatedKey(relation, existsJunctionRelated, data);\n\n\t\t\t\t\tnewRelatedItem.create.push(data);\n\t\t\t\t}\n\n\t\t\t\tfor (const item of existingItems) {\n\t\t\t\t\tclearPrimaryKey(relatedPrimaryKeyField, item);\n\n\t\t\t\t\tnewRelatedItem.create.push(item);\n\t\t\t\t}\n\n\t\t\t\tnewRelatedItem.update.length = 0;\n\t\t\t}\n\t\t}\n\n\t\tconst errors = validateItem(newItem, fieldsWithPermissions.value, isNew.value);\n\t\tif (nestedValidationErrors.value?.length) errors.push(...nestedValidationErrors.value);\n\n\t\tif (errors.length > 0) {\n\t\t\tvalidationErrors.value = errors;\n\t\t\tsaving.value = false;\n\t\t\tthrow errors;\n\t\t}\n\n\t\ttry {\n\t\t\tconst response = await api.post(getEndpoint(collection.value), newItem);\n\n\t\t\tnotify({\n\t\t\t\ttitle: i18n.global.t('item_create_success', 1),\n\t\t\t});\n\n\t\t\t// Reset edits to the current item\n\t\t\tedits.value = {};\n\n\t\t\treturn primaryKeyField.value ? response.data.data[primaryKeyField.value.field] : null;\n\t\t} catch (error) {\n\t\t\tsaveErrorHandler(error);\n\t\t} finally {\n\t\t\tsaving.value = false;\n\t\t}\n\n\t\tasync function findExistingRelatedItems(relation: Relation, relatedPrimaryKeyField: Field): Promise<Item[]> {\n\t\t\tconst existingRelatedItem = itemData[relation.meta!.one_field!];\n\n\t\t\tif (!existingRelatedItem) return [];\n\n\t\t\tconst existingIds = existingRelatedItem.filter(\n\t\t\t\t(item: unknown) => isObject(item) && relatedPrimaryKeyField.field in item,\n\t\t\t);\n\n\t\t\tif (existingIds.length === 0) return [];\n\n\t\t\tconst fieldsToFetch = new Set(\n\t\t\t\tfields.reduce((accumulator, currentValue) => {\n\t\t\t\t\tconst [onePart, ...remainingParts] = currentValue.split('.');\n\n\t\t\t\t\tif (onePart === relation.meta!.one_field! && remainingParts.length > 0)\n\t\t\t\t\t\taccumulator.push(remainingParts.join('.'));\n\n\t\t\t\t\treturn accumulator;\n\t\t\t\t}, [] as string[]),\n\t\t\t);\n\n\t\t\tif (fieldsToFetch.size > 0) fieldsToFetch.add(relatedPrimaryKeyField.field);\n\n\t\t\tconst response = await api.get(getEndpoint(relation.collection), {\n\t\t\t\tparams: {\n\t\t\t\t\tfields: Array.from(fieldsToFetch),\n\t\t\t\t\t[`filter[${relation.field}][_eq]`]: primaryKey.value,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\treturn response.data.data;\n\t\t}\n\n\t\tfunction clearPrimaryKey(primaryKeyField: Field | null, item: Item) {\n\t\t\tif (primaryKeyField?.schema?.has_auto_increment || primaryKeyField?.meta?.special?.includes('uuid')) {\n\t\t\t\tdelete item[primaryKeyField.field];\n\t\t\t}\n\t\t}\n\n\t\tfunction clearJunctionRelatedKey(relation: Relation, existsJunctionRelated: Relation | undefined, item: Item) {\n\t\t\tif (!relation.meta?.junction_field || !isObject(item[relation.meta.junction_field]) || !existsJunctionRelate",
            "output_extracted": "import api from '@/api';\nimport { useNestedValidation } from '@/composables/use-nested-validation';\nimport { VALIDATION_TYPES } from '@/constants';\nimport { i18n } from '@/lang';\nimport { useFieldsStore } from '@/stores/fields';\nimport { useRelationsStore } from '@/stores/relations';\nimport { APIError } from '@/types/error';\nimport { getDefaultValuesFromFields } from '@/utils/get-default-values-from-fields';\nimport { notify } from '@/utils/notify';\nimport { pushGroupOptionsDown } from '@/utils/push-group-options-down';\nimport { translate } from '@/utils/translate-object-values';\nimport { unexpectedError } from '@/utils/unexpected-error';\nimport { validateItem } from '@/utils/validate-item';\nimport { getFieldsInGroup } from '@/utils/get-fields-in-group';\nimport { useCollection } from '@directus/composables';\nimport { isSystemCollection } from '@directus/system-data';\nimport { Alterations, Field, Item, PrimaryKey, Query, Relation } from '@directus/types';\nimport { getEndpoint, isObject } from '@directus/utils';\nimport { AxiosResponse } from 'axios';\nimport { jsonToGraphQLQuery } from 'json-to-graphql-query';\nimport { mergeWith, cloneDeep } from 'lodash';\nimport { ComputedRef, MaybeRef, Ref, computed, isRef, ref, unref, watch } from 'vue';\nimport { UsablePermissions, usePermissions } from '../use-permissions';\nimport { getGraphqlQueryFields } from './lib/get-graphql-query-fields';\nimport { applyConditions } from '@/utils/apply-conditions';\n\ntype UsableItem<T extends Item> = {\n\tedits: Ref<Item>;\n\thasEdits: ComputedRef<boolean>;\n\titem: Ref<T | null>;\n\tpermissions: UsablePermissions;\n\terror: Ref<any>;\n\tloading: ComputedRef<boolean>;\n\tsaving: Ref<boolean>;\n\trefresh: () => void;\n\tsave: () => Promise<T>;\n\tisNew: ComputedRef<boolean>;\n\tremove: () => Promise<void>;\n\tdeleting: Ref<boolean>;\n\tarchive: () => Promise<void>;\n\tisArchived: ComputedRef<boolean | null>;\n\tarchiving: Ref<boolean>;\n\tsaveAsCopy: () => Promise<PrimaryKey | null>;\n\tgetItem: () => Promise<void>;\n\tvalidationErrors: Ref<any[]>;\n};\n\nexport function useItem<T extends Item>(\n\tcollection: Ref<string>,\n\tprimaryKey: Ref<PrimaryKey | null>,\n\tquery: MaybeRef<Query> = {},\n): UsableItem<T> {\n\tconst { info: collectionInfo, primaryKeyField } = useCollection(collection);\n\tconst item: Ref<T | null> = ref(null);\n\tconst error = ref<any>(null);\n\tconst validationErrors = ref<any[]>([]);\n\tconst loadingItem = ref(false);\n\tconst saving = ref(false);\n\tconst deleting = ref(false);\n\tconst archiving = ref(false);\n\tconst edits = ref<Item>({});\n\tconst hasEdits = computed(() => Object.keys(edits.value).length > 0);\n\tconst isNew = computed(() => primaryKey.value === '+');\n\tconst isSingle = computed(() => !!collectionInfo.value?.meta?.singleton);\n\n\tconst isArchived = computed(() => {\n\t\tif (!collectionInfo.value?.meta?.archive_field) return null;\n\n\t\tif (collectionInfo.value.meta.archive_value === 'true') {\n\t\t\treturn item.value?.[collectionInfo.value.meta.archive_field] === true;\n\t\t}\n\n\t\treturn item.value?.[collectionInfo.value.meta.archive_field] === collectionInfo.value.meta.archive_value;\n\t});\n\n\tconst permissions = usePermissions(collection, primaryKey, isNew);\n\tconst fieldsWithPermissions = permissions.itemPermissions.fields;\n\n\tconst loading = computed(() => loadingItem.value || permissions.itemPermissions.loading.value);\n\n\tconst itemEndpoint = computed(() => {\n\t\tif (isSingle.value) {\n\t\t\treturn getEndpoint(collection.value);\n\t\t}\n\n\t\treturn `${getEndpoint(collection.value)}/${encodeURIComponent(primaryKey.value as string)}`;\n\t});\n\n\tconst defaultValues = getDefaultValuesFromFields(fieldsWithPermissions);\n\n\twatch([collection, primaryKey, ...(isRef(query) ? [query] : [])], refresh);\n\n\trefreshItem();\n\n\tconst { nestedValidationErrors } = useNestedValidation();\n\n\treturn {\n\t\tedits,\n\t\thasEdits,\n\t\titem,\n\t\tpermissions,\n\t\terror,\n\t\tloading,\n\t\tsaving,\n\t\trefresh,\n\t\tsave,\n\t\tisNew,\n\t\tremove,\n\t\tdeleting,\n\t\tarchive,\n\t\tisArchived,\n\t\tarchiving,\n\t\tsaveAsCopy,\n\t\tgetItem,\n\t\tvalidationErrors,\n\t};\n\n\tasync function getItem() {\n\t\tloadingItem.value = true;\n\t\terror.value = null;\n\n\t\ttry {\n\t\t\tconst response = await api.get(itemEndpoint.value, { params: unref(query) });\n\t\t\tsetItemValueToResponse(response);\n\t\t} catch (err) {\n\t\t\terror.value = err;\n\t\t} finally {\n\t\t\tloadingItem.value = false;\n\t\t}\n\t}\n\n\tfunction shouldClearField(field: Field, currentValues: Record<string, any>): boolean {\n\t\tif (!field.meta?.conditions) return false;\n\n\t\tconst fieldWithConditions = applyConditions(currentValues, field);\n\t\treturn !!fieldWithConditions.meta?.hidden && !!fieldWithConditions.meta?.clear_hidden_value_on_save;\n\t}\n\n\tfunction clearHiddenFieldsByCondition(edits: Item, fields: Field[], defaultValues: any, item: any): Item {\n\t\tconst currentValues = mergeItemData(defaultValues, item, edits);\n\n\t\tconst fieldsToClearMap: Map<string, any> = new Map();\n\n\t\tfunction addFieldToClear(field: Field) {\n\t\t\tconst defaultValue = field.schema?.default_value;\n\t\t\tfieldsToClearMap.set(field.field, defaultValue !== undefined ? defaultValue : null);\n\t\t}\n\n\t\tfor (const field of fields) {\n\t\t\tif (shouldClearField(field, currentValues)) {\n\t\t\t\t// If this is a group field that should be cleared, clear all fields within the group\n\t\t\t\tif (field.meta?.special?.includes('group')) {\n\t\t\t\t\tconst fieldsInGroup = getFieldsInGroup(field.field, fields);\n\n\t\t\t\t\tfor (const groupField of fieldsInGroup) {\n\t\t\t\t\t\taddFieldToClear(groupField);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// For non-group fields, add the field itself to be cleared\n\t\t\t\t\taddFieldToClear(field);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fieldsToClearMap.size === 0) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst editsWithClearedValues = cloneDeep(edits);\n\n\t\tfor (const [field, defaultValue] of fieldsToClearMap) {\n\t\t\teditsWithClearedValues[field] = defaultValue;\n\t\t}\n\n\t\treturn editsWithClearedValues;\n\t}\n\n\tasync function save() {\n\t\tsaving.value = true;\n\t\tvalidationErrors.value = [];\n\n\t\tconst fields = pushGroupOptionsDown(fieldsWithPermissions.value);\n\n\t\tconst editsWithClearedValues = clearHiddenFieldsByCondition(edits.value, fields, defaultValues.value, item.value);\n\n\t\tconst payloadToValidate = mergeItemData(defaultValues.value, item.value, editsWithClearedValues);\n\n\t\tconst errors = validateItem(payloadToValidate, fields, isNew.value);\n\t\tif (nestedValidationErrors.value?.length) errors.push(...nestedValidationErrors.value);\n\n\t\tif (errors.length > 0) {\n\t\t\tvalidationErrors.value = errors;\n\t\t\tsaving.value = false;\n\t\t\tthrow errors;\n\t\t}\n\n\t\ttry {\n\t\t\tlet response;\n\n\t\t\tif (isNew.value) {\n\t\t\t\tresponse = await api.post(getEndpoint(collection.value), editsWithClearedValues);\n\n\t\t\t\tnotify({\n\t\t\t\t\ttitle: i18n.global.t('item_create_success', 1),\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tresponse = await api.patch(itemEndpoint.value, editsWithClearedValues);\n\n\t\t\t\tnotify({\n\t\t\t\t\ttitle: i18n.global.t('item_update_success', 1),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsetItemValueToResponse(response);\n\t\t\tedits.value = {};\n\t\t\treturn response.data.data;\n\t\t} catch (error) {\n\t\t\tsaveErrorHandler(error);\n\t\t} finally {\n\t\t\tsaving.value = false;\n\t\t}\n\t}\n\n\tfunction mergeItemData(defaultValues: any, item: any, edits: any) {\n\t\treturn mergeWith({}, defaultValues, item, edits, function (_from: any, to: any) {\n\t\t\tif (typeof to !== 'undefined') {\n\t\t\t\treturn to;\n\t\t\t}\n\t\t});\n\t}\n\n\tasync function saveAsCopy() {\n\t\tsaving.value = true;\n\t\tvalidationErrors.value = [];\n\n\t\tconst fields = collectionInfo.value?.meta?.item_duplication_fields ?? [];\n\n\t\tconst queryFields = getGraphqlQueryFields(fields, collection.value);\n\t\tconst alias = isSystemCollection(collection.value) ? collection.value.substring(9) : collection.value;\n\n\t\tconst query = jsonToGraphQLQuery({\n\t\t\tquery: {\n\t\t\t\titem: {\n\t\t\t\t\t__aliasFor: `${alias}_by_id`,\n\t\t\t\t\t__args: {\n\t\t\t\t\t\tid: primaryKey.value,\n\t\t\t\t\t},\n\t\t\t\t\t...queryFields,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\tconst graphqlEndpoint = isSystemCollection(collection.value) ? '/graphql/system' : '/graphql';\n\t\tlet response;\n\n\t\ttry {\n\t\t\tresponse = await api.post(graphqlEndpoint, { query });\n\t\t} catch (error) {\n\t\t\tsaving.value = false;\n\t\t\tunexpectedError(error);\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst itemData = response.data.data.item;\n\n\t\tconst newItem: Item = {\n\t\t\t...(itemData || {}),\n\t\t\t...cloneDeep(edits.value),\n\t\t};\n\n\t\tclearPrimaryKey(primaryKeyField.value, newItem);\n\n\t\tconst fieldsStore = useFieldsStore();\n\t\tconst relationsStore = useRelationsStore();\n\t\tconst relations = relationsStore.getRelationsForCollection(collection.value);\n\n\t\tfor (const relation of relations) {\n\t\t\tconst oneField = relation.meta?.one_field;\n\t\t\tif (!oneField || !(oneField in newItem)) continue;\n\n\t\t\tconst relatedPrimaryKeyField = fieldsStore.getPrimaryKeyFieldForCollection(relation.collection);\n\t\t\tif (!relatedPrimaryKeyField) continue;\n\n\t\t\tconst existsJunctionRelated = relationsStore.relations.find(\n\t\t\t\t(r) => r.collection === relation.collection && r.meta?.many_field === relation.meta?.junction_field,\n\t\t\t);\n\n\t\t\tif (Array.isArray(newItem[oneField])) {\n\t\t\t\tconst existingItems = await findExistingRelatedItems(relation, relatedPrimaryKeyField);\n\n\t\t\t\tif (existingItems.length > 0) {\n\t\t\t\t\tnewItem[oneField] = newItem[oneField].map((relatedItem: Item | PrimaryKey) => {\n\t\t\t\t\t\tconst existingItem = existingItems.find(\n\t\t\t\t\t\t\t(existingItem) =>\n\t\t\t\t\t\t\t\t// Loose equality because GraphQL always returns primary key as string\n\t\t\t\t\t\t\t\texistingItem[relatedPrimaryKeyField.field] ==\n\t\t\t\t\t\t\t\t(isObject(relatedItem) ? relatedItem[relatedPrimaryKeyField.field] : relatedItem),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (existingItem) {\n\t\t\t\t\t\t\tclearPrimaryKey(primaryKeyField.value, existingItem);\n\t\t\t\t\t\t\tclearJunctionRelatedKey(relation, existsJunctionRelated, existingItem);\n\t\t\t\t\t\t\trelatedItem = existingItem;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn relatedItem;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (isObject(newItem[oneField])) {\n\t\t\t\tconst newRelatedItem = newItem[oneField] as Alterations;\n\n\t\t\t\tconst existingItems = (await findExistingRelatedItems(relation, relatedPrimaryKeyField)).filter(\n\t\t\t\t\t(item) => !newRelatedItem.delete.includes(item[relatedPrimaryKeyField.field]),\n\t\t\t\t);\n\n\t\t\t\tfor (const item of newRelatedItem.update) {\n\t\t\t\t\tlet data;\n\n\t\t\t\t\tconst existingItemIndex = existingItems.findIndex(\n\t\t\t\t\t\t(existingItem) => existingItem[relatedPrimaryKeyField.field] === item[relatedPrimaryKeyField.field],\n\t\t\t\t\t);\n\n\t\t\t\t\tif (existingItemIndex > -1) {\n\t\t\t\t\t\tdata = mergeWith(existingItems[existingItemIndex], item, (objValue) => {\n\t\t\t\t\t\t\tif (Array.isArray(objValue)) return objValue;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\texistingItems.splice(existingItemIndex, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata = item;\n\t\t\t\t\t}\n\n\t\t\t\t\tclearPrimaryKey(relatedPrimaryKeyField, data);\n\t\t\t\t\tclearJunctionRelatedKey(relation, existsJunctionRelated, data);\n\n\t\t\t\t\tnewRelatedItem.create.push(data);\n\t\t\t\t}\n\n\t\t\t\tfor (const item of existingItems) {\n\t\t\t\t\tclearPrimaryKey(relatedPrimaryKeyField, item);\n\n\t\t\t\t\tnewRelatedItem.create.push(item);\n\t\t\t\t}\n\n\t\t\t\tnewRelatedItem.update.length = 0;\n\t\t\t}\n\t\t}\n\n\t\tconst errors = validateItem(newItem, fieldsWithPermissions.value, isNew.value);\n\t\tif (nestedValidationErrors.value?.length) errors.push(...nestedValidationErrors.value);\n\n\t\tif (errors.length > 0) {\n\t\t\tvalidationErrors.value = errors;\n\t\t\tsaving.value = false;\n\t\t\tthrow errors;\n\t\t}\n\n\t\ttry {\n\t\t\tconst response = await api.post(getEndpoint(collection.value), newItem);\n\n\t\t\tnotify({\n\t\t\t\ttitle: i18n.global.t('item_create_success', 1),\n\t\t\t});\n\n\t\t\t// Reset edits to the current item\n\t\t\tedits.value = {};\n\n\t\t\treturn primaryKeyField.value ? response.data.data[primaryKeyField.value.field] : null;\n\t\t} catch (error) {\n\t\t\tsaveErrorHandler(error);\n\t\t} finally {\n\t\t\tsaving.value = false;\n\t\t}\n\n\t\tasync function findExistingRelatedItems(relation: Relation, relatedPrimaryKeyField: Field): Promise<Item[]> {\n\t\t\tconst existingRelatedItem = itemData[relation.meta!.one_field!];\n\n\t\t\tif (!existingRelatedItem) return [];\n\n\t\t\tconst existingIds = existingRelatedItem.filter(\n\t\t\t\t(item: unknown) => isObject(item) && relatedPrimaryKeyField.field in item,\n\t\t\t);\n\n\t\t\tif (existingIds.length === 0) return [];\n\n\t\t\tconst fieldsToFetch = new Set(\n\t\t\t\tfields.reduce((accumulator, currentValue) => {\n\t\t\t\t\tconst [onePart, ...remainingParts] = currentValue.split('.');\n\n\t\t\t\t\tif (onePart === relation.meta!.one_field! && remainingParts.length > 0)\n\t\t\t\t\t\taccumulator.push(remainingParts.join('.'));\n\n\t\t\t\t\treturn accumulator;\n\t\t\t\t}, [] as string[]),\n\t\t\t);\n\n\t\t\tif (fieldsToFetch.size > 0) fieldsToFetch.add(relatedPrimaryKeyField.field);\n\n\t\t\tconst response = await api.get(getEndpoint(relation.collection), {\n\t\t\t\tparams: {\n\t\t\t\t\tfields: Array.from(fieldsToFetch),\n\t\t\t\t\t[`filter[${relation.field}][_eq]`]: primaryKey.value,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\treturn response.data.data;\n\t\t}\n\n\t\tfunction clearPrimaryKey(primaryKeyField: Field | null, item: Item) {\n\t\t\tif (primaryKeyField?.schema?.has_auto_increment || primaryKeyField?.meta?.special?.includes('uuid')) {\n\t\t\t\tdelete item[primaryKeyField.field];\n\t\t\t}\n\t\t}\n\n\t\tfunction clearJunctionRelatedKey(relation: Relation, existsJunctionRelated: Relation | undefined, item: Item) {\n\t\t\tif (!relation.meta?.junction_field || !isObject(item[relation.meta.junction_field]) || !existsJunctionRelate",
            "cost": 0.13667
        },
        "directus__directus.447c91d0/app/src/composables/use-versions.ts": {
            "output": "import api from '@/api';\nimport { unexpectedError } from '@/utils/unexpected-error';\nimport { ContentVersion, Filter, Query, Item } from '@directus/types';\nimport { useRouteQuery } from '@vueuse/router';\nimport { Ref, computed, ref, unref, watch } from 'vue';\nimport { useCollectionPermissions, usePermissions } from './use-permissions';\nimport { mergeWith } from 'lodash';\nimport { pushGroupOptionsDown } from '@/utils/push-group-options-down';\nimport { validateItem } from '@/utils/validate-item';\nimport { useNestedValidation } from '@/composables/use-nested-validation';\nimport { getDefaultValuesFromFields } from '@/utils/get-default-values-from-fields';\nimport { APIError } from '@/types/error';\nimport { VALIDATION_TYPES } from '@/constants';\n\nexport function useVersions(collection: Ref<string>, isSingleton: Ref<boolean>, primaryKey: Ref<string | null>) {\n\tconst currentVersion = ref<ContentVersion | null>(null);\n\tconst versions = ref<ContentVersion[] | null>(null);\n\tconst loading = ref(false);\n\tconst saveVersionLoading = ref(false);\n\tconst validationErrors = ref<any[]>([]);\n\n\tconst { readAllowed: readVersionsAllowed } = useCollectionPermissions('directus_versions');\n\n\tconst queryVersion = useRouteQuery<string | null>('version', null, {\n\t\ttransform: (value) => (Array.isArray(value) ? value[0] : value),\n\t\tmode: 'push',\n\t});\n\n\tconst permissions = usePermissions(collection, primaryKey, false);\n\tconst fieldsWithPermissions = permissions.itemPermissions.fields;\n\tconst { nestedValidationErrors } = useNestedValidation();\n\tconst defaultValues = getDefaultValuesFromFields(fieldsWithPermissions);\n\n\twatch(\n\t\t[queryVersion, versions],\n\t\t([newQueryVersion, newVersions]) => {\n\t\t\tif (!newVersions) return;\n\n\t\t\tlet version;\n\n\t\t\tif (queryVersion.value) {\n\t\t\t\tversion = newVersions.find((version) => version.key === newQueryVersion);\n\t\t\t}\n\n\t\t\tif (version?.key !== currentVersion.value?.key) {\n\t\t\t\tvalidationErrors.value = [];\n\t\t\t}\n\n\t\t\tcurrentVersion.value = version ?? null;\n\t\t},\n\t\t{ immediate: true },\n\t);\n\n\twatch(currentVersion, (newCurrentVersion) => {\n\t\tqueryVersion.value = newCurrentVersion?.key ?? null;\n\t\tvalidationErrors.value = [];\n\t});\n\n\tconst query = computed<Query>(() => {\n\t\tif (!currentVersion.value) return {};\n\n\t\treturn {\n\t\t\tversion: currentVersion.value.key,\n\t\t\tversionRaw: true,\n\t\t};\n\t});\n\n\twatch(\n\t\t[collection, isSingleton, primaryKey],\n\t\t([newCollection], [oldCollection]) => {\n\t\t\tif (newCollection !== oldCollection) currentVersion.value = null;\n\t\t\tgetVersions();\n\t\t},\n\t\t{ immediate: true },\n\t);\n\n\treturn {\n\t\treadVersionsAllowed,\n\t\tcurrentVersion,\n\t\tversions,\n\t\tloading,\n\t\tquery,\n\t\tgetVersions,\n\t\taddVersion,\n\t\tupdateVersion,\n\t\tdeleteVersion,\n\t\tsaveVersionLoading,\n\t\tsaveVersion,\n\t\tvalidationErrors,\n\t};\n\n\tfunction saveVersionErrorHandler(error: any) {\n\t\tif (error?.response?.data?.errors) {\n\t\t\tvalidationErrors.value = error.response.data.errors\n\t\t\t\t.filter((err: APIError) => VALIDATION_TYPES.includes(err?.extensions?.code))\n\t\t\t\t.map((err: APIError) => {\n\t\t\t\t\treturn err.extensions;\n\t\t\t\t});\n\n\t\t\tconst otherErrors = error.response.data.errors.filter(\n\t\t\t\t(err: APIError) => !VALIDATION_TYPES.includes(err?.extensions?.code),\n\t\t\t);\n\n\t\t\tif (otherErrors.length > 0) {\n\t\t\t\totherErrors.forEach(unexpectedError);\n\t\t\t}\n\t\t} else {\n\t\t\tunexpectedError(error);\n\t\t}\n\n\t\tthrow error;\n\t}\n\n\tasync function getVersions() {\n\t\tif (!readVersionsAllowed.value) return;\n\n\t\tif ((!isSingleton.value && !primaryKey.value) || primaryKey.value === '+') return;\n\n\t\tloading.value = true;\n\n\t\ttry {\n\t\t\tconst filter: Filter = {\n\t\t\t\t_and: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcollection: {\n\t\t\t\t\t\t\t_eq: unref(collection),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t...(primaryKey.value\n\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\titem: {\n\t\t\t\t\t\t\t\t\t\t_eq: primaryKey.value,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t: []),\n\t\t\t\t],\n\t\t\t};\n\n\t\t\tconst response = await api.get(`/versions`, {\n\t\t\t\tparams: {\n\t\t\t\t\tfilter,\n\t\t\t\t\tsort: '-date_created',\n\t\t\t\t\tfields: ['*'],\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tversions.value = response.data.data;\n\t\t} catch (error) {\n\t\t\tunexpectedError(error);\n\t\t} finally {\n\t\t\tloading.value = false;\n\t\t}\n\t}\n\n\tasync function addVersion(version: ContentVersion) {\n\t\tversions.value = [...(versions.value ? versions.value : []), version];\n\t\tqueryVersion.value = version.key;\n\t}\n\n\tasync function updateVersion(updates: { key: string; name?: string | null }) {\n\t\tif (!currentVersion.value || !versions.value) return;\n\n\t\tconst currentVersionId = currentVersion.value.id;\n\n\t\tconst versionToUpdate = versions.value.find((version) => version.id === currentVersionId);\n\n\t\tif (versionToUpdate) {\n\t\t\tversionToUpdate.key = updates.key;\n\t\t\tif ('name' in updates) versionToUpdate.name = updates.name ?? null;\n\t\t\tcurrentVersion.value = versionToUpdate;\n\t\t}\n\t}\n\n\tasync function deleteVersion() {\n\t\tif (!currentVersion.value || !versions.value) return;\n\n\t\tconst currentVersionId = currentVersion.value.id;\n\n\t\tconst index = versions.value.findIndex((version) => version.id === currentVersionId);\n\n\t\tif (index !== undefined) {\n\t\t\tcurrentVersion.value = null;\n\t\t\tversions.value.splice(index, 1);\n\t\t}\n\t}\n\n\tasync function saveVersion(edits: Ref<Record<string, any>>, item: Ref<Item>) {\n\t\tif (!currentVersion.value) return;\n\t\tsaveVersionLoading.value = true;\n\t\tvalidationErrors.value = [];\n\n\t\tconst payloadToValidate = mergeWith(\n\t\t\t{},\n\t\t\tdefaultValues.value,\n\t\t\titem.value,\n\t\t\tedits.value,\n\t\t\tfunction (_from: any, to: any) {\n\t\t\t\tif (typeof to !== 'undefined') {\n\t\t\t\t\treturn to;\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\tconst fields = pushGroupOptionsDown(fieldsWithPermissions.value);\n\n\t\tconst errors = validateItem(payloadToValidate, fields, false, false, currentVersion.value);\n\t\tif (nestedValidationErrors.value?.length) errors.push(...nestedValidationErrors.value);\n\n\t\tif (errors.length > 0) {\n\t\t\tvalidationErrors.value = errors;\n\t\t\tsaveVersionLoading.value = false;\n\t\t\tthrow errors;\n\t\t}\n\n\t\ttry {\n\t\t\tconst response = await api.post(`/versions/${currentVersion.value.id}/save`, unref(edits));\n\t\t\tconst savedData = response.data.data;\n\n\t\t\t// Update local item with the saved changes\n\t\t\tObject.assign(item.value, savedData);\n\t\t\tedits.value = {};\n\n\t\t\tawait getVersions();\n\n\t\t\treturn savedData;\n\t\t} catch (error) {\n\t\t\tsaveVersionErrorHandler(error);\n\t\t} finally {\n\t\t\tsaveVersionLoading.value = false;\n\t\t}\n\t}\n}",
            "output_extracted": "import api from '@/api';\nimport { unexpectedError } from '@/utils/unexpected-error';\nimport { ContentVersion, Filter, Query, Item } from '@directus/types';\nimport { useRouteQuery } from '@vueuse/router';\nimport { Ref, computed, ref, unref, watch } from 'vue';\nimport { useCollectionPermissions, usePermissions } from './use-permissions';\nimport { mergeWith } from 'lodash';\nimport { pushGroupOptionsDown } from '@/utils/push-group-options-down';\nimport { validateItem } from '@/utils/validate-item';\nimport { useNestedValidation } from '@/composables/use-nested-validation';\nimport { getDefaultValuesFromFields } from '@/utils/get-default-values-from-fields';\nimport { APIError } from '@/types/error';\nimport { VALIDATION_TYPES } from '@/constants';\n\nexport function useVersions(collection: Ref<string>, isSingleton: Ref<boolean>, primaryKey: Ref<string | null>) {\n\tconst currentVersion = ref<ContentVersion | null>(null);\n\tconst versions = ref<ContentVersion[] | null>(null);\n\tconst loading = ref(false);\n\tconst saveVersionLoading = ref(false);\n\tconst validationErrors = ref<any[]>([]);\n\n\tconst { readAllowed: readVersionsAllowed } = useCollectionPermissions('directus_versions');\n\n\tconst queryVersion = useRouteQuery<string | null>('version', null, {\n\t\ttransform: (value) => (Array.isArray(value) ? value[0] : value),\n\t\tmode: 'push',\n\t});\n\n\tconst permissions = usePermissions(collection, primaryKey, false);\n\tconst fieldsWithPermissions = permissions.itemPermissions.fields;\n\tconst { nestedValidationErrors } = useNestedValidation();\n\tconst defaultValues = getDefaultValuesFromFields(fieldsWithPermissions);\n\n\twatch(\n\t\t[queryVersion, versions],\n\t\t([newQueryVersion, newVersions]) => {\n\t\t\tif (!newVersions) return;\n\n\t\t\tlet version;\n\n\t\t\tif (queryVersion.value) {\n\t\t\t\tversion = newVersions.find((version) => version.key === newQueryVersion);\n\t\t\t}\n\n\t\t\tif (version?.key !== currentVersion.value?.key) {\n\t\t\t\tvalidationErrors.value = [];\n\t\t\t}\n\n\t\t\tcurrentVersion.value = version ?? null;\n\t\t},\n\t\t{ immediate: true },\n\t);\n\n\twatch(currentVersion, (newCurrentVersion) => {\n\t\tqueryVersion.value = newCurrentVersion?.key ?? null;\n\t\tvalidationErrors.value = [];\n\t});\n\n\tconst query = computed<Query>(() => {\n\t\tif (!currentVersion.value) return {};\n\n\t\treturn {\n\t\t\tversion: currentVersion.value.key,\n\t\t\tversionRaw: true,\n\t\t};\n\t});\n\n\twatch(\n\t\t[collection, isSingleton, primaryKey],\n\t\t([newCollection], [oldCollection]) => {\n\t\t\tif (newCollection !== oldCollection) currentVersion.value = null;\n\t\t\tgetVersions();\n\t\t},\n\t\t{ immediate: true },\n\t);\n\n\treturn {\n\t\treadVersionsAllowed,\n\t\tcurrentVersion,\n\t\tversions,\n\t\tloading,\n\t\tquery,\n\t\tgetVersions,\n\t\taddVersion,\n\t\tupdateVersion,\n\t\tdeleteVersion,\n\t\tsaveVersionLoading,\n\t\tsaveVersion,\n\t\tvalidationErrors,\n\t};\n\n\tfunction saveVersionErrorHandler(error: any) {\n\t\tif (error?.response?.data?.errors) {\n\t\t\tvalidationErrors.value = error.response.data.errors\n\t\t\t\t.filter((err: APIError) => VALIDATION_TYPES.includes(err?.extensions?.code))\n\t\t\t\t.map((err: APIError) => {\n\t\t\t\t\treturn err.extensions;\n\t\t\t\t});\n\n\t\t\tconst otherErrors = error.response.data.errors.filter(\n\t\t\t\t(err: APIError) => !VALIDATION_TYPES.includes(err?.extensions?.code),\n\t\t\t);\n\n\t\t\tif (otherErrors.length > 0) {\n\t\t\t\totherErrors.forEach(unexpectedError);\n\t\t\t}\n\t\t} else {\n\t\t\tunexpectedError(error);\n\t\t}\n\n\t\tthrow error;\n\t}\n\n\tasync function getVersions() {\n\t\tif (!readVersionsAllowed.value) return;\n\n\t\tif ((!isSingleton.value && !primaryKey.value) || primaryKey.value === '+') return;\n\n\t\tloading.value = true;\n\n\t\ttry {\n\t\t\tconst filter: Filter = {\n\t\t\t\t_and: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcollection: {\n\t\t\t\t\t\t\t_eq: unref(collection),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t...(primaryKey.value\n\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\titem: {\n\t\t\t\t\t\t\t\t\t\t_eq: primaryKey.value,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t: []),\n\t\t\t\t],\n\t\t\t};\n\n\t\t\tconst response = await api.get(`/versions`, {\n\t\t\t\tparams: {\n\t\t\t\t\tfilter,\n\t\t\t\t\tsort: '-date_created',\n\t\t\t\t\tfields: ['*'],\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tversions.value = response.data.data;\n\t\t} catch (error) {\n\t\t\tunexpectedError(error);\n\t\t} finally {\n\t\t\tloading.value = false;\n\t\t}\n\t}\n\n\tasync function addVersion(version: ContentVersion) {\n\t\tversions.value = [...(versions.value ? versions.value : []), version];\n\t\tqueryVersion.value = version.key;\n\t}\n\n\tasync function updateVersion(updates: { key: string; name?: string | null }) {\n\t\tif (!currentVersion.value || !versions.value) return;\n\n\t\tconst currentVersionId = currentVersion.value.id;\n\n\t\tconst versionToUpdate = versions.value.find((version) => version.id === currentVersionId);\n\n\t\tif (versionToUpdate) {\n\t\t\tversionToUpdate.key = updates.key;\n\t\t\tif ('name' in updates) versionToUpdate.name = updates.name ?? null;\n\t\t\tcurrentVersion.value = versionToUpdate;\n\t\t}\n\t}\n\n\tasync function deleteVersion() {\n\t\tif (!currentVersion.value || !versions.value) return;\n\n\t\tconst currentVersionId = currentVersion.value.id;\n\n\t\tconst index = versions.value.findIndex((version) => version.id === currentVersionId);\n\n\t\tif (index !== undefined) {\n\t\t\tcurrentVersion.value = null;\n\t\t\tversions.value.splice(index, 1);\n\t\t}\n\t}\n\n\tasync function saveVersion(edits: Ref<Record<string, any>>, item: Ref<Item>) {\n\t\tif (!currentVersion.value) return;\n\t\tsaveVersionLoading.value = true;\n\t\tvalidationErrors.value = [];\n\n\t\tconst payloadToValidate = mergeWith(\n\t\t\t{},\n\t\t\tdefaultValues.value,\n\t\t\titem.value,\n\t\t\tedits.value,\n\t\t\tfunction (_from: any, to: any) {\n\t\t\t\tif (typeof to !== 'undefined') {\n\t\t\t\t\treturn to;\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\tconst fields = pushGroupOptionsDown(fieldsWithPermissions.value);\n\n\t\tconst errors = validateItem(payloadToValidate, fields, false, false, currentVersion.value);\n\t\tif (nestedValidationErrors.value?.length) errors.push(...nestedValidationErrors.value);\n\n\t\tif (errors.length > 0) {\n\t\t\tvalidationErrors.value = errors;\n\t\t\tsaveVersionLoading.value = false;\n\t\t\tthrow errors;\n\t\t}\n\n\t\ttry {\n\t\t\tconst response = await api.post(`/versions/${currentVersion.value.id}/save`, unref(edits));\n\t\t\tconst savedData = response.data.data;\n\n\t\t\t// Update local item with the saved changes\n\t\t\tObject.assign(item.value, savedData);\n\t\t\tedits.value = {};\n\n\t\t\tawait getVersions();\n\n\t\t\treturn savedData;\n\t\t} catch (error) {\n\t\t\tsaveVersionErrorHandler(error);\n\t\t} finally {\n\t\t\tsaveVersionLoading.value = false;\n\t\t}\n\t}\n}",
            "cost": 0.06454
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "directus/directus",
        "instance_id": "directus__directus.pr_mirror.25965",
        "base_commit": "f636050870ad3ed1cff05aa2513c16c0384f36a0",
        "patch": "diff --git a/.changeset/eager-tables-invite.md b/.changeset/eager-tables-invite.md\nnew file mode 100644\nindex 0000000000000..147b9b53adc5e\n--- /dev/null\n+++ b/.changeset/eager-tables-invite.md\n@@ -0,0 +1,5 @@\n+---\n+'@directus/app': patch\n+---\n+\n+Fixed merge behavior during validation for nested drawer forms\ndiff --git a/app/src/composables/use-item/index.ts b/app/src/composables/use-item/index.ts\nindex 75a55f23d8414..ad7c48391f6ff 100644\n--- a/app/src/composables/use-item/index.ts\n+++ b/app/src/composables/use-item/index.ts\n@@ -5,24 +5,25 @@ import { i18n } from '@/lang';\n import { useFieldsStore } from '@/stores/fields';\n import { useRelationsStore } from '@/stores/relations';\n import { APIError } from '@/types/error';\n+import { applyConditions } from '@/utils/apply-conditions';\n import { getDefaultValuesFromFields } from '@/utils/get-default-values-from-fields';\n+import { getFieldsInGroup } from '@/utils/get-fields-in-group';\n+import { mergeItemData } from '@/utils/merge-item-data';\n import { notify } from '@/utils/notify';\n import { pushGroupOptionsDown } from '@/utils/push-group-options-down';\n import { translate } from '@/utils/translate-object-values';\n import { unexpectedError } from '@/utils/unexpected-error';\n import { validateItem } from '@/utils/validate-item';\n-import { getFieldsInGroup } from '@/utils/get-fields-in-group';\n import { useCollection } from '@directus/composables';\n import { isSystemCollection } from '@directus/system-data';\n import { Alterations, Field, Item, PrimaryKey, Query, Relation } from '@directus/types';\n import { getEndpoint, isObject } from '@directus/utils';\n import { AxiosResponse } from 'axios';\n import { jsonToGraphQLQuery } from 'json-to-graphql-query';\n-import { mergeWith, cloneDeep } from 'lodash';\n+import { cloneDeep, mergeWith } from 'lodash';\n import { ComputedRef, MaybeRef, Ref, computed, isRef, ref, unref, watch } from 'vue';\n import { UsablePermissions, usePermissions } from '../use-permissions';\n import { getGraphqlQueryFields } from './lib/get-graphql-query-fields';\n-import { applyConditions } from '@/utils/apply-conditions';\n \n type UsableItem<T extends Item> = {\n \tedits: Ref<Item>;\n@@ -183,7 +184,7 @@ export function useItem<T extends Item>(\n \n \t\tconst editsWithClearedValues = clearHiddenFieldsByCondition(edits.value, fields, defaultValues.value, item.value);\n \n-\t\tconst payloadToValidate = mergeItemData(defaultValues.value, item.value, editsWithClearedValues);\n+\t\tconst payloadToValidate = mergeItemData(defaultValues.value, item.value ?? {}, editsWithClearedValues);\n \n \t\tconst errors = validateItem(payloadToValidate, fields, isNew.value);\n \t\tif (nestedValidationErrors.value?.length) errors.push(...nestedValidationErrors.value);\n@@ -221,14 +222,6 @@ export function useItem<T extends Item>(\n \t\t}\n \t}\n \n-\tfunction mergeItemData(defaultValues: any, item: any, edits: any) {\n-\t\treturn mergeWith({}, defaultValues, item, edits, function (_from: any, to: any) {\n-\t\t\tif (typeof to !== 'undefined') {\n-\t\t\t\treturn to;\n-\t\t\t}\n-\t\t});\n-\t}\n-\n \tasync function saveAsCopy() {\n \t\tsaving.value = true;\n \t\tvalidationErrors.value = [];\ndiff --git a/app/src/composables/use-versions.ts b/app/src/composables/use-versions.ts\nindex a342263e900e3..1b3648a437975 100644\n--- a/app/src/composables/use-versions.ts\n+++ b/app/src/composables/use-versions.ts\n@@ -1,16 +1,16 @@\n import api from '@/api';\n+import { useNestedValidation } from '@/composables/use-nested-validation';\n+import { VALIDATION_TYPES } from '@/constants';\n+import { APIError } from '@/types/error';\n+import { getDefaultValuesFromFields } from '@/utils/get-default-values-from-fields';\n+import { mergeItemData } from '@/utils/merge-item-data';\n+import { pushGroupOptionsDown } from '@/utils/push-group-options-down';\n import { unexpectedError } from '@/utils/unexpected-error';\n-import { ContentVersion, Filter, Query, Item } from '@directus/types';\n+import { validateItem } from '@/utils/validate-item';\n+import { ContentVersion, Filter, Item, Query } from '@directus/types';\n import { useRouteQuery } from '@vueuse/router';\n import { Ref, computed, ref, unref, watch } from 'vue';\n import { useCollectionPermissions, usePermissions } from './use-permissions';\n-import { mergeWith } from 'lodash';\n-import { pushGroupOptionsDown } from '@/utils/push-group-options-down';\n-import { validateItem } from '@/utils/validate-item';\n-import { useNestedValidation } from '@/composables/use-nested-validation';\n-import { getDefaultValuesFromFields } from '@/utils/get-default-values-from-fields';\n-import { APIError } from '@/types/error';\n-import { VALIDATION_TYPES } from '@/constants';\n \n export function useVersions(collection: Ref<string>, isSingleton: Ref<boolean>, primaryKey: Ref<string | null>) {\n \tconst currentVersion = ref<ContentVersion | null>(null);\n@@ -191,17 +191,7 @@ export function useVersions(collection: Ref<string>, isSingleton: Ref<boolean>,\n \t\tsaveVersionLoading.value = true;\n \t\tvalidationErrors.value = [];\n \n-\t\tconst payloadToValidate = mergeWith(\n-\t\t\t{},\n-\t\t\tdefaultValues.value,\n-\t\t\titem.value,\n-\t\t\tedits.value,\n-\t\t\tfunction (_from: any, to: any) {\n-\t\t\t\tif (typeof to !== 'undefined') {\n-\t\t\t\t\treturn to;\n-\t\t\t\t}\n-\t\t\t},\n-\t\t);\n+\t\tconst payloadToValidate = mergeItemData(defaultValues.value, item.value, edits.value);\n \n \t\tconst fields = pushGroupOptionsDown(fieldsWithPermissions.value);\n \ndiff --git a/app/src/utils/merge-item-data.test.ts b/app/src/utils/merge-item-data.test.ts\nnew file mode 100644\nindex 0000000000000..072f16f80d656\n--- /dev/null\n+++ b/app/src/utils/merge-item-data.test.ts\n@@ -0,0 +1,85 @@\n+import { describe, it, expect } from 'vitest';\n+import { mergeItemData } from './merge-item-data';\n+\n+describe('mergeItemData', () => {\n+\tit('should use existing if field is undefined in edits', () => {\n+\t\tconst defaults = { x: 'default' };\n+\t\tconst existing = { x: 'existing' };\n+\t\tconst edits = {};\n+\t\tconst result = mergeItemData(defaults, existing, edits);\n+\t\texpect(result.x).toMatchInlineSnapshot(`\"existing\"`);\n+\t});\n+\n+\tit('should use default if field is undefined in both existing and edits', () => {\n+\t\tconst defaults = { x: 'default' };\n+\t\tconst existing = {};\n+\t\tconst edits = {};\n+\t\tconst result = mergeItemData(defaults, existing, edits);\n+\t\texpect(result.x).toMatchInlineSnapshot(`\"default\"`);\n+\t});\n+\n+\tit('should use edits over existing and default', () => {\n+\t\tconst defaults = { x: 'default' };\n+\t\tconst existing = { x: 'existing' };\n+\t\tconst edits = { x: 'edited' };\n+\t\tconst result = mergeItemData(defaults, existing, edits);\n+\t\texpect(result.x).toMatchInlineSnapshot(`\"edited\"`);\n+\t});\n+\n+\tit('should merge default, existing, and edits with correct precedence', () => {\n+\t\tconst defaults = { b: 'default b', c: 'default c' };\n+\t\tconst existing = { a: 'existing a', b: 'existing b', d: 'existing d' };\n+\t\tconst edits = { b: 'edit b', e: 'edit e' };\n+\t\tconst result = mergeItemData(defaults, existing, edits);\n+\n+\t\texpect(result).toMatchInlineSnapshot(`\n+\t\t\t{\n+\t\t\t  \"a\": \"existing a\",\n+\t\t\t  \"b\": \"edit b\",\n+\t\t\t  \"c\": \"default c\",\n+\t\t\t  \"d\": \"existing d\",\n+\t\t\t  \"e\": \"edit e\",\n+\t\t\t}\n+\t\t`);\n+\t});\n+\n+\tit('should not merge nested objects', () => {\n+\t\tconst defaults = { obj: { a: 1, b: 2 } };\n+\t\tconst existing = { obj: { b: 3 } };\n+\t\tconst edits = { obj: { c: 4 } };\n+\t\tconst result = mergeItemData(defaults, existing, edits);\n+\n+\t\texpect(result.obj).toMatchInlineSnapshot(`\n+\t\t\t{\n+\t\t\t  \"c\": 4,\n+\t\t\t}\n+\t\t`);\n+\t});\n+\n+\tit('should not merge nested arrays', () => {\n+\t\tconst defaults = { arr: [1, 2, 3] };\n+\t\tconst existing = { arr: [4, 5] };\n+\t\tconst edits = { arr: [6] };\n+\t\tconst result = mergeItemData(defaults, existing, edits);\n+\n+\t\texpect(result.arr).toMatchInlineSnapshot(`\n+\t\t\t[\n+\t\t\t  6,\n+\t\t\t]\n+\t\t`);\n+\t});\n+\n+\tit('should handle null and undefined values correctly', () => {\n+\t\tconst defaults = { a: 'default a', b: 'default b' };\n+\t\tconst existing = { a: null };\n+\t\tconst edits = { b: undefined };\n+\t\tconst result = mergeItemData(defaults, existing, edits);\n+\n+\t\texpect(result).toMatchInlineSnapshot(`\n+\t\t\t{\n+\t\t\t  \"a\": null,\n+\t\t\t  \"b\": \"default b\",\n+\t\t\t}\n+\t\t`);\n+\t});\n+});\ndiff --git a/app/src/utils/merge-item-data.ts b/app/src/utils/merge-item-data.ts\nnew file mode 100644\nindex 0000000000000..a30d1907426e9\n--- /dev/null\n+++ b/app/src/utils/merge-item-data.ts\n@@ -0,0 +1,13 @@\n+import { mergeWith } from 'lodash';\n+\n+export function mergeItemData(\n+\tdefaultValues: Record<string, any>,\n+\texistingValues: Record<string, any>,\n+\tedits: Record<string, any>,\n+) {\n+\treturn mergeWith({}, defaultValues, existingValues, edits, customizer);\n+\n+\tfunction customizer(_from: unknown, to: unknown): any {\n+\t\tif (typeof to !== 'undefined') return to;\n+\t}\n+}\ndiff --git a/app/src/views/private/components/overlay-item.vue b/app/src/views/private/components/overlay-item.vue\nindex 99f165cd7c2de..772373a2b4214 100644\n--- a/app/src/views/private/components/overlay-item.vue\n+++ b/app/src/views/private/components/overlay-item.vue\n@@ -2,13 +2,15 @@\n import api from '@/api';\n import { type ApplyShortcut } from '@/components/v-dialog.vue';\n import { useEditsGuard } from '@/composables/use-edits-guard';\n+import { useFlows } from '@/composables/use-flows';\n+import { useNestedValidation } from '@/composables/use-nested-validation';\n import { usePermissions } from '@/composables/use-permissions';\n import { useShortcut } from '@/composables/use-shortcut';\n import { useTemplateData } from '@/composables/use-template-data';\n-import { useNestedValidation } from '@/composables/use-nested-validation';\n import { useFieldsStore } from '@/stores/fields';\n import { useRelationsStore } from '@/stores/relations';\n import { getDefaultValuesFromFields } from '@/utils/get-default-values-from-fields';\n+import { mergeItemData } from '@/utils/merge-item-data';\n import { translateShortcut } from '@/utils/translate-shortcut';\n import { unexpectedError } from '@/utils/unexpected-error';\n import { validateItem } from '@/utils/validate-item';\n@@ -16,12 +18,11 @@ import { useCollection } from '@directus/composables';\n import { isSystemCollection } from '@directus/system-data';\n import { Field, PrimaryKey, Relation } from '@directus/types';\n import { getEndpoint } from '@directus/utils';\n-import { isEmpty, merge, set } from 'lodash';\n-import { computed, ref, toRefs, watch, unref, type Ref } from 'vue';\n+import { isEmpty, set } from 'lodash';\n+import { computed, ref, toRefs, unref, watch, type Ref } from 'vue';\n import { useI18n } from 'vue-i18n';\n import { useRouter } from 'vue-router';\n import OverlayItemContent from './overlay-item-content.vue';\n-import { useFlows } from '@/composables/use-flows';\n \n export interface OverlayItemProps {\n \toverlay?: 'drawer' | 'modal' | 'popover';\n@@ -435,7 +436,12 @@ function useActions() {\n \t}\n \n \tfunction validateForm({ defaultValues, existingValues, editsToValidate, fieldsToValidate }: Record<string, any>) {\n-\t\treturn validateItem(merge({}, defaultValues, existingValues, editsToValidate), fieldsToValidate, isNew.value, true);\n+\t\treturn validateItem(\n+\t\t\tmergeItemData(defaultValues, existingValues, editsToValidate),\n+\t\t\tfieldsToValidate,\n+\t\t\tisNew.value,\n+\t\t\ttrue,\n+\t\t);\n \t}\n \n \tfunction save() {\n",
        "test_patch": "",
        "problem_statement": "## Scope\r\n\r\nWhat's changed:\r\n\r\n- Fixed an issue where saving nested many-to-many relationships triggered a validation error due to incorrect merging behavior\r\n- Moved the redundant logic from the useItem() and useVersions() composables into a new mergeItemData utility, and also applied it to the overlay-item component\r\n\r\n\r\n## Potential Risks / Drawbacks\r\n\r\n\u2014\r\n\r\n## Tested Scenarios\r\n\r\n- Reproduction steps\r\n\r\n## Review Notes / Questions\r\n\r\n\u2014\r\n\r\n## Checklist\r\n\r\n- [x] Added or updated tests\r\n- [x] Documentation PR created [here](https://github.com/directus/docs) or not required\r\n\r\n---\r\n\r\nFixes #25919\r\n",
        "hints_text": "",
        "created_at": "2025-10-10T12:59:51Z",
        "pull_number": 25965,
        "test_files": [
            "app/src/utils/merge-item-data.test.ts"
        ],
        "code_files": [
            "app/src/composables/use-item/index.ts",
            "app/src/composables/use-versions.ts",
            "app/src/utils/merge-item-data.ts"
        ],
        "title": "Fix merge behavior during validation for nested drawer forms",
        "additions": 0,
        "deletions": 0,
        "pr_mirror": "directus__directus.447c91d0"
    }
}