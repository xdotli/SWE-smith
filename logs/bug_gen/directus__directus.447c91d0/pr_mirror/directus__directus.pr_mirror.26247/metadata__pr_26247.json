{
    "cost": 0.04190000000000001,
    "rewrites": {
        "directus__directus.447c91d0/api/src/services/tus/server.ts": {
            "output": "/**\n * TUS implementation for resumable uploads\n *\n * https://tus.io/\n */\nimport { useEnv } from '@directus/env';\nimport type { Driver, TusDriver } from '@directus/storage';\nimport { supportsTus } from '@directus/storage';\nimport type { Accountability, File, SchemaOverview } from '@directus/types';\nimport { toArray } from '@directus/utils';\nimport { Server } from '@tus/server';\nimport { RESUMABLE_UPLOADS } from '../../constants.js';\nimport { getStorage } from '../../storage/index.js';\nimport { extractMetadata } from '../files/lib/extract-metadata.js';\nimport { ItemsService } from '../index.js';\nimport { TusDataStore } from './data-store.js';\nimport { getTusLocker } from './lockers.js';\nimport { pick } from 'lodash-es';\nimport emitter from '../../emitter.js';\nimport getDatabase from '../../database/index.js';\nimport { getSchema } from '../../utils/get-schema.js';\n\ntype Context = {\n\tschema: SchemaOverview;\n\taccountability?: Accountability | undefined;\n};\n\nasync function createTusStore(context: Context) {\n\tconst env = useEnv();\n\tconst storage = await getStorage();\n\tconst location = toArray(env['STORAGE_LOCATIONS'] as string)[0]!;\n\tconst driver: Driver | TusDriver = storage.location(location);\n\n\tif (!supportsTus(driver)) {\n\t\tthrow new Error(`Storage location ${location} does not support the TUS protocol`);\n\t}\n\n\treturn new TusDataStore({\n\t\tconstants: RESUMABLE_UPLOADS,\n\t\taccountability: context.accountability,\n\t\tschema: context.schema,\n\t\tlocation,\n\t\tdriver,\n\t});\n}\n\nexport async function createTusServer(context: Context): Promise<[Server, () => void]> {\n\tconst env = useEnv();\n\tconst store = await createTusStore(context);\n\n\tconst server = new Server({\n\t\tpath: '/files/tus',\n\t\tdatastore: store,\n\t\tlocker: getTusLocker(),\n\t\t...(RESUMABLE_UPLOADS.MAX_SIZE !== null && { maxSize: RESUMABLE_UPLOADS.MAX_SIZE }),\n\t\tasync onUploadFinish(req: any, upload) {\n\t\t\tconst schema = await getSchema();\n\n\t\t\tconst service = new ItemsService<File>('directus_files', {\n\t\t\t\tschema,\n\t\t\t});\n\n\t\t\tconst file = (\n\t\t\t\tawait service.readByQuery({\n\t\t\t\t\tfilter: { tus_id: { _eq: upload.id } },\n\t\t\t\t\tlimit: 1,\n\t\t\t\t})\n\t\t\t)[0];\n\n\t\t\tif (!file) return {};\n\n\t\t\tlet fileData;\n\n\t\t\t// update metadata when file is replaced\n\t\t\tif (file.tus_data?.['metadata']?.['replace_id']) {\n\t\t\t\tconst newFile = await service.readOne(file.tus_data['metadata']['replace_id']);\n\t\t\t\tconst updateFields = pick(file, ['filename_download', 'filesize', 'type']);\n\n\t\t\t\tconst metadata = await extractMetadata(newFile.storage, {\n\t\t\t\t\t...newFile,\n\t\t\t\t\t...updateFields,\n\t\t\t\t});\n\n\t\t\t\tawait service.updateOne(file.tus_data['metadata']['replace_id'], {\n\t\t\t\t\t...updateFields,\n\t\t\t\t\t...metadata,\n\t\t\t\t});\n\n\t\t\t\tfileData = {\n\t\t\t\t\t...newFile,\n\t\t\t\t\t...updateFields,\n\t\t\t\t\t...metadata,\n\t\t\t\t\tid: file.tus_data['metadata']['replace_id'],\n\t\t\t\t};\n\n\t\t\t\tawait service.deleteOne(file.id);\n\t\t\t} else {\n\t\t\t\tconst metadata = await extractMetadata(file.storage, file);\n\n\t\t\t\tawait service.updateOne(file.id, {\n\t\t\t\t\t...metadata,\n\t\t\t\t\ttus_id: null,\n\t\t\t\t\ttus_data: null,\n\t\t\t\t});\n\n\t\t\t\tfileData = {\n\t\t\t\t\t...file,\n\t\t\t\t\t...metadata,\n\t\t\t\t\ttus_id: null,\n\t\t\t\t\ttus_data: null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\temitter.emitAction(\n\t\t\t\t'files.upload',\n\t\t\t\t{\n\t\t\t\t\tpayload: fileData,\n\t\t\t\t\tkey: fileData.id,\n\t\t\t\t\tcollection: 'directus_files',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdatabase: getDatabase(),\n\t\t\t\t\tschema,\n\t\t\t\t\taccountability: req.accountability,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\theaders: {\n\t\t\t\t\t'Directus-File-Id': upload.metadata!['id']!,\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t\tgenerateUrl(_req, opts) {\n\t\t\treturn env['PUBLIC_URL'] + '/files/tus/' + opts.id;\n\t\t},\n\t\tallowedHeaders: env['CORS_ALLOWED_HEADERS'] as string[],\n\t\texposedHeaders: env['CORS_EXPOSED_HEADERS'] as string[],\n\t\trelativeLocation: String(env['PUBLIC_URL']).startsWith('http'),\n\t});\n\n\treturn [server, cleanup];\n\n\tfunction cleanup() {\n\t\tserver.removeAllListeners();\n\t}\n}",
            "output_extracted": "/**\n * TUS implementation for resumable uploads\n *\n * https://tus.io/\n */\nimport { useEnv } from '@directus/env';\nimport type { Driver, TusDriver } from '@directus/storage';\nimport { supportsTus } from '@directus/storage';\nimport type { Accountability, File, SchemaOverview } from '@directus/types';\nimport { toArray } from '@directus/utils';\nimport { Server } from '@tus/server';\nimport { RESUMABLE_UPLOADS } from '../../constants.js';\nimport { getStorage } from '../../storage/index.js';\nimport { extractMetadata } from '../files/lib/extract-metadata.js';\nimport { ItemsService } from '../index.js';\nimport { TusDataStore } from './data-store.js';\nimport { getTusLocker } from './lockers.js';\nimport { pick } from 'lodash-es';\nimport emitter from '../../emitter.js';\nimport getDatabase from '../../database/index.js';\nimport { getSchema } from '../../utils/get-schema.js';\n\ntype Context = {\n\tschema: SchemaOverview;\n\taccountability?: Accountability | undefined;\n};\n\nasync function createTusStore(context: Context) {\n\tconst env = useEnv();\n\tconst storage = await getStorage();\n\tconst location = toArray(env['STORAGE_LOCATIONS'] as string)[0]!;\n\tconst driver: Driver | TusDriver = storage.location(location);\n\n\tif (!supportsTus(driver)) {\n\t\tthrow new Error(`Storage location ${location} does not support the TUS protocol`);\n\t}\n\n\treturn new TusDataStore({\n\t\tconstants: RESUMABLE_UPLOADS,\n\t\taccountability: context.accountability,\n\t\tschema: context.schema,\n\t\tlocation,\n\t\tdriver,\n\t});\n}\n\nexport async function createTusServer(context: Context): Promise<[Server, () => void]> {\n\tconst env = useEnv();\n\tconst store = await createTusStore(context);\n\n\tconst server = new Server({\n\t\tpath: '/files/tus',\n\t\tdatastore: store,\n\t\tlocker: getTusLocker(),\n\t\t...(RESUMABLE_UPLOADS.MAX_SIZE !== null && { maxSize: RESUMABLE_UPLOADS.MAX_SIZE }),\n\t\tasync onUploadFinish(req: any, upload) {\n\t\t\tconst schema = await getSchema();\n\n\t\t\tconst service = new ItemsService<File>('directus_files', {\n\t\t\t\tschema,\n\t\t\t});\n\n\t\t\tconst file = (\n\t\t\t\tawait service.readByQuery({\n\t\t\t\t\tfilter: { tus_id: { _eq: upload.id } },\n\t\t\t\t\tlimit: 1,\n\t\t\t\t})\n\t\t\t)[0];\n\n\t\t\tif (!file) return {};\n\n\t\t\tlet fileData;\n\n\t\t\t// update metadata when file is replaced\n\t\t\tif (file.tus_data?.['metadata']?.['replace_id']) {\n\t\t\t\tconst newFile = await service.readOne(file.tus_data['metadata']['replace_id']);\n\t\t\t\tconst updateFields = pick(file, ['filename_download', 'filesize', 'type']);\n\n\t\t\t\tconst metadata = await extractMetadata(newFile.storage, {\n\t\t\t\t\t...newFile,\n\t\t\t\t\t...updateFields,\n\t\t\t\t});\n\n\t\t\t\tawait service.updateOne(file.tus_data['metadata']['replace_id'], {\n\t\t\t\t\t...updateFields,\n\t\t\t\t\t...metadata,\n\t\t\t\t});\n\n\t\t\t\tfileData = {\n\t\t\t\t\t...newFile,\n\t\t\t\t\t...updateFields,\n\t\t\t\t\t...metadata,\n\t\t\t\t\tid: file.tus_data['metadata']['replace_id'],\n\t\t\t\t};\n\n\t\t\t\tawait service.deleteOne(file.id);\n\t\t\t} else {\n\t\t\t\tconst metadata = await extractMetadata(file.storage, file);\n\n\t\t\t\tawait service.updateOne(file.id, {\n\t\t\t\t\t...metadata,\n\t\t\t\t\ttus_id: null,\n\t\t\t\t\ttus_data: null,\n\t\t\t\t});\n\n\t\t\t\tfileData = {\n\t\t\t\t\t...file,\n\t\t\t\t\t...metadata,\n\t\t\t\t\ttus_id: null,\n\t\t\t\t\ttus_data: null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\temitter.emitAction(\n\t\t\t\t'files.upload',\n\t\t\t\t{\n\t\t\t\t\tpayload: fileData,\n\t\t\t\t\tkey: fileData.id,\n\t\t\t\t\tcollection: 'directus_files',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdatabase: getDatabase(),\n\t\t\t\t\tschema,\n\t\t\t\t\taccountability: req.accountability,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\theaders: {\n\t\t\t\t\t'Directus-File-Id': upload.metadata!['id']!,\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t\tgenerateUrl(_req, opts) {\n\t\t\treturn env['PUBLIC_URL'] + '/files/tus/' + opts.id;\n\t\t},\n\t\tallowedHeaders: env['CORS_ALLOWED_HEADERS'] as string[],\n\t\texposedHeaders: env['CORS_EXPOSED_HEADERS'] as string[],\n\t\trelativeLocation: String(env['PUBLIC_URL']).startsWith('http'),\n\t});\n\n\treturn [server, cleanup];\n\n\tfunction cleanup() {\n\t\tserver.removeAllListeners();\n\t}\n}",
            "cost": 0.04190000000000001
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "directus/directus",
        "instance_id": "directus__directus.pr_mirror.26247",
        "base_commit": "f74b2c1f76e595ce073870a076755bf62b6825ce",
        "patch": "diff --git a/.changeset/tall-sheep-write.md b/.changeset/tall-sheep-write.md\nnew file mode 100644\nindex 0000000000000..b6f9c707bc0c5\n--- /dev/null\n+++ b/.changeset/tall-sheep-write.md\n@@ -0,0 +1,5 @@\n+---\n+'@directus/api': patch\n+---\n+\n+Fixed missing accountability for `files.upload` when TUS is enabled\ndiff --git a/api/src/services/tus/server.test.ts b/api/src/services/tus/server.test.ts\nnew file mode 100644\nindex 0000000000000..12b2da13cd5b1\n--- /dev/null\n+++ b/api/src/services/tus/server.test.ts\n@@ -0,0 +1,198 @@\n+import type { Accountability, File, SchemaOverview } from '@directus/types';\n+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';\n+import { createTusServer } from './server.js';\n+import emitter from '../../emitter.js';\n+import { ItemsService } from '../index.js';\n+import { extractMetadata } from '../files/lib/extract-metadata.js';\n+import getDatabase from '../../database/index.js';\n+import { getSchema } from '../../utils/get-schema.js';\n+\n+vi.mock('../../emitter.js', () => ({\n+\tdefault: {\n+\t\temitAction: vi.fn(),\n+\t},\n+}));\n+\n+vi.mock('../index.js', () => ({\n+\tItemsService: vi.fn(),\n+}));\n+\n+vi.mock('../files/lib/extract-metadata.js', () => ({\n+\textractMetadata: vi.fn(),\n+}));\n+\n+vi.mock('../../database/index.js', () => ({\n+\tdefault: vi.fn(),\n+}));\n+\n+vi.mock('../../utils/get-schema.js', () => ({\n+\tgetSchema: vi.fn(),\n+}));\n+\n+vi.mock('../../storage/index.js', () => ({\n+\tgetStorage: vi.fn().mockResolvedValue({\n+\t\tlocation: vi.fn().mockReturnValue({\n+\t\t\tread: vi.fn(),\n+\t\t\twrite: vi.fn(),\n+\t\t\tdelete: vi.fn(),\n+\t\t\tstat: vi.fn(),\n+\t\t\tcopy: vi.fn(),\n+\t\t\tmove: vi.fn(),\n+\t\t\tlist: vi.fn(),\n+\t\t\t$createMultipartUpload: vi.fn(),\n+\t\t\t$uploadPart: vi.fn(),\n+\t\t\t$completeMultipartUpload: vi.fn(),\n+\t\t\t$abortMultipartUpload: vi.fn(),\n+\t\t\t$listParts: vi.fn(),\n+\t\t}),\n+\t}),\n+}));\n+\n+vi.mock('@directus/storage', () => ({\n+\tsupportsTus: vi.fn().mockReturnValue(true),\n+}));\n+\n+vi.mock('@directus/env', () => ({\n+\tuseEnv: vi.fn().mockReturnValue({\n+\t\tSTORAGE_LOCATIONS: 'local',\n+\t\tPUBLIC_URL: 'http://localhost:8055',\n+\t\tCORS_ALLOWED_HEADERS: ['*'],\n+\t\tCORS_EXPOSED_HEADERS: ['*'],\n+\t}),\n+}));\n+\n+describe('createTusServer', () => {\n+\tlet mockSchema: SchemaOverview;\n+\tlet mockAccountability: Accountability;\n+\tlet mockDatabase: any;\n+\tlet mockItemsService: any;\n+\n+\tbeforeEach(() => {\n+\t\tmockSchema = {\n+\t\t\tcollections: {},\n+\t\t\trelations: [],\n+\t\t};\n+\n+\t\tmockAccountability = {\n+\t\t\trole: 'test-role',\n+\t\t\tuser: 'test-user-id',\n+\t\t} as Accountability;\n+\n+\t\tmockDatabase = {};\n+\n+\t\tmockItemsService = {\n+\t\t\treadByQuery: vi.fn(),\n+\t\t\treadOne: vi.fn(),\n+\t\t\tupdateOne: vi.fn(),\n+\t\t\tdeleteOne: vi.fn(),\n+\t\t};\n+\n+\t\tvi.mocked(getDatabase).mockReturnValue(mockDatabase);\n+\t\tvi.mocked(getSchema).mockResolvedValue(mockSchema);\n+\t\tvi.mocked(ItemsService).mockImplementation(() => mockItemsService);\n+\t\tvi.mocked(extractMetadata).mockResolvedValue({});\n+\t});\n+\n+\tafterEach(() => {\n+\t\tvi.clearAllMocks();\n+\t});\n+\n+\tdescribe('onUploadFinish', () => {\n+\t\ttest('should pass accountability to emitter.emitAction when accountability is provided (issue #26242)', async () => {\n+\t\t\tconst mockFile: Partial<File> = {\n+\t\t\t\tid: 'test-file-id',\n+\t\t\t\tstorage: 'local',\n+\t\t\t\tfilename_download: 'test.txt',\n+\t\t\t\ttus_id: 'upload-123',\n+\t\t\t\ttus_data: null,\n+\t\t\t};\n+\n+\t\t\tmockItemsService.readByQuery.mockResolvedValue([mockFile]);\n+\n+\t\t\tconst [server, _cleanup] = await createTusServer({\n+\t\t\t\tschema: mockSchema,\n+\t\t\t\taccountability: mockAccountability,\n+\t\t\t});\n+\n+\t\t\tconst onUploadFinish = (server as any).options.onUploadFinish;\n+\t\t\texpect(onUploadFinish).toBeDefined();\n+\n+\t\t\tawait onUploadFinish(\n+\t\t\t\t{},\n+\t\t\t\t{\n+\t\t\t\t\tid: 'upload-123',\n+\t\t\t\t\tmetadata: { id: 'test-file-id' },\n+\t\t\t\t},\n+\t\t\t);\n+\n+\t\t\texpect(emitter.emitAction).toHaveBeenCalledWith(\n+\t\t\t\t'files.upload',\n+\t\t\t\t{\n+\t\t\t\t\tpayload: {\n+\t\t\t\t\t\tid: 'test-file-id',\n+\t\t\t\t\t\tstorage: 'local',\n+\t\t\t\t\t\tfilename_download: 'test.txt',\n+\t\t\t\t\t\ttus_id: null,\n+\t\t\t\t\t\ttus_data: null,\n+\t\t\t\t\t},\n+\t\t\t\t\tkey: 'test-file-id',\n+\t\t\t\t\tcollection: 'directus_files',\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tschema: mockSchema,\n+\t\t\t\t\tdatabase: mockDatabase,\n+\t\t\t\t\taccountability: mockAccountability,\n+\t\t\t\t},\n+\t\t\t);\n+\t\t});\n+\n+\t\ttest('should pass null accountability to emitter.emitAction when accountability is not provided', async () => {\n+\t\t\tconst mockFile: Partial<File> = {\n+\t\t\t\tid: 'test-file-id',\n+\t\t\t\tstorage: 'local',\n+\t\t\t\tfilename_download: 'test.txt',\n+\t\t\t\ttus_id: 'upload-123',\n+\t\t\t\ttus_data: null,\n+\t\t\t};\n+\n+\t\t\tmockItemsService.readByQuery.mockResolvedValue([mockFile]);\n+\n+\t\t\tconst [server, _cleanup] = await createTusServer({\n+\t\t\t\tschema: mockSchema,\n+\t\t\t\taccountability: undefined,\n+\t\t\t});\n+\n+\t\t\tconst tusServer = server as any;\n+\t\t\tconst onUploadFinish = tusServer.options.onUploadFinish;\n+\n+\t\t\texpect(onUploadFinish).toBeDefined();\n+\n+\t\t\tconst mockUpload = {\n+\t\t\t\tid: 'upload-123',\n+\t\t\t\tmetadata: { id: 'test-file-id' },\n+\t\t\t};\n+\n+\t\t\tawait onUploadFinish({}, mockUpload);\n+\n+\t\t\texpect(emitter.emitAction).toHaveBeenCalledWith(\n+\t\t\t\t'files.upload',\n+\t\t\t\t{\n+\t\t\t\t\tpayload: {\n+\t\t\t\t\t\tid: 'test-file-id',\n+\t\t\t\t\t\tstorage: 'local',\n+\t\t\t\t\t\tfilename_download: 'test.txt',\n+\t\t\t\t\t\ttus_id: null,\n+\t\t\t\t\t\ttus_data: null,\n+\t\t\t\t\t},\n+\t\t\t\t\tkey: 'test-file-id',\n+\t\t\t\t\tcollection: 'directus_files',\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tschema: mockSchema,\n+\t\t\t\t\tdatabase: mockDatabase,\n+\t\t\t\t\taccountability: null,\n+\t\t\t\t},\n+\t\t\t);\n+\t\t});\n+\t});\n+});\ndiff --git a/api/src/services/tus/server.ts b/api/src/services/tus/server.ts\nindex 657bb26878934..5d921b738b263 100644\n--- a/api/src/services/tus/server.ts\n+++ b/api/src/services/tus/server.ts\n@@ -53,7 +53,7 @@ export async function createTusServer(context: Context): Promise<[Server, () =>\n \t\tdatastore: store,\n \t\tlocker: getTusLocker(),\n \t\t...(RESUMABLE_UPLOADS.MAX_SIZE !== null && { maxSize: RESUMABLE_UPLOADS.MAX_SIZE }),\n-\t\tasync onUploadFinish(req: any, upload) {\n+\t\tasync onUploadFinish(_req: any, upload) {\n \t\t\tconst schema = await getSchema();\n \n \t\t\tconst service = new ItemsService<File>('directus_files', {\n@@ -119,9 +119,9 @@ export async function createTusServer(context: Context): Promise<[Server, () =>\n \t\t\t\t\tcollection: 'directus_files',\n \t\t\t\t},\n \t\t\t\t{\n-\t\t\t\t\tdatabase: getDatabase(),\n \t\t\t\t\tschema,\n-\t\t\t\t\taccountability: req.accountability,\n+\t\t\t\t\tdatabase: getDatabase(),\n+\t\t\t\t\taccountability: context.accountability ?? null,\n \t\t\t\t},\n \t\t\t);\n \n",
        "test_patch": "",
        "problem_statement": "## Scope\r\n\r\nWhat's changed:\r\n\r\nAfter the `@tus/server` dependency update it looks like the Directus request object no longer gets properly propagated to its callback functions.\r\n\r\n- The `createTusServer` receives the proper request object containing `accountability`, `schema` and `token` from our middleware\r\n- But the `onUploadFinish` callback however seems to be lacking our custom properties listed above\r\n\r\nTo fix this issue I am using the `context` object provided to the `createTusServer` function as the data for emitting the event instead of relying on the `req` parameter of the callback.\r\n\r\n## Potential Risks / Drawbacks\r\n\r\n- Small fix i dont see many risks\r\n\r\n## Tested Scenarios\r\n\r\n- Lorem ipsum dolor sit amet\r\n- Consectetur adipiscing elit\r\n\r\n## Review Notes / Questions\r\n\r\n- I would like to lorem ipsum\r\n- Special attention should be paid to dolor sit amet\r\n\r\n## Checklist\r\n\r\n- [x] Added or updated tests\r\n\r\n---\r\n\r\nFixes #26242\r\n",
        "hints_text": "",
        "created_at": "2025-11-24T15:00:56Z",
        "pull_number": 26247,
        "test_files": [
            "api/src/services/tus/server.test.ts"
        ],
        "code_files": [
            "api/src/services/tus/server.ts"
        ],
        "title": "Fixed missing accountability for `files.upload` when TUS is enabled",
        "additions": 0,
        "deletions": 0,
        "pr_mirror": "directus__directus.447c91d0"
    }
}