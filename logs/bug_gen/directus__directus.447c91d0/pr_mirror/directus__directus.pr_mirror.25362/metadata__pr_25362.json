{
    "cost": 0.031585,
    "rewrites": {
        "directus__directus.447c91d0/api/src/services/meta.ts": {
            "output": "import type { AbstractServiceOptions, Accountability, Query, SchemaOverview } from '@directus/types';\nimport type { Knex } from 'knex';\nimport { isArray } from 'lodash-es';\nimport { getAstFromQuery } from '../database/get-ast-from-query/get-ast-from-query.js';\nimport getDatabase from '../database/index.js';\nimport { runAst } from '../database/run-ast/run-ast.js';\nimport { processAst } from '../permissions/modules/process-ast/process-ast.js';\n\nexport class MetaService {\n\tknex: Knex;\n\taccountability: Accountability | null;\n\tschema: SchemaOverview;\n\n\tconstructor(options: AbstractServiceOptions) {\n\t\tthis.knex = options.knex || getDatabase();\n\t\tthis.accountability = options.accountability || null;\n\t\tthis.schema = options.schema;\n\t}\n\n\tasync getMetaForQuery(collection: string, query: any): Promise<Record<string, any> | undefined> {\n\t\tif (!query || !query.meta) return;\n\n\t\tconst results = await Promise.all(\n\t\t\tquery.meta.map((metaVal: string) => {\n\t\t\t\tif (metaVal === 'total_count') return this.totalCount(collection);\n\t\t\t\tif (metaVal === 'filter_count') return this.filterCount(collection, query);\n\t\t\t\treturn undefined;\n\t\t\t}),\n\t\t);\n\n\t\treturn results.reduce((metaObject: Record<string, any>, value, index) => {\n\t\t\treturn {\n\t\t\t\t...metaObject,\n\t\t\t\t[query.meta![index]]: value,\n\t\t\t};\n\t\t}, {});\n\t}\n\n\tasync totalCount(collection: string): Promise<number> {\n\t\treturn this.filterCount(collection, {});\n\t}\n\n\tasync filterCount(collection: string, query: Query): Promise<number> {\n\t\tconst primaryKeyName = this.schema.collections[collection]!.primary;\n\n\t\tconst aggregateQuery: Query = {\n\t\t\taggregate: {\n\t\t\t\tcountDistinct: [primaryKeyName],\n\t\t\t},\n\t\t\tsearch: query.search ?? null,\n\t\t\tfilter: query.filter ?? null,\n\t\t};\n\n\t\tlet ast = await getAstFromQuery(\n\t\t\t{\n\t\t\t\tcollection,\n\t\t\t\tquery: aggregateQuery,\n\t\t\t\taccountability: this.accountability,\n\t\t\t},\n\t\t\t{\n\t\t\t\tschema: this.schema,\n\t\t\t\tknex: this.knex,\n\t\t\t},\n\t\t);\n\n\t\tast = await processAst(\n\t\t\t{ ast, action: 'read', accountability: this.accountability },\n\t\t\t{ knex: this.knex, schema: this.schema },\n\t\t);\n\n\t\tconst records = await runAst(ast, this.schema, this.accountability, {\n\t\t\tknex: this.knex,\n\t\t});\n\n\t\treturn Number(\n\t\t\t(isArray(records) ? records[0]?.['countDistinct'][primaryKeyName] : records?.['countDistinct'][primaryKeyName]) ??\n\t\t\t\t0,\n\t\t);\n\t}\n}",
            "output_extracted": "import type { AbstractServiceOptions, Accountability, Query, SchemaOverview } from '@directus/types';\nimport type { Knex } from 'knex';\nimport { isArray } from 'lodash-es';\nimport { getAstFromQuery } from '../database/get-ast-from-query/get-ast-from-query.js';\nimport getDatabase from '../database/index.js';\nimport { runAst } from '../database/run-ast/run-ast.js';\nimport { processAst } from '../permissions/modules/process-ast/process-ast.js';\n\nexport class MetaService {\n\tknex: Knex;\n\taccountability: Accountability | null;\n\tschema: SchemaOverview;\n\n\tconstructor(options: AbstractServiceOptions) {\n\t\tthis.knex = options.knex || getDatabase();\n\t\tthis.accountability = options.accountability || null;\n\t\tthis.schema = options.schema;\n\t}\n\n\tasync getMetaForQuery(collection: string, query: any): Promise<Record<string, any> | undefined> {\n\t\tif (!query || !query.meta) return;\n\n\t\tconst results = await Promise.all(\n\t\t\tquery.meta.map((metaVal: string) => {\n\t\t\t\tif (metaVal === 'total_count') return this.totalCount(collection);\n\t\t\t\tif (metaVal === 'filter_count') return this.filterCount(collection, query);\n\t\t\t\treturn undefined;\n\t\t\t}),\n\t\t);\n\n\t\treturn results.reduce((metaObject: Record<string, any>, value, index) => {\n\t\t\treturn {\n\t\t\t\t...metaObject,\n\t\t\t\t[query.meta![index]]: value,\n\t\t\t};\n\t\t}, {});\n\t}\n\n\tasync totalCount(collection: string): Promise<number> {\n\t\treturn this.filterCount(collection, {});\n\t}\n\n\tasync filterCount(collection: string, query: Query): Promise<number> {\n\t\tconst primaryKeyName = this.schema.collections[collection]!.primary;\n\n\t\tconst aggregateQuery: Query = {\n\t\t\taggregate: {\n\t\t\t\tcountDistinct: [primaryKeyName],\n\t\t\t},\n\t\t\tsearch: query.search ?? null,\n\t\t\tfilter: query.filter ?? null,\n\t\t};\n\n\t\tlet ast = await getAstFromQuery(\n\t\t\t{\n\t\t\t\tcollection,\n\t\t\t\tquery: aggregateQuery,\n\t\t\t\taccountability: this.accountability,\n\t\t\t},\n\t\t\t{\n\t\t\t\tschema: this.schema,\n\t\t\t\tknex: this.knex,\n\t\t\t},\n\t\t);\n\n\t\tast = await processAst(\n\t\t\t{ ast, action: 'read', accountability: this.accountability },\n\t\t\t{ knex: this.knex, schema: this.schema },\n\t\t);\n\n\t\tconst records = await runAst(ast, this.schema, this.accountability, {\n\t\t\tknex: this.knex,\n\t\t});\n\n\t\treturn Number(\n\t\t\t(isArray(records) ? records[0]?.['countDistinct'][primaryKeyName] : records?.['countDistinct'][primaryKeyName]) ??\n\t\t\t\t0,\n\t\t);\n\t}\n}",
            "cost": 0.031585
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "directus/directus",
        "instance_id": "directus__directus.pr_mirror.25362",
        "base_commit": "68942ab8755f8d62ba508d9f22642d22bb311b84",
        "patch": "diff --git a/.changeset/fresh-rules-talk.md b/.changeset/fresh-rules-talk.md\nnew file mode 100644\nindex 0000000000000..ebeb0cafd7c9d\n--- /dev/null\n+++ b/.changeset/fresh-rules-talk.md\n@@ -0,0 +1,5 @@\n+---\n+'@directus/api': patch\n+---\n+\n+Removed implicit primaryKey permission for non relational meta queries\ndiff --git a/api/src/services/meta.test.ts b/api/src/services/meta.test.ts\nnew file mode 100644\nindex 0000000000000..7207238fc07a8\n--- /dev/null\n+++ b/api/src/services/meta.test.ts\n@@ -0,0 +1,499 @@\n+import { ForbiddenError } from '@directus/errors';\n+import { SchemaBuilder } from '@directus/schema-builder';\n+import type { Permission, Query } from '@directus/types';\n+import { knex } from 'knex';\n+import { MockClient } from 'knex-mock-client';\n+import { beforeEach, describe, expect, test, vi, type MockedFunction } from 'vitest';\n+import applyQuery from '../database/run-ast/lib/apply-query/index.js';\n+import { fetchPermissions } from '../permissions/lib/fetch-permissions.js';\n+import { fetchPolicies } from '../permissions/lib/fetch-policies.js';\n+import { getCases } from '../permissions/modules/process-ast/lib/get-cases.js';\n+import { validateAccess } from '../permissions/modules/validate-access/validate-access.js';\n+import { createDefaultAccountability } from '../permissions/utils/create-default-accountability.js';\n+import { MetaService } from './meta.js';\n+\n+vi.mock('../database/run-ast/lib/apply-query/index.js', () => ({ default: vi.fn() }));\n+\n+vi.mock('../permissions/lib/fetch-permissions.js', () => ({\n+\tfetchPermissions: vi.fn(),\n+}));\n+\n+vi.mock('../permissions/lib/fetch-policies.js', () => ({\n+\tfetchPolicies: vi.fn(),\n+}));\n+\n+vi.mock('../permissions/modules/process-ast/lib/get-cases.js', () => ({\n+\tgetCases: vi.fn(),\n+}));\n+\n+vi.mock('../permissions/modules/validate-access/validate-access.js', () => ({\n+\tvalidateAccess: vi.fn(),\n+}));\n+\n+describe('MetaService', () => {\n+\tlet db: MockedFunction<knex.Knex<any, unknown[]>>;\n+\n+\tconst mockSchema = new SchemaBuilder()\n+\t\t.collection('test_collection', (c) => {\n+\t\t\tc.field('id').id();\n+\t\t})\n+\t\t.build();\n+\n+\tbeforeEach(() => {\n+\t\tvi.clearAllMocks();\n+\n+\t\tdb = vi.mocked(knex.default({ client: MockClient }));\n+\t});\n+\n+\tdescribe('getMetaForQuery', () => {\n+\t\tlet service: MetaService;\n+\n+\t\tconst mockAccountability = createDefaultAccountability({\n+\t\t\tadmin: false,\n+\t\t});\n+\n+\t\tbeforeEach(() => {\n+\t\t\tvi.clearAllMocks();\n+\n+\t\t\tservice = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\taccountability: mockAccountability,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\t\t});\n+\n+\t\tdescribe('should return undefined when query is falsy', async () => {\n+\t\t\ttest.each([null, undefined])('%s', async () => {\n+\t\t\t\tconst result = await service.getMetaForQuery('test_collection', null);\n+\t\t\t\texpect(result).toBeUndefined();\n+\t\t\t});\n+\t\t});\n+\n+\t\ttest('should return undefined when query.meta is falsy', async () => {\n+\t\t\tconst query = { filter: { status: 'published' } };\n+\t\t\tconst result = await service.getMetaForQuery('test_collection', query);\n+\t\t\texpect(result).toBeUndefined();\n+\t\t});\n+\n+\t\ttest('should handle total_count meta value', async () => {\n+\t\t\tvi.spyOn(service, 'totalCount').mockResolvedValue(100);\n+\n+\t\t\tconst query = { meta: ['total_count'] };\n+\t\t\tconst result = await service.getMetaForQuery('test_collection', query);\n+\n+\t\t\texpect(service.totalCount).toHaveBeenCalledWith('test_collection');\n+\t\t\texpect(result).toEqual({ total_count: 100 });\n+\t\t});\n+\n+\t\ttest('should handle filter_count meta value', async () => {\n+\t\t\tvi.spyOn(service, 'filterCount').mockResolvedValue(50);\n+\n+\t\t\tconst query = { meta: ['filter_count'], filter: { status: 'published' } };\n+\t\t\tconst result = await service.getMetaForQuery('test_collection', query);\n+\n+\t\t\texpect(service.filterCount).toHaveBeenCalledWith('test_collection', query);\n+\t\t\texpect(result).toEqual({ filter_count: 50 });\n+\t\t});\n+\n+\t\ttest('should handle multiple meta values', async () => {\n+\t\t\tvi.spyOn(service, 'totalCount').mockResolvedValue(100);\n+\t\t\tvi.spyOn(service, 'filterCount').mockResolvedValue(50);\n+\n+\t\t\tconst query = { meta: ['total_count', 'filter_count'] };\n+\t\t\tconst result = await service.getMetaForQuery('test_collection', query);\n+\n+\t\t\texpect(result).toEqual({\n+\t\t\t\ttotal_count: 100,\n+\t\t\t\tfilter_count: 50,\n+\t\t\t});\n+\t\t});\n+\n+\t\ttest('should handle unknown meta values as undefined', async () => {\n+\t\t\tconst query = { meta: ['unknown_meta'] };\n+\t\t\tconst result = await service.getMetaForQuery('test_collection', query);\n+\n+\t\t\texpect(result).toEqual({ unknown_meta: undefined });\n+\t\t});\n+\n+\t\ttest('should handle mixed known and unknown meta values', async () => {\n+\t\t\tvi.spyOn(service, 'totalCount').mockResolvedValue(100);\n+\n+\t\t\tconst query = { meta: ['total_count', 'unknown_meta'] };\n+\t\t\tconst result = await service.getMetaForQuery('test_collection', query);\n+\n+\t\t\texpect(result).toEqual({\n+\t\t\t\ttotal_count: 100,\n+\t\t\t\tunknown_meta: undefined,\n+\t\t\t});\n+\t\t});\n+\t});\n+\n+\tdescribe('totalCount', () => {\n+\t\tlet service: MetaService;\n+\n+\t\tconst mockAccountability = createDefaultAccountability({\n+\t\t\tadmin: false,\n+\t\t});\n+\n+\t\tbeforeEach(() => {\n+\t\t\tvi.clearAllMocks();\n+\n+\t\t\tservice = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\taccountability: mockAccountability,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\t\t});\n+\n+\t\ttest('should call filterCount with empty query', async () => {\n+\t\t\tvi.spyOn(service, 'filterCount').mockResolvedValue(150);\n+\n+\t\t\tconst result = await service.totalCount('test_collection');\n+\n+\t\t\texpect(service.filterCount).toHaveBeenCalledWith('test_collection', {});\n+\t\t\texpect(result).toBe(150);\n+\t\t});\n+\t});\n+\n+\tdescribe('filterCount', () => {\n+\t\tconst createMockQueryBuilder = (\n+\t\t\tvalue: { count?: number | null } | { count: number | null }[] = [{ count: 10 }],\n+\t\t) => {\n+\t\t\tconst mockQueryBuilder = Promise.resolve(value) as any;\n+\t\t\tmockQueryBuilder.count = vi.fn().mockReturnValue(mockQueryBuilder);\n+\t\t\tmockQueryBuilder.countDistinct = vi.fn().mockReturnValue(mockQueryBuilder);\n+\n+\t\t\treturn mockQueryBuilder;\n+\t\t};\n+\n+\t\tbeforeEach(() => {\n+\t\t\tvi.clearAllMocks();\n+\t\t});\n+\n+\t\ttest('should handle admin user without permission checks', async () => {\n+\t\t\tconst mockAccountability = createDefaultAccountability({\n+\t\t\t\tadmin: true,\n+\t\t\t});\n+\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\taccountability: mockAccountability,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tvi.mocked(getCases).mockReturnValue({ cases: [], caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\tquery: createMockQueryBuilder() as any,\n+\t\t\t\thasJoins: false,\n+\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t});\n+\n+\t\t\tconst result = await service.filterCount('test_collection', { filter: { status: { _eq: 'published' } } });\n+\n+\t\t\texpect(validateAccess).not.toHaveBeenCalled();\n+\t\t\texpect(fetchPolicies).not.toHaveBeenCalled();\n+\t\t\texpect(fetchPermissions).not.toHaveBeenCalled();\n+\t\t\texpect(result).toBe(10);\n+\t\t});\n+\n+\t\ttest('should handle null accountability without permission checks', async () => {\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\taccountability: null,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tvi.mocked(getCases).mockReturnValue({ cases: [], caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\tquery: createMockQueryBuilder() as any,\n+\t\t\t\thasJoins: false,\n+\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t});\n+\n+\t\t\tconst result = await service.filterCount('test_collection', { filter: { status: { _eq: 'published' } } });\n+\n+\t\t\texpect(validateAccess).not.toHaveBeenCalled();\n+\t\t\texpect(fetchPolicies).not.toHaveBeenCalled();\n+\t\t\texpect(fetchPermissions).not.toHaveBeenCalled();\n+\t\t\texpect(result).toBe(10);\n+\t\t});\n+\n+\t\ttest('should perform permission checks for non-admin users', async () => {\n+\t\t\tconst mockPolicies = ['policy-1'];\n+\n+\t\t\tconst mockPermissions: Permission[] = [\n+\t\t\t\t{\n+\t\t\t\t\tid: 1,\n+\t\t\t\t\tcollection: 'test_collection',\n+\t\t\t\t\taction: 'read',\n+\t\t\t\t\tpermissions: {},\n+\t\t\t\t\tvalidation: {},\n+\t\t\t\t\tpresets: {},\n+\t\t\t\t\tfields: ['*'],\n+\t\t\t\t\tpolicy: 'policy-1',\n+\t\t\t\t},\n+\t\t\t];\n+\n+\t\t\tconst mockAccountability = createDefaultAccountability({\n+\t\t\t\tadmin: false,\n+\t\t\t});\n+\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\taccountability: mockAccountability,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tvi.mocked(validateAccess).mockResolvedValue(undefined);\n+\t\t\tvi.mocked(fetchPolicies).mockResolvedValue(mockPolicies);\n+\t\t\tvi.mocked(fetchPermissions).mockResolvedValue(mockPermissions);\n+\n+\t\t\tvi.mocked(getCases).mockReturnValue({ cases: [], caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\tquery: createMockQueryBuilder() as any,\n+\t\t\t\thasJoins: false,\n+\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t});\n+\n+\t\t\tconst result = await service.filterCount('test_collection', { filter: { status: { _eq: 'published' } } });\n+\n+\t\t\texpect(validateAccess).toHaveBeenCalledWith(\n+\t\t\t\t{\n+\t\t\t\t\taccountability: mockAccountability,\n+\t\t\t\t\taction: 'read',\n+\t\t\t\t\tcollection: 'test_collection',\n+\t\t\t\t},\n+\t\t\t\t{ knex: db, schema: mockSchema },\n+\t\t\t);\n+\n+\t\t\texpect(fetchPolicies).toHaveBeenCalledWith(mockAccountability, { knex: db, schema: mockSchema });\n+\n+\t\t\texpect(fetchPermissions).toHaveBeenCalledWith(\n+\t\t\t\t{ action: 'read', accountability: mockAccountability, policies: mockPolicies },\n+\t\t\t\t{ knex: db, schema: mockSchema },\n+\t\t\t);\n+\n+\t\t\texpect(result).toBe(10);\n+\t\t});\n+\n+\t\ttest('should propagate validateAccess errors', async () => {\n+\t\t\tconst mockAccountability = createDefaultAccountability({ admin: false });\n+\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\taccountability: mockAccountability,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tconst mockError = new ForbiddenError({ reason: 'No access' });\n+\t\t\tvi.mocked(validateAccess).mockRejectedValue(mockError);\n+\n+\t\t\tawait expect(service.filterCount('test_collection', {})).rejects.toThrow(mockError);\n+\n+\t\t\texpect(fetchPolicies).not.toHaveBeenCalled();\n+\t\t\texpect(applyQuery).not.toHaveBeenCalled();\n+\t\t});\n+\n+\t\ttest('should use countDistinct when query has joins', async () => {\n+\t\t\tvi.mocked(getCases).mockReturnValue({ cases: [], caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\tconst mockQueryBuilder = createMockQueryBuilder();\n+\n+\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\tquery: mockQueryBuilder,\n+\t\t\t\thasJoins: true,\n+\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t});\n+\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tconst result = await service.filterCount('test_collection', { filter: { status: { _eq: 'published' } } });\n+\n+\t\t\texpect(mockQueryBuilder.countDistinct).toHaveBeenCalledWith({\n+\t\t\t\tcount: ['test_collection.id'],\n+\t\t\t});\n+\n+\t\t\texpect(mockQueryBuilder.count).not.toHaveBeenCalled();\n+\t\t\texpect(result).toBe(10);\n+\t\t});\n+\n+\t\ttest('should use regular count when query has no joins', async () => {\n+\t\t\tvi.mocked(getCases).mockReturnValue({ cases: [], caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\tconst mockQueryBuilder = createMockQueryBuilder();\n+\n+\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\tquery: mockQueryBuilder,\n+\t\t\t\thasJoins: false,\n+\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t});\n+\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tconst result = await service.filterCount('test_collection', { filter: { status: { _eq: 'published' } } });\n+\n+\t\t\texpect(mockQueryBuilder.count).toHaveBeenCalledWith('*', { as: 'count' });\n+\t\t\texpect(mockQueryBuilder.countDistinct).not.toHaveBeenCalled();\n+\t\t\texpect(result).toBe(10);\n+\t\t});\n+\n+\t\ttest('should handle array result from database', async () => {\n+\t\t\tvi.mocked(getCases).mockReturnValue({ cases: [], caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\tconst mockQueryBuilder = createMockQueryBuilder([{ count: 15 }]);\n+\n+\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\tquery: mockQueryBuilder,\n+\t\t\t\thasJoins: true,\n+\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t});\n+\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tconst result = await service.filterCount('test_collection', { filter: { status: { _eq: 'published' } } });\n+\t\t\texpect(result).toBe(15);\n+\t\t});\n+\n+\t\ttest('should handle non-array result from database', async () => {\n+\t\t\tvi.mocked(getCases).mockReturnValue({ cases: [], caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\tconst mockQueryBuilder = createMockQueryBuilder({ count: 30 });\n+\n+\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\tquery: mockQueryBuilder as any,\n+\t\t\t\thasJoins: false,\n+\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t});\n+\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tconst result = await service.filterCount('test_collection', { filter: { status: { _eq: 'published' } } });\n+\t\t\texpect(result).toBe(30);\n+\t\t});\n+\n+\t\tdescribe('should return 0 when count is null or undefined', () => {\n+\t\t\ttest.each([0, null])('%s', async (count) => {\n+\t\t\t\tvi.mocked(getCases).mockReturnValue({ cases: [], caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\t\tconst mockQueryBuilder = createMockQueryBuilder({ count });\n+\n+\t\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\t\tquery: mockQueryBuilder as any,\n+\t\t\t\t\thasJoins: false,\n+\t\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t\t});\n+\n+\t\t\t\tconst service = new MetaService({\n+\t\t\t\t\tknex: db,\n+\t\t\t\t\tschema: mockSchema,\n+\t\t\t\t});\n+\n+\t\t\t\tconst result = await service.filterCount('test_collection', {});\n+\t\t\t\texpect(result).toBe(0);\n+\t\t\t});\n+\t\t});\n+\n+\t\ttest('should handle empty array result', async () => {\n+\t\t\tvi.mocked(getCases).mockReturnValue({ cases: [], caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\tconst mockQueryBuilder = createMockQueryBuilder([]);\n+\n+\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\tquery: mockQueryBuilder as any,\n+\t\t\t\thasJoins: true,\n+\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t});\n+\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tconst result = await service.filterCount('test_collection', {});\n+\t\t\texpect(result).toBe(0);\n+\t\t});\n+\n+\t\ttest('should pass correct parameters to applyQuery', async () => {\n+\t\t\tconst mockCases = [{}];\n+\n+\t\t\tvi.mocked(getCases).mockReturnValue({ cases: mockCases, caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\tconst mockQueryBuilder = createMockQueryBuilder();\n+\n+\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\tquery: mockQueryBuilder,\n+\t\t\t\thasJoins: false,\n+\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t});\n+\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tconst query: Query = {\n+\t\t\t\tfilter: { status: { _eq: 'published' } },\n+\t\t\t\tsearch: 'test search',\n+\t\t\t};\n+\n+\t\t\tawait service.filterCount('test_collection', query);\n+\n+\t\t\texpect(applyQuery).toHaveBeenCalledWith(\n+\t\t\t\tdb,\n+\t\t\t\t'test_collection',\n+\t\t\t\tdb('test_collection'),\n+\t\t\t\tquery,\n+\t\t\t\tmockSchema,\n+\t\t\t\tmockCases,\n+\t\t\t\t[],\n+\t\t\t);\n+\t\t});\n+\n+\t\ttest('should handle query with null filter and search', async () => {\n+\t\t\tvi.mocked(getCases).mockReturnValue({ cases: [], caseMap: {}, allowedFields: new Set() });\n+\n+\t\t\tconst mockQueryBuilder = createMockQueryBuilder();\n+\n+\t\t\tvi.mocked(applyQuery).mockReturnValue({\n+\t\t\t\tquery: mockQueryBuilder,\n+\t\t\t\thasJoins: false,\n+\t\t\t\thasMultiRelationalFilter: false,\n+\t\t\t});\n+\n+\t\t\tconst service = new MetaService({\n+\t\t\t\tknex: db,\n+\t\t\t\tschema: mockSchema,\n+\t\t\t});\n+\n+\t\t\tawait service.filterCount('test_collection', {});\n+\n+\t\t\texpect(applyQuery).toHaveBeenCalledWith(\n+\t\t\t\tdb,\n+\t\t\t\t'test_collection',\n+\t\t\t\tdb('test_collection'),\n+\t\t\t\t{\n+\t\t\t\t\tfilter: null,\n+\t\t\t\t\tsearch: null,\n+\t\t\t\t},\n+\t\t\t\tmockSchema,\n+\t\t\t\t[],\n+\t\t\t\t[],\n+\t\t\t);\n+\t\t});\n+\t});\n+});\ndiff --git a/api/src/services/meta.ts b/api/src/services/meta.ts\nindex 4be6ffa2ca2c3..fc06975a7cca0 100644\n--- a/api/src/services/meta.ts\n+++ b/api/src/services/meta.ts\n@@ -1,10 +1,12 @@\n-import type { AbstractServiceOptions, Accountability, Query, SchemaOverview } from '@directus/types';\n+import type { AbstractServiceOptions, Accountability, Permission, Query, SchemaOverview } from '@directus/types';\n import type { Knex } from 'knex';\n import { isArray } from 'lodash-es';\n-import { getAstFromQuery } from '../database/get-ast-from-query/get-ast-from-query.js';\n import getDatabase from '../database/index.js';\n-import { runAst } from '../database/run-ast/run-ast.js';\n-import { processAst } from '../permissions/modules/process-ast/process-ast.js';\n+import applyQuery from '../database/run-ast/lib/apply-query/index.js';\n+import { fetchPermissions } from '../permissions/lib/fetch-permissions.js';\n+import { fetchPolicies } from '../permissions/lib/fetch-policies.js';\n+import { getCases } from '../permissions/modules/process-ast/lib/get-cases.js';\n+import { validateAccess } from '../permissions/modules/validate-access/validate-access.js';\n \n export class MetaService {\n \tknex: Knex;\n@@ -41,40 +43,48 @@ export class MetaService {\n \t}\n \n \tasync filterCount(collection: string, query: Query): Promise<number> {\n-\t\tconst primaryKeyName = this.schema.collections[collection]!.primary;\n+\t\tlet permissions: Permission[] = [];\n \n-\t\tconst aggregateQuery: Query = {\n-\t\t\taggregate: {\n-\t\t\t\tcountDistinct: [primaryKeyName],\n-\t\t\t},\n-\t\t\tsearch: query.search ?? null,\n-\t\t\tfilter: query.filter ?? null,\n-\t\t};\n+\t\tif (this.accountability && this.accountability.admin !== true) {\n+\t\t\tconst context = { knex: this.knex, schema: this.schema };\n \n-\t\tlet ast = await getAstFromQuery(\n-\t\t\t{\n-\t\t\t\tcollection,\n-\t\t\t\tquery: aggregateQuery,\n-\t\t\t\taccountability: this.accountability,\n-\t\t\t},\n+\t\t\tawait validateAccess(\n+\t\t\t\t{\n+\t\t\t\t\taccountability: this.accountability,\n+\t\t\t\t\taction: 'read',\n+\t\t\t\t\tcollection,\n+\t\t\t\t},\n+\t\t\t\tcontext,\n+\t\t\t);\n+\n+\t\t\tconst policies = await fetchPolicies(this.accountability, context);\n+\n+\t\t\tpermissions = await fetchPermissions({ action: 'read', accountability: this.accountability, policies }, context);\n+\t\t}\n+\n+\t\tconst { cases } = getCases(collection, permissions, []);\n+\n+\t\tconst { query: dbQuery, hasJoins } = applyQuery(\n+\t\t\tthis.knex,\n+\t\t\tcollection,\n+\t\t\tthis.knex(collection),\n \t\t\t{\n-\t\t\t\tschema: this.schema,\n-\t\t\t\tknex: this.knex,\n+\t\t\t\tfilter: query.filter ?? null,\n+\t\t\t\tsearch: query.search ?? null,\n \t\t\t},\n+\t\t\tthis.schema,\n+\t\t\tcases,\n+\t\t\tpermissions,\n \t\t);\n \n-\t\tast = await processAst(\n-\t\t\t{ ast, action: 'read', accountability: this.accountability },\n-\t\t\t{ knex: this.knex, schema: this.schema },\n-\t\t);\n+\t\tif (hasJoins) {\n+\t\t\tdbQuery.countDistinct({ count: [`${collection}.${this.schema.collections[collection]!.primary}`] });\n+\t\t} else {\n+\t\t\tdbQuery.count('*', { as: 'count' });\n+\t\t}\n \n-\t\tconst records = await runAst(ast, this.schema, this.accountability, {\n-\t\t\tknex: this.knex,\n-\t\t});\n+\t\tconst records = await dbQuery;\n \n-\t\treturn Number(\n-\t\t\t(isArray(records) ? records[0]?.['countDistinct'][primaryKeyName] : records?.['countDistinct'][primaryKeyName]) ??\n-\t\t\t\t0,\n-\t\t);\n+\t\treturn Number((isArray(records) ? records[0]?.['count'] : records?.['count']) ?? 0);\n \t}\n }\n",
        "test_patch": "",
        "problem_statement": "<!--\r\n\r\nHeya! Thanks for opening a Pull Request! If your PR is implementing a new feature or fix for Directus, please make sure your PR adheres to the following requirements:\r\n\r\n- The PR closes an Issue (not Discussion)\r\n- Tests are added/updated and are passing locally if applicable\r\n- Documentation was added/updated if applicable\r\n\r\nPlease make sure to \"Link\" the issue you're closing. Without a Linked issue, this PR won't be accepted. See https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue for more information.\r\n\r\n-->\r\n\r\n## Scope\r\n\r\nWhat's changed:\r\n\r\n- Permissions to `read` on `primaryKey` is no longer required for non relational counts\r\n\r\n## Potential Risks / Drawbacks\r\n\r\n- None that I am aware of\r\n\r\n## Review Notes / Questions\r\n\r\n- I have tested all cases I could think of (listed below), please test any additional cases that may have been missed.\r\n- Do we want to check field permissions in filters as well and error if no access? Currently the no permission returns 0 results which is what we had previously.\r\n\r\n### Tests\r\n- db: `pg`\r\n#### Setup\r\n- Create an ingredient collection with a name field\r\n- Create a food collection with a name field and an ingredients field that is `m2m` to ingredient\r\n- Add 2 food records, one with 1 ingredient sub record and one with 2\r\n\r\n#### Setup Data\r\n\r\n##### Foods\r\n```csv\r\n\"id\",\"name\"\r\n1,\"Food 1\"\r\n2,\"Food 2\"\r\n```\r\n##### Ingredients\r\n```csv\r\n\"id\",\"name\"\r\n1,\"Ingredient 1\"\r\n2,\"Ingredient 2\"\r\n3,\"Ingredient 3\"\r\n```\r\n#### Cases\r\n- [x]  Expect `total_count` to return correctly with no filter\r\n   - `/items/food?meta=total_count`\r\n- [x]  Expect `filter_count` to return correctly with no filter\r\n   - `/items/food?meta=filter_count`\r\n- [x]  Expect `total_count` to return correctly for non relational filter\r\n   - `/items/food?filter[name][_contains]=2&meta=total_count`\r\n- [x]  Expect `filter_count` to return correctly for non relational filter\r\n   - `/items/food?filter[name][_contains]=2&meta=filter_count`\r\n- [x]  Expect `total_count` to return correctly for relational filter\r\n   - `/items/food?filter[ingredients][ingredient_id][name][_contains]=2&meta=total_count`\r\n- [x]  Expect `filter_count` to return correctly for relational filter\r\n   - `/items/food?filter[ingredients][ingredient_id][name][_contains]=2&meta=total_count`\r\n- [x] Expect `total_count` & `filter_count` to return correctly with no filter with `search`\r\n  - `/items/food?search=2&meta=total_count,filter_count`\r\n- [x] Expect `total_count` & `filter_count` to return correctly for non relational filter with `search`\r\n   - `/items/food?filter[name][_contains]=2&search=2&meta=total_count,filter_count`\r\n- [x] Expect `total_count` & `filter_count` to return correctly for relational filter with `search`\r\n   - `/items/food?filter[ingredients][ingredient_id][name][_contains]=2&search=2&meta=total_count,filter_count` \r\n- [x] Expect `search` to respect field permissions for `total_count` & `filter_count`\r\n   - Removed `read` for `food.name`\r\n   -  `/items/food?filter[id][_eq]=2&search=food&meta=total_count,filter_count`\r\n\r\n\r\n---\r\n\r\nFixes #25212\r\n",
        "hints_text": "",
        "created_at": "2025-06-26T12:50:42Z",
        "pull_number": 25362,
        "test_files": [
            "api/src/services/meta.test.ts"
        ],
        "code_files": [
            "api/src/services/meta.ts"
        ],
        "title": "Remove implicit primaryKey permission for non relational meta queries",
        "additions": 0,
        "deletions": 0,
        "pr_mirror": "directus__directus.447c91d0"
    }
}