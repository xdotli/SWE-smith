{
    "cost": 0.17029500000000003,
    "rewrites": {
        "directus__directus.447c91d0/app/src/components/v-input.test.ts": {
            "output": "import { Focus } from '@/__utils__/focus';\nimport type { GlobalMountOptions } from '@/__utils__/types';\nimport { i18n } from '@/lang';\nimport { mount } from '@vue/test-utils';\nimport { afterEach, describe, expect, test, vi } from 'vitest';\nimport VInput from './v-input.vue';\n\nconst global: GlobalMountOptions = {\n\tstubs: ['v-icon'],\n\tplugins: [i18n],\n\tdirectives: {\n\t\tfocus: Focus,\n\t},\n};\n\ntest('Mount component', () => {\n\texpect(VInput).toBeTruthy();\n\n\tconst wrapper = mount(VInput, {\n\t\tglobal,\n\t});\n\n\texpect(wrapper.html()).toMatchSnapshot();\n});\n\ntest('modelValue prop', async () => {\n\tconst wrapper = mount(VInput, {\n\t\tprops: {\n\t\t\tmodelValue: 'my value',\n\t\t},\n\t\tglobal,\n\t});\n\n\texpect(wrapper.get('input').element.value).toBe('my value');\n\n\tawait wrapper.find('input').setValue('my value1');\n\n\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['my value1']);\n});\n\ntest('modelValue trim', async () => {\n\tconst wrapper = mount(VInput, {\n\t\tprops: {\n\t\t\tmodelValue: '  please trim that beard    ',\n\t\t\ttrim: true,\n\t\t},\n\t\tglobal,\n\t});\n\n\tawait wrapper.find('input').trigger('blur');\n\n\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['please trim that beard']);\n});\n\ntest('modelValue dbSafe', async () => {\n\tconst wrapper = mount(VInput, {\n\t\tprops: {\n\t\t\tmodelValue: 'this $hould be D\u00df save!!',\n\t\t\tdbSafe: true,\n\t\t},\n\t\tglobal,\n\t});\n\n\tawait wrapper.find('input').trigger('input');\n\n\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['this_hould_be_D_save']);\n});\n\ndescribe('processValue', () => {\n\tconst commonTestScenarios = [\n\t\t{\n\t\t\tscenario: 'should allow slug safe characters',\n\t\t\tevent: { key: 'a' },\n\t\t\tshouldDefaultPrevented: false,\n\t\t},\n\t\t{\n\t\t\tscenario: 'should not allow non slug safe characters',\n\t\t\tevent: { key: '$' },\n\t\t\tshouldDefaultPrevented: true,\n\t\t},\n\t\t{\n\t\t\tscenario: 'should allow system keys',\n\t\t\tevent: { key: 'Control' }, // also tests whether \"Control\" is mapped to \"meta\"\n\t\t\tshouldDefaultPrevented: false,\n\t\t},\n\t\t{\n\t\t\tscenario: 'should allow arrow keys',\n\t\t\tevent: { key: 'ArrowUp' },\n\t\t\tshouldDefaultPrevented: false,\n\t\t},\n\t];\n\n\ttest.each([\n\t\t...commonTestScenarios,\n\t\t{\n\t\t\tscenario: 'should not allow trailing space after the slug separator',\n\t\t\tevent: { key: ' ' },\n\t\t\tshouldDefaultPrevented: true,\n\t\t},\n\t])('slug input %scenario', async ({ event, shouldDefaultPrevented }) => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\t// default slug separator to test the \"should not allow trailing space after slug separator\" scenario\n\t\t\t\tmodelValue: '-',\n\t\t\t\tslug: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tconst input = wrapper.find('input');\n\n\t\tawait input.trigger('keydown', event);\n\n\t\tconst keyboardEvent = wrapper.emitted('keydown')?.[0]?.[0] as KeyboardEvent;\n\n\t\texpect(keyboardEvent.defaultPrevented).toBe(shouldDefaultPrevented);\n\t});\n\n\ttest.each([\n\t\t...commonTestScenarios,\n\t\t{\n\t\t\tscenario: 'should allow system key combinations with number when entering the first character',\n\t\t\tevent: { key: '1', shiftKey: true },\n\t\t\tshouldDefaultPrevented: false,\n\t\t},\n\t\t{\n\t\t\tscenario: 'should not allow number when entering the first character',\n\t\t\tevent: { key: '1' },\n\t\t\tshouldDefaultPrevented: true,\n\t\t},\n\t])('dbSafe input %scenario', async ({ event, shouldDefaultPrevented }) => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tdbSafe: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tconst input = wrapper.find('input');\n\n\t\tawait input.trigger('keydown', event);\n\n\t\tconst keyboardEvent = wrapper.emitted('keydown')?.[0]?.[0] as KeyboardEvent;\n\n\t\texpect(keyboardEvent.defaultPrevented).toBe(shouldDefaultPrevented);\n\t});\n});\n\ndescribe('emitValue', () => {\n\ttest('should emit null value when empty', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tmodelValue: '',\n\t\t\t\tnullable: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual([null]);\n\t});\n\n\ttest('should emit number when type is number', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\ttype: 'number',\n\t\t\t\tmodelValue: '1',\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual([1]);\n\t});\n\n\ttest('should replace \",\" with \".\" for decimal separator when decimal types marked as text', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\ttype: 'text',\n\t\t\t\tmodelValue: '1,22',\n\t\t\t\tfloat: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['1.22']);\n\t});\n\n\ttest('should emit number without a thousandths separator', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\ttype: 'text',\n\t\t\t\tmodelValue: '1,222,220',\n\t\t\t\tfloat: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['1.222220']);\n\t});\n\n\ttest('should turn ending space into slug separator for slug input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tmodelValue: 'test ',\n\t\t\t\tslug: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['test-']);\n\t});\n\n\ttest('should turn space into underscores for dbSafe input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tmodelValue: 'a custom field',\n\t\t\t\tdbSafe: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['a_custom_field']);\n\t});\n\n\ttest('should prevent pasting of non db safe characters for dbSafe input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tmodelValue: '$test_field',\n\t\t\t\tdbSafe: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['test_field']);\n\t});\n\n\ttest('should normalize accented characters for dbSafe input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tmodelValue: '\u00e0_test_field',\n\t\t\t\tdbSafe: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['a_test_field']);\n\t});\n});\n\ndescribe('invalid warning', () => {\n\tafterEach(() => {\n\t\tvi.restoreAllMocks();\n\t});\n\n\tconst validityMock: ValidityState = {\n\t\tbadInput: false,\n\t\tcustomError: false,\n\t\tpatternMismatch: false,\n\t\trangeOverflow: false,\n\t\trangeUnderflow: false,\n\t\tstepMismatch: false,\n\t\ttooLong: false,\n\t\ttooShort: false,\n\t\ttypeMismatch: false,\n\t\tvalid: true,\n\t\tvalueMissing: false,\n\t};\n\n\ttest('should appear for invalid input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\ttype: 'number',\n\t\t\t\tinteger: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tconst input = wrapper.find('input');\n\t\tconst inputEl = input.element as HTMLInputElement;\n\t\tconst validitySpy = vi.spyOn(inputEl, 'validity', 'get').mockReturnValue({ ...validityMock, badInput: true });\n\n\t\texpect(inputEl.validity.badInput).toBe(true);\n\t\texpect((wrapper.vm as any).isInvalidInput).toBe(false);\n\n\t\tawait input.trigger('input');\n\t\tawait wrapper.vm.$nextTick();\n\n\t\texpect((wrapper.vm as any).isInvalidInput).toBe(true);\n\t\texpect(wrapper.find('.v-input.invalid').exists()).toBe(true);\n\t\texpect(wrapper.find('v-icon-stub.warning-invalid').exists()).toBe(true);\n\t\texpect(validitySpy).toHaveBeenCalledTimes(2);\n\n\t\texpect(wrapper.html()).toMatchSnapshot();\n\t});\n\n\ttest('should not appear for valid input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\ttype: 'number',\n\t\t\t\tinteger: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tconst input = wrapper.find('input');\n\t\tconst inputEl = input.element as HTMLInputElement;\n\t\tconst validitySpy = vi.spyOn(inputEl, 'validity', 'get').mockReturnValue(validityMock);\n\n\t\texpect(inputEl.validity.badInput).toBe(false);\n\t\texpect((wrapper.vm as any).isInvalidInput).toBe(false);\n\n\t\tawait input.trigger('input');\n\t\tawait wrapper.vm.$nextTick();\n\n\t\texpect((wrapper.vm as any).isInvalidInput).toBe(false);\n\t\texpect(wrapper.find('.v-input.invalid').exists()).toBe(false);\n\t\texpect(wrapper.find('v-icon-stub.warning-invalid').exists()).toBe(false);\n\t\texpect(validitySpy).toHaveBeenCalledTimes(2);\n\n\t\texpect(wrapper.html()).toMatchSnapshot();\n\t});\n});",
            "output_extracted": "import { Focus } from '@/__utils__/focus';\nimport type { GlobalMountOptions } from '@/__utils__/types';\nimport { i18n } from '@/lang';\nimport { mount } from '@vue/test-utils';\nimport { afterEach, describe, expect, test, vi } from 'vitest';\nimport VInput from './v-input.vue';\n\nconst global: GlobalMountOptions = {\n\tstubs: ['v-icon'],\n\tplugins: [i18n],\n\tdirectives: {\n\t\tfocus: Focus,\n\t},\n};\n\ntest('Mount component', () => {\n\texpect(VInput).toBeTruthy();\n\n\tconst wrapper = mount(VInput, {\n\t\tglobal,\n\t});\n\n\texpect(wrapper.html()).toMatchSnapshot();\n});\n\ntest('modelValue prop', async () => {\n\tconst wrapper = mount(VInput, {\n\t\tprops: {\n\t\t\tmodelValue: 'my value',\n\t\t},\n\t\tglobal,\n\t});\n\n\texpect(wrapper.get('input').element.value).toBe('my value');\n\n\tawait wrapper.find('input').setValue('my value1');\n\n\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['my value1']);\n});\n\ntest('modelValue trim', async () => {\n\tconst wrapper = mount(VInput, {\n\t\tprops: {\n\t\t\tmodelValue: '  please trim that beard    ',\n\t\t\ttrim: true,\n\t\t},\n\t\tglobal,\n\t});\n\n\tawait wrapper.find('input').trigger('blur');\n\n\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['please trim that beard']);\n});\n\ntest('modelValue dbSafe', async () => {\n\tconst wrapper = mount(VInput, {\n\t\tprops: {\n\t\t\tmodelValue: 'this $hould be D\u00df save!!',\n\t\t\tdbSafe: true,\n\t\t},\n\t\tglobal,\n\t});\n\n\tawait wrapper.find('input').trigger('input');\n\n\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['this_hould_be_D_save']);\n});\n\ndescribe('processValue', () => {\n\tconst commonTestScenarios = [\n\t\t{\n\t\t\tscenario: 'should allow slug safe characters',\n\t\t\tevent: { key: 'a' },\n\t\t\tshouldDefaultPrevented: false,\n\t\t},\n\t\t{\n\t\t\tscenario: 'should not allow non slug safe characters',\n\t\t\tevent: { key: '$' },\n\t\t\tshouldDefaultPrevented: true,\n\t\t},\n\t\t{\n\t\t\tscenario: 'should allow system keys',\n\t\t\tevent: { key: 'Control' }, // also tests whether \"Control\" is mapped to \"meta\"\n\t\t\tshouldDefaultPrevented: false,\n\t\t},\n\t\t{\n\t\t\tscenario: 'should allow arrow keys',\n\t\t\tevent: { key: 'ArrowUp' },\n\t\t\tshouldDefaultPrevented: false,\n\t\t},\n\t];\n\n\ttest.each([\n\t\t...commonTestScenarios,\n\t\t{\n\t\t\tscenario: 'should not allow trailing space after the slug separator',\n\t\t\tevent: { key: ' ' },\n\t\t\tshouldDefaultPrevented: true,\n\t\t},\n\t])('slug input %scenario', async ({ event, shouldDefaultPrevented }) => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\t// default slug separator to test the \"should not allow trailing space after slug separator\" scenario\n\t\t\t\tmodelValue: '-',\n\t\t\t\tslug: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tconst input = wrapper.find('input');\n\n\t\tawait input.trigger('keydown', event);\n\n\t\tconst keyboardEvent = wrapper.emitted('keydown')?.[0]?.[0] as KeyboardEvent;\n\n\t\texpect(keyboardEvent.defaultPrevented).toBe(shouldDefaultPrevented);\n\t});\n\n\ttest.each([\n\t\t...commonTestScenarios,\n\t\t{\n\t\t\tscenario: 'should allow system key combinations with number when entering the first character',\n\t\t\tevent: { key: '1', shiftKey: true },\n\t\t\tshouldDefaultPrevented: false,\n\t\t},\n\t\t{\n\t\t\tscenario: 'should not allow number when entering the first character',\n\t\t\tevent: { key: '1' },\n\t\t\tshouldDefaultPrevented: true,\n\t\t},\n\t])('dbSafe input %scenario', async ({ event, shouldDefaultPrevented }) => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tdbSafe: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tconst input = wrapper.find('input');\n\n\t\tawait input.trigger('keydown', event);\n\n\t\tconst keyboardEvent = wrapper.emitted('keydown')?.[0]?.[0] as KeyboardEvent;\n\n\t\texpect(keyboardEvent.defaultPrevented).toBe(shouldDefaultPrevented);\n\t});\n});\n\ndescribe('emitValue', () => {\n\ttest('should emit null value when empty', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tmodelValue: '',\n\t\t\t\tnullable: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual([null]);\n\t});\n\n\ttest('should emit number when type is number', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\ttype: 'number',\n\t\t\t\tmodelValue: '1',\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual([1]);\n\t});\n\n\ttest('should replace \",\" with \".\" for decimal separator when decimal types marked as text', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\ttype: 'text',\n\t\t\t\tmodelValue: '1,22',\n\t\t\t\tfloat: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['1.22']);\n\t});\n\n\ttest('should emit number without a thousandths separator', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\ttype: 'text',\n\t\t\t\tmodelValue: '1,222,220',\n\t\t\t\tfloat: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['1.222220']);\n\t});\n\n\ttest('should turn ending space into slug separator for slug input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tmodelValue: 'test ',\n\t\t\t\tslug: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['test-']);\n\t});\n\n\ttest('should turn space into underscores for dbSafe input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tmodelValue: 'a custom field',\n\t\t\t\tdbSafe: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['a_custom_field']);\n\t});\n\n\ttest('should prevent pasting of non db safe characters for dbSafe input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tmodelValue: '$test_field',\n\t\t\t\tdbSafe: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['test_field']);\n\t});\n\n\ttest('should normalize accented characters for dbSafe input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\tmodelValue: '\u00e0_test_field',\n\t\t\t\tdbSafe: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tawait wrapper.find('input').trigger('input');\n\n\t\texpect(wrapper.emitted()['update:modelValue']?.[0]).toEqual(['a_test_field']);\n\t});\n});\n\ndescribe('invalid warning', () => {\n\tafterEach(() => {\n\t\tvi.restoreAllMocks();\n\t});\n\n\tconst validityMock: ValidityState = {\n\t\tbadInput: false,\n\t\tcustomError: false,\n\t\tpatternMismatch: false,\n\t\trangeOverflow: false,\n\t\trangeUnderflow: false,\n\t\tstepMismatch: false,\n\t\ttooLong: false,\n\t\ttooShort: false,\n\t\ttypeMismatch: false,\n\t\tvalid: true,\n\t\tvalueMissing: false,\n\t};\n\n\ttest('should appear for invalid input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\ttype: 'number',\n\t\t\t\tinteger: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tconst input = wrapper.find('input');\n\t\tconst inputEl = input.element as HTMLInputElement;\n\t\tconst validitySpy = vi.spyOn(inputEl, 'validity', 'get').mockReturnValue({ ...validityMock, badInput: true });\n\n\t\texpect(inputEl.validity.badInput).toBe(true);\n\t\texpect((wrapper.vm as any).isInvalidInput).toBe(false);\n\n\t\tawait input.trigger('input');\n\t\tawait wrapper.vm.$nextTick();\n\n\t\texpect((wrapper.vm as any).isInvalidInput).toBe(true);\n\t\texpect(wrapper.find('.v-input.invalid').exists()).toBe(true);\n\t\texpect(wrapper.find('v-icon-stub.warning-invalid').exists()).toBe(true);\n\t\texpect(validitySpy).toHaveBeenCalledTimes(2);\n\n\t\texpect(wrapper.html()).toMatchSnapshot();\n\t});\n\n\ttest('should not appear for valid input', async () => {\n\t\tconst wrapper = mount(VInput, {\n\t\t\tprops: {\n\t\t\t\ttype: 'number',\n\t\t\t\tinteger: true,\n\t\t\t},\n\t\t\tglobal,\n\t\t});\n\n\t\tconst input = wrapper.find('input');\n\t\tconst inputEl = input.element as HTMLInputElement;\n\t\tconst validitySpy = vi.spyOn(inputEl, 'validity', 'get').mockReturnValue(validityMock);\n\n\t\texpect(inputEl.validity.badInput).toBe(false);\n\t\texpect((wrapper.vm as any).isInvalidInput).toBe(false);\n\n\t\tawait input.trigger('input');\n\t\tawait wrapper.vm.$nextTick();\n\n\t\texpect((wrapper.vm as any).isInvalidInput).toBe(false);\n\t\texpect(wrapper.find('.v-input.invalid').exists()).toBe(false);\n\t\texpect(wrapper.find('v-icon-stub.warning-invalid').exists()).toBe(false);\n\t\texpect(validitySpy).toHaveBeenCalledTimes(2);\n\n\t\texpect(wrapper.html()).toMatchSnapshot();\n\t});\n});",
            "cost": 0.11441000000000001
        },
        "directus__directus.447c91d0/app/src/interfaces/input/index.ts": {
            "output": "import { DeepPartial, Field } from '@directus/types';\nimport { defineInterface } from '@directus/extensions';\nimport { APP_NUMERIC_TYPES } from '@/constants';\nimport InterfaceInput from './input.vue';\nimport PreviewSVG from './preview.svg?raw';\n\nexport default defineInterface({\n\tid: 'input',\n\tname: '$t:interfaces.input.input',\n\tdescription: '$t:interfaces.input.description',\n\ticon: 'text_fields',\n\tcomponent: InterfaceInput,\n\ttypes: ['string', 'uuid', 'bigInteger', 'integer', 'float', 'decimal', 'text'],\n\tgroup: 'standard',\n\toptions: ({ field }) => {\n\t\tconst textOptions: { standard: DeepPartial<Field>[]; advanced: DeepPartial<Field>[] } = {\n\t\t\tstandard: [\n\t\t\t\t{\n\t\t\t\t\tfield: 'placeholder',\n\t\t\t\t\tname: '$t:placeholder',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'full',\n\t\t\t\t\t\tinterface: 'system-input-translated-string',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tplaceholder: '$t:enter_a_placeholder',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'iconLeft',\n\t\t\t\t\tname: '$t:icon_left',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'select-icon',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'iconRight',\n\t\t\t\t\tname: '$t:icon_right',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'select-icon',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tadvanced: [\n\t\t\t\t{\n\t\t\t\t\tfield: 'softLength',\n\t\t\t\t\tname: '$t:soft_length',\n\t\t\t\t\ttype: 'integer',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'input',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tplaceholder: '255',\n\t\t\t\t\t\t\tmin: 1,\n\t\t\t\t\t\t\tmax: field.schema?.max_length,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'font',\n\t\t\t\t\tname: '$t:font',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'select-dropdown',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tchoices: [\n\t\t\t\t\t\t\t\t{ text: '$t:sans_serif', value: 'sans-serif' },\n\t\t\t\t\t\t\t\t{ text: '$t:monospace', value: 'monospace' },\n\t\t\t\t\t\t\t\t{ text: '$t:serif', value: 'serif' },\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tdefault_value: 'sans-serif',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'trim',\n\t\t\t\t\tname: '$t:interfaces.input.trim',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'boolean',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tlabel: '$t:interfaces.input.trim_label',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tdefault_value: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'masked',\n\t\t\t\t\tname: '$t:interfaces.input.mask',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'boolean',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tlabel: '$t:interfaces.input.mask_label',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tdefault_value: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'clear',\n\t\t\t\t\tname: '$t:interfaces.input.clear',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'boolean',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tlabel: '$t:interfaces.input.clear_label',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tdefault_value: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'slug',\n\t\t\t\t\tname: '$t:interfaces.input.slug',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'boolean',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tlabel: '$t:interfaces.input.slug_label',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tdefault_value: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst numberOptions: DeepPartial<Field>[] = [\n\t\t\t{\n\t\t\t\tfield: 'min',\n\t\t\t\tname: '$t:interfaces.input.minimum_value',\n\t\t\t\ttype: 'integer',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'input',\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'max',\n\t\t\t\tname: '$t:interfaces.input.maximum_value',\n\t\t\t\ttype: 'integer',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'input',\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'step',\n\t\t\t\tname: '$t:interfaces.input.step_interval',\n\t\t\t\ttype: 'integer',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'input',\n\t\t\t\t},\n\t\t\t\tschema: {\n\t\t\t\t\tdefault_value: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'placeholder',\n\t\t\t\tname: '$t:placeholder',\n\t\t\t\ttype: 'string',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'system-input-translated-string',\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tplaceholder: '$t:enter_a_placeholder',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'iconLeft',\n\t\t\t\tname: '$t:icon_left',\n\t\t\t\ttype: 'string',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'select-icon',\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'iconRight',\n\t\t\t\tname: '$t:icon_right',\n\t\t\t\ttype: 'string',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'select-icon',\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'font',\n\t\t\t\tname: '$t:font',\n\t\t\t\ttype: 'string',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'select-dropdown',\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tchoices: [\n\t\t\t\t\t\t\t{ text: '$t:sans_serif', value: 'sans-serif' },\n\t\t\t\t\t\t\t{ text: '$t:monospace', value: 'monospace' },\n\t\t\t\t\t\t\t{ text: '$t:serif', value: 'serif' },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tschema: {\n\t\t\t\t\tdefault_value: 'sans-serif',\n\t\t\t\t},\n\t\t\t},\n\t\t];\n\n\t\tif (field.type && APP_NUMERIC_TYPES.includes(field.type)) {\n\t\t\treturn numberOptions;\n\t\t}\n\n\t\treturn textOptions;\n\t},\n\tpreview: PreviewSVG,\n});",
            "output_extracted": "import { DeepPartial, Field } from '@directus/types';\nimport { defineInterface } from '@directus/extensions';\nimport { APP_NUMERIC_TYPES } from '@/constants';\nimport InterfaceInput from './input.vue';\nimport PreviewSVG from './preview.svg?raw';\n\nexport default defineInterface({\n\tid: 'input',\n\tname: '$t:interfaces.input.input',\n\tdescription: '$t:interfaces.input.description',\n\ticon: 'text_fields',\n\tcomponent: InterfaceInput,\n\ttypes: ['string', 'uuid', 'bigInteger', 'integer', 'float', 'decimal', 'text'],\n\tgroup: 'standard',\n\toptions: ({ field }) => {\n\t\tconst textOptions: { standard: DeepPartial<Field>[]; advanced: DeepPartial<Field>[] } = {\n\t\t\tstandard: [\n\t\t\t\t{\n\t\t\t\t\tfield: 'placeholder',\n\t\t\t\t\tname: '$t:placeholder',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'full',\n\t\t\t\t\t\tinterface: 'system-input-translated-string',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tplaceholder: '$t:enter_a_placeholder',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'iconLeft',\n\t\t\t\t\tname: '$t:icon_left',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'select-icon',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'iconRight',\n\t\t\t\t\tname: '$t:icon_right',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'select-icon',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tadvanced: [\n\t\t\t\t{\n\t\t\t\t\tfield: 'softLength',\n\t\t\t\t\tname: '$t:soft_length',\n\t\t\t\t\ttype: 'integer',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'input',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tplaceholder: '255',\n\t\t\t\t\t\t\tmin: 1,\n\t\t\t\t\t\t\tmax: field.schema?.max_length,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'font',\n\t\t\t\t\tname: '$t:font',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'select-dropdown',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tchoices: [\n\t\t\t\t\t\t\t\t{ text: '$t:sans_serif', value: 'sans-serif' },\n\t\t\t\t\t\t\t\t{ text: '$t:monospace', value: 'monospace' },\n\t\t\t\t\t\t\t\t{ text: '$t:serif', value: 'serif' },\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tdefault_value: 'sans-serif',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'trim',\n\t\t\t\t\tname: '$t:interfaces.input.trim',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'boolean',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tlabel: '$t:interfaces.input.trim_label',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tdefault_value: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'masked',\n\t\t\t\t\tname: '$t:interfaces.input.mask',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'boolean',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tlabel: '$t:interfaces.input.mask_label',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tdefault_value: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'clear',\n\t\t\t\t\tname: '$t:interfaces.input.clear',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'boolean',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tlabel: '$t:interfaces.input.clear_label',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tdefault_value: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: 'slug',\n\t\t\t\t\tname: '$t:interfaces.input.slug',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\twidth: 'half',\n\t\t\t\t\t\tinterface: 'boolean',\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tlabel: '$t:interfaces.input.slug_label',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tdefault_value: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\tconst numberOptions: DeepPartial<Field>[] = [\n\t\t\t{\n\t\t\t\tfield: 'min',\n\t\t\t\tname: '$t:interfaces.input.minimum_value',\n\t\t\t\ttype: 'integer',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'input',\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'max',\n\t\t\t\tname: '$t:interfaces.input.maximum_value',\n\t\t\t\ttype: 'integer',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'input',\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'step',\n\t\t\t\tname: '$t:interfaces.input.step_interval',\n\t\t\t\ttype: 'integer',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'input',\n\t\t\t\t},\n\t\t\t\tschema: {\n\t\t\t\t\tdefault_value: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'placeholder',\n\t\t\t\tname: '$t:placeholder',\n\t\t\t\ttype: 'string',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'system-input-translated-string',\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tplaceholder: '$t:enter_a_placeholder',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'iconLeft',\n\t\t\t\tname: '$t:icon_left',\n\t\t\t\ttype: 'string',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'select-icon',\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'iconRight',\n\t\t\t\tname: '$t:icon_right',\n\t\t\t\ttype: 'string',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'select-icon',\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tfield: 'font',\n\t\t\t\tname: '$t:font',\n\t\t\t\ttype: 'string',\n\t\t\t\tmeta: {\n\t\t\t\t\twidth: 'half',\n\t\t\t\t\tinterface: 'select-dropdown',\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tchoices: [\n\t\t\t\t\t\t\t{ text: '$t:sans_serif', value: 'sans-serif' },\n\t\t\t\t\t\t\t{ text: '$t:monospace', value: 'monospace' },\n\t\t\t\t\t\t\t{ text: '$t:serif', value: 'serif' },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tschema: {\n\t\t\t\t\tdefault_value: 'sans-serif',\n\t\t\t\t},\n\t\t\t},\n\t\t];\n\n\t\tif (field.type && APP_NUMERIC_TYPES.includes(field.type)) {\n\t\t\treturn numberOptions;\n\t\t}\n\n\t\treturn textOptions;\n\t},\n\tpreview: PreviewSVG,\n});",
            "cost": 0.055885000000000004
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "directus/directus",
        "instance_id": "directus__directus.pr_mirror.26190",
        "base_commit": "f74b2c1f76e595ce073870a076755bf62b6825ce",
        "patch": "diff --git a/.changeset/mighty-facts-study.md b/.changeset/mighty-facts-study.md\nnew file mode 100644\nindex 0000000000000..587d0b24f2b72\n--- /dev/null\n+++ b/.changeset/mighty-facts-study.md\n@@ -0,0 +1,5 @@\n+---\n+'@directus/app': minor\n+---\n+\n+Added support for float intervals and min/max warnings for number inputs\n\\ No newline at end of file\ndiff --git a/app/src/components/__snapshots__/v-input.test.ts.snap b/app/src/components/__snapshots__/v-input.test.ts.snap\nindex 75084478e58ca..1163c8ad3a68b 100644\n--- a/app/src/components/__snapshots__/v-input.test.ts.snap\n+++ b/app/src/components/__snapshots__/v-input.test.ts.snap\n@@ -1,27 +1,12 @@\n // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html\n \n-exports[`Mount component 1`] = `\n-\"<div data-v-418390f4=\"\" class=\"v-input full-width\">\n-  <!--v-if-->\n-  <div data-v-418390f4=\"\" class=\"input\">\n-    <!--v-if-->\n-    <!--v-if--><input data-v-418390f4=\"\" autocomplete=\"off\" type=\"text\" step=\"1\" value=\"\">\n-    <!--v-if-->\n-    <!--v-if-->\n-    <!--v-if-->\n-    <!--v-if-->\n-  </div>\n-  <!--v-if-->\n-</div>\"\n-`;\n-\n-exports[`invalid warning > should appear for invalid input 1`] = `\n+exports[`inline warning > should appear for invalid input 1`] = `\n \"<div data-v-418390f4=\"\" class=\"v-input full-width invalid\">\n   <!--v-if-->\n   <div data-v-418390f4=\"\" class=\"input\">\n     <!--v-if-->\n     <!--v-if--><input data-v-418390f4=\"\" autocomplete=\"off\" type=\"number\" step=\"1\" value=\"\">\n-    <v-icon-stub data-v-418390f4=\"\" name=\"warning\" class=\"warning-invalid\"></v-icon-stub>\n+    <v-icon-stub data-v-418390f4=\"\" name=\"warning\" class=\"inline-warning\"></v-icon-stub>\n     <!--v-if--><span data-v-418390f4=\"\"><v-icon-stub data-v-418390f4=\"\" class=\"step-up\" name=\"keyboard_arrow_up\" tabindex=\"-1\" clickable=\"\" disabled=\"false\"></v-icon-stub><v-icon-stub data-v-418390f4=\"\" class=\"step-down\" name=\"keyboard_arrow_down\" tabindex=\"-1\" clickable=\"\" disabled=\"false\"></v-icon-stub></span>\n     <!--v-if-->\n   </div>\n@@ -29,7 +14,7 @@ exports[`invalid warning > should appear for invalid input 1`] = `\n </div>\"\n `;\n \n-exports[`invalid warning > should not appear for valid input 1`] = `\n+exports[`inline warning > should not appear for valid input 1`] = `\n \"<div data-v-418390f4=\"\" class=\"v-input full-width\">\n   <!--v-if-->\n   <div data-v-418390f4=\"\" class=\"input\">\ndiff --git a/app/src/components/v-input.test.ts b/app/src/components/v-input.test.ts\nindex 4734520815185..463291b6a1ba6 100644\n--- a/app/src/components/v-input.test.ts\n+++ b/app/src/components/v-input.test.ts\n@@ -1,28 +1,20 @@\n import { Focus } from '@/__utils__/focus';\n+import { Tooltip } from '@/__utils__/tooltip';\n import type { GlobalMountOptions } from '@/__utils__/types';\n-import { i18n } from '@/lang';\n import { mount } from '@vue/test-utils';\n import { afterEach, describe, expect, test, vi } from 'vitest';\n import VInput from './v-input.vue';\n+import { i18n } from '@/lang';\n \n const global: GlobalMountOptions = {\n \tstubs: ['v-icon'],\n \tplugins: [i18n],\n \tdirectives: {\n \t\tfocus: Focus,\n+\t\ttooltip: Tooltip,\n \t},\n };\n \n-test('Mount component', () => {\n-\texpect(VInput).toBeTruthy();\n-\n-\tconst wrapper = mount(VInput, {\n-\t\tglobal,\n-\t});\n-\n-\texpect(wrapper.html()).toMatchSnapshot();\n-});\n-\n test('modelValue prop', async () => {\n \tconst wrapper = mount(VInput, {\n \t\tprops: {\n@@ -262,7 +254,7 @@ describe('emitValue', () => {\n \t});\n });\n \n-describe('invalid warning', () => {\n+describe('inline warning', () => {\n \tafterEach(() => {\n \t\tvi.restoreAllMocks();\n \t});\n@@ -295,16 +287,18 @@ describe('invalid warning', () => {\n \t\tconst validitySpy = vi.spyOn(inputEl, 'validity', 'get').mockReturnValue({ ...validityMock, badInput: true });\n \n \t\texpect(inputEl.validity.badInput).toBe(true);\n-\t\texpect((wrapper.vm as any).isInvalidInput).toBe(false);\n+\t\texpect((wrapper.vm as any).isBadInput).toBe(false);\n \n \t\tawait input.trigger('input');\n \t\tawait wrapper.vm.$nextTick();\n \n-\t\texpect((wrapper.vm as any).isInvalidInput).toBe(true);\n+\t\texpect((wrapper.vm as any).isBadInput).toBe(true);\n \t\texpect(wrapper.find('.v-input.invalid').exists()).toBe(true);\n-\t\texpect(wrapper.find('v-icon-stub.warning-invalid').exists()).toBe(true);\n+\t\texpect(wrapper.find('v-icon-stub.inline-warning').exists()).toBe(true);\n \t\texpect(validitySpy).toHaveBeenCalledTimes(2);\n \n+\t\texpect((wrapper.vm as any).inlineWarning).toBe(i18n.global.t('not_a_number'));\n+\n \t\texpect(wrapper.html()).toMatchSnapshot();\n \t});\n \n@@ -322,16 +316,295 @@ describe('invalid warning', () => {\n \t\tconst validitySpy = vi.spyOn(inputEl, 'validity', 'get').mockReturnValue(validityMock);\n \n \t\texpect(inputEl.validity.badInput).toBe(false);\n-\t\texpect((wrapper.vm as any).isInvalidInput).toBe(false);\n+\t\texpect((wrapper.vm as any).isBadInput).toBe(false);\n \n \t\tawait input.trigger('input');\n \t\tawait wrapper.vm.$nextTick();\n \n-\t\texpect((wrapper.vm as any).isInvalidInput).toBe(false);\n+\t\texpect((wrapper.vm as any).isBadInput).toBe(false);\n \t\texpect(wrapper.find('.v-input.invalid').exists()).toBe(false);\n-\t\texpect(wrapper.find('v-icon-stub.warning-invalid').exists()).toBe(false);\n+\t\texpect(wrapper.find('v-icon-stub.inline-warning').exists()).toBe(false);\n \t\texpect(validitySpy).toHaveBeenCalledTimes(2);\n \n \t\texpect(wrapper.html()).toMatchSnapshot();\n \t});\n+\n+\ttest('should appear when value exceeds maximum', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 15,\n+\t\t\t\tmin: 0,\n+\t\t\t\tmax: 10,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\tawait wrapper.vm.$nextTick();\n+\n+\t\texpect((wrapper.vm as any).inlineWarning).toBeDefined();\n+\t\texpect(wrapper.find('v-icon-stub.inline-warning').exists()).toBe(true);\n+\t\texpect((wrapper.vm as any).inlineWarning).toBe(i18n.global.t('invalid_range_max', { value: 10 }));\n+\t});\n+\n+\ttest('should appear when value is below minimum', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: -5,\n+\t\t\t\tmin: 0,\n+\t\t\t\tmax: 10,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\tawait wrapper.vm.$nextTick();\n+\n+\t\texpect((wrapper.vm as any).inlineWarning).toBeDefined();\n+\t\texpect(wrapper.find('v-icon-stub.inline-warning').exists()).toBe(true);\n+\t\texpect((wrapper.vm as any).inlineWarning).toBe(i18n.global.t('invalid_range_min', { value: 0 }));\n+\t});\n+\n+\ttest('should not appear when value is within range', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 5,\n+\t\t\t\tmin: 0,\n+\t\t\t\tmax: 10,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\tawait wrapper.vm.$nextTick();\n+\n+\t\texpect((wrapper.vm as any).inlineWarning).toBeUndefined();\n+\t\texpect(wrapper.find('v-icon-stub.inline-warning').exists()).toBe(false);\n+\t});\n+\n+\ttest('should work with decimal values for float type', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 10.5,\n+\t\t\t\tmin: 0.5,\n+\t\t\t\tmax: 10,\n+\t\t\t\tfloat: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\tawait wrapper.vm.$nextTick();\n+\n+\t\texpect((wrapper.vm as any).inlineWarning).toBeDefined();\n+\t\texpect(wrapper.find('v-icon-stub.inline-warning').exists()).toBe(true);\n+\t\texpect((wrapper.vm as any).inlineWarning).toBe(i18n.global.t('invalid_range_max', { value: 10 }));\n+\t});\n+\n+\ttest('should show invalid_input key for non-number type', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'text',\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\tconst input = wrapper.find('input');\n+\t\tconst inputEl = input.element as HTMLInputElement;\n+\n+\t\tvi.spyOn(inputEl, 'validity', 'get').mockReturnValue({\n+\t\t\tbadInput: true,\n+\t\t} as ValidityState);\n+\n+\t\tawait input.trigger('input');\n+\t\tawait wrapper.vm.$nextTick();\n+\n+\t\texpect((wrapper.vm as any).inlineWarning).toBe(i18n.global.t('invalid_input'));\n+\t});\n+\n+\ttest('useInvalidInput takes priority over useInvalidRange', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 15,\n+\t\t\t\tmin: 0,\n+\t\t\t\tmax: 10,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\tconst input = wrapper.find('input');\n+\t\tconst inputEl = input.element as HTMLInputElement;\n+\n+\t\tvi.spyOn(inputEl, 'validity', 'get').mockReturnValue({\n+\t\t\tbadInput: true,\n+\t\t} as ValidityState);\n+\n+\t\tawait input.trigger('input');\n+\t\tawait wrapper.vm.$nextTick();\n+\n+\t\texpect((wrapper.vm as any).isBadInput).toBe(true);\n+\t\texpect(wrapper.find('.v-input.invalid').exists()).toBe(true);\n+\t});\n+});\n+\n+describe('step controls', () => {\n+\ttest('isStepUpAllowed should work with integer values', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 5,\n+\t\t\t\tmax: 10,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepUpAllowed).toBe(true);\n+\t});\n+\n+\ttest('isStepUpAllowed should work with float values', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 5.5,\n+\t\t\t\tmax: 10,\n+\t\t\t\tfloat: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepUpAllowed).toBe(true);\n+\t});\n+\n+\ttest('isStepUpAllowed should be false when at max', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 10,\n+\t\t\t\tmax: 10,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepUpAllowed).toBe(false);\n+\t});\n+\n+\ttest('isStepUpAllowed should be false when exceeding max', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 10.5,\n+\t\t\t\tmax: 10,\n+\t\t\t\tfloat: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepUpAllowed).toBe(false);\n+\t});\n+\n+\ttest('isStepDownAllowed should work with integer values', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 5,\n+\t\t\t\tmin: 0,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepDownAllowed).toBe(true);\n+\t});\n+\n+\ttest('isStepDownAllowed should work with float values', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 5.5,\n+\t\t\t\tmin: 0,\n+\t\t\t\tfloat: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepDownAllowed).toBe(true);\n+\t});\n+\n+\ttest('isStepDownAllowed should be false when at min', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 0,\n+\t\t\t\tmin: 0,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepDownAllowed).toBe(false);\n+\t});\n+\n+\ttest('isStepDownAllowed should be false when below min', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: -0.5,\n+\t\t\t\tmin: 0,\n+\t\t\t\tfloat: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepDownAllowed).toBe(false);\n+\t});\n+\n+\ttest('isStepUpAllowed should be true when no max is set', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 100,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepUpAllowed).toBe(true);\n+\t});\n+\n+\ttest('isStepDownAllowed should be true when no min is set', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: -100,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepDownAllowed).toBe(true);\n+\t});\n+\n+\ttest('step controls should be disabled when input is disabled', async () => {\n+\t\tconst wrapper = mount(VInput, {\n+\t\t\tprops: {\n+\t\t\t\ttype: 'number',\n+\t\t\t\tmodelValue: 5,\n+\t\t\t\tmin: 0,\n+\t\t\t\tmax: 10,\n+\t\t\t\tdisabled: true,\n+\t\t\t\tinteger: true,\n+\t\t\t},\n+\t\t\tglobal,\n+\t\t});\n+\n+\t\texpect((wrapper.vm as any).isStepUpAllowed).toBe(false);\n+\t\texpect((wrapper.vm as any).isStepDownAllowed).toBe(false);\n+\t});\n });\ndiff --git a/app/src/components/v-input.vue b/app/src/components/v-input.vue\nindex e5d21d5fd2a9d..b9bbd6a1ca4db 100644\n--- a/app/src/components/v-input.vue\n+++ b/app/src/components/v-input.vue\n@@ -1,7 +1,7 @@\n <script setup lang=\"ts\">\n import { keyMap, systemKeys } from '@/composables/use-shortcut';\n import slugify from '@sindresorhus/slugify';\n-import { omit } from 'lodash';\n+import { isNil, omit } from 'lodash';\n import { computed, ref, useAttrs } from 'vue';\n import { useI18n } from 'vue-i18n';\n \n@@ -114,20 +114,20 @@ const classes = computed(() => [\n \t\t'has-click': props.clickable,\n \t\tdisabled: props.disabled,\n \t\tsmall: props.small,\n-\t\tinvalid: isInvalidInput.value,\n+\t\tinvalid: isBadInput.value,\n \t},\n \t...((attrs.class || '') as string).split(' '),\n ]);\n \n const isStepUpAllowed = computed(() => {\n-\treturn props.disabled === false && (props.max === undefined || parseInt(String(props.modelValue), 10) < props.max);\n+\treturn props.disabled === false && (props.max === undefined || Number(props.modelValue) < props.max);\n });\n \n const isStepDownAllowed = computed(() => {\n-\treturn props.disabled === false && (props.min === undefined || parseInt(String(props.modelValue), 10) > props.min);\n+\treturn props.disabled === false && (props.min === undefined || Number(props.modelValue) > props.min);\n });\n \n-const { isInvalidInput, tooltipInvalid, setInvalidInput } = useInvalidInput();\n+const { isBadInput, setInvalidInput, inlineWarning } = useInlineWarning();\n \n function onInput(event: InputEvent) {\n \tconst target = event.target as HTMLInputElement;\n@@ -291,15 +291,37 @@ function stepDown() {\n \t}\n }\n \n-function useInvalidInput() {\n-\tconst isInvalidInput = ref(false);\n-\tconst tooltipInvalid = computed(() => t(props.type === 'number' ? 'not_a_number' : 'invalid_input'));\n+function useInlineWarning() {\n+\tconst isBadInput = ref(false);\n \n-\treturn { isInvalidInput, tooltipInvalid, setInvalidInput };\n+\tconst badInputWarning = computed(() => {\n+\t\tif (!isBadInput.value) return undefined;\n+\t\treturn t(props.type === 'number' ? 'not_a_number' : 'invalid_input');\n+\t});\n+\n+\tconst invalidRangeWarning = computed(() => {\n+\t\tif (isNil(props.modelValue)) return undefined;\n+\n+\t\tconst modelValue = Number(props.modelValue);\n+\n+\t\tif (props.min !== undefined && modelValue < props.min) {\n+\t\t\treturn t('invalid_range_min', { value: props.min });\n+\t\t}\n+\n+\t\tif (props.max !== undefined && modelValue > props.max) {\n+\t\t\treturn t('invalid_range_max', { value: props.max });\n+\t\t}\n+\n+\t\treturn undefined;\n+\t});\n+\n+\tconst inlineWarning = computed(() => badInputWarning.value ?? invalidRangeWarning.value);\n+\n+\treturn { isBadInput, setInvalidInput, inlineWarning };\n \n \tfunction setInvalidInput(target: HTMLInputElement) {\n \t\t// When the input\u2019s validity.badInput property is true (e.g., due to invalid user input like non-numeric characters in a number field), the input event\u2019s target.value will be empty even if we see a value in the input field. This means we can\u2019t sanitize the input value in the input event handler.\n-\t\tisInvalidInput.value = target.validity.badInput;\n+\t\tisBadInput.value = target.validity.badInput;\n \t}\n }\n </script>\n@@ -333,7 +355,7 @@ function useInvalidInput() {\n \t\t\t\t\t@keydown.enter=\"$emit('keydown:enter', $event)\"\n \t\t\t\t/>\n \t\t\t</slot>\n-\t\t\t<v-icon v-if=\"isInvalidInput\" v-tooltip=\"tooltipInvalid\" name=\"warning\" class=\"warning-invalid\" />\n+\t\t\t<v-icon v-if=\"inlineWarning\" v-tooltip=\"inlineWarning\" name=\"warning\" class=\"inline-warning\" />\n \t\t\t<span v-if=\"suffix\" class=\"suffix\">{{ suffix }}</span>\n \t\t\t<span v-if=\"type === 'number' && !hideArrows && !nonEditable\">\n \t\t\t\t<v-icon\n@@ -560,7 +582,7 @@ function useInvalidInput() {\n \t\tcolor: var(--theme--foreground-subdued);\n \t}\n \n-\t.warning-invalid {\n+\t.inline-warning {\n \t\t--v-icon-color: var(--theme--warning);\n \n \t\tmargin-inline-end: 8px;\ndiff --git a/app/src/interfaces/input/index.test.ts b/app/src/interfaces/input/index.test.ts\nnew file mode 100644\nindex 0000000000000..87807857c09b5\n--- /dev/null\n+++ b/app/src/interfaces/input/index.test.ts\n@@ -0,0 +1,153 @@\n+import { describe, expect, test } from 'vitest';\n+import type { ExtensionOptionsContext } from '@directus/extensions';\n+import config from './index';\n+\n+type OptionsFunction = (context: Partial<ExtensionOptionsContext>) => unknown;\n+\n+describe('input interface options', () => {\n+\tdescribe('numeric field types', () => {\n+\t\ttest('returns float type for min/max/step when field is float', () => {\n+\t\t\tconst field = {\n+\t\t\t\ttype: 'float' as const,\n+\t\t\t};\n+\n+\t\t\texpect(typeof config.options).toBe('function');\n+\t\t\tconst options = (config.options as OptionsFunction)({ field });\n+\n+\t\t\texpect(options).toBeDefined();\n+\t\t\texpect(Array.isArray(options)).toBe(true);\n+\n+\t\t\tconst stepOption = (options as any[]).find((opt) => opt.field === 'step');\n+\t\t\texpect(stepOption).toBeDefined();\n+\t\t\texpect(stepOption.type).toBe('float');\n+\n+\t\t\tconst minOption = (options as any[]).find((opt) => opt.field === 'min');\n+\t\t\texpect(minOption).toBeDefined();\n+\t\t\texpect(minOption.type).toBe('float');\n+\n+\t\t\tconst maxOption = (options as any[]).find((opt) => opt.field === 'max');\n+\t\t\texpect(maxOption).toBeDefined();\n+\t\t\texpect(maxOption.type).toBe('float');\n+\t\t});\n+\n+\t\ttest('returns integer type for min/max/step when field is integer', () => {\n+\t\t\tconst field = {\n+\t\t\t\ttype: 'integer' as const,\n+\t\t\t};\n+\n+\t\t\texpect(typeof config.options).toBe('function');\n+\t\t\tconst options = (config.options as OptionsFunction)({ field });\n+\n+\t\t\texpect(options).toBeDefined();\n+\t\t\texpect(Array.isArray(options)).toBe(true);\n+\n+\t\t\tconst stepOption = (options as any[]).find((opt) => opt.field === 'step');\n+\t\t\texpect(stepOption).toBeDefined();\n+\t\t\texpect(stepOption.type).toBe('integer');\n+\n+\t\t\tconst minOption = (options as any[]).find((opt) => opt.field === 'min');\n+\t\t\texpect(minOption).toBeDefined();\n+\t\t\texpect(minOption.type).toBe('integer');\n+\n+\t\t\tconst maxOption = (options as any[]).find((opt) => opt.field === 'max');\n+\t\t\texpect(maxOption).toBeDefined();\n+\t\t\texpect(maxOption.type).toBe('integer');\n+\t\t});\n+\n+\t\ttest('has default step value of 1 for numeric types', () => {\n+\t\t\tconst floatField = {\n+\t\t\t\ttype: 'float' as const,\n+\t\t\t};\n+\n+\t\t\tconst integerField = {\n+\t\t\t\ttype: 'integer' as const,\n+\t\t\t\tfield: 'test',\n+\t\t\t};\n+\n+\t\t\texpect(typeof config.options).toBe('function');\n+\t\t\tconst floatOptions = (config.options as OptionsFunction)({ field: floatField });\n+\t\t\tconst integerOptions = (config.options as OptionsFunction)({ field: integerField });\n+\n+\t\t\texpect(floatOptions).toBeDefined();\n+\t\t\texpect(integerOptions).toBeDefined();\n+\n+\t\t\tconst floatStepOption = (floatOptions as any[]).find((opt) => opt.field === 'step');\n+\t\t\tconst integerStepOption = (integerOptions as any[]).find((opt) => opt.field === 'step');\n+\n+\t\t\texpect(floatStepOption.schema.default_value).toBe(1);\n+\t\t\texpect(integerStepOption.schema.default_value).toBe(1);\n+\t\t});\n+\t});\n+\n+\tdescribe('text field types', () => {\n+\t\ttest('returns textOptions for string field', () => {\n+\t\t\tconst field = {\n+\t\t\t\ttype: 'string' as const,\n+\t\t\t\tfield: 'test',\n+\t\t\t};\n+\n+\t\t\texpect(typeof config.options).toBe('function');\n+\t\t\tconst options = (config.options as OptionsFunction)({ field });\n+\n+\t\t\texpect(options).toBeDefined();\n+\t\t\texpect(options).toHaveProperty('standard');\n+\t\t\texpect(options).toHaveProperty('advanced');\n+\t\t});\n+\n+\t\ttest('returns textOptions for text field', () => {\n+\t\t\tconst field = {\n+\t\t\t\ttype: 'text' as const,\n+\t\t\t\tfield: 'test',\n+\t\t\t};\n+\n+\t\t\texpect(typeof config.options).toBe('function');\n+\t\t\tconst options = (config.options as OptionsFunction)({ field });\n+\n+\t\t\texpect(options).toBeDefined();\n+\t\t\texpect(options).toHaveProperty('standard');\n+\t\t\texpect(options).toHaveProperty('advanced');\n+\t\t});\n+\n+\t\ttest('returns textOptions for uuid field', () => {\n+\t\t\tconst field = {\n+\t\t\t\ttype: 'uuid' as const,\n+\t\t\t\tfield: 'test',\n+\t\t\t};\n+\n+\t\t\texpect(typeof config.options).toBe('function');\n+\t\t\tconst options = (config.options as OptionsFunction)({ field });\n+\n+\t\t\texpect(options).toBeDefined();\n+\t\t\texpect(options).toHaveProperty('standard');\n+\t\t\texpect(options).toHaveProperty('advanced');\n+\t\t});\n+\n+\t\ttest('returns textOptions for decimal field', () => {\n+\t\t\tconst field = {\n+\t\t\t\ttype: 'decimal' as const,\n+\t\t\t\tfield: 'test',\n+\t\t\t};\n+\n+\t\t\texpect(typeof config.options).toBe('function');\n+\t\t\tconst options = (config.options as OptionsFunction)({ field });\n+\n+\t\t\texpect(options).toBeDefined();\n+\t\t\texpect(options).toHaveProperty('standard');\n+\t\t\texpect(options).toHaveProperty('advanced');\n+\t\t});\n+\n+\t\ttest('returns textOptions for bigInteger field', () => {\n+\t\t\tconst field = {\n+\t\t\t\ttype: 'bigInteger' as const,\n+\t\t\t\tfield: 'test',\n+\t\t\t};\n+\n+\t\t\texpect(typeof config.options).toBe('function');\n+\t\t\tconst options = (config.options as OptionsFunction)({ field });\n+\n+\t\t\texpect(options).toBeDefined();\n+\t\t\texpect(options).toHaveProperty('standard');\n+\t\t\texpect(options).toHaveProperty('advanced');\n+\t\t});\n+\t});\n+});\ndiff --git a/app/src/interfaces/input/index.ts b/app/src/interfaces/input/index.ts\nindex d4330a9776468..a89463d5a6da2 100644\n--- a/app/src/interfaces/input/index.ts\n+++ b/app/src/interfaces/input/index.ts\n@@ -146,7 +146,7 @@ export default defineInterface({\n \t\t\t{\n \t\t\t\tfield: 'min',\n \t\t\t\tname: '$t:interfaces.input.minimum_value',\n-\t\t\t\ttype: 'integer',\n+\t\t\t\ttype: field.type,\n \t\t\t\tmeta: {\n \t\t\t\t\twidth: 'half',\n \t\t\t\t\tinterface: 'input',\n@@ -155,7 +155,7 @@ export default defineInterface({\n \t\t\t{\n \t\t\t\tfield: 'max',\n \t\t\t\tname: '$t:interfaces.input.maximum_value',\n-\t\t\t\ttype: 'integer',\n+\t\t\t\ttype: field.type,\n \t\t\t\tmeta: {\n \t\t\t\t\twidth: 'half',\n \t\t\t\t\tinterface: 'input',\n@@ -164,7 +164,7 @@ export default defineInterface({\n \t\t\t{\n \t\t\t\tfield: 'step',\n \t\t\t\tname: '$t:interfaces.input.step_interval',\n-\t\t\t\ttype: 'integer',\n+\t\t\t\ttype: field.type,\n \t\t\t\tmeta: {\n \t\t\t\t\twidth: 'half',\n \t\t\t\t\tinterface: 'input',\ndiff --git a/app/src/interfaces/input/input.test.ts b/app/src/interfaces/input/input.test.ts\nnew file mode 100644\nindex 0000000000000..2973a8d2155e4\n--- /dev/null\n+++ b/app/src/interfaces/input/input.test.ts\n@@ -0,0 +1,293 @@\n+import { mount } from '@vue/test-utils';\n+import { beforeEach, describe, expect, test, vi } from 'vitest';\n+import InputInterface from './input.vue';\n+\n+const mountOptions = {\n+\tglobal: {\n+\t\tstubs: {\n+\t\t\t'v-input': {\n+\t\t\t\tname: 'v-input',\n+\t\t\t\tprops: ['modelValue', 'type', 'min', 'max', 'step', 'placeholder', 'disabled', 'trim', 'integer', 'float'],\n+\t\t\t\ttemplate: '<input />',\n+\t\t\t\temits: ['update:model-value'],\n+\t\t\t},\n+\t\t\t'v-icon': {\n+\t\t\t\ttemplate: '<span><slot /></span>',\n+\t\t\t},\n+\t\t},\n+\t},\n+};\n+\n+describe('input interface', () => {\n+\tlet wrapper: any;\n+\n+\tbeforeEach(() => {\n+\t\tvi.clearAllMocks();\n+\t});\n+\n+\ttest('interface mounts', () => {\n+\t\texpect(() => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 'test',\n+\t\t\t\t\ttype: 'string',\n+\t\t\t\t},\n+\t\t\t});\n+\t\t}).not.toThrow();\n+\n+\t\texpect(wrapper.exists()).toBe(true);\n+\t});\n+\n+\tdescribe('type handling', () => {\n+\t\ttest('sets inputType to \"number\" for integer type', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 42,\n+\t\t\t\t\ttype: 'integer',\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('type')).toBe('number');\n+\t\t});\n+\n+\t\ttest('sets inputType to \"number\" for float type', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 3.14,\n+\t\t\t\t\ttype: 'float',\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('type')).toBe('number');\n+\t\t});\n+\n+\t\ttest('sets inputType to \"text\" for string type', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 'test',\n+\t\t\t\t\ttype: 'string',\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('type')).toBe('text');\n+\t\t});\n+\n+\t\ttest('sets inputType to \"password\" when masked is true', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 'secret',\n+\t\t\t\t\ttype: 'string',\n+\t\t\t\t\tmasked: true,\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('type')).toBe('password');\n+\t\t});\n+\t});\n+\n+\tdescribe('integer and float props', () => {\n+\t\ttest('sets integer prop to true for integer type', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 42,\n+\t\t\t\t\ttype: 'integer',\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('integer')).toBe(true);\n+\t\t\texpect(input.props('float')).toBe(false);\n+\t\t});\n+\n+\t\ttest('sets integer prop to true for bigInteger type', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 42,\n+\t\t\t\t\ttype: 'bigInteger',\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('integer')).toBe(true);\n+\t\t\texpect(input.props('float')).toBe(false);\n+\t\t});\n+\n+\t\ttest('sets float prop to true for float type', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 3.14,\n+\t\t\t\t\ttype: 'float',\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('float')).toBe(true);\n+\t\t\texpect(input.props('integer')).toBe(false);\n+\t\t});\n+\n+\t\ttest('sets float prop to true for decimal type', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 19.99,\n+\t\t\t\t\ttype: 'decimal',\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('float')).toBe(true);\n+\t\t\texpect(input.props('integer')).toBe(false);\n+\t\t});\n+\t});\n+\n+\tdescribe('numeric options', () => {\n+\t\ttest('passes min and max props correctly', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 5,\n+\t\t\t\t\ttype: 'integer',\n+\t\t\t\t\tmin: 0,\n+\t\t\t\t\tmax: 10,\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('min')).toBe(0);\n+\t\t\texpect(input.props('max')).toBe(10);\n+\t\t});\n+\n+\t\ttest('passes step prop correctly', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 5,\n+\t\t\t\t\ttype: 'integer',\n+\t\t\t\t\tstep: 2,\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('step')).toBe(2);\n+\t\t});\n+\n+\t\ttest('defaults step to 1', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 5,\n+\t\t\t\t\ttype: 'integer',\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('step')).toBe(1);\n+\t\t});\n+\n+\t\ttest('supports decimal step for float types', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 5.5,\n+\t\t\t\t\ttype: 'float',\n+\t\t\t\t\tstep: 0.2,\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('step')).toBe(0.2);\n+\t\t});\n+\n+\t\ttest('supports decimal min and max for float types', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 5.5,\n+\t\t\t\t\ttype: 'float',\n+\t\t\t\t\tmin: 0.5,\n+\t\t\t\t\tmax: 10.5,\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('min')).toBe(0.5);\n+\t\t\texpect(input.props('max')).toBe(10.5);\n+\t\t});\n+\t});\n+\n+\tdescribe('events', () => {\n+\t\ttest('emits input event when value changes', async () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 'test',\n+\t\t\t\t\ttype: 'string',\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\tawait input.vm.$emit('update:model-value', 'new value');\n+\n+\t\t\texpect(wrapper.emitted('input')).toBeTruthy();\n+\t\t\texpect(wrapper.emitted('input')?.[0]).toEqual(['new value']);\n+\t\t});\n+\t});\n+\n+\tdescribe('text field options', () => {\n+\t\ttest('renders with placeholder', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: '',\n+\t\t\t\t\ttype: 'string',\n+\t\t\t\t\tplaceholder: 'Enter text...',\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('placeholder')).toBe('Enter text...');\n+\t\t});\n+\n+\t\ttest('passes trim prop for text trimming', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 'test',\n+\t\t\t\t\ttype: 'string',\n+\t\t\t\t\ttrim: true,\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('trim')).toBe(true);\n+\t\t});\n+\t});\n+\n+\tdescribe('state management', () => {\n+\t\ttest('handles disabled state', () => {\n+\t\t\twrapper = mount(InputInterface, {\n+\t\t\t\t...mountOptions,\n+\t\t\t\tprops: {\n+\t\t\t\t\tvalue: 'test',\n+\t\t\t\t\ttype: 'string',\n+\t\t\t\t\tdisabled: true,\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst input = wrapper.findComponent({ name: 'v-input' });\n+\t\t\texpect(input.props('disabled')).toBe(true);\n+\t\t});\n+\t});\n+});\ndiff --git a/app/src/lang/translations/en-US.yaml b/app/src/lang/translations/en-US.yaml\nindex 2f1f00cbd08cd..0c8c786e388d4 100644\n--- a/app/src/lang/translations/en-US.yaml\n+++ b/app/src/lang/translations/en-US.yaml\n@@ -75,6 +75,8 @@ condition_rules: Condition Rules\n input: Input\n invalid_input: Invalid Input\n not_a_number: Not a Number\n+invalid_range_min: Value is below minimum of {value}\n+invalid_range_max: Value exceeds maximum of {value}\n maps: Maps\n switch_user: Switch User\n item_creation: Item Creation\n",
        "test_patch": "",
        "problem_statement": "## Scope\r\n\r\nWhat's changed:\r\n\r\n- Step, min, and max options now accept decimal values for float/decimal fields\r\n - Input validation warnings now detect and display min/max range violations\r\n - Step up/down controls now properly handle float values\r\n\r\n## Tested Scenarios\r\n\r\n- Configured float field with decimal step interval (0.2)\r\n- Entered value exceeding configured maximum, warning icon displayed\r\n- Entered value below configured minimum, warning icon displayed\r\n- Step up/down controls with integer values\r\n- Step up/down controls with float/decimal values\r\n- Step controls respect min/max boundaries\r\n- Invalid input validation takes priority over range validation\r\n\r\n## Checklist\r\n\r\n- [X] Added or updated tests\r\n- [x] Documentation PR created [here](https://github.com/directus/docs) or not required\r\n- [x] OpenAPI package PR created [here](https://github.com/directus/openapi) or not required\r\n\r\n---\r\n\r\nFixes #25682 \r\n",
        "hints_text": "",
        "created_at": "2025-11-14T15:02:29Z",
        "pull_number": 26190,
        "test_files": [
            "app/src/components/v-input.test.ts",
            "app/src/interfaces/input/index.test.ts",
            "app/src/interfaces/input/input.test.ts"
        ],
        "code_files": [
            "app/src/interfaces/input/index.ts"
        ],
        "title": "Add support for float intervals and min/max warnings for number inputs",
        "additions": 0,
        "deletions": 0,
        "pr_mirror": "directus__directus.447c91d0"
    }
}