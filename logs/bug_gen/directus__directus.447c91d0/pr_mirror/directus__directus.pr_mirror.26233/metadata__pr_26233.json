{
    "cost": 0.0895,
    "rewrites": {
        "directus__directus.447c91d0/api/src/services/graphql/resolvers/query.ts": {
            "output": "import type { Item, Query } from '@directus/types';\nimport { parseFilterFunctionPath } from '@directus/utils';\nimport type { GraphQLResolveInfo } from 'graphql';\nimport { omit } from 'lodash-es';\nimport type { GraphQLService } from '../index.js';\nimport { parseArgs } from '../schema/parse-args.js';\nimport { getQuery } from '../schema/parse-query.js';\nimport { getAggregateQuery } from '../utils/aggregate-query.js';\nimport { replaceFragmentsInSelections } from '../utils/replace-fragments.js';\n\n/**\n * Generic resolver that's used for every \"regular\" items/system query. Converts the incoming GraphQL AST / fragments into\n * Directus' query structure which is then executed by the services.\n */\nexport async function resolveQuery(gql: GraphQLService, info: GraphQLResolveInfo): Promise<Partial<Item> | null> {\n\tlet collection = info.fieldName;\n\tif (gql.scope === 'system') collection = `directus_${collection}`;\n\tconst selections = replaceFragmentsInSelections(info.fieldNodes[0]?.selectionSet?.selections, info.fragments);\n\n\tif (!selections) return null;\n\tconst args: Record<string, any> = parseArgs(info.fieldNodes[0]!.arguments || [], info.variableValues);\n\n\tlet query: Query;\n\n\tconst isAggregate = collection.endsWith('_aggregated') && collection in gql.schema.collections === false;\n\n\tif (isAggregate) {\n\t\tcollection = collection.slice(0, -11);\n\t\tquery = await getAggregateQuery(args, selections, gql.schema, gql.accountability, collection);\n\t} else {\n\t\tquery = await getQuery(args, gql.schema, selections, info.variableValues, gql.accountability, collection);\n\n\t\tif (collection.endsWith('_by_id') && collection in gql.schema.collections === false) {\n\t\t\tcollection = collection.slice(0, -6);\n\t\t}\n\n\t\tif (collection.endsWith('_by_version') && collection in gql.schema.collections === false) {\n\t\t\tcollection = collection.slice(0, -11);\n\t\t\tquery.versionRaw = true;\n\t\t}\n\t}\n\n\t// Transform count(a.b.c) into a.b.count(c)\n\tif (query.fields?.length) {\n\t\tfor (let fieldIndex = 0; fieldIndex < query.fields.length; fieldIndex++) {\n\t\t\tquery.fields[fieldIndex] = parseFilterFunctionPath(query.fields[fieldIndex]!);\n\t\t}\n\t}\n\n\tconst result = await gql.read(collection, query, args['id']);\n\n\tif (args['id']) return result;\n\n\tif (query.group) {\n\t\t// for every entry in result add a group field based on query.group;\n\t\tconst aggregateKeys = Object.keys(query.aggregate ?? {});\n\n\t\tresult['map']((field: Item) => {\n\t\t\tfield['group'] = omit(field, aggregateKeys);\n\t\t});\n\t}\n\n\treturn result;\n}",
            "output_extracted": "import type { Item, Query } from '@directus/types';\nimport { parseFilterFunctionPath } from '@directus/utils';\nimport type { GraphQLResolveInfo } from 'graphql';\nimport { omit } from 'lodash-es';\nimport type { GraphQLService } from '../index.js';\nimport { parseArgs } from '../schema/parse-args.js';\nimport { getQuery } from '../schema/parse-query.js';\nimport { getAggregateQuery } from '../utils/aggregate-query.js';\nimport { replaceFragmentsInSelections } from '../utils/replace-fragments.js';\n\n/**\n * Generic resolver that's used for every \"regular\" items/system query. Converts the incoming GraphQL AST / fragments into\n * Directus' query structure which is then executed by the services.\n */\nexport async function resolveQuery(gql: GraphQLService, info: GraphQLResolveInfo): Promise<Partial<Item> | null> {\n\tlet collection = info.fieldName;\n\tif (gql.scope === 'system') collection = `directus_${collection}`;\n\tconst selections = replaceFragmentsInSelections(info.fieldNodes[0]?.selectionSet?.selections, info.fragments);\n\n\tif (!selections) return null;\n\tconst args: Record<string, any> = parseArgs(info.fieldNodes[0]!.arguments || [], info.variableValues);\n\n\tlet query: Query;\n\n\tconst isAggregate = collection.endsWith('_aggregated') && collection in gql.schema.collections === false;\n\n\tif (isAggregate) {\n\t\tcollection = collection.slice(0, -11);\n\t\tquery = await getAggregateQuery(args, selections, gql.schema, gql.accountability, collection);\n\t} else {\n\t\tquery = await getQuery(args, gql.schema, selections, info.variableValues, gql.accountability, collection);\n\n\t\tif (collection.endsWith('_by_id') && collection in gql.schema.collections === false) {\n\t\t\tcollection = collection.slice(0, -6);\n\t\t}\n\n\t\tif (collection.endsWith('_by_version') && collection in gql.schema.collections === false) {\n\t\t\tcollection = collection.slice(0, -11);\n\t\t\tquery.versionRaw = true;\n\t\t}\n\t}\n\n\t// Transform count(a.b.c) into a.b.count(c)\n\tif (query.fields?.length) {\n\t\tfor (let fieldIndex = 0; fieldIndex < query.fields.length; fieldIndex++) {\n\t\t\tquery.fields[fieldIndex] = parseFilterFunctionPath(query.fields[fieldIndex]!);\n\t\t}\n\t}\n\n\tconst result = await gql.read(collection, query, args['id']);\n\n\tif (args['id']) return result;\n\n\tif (query.group) {\n\t\t// for every entry in result add a group field based on query.group;\n\t\tconst aggregateKeys = Object.keys(query.aggregate ?? {});\n\n\t\tresult['map']((field: Item) => {\n\t\t\tfield['group'] = omit(field, aggregateKeys);\n\t\t});\n\t}\n\n\treturn result;\n}",
            "cost": 0.028450000000000003
        },
        "directus__directus.447c91d0/api/src/services/graphql/schema/parse-query.test.ts": {
            "output": "import type { FieldNode, SelectionNode } from 'graphql';\nimport { afterEach, describe, expect, test, vi } from 'vitest';\nimport { sanitizeQuery } from '../../../utils/sanitize-query.js';\nimport { parseArgs } from './parse-args.js';\nimport { getQuery } from './parse-query.js';\n\nvi.mock('/parse-args.js');\n\nvi.mock('../../../utils/sanitize-query.js', () => ({\n\tsanitizeQuery: vi.fn(async (q) => q),\n}));\n\nvi.mock('../../../utils/validate-query.js', () => ({\n\tvalidateQuery: vi.fn(),\n}));\n\nvi.mock('../utils/filter-replace-m2a.js', () => ({\n\tfilterReplaceM2A: vi.fn((f) => f),\n\tfilterReplaceM2ADeep: vi.fn((d) => d),\n}));\n\nvi.mock('../utils/replace-funcs.js', () => ({\n\treplaceFuncs: vi.fn((v) => v),\n}));\n\nvi.mock('./parse-args.js');\n\nconst mockSchema = {} as any;\nconst mockAccountability = null;\nconst mockVariableValues = {};\n\ndescribe('parseFields', () => {\n\tafterEach(() => {\n\t\tvi.clearAllMocks();\n\t});\n\n\ttest('should parse simple field selection', async () => {\n\t\tconst selections = [\n\t\t\t{ kind: 'Field', name: { value: 'id' } },\n\t\t\t{ kind: 'Field', name: { value: 'name' } },\n\t\t] as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['id', 'name']);\n\t});\n\n\ttest('should ignore __typename fields', async () => {\n\t\tconst selections = [\n\t\t\t{ kind: 'Field', name: { value: '__typename' } },\n\t\t\t{ kind: 'Field', name: { value: 'title' } },\n\t\t] as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['title']);\n\t});\n\n\ttest('should parse field with alias', async () => {\n\t\tconst selections = [{ kind: 'Field', name: { value: 'author' }, alias: { value: 'writer' } }] as SelectionNode[];\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['author']);\n\t\texpect(query.alias).toEqual({ writer: 'author' });\n\t});\n\n\ttest('should parse InlineFragment', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'parent' },\n\t\t\t\tselectionSet: { selections: [{ kind: 'InlineFragment', typeCondition: { name: { value: 'child' } } }] },\n\t\t\t},\n\t\t] as unknown as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability, 'test_collection');\n\t\texpect(query.fields).toContain('parent:child');\n\t});\n\n\ttest('should parse nested selectionSet', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'user' },\n\t\t\t\tselectionSet: {\n\t\t\t\t\tselections: [\n\t\t\t\t\t\t{ kind: 'Field', name: { value: 'id' } },\n\t\t\t\t\t\t{ kind: 'Field', name: { value: 'email' } },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t] as unknown as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['user.id', 'user.email']);\n\t});\n\n\ttest('should parse field with arguments', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'posts' },\n\t\t\t\targuments: [{ name: { value: 'limit' }, value: { kind: 'IntValue', value: '10' } }],\n\t\t\t},\n\t\t] as unknown as FieldNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['posts']);\n\t\texpect(parseArgs).toHaveBeenCalledWith(selections[0]!.arguments, mockVariableValues);\n\t});\n\n\ttest('should parse InlineFragment with arguments', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'parent' },\n\t\t\t\tselectionSet: {\n\t\t\t\t\tselections: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'InlineFragment',\n\t\t\t\t\t\t\ttypeCondition: { name: { value: 'child' } },\n\t\t\t\t\t\t\tselectionSet: {\n\t\t\t\t\t\t\t\tselections: [\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tkind: 'Field',\n\t\t\t\t\t\t\t\t\t\tname: { value: 'grandchild' },\n\t\t\t\t\t\t\t\t\t\targuments: [{ name: { value: 'limit' }, value: { kind: 'IntValue', value: '10' } }],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t] as unknown as SelectionNode[];\n\n\t\tvi.mocked(sanitizeQuery).mockResolvedValue({ limit: 10 });\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['parent:child.grandchild']);\n\n\t\texpect(query.deep).toStrictEqual({\n\t\t\tparent__child: {\n\t\t\t\tgrandchild: {\n\t\t\t\t\t_alias: {},\n\t\t\t\t\t_deep: {},\n\t\t\t\t\t_limit: 10,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t});\n\n\ttest('should parse _func field with selectionSet', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'count_func' },\n\t\t\t\tselectionSet: {\n\t\t\t\t\tselections: [\n\t\t\t\t\t\t{ kind: 'Field', name: { value: 'sum' } },\n\t\t\t\t\t\t{ kind: 'Field', name: { value: 'avg' } },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t] as unknown as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['sum(count)', 'avg(count)']);\n\t});\n\n\ttest('should handle empty selections', async () => {\n\t\tconst query = await getQuery({}, mockSchema, [], mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual([]);\n\t});\n\n\ttest('should handle deeply nested fields', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'parent' },\n\t\t\t\tselectionSet: {\n\t\t\t\t\tselections: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'Field',\n\t\t\t\t\t\t\tname: { value: 'child' },\n\t\t\t\t\t\t\tselectionSet: {\n\t\t\t\t\t\t\t\tselections: [{ kind: 'Field', name: { value: 'grandchild' } }],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t] as unknown as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['parent.child.grandchild']);\n\t});\n});",
            "output_extracted": "import type { FieldNode, SelectionNode } from 'graphql';\nimport { afterEach, describe, expect, test, vi } from 'vitest';\nimport { sanitizeQuery } from '../../../utils/sanitize-query.js';\nimport { parseArgs } from './parse-args.js';\nimport { getQuery } from './parse-query.js';\n\nvi.mock('/parse-args.js');\n\nvi.mock('../../../utils/sanitize-query.js', () => ({\n\tsanitizeQuery: vi.fn(async (q) => q),\n}));\n\nvi.mock('../../../utils/validate-query.js', () => ({\n\tvalidateQuery: vi.fn(),\n}));\n\nvi.mock('../utils/filter-replace-m2a.js', () => ({\n\tfilterReplaceM2A: vi.fn((f) => f),\n\tfilterReplaceM2ADeep: vi.fn((d) => d),\n}));\n\nvi.mock('../utils/replace-funcs.js', () => ({\n\treplaceFuncs: vi.fn((v) => v),\n}));\n\nvi.mock('./parse-args.js');\n\nconst mockSchema = {} as any;\nconst mockAccountability = null;\nconst mockVariableValues = {};\n\ndescribe('parseFields', () => {\n\tafterEach(() => {\n\t\tvi.clearAllMocks();\n\t});\n\n\ttest('should parse simple field selection', async () => {\n\t\tconst selections = [\n\t\t\t{ kind: 'Field', name: { value: 'id' } },\n\t\t\t{ kind: 'Field', name: { value: 'name' } },\n\t\t] as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['id', 'name']);\n\t});\n\n\ttest('should ignore __typename fields', async () => {\n\t\tconst selections = [\n\t\t\t{ kind: 'Field', name: { value: '__typename' } },\n\t\t\t{ kind: 'Field', name: { value: 'title' } },\n\t\t] as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['title']);\n\t});\n\n\ttest('should parse field with alias', async () => {\n\t\tconst selections = [{ kind: 'Field', name: { value: 'author' }, alias: { value: 'writer' } }] as SelectionNode[];\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['author']);\n\t\texpect(query.alias).toEqual({ writer: 'author' });\n\t});\n\n\ttest('should parse InlineFragment', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'parent' },\n\t\t\t\tselectionSet: { selections: [{ kind: 'InlineFragment', typeCondition: { name: { value: 'child' } } }] },\n\t\t\t},\n\t\t] as unknown as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability, 'test_collection');\n\t\texpect(query.fields).toContain('parent:child');\n\t});\n\n\ttest('should parse nested selectionSet', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'user' },\n\t\t\t\tselectionSet: {\n\t\t\t\t\tselections: [\n\t\t\t\t\t\t{ kind: 'Field', name: { value: 'id' } },\n\t\t\t\t\t\t{ kind: 'Field', name: { value: 'email' } },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t] as unknown as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['user.id', 'user.email']);\n\t});\n\n\ttest('should parse field with arguments', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'posts' },\n\t\t\t\targuments: [{ name: { value: 'limit' }, value: { kind: 'IntValue', value: '10' } }],\n\t\t\t},\n\t\t] as unknown as FieldNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['posts']);\n\t\texpect(parseArgs).toHaveBeenCalledWith(selections[0]!.arguments, mockVariableValues);\n\t});\n\n\ttest('should parse InlineFragment with arguments', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'parent' },\n\t\t\t\tselectionSet: {\n\t\t\t\t\tselections: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'InlineFragment',\n\t\t\t\t\t\t\ttypeCondition: { name: { value: 'child' } },\n\t\t\t\t\t\t\tselectionSet: {\n\t\t\t\t\t\t\t\tselections: [\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tkind: 'Field',\n\t\t\t\t\t\t\t\t\t\tname: { value: 'grandchild' },\n\t\t\t\t\t\t\t\t\t\targuments: [{ name: { value: 'limit' }, value: { kind: 'IntValue', value: '10' } }],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t] as unknown as SelectionNode[];\n\n\t\tvi.mocked(sanitizeQuery).mockResolvedValue({ limit: 10 });\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['parent:child.grandchild']);\n\n\t\texpect(query.deep).toStrictEqual({\n\t\t\tparent__child: {\n\t\t\t\tgrandchild: {\n\t\t\t\t\t_alias: {},\n\t\t\t\t\t_deep: {},\n\t\t\t\t\t_limit: 10,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t});\n\n\ttest('should parse _func field with selectionSet', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'count_func' },\n\t\t\t\tselectionSet: {\n\t\t\t\t\tselections: [\n\t\t\t\t\t\t{ kind: 'Field', name: { value: 'sum' } },\n\t\t\t\t\t\t{ kind: 'Field', name: { value: 'avg' } },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t] as unknown as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['sum(count)', 'avg(count)']);\n\t});\n\n\ttest('should handle empty selections', async () => {\n\t\tconst query = await getQuery({}, mockSchema, [], mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual([]);\n\t});\n\n\ttest('should handle deeply nested fields', async () => {\n\t\tconst selections = [\n\t\t\t{\n\t\t\t\tkind: 'Field',\n\t\t\t\tname: { value: 'parent' },\n\t\t\t\tselectionSet: {\n\t\t\t\t\tselections: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'Field',\n\t\t\t\t\t\t\tname: { value: 'child' },\n\t\t\t\t\t\t\tselectionSet: {\n\t\t\t\t\t\t\t\tselections: [{ kind: 'Field', name: { value: 'grandchild' } }],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t] as unknown as SelectionNode[];\n\n\t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n\t\texpect(query.fields).toEqual(['parent.child.grandchild']);\n\t});\n});",
            "cost": 0.06105
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "directus/directus",
        "instance_id": "directus__directus.pr_mirror.26233",
        "base_commit": "d5bc1f5834f6ff8bce26becfba1fe3cb4a3c799d",
        "patch": "diff --git a/.changeset/forty-wombats-wash.md b/.changeset/forty-wombats-wash.md\nnew file mode 100644\nindex 0000000000000..3245ad1d428e6\n--- /dev/null\n+++ b/.changeset/forty-wombats-wash.md\n@@ -0,0 +1,5 @@\n+---\n+'@directus/api': patch\n+---\n+\n+Fixed `_by_id` querying with M2A filters in GraphQL\ndiff --git a/api/src/services/graphql/resolvers/query.test.ts b/api/src/services/graphql/resolvers/query.test.ts\nnew file mode 100644\nindex 0000000000000..828daaacf1ca8\n--- /dev/null\n+++ b/api/src/services/graphql/resolvers/query.test.ts\n@@ -0,0 +1,243 @@\n+import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';\n+import { parseArgs } from '../schema/parse-args.js';\n+import { getQuery } from '../schema/parse-query.js';\n+import { getAggregateQuery } from '../utils/aggregate-query.js';\n+import { replaceFragmentsInSelections } from '../utils/replace-fragments.js';\n+import { resolveQuery } from './query.js';\n+\n+vi.mock('../utils/replace-fragments.js');\n+vi.mock('../schema/parse-args.js');\n+vi.mock('../utils/aggregate-query.js');\n+vi.mock('../schema/parse-query.js');\n+\n+describe('resolveQuery', () => {\n+\tconst mockReplaceFragments = vi.fn();\n+\tconst mockParseArgs = vi.fn();\n+\tconst mockGetAggregateQuery = vi.fn();\n+\tconst mockGetQuery = vi.fn();\n+\n+\tbeforeEach(() => {\n+\t\tvi.mocked(replaceFragmentsInSelections).mockImplementation(mockReplaceFragments);\n+\t\tvi.mocked(parseArgs).mockImplementation(mockParseArgs);\n+\t\tvi.mocked(getAggregateQuery).mockImplementation(mockGetAggregateQuery);\n+\t\tvi.mocked(getQuery).mockImplementation(mockGetQuery);\n+\t});\n+\n+\tafterEach(() => {\n+\t\tvi.clearAllMocks();\n+\t\tvi.resetAllMocks();\n+\t\tvi.restoreAllMocks();\n+\t});\n+\n+\ttest('system scope prefixes collection with directus_', async () => {\n+\t\tmockReplaceFragments.mockReturnValue([{}]);\n+\t\tmockParseArgs.mockReturnValue({});\n+\n+\t\tmockGetQuery.mockResolvedValue({\n+\t\t\tfields: [],\n+\t\t});\n+\n+\t\tconst gql: any = {\n+\t\t\tscope: 'system',\n+\t\t\tschema: { collections: {} },\n+\t\t\taccountability: {},\n+\t\t\tread: vi.fn(() => []),\n+\t\t};\n+\n+\t\tconst info: any = {\n+\t\t\tfieldName: 'users',\n+\t\t\tfieldNodes: [{ selectionSet: { selections: [{}] }, arguments: [] }],\n+\t\t\tfragments: {},\n+\t\t\tvariableValues: {},\n+\t\t};\n+\n+\t\tawait resolveQuery(gql, info);\n+\n+\t\texpect(mockGetQuery).toHaveBeenCalled();\n+\t\tconst lastCallArgs = mockGetQuery.mock.calls[mockGetQuery.mock.calls.length - 1];\n+\t\tconst collectionArg = lastCallArgs?.[lastCallArgs.length - 1];\n+\t\texpect(collectionArg).toBe('directus_users');\n+\t});\n+\n+\ttest('returns null when selections are missing', async () => {\n+\t\tmockReplaceFragments.mockReturnValue(null);\n+\n+\t\tconst gql: any = {\n+\t\t\tscope: 'app',\n+\t\t\tschema: { collections: {} },\n+\t\t\taccountability: {},\n+\t\t\tread: vi.fn(),\n+\t\t};\n+\n+\t\tconst info: any = {\n+\t\t\tfieldName: 'posts',\n+\t\t\tfieldNodes: [{ selectionSet: undefined }],\n+\t\t\tfragments: {},\n+\t\t\tvariableValues: {},\n+\t\t};\n+\n+\t\tconst res = await resolveQuery(gql, info);\n+\n+\t\texpect(res).toBeNull();\n+\t\texpect(mockParseArgs).not.toHaveBeenCalled();\n+\t});\n+\n+\ttest('aggregate branch calls getAggregateQuery with correct collection name', async () => {\n+\t\tmockReplaceFragments.mockReturnValue([{}]);\n+\t\tmockParseArgs.mockReturnValue({ id: 'id' });\n+\n+\t\tmockGetAggregateQuery.mockReturnValue({\n+\t\t\tfields: [],\n+\t\t});\n+\n+\t\tconst gql: any = {\n+\t\t\tscope: 'app',\n+\t\t\tschema: {\n+\t\t\t\tcollections: {},\n+\t\t\t},\n+\t\t\taccountability: {},\n+\t\t\tread: vi.fn(),\n+\t\t};\n+\n+\t\tconst info: any = {\n+\t\t\tfieldName: 'posts_aggregated',\n+\t\t\tfieldNodes: [{ selectionSet: { selections: [{}] }, arguments: [] }],\n+\t\t\tfragments: {},\n+\t\t\tvariableValues: {},\n+\t\t};\n+\n+\t\tawait resolveQuery(gql, info);\n+\n+\t\tconst lastCallArgs = mockGetAggregateQuery.mock.calls[mockGetAggregateQuery.mock.calls.length - 1];\n+\t\tconst collectionArg = lastCallArgs?.[lastCallArgs.length - 1];\n+\t\texpect(collectionArg).toBe('posts');\n+\t});\n+\n+\ttest('query by id calls getQuery with correct collection name', async () => {\n+\t\tmockReplaceFragments.mockReturnValue([{}]);\n+\t\tmockParseArgs.mockReturnValue({ id: 'abc' });\n+\n+\t\tmockGetQuery.mockReturnValue({\n+\t\t\tfields: [],\n+\t\t});\n+\n+\t\tconst gql: any = {\n+\t\t\tscope: 'app',\n+\t\t\tschema: {\n+\t\t\t\tcollections: {},\n+\t\t\t},\n+\t\t\taccountability: {},\n+\t\t\tread: vi.fn(),\n+\t\t};\n+\n+\t\tconst info: any = {\n+\t\t\tfieldName: 'posts_by_id',\n+\t\t\tfieldNodes: [{ selectionSet: { selections: [{}] }, arguments: [] }],\n+\t\t\tfragments: {},\n+\t\t\tvariableValues: {},\n+\t\t};\n+\n+\t\tawait resolveQuery(gql, info);\n+\n+\t\texpect(mockGetQuery).toHaveBeenCalled();\n+\t\tconst lastCallArgs = mockGetQuery.mock.calls[mockGetQuery.mock.calls.length - 1];\n+\t\tconst collectionArg = lastCallArgs?.[lastCallArgs.length - 1];\n+\t\texpect(collectionArg).toBe('posts');\n+\t});\n+\n+\ttest('query by version injects versionRaw to query', async () => {\n+\t\tmockReplaceFragments.mockReturnValue([{}]);\n+\t\tmockParseArgs.mockReturnValue({ id: 'abc' });\n+\n+\t\tmockGetQuery.mockReturnValue({\n+\t\t\tfields: [],\n+\t\t});\n+\n+\t\tconst gql: any = {\n+\t\t\tscope: 'app',\n+\t\t\tschema: {\n+\t\t\t\tcollections: {},\n+\t\t\t},\n+\t\t\taccountability: {},\n+\t\t\tread: vi.fn(),\n+\t\t};\n+\n+\t\tconst info: any = {\n+\t\t\tfieldName: 'posts_by_version',\n+\t\t\tfieldNodes: [{ selectionSet: { selections: [{}] }, arguments: [] }],\n+\t\t\tfragments: {},\n+\t\t\tvariableValues: {},\n+\t\t};\n+\n+\t\tawait resolveQuery(gql, info);\n+\n+\t\texpect(gql.read).toHaveBeenCalled();\n+\t\tconst lastCallArgs = gql.read.mock.calls[gql.read.mock.calls.length - 1];\n+\t\tconst queryArg = lastCallArgs?.[1];\n+\t\texpect(queryArg).toEqual(expect.objectContaining({ versionRaw: true }));\n+\t});\n+\n+\ttest('properly resolves fields to correct path for each nested function field', async () => {\n+\t\tmockReplaceFragments.mockReturnValue([{}]);\n+\t\tmockParseArgs.mockReturnValue({ id: 'abc' });\n+\n+\t\tmockGetAggregateQuery.mockResolvedValue({\n+\t\t\tfields: ['count(a)', 'sum(b.c)', 'max(c.d.e)'],\n+\t\t});\n+\n+\t\tconst gql: any = {\n+\t\t\tscope: 'app',\n+\t\t\tschema: { collections: {} },\n+\t\t\taccountability: {},\n+\t\t\tread: vi.fn(() => []),\n+\t\t};\n+\n+\t\tconst info: any = {\n+\t\t\tfieldName: 'col_aggregated',\n+\t\t\tfieldNodes: [{ selectionSet: { selections: [{}] }, arguments: [] }],\n+\t\t\tfragments: {},\n+\t\t\tvariableValues: {},\n+\t\t};\n+\n+\t\tawait resolveQuery(gql, info);\n+\n+\t\texpect(gql.read).toHaveBeenCalled();\n+\t\tconst lastCallArgs = gql.read.mock.calls[gql.read.mock.calls.length - 1];\n+\t\tconst queryArg = lastCallArgs?.[1];\n+\t\texpect(queryArg).toEqual(expect.objectContaining({ fields: ['count(a)', 'b.sum(c)', 'c.d.max(e)'] }));\n+\t});\n+\n+\ttest('inject group field for each item when grouping', async () => {\n+\t\tmockReplaceFragments.mockReturnValue([{}]);\n+\t\tmockParseArgs.mockReturnValue({});\n+\n+\t\tmockGetAggregateQuery.mockResolvedValue({\n+\t\t\tgroup: ['category'],\n+\t\t\taggregate: { count: ['id'] },\n+\t\t});\n+\n+\t\tconst gql: any = {\n+\t\t\tscope: 'app',\n+\t\t\tschema: { collections: {} },\n+\t\t\taccountability: {},\n+\t\t\tread: vi.fn(() => [\n+\t\t\t\t{ category: 'A', count: { id: 5 } },\n+\t\t\t\t{ category: 'B', count: { id: 10 } },\n+\t\t\t]),\n+\t\t};\n+\n+\t\tconst info: any = {\n+\t\t\tfieldName: 'items_aggregated',\n+\t\t\tfieldNodes: [{ selectionSet: { selections: [{}] }, arguments: [] }],\n+\t\t\tfragments: {},\n+\t\t\tvariableValues: {},\n+\t\t};\n+\n+\t\tconst res = await resolveQuery(gql, info);\n+\n+\t\texpect(res).toEqual([\n+\t\t\t{ category: 'A', count: { id: 5 }, group: { category: 'A' } },\n+\t\t\t{ category: 'B', count: { id: 10 }, group: { category: 'B' } },\n+\t\t]);\n+\t});\n+});\ndiff --git a/api/src/services/graphql/resolvers/query.ts b/api/src/services/graphql/resolvers/query.ts\nindex b014b12d67253..dafadf2e820f6 100644\n--- a/api/src/services/graphql/resolvers/query.ts\n+++ b/api/src/services/graphql/resolvers/query.ts\n@@ -28,12 +28,12 @@ export async function resolveQuery(gql: GraphQLService, info: GraphQLResolveInfo\n \t\tcollection = collection.slice(0, -11);\n \t\tquery = await getAggregateQuery(args, selections, gql.schema, gql.accountability, collection);\n \t} else {\n-\t\tquery = await getQuery(args, gql.schema, selections, info.variableValues, gql.accountability, collection);\n-\n \t\tif (collection.endsWith('_by_id') && collection in gql.schema.collections === false) {\n \t\t\tcollection = collection.slice(0, -6);\n \t\t}\n \n+\t\tquery = await getQuery(args, gql.schema, selections, info.variableValues, gql.accountability, collection);\n+\n \t\tif (collection.endsWith('_by_version') && collection in gql.schema.collections === false) {\n \t\t\tcollection = collection.slice(0, -11);\n \t\t\tquery.versionRaw = true;\ndiff --git a/api/src/services/graphql/schema/parse-query.test.ts b/api/src/services/graphql/schema/parse-query.test.ts\nindex d806a4dbeea0c..aeb33eb2a9951 100644\n--- a/api/src/services/graphql/schema/parse-query.test.ts\n+++ b/api/src/services/graphql/schema/parse-query.test.ts\n@@ -1,11 +1,8 @@\n import type { FieldNode, SelectionNode } from 'graphql';\n import { afterEach, describe, expect, test, vi } from 'vitest';\n import { sanitizeQuery } from '../../../utils/sanitize-query.js';\n-import { parseArgs } from './parse-args.js';\n import { getQuery } from './parse-query.js';\n \n-vi.mock('/parse-args.js');\n-\n vi.mock('../../../utils/sanitize-query.js', () => ({\n \tsanitizeQuery: vi.fn(async (q) => q),\n }));\n@@ -23,8 +20,6 @@ vi.mock('../utils/replace-funcs.js', () => ({\n \treplaceFuncs: vi.fn((v) => v),\n }));\n \n-vi.mock('./parse-args.js');\n-\n const mockSchema = {} as any;\n const mockAccountability = null;\n const mockVariableValues = {};\n@@ -103,7 +98,6 @@ describe('parseFields', () => {\n \n \t\tconst query = await getQuery({}, mockSchema, selections, mockVariableValues, mockAccountability);\n \t\texpect(query.fields).toEqual(['posts']);\n-\t\texpect(parseArgs).toHaveBeenCalledWith(selections[0]!.arguments, mockVariableValues);\n \t});\n \n \ttest('should parse InlineFragment with arguments', async () => {\n",
        "test_patch": "",
        "problem_statement": "## Scope\r\n\r\nWhat's changed:\r\n\r\n- The correct collection name is now passed down for filtering m2a fields\r\n\r\n## Potential Risks / Drawbacks\r\n\r\n- Should be none\r\n\r\n## Tested Scenarios\r\n\r\n-  [x] Expect M2A filtering with `_by_id` to succeed\r\n\r\n## Review Notes / Questions\r\n\r\n- I would like to lorem ipsum\r\n- Special attention should be paid to dolor sit amet\r\n\r\n## Checklist\r\n\r\n- [x] Added or updated tests\r\n- [ ] Documentation PR created [here](https://github.com/directus/docs) or not required\r\n- [ ] OpenAPI package PR created [here](https://github.com/directus/openapi) or not required\r\n\r\n---\r\n\r\nFixes #26232",
        "hints_text": "",
        "created_at": "2025-11-20T17:45:50Z",
        "pull_number": 26233,
        "test_files": [
            "api/src/services/graphql/resolvers/query.test.ts",
            "api/src/services/graphql/schema/parse-query.test.ts"
        ],
        "code_files": [
            "api/src/services/graphql/resolvers/query.ts"
        ],
        "title": "Fixed `_by_id` querying with M2A filters in GraphQL",
        "additions": 0,
        "deletions": 0,
        "pr_mirror": "directus__directus.447c91d0"
    }
}