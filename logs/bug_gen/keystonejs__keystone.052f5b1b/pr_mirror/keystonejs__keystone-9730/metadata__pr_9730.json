{
    "cost": 0.30205000000000004,
    "rewrites": {
        "keystonejs__keystone.052f5b1b/examples/actions/schema.ts": {
            "output": "import { list } from '@keystone-6/core'\nimport { allowAll, denyAll } from '@keystone-6/core/access'\nimport { checkbox, integer, text, timestamp } from '@keystone-6/core/fields'\n\nimport type { Lists } from '.keystone/types'\n\n// WARNING: this example is for demonstration purposes only\n//   as with each of our examples, it has not been vetted\n//   or tested for any particular usage\n\nconst readOnly = {\n  access: {\n    read: allowAll,\n    create: denyAll,\n    update: denyAll,\n  },\n  graphql: {\n    omit: {\n      create: true,\n      update: true,\n    },\n  },\n  ui: {\n    createView: {\n      fieldMode: 'hidden' as const,\n    },\n    itemView: {\n      fieldMode: 'read' as const,\n      fieldPosition: 'sidebar' as const,\n    },\n  },\n}\n\nexport const lists = {\n  Post: list({\n    access: allowAll, // WARNING: public\n    fields: {\n      title: text(),\n      content: text(),\n      hidden: checkbox(),\n      votes: integer({ defaultValue: 0 }),\n      reportedAt: timestamp({\n        ui: {\n          itemView: {\n            fieldMode: ({ item, itemField }) => {\n              // WARNING: none of this is access control\n              if (!item || item.votes === null) return 'edit'\n              if (itemField) return 'edit'\n              return item.votes > 0 ? 'read' : 'edit'\n            },\n          },\n        },\n      }),\n    },\n    actions: {\n      vote: {\n        access: ({ context }) => {\n          const ua = context.req?.headers['user-agent'] ?? ''\n          // only allow voting from Chrome browsers\n          return ua.includes('Chrome')\n        },\n        // with navigation: 'follow', null redirects to the list view, otherwise to the item view {with the returned item id}\n        async resolve({ actionKey, where }, context) {\n          console.log(`${actionKey}`, JSON.stringify({ where }))\n          if (!where) return null\n          if (typeof where.id !== 'string') return null // TODO: FIXME: { increment } support for context.db?\n\n          // WARNING: prisma bypasses access control, be wary of this\n          return await context.prisma.post.update({\n            where: { id: where.id },\n            data: {\n              votes: {\n                increment: 1,\n              },\n            },\n          })\n        },\n        ui: {\n          label: 'Vote +1',\n          icon: 'voteIcon',\n          messages: {\n            success: 'Voted for {itemLabel}',\n            successMany: 'Voted for {countSuccess} {singular|plural}',\n          },\n          itemView: {\n            hidePrompt: true,\n          },\n          listView: {\n            actionMode: 'hidden',\n          },\n        },\n      },\n      report: {\n        access: allowAll,\n        async resolve({ actionKey, where }, context) {\n          console.log(`${actionKey}`, JSON.stringify({ where }))\n          // throw new Error('Random failure, try again')\n          return await context.db.Post.updateOne({\n            where,\n            data: {\n              reportedAt: new Date(),\n            },\n          })\n        },\n        graphql: {\n          singular: 'reportAPost', // optional, defaults to 'reportPost'\n          plural: 'reportSomePosts', // optional, defaults to 'reportPosts'\n        },\n        ui: {\n          label: 'Report',\n          icon: 'flagIcon',\n          messages: {\n            promptTitle: 'Report {singular}',\n            promptTitleMany: 'Report {count} {singular|plural}',\n            prompt: 'Are you sure you want to report \"{itemLabel}\"?',\n            promptMany: 'Are you sure you want to report {count} {singular|plural}?',\n            promptConfirmLabel: 'Yes, report',\n            promptConfirmLabelMany: 'Yes, report {count} {singular|plural}',\n            fail: 'Could not report {singular} \"{itemLabel}\"',\n            failMany: 'Could not report {countFail} {singular|plural}',\n            success: '{Singular} reported',\n            successMany: 'Successfully reported {countSuccess} {singular|plural}',\n          },\n          itemView: {\n            actionMode: () => 'enabled',\n            navigation: 'refetch',\n            hideToast: true,\n          },\n          listView: {\n            actionMode: 'enabled',\n          },\n        },\n      },\n    },\n    ui: {\n      listView: {\n        initialFilter: {\n          hidden: { equals: false },\n        },\n        initialSort: { field: 'votes', direction: 'DESC' },\n      },\n    },\n  }),\n} satisfies Lists",
            "output_extracted": "import { list } from '@keystone-6/core'\nimport { allowAll, denyAll } from '@keystone-6/core/access'\nimport { checkbox, integer, text, timestamp } from '@keystone-6/core/fields'\n\nimport type { Lists } from '.keystone/types'\n\n// WARNING: this example is for demonstration purposes only\n//   as with each of our examples, it has not been vetted\n//   or tested for any particular usage\n\nconst readOnly = {\n  access: {\n    read: allowAll,\n    create: denyAll,\n    update: denyAll,\n  },\n  graphql: {\n    omit: {\n      create: true,\n      update: true,\n    },\n  },\n  ui: {\n    createView: {\n      fieldMode: 'hidden' as const,\n    },\n    itemView: {\n      fieldMode: 'read' as const,\n      fieldPosition: 'sidebar' as const,\n    },\n  },\n}\n\nexport const lists = {\n  Post: list({\n    access: allowAll, // WARNING: public\n    fields: {\n      title: text(),\n      content: text(),\n      hidden: checkbox(),\n      votes: integer({ defaultValue: 0 }),\n      reportedAt: timestamp({\n        ui: {\n          itemView: {\n            fieldMode: ({ item, itemField }) => {\n              // WARNING: none of this is access control\n              if (!item || item.votes === null) return 'edit'\n              if (itemField) return 'edit'\n              return item.votes > 0 ? 'read' : 'edit'\n            },\n          },\n        },\n      }),\n    },\n    actions: {\n      vote: {\n        access: ({ context }) => {\n          const ua = context.req?.headers['user-agent'] ?? ''\n          // only allow voting from Chrome browsers\n          return ua.includes('Chrome')\n        },\n        // with navigation: 'follow', null redirects to the list view, otherwise to the item view {with the returned item id}\n        async resolve({ actionKey, where }, context) {\n          console.log(`${actionKey}`, JSON.stringify({ where }))\n          if (!where) return null\n          if (typeof where.id !== 'string') return null // TODO: FIXME: { increment } support for context.db?\n\n          // WARNING: prisma bypasses access control, be wary of this\n          return await context.prisma.post.update({\n            where: { id: where.id },\n            data: {\n              votes: {\n                increment: 1,\n              },\n            },\n          })\n        },\n        ui: {\n          label: 'Vote +1',\n          icon: 'voteIcon',\n          messages: {\n            success: 'Voted for {itemLabel}',\n            successMany: 'Voted for {countSuccess} {singular|plural}',\n          },\n          itemView: {\n            hidePrompt: true,\n          },\n          listView: {\n            actionMode: 'hidden',\n          },\n        },\n      },\n      report: {\n        access: allowAll,\n        async resolve({ actionKey, where }, context) {\n          console.log(`${actionKey}`, JSON.stringify({ where }))\n          // throw new Error('Random failure, try again')\n          return await context.db.Post.updateOne({\n            where,\n            data: {\n              reportedAt: new Date(),\n            },\n          })\n        },\n        graphql: {\n          singular: 'reportAPost', // optional, defaults to 'reportPost'\n          plural: 'reportSomePosts', // optional, defaults to 'reportPosts'\n        },\n        ui: {\n          label: 'Report',\n          icon: 'flagIcon',\n          messages: {\n            promptTitle: 'Report {singular}',\n            promptTitleMany: 'Report {count} {singular|plural}',\n            prompt: 'Are you sure you want to report \"{itemLabel}\"?',\n            promptMany: 'Are you sure you want to report {count} {singular|plural}?',\n            promptConfirmLabel: 'Yes, report',\n            promptConfirmLabelMany: 'Yes, report {count} {singular|plural}',\n            fail: 'Could not report {singular} \"{itemLabel}\"',\n            failMany: 'Could not report {countFail} {singular|plural}',\n            success: '{Singular} reported',\n            successMany: 'Successfully reported {countSuccess} {singular|plural}',\n          },\n          itemView: {\n            actionMode: () => 'enabled',\n            navigation: 'refetch',\n            hideToast: true,\n          },\n          listView: {\n            actionMode: 'enabled',\n          },\n        },\n      },\n    },\n    ui: {\n      listView: {\n        initialFilter: {\n          hidden: { equals: false },\n        },\n        initialSort: { field: 'votes', direction: 'DESC' },\n      },\n    },\n  }),\n} satisfies Lists",
            "cost": 0.041510000000000005
        },
        "keystonejs__keystone.052f5b1b/packages/core/src/fields/types/checkbox/views/index.tsx": {
            "output": "import { Checkbox } from '@keystar/ui/checkbox'\nimport { Icon } from '@keystar/ui/icon'\nimport { checkIcon } from '@keystar/ui/icon/icons/checkIcon'\nimport { Text, VisuallyHidden } from '@keystar/ui/typography'\n\nimport type {\n  CellComponent,\n  FieldController,\n  FieldControllerConfig,\n  FieldProps,\n  SimpleFieldTypeInfo,\n} from '../../../../types'\nimport { entriesTyped } from '../../../../lib/core/utils'\n\nexport function Field({ field, value, onChange, autoFocus }: FieldProps<typeof controller>) {\n  return (\n    <Checkbox\n      autoFocus={autoFocus}\n      isReadOnly={onChange == null}\n      isSelected={value}\n      onChange={onChange}\n    >\n      <Text>{field.label}</Text>\n      {field.description && <Text slot=\"description\">{field.description}</Text>}\n    </Checkbox>\n  )\n}\n\nexport const Cell: CellComponent<typeof controller> = ({ value }) => {\n  return value ? <Icon src={checkIcon} aria-label=\"true\" /> : <VisuallyHidden>false</VisuallyHidden>\n}\n\ntype CheckboxController = FieldController<\n  boolean,\n  boolean,\n  SimpleFieldTypeInfo<'Boolean'>['inputs']['where']\n>\n\nexport function controller(\n  config: FieldControllerConfig<{ defaultValue: boolean }>\n): CheckboxController {\n  return {\n    fieldKey: config.fieldKey,\n    label: config.label,\n    description: config.description,\n    defaultValue: config.fieldMeta.defaultValue,\n    deserialize(item) {\n      const value = item[config.fieldKey]\n      return typeof value === 'boolean' ? value : false\n    },\n    serialize(value) {\n      return { [config.fieldKey]: value }\n    },\n    graphqlSelection: config.fieldKey,\n    filter: {\n      Filter(props) {\n        const { autoFocus, context, typeLabel, onChange, value, type, ...otherProps } = props\n        return (\n          <Checkbox autoFocus={autoFocus} onChange={onChange} isSelected={value} {...otherProps}>\n            {typeLabel} {config.label.toLocaleLowerCase()}\n          </Checkbox>\n        )\n      },\n      Label({ label, type, value }) {\n        return `${label.toLowerCase()} ${value ? 'true' : 'false'}`\n      },\n      graphql({ type, value }) {\n        return {\n          [config.fieldKey]: {\n            equals: type === 'not' ? !value : value,\n          },\n        }\n      },\n      parseGraphQL: value => {\n        return entriesTyped(value).flatMap(([type, value]) => {\n          if (value == null) return []\n          if (type === 'equals') return { type: 'is', value }\n          if (type === 'not') {\n            if (value.equals == null) return []\n            return { type: 'not', value: value.equals }\n          }\n          return []\n        })\n      },\n      types: {\n        is: {\n          label: 'Is',\n          initialValue: true,\n        },\n        not: {\n          label: 'Is not',\n          initialValue: true,\n        },\n      },\n    },\n  }\n}",
            "output_extracted": "import { Checkbox } from '@keystar/ui/checkbox'\nimport { Icon } from '@keystar/ui/icon'\nimport { checkIcon } from '@keystar/ui/icon/icons/checkIcon'\nimport { Text, VisuallyHidden } from '@keystar/ui/typography'\n\nimport type {\n  CellComponent,\n  FieldController,\n  FieldControllerConfig,\n  FieldProps,\n  SimpleFieldTypeInfo,\n} from '../../../../types'\nimport { entriesTyped } from '../../../../lib/core/utils'\n\nexport function Field({ field, value, onChange, autoFocus }: FieldProps<typeof controller>) {\n  return (\n    <Checkbox\n      autoFocus={autoFocus}\n      isReadOnly={onChange == null}\n      isSelected={value}\n      onChange={onChange}\n    >\n      <Text>{field.label}</Text>\n      {field.description && <Text slot=\"description\">{field.description}</Text>}\n    </Checkbox>\n  )\n}\n\nexport const Cell: CellComponent<typeof controller> = ({ value }) => {\n  return value ? <Icon src={checkIcon} aria-label=\"true\" /> : <VisuallyHidden>false</VisuallyHidden>\n}\n\ntype CheckboxController = FieldController<\n  boolean,\n  boolean,\n  SimpleFieldTypeInfo<'Boolean'>['inputs']['where']\n>\n\nexport function controller(\n  config: FieldControllerConfig<{ defaultValue: boolean }>\n): CheckboxController {\n  return {\n    fieldKey: config.fieldKey,\n    label: config.label,\n    description: config.description,\n    defaultValue: config.fieldMeta.defaultValue,\n    deserialize(item) {\n      const value = item[config.fieldKey]\n      return typeof value === 'boolean' ? value : false\n    },\n    serialize(value) {\n      return { [config.fieldKey]: value }\n    },\n    graphqlSelection: config.fieldKey,\n    filter: {\n      Filter(props) {\n        const { autoFocus, context, typeLabel, onChange, value, type, ...otherProps } = props\n        return (\n          <Checkbox autoFocus={autoFocus} onChange={onChange} isSelected={value} {...otherProps}>\n            {typeLabel} {config.label.toLocaleLowerCase()}\n          </Checkbox>\n        )\n      },\n      Label({ label, type, value }) {\n        return `${label.toLowerCase()} ${value ? 'true' : 'false'}`\n      },\n      graphql({ type, value }) {\n        return {\n          [config.fieldKey]: {\n            equals: type === 'not' ? !value : value,\n          },\n        }\n      },\n      parseGraphQL: value => {\n        return entriesTyped(value).flatMap(([type, value]) => {\n          if (value == null) return []\n          if (type === 'equals') return { type: 'is', value }\n          if (type === 'not') {\n            if (value.equals == null) return []\n            return { type: 'not', value: value.equals }\n          }\n          return []\n        })\n      },\n      types: {\n        is: {\n          label: 'Is',\n          initialValue: true,\n        },\n        not: {\n          label: 'Is not',\n          initialValue: true,\n        },\n      },\n    },\n  }\n}",
            "cost": 0.030165000000000004
        },
        "keystonejs__keystone.052f5b1b/packages/core/src/lib/admin-meta-graphql.ts": {
            "output": "import { QueryMode } from '../types'\nimport { g } from '../types/schema'\nimport type { GraphQLNames } from '../types/utils'\nimport type {\n  ActionMetaSource,\n  AdminMetaSource,\n  FieldMetaSource,\n  ListMetaSource,\n} from './admin-meta'\n\nconst KeystoneAdminUIFieldMeta = g.object<FieldMetaSource>()({\n  name: 'KeystoneAdminUIFieldMeta',\n  fields: {\n    key: g.field({ type: g.nonNull(g.String) }),\n    label: g.field({ type: g.nonNull(g.String) }),\n    description: g.field({ type: g.String }),\n    isOrderable: g.field({ type: g.nonNull(g.Boolean) }),\n    isFilterable: g.field({ type: g.nonNull(g.Boolean) }),\n    isNonNull: g.field({\n      type: g.list(\n        g.nonNull(\n          g.enum({\n            name: 'KeystoneAdminUIFieldMetaIsNonNull',\n            values: g.enumValues(['read', 'create', 'update']),\n          })\n        )\n      ),\n    }),\n    fieldMeta: g.field({ type: g.JSON }),\n    viewsIndex: g.field({ type: g.nonNull(g.Int) }),\n    customViewsIndex: g.field({ type: g.Int }),\n    createView: g.field({\n      type: g.nonNull(\n        g.object<FieldMetaSource['createView']>()({\n          name: 'KeystoneAdminUIFieldMetaCreateView',\n          fields: {\n            fieldMode: g.field({\n              type: g.nonNull(g.JSON),\n            }),\n            isRequired: g.field({\n              type: g.nonNull(g.JSON),\n            }),\n          },\n        })\n      ),\n    }),\n    itemView: g.field({\n      resolve: args => args,\n      type: g.object<FieldMetaSource>()({\n        name: 'KeystoneAdminUIFieldMetaItemView',\n        fields: {\n          fieldMode: g.field({\n            type: g.nonNull(g.JSON),\n            async resolve({ listKey, fieldKey, itemView, item, itemField }, _, context) {\n              const { fieldMode } = itemView\n              if (typeof fieldMode !== 'function') return fieldMode\n              return fieldMode({\n                session: context.session,\n                context,\n                listKey,\n                fieldKey,\n                item,\n                itemField,\n              })\n            },\n          }),\n          fieldPosition: g.field({\n            type: g.nonNull(\n              g.enum({\n                name: 'KeystoneAdminUIFieldMetaItemViewFieldPosition',\n                values: g.enumValues(['form', 'sidebar']),\n              })\n            ),\n            async resolve({ listKey, fieldKey, itemView, item, itemField }, _, context) {\n              const { fieldPosition } = itemView\n              if (typeof fieldPosition !== 'function') return fieldPosition\n              return fieldPosition({\n                session: context.session,\n                context,\n                listKey,\n                fieldKey,\n                item,\n                itemField,\n              })\n            },\n          }),\n          isRequired: g.field({\n            type: g.nonNull(g.JSON),\n            resolve({ item, fieldKey, itemView, itemField, listKey }, _, context) {\n              const { isRequired } = itemView\n              if (typeof isRequired !== 'function') return isRequired\n              return isRequired({\n                session: context.session,\n                context,\n                listKey,\n                fieldKey,\n                item,\n                itemField,\n              })\n            },\n          }),\n        },\n      }),\n    }),\n    listView: g.field({\n      type: g.nonNull(\n        g.object<FieldMetaSource['listView']>()({\n          name: 'KeystoneAdminUIFieldMetaListView',\n          fields: {\n            fieldMode: g.field({\n              type: g.nonNull(\n                g.enum({\n                  name: 'KeystoneAdminUIFieldMetaListViewFieldMode',\n                  values: g.enumValues(['read', 'hidden']),\n                })\n              ),\n            }),\n          },\n        })\n      ),\n    }),\n    search: g.field({\n      type: QueryMode,\n    }),\n  },\n})\n\nconst KeystoneAdminUIActionMeta = g.object<ActionMetaSource>()({\n  name: 'KeystoneAdminUIActionMeta',\n  fields: {\n    key: g.field({ type: g.nonNull(g.String) }),\n    label: g.field({ type: g.nonNull(g.String) }),\n    icon: g.field({ type: g.String }),\n    messages: g.field({\n      type: g.nonNull(\n        g.object<ActionMetaSource['messages']>()({\n          name: 'KeystoneAdminUIActionMetaMessages',\n          fields: {\n            promptTitle: g.field({ type: g.nonNull(g.String) }),\n            promptTitleMany: g.field({ type: g.String }),\n            prompt: g.field({ type: g.nonNull(g.String) }),\n            promptMany: g.field({ type: g.String }),\n            promptConfirmLabel: g.field({ type: g.nonNull(g.String) }),\n            promptConfirmLabelMany: g.field({ type: g.String }),\n            fail: g.field({ type: g.nonNull(g.String) }),\n            failMany: g.field({ type: g.String }),\n            success: g.field({ type: g.nonNull(g.String) }),\n            successMany: g.field({ type: g.String }),\n          },\n        })\n      ),\n    }),\n    graphql: g.field({\n      type: g.object<ActionMetaSource['graphql']>()({\n        name: 'KeystoneAdminUIActionMetaGraphQL',\n        fields: {\n          names: g.field({\n            type: g.nonNull(\n              g.object<ActionMetaSource['graphql']['names']>()({\n                name: 'KeystoneAdminUIActionMetaGraphQLNames',\n                fields: {\n                  one: g.field({ type: g.nonNull(g.String) }),\n                  many: g.field({ type: g.String }),\n                },\n              })\n            ),\n          }),\n        },\n      }),\n    }),\n    itemView: g.field({\n      resolve: args => args,\n      type: g.object<ActionMetaSource>()({\n        name: 'KeystoneAdminUIActionMetaItemView',\n        fields: {\n          actionMode: g.field({\n            type: g.nonNull(g.JSON),\n            async resolve({ listKey, key, itemView, item }, _, context) {\n              const { actionMode } = itemView\n              if (typeof actionMode !== 'function') return actionMode\n              return actionMode({\n                session: context.session,\n                context,\n                listKey,\n                actionKey: key,\n                item,\n              })\n            },\n          }),\n          navigation: g.field({\n            type: g.nonNull(\n              g.enum({\n                name: 'KeystoneAdminUIActionMetaItemViewNavigation',\n                values: g.enumValues(['follow', 'refetch', 'return']),\n              })\n            ),\n            resolve({ itemView }) {\n              return itemView.navigation\n            },\n          }),\n          hidePrompt: g.field({\n            type: g.nonNull(g.Boolean),\n            resolve({ itemView }) {\n              return itemView.hidePrompt\n            },\n          }),\n          hideToast: g.field({\n            type: g.nonNull(g.Boolean),\n            resolve({ itemView }) {\n              return itemView.hideToast\n            },\n          }),\n        },\n      }),\n    }),\n    listView: g.field({\n      type: g.nonNull(\n        g.object<ActionMetaSource['listView']>()({\n          name: 'KeystoneAdminUIActionMetaListView',\n          fields: {\n            actionMode: g.field({\n              type: g.nonNull(\n                g.enum({\n                  name: 'KeystoneAdminUIActionMetaListViewActionMode',\n                  values: g.enumValues(['enabled', 'hidden']),\n                })\n              ),\n            }),\n          },\n        })\n      ),\n    }),\n  },\n})\n\nconst KeystoneAdminUIFieldGroupMeta = g.object<{\n  label: string\n  description: string | null\n  fields: FieldMetaSource[]\n}>()({\n  name: 'KeystoneAdminUIFieldGroupMeta',\n  fields: {\n    label: g.field({ type: g.nonNull(g.String) }),\n    description: g.field({ type: g.String }),\n    fields: g.field({\n      type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldMeta))),\n    }),\n  },\n})\n\nconst KeystoneAdminUISort = g.object<NonNullable<ListMetaSource['initialSort']>>()({\n  name: 'KeystoneAdminUISort',\n  fields: {\n    field: g.field({ type: g.nonNull(g.String) }),\n    direction: g.field({\n      type: g.nonNull(\n        g.enum({\n          name: 'KeystoneAdminUISortDirection',\n          values: g.enumValues(['ASC', 'DESC']),\n        })\n      ),\n    }),\n  },\n})\n\nconst KeystoneAdminUIGraphQL = g.object<any>()({\n  name: 'KeystoneAdminUIGraphQL',\n  fields: {\n    names: g.field({\n      type: g.nonNull(\n        g.object<GraphQLNames>()({\n          name: 'KeystoneAdminUIGraphQLNames',\n          fields: {\n            outputTypeName: g.field({ type: g.nonNull(g.String) }),\n            whereInputName: g.field({ type: g.nonNull(g.String) }),\n            whereUniqueInputName: g.field({ type: g.nonNull(g.String) }),\n\n            // create\n            createInputName: g.field({ type: g.nonNull(g.String) }),\n            createMutationName: g.field({ type: g.nonNull(g.String) }),\n            createManyMutationName: g.field({ type: g.nonNull(g.String) }),\n            relateToOneForCreateInputName: g.field({ type: g.nonNull(g.String) }),\n            relateToManyForCreateInputName: g.field({ type: g.nonNull(g.String) }),\n\n            // read\n            itemQueryName: g.field({ type: g.nonNull(g.String) }),\n            listOrderName: g.field({ type: g.nonNull(g.String) }),\n            listQueryCountName: g.field({ type: g.nonNull(g.String) }),\n            listQueryName: g.field({ type: g.nonNull(g.String) }),\n\n            // update\n            updateInputName: g.field({ type: g.nonNull(g.String) }),\n            updateMutationName: g.field({ type: g.nonNull(g.String) }),\n            updateManyInputName: g.field({ type: g.nonNull(g.String) }),\n            updateManyMutationName: g.field({ type: g.nonNull(g.String) }),\n            relateToOneForUpdateInputName: g.field({ type: g.nonNull(g.String) }),\n            relateToManyForUpdateInputName: g.field({ type: g.nonNull(g.String) }),\n\n            // delete\n            deleteMutationName: g.field({ type: g.nonNull(g.String) }),\n            deleteManyMutationName: g.field({ type: g.nonNull(g.String) }),\n          },\n        })\n      ),\n    }),\n  },\n})\n\nconst KeystoneAdminUIListMeta = g.object<ListMetaSource>()({\n  name: 'KeystoneAdminUIListMeta',\n  fields: {\n    key: g.field({ type: g.nonNull(g.String) }),\n    label: g.field({ type: g.nonNull(g.String) }),\n    singular: g.field({ type: g.nonNull(g.String) }),\n    plural: g.field({ type: g.nonNull(g.String) }),\n    path: g.field({ type: g.nonNull(g.String) }),\n\n    labelField: g.field({ type: g.nonNull(g.String) }),\n    fields: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldMeta))) }),\n    groups: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldGroupMeta))) }),\n    actions: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIActionMeta))) }),\n    graphql: g.field({ type: g.nonNull(KeystoneAdminUIGraphQL) }),\n\n    pageSize: g.field({ type: g.nonNull(g.Int) }),\n    initialColumns: g.field({ type: g.nonNull(g.list(g.nonNull(g.String))) }),\n    initialSearchFields: g.field({ type: g.nonNull(g.list(g.nonNull(g.String))) }),\n    initialSort: g.field({ type: KeystoneAdminUISort }),\n    initialFilter: g.field({ type: g.JSON }),\n    isSingleton: g.field({ type: g.nonNull(g.Boolean) }),\n    hideNavigation: g.field({ type: g.nonNull(g.Boolean) }),\n    hideCreate: g.field({ type: g.nonNull(g.Boolean) }),\n    hideDelete: g.field({ type: g.nonNull(g.Boolean) }),\n  },\n})\n\nconst adminMeta = g.object<AdminMetaSource>()({\n  name: 'KeystoneAdminMeta',\n  fields: {\n    lists: g.field({\n      type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIListMeta))),\n    }),\n    list: g.field({\n      type: KeystoneAdminUIListMeta,\n      args: {\n        key: g.arg({ type: g.nonNull(g.String) }),\n        itemId: g.arg({ type: g.ID }),\n      },\n      async resolve(source, { key, itemId }, context) {\n        if (itemId === null || itemId === undefined) {\n          return {\n            ...source.listsByKey[key],\n            item: null,\n          }\n        }\n        const item = await context.db[key].findOne({ where: { id: itemId } })\n        if (!item) return null\n        return {\n          ...source.listsByKey[key],\n          item,\n        }\n      },\n    }),\n  },\n})\n\nexport const KeystoneMeta = g.object<{ adminMeta: AdminMetaSource }>()({\n  name: 'KeystoneMeta',\n  fields: {\n    adminMeta: g.field({\n      type: g.nonNull(adminMeta),\n      async resolve({ adminMeta }, _, context) {\n        if (context.__internal.sudo) return adminMeta\n\n        const isAllowed = await adminMeta.isAccessAllowed(context)\n        if (isAllowed) return adminMeta\n\n        // TODO: we need better errors\n        throw new Error('Access denied')\n      },\n    }),\n  },\n})",
            "output_extracted": "import { QueryMode } from '../types'\nimport { g } from '../types/schema'\nimport type { GraphQLNames } from '../types/utils'\nimport type {\n  ActionMetaSource,\n  AdminMetaSource,\n  FieldMetaSource,\n  ListMetaSource,\n} from './admin-meta'\n\nconst KeystoneAdminUIFieldMeta = g.object<FieldMetaSource>()({\n  name: 'KeystoneAdminUIFieldMeta',\n  fields: {\n    key: g.field({ type: g.nonNull(g.String) }),\n    label: g.field({ type: g.nonNull(g.String) }),\n    description: g.field({ type: g.String }),\n    isOrderable: g.field({ type: g.nonNull(g.Boolean) }),\n    isFilterable: g.field({ type: g.nonNull(g.Boolean) }),\n    isNonNull: g.field({\n      type: g.list(\n        g.nonNull(\n          g.enum({\n            name: 'KeystoneAdminUIFieldMetaIsNonNull',\n            values: g.enumValues(['read', 'create', 'update']),\n          })\n        )\n      ),\n    }),\n    fieldMeta: g.field({ type: g.JSON }),\n    viewsIndex: g.field({ type: g.nonNull(g.Int) }),\n    customViewsIndex: g.field({ type: g.Int }),\n    createView: g.field({\n      type: g.nonNull(\n        g.object<FieldMetaSource['createView']>()({\n          name: 'KeystoneAdminUIFieldMetaCreateView',\n          fields: {\n            fieldMode: g.field({\n              type: g.nonNull(g.JSON),\n            }),\n            isRequired: g.field({\n              type: g.nonNull(g.JSON),\n            }),\n          },\n        })\n      ),\n    }),\n    itemView: g.field({\n      resolve: args => args,\n      type: g.object<FieldMetaSource>()({\n        name: 'KeystoneAdminUIFieldMetaItemView',\n        fields: {\n          fieldMode: g.field({\n            type: g.nonNull(g.JSON),\n            async resolve({ listKey, fieldKey, itemView, item, itemField }, _, context) {\n              const { fieldMode } = itemView\n              if (typeof fieldMode !== 'function') return fieldMode\n              return fieldMode({\n                session: context.session,\n                context,\n                listKey,\n                fieldKey,\n                item,\n                itemField,\n              })\n            },\n          }),\n          fieldPosition: g.field({\n            type: g.nonNull(\n              g.enum({\n                name: 'KeystoneAdminUIFieldMetaItemViewFieldPosition',\n                values: g.enumValues(['form', 'sidebar']),\n              })\n            ),\n            async resolve({ listKey, fieldKey, itemView, item, itemField }, _, context) {\n              const { fieldPosition } = itemView\n              if (typeof fieldPosition !== 'function') return fieldPosition\n              return fieldPosition({\n                session: context.session,\n                context,\n                listKey,\n                fieldKey,\n                item,\n                itemField,\n              })\n            },\n          }),\n          isRequired: g.field({\n            type: g.nonNull(g.JSON),\n            resolve({ item, fieldKey, itemView, itemField, listKey }, _, context) {\n              const { isRequired } = itemView\n              if (typeof isRequired !== 'function') return isRequired\n              return isRequired({\n                session: context.session,\n                context,\n                listKey,\n                fieldKey,\n                item,\n                itemField,\n              })\n            },\n          }),\n        },\n      }),\n    }),\n    listView: g.field({\n      type: g.nonNull(\n        g.object<FieldMetaSource['listView']>()({\n          name: 'KeystoneAdminUIFieldMetaListView',\n          fields: {\n            fieldMode: g.field({\n              type: g.nonNull(\n                g.enum({\n                  name: 'KeystoneAdminUIFieldMetaListViewFieldMode',\n                  values: g.enumValues(['read', 'hidden']),\n                })\n              ),\n            }),\n          },\n        })\n      ),\n    }),\n    search: g.field({\n      type: QueryMode,\n    }),\n  },\n})\n\nconst KeystoneAdminUIActionMeta = g.object<ActionMetaSource>()({\n  name: 'KeystoneAdminUIActionMeta',\n  fields: {\n    key: g.field({ type: g.nonNull(g.String) }),\n    label: g.field({ type: g.nonNull(g.String) }),\n    icon: g.field({ type: g.String }),\n    messages: g.field({\n      type: g.nonNull(\n        g.object<ActionMetaSource['messages']>()({\n          name: 'KeystoneAdminUIActionMetaMessages',\n          fields: {\n            promptTitle: g.field({ type: g.nonNull(g.String) }),\n            promptTitleMany: g.field({ type: g.String }),\n            prompt: g.field({ type: g.nonNull(g.String) }),\n            promptMany: g.field({ type: g.String }),\n            promptConfirmLabel: g.field({ type: g.nonNull(g.String) }),\n            promptConfirmLabelMany: g.field({ type: g.String }),\n            fail: g.field({ type: g.nonNull(g.String) }),\n            failMany: g.field({ type: g.String }),\n            success: g.field({ type: g.nonNull(g.String) }),\n            successMany: g.field({ type: g.String }),\n          },\n        })\n      ),\n    }),\n    graphql: g.field({\n      type: g.object<ActionMetaSource['graphql']>()({\n        name: 'KeystoneAdminUIActionMetaGraphQL',\n        fields: {\n          names: g.field({\n            type: g.nonNull(\n              g.object<ActionMetaSource['graphql']['names']>()({\n                name: 'KeystoneAdminUIActionMetaGraphQLNames',\n                fields: {\n                  one: g.field({ type: g.nonNull(g.String) }),\n                  many: g.field({ type: g.String }),\n                },\n              })\n            ),\n          }),\n        },\n      }),\n    }),\n    itemView: g.field({\n      resolve: args => args,\n      type: g.object<ActionMetaSource>()({\n        name: 'KeystoneAdminUIActionMetaItemView',\n        fields: {\n          actionMode: g.field({\n            type: g.nonNull(g.JSON),\n            async resolve({ listKey, key, itemView, item }, _, context) {\n              const { actionMode } = itemView\n              if (typeof actionMode !== 'function') return actionMode\n              return actionMode({\n                session: context.session,\n                context,\n                listKey,\n                actionKey: key,\n                item,\n              })\n            },\n          }),\n          navigation: g.field({\n            type: g.nonNull(\n              g.enum({\n                name: 'KeystoneAdminUIActionMetaItemViewNavigation',\n                values: g.enumValues(['follow', 'refetch', 'return']),\n              })\n            ),\n            resolve({ itemView }) {\n              return itemView.navigation\n            },\n          }),\n          hidePrompt: g.field({\n            type: g.nonNull(g.Boolean),\n            resolve({ itemView }) {\n              return itemView.hidePrompt\n            },\n          }),\n          hideToast: g.field({\n            type: g.nonNull(g.Boolean),\n            resolve({ itemView }) {\n              return itemView.hideToast\n            },\n          }),\n        },\n      }),\n    }),\n    listView: g.field({\n      type: g.nonNull(\n        g.object<ActionMetaSource['listView']>()({\n          name: 'KeystoneAdminUIActionMetaListView',\n          fields: {\n            actionMode: g.field({\n              type: g.nonNull(\n                g.enum({\n                  name: 'KeystoneAdminUIActionMetaListViewActionMode',\n                  values: g.enumValues(['enabled', 'hidden']),\n                })\n              ),\n            }),\n          },\n        })\n      ),\n    }),\n  },\n})\n\nconst KeystoneAdminUIFieldGroupMeta = g.object<{\n  label: string\n  description: string | null\n  fields: FieldMetaSource[]\n}>()({\n  name: 'KeystoneAdminUIFieldGroupMeta',\n  fields: {\n    label: g.field({ type: g.nonNull(g.String) }),\n    description: g.field({ type: g.String }),\n    fields: g.field({\n      type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldMeta))),\n    }),\n  },\n})\n\nconst KeystoneAdminUISort = g.object<NonNullable<ListMetaSource['initialSort']>>()({\n  name: 'KeystoneAdminUISort',\n  fields: {\n    field: g.field({ type: g.nonNull(g.String) }),\n    direction: g.field({\n      type: g.nonNull(\n        g.enum({\n          name: 'KeystoneAdminUISortDirection',\n          values: g.enumValues(['ASC', 'DESC']),\n        })\n      ),\n    }),\n  },\n})\n\nconst KeystoneAdminUIGraphQL = g.object<any>()({\n  name: 'KeystoneAdminUIGraphQL',\n  fields: {\n    names: g.field({\n      type: g.nonNull(\n        g.object<GraphQLNames>()({\n          name: 'KeystoneAdminUIGraphQLNames',\n          fields: {\n            outputTypeName: g.field({ type: g.nonNull(g.String) }),\n            whereInputName: g.field({ type: g.nonNull(g.String) }),\n            whereUniqueInputName: g.field({ type: g.nonNull(g.String) }),\n\n            // create\n            createInputName: g.field({ type: g.nonNull(g.String) }),\n            createMutationName: g.field({ type: g.nonNull(g.String) }),\n            createManyMutationName: g.field({ type: g.nonNull(g.String) }),\n            relateToOneForCreateInputName: g.field({ type: g.nonNull(g.String) }),\n            relateToManyForCreateInputName: g.field({ type: g.nonNull(g.String) }),\n\n            // read\n            itemQueryName: g.field({ type: g.nonNull(g.String) }),\n            listOrderName: g.field({ type: g.nonNull(g.String) }),\n            listQueryCountName: g.field({ type: g.nonNull(g.String) }),\n            listQueryName: g.field({ type: g.nonNull(g.String) }),\n\n            // update\n            updateInputName: g.field({ type: g.nonNull(g.String) }),\n            updateMutationName: g.field({ type: g.nonNull(g.String) }),\n            updateManyInputName: g.field({ type: g.nonNull(g.String) }),\n            updateManyMutationName: g.field({ type: g.nonNull(g.String) }),\n            relateToOneForUpdateInputName: g.field({ type: g.nonNull(g.String) }),\n            relateToManyForUpdateInputName: g.field({ type: g.nonNull(g.String) }),\n\n            // delete\n            deleteMutationName: g.field({ type: g.nonNull(g.String) }),\n            deleteManyMutationName: g.field({ type: g.nonNull(g.String) }),\n          },\n        })\n      ),\n    }),\n  },\n})\n\nconst KeystoneAdminUIListMeta = g.object<ListMetaSource>()({\n  name: 'KeystoneAdminUIListMeta',\n  fields: {\n    key: g.field({ type: g.nonNull(g.String) }),\n    label: g.field({ type: g.nonNull(g.String) }),\n    singular: g.field({ type: g.nonNull(g.String) }),\n    plural: g.field({ type: g.nonNull(g.String) }),\n    path: g.field({ type: g.nonNull(g.String) }),\n\n    labelField: g.field({ type: g.nonNull(g.String) }),\n    fields: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldMeta))) }),\n    groups: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldGroupMeta))) }),\n    actions: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIActionMeta))) }),\n    graphql: g.field({ type: g.nonNull(KeystoneAdminUIGraphQL) }),\n\n    pageSize: g.field({ type: g.nonNull(g.Int) }),\n    initialColumns: g.field({ type: g.nonNull(g.list(g.nonNull(g.String))) }),\n    initialSearchFields: g.field({ type: g.nonNull(g.list(g.nonNull(g.String))) }),\n    initialSort: g.field({ type: KeystoneAdminUISort }),\n    initialFilter: g.field({ type: g.JSON }),\n    isSingleton: g.field({ type: g.nonNull(g.Boolean) }),\n    hideNavigation: g.field({ type: g.nonNull(g.Boolean) }),\n    hideCreate: g.field({ type: g.nonNull(g.Boolean) }),\n    hideDelete: g.field({ type: g.nonNull(g.Boolean) }),\n  },\n})\n\nconst adminMeta = g.object<AdminMetaSource>()({\n  name: 'KeystoneAdminMeta',\n  fields: {\n    lists: g.field({\n      type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIListMeta))),\n    }),\n    list: g.field({\n      type: KeystoneAdminUIListMeta,\n      args: {\n        key: g.arg({ type: g.nonNull(g.String) }),\n        itemId: g.arg({ type: g.ID }),\n      },\n      async resolve(source, { key, itemId }, context) {\n        if (itemId === null || itemId === undefined) {\n          return {\n            ...source.listsByKey[key],\n            item: null,\n          }\n        }\n        const item = await context.db[key].findOne({ where: { id: itemId } })\n        if (!item) return null\n        return {\n          ...source.listsByKey[key],\n          item,\n        }\n      },\n    }),\n  },\n})\n\nexport const KeystoneMeta = g.object<{ adminMeta: AdminMetaSource }>()({\n  name: 'KeystoneMeta',\n  fields: {\n    adminMeta: g.field({\n      type: g.nonNull(adminMeta),\n      async resolve({ adminMeta }, _, context) {\n        if (context.__internal.sudo) return adminMeta\n\n        const isAllowed = await adminMeta.isAccessAllowed(context)\n        if (isAllowed) return adminMeta\n\n        // TODO: we need better errors\n        throw new Error('Access denied')\n      },\n    }),\n  },\n})",
            "cost": 0.12552
        },
        "keystonejs__keystone.052f5b1b/tests2/omit.test.ts": {
            "output": "import assert from 'node:assert/strict'\nimport { describe, test } from 'node:test'\nimport { relationship, text } from '@keystone-6/core/fields'\nimport { list } from '@keystone-6/core'\nimport { allowAll } from '@keystone-6/core/access'\nimport type { KeystoneContext } from '@keystone-6/core/types'\nimport { setupTestSuite, dbProvider } from './utils'\n\nfunction yn(x: boolean) {\n  return x ? '1' : '0'\n}\n\nfunction makeField({\n  isFilterable,\n  isOrderable,\n  omit,\n}: {\n  isFilterable: boolean\n  isOrderable: boolean\n  omit:\n    | boolean\n    | {\n        read: boolean\n        create: boolean\n        update: boolean\n      }\n}) {\n  const suffix = [\n    `Filt${yn(isFilterable)}`,\n    `Ord${yn(isOrderable)}`,\n    `Omit${\n      typeof omit !== 'object' ? yn(omit) : [omit.read, omit.create, omit.update].map(yn).join('')\n    }`,\n  ].join('')\n\n  return [\n    `Field_${suffix}`,\n    text({\n      graphql: { omit },\n      isFilterable,\n      isOrderable,\n    }),\n  ] as const\n}\n\nconst fieldsMatrix = [\n  ...(function* () {\n    for (const isFilterable of [false, true]) {\n      for (const isOrderable of [false, true]) {\n        for (const omit of [false, true]) {\n          yield makeField({ isFilterable, isOrderable, omit })\n        }\n\n        for (const read of [false, true]) {\n          for (const create of [false, true]) {\n            for (const update of [false, true]) {\n              yield makeField({\n                isFilterable,\n                isOrderable,\n                omit: {\n                  read,\n                  create,\n                  update,\n                },\n              })\n            }\n          }\n        }\n      }\n    }\n  })(),\n]\n\nfunction makeList({\n  fields,\n  isFilterable,\n  isOrderable,\n  omit,\n}: {\n  fields: typeof fieldsMatrix\n  isFilterable: boolean\n  isOrderable: boolean\n  omit:\n    | boolean\n    | {\n        query: boolean\n        create: boolean\n        update: boolean\n        delete: boolean\n      }\n}) {\n  const prefix = `List${fields.length}_Filt${yn(isFilterable)}_Ord${yn(isOrderable)}` as const\n  const __name = `${prefix}_Omit${\n    typeof omit !== 'object'\n      ? yn(omit)\n      : [omit.query, omit.create, omit.update, omit.delete].map(yn).join('')\n  }`\n\n  return {\n    __name,\n    access: allowAll,\n    fields: Object.fromEntries(fields),\n    defaultIsFilterable: isFilterable,\n    defaultIsOrderable: isOrderable,\n    graphql: {\n      plural: __name + 's',\n      omit,\n    },\n  } as const\n}\n\nconst listsMatrix = [\n  ...(function* () {\n    for (const isFilterable of [false, true]) {\n      for (const isOrderable of [false, true]) {\n        for (const omit of [false, true]) {\n          yield makeList({ fields: fieldsMatrix, isFilterable, isOrderable, omit })\n        }\n\n        for (const query of [false, true]) {\n          for (const create of [false, true]) {\n            for (const update of [false, true]) {\n              for (const delete_ of [false, true]) {\n                yield makeList({\n                  fields: fieldsMatrix,\n                  isFilterable,\n                  isOrderable,\n                  omit: {\n                    query,\n                    create,\n                    update,\n                    delete: delete_,\n                  },\n                })\n\n                yield makeList({\n                  fields: [],\n                  isFilterable,\n                  isOrderable,\n                  omit: {\n                    query,\n                    create,\n                    update,\n                    delete: delete_,\n                  },\n                })\n              }\n            }\n          }\n        }\n      }\n    }\n  })(),\n]\n\n// TODO: FIXME: skip for now, MySQL has a limit on the number of indexes\nif (dbProvider !== 'mysql') {\n  listsMatrix.push({\n    __name: 'RelatedToAll',\n    access: allowAll,\n    fields: Object.fromEntries(\n      (function* () {\n        for (const l of listsMatrix) {\n          // WARNING: if names exceed some length, expect duplicate _AB_unique index errors\n          yield [\n            `R${l.__name}_one`,\n            relationship({\n              ref: l.__name,\n              many: false,\n            }),\n          ] as const\n\n          yield [\n            `R${l.__name}_many`,\n            relationship({\n              ref: l.__name,\n              many: true,\n            }),\n          ] as const\n        }\n      })()\n    ),\n    defaultIsFilterable: true,\n    defaultIsOrderable: true,\n    graphql: {\n      plural: 'RelatedToAlls',\n      omit: false,\n    },\n  })\n}\n\nasync function introspectSchema(context: KeystoneContext) {\n  const data = await context.graphql.run<\n    {\n      __schema: {\n        types: {\n          name: string\n          fields: {\n            name: string\n          }[]\n        }[]\n        queryType: {\n          fields: {\n            name: string\n          }[]\n        }\n        mutationType: {\n          fields: {\n            name: string\n          }[]\n        }\n      }\n      keystone: {\n        adminMeta: {\n          lists: {\n            key: string\n          }[]\n        }\n      }\n    },\n    any\n  >({\n    query: `{\n      __schema {\n        types {\n          name\n          fields {\n            name\n          }\n        }\n        queryType {\n          fields {\n            name\n          }\n        }\n        mutationType {\n          fields {\n            name\n          }\n        }\n      }\n      keystone {\n        adminMeta {\n          lists {\n            key\n          }\n        }\n      }\n    }`,\n  })\n\n  return {\n    queries: data.__schema.queryType.fields.map(x => x.name.toLowerCase()),\n    mutations: data.__schema.mutationType.fields.map(x => x.name.toLowerCase()),\n    adminMetaLists: data.keystone.adminMeta.lists.map(x => x.key.toLowerCase()),\n    schemaTypes: data.__schema.types.map(x => x.name.toLowerCase()),\n  }\n}\n\ndescribe(`Omit (${dbProvider})`, () => {\n  function testOmit(\n    listName_: string,\n    d: ReturnType<typeof introspectSchema>,\n    expected: {\n      type: boolean\n      meta: boolean\n      query: boolean\n      create: boolean\n      update: boolean\n      delete: boolean\n    }\n  ) {\n    const listName = listName_.toLowerCase()\n\n    if (expected.query)\n      test('does have find', async () => assert.ok((await d).queries.includes(listName)))\n    if (expected.query)\n      test('does have findMany', async () => assert.ok((await d).queries.includes(listName + 's')))\n    if (expected.create)\n      test('does have create', async () =>\n        assert.ok((await d).mutations.includes(`create${listName}`)))\n    if (expected.create)\n      test('does have createMany', async () =>\n        assert.ok((await d).mutations.includes(`create${listName}s`)))\n    if (expected.update)\n      test('does have update', async () =>\n        assert.ok((await d).mutations.includes(`update${listName}`)))\n    if (expected.update)\n      test('does have updateMany', async () =>\n        assert.ok((await d).mutations.includes(`update${listName}s`)))\n    if (expected.delete)\n      test('does have delete', async () =>\n        assert.ok((await d).mutations.includes(`delete${listName}`)))\n    if (expected.delete)\n      test('does have deleteMany', async () =>\n        assert.ok((await d).mutations.includes(`delete${listName}s`)))\n    if (expected.meta)\n      test('does have an Admin meta list entry', async () =>\n        assert.ok((await d).adminMetaLists.includes(listName)))\n    if (expected.type)\n      test('does have a GraphQL schema type', async () =>\n        assert.ok((await d).schemaTypes.includes(listName)))\n\n    if (!expected.query)\n      test('does not have find', async () => assert.ok(!(await d).queries.includes(listName)))\n    if (!expected.query)\n      test('does not have findMany', async () =>\n        assert.ok(!(await d).queries.includes(listName + 's')))\n    if (!expected.create)\n      test('does not have create', async () =>\n        assert.ok(!(await d).mutations.includes(`create${listName}`)))\n    if (!expected.create)\n      test('does not have createMany', async () =>\n        assert.ok(!(await d).mutations.includes(`create${listName}s`)))\n    if (!expected.update)\n      test('does not have update', async () =>\n        assert.ok(!(await d).mutations.includes(`update${listName}`)))\n    if (!expected.update)\n      test('does not have updateMany', async () =>\n        assert.ok(!(await d).mutations.includes(`update${listName}s`)))\n    if (!expected.delete)\n      test('does not have delete', async () =>\n        assert.ok(!(await d).mutations.includes(`delete${listName}`)))\n    if (!expected.delete)\n      test('does not have deleteMany', async () =>\n        assert.ok(!(await d).mutations.includes(`delete${listName}s`)))\n    if (!expected.meta)\n      test('does not have an Admin meta list entry', async () =>\n        assert.ok(!(await d).adminMetaLists.includes(listName)))\n    if (!expected.type)\n      test('does not have a GraphQL schema type', async () =>\n        assert.ok(!(await d).schemaTypes.includes(listName)))\n  }\n\n  const suite = setupTestSuite({\n    config: {\n      lists: Object.fromEntries(listsMatrix.map(({ __name, ...l }) => [__name, list(l)])),\n    },\n  })\n\n  const data = suite().then(async ({ context }) => await introspectSchema(context))\n  const sudoData = suite().then(async ({ context }) => await introspectSchema(context.sudo()))\n\n  for (const l of listsMatrix) {\n    const listName = l.__name\n    const omit = l.graphql.omit\n\n    // common context is configurable\n    describe(`Common context for ${listName}`, () => {\n      if (typeof omit === 'boolean') {\n        testOmit(listName, data, {\n          type: !omit,\n          meta: !omit,\n          query: !omit,\n          create: !omit,\n          update: !omit,\n          delete: !omit,\n        })\n\n        return\n      }\n\n      testOmit(listName, data, {\n        type: true,\n        // TODO: see create-admin-meta.ts#L102\n        meta: !omit.query,\n        query: !omit.query,\n        create: !omit.create,\n        update: !omit.update,\n        delete: !omit.delete,\n      })\n    })\n\n    // internal context is unaffected by graphql.omit\n    describe(`Internal context for ${listName}`, () => {\n      testOmit(listName, dataInternal, {\n        type: true,\n        meta: true,\n        query: true,\n        create: true,\n        update: true,\n        delete: true,\n      })\n    })\n\n    // sudo context is unaffected by graphql.omit\n    describe(`Sudo context for ${listName}`, () => {\n      testOmit(listName, dataSudo, {\n        type: true,\n        meta: true,\n        query: true,\n        create: true,\n        update: true,\n        delete: true,\n      })\n    })\n  }\n})",
            "output_extracted": "import assert from 'node:assert/strict'\nimport { describe, test } from 'node:test'\nimport { relationship, text } from '@keystone-6/core/fields'\nimport { list } from '@keystone-6/core'\nimport { allowAll } from '@keystone-6/core/access'\nimport type { KeystoneContext } from '@keystone-6/core/types'\nimport { setupTestSuite, dbProvider } from './utils'\n\nfunction yn(x: boolean) {\n  return x ? '1' : '0'\n}\n\nfunction makeField({\n  isFilterable,\n  isOrderable,\n  omit,\n}: {\n  isFilterable: boolean\n  isOrderable: boolean\n  omit:\n    | boolean\n    | {\n        read: boolean\n        create: boolean\n        update: boolean\n      }\n}) {\n  const suffix = [\n    `Filt${yn(isFilterable)}`,\n    `Ord${yn(isOrderable)}`,\n    `Omit${\n      typeof omit !== 'object' ? yn(omit) : [omit.read, omit.create, omit.update].map(yn).join('')\n    }`,\n  ].join('')\n\n  return [\n    `Field_${suffix}`,\n    text({\n      graphql: { omit },\n      isFilterable,\n      isOrderable,\n    }),\n  ] as const\n}\n\nconst fieldsMatrix = [\n  ...(function* () {\n    for (const isFilterable of [false, true]) {\n      for (const isOrderable of [false, true]) {\n        for (const omit of [false, true]) {\n          yield makeField({ isFilterable, isOrderable, omit })\n        }\n\n        for (const read of [false, true]) {\n          for (const create of [false, true]) {\n            for (const update of [false, true]) {\n              yield makeField({\n                isFilterable,\n                isOrderable,\n                omit: {\n                  read,\n                  create,\n                  update,\n                },\n              })\n            }\n          }\n        }\n      }\n    }\n  })(),\n]\n\nfunction makeList({\n  fields,\n  isFilterable,\n  isOrderable,\n  omit,\n}: {\n  fields: typeof fieldsMatrix\n  isFilterable: boolean\n  isOrderable: boolean\n  omit:\n    | boolean\n    | {\n        query: boolean\n        create: boolean\n        update: boolean\n        delete: boolean\n      }\n}) {\n  const prefix = `List${fields.length}_Filt${yn(isFilterable)}_Ord${yn(isOrderable)}` as const\n  const __name = `${prefix}_Omit${\n    typeof omit !== 'object'\n      ? yn(omit)\n      : [omit.query, omit.create, omit.update, omit.delete].map(yn).join('')\n  }`\n\n  return {\n    __name,\n    access: allowAll,\n    fields: Object.fromEntries(fields),\n    defaultIsFilterable: isFilterable,\n    defaultIsOrderable: isOrderable,\n    graphql: {\n      plural: __name + 's',\n      omit,\n    },\n  } as const\n}\n\nconst listsMatrix = [\n  ...(function* () {\n    for (const isFilterable of [false, true]) {\n      for (const isOrderable of [false, true]) {\n        for (const omit of [false, true]) {\n          yield makeList({ fields: fieldsMatrix, isFilterable, isOrderable, omit })\n        }\n\n        for (const query of [false, true]) {\n          for (const create of [false, true]) {\n            for (const update of [false, true]) {\n              for (const delete_ of [false, true]) {\n                yield makeList({\n                  fields: fieldsMatrix,\n                  isFilterable,\n                  isOrderable,\n                  omit: {\n                    query,\n                    create,\n                    update,\n                    delete: delete_,\n                  },\n                })\n\n                yield makeList({\n                  fields: [],\n                  isFilterable,\n                  isOrderable,\n                  omit: {\n                    query,\n                    create,\n                    update,\n                    delete: delete_,\n                  },\n                })\n              }\n            }\n          }\n        }\n      }\n    }\n  })(),\n]\n\n// TODO: FIXME: skip for now, MySQL has a limit on the number of indexes\nif (dbProvider !== 'mysql') {\n  listsMatrix.push({\n    __name: 'RelatedToAll',\n    access: allowAll,\n    fields: Object.fromEntries(\n      (function* () {\n        for (const l of listsMatrix) {\n          // WARNING: if names exceed some length, expect duplicate _AB_unique index errors\n          yield [\n            `R${l.__name}_one`,\n            relationship({\n              ref: l.__name,\n              many: false,\n            }),\n          ] as const\n\n          yield [\n            `R${l.__name}_many`,\n            relationship({\n              ref: l.__name,\n              many: true,\n            }),\n          ] as const\n        }\n      })()\n    ),\n    defaultIsFilterable: true,\n    defaultIsOrderable: true,\n    graphql: {\n      plural: 'RelatedToAlls',\n      omit: false,\n    },\n  })\n}\n\nasync function introspectSchema(context: KeystoneContext) {\n  const data = await context.graphql.run<\n    {\n      __schema: {\n        types: {\n          name: string\n          fields: {\n            name: string\n          }[]\n        }[]\n        queryType: {\n          fields: {\n            name: string\n          }[]\n        }\n        mutationType: {\n          fields: {\n            name: string\n          }[]\n        }\n      }\n      keystone: {\n        adminMeta: {\n          lists: {\n            key: string\n          }[]\n        }\n      }\n    },\n    any\n  >({\n    query: `{\n      __schema {\n        types {\n          name\n          fields {\n            name\n          }\n        }\n        queryType {\n          fields {\n            name\n          }\n        }\n        mutationType {\n          fields {\n            name\n          }\n        }\n      }\n      keystone {\n        adminMeta {\n          lists {\n            key\n          }\n        }\n      }\n    }`,\n  })\n\n  return {\n    queries: data.__schema.queryType.fields.map(x => x.name.toLowerCase()),\n    mutations: data.__schema.mutationType.fields.map(x => x.name.toLowerCase()),\n    adminMetaLists: data.keystone.adminMeta.lists.map(x => x.key.toLowerCase()),\n    schemaTypes: data.__schema.types.map(x => x.name.toLowerCase()),\n  }\n}\n\ndescribe(`Omit (${dbProvider})`, () => {\n  function testOmit(\n    listName_: string,\n    d: ReturnType<typeof introspectSchema>,\n    expected: {\n      type: boolean\n      meta: boolean\n      query: boolean\n      create: boolean\n      update: boolean\n      delete: boolean\n    }\n  ) {\n    const listName = listName_.toLowerCase()\n\n    if (expected.query)\n      test('does have find', async () => assert.ok((await d).queries.includes(listName)))\n    if (expected.query)\n      test('does have findMany', async () => assert.ok((await d).queries.includes(listName + 's')))\n    if (expected.create)\n      test('does have create', async () =>\n        assert.ok((await d).mutations.includes(`create${listName}`)))\n    if (expected.create)\n      test('does have createMany', async () =>\n        assert.ok((await d).mutations.includes(`create${listName}s`)))\n    if (expected.update)\n      test('does have update', async () =>\n        assert.ok((await d).mutations.includes(`update${listName}`)))\n    if (expected.update)\n      test('does have updateMany', async () =>\n        assert.ok((await d).mutations.includes(`update${listName}s`)))\n    if (expected.delete)\n      test('does have delete', async () =>\n        assert.ok((await d).mutations.includes(`delete${listName}`)))\n    if (expected.delete)\n      test('does have deleteMany', async () =>\n        assert.ok((await d).mutations.includes(`delete${listName}s`)))\n    if (expected.meta)\n      test('does have an Admin meta list entry', async () =>\n        assert.ok((await d).adminMetaLists.includes(listName)))\n    if (expected.type)\n      test('does have a GraphQL schema type', async () =>\n        assert.ok((await d).schemaTypes.includes(listName)))\n\n    if (!expected.query)\n      test('does not have find', async () => assert.ok(!(await d).queries.includes(listName)))\n    if (!expected.query)\n      test('does not have findMany', async () =>\n        assert.ok(!(await d).queries.includes(listName + 's')))\n    if (!expected.create)\n      test('does not have create', async () =>\n        assert.ok(!(await d).mutations.includes(`create${listName}`)))\n    if (!expected.create)\n      test('does not have createMany', async () =>\n        assert.ok(!(await d).mutations.includes(`create${listName}s`)))\n    if (!expected.update)\n      test('does not have update', async () =>\n        assert.ok(!(await d).mutations.includes(`update${listName}`)))\n    if (!expected.update)\n      test('does not have updateMany', async () =>\n        assert.ok(!(await d).mutations.includes(`update${listName}s`)))\n    if (!expected.delete)\n      test('does not have delete', async () =>\n        assert.ok(!(await d).mutations.includes(`delete${listName}`)))\n    if (!expected.delete)\n      test('does not have deleteMany', async () =>\n        assert.ok(!(await d).mutations.includes(`delete${listName}s`)))\n    if (!expected.meta)\n      test('does not have an Admin meta list entry', async () =>\n        assert.ok(!(await d).adminMetaLists.includes(listName)))\n    if (!expected.type)\n      test('does not have a GraphQL schema type', async () =>\n        assert.ok(!(await d).schemaTypes.includes(listName)))\n  }\n\n  const suite = setupTestSuite({\n    config: {\n      lists: Object.fromEntries(listsMatrix.map(({ __name, ...l }) => [__name, list(l)])),\n    },\n  })\n\n  const data = suite().then(async ({ context }) => await introspectSchema(context))\n  const sudoData = suite().then(async ({ context }) => await introspectSchema(context.sudo()))\n\n  for (const l of listsMatrix) {\n    const listName = l.__name\n    const omit = l.graphql.omit\n\n    // common context is configurable\n    describe(`Common context for ${listName}`, () => {\n      if (typeof omit === 'boolean') {\n        testOmit(listName, data, {\n          type: !omit,\n          meta: !omit,\n          query: !omit,\n          create: !omit,\n          update: !omit,\n          delete: !omit,\n        })\n\n        return\n      }\n\n      testOmit(listName, data, {\n        type: true,\n        // TODO: see create-admin-meta.ts#L102\n        meta: !omit.query,\n        query: !omit.query,\n        create: !omit.create,\n        update: !omit.update,\n        delete: !omit.delete,\n      })\n    })\n\n    // internal context is unaffected by graphql.omit\n    describe(`Internal context for ${listName}`, () => {\n      testOmit(listName, dataInternal, {\n        type: true,\n        meta: true,\n        query: true,\n        create: true,\n        update: true,\n        delete: true,\n      })\n    })\n\n    // sudo context is unaffected by graphql.omit\n    describe(`Sudo context for ${listName}`, () => {\n      testOmit(listName, dataSudo, {\n        type: true,\n        meta: true,\n        query: true,\n        create: true,\n        update: true,\n        delete: true,\n      })\n    })\n  }\n})",
            "cost": 0.104855
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "keystonejs__keystone-9730",
        "repo": "keystonejs/keystone",
        "pull_number": 9730,
        "base_commit": "052f5b1bfdc76868125722ea385c59ffae7eb000",
        "patch": "diff --git a/examples/actions/schema.ts b/examples/actions/schema.ts\nindex 33263c0cac0..e0b9b2274f9 100644\n--- a/examples/actions/schema.ts\n+++ b/examples/actions/schema.ts\n@@ -14,7 +14,18 @@ export const lists = {\n     fields: {\n       title: text(),\n       content: text(),\n-      hidden: checkbox(),\n+      hidden: checkbox({\n+        ui: {\n+          itemView: {\n+            fieldMode: ({ item, itemField }) => {\n+              // WARNING: none of this is access control\n+              if (!item || item.votes === null) return 'edit'\n+              if (itemField) return 'edit'\n+              return item.votes > 0 ? 'read' : 'edit'\n+            },\n+          },\n+        },\n+      }),\n       votes: integer({ defaultValue: 0 }),\n       reportedAt: timestamp({\n         ui: {\ndiff --git a/packages/core/src/fields/types/checkbox/views/index.tsx b/packages/core/src/fields/types/checkbox/views/index.tsx\nindex ded256df246..7ccf76fba7a 100644\n--- a/packages/core/src/fields/types/checkbox/views/index.tsx\n+++ b/packages/core/src/fields/types/checkbox/views/index.tsx\n@@ -3,6 +3,7 @@ import { Icon } from '@keystar/ui/icon'\n import { checkIcon } from '@keystar/ui/icon/icons/checkIcon'\n import { Text, VisuallyHidden } from '@keystar/ui/typography'\n \n+import { entriesTyped } from '../../../../lib/core/utils'\n import type {\n   CellComponent,\n   FieldController,\n@@ -10,7 +11,6 @@ import type {\n   FieldProps,\n   SimpleFieldTypeInfo,\n } from '../../../../types'\n-import { entriesTyped } from '../../../../lib/core/utils'\n \n export function Field({ field, value, onChange, autoFocus }: FieldProps<typeof controller>) {\n   return (\ndiff --git a/packages/core/src/lib/admin-meta-graphql.ts b/packages/core/src/lib/admin-meta-graphql.ts\nindex b33c7a13bc3..db48a73ad11 100644\n--- a/packages/core/src/lib/admin-meta-graphql.ts\n+++ b/packages/core/src/lib/admin-meta-graphql.ts\n@@ -86,7 +86,7 @@ const KeystoneAdminUIFieldMeta = g.object<FieldMetaSource>()({\n           }),\n           isRequired: g.field({\n             type: g.nonNull(g.JSON),\n-            resolve({ item, fieldKey, itemView, itemField, listKey }, _, context) {\n+            resolve({ listKey, fieldKey, itemView, item, itemField }, _, context) {\n               const { isRequired } = itemView\n               if (typeof isRequired !== 'function') return isRequired\n               return isRequired({\n@@ -316,7 +316,12 @@ const KeystoneAdminUIListMeta = g.object<ListMetaSource>()({\n     path: g.field({ type: g.nonNull(g.String) }),\n \n     labelField: g.field({ type: g.nonNull(g.String) }),\n-    fields: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldMeta))) }),\n+    fields: g.field({\n+      resolve: ({ fields, item }) => {\n+        return fields.map(f => ({ ...f, item, itemField: item?.[f.key] ?? null }))\n+      },\n+      type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldMeta))),\n+    }),\n     groups: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldGroupMeta))) }),\n     actions: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIActionMeta))) }),\n     graphql: g.field({ type: g.nonNull(KeystoneAdminUIGraphQL) }),\n@@ -352,8 +357,14 @@ const adminMeta = g.object<AdminMetaSource>()({\n             item: null,\n           }\n         }\n+        // WARNING: do not use sudo\n         const item = await context.db[key].findOne({ where: { id: itemId } })\n-        if (!item) return null\n+        if (!item) {\n+          return {\n+            ...source.listsByKey[key],\n+            item: null,\n+          }\n+        }\n         return {\n           ...source.listsByKey[key],\n           item,\ndiff --git a/tests2/omit.test.ts b/tests2/omit.test.ts\nindex 26b624b9dcc..99e9ed362b0 100644\n--- a/tests2/omit.test.ts\n+++ b/tests2/omit.test.ts\n@@ -73,13 +73,13 @@ const fieldsMatrix = [\n \n function makeList({\n   fields,\n-  isFilterable,\n-  isOrderable,\n+  defaultIsFilterable,\n+  defaultIsOrderable,\n   omit,\n }: {\n   fields: typeof fieldsMatrix\n-  isFilterable: boolean\n-  isOrderable: boolean\n+  defaultIsFilterable: boolean\n+  defaultIsOrderable: boolean\n   omit:\n     | boolean\n     | {\n@@ -89,21 +89,22 @@ function makeList({\n         delete: boolean\n       }\n }) {\n-  const prefix = `List${fields.length}_Filt${yn(isFilterable)}_Ord${yn(isOrderable)}` as const\n-  const __name = `${prefix}_Omit${\n+  const prefix =\n+    `List${fields.length}_Filt${yn(defaultIsFilterable)}_Ord${yn(defaultIsOrderable)}` as const\n+  const name__ = `${prefix}_Omit${\n     typeof omit !== 'object'\n       ? yn(omit)\n       : [omit.query, omit.create, omit.update, omit.delete].map(yn).join('')\n   }`\n \n   return {\n-    __name,\n+    name__,\n     access: allowAll,\n     fields: Object.fromEntries(fields),\n-    defaultIsFilterable: isFilterable,\n-    defaultIsOrderable: isOrderable,\n+    defaultIsFilterable,\n+    defaultIsOrderable,\n     graphql: {\n-      plural: __name + 's',\n+      plural: name__ + 's',\n       omit,\n     },\n   } as const\n@@ -111,10 +112,15 @@ function makeList({\n \n const listsMatrix = [\n   ...(function* () {\n-    for (const isFilterable of [false, true]) {\n-      for (const isOrderable of [false, true]) {\n+    for (const defaultIsFilterable of [false, true]) {\n+      for (const defaultIsOrderable of [false, true]) {\n         for (const omit of [false, true]) {\n-          yield makeList({ fields: fieldsMatrix, isFilterable, isOrderable, omit })\n+          yield makeList({\n+            fields: fieldsMatrix,\n+            defaultIsFilterable,\n+            defaultIsOrderable,\n+            omit,\n+          })\n         }\n \n         for (const query of [false, true]) {\n@@ -123,8 +129,8 @@ const listsMatrix = [\n               for (const delete_ of [false, true]) {\n                 yield makeList({\n                   fields: fieldsMatrix,\n-                  isFilterable,\n-                  isOrderable,\n+                  defaultIsFilterable,\n+                  defaultIsOrderable,\n                   omit: {\n                     query,\n                     create,\n@@ -135,8 +141,8 @@ const listsMatrix = [\n \n                 yield makeList({\n                   fields: [],\n-                  isFilterable,\n-                  isOrderable,\n+                  defaultIsFilterable,\n+                  defaultIsOrderable,\n                   omit: {\n                     query,\n                     create,\n@@ -156,24 +162,24 @@ const listsMatrix = [\n // TODO: FIXME: skip for now, MySQL has a limit on the number of indexes\n if (dbProvider !== 'mysql') {\n   listsMatrix.push({\n-    __name: 'RelatedToAll',\n+    name__: 'RelatedToAll',\n     access: allowAll,\n     fields: Object.fromEntries(\n       (function* () {\n         for (const l of listsMatrix) {\n           // WARNING: if names exceed some length, expect duplicate _AB_unique index errors\n           yield [\n-            `R${l.__name}_one`,\n+            `R${l.name__}_one`,\n             relationship({\n-              ref: l.__name,\n+              ref: l.name__,\n               many: false,\n             }),\n           ] as const\n \n           yield [\n-            `R${l.__name}_many`,\n+            `R${l.name__}_many`,\n             relationship({\n-              ref: l.__name,\n+              ref: l.name__,\n               many: true,\n             }),\n           ] as const\n@@ -334,7 +340,7 @@ describe(`Omit (${dbProvider})`, () => {\n \n   const suite = setupTestSuite({\n     config: {\n-      lists: Object.fromEntries(listsMatrix.map(({ __name, ...l }) => [__name, list(l)])),\n+      lists: Object.fromEntries(listsMatrix.map(({ name__: __name, ...l }) => [__name, list(l)])),\n     },\n   })\n \n@@ -342,7 +348,7 @@ describe(`Omit (${dbProvider})`, () => {\n   const sudoData = suite().then(async ({ context }) => await introspectSchema(context.sudo()))\n \n   for (const l of listsMatrix) {\n-    const listName = l.__name\n+    const listName = l.name__\n     const omit = l.graphql.omit\n \n     // common context is configurable\n",
        "test_patch": "",
        "problem_statement": "",
        "hints_text": "",
        "created_at": "2025-11-12T06:52:26Z",
        "issue_numbers": [],
        "pr_mirror": "keystonejs__keystone.052f5b1b"
    }
}