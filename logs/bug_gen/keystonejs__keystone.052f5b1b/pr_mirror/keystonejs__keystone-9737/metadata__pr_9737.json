{
    "cost": 0.14935500000000002,
    "rewrites": {
        "keystonejs__keystone.052f5b1b/packages/core/src/fields/types/relationship/views/useApolloQuery.ts": {
            "output": "import { useEffect, useMemo, useState } from 'react'\n\nimport type { ListMeta, ListSortDescriptor } from '../../../../types'\nimport {\n  type TypedDocumentNode,\n  ApolloClient,\n  gql,\n  InMemoryCache,\n  useApolloClient,\n  useQuery,\n} from '../../../../admin-ui/apollo'\nimport { useSearchFilter } from './useFilter'\nimport type { RelationshipValue } from './types'\n\nfunction useDebouncedValue<T>(value: T, limitMs: number) {\n  const [debouncedValue, setDebouncedValue] = useState(() => value)\n\n  useEffect(() => {\n    const timeout = setTimeout(() => {\n      setDebouncedValue(() => value)\n    }, limitMs)\n    return () => clearTimeout(timeout)\n  }, [value, limitMs])\n\n  return debouncedValue\n}\n\nexport function useApolloQuery(args: {\n  labelField: string\n  list: ListMeta\n  searchFields: string[]\n  sort?: ListSortDescriptor<string> | null\n  filter?: Record<string, any> | null\n  state:\n    | { kind: 'many'; value: RelationshipValue[] }\n    | { kind: 'one'; value: RelationshipValue | null }\n}) {\n  const { labelField, list, searchFields, state } = args\n  const [search, setSearch] = useState(() => {\n    if (state.kind === 'one' && state.value?.label) return state.value?.label\n    return ''\n  })\n\n  const QUERY: TypedDocumentNode<\n    { items: { id: string; label: string | null }[]; count: number },\n    {\n      where: Record<string, any>\n      take: number\n      skip: number\n      orderBy: Record<string, any> | undefined\n    }\n  > = gql`\n    query RelationshipSelect($where: ${list.graphql.names.whereInputName}!, $take: Int!, $skip: Int!, $orderBy: [${list.graphql.names.listOrderName}!]) {\n      items: ${list.graphql.names.listQueryName}(where: $where, take: $take, skip: $skip, orderBy: $orderBy) {\n        id: id\n        label: ${labelField}\n      }\n      count: ${list.graphql.names.listQueryCountName}(where: $where)\n    }\n  `\n\n  const debouncedSearch = useDebouncedValue(search, 200)\n  const manipulatedSearch =\n    state.kind === 'one' && state.value?.label === debouncedSearch ? '' : debouncedSearch\n\n  // TODO: rewrite\n  const _where = {\n    OR: useSearchFilter(manipulatedSearch, list, searchFields),\n  }\n  // memo is used for referential stability, not for performance\n  const where = useMemo(() => {\n    return args.filter ? { AND: [_where, args.filter] } : _where\n  }, [args.filter, _where])\n\n  const orderBy = useMemo(() => {\n    return args.sort ? { [args.sort.field]: args.sort.direction.toLowerCase() } : undefined\n  }, [args.sort])\n\n  const link = useApolloClient().link\n  // we're using a local apollo client here because writing a global implementation of the typePolicies\n  // would require making assumptions about how pagination should work which won't always be right\n  const apolloClient = useMemo(\n    () =>\n      new ApolloClient({\n        link,\n        cache: new InMemoryCache({\n          typePolicies: {\n            Query: {\n              fields: {\n                [list.graphql.names.listQueryName]: {\n                  keyArgs: ['where'],\n                  merge: (existing: readonly unknown[], incoming: readonly unknown[], { args }) => {\n                    const merged = existing ? existing.slice() : []\n                    const { skip } = args!\n                    for (let i = 0; i < incoming.length; ++i) {\n                      merged[skip + i] = incoming[i]\n                    }\n                    return merged\n                  },\n                },\n              },\n            },\n          },\n        }),\n      }),\n    [link, list.graphql.names.listQueryName]\n  )\n\n  const initialItemsToLoad = Math.min(list.pageSize, 10)\n  const subsequentItemsToLoad = Math.min(list.pageSize, 50)\n  const { data, previousData, error, loading, fetchMore } = useQuery(QUERY, {\n    fetchPolicy: 'network-only',\n    variables: { where, take: initialItemsToLoad, skip: 0, orderBy },\n    client: apolloClient,\n  })\n\n  // we want to avoid fetching more again and `loading` from Apollo\n  // doesn't seem to become true when fetching more\n  const [lastFetchMore, setLastFetchMore] = useState<{\n    where: Record<string, any>\n    list: ListMeta\n    skip: number\n  } | null>(null)\n\n  const count = data?.count || 0\n  const onLoadMore = () => {\n    const skip = data?.items.length\n    if (\n      !loading &&\n      skip &&\n      data.items.length < count &&\n      (lastFetchMore?.where !== where ||\n        lastFetchMore?.list !== list ||\n        lastFetchMore?.skip !== skip)\n    ) {\n      const QUERY: TypedDocumentNode<\n        { items: { id: string; label: string | null }[] },\n        {\n          where: Record<string, any>\n          take: number\n          skip: number\n          orderBy: Record<string, any> | undefined\n        }\n      > = gql`\n        query RelationshipSelectMore($where: ${list.graphql.names.whereInputName}!, $take: Int!, $skip: Int!, $orderBy: [${list.graphql.names.listOrderName}!]) {\n          items: ${list.graphql.names.listQueryName}(where: $where, take: $take, skip: $skip, orderBy: $orderBy) {\n            id\n            label: ${labelField}\n          }\n        }\n      `\n      setLastFetchMore({ list, skip, where })\n      fetchMore({\n        query: QUERY,\n        variables: {\n          where,\n          take: subsequentItemsToLoad,\n          skip,\n          orderBy,\n        },\n      })\n        .then(() => setLastFetchMore(null))\n        .catch(() => setLastFetchMore(null))\n    }\n  }\n\n  return {\n    data: loading ? previousData : data,\n    error,\n    loading,\n    loadingState: getLoadingState({ loading, search }),\n    search,\n    setSearch,\n    onLoadMore,\n  }\n}\n\nfunction getLoadingState(options: { loading: boolean; search: string }): LoadingState {\n  if (options.loading) {\n    if (options.search.length) return 'filtering'\n    return 'loading'\n  }\n\n  return 'idle'\n}\n\ntype LoadingState = 'loading' | 'sorting' | 'loadingMore' | 'error' | 'idle' | 'filtering'",
            "output_extracted": "import { useEffect, useMemo, useState } from 'react'\n\nimport type { ListMeta, ListSortDescriptor } from '../../../../types'\nimport {\n  type TypedDocumentNode,\n  ApolloClient,\n  gql,\n  InMemoryCache,\n  useApolloClient,\n  useQuery,\n} from '../../../../admin-ui/apollo'\nimport { useSearchFilter } from './useFilter'\nimport type { RelationshipValue } from './types'\n\nfunction useDebouncedValue<T>(value: T, limitMs: number) {\n  const [debouncedValue, setDebouncedValue] = useState(() => value)\n\n  useEffect(() => {\n    const timeout = setTimeout(() => {\n      setDebouncedValue(() => value)\n    }, limitMs)\n    return () => clearTimeout(timeout)\n  }, [value, limitMs])\n\n  return debouncedValue\n}\n\nexport function useApolloQuery(args: {\n  labelField: string\n  list: ListMeta\n  searchFields: string[]\n  sort?: ListSortDescriptor<string> | null\n  filter?: Record<string, any> | null\n  state:\n    | { kind: 'many'; value: RelationshipValue[] }\n    | { kind: 'one'; value: RelationshipValue | null }\n}) {\n  const { labelField, list, searchFields, state } = args\n  const [search, setSearch] = useState(() => {\n    if (state.kind === 'one' && state.value?.label) return state.value?.label\n    return ''\n  })\n\n  const QUERY: TypedDocumentNode<\n    { items: { id: string; label: string | null }[]; count: number },\n    {\n      where: Record<string, any>\n      take: number\n      skip: number\n      orderBy: Record<string, any> | undefined\n    }\n  > = gql`\n    query RelationshipSelect($where: ${list.graphql.names.whereInputName}!, $take: Int!, $skip: Int!, $orderBy: [${list.graphql.names.listOrderName}!]) {\n      items: ${list.graphql.names.listQueryName}(where: $where, take: $take, skip: $skip, orderBy: $orderBy) {\n        id: id\n        label: ${labelField}\n      }\n      count: ${list.graphql.names.listQueryCountName}(where: $where)\n    }\n  `\n\n  const debouncedSearch = useDebouncedValue(search, 200)\n  const manipulatedSearch =\n    state.kind === 'one' && state.value?.label === debouncedSearch ? '' : debouncedSearch\n\n  // TODO: rewrite\n  const _where = {\n    OR: useSearchFilter(manipulatedSearch, list, searchFields),\n  }\n  // memo is used for referential stability, not for performance\n  const where = useMemo(() => {\n    return args.filter ? { AND: [_where, args.filter] } : _where\n  }, [args.filter, _where])\n\n  const orderBy = useMemo(() => {\n    return args.sort ? { [args.sort.field]: args.sort.direction.toLowerCase() } : undefined\n  }, [args.sort])\n\n  const link = useApolloClient().link\n  // we're using a local apollo client here because writing a global implementation of the typePolicies\n  // would require making assumptions about how pagination should work which won't always be right\n  const apolloClient = useMemo(\n    () =>\n      new ApolloClient({\n        link,\n        cache: new InMemoryCache({\n          typePolicies: {\n            Query: {\n              fields: {\n                [list.graphql.names.listQueryName]: {\n                  keyArgs: ['where'],\n                  merge: (existing: readonly unknown[], incoming: readonly unknown[], { args }) => {\n                    const merged = existing ? existing.slice() : []\n                    const { skip } = args!\n                    for (let i = 0; i < incoming.length; ++i) {\n                      merged[skip + i] = incoming[i]\n                    }\n                    return merged\n                  },\n                },\n              },\n            },\n          },\n        }),\n      }),\n    [link, list.graphql.names.listQueryName]\n  )\n\n  const initialItemsToLoad = Math.min(list.pageSize, 10)\n  const subsequentItemsToLoad = Math.min(list.pageSize, 50)\n  const { data, previousData, error, loading, fetchMore } = useQuery(QUERY, {\n    fetchPolicy: 'network-only',\n    variables: { where, take: initialItemsToLoad, skip: 0, orderBy },\n    client: apolloClient,\n  })\n\n  // we want to avoid fetching more again and `loading` from Apollo\n  // doesn't seem to become true when fetching more\n  const [lastFetchMore, setLastFetchMore] = useState<{\n    where: Record<string, any>\n    list: ListMeta\n    skip: number\n  } | null>(null)\n\n  const count = data?.count || 0\n  const onLoadMore = () => {\n    const skip = data?.items.length\n    if (\n      !loading &&\n      skip &&\n      data.items.length < count &&\n      (lastFetchMore?.where !== where ||\n        lastFetchMore?.list !== list ||\n        lastFetchMore?.skip !== skip)\n    ) {\n      const QUERY: TypedDocumentNode<\n        { items: { id: string; label: string | null }[] },\n        {\n          where: Record<string, any>\n          take: number\n          skip: number\n          orderBy: Record<string, any> | undefined\n        }\n      > = gql`\n        query RelationshipSelectMore($where: ${list.graphql.names.whereInputName}!, $take: Int!, $skip: Int!, $orderBy: [${list.graphql.names.listOrderName}!]) {\n          items: ${list.graphql.names.listQueryName}(where: $where, take: $take, skip: $skip, orderBy: $orderBy) {\n            id\n            label: ${labelField}\n          }\n        }\n      `\n      setLastFetchMore({ list, skip, where })\n      fetchMore({\n        query: QUERY,\n        variables: {\n          where,\n          take: subsequentItemsToLoad,\n          skip,\n          orderBy,\n        },\n      })\n        .then(() => setLastFetchMore(null))\n        .catch(() => setLastFetchMore(null))\n    }\n  }\n\n  return {\n    data: loading ? previousData : data,\n    error,\n    loading,\n    loadingState: getLoadingState({ loading, search }),\n    search,\n    setSearch,\n    onLoadMore,\n  }\n}\n\nfunction getLoadingState(options: { loading: boolean; search: string }): LoadingState {\n  if (options.loading) {\n    if (options.search.length) return 'filtering'\n    return 'loading'\n  }\n\n  return 'idle'\n}\n\ntype LoadingState = 'loading' | 'sorting' | 'loadingMore' | 'error' | 'idle' | 'filtering'",
            "cost": 0.06016500000000001
        },
        "keystonejs__keystone.052f5b1b/tests/admin-ui-tests/relations.test.ts": {
            "output": "import type { Browser, Page } from 'playwright'\nimport { expect } from 'playwright/test'\nimport { adminUITests } from './utils'\n\nconst gql = ([str]: TemplateStringsArray) => str\n\nadminUITests('./tests/test-projects/basic', browserType => {\n  let browser: Browser = undefined as any\n  let page: Page = undefined as any\n\n  beforeAll(async () => {\n    browser = await browserType.launch()\n    page = await browser.newPage()\n  })\n\n  test('Creating related item does not submit main form', async () => {\n    await page.goto('http://localhost:3000/tasks/create')\n    await page.fill('label:has-text(\"Label\")', 'Buy beer')\n    await page.getByRole('button', { name: 'Actions for Assigned To' }).click()\n    await page.getByText('Add person').click()\n    await page.getByRole('textbox', { name: 'Name' }).fill('Geralt')\n    await page.getByRole('button', { name: 'Add' }).click()\n    await expect(page.getByRole('combobox', { name: 'Assigned To' })).toHaveValue('Geralt')\n    expect(page.url()).toBe('http://localhost:3000/tasks/create')\n  })\n\n  test('selection is not removed when focusing and blurring relationship field', async () => {\n    const result = await fetch('http://localhost:3000/api/graphql', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        query: gql`\n          mutation {\n            createTask(data: { label: \"A task\", assignedTo: { create: { name: \"A user\" } } }) {\n              id\n            }\n          }\n        `,\n        variables: {},\n      }),\n    }).then(res => res.json())\n    expect(result.errors).toBeUndefined()\n\n    await page.goto(`http://localhost:3000/tasks/${result.data.createTask.id}`)\n    await page.getByRole('combobox', { name: 'Assigned To' }).click()\n    await page.getByRole('textbox', { name: 'Label' }).click()\n    await expect(page.getByRole('combobox', { name: 'Assigned To' })).toHaveValue('A user')\n    await expect(page.getByRole('button', { name: 'Save' })).toBeDisabled()\n  })\n\n  test('view related relationships on the item page filters the list view', async () => {\n    const result = await fetch('http://localhost:3000/api/graphql', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        query: gql`\n          mutation {\n            createTask(data: { label: \"My task\", assignedTo: { create: { name: \"My user\" } } }) {\n              id\n              assignedTo {\n                id\n              }\n            }\n          }\n        `,\n        variables: {},\n      }),\n    }).then(res => res.json())\n    expect(result.errors).toBeUndefined()\n\n    await page.goto(`http://localhost:3000/people/${result.data.createTask.assignedTo.id}`)\n    await page.getByRole('button', { name: 'Actions for Tasks' }).click()\n    await page.getByText('View related').click()\n\n    await page.waitForURL(\n      new RegExp(encodeURI(`assignedTo_is_\"${result.data.createTask.assignedTo.id}\"`))\n    )\n    await page.getByText('My task').waitFor()\n    await expect(page.getByText('A task')).toBeHidden()\n  })\n\n  afterAll(async () => {\n    await browser.close()\n  })\n})",
            "output_extracted": "import type { Browser, Page } from 'playwright'\nimport { expect } from 'playwright/test'\nimport { adminUITests } from './utils'\n\nconst gql = ([str]: TemplateStringsArray) => str\n\nadminUITests('./tests/test-projects/basic', browserType => {\n  let browser: Browser = undefined as any\n  let page: Page = undefined as any\n\n  beforeAll(async () => {\n    browser = await browserType.launch()\n    page = await browser.newPage()\n  })\n\n  test('Creating related item does not submit main form', async () => {\n    await page.goto('http://localhost:3000/tasks/create')\n    await page.fill('label:has-text(\"Label\")', 'Buy beer')\n    await page.getByRole('button', { name: 'Actions for Assigned To' }).click()\n    await page.getByText('Add person').click()\n    await page.getByRole('textbox', { name: 'Name' }).fill('Geralt')\n    await page.getByRole('button', { name: 'Add' }).click()\n    await expect(page.getByRole('combobox', { name: 'Assigned To' })).toHaveValue('Geralt')\n    expect(page.url()).toBe('http://localhost:3000/tasks/create')\n  })\n\n  test('selection is not removed when focusing and blurring relationship field', async () => {\n    const result = await fetch('http://localhost:3000/api/graphql', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        query: gql`\n          mutation {\n            createTask(data: { label: \"A task\", assignedTo: { create: { name: \"A user\" } } }) {\n              id\n            }\n          }\n        `,\n        variables: {},\n      }),\n    }).then(res => res.json())\n    expect(result.errors).toBeUndefined()\n\n    await page.goto(`http://localhost:3000/tasks/${result.data.createTask.id}`)\n    await page.getByRole('combobox', { name: 'Assigned To' }).click()\n    await page.getByRole('textbox', { name: 'Label' }).click()\n    await expect(page.getByRole('combobox', { name: 'Assigned To' })).toHaveValue('A user')\n    await expect(page.getByRole('button', { name: 'Save' })).toBeDisabled()\n  })\n\n  test('view related relationships on the item page filters the list view', async () => {\n    const result = await fetch('http://localhost:3000/api/graphql', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        query: gql`\n          mutation {\n            createTask(data: { label: \"My task\", assignedTo: { create: { name: \"My user\" } } }) {\n              id\n              assignedTo {\n                id\n              }\n            }\n          }\n        `,\n        variables: {},\n      }),\n    }).then(res => res.json())\n    expect(result.errors).toBeUndefined()\n\n    await page.goto(`http://localhost:3000/people/${result.data.createTask.assignedTo.id}`)\n    await page.getByRole('button', { name: 'Actions for Tasks' }).click()\n    await page.getByText('View related').click()\n\n    await page.waitForURL(\n      new RegExp(encodeURI(`assignedTo_is_\"${result.data.createTask.assignedTo.id}\"`))\n    )\n    await page.getByText('My task').waitFor()\n    await expect(page.getByText('A task')).toBeHidden()\n  })\n\n  afterAll(async () => {\n    await browser.close()\n  })\n})",
            "cost": 0.037115
        },
        "keystonejs__keystone.052f5b1b/tests/admin-ui-tests/utils.ts": {
            "output": "import { type ChildProcessWithoutNullStreams, spawn } from 'node:child_process'\nimport { stat } from 'node:fs/promises'\nimport path from 'node:path'\n\nimport dotenv from 'dotenv'\nimport type { ExecaChildProcess } from 'execa'\nimport ms from 'ms'\nimport * as playwright from 'playwright'\n\njest.setTimeout(ms('20 minutes'))\n\nexport async function loadIndex(page: playwright.Page) {\n  try {\n    await page.goto('http://localhost:3000')\n  } catch {}\n  try {\n    // sometimes Next will fail to load the page the first time\n    // this is probably because Keystone is fetching the API route to compile Keystone\n    // while we're fetching an Admin UI page\n    // and Next doesn't handle fetching two pages at the same time well\n    await page.waitForSelector(':has-text(\"Dashboard\")', { timeout: 2000 })\n  } catch {\n    await page.goto('http://localhost:3000')\n  }\n}\n\nconst projectRoot = path.resolve(__dirname, '..', '..')\n\nexport async function makeGqlRequest(query: string, variables?: Record<string, any>) {\n  const { data, errors } = await fetch('http://localhost:3000/api/graphql', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ query, variables }),\n  }).then(res => res.json())\n\n  if (errors) throw new Error(`graphql errors: ${errors.map((x: Error) => x.message).join('\\n')}`)\n  return data\n}\n\n// Simple utility to create an Array of records given a map function and a range.\nexport function generateDataArray(map: (key: number) => any, range: number) {\n  return Array.from(Array(range).keys()).map(map)\n}\n\nexport async function deleteAllData(projectDir: string) {\n  const resolvedProjectDir = path.resolve(projectRoot, projectDir)\n\n  const { PrismaClient } = require(path.join(resolvedProjectDir, 'node_modules/.testprisma/client'))\n  const prisma = new PrismaClient()\n\n  await prisma.$transaction(\n    Object.values(prisma)\n      .filter((x: any) => x?.deleteMany)\n      .map((x: any) => x?.deleteMany?.({}))\n  )\n\n  await prisma.$disconnect()\n}\n\nexport function adminUITests(\n  pathToTest: string,\n  tests: (browser: playwright.BrowserType<playwright.Browser>) => void\n) {\n  const projectDir = path.join(projectRoot, pathToTest)\n  dotenv.config()\n\n  describe('development', () => {\n    let exit: (() => Promise<void>) | undefined = undefined\n    test('prepare keystone', async () => {\n      ;({ exit } = await spawnCommand3(projectDir, ['dev'], 'Admin UI ready'))\n    })\n\n    describe('browser tests', () => tests(playwright.chromium))\n    afterAll(async () => await exit?.())\n  })\n\n  describe('production browser tests', () => {\n    let exit: (() => Promise<void>) | undefined = undefined\n    test('prepare keystone', async () => {\n      await (\n        await spawnCommand3(projectDir, ['build'])\n      ).exited\n      ;({ exit } = await spawnCommand3(projectDir, ['start'], 'Admin UI ready'))\n    })\n\n    describe('browser tests', () => tests(playwright.chromium))\n    afterAll(async () => await exit?.())\n  })\n}\n\nexport async function waitForIO(\n  p: ExecaChildProcess | ChildProcessWithoutNullStreams,\n  content: string,\n  timeout = 10000\n) {\n  const signal = AbortSignal.timeout(timeout)\n  return new Promise<string>((resolve, reject) => {\n    let output = ''\n    function listener(chunk: Buffer) {\n      output += chunk.toString('utf8')\n      if (!output.includes(content)) return\n      signal.removeEventListener('abort', abortListener)\n      p.stdout!.off('data', listener)\n      p.stderr!.off('data', listener)\n      resolve(output)\n    }\n\n    p.stdout!.on('data', listener)\n    p.stderr!.on('data', listener)\n    p.on('error', err => {\n      p.stdout!.off('data', listener)\n      p.stderr!.off('data', listener)\n      signal.removeEventListener('abort', abortListener)\n      reject(err)\n    })\n    const abortListener = () => {\n      p.stdout!.off('data', listener)\n      p.stderr!.off('data', listener)\n      reject(signal.reason)\n    }\n    signal.addEventListener('abort', abortListener, { once: true })\n  })\n}\n\nconst cliBinPath = require.resolve('@keystone-6/core/bin/cli.js')\n\nexport async function spawnCommand3(cwd: string, commands: string[], waitOn: string | null = null) {\n  if (!(await stat(cwd))) throw new Error(`No such file or directory ${cwd}`)\n\n  const p = spawn('node', [cliBinPath, ...commands], { cwd })\n  if (waitOn) {\n    await waitForIO(p, waitOn)\n  }\n\n  if (process.env.VERBOSE) {\n    function listener(chunk: Buffer) {\n      console.log(chunk.toString('utf8'))\n    }\n    p.stdout!.on('data', listener)\n    p.stderr!.on('data', listener)\n  }\n\n  const exitPromise = new Promise<void>((resolve, reject) => {\n    p.on('exit', exitCode => {\n      if (typeof exitCode === 'number' && exitCode !== 0)\n        return reject(\n          new Error(\n            `Test Error for ${commands}, exited with error ${exitCode}, see admin-ui/utils.ts`\n          )\n        )\n      resolve()\n    })\n  })\n\n  return {\n    process: p,\n    exit: async () => {\n      p.kill('SIGHUP')\n      await exitPromise\n    },\n    exited: exitPromise,\n  }\n}",
            "output_extracted": "import { type ChildProcessWithoutNullStreams, spawn } from 'node:child_process'\nimport { stat } from 'node:fs/promises'\nimport path from 'node:path'\n\nimport dotenv from 'dotenv'\nimport type { ExecaChildProcess } from 'execa'\nimport ms from 'ms'\nimport * as playwright from 'playwright'\n\njest.setTimeout(ms('20 minutes'))\n\nexport async function loadIndex(page: playwright.Page) {\n  try {\n    await page.goto('http://localhost:3000')\n  } catch {}\n  try {\n    // sometimes Next will fail to load the page the first time\n    // this is probably because Keystone is fetching the API route to compile Keystone\n    // while we're fetching an Admin UI page\n    // and Next doesn't handle fetching two pages at the same time well\n    await page.waitForSelector(':has-text(\"Dashboard\")', { timeout: 2000 })\n  } catch {\n    await page.goto('http://localhost:3000')\n  }\n}\n\nconst projectRoot = path.resolve(__dirname, '..', '..')\n\nexport async function makeGqlRequest(query: string, variables?: Record<string, any>) {\n  const { data, errors } = await fetch('http://localhost:3000/api/graphql', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ query, variables }),\n  }).then(res => res.json())\n\n  if (errors) throw new Error(`graphql errors: ${errors.map((x: Error) => x.message).join('\\n')}`)\n  return data\n}\n\n// Simple utility to create an Array of records given a map function and a range.\nexport function generateDataArray(map: (key: number) => any, range: number) {\n  return Array.from(Array(range).keys()).map(map)\n}\n\nexport async function deleteAllData(projectDir: string) {\n  const resolvedProjectDir = path.resolve(projectRoot, projectDir)\n\n  const { PrismaClient } = require(path.join(resolvedProjectDir, 'node_modules/.testprisma/client'))\n  const prisma = new PrismaClient()\n\n  await prisma.$transaction(\n    Object.values(prisma)\n      .filter((x: any) => x?.deleteMany)\n      .map((x: any) => x?.deleteMany?.({}))\n  )\n\n  await prisma.$disconnect()\n}\n\nexport function adminUITests(\n  pathToTest: string,\n  tests: (browser: playwright.BrowserType<playwright.Browser>) => void\n) {\n  const projectDir = path.join(projectRoot, pathToTest)\n  dotenv.config()\n\n  describe('development', () => {\n    let exit: (() => Promise<void>) | undefined = undefined\n    test('prepare keystone', async () => {\n      ;({ exit } = await spawnCommand3(projectDir, ['dev'], 'Admin UI ready'))\n    })\n\n    describe('browser tests', () => tests(playwright.chromium))\n    afterAll(async () => await exit?.())\n  })\n\n  describe('production browser tests', () => {\n    let exit: (() => Promise<void>) | undefined = undefined\n    test('prepare keystone', async () => {\n      await (\n        await spawnCommand3(projectDir, ['build'])\n      ).exited\n      ;({ exit } = await spawnCommand3(projectDir, ['start'], 'Admin UI ready'))\n    })\n\n    describe('browser tests', () => tests(playwright.chromium))\n    afterAll(async () => await exit?.())\n  })\n}\n\nexport async function waitForIO(\n  p: ExecaChildProcess | ChildProcessWithoutNullStreams,\n  content: string,\n  timeout = 10000\n) {\n  const signal = AbortSignal.timeout(timeout)\n  return new Promise<string>((resolve, reject) => {\n    let output = ''\n    function listener(chunk: Buffer) {\n      output += chunk.toString('utf8')\n      if (!output.includes(content)) return\n      signal.removeEventListener('abort', abortListener)\n      p.stdout!.off('data', listener)\n      p.stderr!.off('data', listener)\n      resolve(output)\n    }\n\n    p.stdout!.on('data', listener)\n    p.stderr!.on('data', listener)\n    p.on('error', err => {\n      p.stdout!.off('data', listener)\n      p.stderr!.off('data', listener)\n      signal.removeEventListener('abort', abortListener)\n      reject(err)\n    })\n    const abortListener = () => {\n      p.stdout!.off('data', listener)\n      p.stderr!.off('data', listener)\n      reject(signal.reason)\n    }\n    signal.addEventListener('abort', abortListener, { once: true })\n  })\n}\n\nconst cliBinPath = require.resolve('@keystone-6/core/bin/cli.js')\n\nexport async function spawnCommand3(cwd: string, commands: string[], waitOn: string | null = null) {\n  if (!(await stat(cwd))) throw new Error(`No such file or directory ${cwd}`)\n\n  const p = spawn('node', [cliBinPath, ...commands], { cwd })\n  if (waitOn) {\n    await waitForIO(p, waitOn)\n  }\n\n  if (process.env.VERBOSE) {\n    function listener(chunk: Buffer) {\n      console.log(chunk.toString('utf8'))\n    }\n    p.stdout!.on('data', listener)\n    p.stderr!.on('data', listener)\n  }\n\n  const exitPromise = new Promise<void>((resolve, reject) => {\n    p.on('exit', exitCode => {\n      if (typeof exitCode === 'number' && exitCode !== 0)\n        return reject(\n          new Error(\n            `Test Error for ${commands}, exited with error ${exitCode}, see admin-ui/utils.ts`\n          )\n        )\n      resolve()\n    })\n  })\n\n  return {\n    process: p,\n    exit: async () => {\n      p.kill('SIGHUP')\n      await exitPromise\n    },\n    exited: exitPromise,\n  }\n}",
            "cost": 0.052075
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "keystonejs__keystone-9737",
        "repo": "keystonejs/keystone",
        "pull_number": 9737,
        "base_commit": "052f5b1bfdc76868125722ea385c59ffae7eb000",
        "patch": "diff --git a/packages/core/src/fields/types/relationship/views/useApolloQuery.ts b/packages/core/src/fields/types/relationship/views/useApolloQuery.ts\nindex 703278638b7..5cf30b1c193 100644\n--- a/packages/core/src/fields/types/relationship/views/useApolloQuery.ts\n+++ b/packages/core/src/fields/types/relationship/views/useApolloQuery.ts\n@@ -1,4 +1,5 @@\n import { useEffect, useMemo, useState } from 'react'\n+import isDeepEqual from 'fast-deep-equal'\n \n import type { ListMeta, ListSortDescriptor } from '../../../../types'\n import {\n@@ -63,14 +64,11 @@ export function useApolloQuery(args: {\n   const manipulatedSearch =\n     state.kind === 'one' && state.value?.label === debouncedSearch ? '' : debouncedSearch\n \n-  // TODO: rewrite\n+  const searchFilter = useSearchFilter(manipulatedSearch, list, searchFields)\n   const _where = {\n-    OR: useSearchFilter(manipulatedSearch, list, searchFields),\n+    OR: searchFilter,\n   }\n-  // memo is used for referential stability, not for performance\n-  const where = useMemo(() => {\n-    return args.filter ? { AND: [_where, args.filter] } : _where\n-  }, [args.filter, _where])\n+  const where = args.filter ? { AND: [_where, args.filter] } : _where\n \n   const orderBy = useMemo(() => {\n     return args.sort ? { [args.sort.field]: args.sort.direction.toLowerCase() } : undefined\n@@ -129,7 +127,7 @@ export function useApolloQuery(args: {\n       !loading &&\n       skip &&\n       data.items.length < count &&\n-      (lastFetchMore?.where !== where ||\n+      (!isDeepEqual(lastFetchMore?.where, where) ||\n         lastFetchMore?.list !== list ||\n         lastFetchMore?.skip !== skip)\n     ) {\ndiff --git a/tests/admin-ui-tests/relations.test.ts b/tests/admin-ui-tests/relations.test.ts\nindex 39a28039176..3a3690868ff 100644\n--- a/tests/admin-ui-tests/relations.test.ts\n+++ b/tests/admin-ui-tests/relations.test.ts\n@@ -1,6 +1,6 @@\n import type { Browser, Page } from 'playwright'\n import { expect } from 'playwright/test'\n-import { adminUITests } from './utils'\n+import { adminUITests, callGraphQL } from './utils'\n \n const gql = ([str]: TemplateStringsArray) => str\n \n@@ -79,6 +79,32 @@ adminUITests('./tests/test-projects/basic', browserType => {\n     await expect(page.getByText('A task')).toBeHidden()\n   })\n \n+  test(\"the combobox having to paginate doesn't break the page\", async () => {\n+    await callGraphQL(\n+      gql`\n+        mutation ($data: [PersonCreateInput!]!) {\n+          createPeople(data: $data) {\n+            id\n+          }\n+        }\n+      `,\n+      {\n+        data: [\n+          { name: 'User to pick' },\n+          ...Array.from({ length: 100 }, (_, i) => ({ name: `User ${i}` })),\n+        ],\n+      }\n+    )\n+\n+    await page.goto(`http://localhost:3000/tasks/create`)\n+    await page.getByRole('textbox', { name: 'Label' }).fill('some task')\n+    await page.getByRole('combobox', { name: 'Assigned To' }).click()\n+    await page.getByRole('button', { name: 'Show suggestions Assigned To' }).click()\n+    await page.getByText('User to pick').click()\n+    await page.getByRole('button', { name: 'Create' }).click()\n+    await expect(page.getByText('Task created')).toBeVisible()\n+  })\n+\n   afterAll(async () => {\n     await browser.close()\n   })\ndiff --git a/tests/admin-ui-tests/utils.ts b/tests/admin-ui-tests/utils.ts\nindex 2695dc6733b..d74d8c7dd37 100644\n--- a/tests/admin-ui-tests/utils.ts\n+++ b/tests/admin-ui-tests/utils.ts\n@@ -161,3 +161,17 @@ export async function spawnCommand3(cwd: string, commands: string[], waitOn: str\n     exited: exitPromise,\n   }\n }\n+\n+// TODO: use elsewhere in tests\n+export async function callGraphQL(query: string, variables?: Record<string, any>) {\n+  const result = await fetch('http://localhost:3000/api/graphql', {\n+    method: 'POST',\n+    headers: { 'Content-Type': 'application/json' },\n+    body: JSON.stringify({\n+      query,\n+      variables,\n+    }),\n+  }).then(res => res.json())\n+  expect(result.errors).toBeUndefined()\n+  return result.data\n+}\n",
        "test_patch": "",
        "problem_statement": "",
        "hints_text": "",
        "created_at": "2025-11-24T01:07:49Z",
        "issue_numbers": [],
        "pr_mirror": "keystonejs__keystone.052f5b1b"
    }
}