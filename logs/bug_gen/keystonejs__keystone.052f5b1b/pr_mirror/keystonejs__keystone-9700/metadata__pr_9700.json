{
    "cost": 0.20914500000000003,
    "rewrites": {
        "keystonejs__keystone.052f5b1b/examples/logging-opentelemetry/keystone.ts": {
            "output": "import { createHash } from 'node:crypto'\nimport { config } from '@keystone-6/core'\n\nimport type { TypeInfo } from '.keystone/types'\nimport { lists } from './schema'\nimport { init as initOtel, tracer } from './otel'\n\ninitOtel()\n\nfunction sha256(q: string) {\n  return createHash('sha256').update(q).digest('base64url')\n}\n\nexport default config<TypeInfo>({\n  db: {\n    provider: 'sqlite',\n    url: process.env.DATABASE_URL || 'file:./keystone-example.db',\n\n    // WARNING: this is only needed for our monorepo examples, dont do this\n    prismaClientPath: 'node_modules/myprisma',\n  },\n  graphql: {\n    apolloConfig: {\n      plugins: [\n        {\n          async requestDidStart() {\n            const span = tracer.startSpan('graphql request')\n\n            return {\n              async willSendResponse({ operation, request }) {\n                span.setAttribute('type', operation?.operation || 'unknown')\n                span.setAttribute('name', request.operationName || 'unknown')\n                span.setAttribute('hash', request.query ? sha256(request.query) : 'empty')\n                // span.setAttribute('query', request.query?.replaceAll(/\\s+/g, ' ') || '') // WARNING: verbose\n                span.end()\n              },\n            }\n          },\n        },\n      ],\n    },\n  },\n  server: {\n    extendExpressApp(app) {\n      app.use((req, res, next) => {\n        tracer.startActiveSpan(\n          'http request',\n          {\n            attributes: {\n              method: req.method,\n              path: req.path,\n              userAgent: req.headers['user-agent'] || '',\n            },\n          },\n          span => {\n            next()\n            res.on('finish', () => {\n              span.end()\n            })\n          }\n        )\n      })\n    },\n  },\n  ui: {\n    getAdditionalFiles: async () => [\n      {\n        mode: 'write',\n        src: `module.exports = ${JSON.stringify({\n          // stop the default Next logging\n          logging: false, // we use something else\n\n          // defaults from packages/core/src/templates/next-config.ts\n          bundlePagesRouterDependencies: true,\n          eslint: { ignoreDuringBuilds: true },\n          typescript: { ignoreBuildErrors: true },\n          transpilePackages: ['../../admin'],\n        })}`,\n        outputPath: 'next.config.js',\n      },\n    ],\n  },\n  lists,\n})",
            "output_extracted": "import { createHash } from 'node:crypto'\nimport { config } from '@keystone-6/core'\n\nimport type { TypeInfo } from '.keystone/types'\nimport { lists } from './schema'\nimport { init as initOtel, tracer } from './otel'\n\ninitOtel()\n\nfunction sha256(q: string) {\n  return createHash('sha256').update(q).digest('base64url')\n}\n\nexport default config<TypeInfo>({\n  db: {\n    provider: 'sqlite',\n    url: process.env.DATABASE_URL || 'file:./keystone-example.db',\n\n    // WARNING: this is only needed for our monorepo examples, dont do this\n    prismaClientPath: 'node_modules/myprisma',\n  },\n  graphql: {\n    apolloConfig: {\n      plugins: [\n        {\n          async requestDidStart() {\n            const span = tracer.startSpan('graphql request')\n\n            return {\n              async willSendResponse({ operation, request }) {\n                span.setAttribute('type', operation?.operation || 'unknown')\n                span.setAttribute('name', request.operationName || 'unknown')\n                span.setAttribute('hash', request.query ? sha256(request.query) : 'empty')\n                // span.setAttribute('query', request.query?.replaceAll(/\\s+/g, ' ') || '') // WARNING: verbose\n                span.end()\n              },\n            }\n          },\n        },\n      ],\n    },\n  },\n  server: {\n    extendExpressApp(app) {\n      app.use((req, res, next) => {\n        tracer.startActiveSpan(\n          'http request',\n          {\n            attributes: {\n              method: req.method,\n              path: req.path,\n              userAgent: req.headers['user-agent'] || '',\n            },\n          },\n          span => {\n            next()\n            res.on('finish', () => {\n              span.end()\n            })\n          }\n        )\n      })\n    },\n  },\n  ui: {\n    getAdditionalFiles: async () => [\n      {\n        mode: 'write',\n        src: `module.exports = ${JSON.stringify({\n          // stop the default Next logging\n          logging: false, // we use something else\n\n          // defaults from packages/core/src/templates/next-config.ts\n          bundlePagesRouterDependencies: true,\n          eslint: { ignoreDuringBuilds: true },\n          typescript: { ignoreBuildErrors: true },\n          transpilePackages: ['../../admin'],\n        })}`,\n        outputPath: 'next.config.js',\n      },\n    ],\n  },\n  lists,\n})",
            "cost": 0.026340000000000002
        },
        "keystonejs__keystone.052f5b1b/packages/core/src/lib/core/mutations/index.ts": {
            "output": "import { GInputObjectType, type GNullableInputType } from '@graphql-ts/schema'\nimport type { GraphQLNamedType } from 'graphql'\n\nimport type { BaseItem, KeystoneContext } from '../../../types'\nimport type { UniquePrismaFilter } from '../../../types/prisma'\nimport { g } from '../../../types/schema'\nimport { withSpan } from '../../otel'\nimport {\n  cannotActionForItem,\n  cannotForItem,\n  enforceFieldLevelAccessControl,\n  enforceListLevelAccessControl,\n  getAccessFilters,\n  getOperationAccess,\n} from '../access-control'\nimport { checkFilterOrderAccess } from '../filter-order-access'\nimport {\n  accessDeniedError,\n  extensionError,\n  relationshipError,\n  resolverError,\n} from '../graphql-errors'\nimport { runSideEffectOnlyHook, validate } from '../hooks'\nimport type { InitialisedAction, InitialisedList } from '../initialise-lists'\nimport { mapUniqueWhereToWhere, traverse } from '../queries/resolvers'\nimport type { ResolvedDBField } from '../resolve-relationships'\nimport {\n  type IdType,\n  getDBFieldKeyForFieldOnMultiField,\n  promiseAllRejectWithAllErrors,\n} from '../utils'\nimport {\n  type InputFilter,\n  type UniqueInputFilter,\n  resolveUniqueWhereInput,\n  resolveWhereInput,\n} from '../where-inputs'\nimport {\n  RelationshipErrors,\n  resolveRelateToManyForCreateInput,\n  resolveRelateToManyForUpdateInput,\n} from './nested-mutation-many-input-resolvers'\nimport {\n  resolveRelateToOneForCreateInput,\n  resolveRelateToOneForUpdateInput,\n} from './nested-mutation-one-input-resolvers'\n\nasync function getFilteredItem(\n  list: InitialisedList,\n  context: KeystoneContext,\n  uniqueWhere: UniquePrismaFilter,\n  accessFilters: boolean | InputFilter,\n  operation: 'update' | 'delete'\n) {\n  // early exit if they want to exclude everything\n  if (accessFilters === false) {\n    throw accessDeniedError(cannotForItem(operation, list))\n  }\n\n  // merge the filter access control and try to get the item\n  let where = mapUniqueWhereToWhere(uniqueWhere, list)\n\n  await checkFilterOrderAccess([...traverse(list, where as any)], context, 'filter')\n\n  if (typeof accessFilters === 'object') {\n    where = { AND: [where, await resolveWhereInput(accessFilters, list, context)] }\n  }\n\n  const item = await context.prisma[list.listKey].findFirst({ where })\n  if (item !== null) return item\n\n  throw accessDeniedError(cannotForItem(operation, list))\n}\n\nasync function createSingle__(\n  inputData: Record<string, unknown>,\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  return await withSpan(\n    `create ${list.graphql.names.outputTypeNameLower}`,\n    async () => {\n      // throw an accessDeniedError if not allowed\n      await enforceListLevelAccessControl(context, 'create', list, inputData, undefined)\n      await enforceFieldLevelAccessControl(context, 'create', list, inputData, undefined)\n      const { beforeOperation, afterOperation, data } = await resolveInputForCreateOrUpdate(\n        list,\n        context,\n        inputData,\n        undefined\n      )\n\n      // before operation\n      await beforeOperation()\n\n      // operation\n      const item = await context.prisma[list.listKey].create({\n        data: list.isSingleton ? { ...data, id: 1 } : data,\n      })\n\n      return { item, afterOperation }\n    },\n    { 'keystone.list': list.listKey, 'keystone.operation': 'create' }\n  )\n}\n\nexport class NestedMutationState {\n  #afterOperations: (() => void | Promise<void>)[] = []\n  #context: KeystoneContext\n  constructor(context: KeystoneContext) {\n    this.#context = context\n  }\n  async create(data: Record<string, unknown>, list: InitialisedList) {\n    const context = this.#context\n\n    const operationAccess = await getOperationAccess(list, context, 'create')\n    if (!operationAccess) throw accessDeniedError(cannotForItem('create', list))\n\n    // before operation AND operation\n    const { item, afterOperation } = await createSingle__(data, list, context)\n\n    // after operation\n    this.#afterOperations.push(() => afterOperation(item))\n    return { id: item.id as IdType }\n  }\n\n  async afterOperation() {\n    await promiseAllRejectWithAllErrors(this.#afterOperations.map(async x => x()))\n  }\n}\n\ntype InputData = Record<string, unknown> | null | undefined\ntype UpdateInput = {\n  where: UniqueInputFilter\n  data: InputData\n}\n\nasync function updateSingle__(\n  { where, data: inputData }: UpdateInput,\n  list: InitialisedList,\n  context: KeystoneContext,\n  accessFilters: boolean | InputFilter\n) {\n  return await withSpan(\n    `update ${list.graphql.names.outputTypeNameLower}`,\n    async () => {\n      // validate and resolve the input filter\n      const uniqueWhere = await resolveUniqueWhereInput(where, list, context)\n\n      // filter and item access control - throws an AccessDeniedError if not allowed\n      const item = await getFilteredItem(list, context, uniqueWhere!, accessFilters, 'update')\n\n      // throw an accessDeniedError if not allowed\n      await enforceListLevelAccessControl(context, 'update', list, inputData ?? {}, item)\n      await enforceFieldLevelAccessControl(context, 'update', list, inputData ?? {}, item)\n      const { beforeOperation, afterOperation, data } = await resolveInputForCreateOrUpdate(\n        list,\n        context,\n        inputData ?? {},\n        item\n      )\n\n      // before operation\n      await beforeOperation()\n\n      // operation\n      const updatedItem = await context.prisma[list.listKey].update({\n        where: { id: item.id },\n        data,\n      })\n\n      // after operation\n      await afterOperation(updatedItem)\n\n      return updatedItem\n    },\n    { 'keystone.list': list.listKey, 'keystone.operation': 'update' }\n  )\n}\n\nasync function deleteSingle__(\n  where: UniqueInputFilter,\n  list: InitialisedList,\n  context: KeystoneContext,\n  accessFilters: boolean | InputFilter\n) {\n  return await withSpan(\n    `delete ${list.graphql.names.outputTypeNameLower}`,\n    async () => {\n      // validate and resolve the input filter\n      const uniqueWhere = await resolveUniqueWhereInput(where, list, context)\n\n      // filter and item access control throw an AccessDeniedError if not allowed\n      // apply access.filter.* controls\n      const item = await getFilteredItem(list, context, uniqueWhere!, accessFilters, 'delete')\n\n      await enforceListLevelAccessControl(context, 'delete', list, {}, item)\n      // WARNING: no field level access control for delete operations\n\n      const hookArgs = {\n        operation: 'delete' as const,\n        listKey: list.listKey,\n        context,\n        item,\n        resolvedData: undefined,\n        inputData: undefined,\n      }\n\n      // hooks\n      await validate({ list, hookArgs })\n\n      // before operation\n      await runSideEffectOnlyHook(list, 'beforeOperation', hookArgs)\n\n      // operation\n      const result = await context.prisma[list.listKey].delete({ where: { id: item.id } })\n\n      // after operation\n      await runSideEffectOnlyHook(list, 'afterOperation', {\n        ...hookArgs,\n        item: undefined,\n        originalItem: item,\n      })\n\n      return result\n    },\n    { 'keystone.list': list.listKey, 'keystone.operation': 'delete' }\n  )\n}\n\nasync function actionSingle__(\n  context: KeystoneContext,\n  list: InitialisedList,\n  action: InitialisedAction,\n  where: UniqueInputFilter\n) {\n  return await withSpan(\n    action.otel,\n    async () => {\n      // no before operation hook for actions\n\n      // operation\n      const result = await action.resolve(\n        {\n          listKey: list.listKey,\n          actionKey: action.actionKey,\n          where,\n        },\n        context\n      )\n\n      // no after operation hook for actions\n      return result\n    },\n    { 'keystone.list': list.listKey, 'keystone.action': action.actionKey }\n  )\n}\n\n//\n\nasync function createOne(inputData: InputData, list: InitialisedList, context: KeystoneContext) {\n  const operationAccess = await getOperationAccess(list, context, 'create')\n  if (!operationAccess) throw accessDeniedError(cannotForItem('create', list))\n\n  // get list-level access control filters\n  //   NOTHING - no filters for create operations\n\n  // operation\n  const { item, afterOperation } = await createSingle__(inputData ?? {}, list, context)\n\n  // after operation // TODO: move to createSingle__\n  await afterOperation(item)\n\n  return item\n}\n\nasync function createMany(\n  inputDatas: InputData[],\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  const operationAccess = await getOperationAccess(list, context, 'create')\n  // WARNING: we do not short-circuit here, we throw for each\n\n  // get list-level access control filters\n  //   NOTHING - no filters for create operations\n\n  return inputDatas.map(async inputData => {\n    // throw for each attempt\n    if (!operationAccess) throw accessDeniedError(cannotForItem('create', list))\n\n    // operation\n    const { item, afterOperation } = await createSingle__(inputData ?? {}, list, context)\n\n    // after operation // TODO: move to createSingle__\n    await afterOperation(item)\n\n    return item\n  })\n}\n\nasync function updateOne(\n  updateInput: UpdateInput,\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  const operationAccess = await getOperationAccess(list, context, 'update')\n  if (!operationAccess) throw accessDeniedError(cannotForItem('update', list))\n\n  // get list-level access control filters\n  const accessFilters = await getAccessFilters(list, context, 'update')\n\n  return updateSingle__(updateInput, list, context, accessFilters)\n}\n\nasync function updateMany(\n  updateManyInput: UpdateInput[],\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  const operationAccess = await getOperationAccess(list, context, 'update')\n  // WARNING: we do not short-circuit here, we throw for each\n\n  // get list-level access control filters\n  const accessFilters = await getAccessFilters(list, context, 'update')\n\n  return updateManyInput.map(async updateInput => {\n    // throw for each attempt\n    if (!operationAccess) throw accessDeniedError(cannotForItem('update', list))\n\n    return updateSingle__(updateInput, list, context, accessFilters)\n  })\n}\n\nasync function deleteOne(\n  where: UniqueInputFilter,\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  const operationAccess = await getOperationAccess(list, context, 'delete')\n  if (!operationAccess) throw accessDeniedError(cannotForItem('delete', list))\n\n  // get list-level access control filters\n  const accessFilters = await getAccessFilters(list, context, 'delete')\n\n  return deleteSingle__(where, list, context, accessFilters)\n}\n\nasync function deleteMany(\n  wheres: UniqueInputFilter[],\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  const operationAccess = await getOperationAccess(list, context, 'delete')\n  // WARNING: we do not short-circuit here, we throw for each\n\n  // get list-level access control filters\n  const accessFilters = await getAccessFilters(list, context, 'delete')\n\n  return wheres.map(async where => {\n    // throw for each attempt\n    if (!operationAccess) throw accessDeniedError(cannotForItem('delete', list))\n\n    return deleteSingle__(where, list, context, accessFilters)\n  })\n}\n\nasync function actionOne(\n  where: UniqueInputFilter,\n  list: InitialisedList,\n  context: KeystoneContext,\n  action: InitialisedAction\n) {\n  const operationAccess = await action.access({\n    context,\n    session: context.session, // TODO: remove in breaking change\n    listKey: list.listKey,\n    actionKey: action.actionKey,\n  })\n  if (!operationAccess) throw accessDeniedError(cannotActionForItem(action, list))\n\n  // get list-level access control filters\n  //   NOTHING - no filters for action operations\n\n  return actionSingle__(context, list, action, where)\n}\n\nasync function actionMany(\n  wheres: UniqueInputFilter[],\n  list: InitialisedList,\n  context: KeystoneContext,\n  action: InitialisedAction\n) {\n  const operationAccess = await action.access({\n    context,\n    session: context.session, // TODO: remove in breaking change\n    listKey: list.listKey,\n    actionKey: action.actionKey,\n  })\n  // WARNING: we do not short-circuit here, we throw for each\n\n  // get list-level access control filters\n  //   NOTHING - no filters for action operations\n\n  return wheres.map(async where => {\n    // throw for each attempt\n    if (!operationAccess) throw accessDeniedError(cannotActionForItem(action, list))\n\n    return actionSingle__(context, list, action, where)\n  })\n}\n\nasync function getResolvedData(\n  list: InitialisedList,\n  hookArgs: {\n    context: KeystoneContext\n    listKey: string\n    inputData: Record<string, any>\n  } & ({ operation: 'create'; item: undefined } | { operation: 'update'; item: BaseItem }),\n  nestedMutationState: NestedMutationState\n) {\n  const { context, operation } = hookArgs\n  let resolvedData = hookArgs.inputData\n\n  // apply non-relationship field type input resolvers\n  const resolverErrors: { error: Error; tag: string }[] = []\n  resolvedData = Object.fromEntries(\n    await Promise.all(\n      Object.entries(list.fields).map(async ([fieldKey, field]) => {\n        const inputResolver = field.input?.[operation]?.resolve\n\n        if (inputResolver && field.dbField.kind !== 'relation') {\n          try {\n            return [fieldKey, await inputResolver(resolvedData[fieldKey], context, undefined)]\n          } catch (error: any) {\n            resolverErrors.push({ error, tag: `${list.listKey}.${fieldKey}` })\n          }\n        }\n        return [fieldKey, resolvedData[fieldKey]] as const\n      })\n    )\n  )\n\n  if (resolverErrors.length) throw resolverError(resolverErrors)\n\n  // apply relationship field type input resolvers\n  const relationshipErrors: { error: Error; tag: string }[] = []\n  resolvedData = Object.fromEntries(\n    await Promise.all(\n      Object.entries(list.fields).map(async ([fieldKey, field]) => {\n        const inputResolver = field.input?.[operation]?.resolve\n        let input = resolvedData[fieldKey]\n        if (inputResolver && field.dbField.kind === 'relation') {\n          const tag = `${list.listKey}.",
            "output_extracted": "import { GInputObjectType, type GNullableInputType } from '@graphql-ts/schema'\nimport type { GraphQLNamedType } from 'graphql'\n\nimport type { BaseItem, KeystoneContext } from '../../../types'\nimport type { UniquePrismaFilter } from '../../../types/prisma'\nimport { g } from '../../../types/schema'\nimport { withSpan } from '../../otel'\nimport {\n  cannotActionForItem,\n  cannotForItem,\n  enforceFieldLevelAccessControl,\n  enforceListLevelAccessControl,\n  getAccessFilters,\n  getOperationAccess,\n} from '../access-control'\nimport { checkFilterOrderAccess } from '../filter-order-access'\nimport {\n  accessDeniedError,\n  extensionError,\n  relationshipError,\n  resolverError,\n} from '../graphql-errors'\nimport { runSideEffectOnlyHook, validate } from '../hooks'\nimport type { InitialisedAction, InitialisedList } from '../initialise-lists'\nimport { mapUniqueWhereToWhere, traverse } from '../queries/resolvers'\nimport type { ResolvedDBField } from '../resolve-relationships'\nimport {\n  type IdType,\n  getDBFieldKeyForFieldOnMultiField,\n  promiseAllRejectWithAllErrors,\n} from '../utils'\nimport {\n  type InputFilter,\n  type UniqueInputFilter,\n  resolveUniqueWhereInput,\n  resolveWhereInput,\n} from '../where-inputs'\nimport {\n  RelationshipErrors,\n  resolveRelateToManyForCreateInput,\n  resolveRelateToManyForUpdateInput,\n} from './nested-mutation-many-input-resolvers'\nimport {\n  resolveRelateToOneForCreateInput,\n  resolveRelateToOneForUpdateInput,\n} from './nested-mutation-one-input-resolvers'\n\nasync function getFilteredItem(\n  list: InitialisedList,\n  context: KeystoneContext,\n  uniqueWhere: UniquePrismaFilter,\n  accessFilters: boolean | InputFilter,\n  operation: 'update' | 'delete'\n) {\n  // early exit if they want to exclude everything\n  if (accessFilters === false) {\n    throw accessDeniedError(cannotForItem(operation, list))\n  }\n\n  // merge the filter access control and try to get the item\n  let where = mapUniqueWhereToWhere(uniqueWhere, list)\n\n  await checkFilterOrderAccess([...traverse(list, where as any)], context, 'filter')\n\n  if (typeof accessFilters === 'object') {\n    where = { AND: [where, await resolveWhereInput(accessFilters, list, context)] }\n  }\n\n  const item = await context.prisma[list.listKey].findFirst({ where })\n  if (item !== null) return item\n\n  throw accessDeniedError(cannotForItem(operation, list))\n}\n\nasync function createSingle__(\n  inputData: Record<string, unknown>,\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  return await withSpan(\n    `create ${list.graphql.names.outputTypeNameLower}`,\n    async () => {\n      // throw an accessDeniedError if not allowed\n      await enforceListLevelAccessControl(context, 'create', list, inputData, undefined)\n      await enforceFieldLevelAccessControl(context, 'create', list, inputData, undefined)\n      const { beforeOperation, afterOperation, data } = await resolveInputForCreateOrUpdate(\n        list,\n        context,\n        inputData,\n        undefined\n      )\n\n      // before operation\n      await beforeOperation()\n\n      // operation\n      const item = await context.prisma[list.listKey].create({\n        data: list.isSingleton ? { ...data, id: 1 } : data,\n      })\n\n      return { item, afterOperation }\n    },\n    { 'keystone.list': list.listKey, 'keystone.operation': 'create' }\n  )\n}\n\nexport class NestedMutationState {\n  #afterOperations: (() => void | Promise<void>)[] = []\n  #context: KeystoneContext\n  constructor(context: KeystoneContext) {\n    this.#context = context\n  }\n  async create(data: Record<string, unknown>, list: InitialisedList) {\n    const context = this.#context\n\n    const operationAccess = await getOperationAccess(list, context, 'create')\n    if (!operationAccess) throw accessDeniedError(cannotForItem('create', list))\n\n    // before operation AND operation\n    const { item, afterOperation } = await createSingle__(data, list, context)\n\n    // after operation\n    this.#afterOperations.push(() => afterOperation(item))\n    return { id: item.id as IdType }\n  }\n\n  async afterOperation() {\n    await promiseAllRejectWithAllErrors(this.#afterOperations.map(async x => x()))\n  }\n}\n\ntype InputData = Record<string, unknown> | null | undefined\ntype UpdateInput = {\n  where: UniqueInputFilter\n  data: InputData\n}\n\nasync function updateSingle__(\n  { where, data: inputData }: UpdateInput,\n  list: InitialisedList,\n  context: KeystoneContext,\n  accessFilters: boolean | InputFilter\n) {\n  return await withSpan(\n    `update ${list.graphql.names.outputTypeNameLower}`,\n    async () => {\n      // validate and resolve the input filter\n      const uniqueWhere = await resolveUniqueWhereInput(where, list, context)\n\n      // filter and item access control - throws an AccessDeniedError if not allowed\n      const item = await getFilteredItem(list, context, uniqueWhere!, accessFilters, 'update')\n\n      // throw an accessDeniedError if not allowed\n      await enforceListLevelAccessControl(context, 'update', list, inputData ?? {}, item)\n      await enforceFieldLevelAccessControl(context, 'update', list, inputData ?? {}, item)\n      const { beforeOperation, afterOperation, data } = await resolveInputForCreateOrUpdate(\n        list,\n        context,\n        inputData ?? {},\n        item\n      )\n\n      // before operation\n      await beforeOperation()\n\n      // operation\n      const updatedItem = await context.prisma[list.listKey].update({\n        where: { id: item.id },\n        data,\n      })\n\n      // after operation\n      await afterOperation(updatedItem)\n\n      return updatedItem\n    },\n    { 'keystone.list': list.listKey, 'keystone.operation': 'update' }\n  )\n}\n\nasync function deleteSingle__(\n  where: UniqueInputFilter,\n  list: InitialisedList,\n  context: KeystoneContext,\n  accessFilters: boolean | InputFilter\n) {\n  return await withSpan(\n    `delete ${list.graphql.names.outputTypeNameLower}`,\n    async () => {\n      // validate and resolve the input filter\n      const uniqueWhere = await resolveUniqueWhereInput(where, list, context)\n\n      // filter and item access control throw an AccessDeniedError if not allowed\n      // apply access.filter.* controls\n      const item = await getFilteredItem(list, context, uniqueWhere!, accessFilters, 'delete')\n\n      await enforceListLevelAccessControl(context, 'delete', list, {}, item)\n      // WARNING: no field level access control for delete operations\n\n      const hookArgs = {\n        operation: 'delete' as const,\n        listKey: list.listKey,\n        context,\n        item,\n        resolvedData: undefined,\n        inputData: undefined,\n      }\n\n      // hooks\n      await validate({ list, hookArgs })\n\n      // before operation\n      await runSideEffectOnlyHook(list, 'beforeOperation', hookArgs)\n\n      // operation\n      const result = await context.prisma[list.listKey].delete({ where: { id: item.id } })\n\n      // after operation\n      await runSideEffectOnlyHook(list, 'afterOperation', {\n        ...hookArgs,\n        item: undefined,\n        originalItem: item,\n      })\n\n      return result\n    },\n    { 'keystone.list': list.listKey, 'keystone.operation': 'delete' }\n  )\n}\n\nasync function actionSingle__(\n  context: KeystoneContext,\n  list: InitialisedList,\n  action: InitialisedAction,\n  where: UniqueInputFilter\n) {\n  return await withSpan(\n    action.otel,\n    async () => {\n      // no before operation hook for actions\n\n      // operation\n      const result = await action.resolve(\n        {\n          listKey: list.listKey,\n          actionKey: action.actionKey,\n          where,\n        },\n        context\n      )\n\n      // no after operation hook for actions\n      return result\n    },\n    { 'keystone.list': list.listKey, 'keystone.action': action.actionKey }\n  )\n}\n\n//\n\nasync function createOne(inputData: InputData, list: InitialisedList, context: KeystoneContext) {\n  const operationAccess = await getOperationAccess(list, context, 'create')\n  if (!operationAccess) throw accessDeniedError(cannotForItem('create', list))\n\n  // get list-level access control filters\n  //   NOTHING - no filters for create operations\n\n  // operation\n  const { item, afterOperation } = await createSingle__(inputData ?? {}, list, context)\n\n  // after operation // TODO: move to createSingle__\n  await afterOperation(item)\n\n  return item\n}\n\nasync function createMany(\n  inputDatas: InputData[],\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  const operationAccess = await getOperationAccess(list, context, 'create')\n  // WARNING: we do not short-circuit here, we throw for each\n\n  // get list-level access control filters\n  //   NOTHING - no filters for create operations\n\n  return inputDatas.map(async inputData => {\n    // throw for each attempt\n    if (!operationAccess) throw accessDeniedError(cannotForItem('create', list))\n\n    // operation\n    const { item, afterOperation } = await createSingle__(inputData ?? {}, list, context)\n\n    // after operation // TODO: move to createSingle__\n    await afterOperation(item)\n\n    return item\n  })\n}\n\nasync function updateOne(\n  updateInput: UpdateInput,\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  const operationAccess = await getOperationAccess(list, context, 'update')\n  if (!operationAccess) throw accessDeniedError(cannotForItem('update', list))\n\n  // get list-level access control filters\n  const accessFilters = await getAccessFilters(list, context, 'update')\n\n  return updateSingle__(updateInput, list, context, accessFilters)\n}\n\nasync function updateMany(\n  updateManyInput: UpdateInput[],\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  const operationAccess = await getOperationAccess(list, context, 'update')\n  // WARNING: we do not short-circuit here, we throw for each\n\n  // get list-level access control filters\n  const accessFilters = await getAccessFilters(list, context, 'update')\n\n  return updateManyInput.map(async updateInput => {\n    // throw for each attempt\n    if (!operationAccess) throw accessDeniedError(cannotForItem('update', list))\n\n    return updateSingle__(updateInput, list, context, accessFilters)\n  })\n}\n\nasync function deleteOne(\n  where: UniqueInputFilter,\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  const operationAccess = await getOperationAccess(list, context, 'delete')\n  if (!operationAccess) throw accessDeniedError(cannotForItem('delete', list))\n\n  // get list-level access control filters\n  const accessFilters = await getAccessFilters(list, context, 'delete')\n\n  return deleteSingle__(where, list, context, accessFilters)\n}\n\nasync function deleteMany(\n  wheres: UniqueInputFilter[],\n  list: InitialisedList,\n  context: KeystoneContext\n) {\n  const operationAccess = await getOperationAccess(list, context, 'delete')\n  // WARNING: we do not short-circuit here, we throw for each\n\n  // get list-level access control filters\n  const accessFilters = await getAccessFilters(list, context, 'delete')\n\n  return wheres.map(async where => {\n    // throw for each attempt\n    if (!operationAccess) throw accessDeniedError(cannotForItem('delete', list))\n\n    return deleteSingle__(where, list, context, accessFilters)\n  })\n}\n\nasync function actionOne(\n  where: UniqueInputFilter,\n  list: InitialisedList,\n  context: KeystoneContext,\n  action: InitialisedAction\n) {\n  const operationAccess = await action.access({\n    context,\n    session: context.session, // TODO: remove in breaking change\n    listKey: list.listKey,\n    actionKey: action.actionKey,\n  })\n  if (!operationAccess) throw accessDeniedError(cannotActionForItem(action, list))\n\n  // get list-level access control filters\n  //   NOTHING - no filters for action operations\n\n  return actionSingle__(context, list, action, where)\n}\n\nasync function actionMany(\n  wheres: UniqueInputFilter[],\n  list: InitialisedList,\n  context: KeystoneContext,\n  action: InitialisedAction\n) {\n  const operationAccess = await action.access({\n    context,\n    session: context.session, // TODO: remove in breaking change\n    listKey: list.listKey,\n    actionKey: action.actionKey,\n  })\n  // WARNING: we do not short-circuit here, we throw for each\n\n  // get list-level access control filters\n  //   NOTHING - no filters for action operations\n\n  return wheres.map(async where => {\n    // throw for each attempt\n    if (!operationAccess) throw accessDeniedError(cannotActionForItem(action, list))\n\n    return actionSingle__(context, list, action, where)\n  })\n}\n\nasync function getResolvedData(\n  list: InitialisedList,\n  hookArgs: {\n    context: KeystoneContext\n    listKey: string\n    inputData: Record<string, any>\n  } & ({ operation: 'create'; item: undefined } | { operation: 'update'; item: BaseItem }),\n  nestedMutationState: NestedMutationState\n) {\n  const { context, operation } = hookArgs\n  let resolvedData = hookArgs.inputData\n\n  // apply non-relationship field type input resolvers\n  const resolverErrors: { error: Error; tag: string }[] = []\n  resolvedData = Object.fromEntries(\n    await Promise.all(\n      Object.entries(list.fields).map(async ([fieldKey, field]) => {\n        const inputResolver = field.input?.[operation]?.resolve\n\n        if (inputResolver && field.dbField.kind !== 'relation') {\n          try {\n            return [fieldKey, await inputResolver(resolvedData[fieldKey], context, undefined)]\n          } catch (error: any) {\n            resolverErrors.push({ error, tag: `${list.listKey}.${fieldKey}` })\n          }\n        }\n        return [fieldKey, resolvedData[fieldKey]] as const\n      })\n    )\n  )\n\n  if (resolverErrors.length) throw resolverError(resolverErrors)\n\n  // apply relationship field type input resolvers\n  const relationshipErrors: { error: Error; tag: string }[] = []\n  resolvedData = Object.fromEntries(\n    await Promise.all(\n      Object.entries(list.fields).map(async ([fieldKey, field]) => {\n        const inputResolver = field.input?.[operation]?.resolve\n        let input = resolvedData[fieldKey]\n        if (inputResolver && field.dbField.kind === 'relation') {\n          const tag = `${list.listKey}.",
            "cost": 0.154085
        },
        "keystonejs__keystone.052f5b1b/packages/core/src/lib/utils.ts": {
            "output": "/**\n * Turns a passed in string into a human readable label\n * @param {String} str The string to convert.\n * @returns The new string\n */\nexport function humanize(str: string, capitalize: boolean = true) {\n  str = str.replace(/[^a-zA-Z0-9]+/g, ' ').replace(/([a-z0-9])([A-Z]+)/g, '$1 $2')\n\n  if (!capitalize) return str\n  return str\n    .split(' ')\n    .map(x => x.charAt(0).toUpperCase() + x.slice(1))\n    .join(' ')\n}",
            "output_extracted": "/**\n * Turns a passed in string into a human readable label\n * @param {String} str The string to convert.\n * @returns The new string\n */\nexport function humanize(str: string, capitalize: boolean = true) {\n  str = str.replace(/[^a-zA-Z0-9]+/g, ' ').replace(/([a-z0-9])([A-Z]+)/g, '$1 $2')\n\n  if (!capitalize) return str\n  return str\n    .split(' ')\n    .map(x => x.charAt(0).toUpperCase() + x.slice(1))\n    .join(' ')\n}",
            "cost": 0.011190000000000002
        },
        "keystonejs__keystone.052f5b1b/tests2/utils.test.ts": {
            "output": "import assert from 'node:assert/strict'\nimport { describe, test } from 'node:test'\n\nimport { humanize } from '../packages/core/src/lib/utils'\n\ndescribe('utils', () => {\n  test('humanize()', () => {\n    assert.equal(humanize('helloDarknessMyOldFriend'), 'Hello Darkness My Old Friend')\n    assert.equal(humanize('someHTML'), 'Some HTML')\n    assert.equal(humanize('snake_case'), 'Snake Case')\n    assert.equal(humanize('kebab-case'), 'Kebab Case')\n    assert.equal(humanize('multiple words here'), 'Multiple Words Here')\n    assert.equal(humanize('Multiple Words Here'), 'Multiple Words Here')\n    assert.equal(humanize('Thing42WithOther43'), 'Thing42 With Other43')\n    assert.equal(humanize('Thing42_withOther43', false), 'Thing42 with Other43')\n    assert.equal(humanize('foo'), 'Foo')\n    assert.equal(humanize('Foo'), 'Foo')\n    assert.equal(humanize('fooBar'), 'Foo Bar')\n    assert.equal(humanize('FooBar'), 'Foo Bar')\n    assert.equal(humanize('Foo Bar'), 'Foo Bar')\n  })\n})",
            "output_extracted": "import assert from 'node:assert/strict'\nimport { describe, test } from 'node:test'\n\nimport { humanize } from '../packages/core/src/lib/utils'\n\ndescribe('utils', () => {\n  test('humanize()', () => {\n    assert.equal(humanize('helloDarknessMyOldFriend'), 'Hello Darkness My Old Friend')\n    assert.equal(humanize('someHTML'), 'Some HTML')\n    assert.equal(humanize('snake_case'), 'Snake Case')\n    assert.equal(humanize('kebab-case'), 'Kebab Case')\n    assert.equal(humanize('multiple words here'), 'Multiple Words Here')\n    assert.equal(humanize('Multiple Words Here'), 'Multiple Words Here')\n    assert.equal(humanize('Thing42WithOther43'), 'Thing42 With Other43')\n    assert.equal(humanize('Thing42_withOther43', false), 'Thing42 with Other43')\n    assert.equal(humanize('foo'), 'Foo')\n    assert.equal(humanize('Foo'), 'Foo')\n    assert.equal(humanize('fooBar'), 'Foo Bar')\n    assert.equal(humanize('FooBar'), 'Foo Bar')\n    assert.equal(humanize('Foo Bar'), 'Foo Bar')\n  })\n})",
            "cost": 0.017530000000000004
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "keystonejs__keystone-9700",
        "repo": "keystonejs/keystone",
        "pull_number": 9700,
        "base_commit": "052f5b1bfdc76868125722ea385c59ffae7eb000",
        "patch": "diff --git a/examples/logging-opentelemetry/keystone.ts b/examples/logging-opentelemetry/keystone.ts\nindex 85d39a644a0..44155838a5b 100644\n--- a/examples/logging-opentelemetry/keystone.ts\n+++ b/examples/logging-opentelemetry/keystone.ts\n@@ -28,10 +28,13 @@ export default config<TypeInfo>({\n \n             return {\n               async willSendResponse({ operation, request }) {\n-                span.setAttribute('type', operation?.operation || 'unknown')\n-                span.setAttribute('name', request.operationName || 'unknown')\n-                span.setAttribute('hash', request.query ? sha256(request.query) : 'empty')\n-                // span.setAttribute('query', request.query?.replaceAll(/\\s+/g, ' ') || '') // WARNING: verbose\n+                span.setAttribute('graphql.operation.name', operation?.operation || 'unknown')\n+                span.setAttribute('graphql.operation.type', request.operationName || 'unknown')\n+                span.setAttribute(\n+                  'graphql.document.sha256',\n+                  request.query ? sha256(request.query) : 'empty'\n+                )\n+                // span.setAttribute('graphql.document', request.query?.replaceAll(/\\s+/g, ' ') || '') // WARNING: verbose\n                 span.end()\n               },\n             }\n@@ -47,9 +50,9 @@ export default config<TypeInfo>({\n           'http request',\n           {\n             attributes: {\n-              method: req.method,\n-              path: req.path,\n-              userAgent: req.headers['user-agent'] || '',\n+              'http.request.method': req.method,\n+              'http.request.path': req.path,\n+              'user_agent.original': req.headers['user-agent'] || '',\n             },\n           },\n           span => {\ndiff --git a/packages/core/src/lib/core/mutations/index.ts b/packages/core/src/lib/core/mutations/index.ts\nindex 8dcd01f71b3..1488c5a2e18 100644\n--- a/packages/core/src/lib/core/mutations/index.ts\n+++ b/packages/core/src/lib/core/mutations/index.ts\n@@ -79,7 +79,7 @@ async function createSingle__(\n ) {\n   return await withSpan(\n     `create ${list.graphql.names.outputTypeNameLower}`,\n-    async () => {\n+    async span => {\n       // throw an accessDeniedError if not allowed\n       await enforceListLevelAccessControl(context, 'create', list, inputData, undefined)\n       await enforceFieldLevelAccessControl(context, 'create', list, inputData, undefined)\n@@ -94,13 +94,17 @@ async function createSingle__(\n       await beforeOperation()\n \n       // operation\n-      const item = await context.prisma[list.listKey].create({\n+      const result = await context.prisma[list.listKey].create({\n         data: list.isSingleton ? { ...data, id: 1 } : data,\n       })\n \n-      return { item, afterOperation }\n+      span.setAttribute('keystone.result.id', result?.id ?? '')\n+      return { item: result, afterOperation }\n     },\n-    { 'keystone.list': list.listKey, 'keystone.operation': 'create' }\n+    {\n+      'keystone.list': list.listKey,\n+      'keystone.operation': 'create',\n+    }\n   )\n }\n \n@@ -143,7 +147,7 @@ async function updateSingle__(\n ) {\n   return await withSpan(\n     `update ${list.graphql.names.outputTypeNameLower}`,\n-    async () => {\n+    async span => {\n       // validate and resolve the input filter\n       const uniqueWhere = await resolveUniqueWhereInput(where, list, context)\n \n@@ -164,15 +168,16 @@ async function updateSingle__(\n       await beforeOperation()\n \n       // operation\n-      const updatedItem = await context.prisma[list.listKey].update({\n+      const result = await context.prisma[list.listKey].update({\n         where: { id: item.id },\n         data,\n       })\n+      span.setAttribute('keystone.result.id', result?.id ?? '')\n \n       // after operation\n-      await afterOperation(updatedItem)\n+      await afterOperation(result)\n \n-      return updatedItem\n+      return result\n     },\n     { 'keystone.list': list.listKey, 'keystone.operation': 'update' }\n   )\n@@ -186,7 +191,7 @@ async function deleteSingle__(\n ) {\n   return await withSpan(\n     `delete ${list.graphql.names.outputTypeNameLower}`,\n-    async () => {\n+    async span => {\n       // validate and resolve the input filter\n       const uniqueWhere = await resolveUniqueWhereInput(where, list, context)\n \n@@ -214,6 +219,7 @@ async function deleteSingle__(\n \n       // operation\n       const result = await context.prisma[list.listKey].delete({ where: { id: item.id } })\n+      span.setAttribute('keystone.result.id', result?.id ?? '')\n \n       // after operation\n       await runSideEffectOnlyHook(list, 'afterOperation', {\n@@ -236,7 +242,7 @@ async function actionSingle__(\n ) {\n   return await withSpan(\n     action.otel,\n-    async () => {\n+    async span => {\n       // no before operation hook for actions\n \n       // operation\n@@ -248,6 +254,7 @@ async function actionSingle__(\n         },\n         context\n       )\n+      span.setAttribute('keystone.result.id', (result?.id as string) ?? '')\n \n       // no after operation hook for actions\n       return result\ndiff --git a/packages/core/src/lib/utils.ts b/packages/core/src/lib/utils.ts\nindex 28e0d9eb4fb..c28c531e072 100644\n--- a/packages/core/src/lib/utils.ts\n+++ b/packages/core/src/lib/utils.ts\n@@ -1,13 +1,20 @@\n-/**\n- * Turns a passed in string into a human readable label\n- * @param {String} str The string to convert.\n- * @returns The new string\n- */\n-export function humanize(str: string, capitalize: boolean = true) {\n-  str = str.replace(/[^a-zA-Z0-9]+/g, ' ').replace(/([a-z0-9])([A-Z]+)/g, '$1 $2')\n+// WARNING: this is an opinionated subject, with too many ways to do this\n+//   we went with a subset that we are happy with\n+//   see tests2/utils.test.ts for examples\n+export function humanize(s: string, capitalize: boolean = true) {\n+  // drop non-alphanumeric\n+  s = s.replace(/[^a-zA-Z0-9]+/g, ' ')\n \n-  if (!capitalize) return str\n-  return str\n+  // insert spaces before camels of length > 1\n+  for (let i = 0; i < 24; i++) {\n+    // not unbounded, shouldnt happen\n+    const next = s.replace(/([a-z0-9])([A-Z][A-Za-z0-9])/, '$1 $2')\n+    if (next === s) break\n+    s = next\n+  }\n+\n+  if (!capitalize) return s\n+  return s\n     .split(' ')\n     .map(x => x.charAt(0).toUpperCase() + x.slice(1))\n     .join(' ')\ndiff --git a/tests2/utils.test.ts b/tests2/utils.test.ts\nindex 33bb2a19612..00ab8adc71e 100644\n--- a/tests2/utils.test.ts\n+++ b/tests2/utils.test.ts\n@@ -11,12 +11,19 @@ describe('utils', () => {\n     assert.equal(humanize('kebab-case'), 'Kebab Case')\n     assert.equal(humanize('multiple words here'), 'Multiple Words Here')\n     assert.equal(humanize('Multiple Words Here'), 'Multiple Words Here')\n-    assert.equal(humanize('Thing42WithOther43'), 'Thing42 With Other43')\n-    assert.equal(humanize('Thing42_withOther43', false), 'Thing42 with Other43')\n     assert.equal(humanize('foo'), 'Foo')\n     assert.equal(humanize('Foo'), 'Foo')\n     assert.equal(humanize('fooBar'), 'Foo Bar')\n     assert.equal(humanize('FooBar'), 'Foo Bar')\n     assert.equal(humanize('Foo Bar'), 'Foo Bar')\n+    assert.equal(humanize('Foo11WithBar11'), 'Foo11 With Bar11')\n+    assert.equal(humanize('Foo1A_WithBar11'), 'Foo1A With Bar11')\n+    assert.equal(humanize('Foo1AA_WithBar11'), 'Foo1 AA With Bar11')\n+    assert.equal(humanize('Foo11_WithBar11'), 'Foo11 With Bar11')\n+    assert.equal(humanize('Foo11_WithBar11A'), 'Foo11 With Bar11A')\n+    assert.equal(humanize('Foo11_WithBar11AA'), 'Foo11 With Bar11 AA')\n+    assert.equal(humanize('Foo11_withBar11', false), 'Foo11 with Bar11')\n+    assert.equal(humanize('FOO1A_BAR11'), 'FOO1A BAR11')\n+    assert.equal(humanize('FOO1A1_BAR11'), 'FOO1 A1 BAR11')\n   })\n })\n",
        "test_patch": "",
        "problem_statement": "",
        "hints_text": "",
        "created_at": "2025-09-03T05:43:27Z",
        "issue_numbers": [],
        "pr_mirror": "keystonejs__keystone.052f5b1b"
    }
}