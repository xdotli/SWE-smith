diff --git a/examples/logging-opentelemetry/keystone.ts b/examples/logging-opentelemetry/keystone.ts
index 44155838a..df6e9d7d5 100644
--- a/examples/logging-opentelemetry/keystone.ts
+++ b/examples/logging-opentelemetry/keystone.ts
@@ -28,13 +28,10 @@ export default config<TypeInfo>({
 
             return {
               async willSendResponse({ operation, request }) {
-                span.setAttribute('graphql.operation.name', operation?.operation || 'unknown')
-                span.setAttribute('graphql.operation.type', request.operationName || 'unknown')
-                span.setAttribute(
-                  'graphql.document.sha256',
-                  request.query ? sha256(request.query) : 'empty'
-                )
-                // span.setAttribute('graphql.document', request.query?.replaceAll(/\s+/g, ' ') || '') // WARNING: verbose
+                span.setAttribute('type', operation?.operation || 'unknown')
+                span.setAttribute('name', request.operationName || 'unknown')
+                span.setAttribute('hash', request.query ? sha256(request.query) : 'empty')
+                // span.setAttribute('query', request.query?.replaceAll(/\s+/g, ' ') || '') // WARNING: verbose
                 span.end()
               },
             }
@@ -50,9 +47,9 @@ export default config<TypeInfo>({
           'http request',
           {
             attributes: {
-              'http.request.method': req.method,
-              'http.request.path': req.path,
-              'user_agent.original': req.headers['user-agent'] || '',
+              method: req.method,
+              path: req.path,
+              userAgent: req.headers['user-agent'] || '',
             },
           },
           span => {
@@ -84,4 +81,4 @@ export default config<TypeInfo>({
     ],
   },
   lists,
-})
+})
\ No newline at end of file
diff --git a/packages/core/src/lib/core/mutations/index.ts b/packages/core/src/lib/core/mutations/index.ts
index f4d76e3d5..5b48fde28 100644
--- a/packages/core/src/lib/core/mutations/index.ts
+++ b/packages/core/src/lib/core/mutations/index.ts
@@ -79,7 +79,7 @@ async function createSingle__(
 ) {
   return await withSpan(
     `create ${list.graphql.names.outputTypeNameLower}`,
-    async span => {
+    async () => {
       // throw an accessDeniedError if not allowed
       await enforceListLevelAccessControl(context, 'create', list, inputData, undefined)
       await enforceFieldLevelAccessControl(context, 'create', list, inputData, undefined)
@@ -94,17 +94,13 @@ async function createSingle__(
       await beforeOperation()
 
       // operation
-      const result = await context.prisma[list.listKey].create({
+      const item = await context.prisma[list.listKey].create({
         data: list.isSingleton ? { ...data, id: 1 } : data,
       })
 
-      span.setAttribute('keystone.result.id', result?.id ?? '')
-      return { item: result, afterOperation }
+      return { item, afterOperation }
     },
-    {
-      'keystone.list': list.listKey,
-      'keystone.operation': 'create',
-    }
+    { 'keystone.list': list.listKey, 'keystone.operation': 'create' }
   )
 }
 
@@ -147,7 +143,7 @@ async function updateSingle__(
 ) {
   return await withSpan(
     `update ${list.graphql.names.outputTypeNameLower}`,
-    async span => {
+    async () => {
       // validate and resolve the input filter
       const uniqueWhere = await resolveUniqueWhereInput(where, list, context)
 
@@ -168,16 +164,15 @@ async function updateSingle__(
       await beforeOperation()
 
       // operation
-      const result = await context.prisma[list.listKey].update({
+      const updatedItem = await context.prisma[list.listKey].update({
         where: { id: item.id },
         data,
       })
-      span.setAttribute('keystone.result.id', result?.id ?? '')
 
       // after operation
-      await afterOperation(result)
+      await afterOperation(updatedItem)
 
-      return result
+      return updatedItem
     },
     { 'keystone.list': list.listKey, 'keystone.operation': 'update' }
   )
@@ -191,7 +186,7 @@ async function deleteSingle__(
 ) {
   return await withSpan(
     `delete ${list.graphql.names.outputTypeNameLower}`,
-    async span => {
+    async () => {
       // validate and resolve the input filter
       const uniqueWhere = await resolveUniqueWhereInput(where, list, context)
 
@@ -219,7 +214,6 @@ async function deleteSingle__(
 
       // operation
       const result = await context.prisma[list.listKey].delete({ where: { id: item.id } })
-      span.setAttribute('keystone.result.id', result?.id ?? '')
 
       // after operation
       await runSideEffectOnlyHook(list, 'afterOperation', {
@@ -242,7 +236,7 @@ async function actionSingle__(
 ) {
   return await withSpan(
     action.otel,
-    async span => {
+    async () => {
       // no before operation hook for actions
 
       // operation
@@ -254,7 +248,6 @@ async function actionSingle__(
         },
         context
       )
-      span.setAttribute('keystone.result.id', (result?.id as string) ?? '')
 
       // no after operation hook for actions
       return result
@@ -458,454 +451,4 @@ async function getResolvedData(
         const inputResolver = field.input?.[operation]?.resolve
         let input = resolvedData[fieldKey]
         if (inputResolver && field.dbField.kind === 'relation') {
-          const tag = `${list.listKey}.${fieldKey}`
-          try {
-            input = await inputResolver(
-              input,
-              context,
-              // this third argument only applies to relationship fields
-              (() => {
-                if (input === undefined) {
-                  // no-op: this is what we want
-                  return () => undefined
-                }
-                if (input === null) {
-                  // no-op: should this be userinputerror?
-                  return () => undefined
-                }
-                const foreignList = list.lists[field.dbField.list]
-                if (field.dbField.mode === 'many' && operation === 'create') {
-                  return resolveRelateToManyForCreateInput(
-                    nestedMutationState,
-                    context,
-                    foreignList,
-                    tag
-                  )
-                }
-
-                if (field.dbField.mode === 'many' && operation === 'update') {
-                  return resolveRelateToManyForUpdateInput(
-                    nestedMutationState,
-                    context,
-                    foreignList,
-                    tag
-                  )
-                }
-
-                if (field.dbField.mode === 'one' && operation === 'create') {
-                  return resolveRelateToOneForCreateInput(nestedMutationState, context, foreignList)
-                }
-
-                if (field.dbField.mode === 'one' && operation === 'update') {
-                  return resolveRelateToOneForUpdateInput(nestedMutationState, context, foreignList)
-                }
-
-                throw new Error('Unknown relationship field type input mode or operation')
-              })()
-            )
-          } catch (error: any) {
-            if (error instanceof RelationshipErrors) {
-              relationshipErrors.push(...error.errors)
-            } else {
-              relationshipErrors.push({ error, tag })
-            }
-          }
-        }
-        return [fieldKey, input] as const
-      })
-    )
-  )
-
-  if (relationshipErrors.length) throw relationshipError(relationshipErrors)
-
-  // field hooks
-  const fieldsErrors: { error: Error; tag: string }[] = []
-  resolvedData = Object.fromEntries(
-    await Promise.all(
-      Object.entries(list.fields).map(async ([fieldKey, field]) => {
-        try {
-          return [
-            fieldKey,
-            operation === 'create'
-              ? await field.hooks.resolveInput.create({
-                  ...hookArgs,
-                  itemField: undefined,
-                  inputFieldData: hookArgs.inputData[fieldKey],
-                  resolvedData,
-                  resolvedFieldData: resolvedData[fieldKey],
-                  fieldKey,
-                })
-              : await field.hooks.resolveInput.update({
-                  ...hookArgs,
-                  itemField: hookArgs.item[fieldKey],
-                  inputFieldData: hookArgs.inputData[fieldKey],
-                  resolvedData,
-                  resolvedFieldData: resolvedData[fieldKey],
-                  fieldKey,
-                }),
-          ]
-        } catch (error: any) {
-          fieldsErrors.push({
-            error,
-            tag: `${list.listKey}.${fieldKey}.hooks.resolveInput`,
-          })
-          return [fieldKey, undefined]
-        }
-      })
-    )
-  )
-
-  if (fieldsErrors.length) throw extensionError('resolveInput', fieldsErrors)
-
-  // list hooks
-  try {
-    if (operation === 'create') {
-      resolvedData = await list.hooks.resolveInput.create({ ...hookArgs, resolvedData })
-    } else if (operation === 'update') {
-      resolvedData = await list.hooks.resolveInput.update({ ...hookArgs, resolvedData })
-    }
-  } catch (error: any) {
-    throw extensionError('resolveInput', [{ error, tag: `${list.listKey}.hooks.resolveInput` }])
-  }
-
-  return resolvedData
-}
-
-async function resolveInputForCreateOrUpdate(
-  list: InitialisedList,
-  context: KeystoneContext,
-  inputData: Record<string, unknown>,
-  item: BaseItem | undefined
-) {
-  const nestedMutationState = new NestedMutationState(context)
-  const baseHookArgs = {
-    context,
-    listKey: list.listKey,
-    inputData,
-    resolvedData: {},
-  }
-  const hookArgs =
-    item === undefined
-      ? { ...baseHookArgs, operation: 'create' as const, item, originalItem: undefined }
-      : { ...baseHookArgs, operation: 'update' as const, item, originalItem: item }
-
-  // Take the original input and resolve all the fields down to what
-  // will be saved into the database.
-  hookArgs.resolvedData = await getResolvedData(list, hookArgs, nestedMutationState)
-
-  // Apply all validation checks
-  await validate({ list, hookArgs })
-
-  // Return the full resolved input (ready for prisma level operation),
-  // and the afterOperation hook to be applied
-  return {
-    data: transformForPrismaClient(list, context, hookArgs.resolvedData),
-    beforeOperation: async () => {
-      // before operation
-      await runSideEffectOnlyHook(list, 'beforeOperation', hookArgs)
-    },
-    afterOperation: async (updatedItem: BaseItem) => {
-      await nestedMutationState.afterOperation()
-
-      // after operation
-      await runSideEffectOnlyHook(list, 'afterOperation', {
-        ...hookArgs,
-        item: updatedItem,
-      })
-    },
-  }
-}
-
-function transformInnerDBField(
-  dbField: Exclude<ResolvedDBField, { kind: 'multi' }>,
-  context: KeystoneContext,
-  value: unknown
-) {
-  if (dbField.kind === 'scalar' && dbField.scalar === 'Json' && value === null) {
-    return context.__internal.prisma.DbNull
-  }
-  return value
-}
-
-function transformForPrismaClient(
-  list: InitialisedList,
-  context: KeystoneContext,
-  data: Record<string, any>
-) {
-  return Object.fromEntries([
-    ...(function* () {
-      for (const fieldKey in data) {
-        if (!(fieldKey in list.fields)) {
-          // either the types are wrong, or someone didnt use them, either way, bail out
-          throw new Error(`Attempted to use unknown field "${fieldKey}"`)
-        }
-        const value = data[fieldKey]
-        const { dbField } = list.fields[fieldKey]
-
-        if (dbField.kind === 'multi') {
-          for (const innerFieldKey in value) {
-            const innerFieldValue = value[innerFieldKey]
-            yield [
-              getDBFieldKeyForFieldOnMultiField(fieldKey, innerFieldKey),
-              transformInnerDBField(dbField.fields[innerFieldKey], context, innerFieldValue),
-            ]
-          }
-
-          continue
-        }
-
-        yield [fieldKey, transformInnerDBField(dbField, context, value)]
-      }
-    })(),
-  ])
-}
-
-// This is not a thing that I really agree with but it's to make the behaviour consistent with old keystone.
-// Basically, old keystone uses Promise.allSettled and then after that maps that into promises that resolve and reject,
-// whereas the new stuff is just like "here are some promises" with no guarantees about the order they will be settled in.
-// That doesn't matter when they all resolve successfully because the order they resolve successfully in
-// doesn't affect anything, If some reject though, the order that they reject in will be the order in the errors array
-// and some of our tests rely on the order of the graphql errors array. They shouldn't, but they do.
-function promisesButSettledWhenAllSettledAndInOrder<T extends Promise<unknown>[]>(promises: T): T {
-  const resultsPromise = Promise.allSettled(promises)
-  return promises.map(async (_, i) => {
-    const result: PromiseSettledResult<Awaited<T>> = (await resultsPromise)[i] as any
-    return result.status === 'fulfilled'
-      ? Promise.resolve(result.value)
-      : Promise.reject(result.reason)
-  }) as T
-}
-
-function nonNull<T extends GNullableInputType>(t: T) {
-  if (t === g.Empty) return t
-  return g.nonNull(t)
-}
-
-export function getMutationsForList(list: InitialisedList) {
-  const defaultUniqueWhereInput = list.isSingleton ? { id: '1' } : undefined
-
-  const createOne_ = g.field({
-    type: list.graphql.types.output,
-    args: {
-      data: g.arg({ type: nonNull(list.graphql.types.create) }),
-    },
-    async resolve(_, { data }, context, info) {
-      return await withSpan(
-        `mutation ${info.fieldName}`,
-        async () => {
-          return createOne(data, list, context)
-        },
-        { 'keystone.list': list.listKey, 'keystone.operation': 'create' }
-      )
-    },
-  })
-
-  const createMany_ = g.field({
-    type: g.list(list.graphql.types.output),
-    args: {
-      data: g.arg({
-        type: g.nonNull(g.list(nonNull(list.graphql.types.create))),
-      }),
-    },
-    async resolve(_, { data }, context, info) {
-      return await withSpan(
-        `mutation ${info.fieldName}`,
-        async () => {
-          return promisesButSettledWhenAllSettledAndInOrder(await createMany(data, list, context))
-        },
-        { 'keystone.list': list.listKey, 'keystone.operation': 'create', 'keystone.many': true }
-      )
-    },
-  })
-
-  const updateOne_ = g.field({
-    type: list.graphql.types.output,
-    args: {
-      where: g.arg({
-        type: g.nonNull(list.graphql.types.uniqueWhere),
-        defaultValue: defaultUniqueWhereInput,
-      }),
-      data: g.arg({ type: nonNull(list.graphql.types.update) }),
-    },
-    async resolve(_, { where, data }, context, info) {
-      return await withSpan(
-        `mutation ${info.fieldName}`,
-        async () => {
-          return updateOne({ where, data }, list, context)
-        },
-        { 'keystone.list': list.listKey, 'keystone.operation': 'update' }
-      )
-    },
-  })
-
-  const updateManyInput = g.inputObject({
-    name: list.graphql.names.updateManyInputName,
-    fields: {
-      where: g.arg({
-        type: g.nonNull(list.graphql.types.uniqueWhere),
-        defaultValue: defaultUniqueWhereInput,
-      }),
-      data: g.arg({ type: nonNull(list.graphql.types.update) }),
-    },
-  })
-  const updateMany_ = g.field({
-    type: g.list(list.graphql.types.output),
-    args: {
-      data: g.arg({
-        type: g.nonNull(g.list(g.nonNull(updateManyInput))),
-      }),
-    },
-    async resolve(_, { data }, context, info) {
-      return await withSpan(
-        `mutation ${info.fieldName}`,
-        async () => {
-          return promisesButSettledWhenAllSettledAndInOrder(await updateMany(data, list, context))
-        },
-        { 'keystone.list': list.listKey, 'keystone.operation': 'update', 'keystone.many': true }
-      )
-    },
-  })
-
-  const deleteOne_ = g.field({
-    type: list.graphql.types.output,
-    args: {
-      where: g.arg({
-        type: g.nonNull(list.graphql.types.uniqueWhere),
-        defaultValue: defaultUniqueWhereInput,
-      }),
-    },
-    async resolve(_, { where }, context, info) {
-      return await withSpan(
-        `mutation ${info.fieldName}`,
-        async () => {
-          return deleteOne(where, list, context)
-        },
-        { 'keystone.list': list.listKey, 'keystone.operation': 'delete' }
-      )
-    },
-  })
-
-  const deleteMany_ = g.field({
-    type: g.list(list.graphql.types.output),
-    args: {
-      where: g.arg({
-        type: g.nonNull(g.list(g.nonNull(list.graphql.types.uniqueWhere))),
-      }),
-    },
-    async resolve(_, { where }, context, info) {
-      return await withSpan(
-        `mutation ${info.fieldName}`,
-        async () => {
-          return promisesButSettledWhenAllSettledAndInOrder(await deleteMany(where, list, context))
-        },
-        { 'keystone.list': list.listKey, 'keystone.operation': 'delete', 'keystone.many': true }
-      )
-    },
-  })
-
-  const collectedTypes: GraphQLNamedType[] = []
-  const { isEnabled } = list.graphql
-  if (isEnabled.type) {
-    // adding all of these types explicitly isn't strictly necessary but we do it to create a certain order in the schema
-    collectedTypes.push(list.graphql.types.output)
-    if (isEnabled.query || isEnabled.update || isEnabled.delete) {
-      collectedTypes.push(list.graphql.types.uniqueWhere)
-    }
-    if (isEnabled.query) {
-      for (const field of Object.values(list.fields)) {
-        if (
-          isEnabled.query &&
-          field.graphql.isEnabled.read &&
-          field.unreferencedConcreteInterfaceImplementations
-        ) {
-          // this _IS_ actually necessary since they aren't implicitly referenced by other types, unlike the types above
-          collectedTypes.push(...field.unreferencedConcreteInterfaceImplementations)
-        }
-      }
-      collectedTypes.push(list.graphql.types.where)
-      collectedTypes.push(list.graphql.types.orderBy)
-    }
-    if (isEnabled.update) {
-      if (list.graphql.types.update instanceof GInputObjectType) {
-        collectedTypes.push(list.graphql.types.update)
-      }
-      collectedTypes.push(updateManyInput)
-    }
-    if (isEnabled.create) {
-      if (list.graphql.types.create instanceof GInputObjectType) {
-        collectedTypes.push(list.graphql.types.create)
-      }
-    }
-  }
-
-  return {
-    mutations: {
-      ...(list.graphql.isEnabled.create && {
-        [list.graphql.names.createMutationName]: createOne_,
-        [list.graphql.names.createManyMutationName]: createMany_,
-      }),
-      ...(list.graphql.isEnabled.update && {
-        [list.graphql.names.updateMutationName]: updateOne_,
-        [list.graphql.names.updateManyMutationName]: updateMany_,
-      }),
-      ...(list.graphql.isEnabled.delete && {
-        [list.graphql.names.deleteMutationName]: deleteOne_,
-        [list.graphql.names.deleteManyMutationName]: deleteMany_,
-      }),
-      ...Object.fromEntries(
-        (function* () {
-          for (const action of list.actions) {
-            yield [
-              action.graphql.names.one,
-              g.field({
-                type: list.graphql.types.output,
-                args: {
-                  where: g.arg({
-                    type: g.nonNull(list.graphql.types.uniqueWhere),
-                    defaultValue: defaultUniqueWhereInput,
-                  }),
-                },
-                async resolve(_, { where }, context, info) {
-                  return await withSpan(
-                    `mutation ${info.fieldName}`,
-                    async () => {
-                      return actionOne(where, list, context, action)
-                    },
-                    { 'keystone.list': list.listKey, 'keystone.action': action.actionKey }
-                  )
-                },
-              }),
-            ]
-            yield [
-              action.graphql.names.many,
-              g.field({
-                type: g.list(list.graphql.types.output),
-                args: {
-                  where: g.arg({
-                    type: g.nonNull(g.list(g.nonNull(list.graphql.types.uniqueWhere))),
-                  }),
-                },
-                async resolve(_, { where }, context, info) {
-                  return await withSpan(
-                    `mutation ${info.fieldName}`,
-                    async () => {
-                      return promisesButSettledWhenAllSettledAndInOrder(
-                        await actionMany(where, list, context, action)
-                      )
-                    },
-                    {
-                      'keystone.list': list.listKey,
-                      'keystone.action': action.actionKey,
-                      'keystone.many': true,
-                    }
-                  )
-                },
-              }),
-            ]
-          }
-        })()
-      ),
-    },
-    types: collectedTypes,
-  }
-}
+          const tag = `${list.listKey}.
\ No newline at end of file
diff --git a/packages/core/src/lib/utils.ts b/packages/core/src/lib/utils.ts
index c28c531e0..089e87264 100644
--- a/packages/core/src/lib/utils.ts
+++ b/packages/core/src/lib/utils.ts
@@ -1,21 +1,14 @@
-// WARNING: this is an opinionated subject, with too many ways to do this
-//   we went with a subset that we are happy with
-//   see tests2/utils.test.ts for examples
-export function humanize(s: string, capitalize: boolean = true) {
-  // drop non-alphanumeric
-  s = s.replace(/[^a-zA-Z0-9]+/g, ' ')
+/**
+ * Turns a passed in string into a human readable label
+ * @param {String} str The string to convert.
+ * @returns The new string
+ */
+export function humanize(str: string, capitalize: boolean = true) {
+  str = str.replace(/[^a-zA-Z0-9]+/g, ' ').replace(/([a-z0-9])([A-Z]+)/g, '$1 $2')
 
-  // insert spaces before camels of length > 1
-  for (let i = 0; i < 24; i++) {
-    // not unbounded, shouldnt happen
-    const next = s.replace(/([a-z0-9])([A-Z][A-Za-z0-9])/, '$1 $2')
-    if (next === s) break
-    s = next
-  }
-
-  if (!capitalize) return s
-  return s
+  if (!capitalize) return str
+  return str
     .split(' ')
     .map(x => x.charAt(0).toUpperCase() + x.slice(1))
     .join(' ')
-}
+}
\ No newline at end of file
diff --git a/tests2/utils.test.ts b/tests2/utils.test.ts
index 00ab8adc7..4ccbe8420 100644
--- a/tests2/utils.test.ts
+++ b/tests2/utils.test.ts
@@ -11,19 +11,12 @@ describe('utils', () => {
     assert.equal(humanize('kebab-case'), 'Kebab Case')
     assert.equal(humanize('multiple words here'), 'Multiple Words Here')
     assert.equal(humanize('Multiple Words Here'), 'Multiple Words Here')
+    assert.equal(humanize('Thing42WithOther43'), 'Thing42 With Other43')
+    assert.equal(humanize('Thing42_withOther43', false), 'Thing42 with Other43')
     assert.equal(humanize('foo'), 'Foo')
     assert.equal(humanize('Foo'), 'Foo')
     assert.equal(humanize('fooBar'), 'Foo Bar')
     assert.equal(humanize('FooBar'), 'Foo Bar')
     assert.equal(humanize('Foo Bar'), 'Foo Bar')
-    assert.equal(humanize('Foo11WithBar11'), 'Foo11 With Bar11')
-    assert.equal(humanize('Foo1A_WithBar11'), 'Foo1A With Bar11')
-    assert.equal(humanize('Foo1AA_WithBar11'), 'Foo1 AA With Bar11')
-    assert.equal(humanize('Foo11_WithBar11'), 'Foo11 With Bar11')
-    assert.equal(humanize('Foo11_WithBar11A'), 'Foo11 With Bar11A')
-    assert.equal(humanize('Foo11_WithBar11AA'), 'Foo11 With Bar11 AA')
-    assert.equal(humanize('Foo11_withBar11', false), 'Foo11 with Bar11')
-    assert.equal(humanize('FOO1A_BAR11'), 'FOO1A BAR11')
-    assert.equal(humanize('FOO1A1_BAR11'), 'FOO1 A1 BAR11')
   })
-})
+})
\ No newline at end of file
