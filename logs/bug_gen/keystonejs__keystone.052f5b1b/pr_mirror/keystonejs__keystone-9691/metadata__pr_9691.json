{
    "cost": 0.5983750000000001,
    "rewrites": {
        "keystonejs__keystone.052f5b1b/examples/actions/schema.ts": {
            "output": "import { list } from '@keystone-6/core'\nimport { allowAll, denyAll } from '@keystone-6/core/access'\nimport { checkbox, integer, text, timestamp } from '@keystone-6/core/fields'\n\nimport type { Lists } from '.keystone/types'\n\n// WARNING: this example is for demonstration purposes only\n//   as with each of our examples, it has not been vetted\n//   or tested for any particular usage\n\nconst readOnly = {\n  access: {\n    read: allowAll,\n    create: denyAll,\n    update: denyAll,\n  },\n  graphql: {\n    omit: {\n      create: true,\n      update: true,\n    },\n  },\n  ui: {\n    createView: {\n      fieldMode: 'hidden' as const,\n    },\n    itemView: {\n      fieldMode: 'read' as const,\n      fieldPosition: 'sidebar' as const,\n    },\n  },\n}\n\nexport const lists = {\n  Post: list({\n    access: allowAll, // WARNING: public\n    fields: {\n      title: text(),\n      content: text(),\n      hidden: checkbox({\n        ui: {\n          itemView: {\n            fieldMode: ({ item, itemField }) => {\n              // WARNING: none of this is access control\n              if (!item || item.votes === null) return 'edit'\n              if (itemField) return 'edit'\n              return item.votes > 0 ? 'read' : 'edit'\n            },\n          },\n        },\n      }),\n      votes: integer({ defaultValue: 0, ...readOnly }),\n      reportedAt: timestamp({ ...readOnly }),\n    },\n    actions: {\n      vote: {\n        access: ({ context }) => {\n          const ua = context.req?.headers['user-agent'] ?? ''\n          // only allow voting from Chrome browsers\n          return ua.includes('Chrome')\n        },\n        // with navigation: 'follow', null redirects to the list view, otherwise to the item view {with the returned item id}\n        async resolve({ actionKey, where }, context) {\n          console.log(`${actionKey}`, JSON.stringify({ where }))\n          if (!where) return null\n          if (typeof where.id !== 'string') return null // TODO: FIXME: { increment } support for context.db?\n\n          // WARNING: prisma bypasses access control, be wary of this\n          return await context.prisma.post.update({\n            where: { id: where.id },\n            data: {\n              votes: {\n                increment: 1,\n              },\n            },\n          })\n        },\n        ui: {\n          label: 'Vote +1',\n          icon: 'voteIcon',\n          messages: {\n            success: 'Voted for {itemLabel}',\n            successMany: 'Voted for {countSuccess} {singular|plural}',\n          },\n          itemView: {\n            hidePrompt: true,\n          },\n          listView: {\n            actionMode: 'hidden',\n          },\n        },\n      },\n      report: {\n        access: allowAll,\n        async resolve({ actionKey, where }, context) {\n          console.log(`${actionKey}`, JSON.stringify({ where }))\n          return await context.db.Post.updateOne({\n            where,\n            data: {\n              reportedAt: new Date(),\n            },\n          })\n        },\n        graphql: {\n          singular: 'reportAPost', // optional, defaults to 'reportPost'\n          plural: 'reportSomePosts', // optional, defaults to 'reportPosts'\n        },\n        ui: {\n          label: 'Report',\n          icon: 'flagIcon',\n          messages: {\n            promptTitle: 'Report {singular}',\n            promptTitleMany: 'Report {count} {singular|plural}',\n            prompt: 'Are you sure you want to report \"{itemLabel}\"?',\n            promptMany: 'Are you sure you want to report {count} {singular|plural}?',\n            promptConfirmLabel: 'Yes, report',\n            promptConfirmLabelMany: 'Yes, report {count} {singular|plural}',\n            fail: 'Could not report {singular}',\n            failMany: 'Could not report {countFail} {singular|plural}',\n            success: '{Singular} reported',\n            successMany: 'Successfully reported {countSuccess} {singular|plural}',\n          },\n          itemView: {\n            actionMode: () => 'enabled',\n            navigation: 'refetch',\n            hideToast: true,\n          },\n          listView: {\n            actionMode: 'enabled',\n          },\n        },\n      },\n    },\n    ui: {\n      listView: {\n        initialFilter: {\n          hidden: { equals: false },\n        },\n        initialSort: { field: 'votes', direction: 'DESC' },\n      },\n    },\n  }),\n} satisfies Lists",
            "output_extracted": "import { list } from '@keystone-6/core'\nimport { allowAll, denyAll } from '@keystone-6/core/access'\nimport { checkbox, integer, text, timestamp } from '@keystone-6/core/fields'\n\nimport type { Lists } from '.keystone/types'\n\n// WARNING: this example is for demonstration purposes only\n//   as with each of our examples, it has not been vetted\n//   or tested for any particular usage\n\nconst readOnly = {\n  access: {\n    read: allowAll,\n    create: denyAll,\n    update: denyAll,\n  },\n  graphql: {\n    omit: {\n      create: true,\n      update: true,\n    },\n  },\n  ui: {\n    createView: {\n      fieldMode: 'hidden' as const,\n    },\n    itemView: {\n      fieldMode: 'read' as const,\n      fieldPosition: 'sidebar' as const,\n    },\n  },\n}\n\nexport const lists = {\n  Post: list({\n    access: allowAll, // WARNING: public\n    fields: {\n      title: text(),\n      content: text(),\n      hidden: checkbox({\n        ui: {\n          itemView: {\n            fieldMode: ({ item, itemField }) => {\n              // WARNING: none of this is access control\n              if (!item || item.votes === null) return 'edit'\n              if (itemField) return 'edit'\n              return item.votes > 0 ? 'read' : 'edit'\n            },\n          },\n        },\n      }),\n      votes: integer({ defaultValue: 0, ...readOnly }),\n      reportedAt: timestamp({ ...readOnly }),\n    },\n    actions: {\n      vote: {\n        access: ({ context }) => {\n          const ua = context.req?.headers['user-agent'] ?? ''\n          // only allow voting from Chrome browsers\n          return ua.includes('Chrome')\n        },\n        // with navigation: 'follow', null redirects to the list view, otherwise to the item view {with the returned item id}\n        async resolve({ actionKey, where }, context) {\n          console.log(`${actionKey}`, JSON.stringify({ where }))\n          if (!where) return null\n          if (typeof where.id !== 'string') return null // TODO: FIXME: { increment } support for context.db?\n\n          // WARNING: prisma bypasses access control, be wary of this\n          return await context.prisma.post.update({\n            where: { id: where.id },\n            data: {\n              votes: {\n                increment: 1,\n              },\n            },\n          })\n        },\n        ui: {\n          label: 'Vote +1',\n          icon: 'voteIcon',\n          messages: {\n            success: 'Voted for {itemLabel}',\n            successMany: 'Voted for {countSuccess} {singular|plural}',\n          },\n          itemView: {\n            hidePrompt: true,\n          },\n          listView: {\n            actionMode: 'hidden',\n          },\n        },\n      },\n      report: {\n        access: allowAll,\n        async resolve({ actionKey, where }, context) {\n          console.log(`${actionKey}`, JSON.stringify({ where }))\n          return await context.db.Post.updateOne({\n            where,\n            data: {\n              reportedAt: new Date(),\n            },\n          })\n        },\n        graphql: {\n          singular: 'reportAPost', // optional, defaults to 'reportPost'\n          plural: 'reportSomePosts', // optional, defaults to 'reportPosts'\n        },\n        ui: {\n          label: 'Report',\n          icon: 'flagIcon',\n          messages: {\n            promptTitle: 'Report {singular}',\n            promptTitleMany: 'Report {count} {singular|plural}',\n            prompt: 'Are you sure you want to report \"{itemLabel}\"?',\n            promptMany: 'Are you sure you want to report {count} {singular|plural}?',\n            promptConfirmLabel: 'Yes, report',\n            promptConfirmLabelMany: 'Yes, report {count} {singular|plural}',\n            fail: 'Could not report {singular}',\n            failMany: 'Could not report {countFail} {singular|plural}',\n            success: '{Singular} reported',\n            successMany: 'Successfully reported {countSuccess} {singular|plural}',\n          },\n          itemView: {\n            actionMode: () => 'enabled',\n            navigation: 'refetch',\n            hideToast: true,\n          },\n          listView: {\n            actionMode: 'enabled',\n          },\n        },\n      },\n    },\n    ui: {\n      listView: {\n        initialFilter: {\n          hidden: { equals: false },\n        },\n        initialSort: { field: 'votes', direction: 'DESC' },\n      },\n    },\n  }),\n} satisfies Lists",
            "cost": 0.041615
        },
        "keystonejs__keystone.052f5b1b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/CreateItemPage/index.tsx": {
            "output": "import { useRouter } from 'next/router'\n\nimport { Button } from '@keystar/ui/button'\nimport { VStack } from '@keystar/ui/layout'\n\nimport { useList } from '../../../../admin-ui'\nimport { GraphQLErrorNotice } from '../../../../admin-ui/components'\nimport { PageContainer } from '../../../../admin-ui/components/PageContainer'\nimport { Fields } from '../../../../admin-ui/utils'\nimport { useCreateItem } from '../../../../admin-ui/utils/useCreateItem'\nimport { BaseToolbar, ColumnLayout, ItemPageHeader } from '../ItemPage/common'\n\nexport const getCreateItemPage = (props: Parameters<typeof CreateItemPage>[0]) => () => (\n  <CreateItemPage {...props} />\n)\n\nfunction CreateItemPage({ listKey }: { listKey: string }) {\n  const list = useList(listKey)\n  const createItem = useCreateItem(list)\n  const router = useRouter()\n\n  return (\n    <PageContainer\n      title={`Create ${list.singular}`}\n      header={\n        <ItemPageHeader\n          list={list}\n          label=\"Create\"\n          title={`Create ${list.singular}`}\n          item={null}\n          onAction={null}\n        />\n      }\n    >\n      <ColumnLayout>\n        <form\n          onSubmit={async e => {\n            if (e.target !== e.currentTarget) return\n            e.preventDefault()\n\n            const item = await createItem.create()\n            if (!item) return\n\n            router.push(`/${list.path}/${item.id}`)\n          }}\n          style={{ display: 'contents' }}\n        >\n          {/*\n            Workaround for react-aria \"bug\" where pressing enter in a form field\n            moves focus to the submit button.\n            See: https://github.com/adobe/react-spectrum/issues/5940\n          */}\n          <button type=\"submit\" style={{ display: 'none' }} />\n          <VStack gap=\"large\" gridArea=\"main\" marginTop=\"xlarge\" minWidth={0}>\n            <GraphQLErrorNotice errors={[createItem.error]} />\n            <Fields {...createItem.props} />\n          </VStack>\n\n          <BaseToolbar>\n            <Button isPending={createItem.state === 'loading'} prominence=\"high\" type=\"submit\">\n              Create\n            </Button>\n          </BaseToolbar>\n        </form>\n      </ColumnLayout>\n    </PageContainer>\n  )\n}",
            "output_extracted": "import { useRouter } from 'next/router'\n\nimport { Button } from '@keystar/ui/button'\nimport { VStack } from '@keystar/ui/layout'\n\nimport { useList } from '../../../../admin-ui'\nimport { GraphQLErrorNotice } from '../../../../admin-ui/components'\nimport { PageContainer } from '../../../../admin-ui/components/PageContainer'\nimport { Fields } from '../../../../admin-ui/utils'\nimport { useCreateItem } from '../../../../admin-ui/utils/useCreateItem'\nimport { BaseToolbar, ColumnLayout, ItemPageHeader } from '../ItemPage/common'\n\nexport const getCreateItemPage = (props: Parameters<typeof CreateItemPage>[0]) => () => (\n  <CreateItemPage {...props} />\n)\n\nfunction CreateItemPage({ listKey }: { listKey: string }) {\n  const list = useList(listKey)\n  const createItem = useCreateItem(list)\n  const router = useRouter()\n\n  return (\n    <PageContainer\n      title={`Create ${list.singular}`}\n      header={\n        <ItemPageHeader\n          list={list}\n          label=\"Create\"\n          title={`Create ${list.singular}`}\n          item={null}\n          onAction={null}\n        />\n      }\n    >\n      <ColumnLayout>\n        <form\n          onSubmit={async e => {\n            if (e.target !== e.currentTarget) return\n            e.preventDefault()\n\n            const item = await createItem.create()\n            if (!item) return\n\n            router.push(`/${list.path}/${item.id}`)\n          }}\n          style={{ display: 'contents' }}\n        >\n          {/*\n            Workaround for react-aria \"bug\" where pressing enter in a form field\n            moves focus to the submit button.\n            See: https://github.com/adobe/react-spectrum/issues/5940\n          */}\n          <button type=\"submit\" style={{ display: 'none' }} />\n          <VStack gap=\"large\" gridArea=\"main\" marginTop=\"xlarge\" minWidth={0}>\n            <GraphQLErrorNotice errors={[createItem.error]} />\n            <Fields {...createItem.props} />\n          </VStack>\n\n          <BaseToolbar>\n            <Button isPending={createItem.state === 'loading'} prominence=\"high\" type=\"submit\">\n              Create\n            </Button>\n          </BaseToolbar>\n        </form>\n      </ColumnLayout>\n    </PageContainer>\n  )\n}",
            "cost": 0.023105
        },
        "keystonejs__keystone.052f5b1b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/common.tsx": {
            "output": "import { useRouter } from 'next/router'\nimport type { HTMLAttributes, ReactNode } from 'react'\nimport { Fragment, useMemo, useState } from 'react'\n\nimport { ActionGroup } from '@keystar/ui/action-group'\nimport { Breadcrumbs, Item } from '@keystar/ui/breadcrumbs'\nimport { AlertDialog, DialogContainer } from '@keystar/ui/dialog'\nimport { Icon } from '@keystar/ui/icon'\nimport { allIcons as KeystarIcons } from '@keystar/ui/icon/all'\nimport { Grid, HStack } from '@keystar/ui/layout'\nimport { breakpointQueries, css, tokenSchema } from '@keystar/ui/style'\nimport { toastQueue } from '@keystar/ui/toast'\nimport { Heading, Text } from '@keystar/ui/typography'\nimport { gql, type TypedDocumentNode, useApolloClient } from '../../../../admin-ui/apollo'\nimport { Container, CONTAINER_MAX } from '../../../../admin-ui/components/Container'\nimport { ErrorDetailsDialog } from '../../../../admin-ui/components/Errors'\nimport type { ActionMeta, ListMeta } from '../../../../types'\n\nexport function ItemPageHeader({\n  list,\n  item,\n  label,\n  title = label,\n  onAction,\n}: {\n  list: ListMeta\n  item: Record<string, unknown> | null\n  label: string\n  title: string\n  onAction: ((action: ActionMeta, resultId: string) => void) | null\n}) {\n  const router = useRouter()\n  const actions = list.actions.filter(action => action.itemView.actionMode !== 'hidden')\n\n  return (\n    <Grid\n      // fill space; take over layout from the `PageContainer` flex wrapper\n      flex\n      // make sure actions don't run into the primary element, even though it'll truncate\n      gap=\"medium\"\n      // best efforts to ensure actions collapse first, then the title/breadcrumbs may truncate\n      columns={`minmax(50cqw, auto) minmax(${tokenSchema.size.element.regular}, max-content)`}\n      // grid areas required because the `ActionGroup` implements focus\n      // sentinels (span) before and after the root element\n      areas={['primary secondary']}\n      // treat this area like a container\n      minWidth={0}\n      maxWidth={CONTAINER_MAX}\n    >\n      {list.isSingleton ? (\n        <Heading elementType=\"h1\" size=\"small\" gridArea=\"primary\" truncate>\n          {list.label}\n        </Heading>\n      ) : (\n        <>\n          <Breadcrumbs size=\"medium\" gridArea=\"primary\">\n            <Item href={`/${list.path}`}>{list.label}</Item>\n            <Item href={router.asPath}>{label}</Item>\n          </Breadcrumbs>\n\n          {/* Every page must have an H1 for accessibility. */}\n          <Text elementType=\"h1\" visuallyHidden>\n            {title}\n          </Text>\n        </>\n      )}\n\n      {item && onAction && actions.length > 0 && (\n        <ItemActions list={list} item={item} actions={actions} onAction={onAction} />\n      )}\n    </Grid>\n  )\n}\n\nfunction replace(\n  s: string,\n  list: ListMeta,\n  args: {\n    itemLabel?: string\n  }\n) {\n  if (s.includes('{Singular}')) s = s.replaceAll('{Singular}', list.singular)\n  if (s.includes('{Plural}')) s = s.replaceAll('{Plural}', list.plural)\n  if (s.includes('{singular}')) s = s.replaceAll('{singular}', list.singular.toLowerCase())\n  if (s.includes('{plural}')) s = s.replaceAll('{plural}', list.plural.toLowerCase())\n  if ('itemLabel' in args) s = s.replaceAll('{itemLabel}', args.itemLabel ?? '')\n  return s\n}\n\nfunction ItemActions({\n  list,\n  item,\n  actions,\n  onAction,\n}: {\n  list: ListMeta\n  item: Record<string, unknown>\n  actions: ActionMeta[]\n  onAction: (action: ActionMeta, resultId: string | null) => void\n}) {\n  const apolloClient = useApolloClient()\n  const actionItems = useMemo(\n    () =>\n      actions.map(action => ({\n        id: action.key,\n        label: action.label,\n        icon: action.icon ? KeystarIcons[action.icon] : null,\n      })),\n    [actions]\n  )\n  const [errorDialogValue, setErrorDialogValue] = useState<Error | null>(null)\n  const [activeAction, setActiveAction] = useState<ActionMeta | null>(null)\n  const itemLabel_ = item[list.labelField] ?? item.id\n  const itemLabel = typeof itemLabel_ === 'string' ? itemLabel_ : (item.id as string)\n\n  const disabledKeys = useMemo(\n    () =>\n      actions.filter(action => action.itemView.actionMode === 'disabled').map(action => action.key),\n    [actions]\n  )\n\n  async function onTryAction(action: ActionMeta, confirmed: boolean) {\n    setActiveAction(null)\n\n    if (!confirmed && !action.itemView.hidePrompt) {\n      setActiveAction(action)\n      return\n    }\n\n    const { messages: m } = action\n    try {\n      const data = await apolloClient.mutate({\n        mutation: gql`mutation ${action.graphql.names.one}($id: ID!) {\n            result: ${action.graphql.names.one}(where: { id: $id }) {\n              id\n            }\n          }` as TypedDocumentNode<{ result: { id: string } }, { id: string }>,\n        variables: { id: item.id as string },\n      })\n\n      if (!action.itemView.hideToast) {\n        toastQueue.neutral(replace(m.success, list, { itemLabel }), { timeout: 5000 })\n      }\n\n      onAction(action, data.data?.result?.id)\n    } catch (err: any) {\n      toastQueue.critical(replace(m.fail, list, { itemLabel }), {\n        actionLabel: 'Details',\n        onAction: () => setErrorDialogValue(err),\n        shouldCloseOnAction: true,\n      })\n    }\n  }\n\n  return (\n    <Fragment>\n      <ActionGroup\n        gridArea=\"secondary\"\n        disabledKeys={disabledKeys}\n        overflowMode=\"collapse\"\n        items={actionItems}\n        onAction={key => {\n          const action = list.actions.find(action => action.key === key)\n          if (!action) return\n          onTryAction(action, false)\n        }}\n      >\n        {item => (\n          <Item textValue={item.label}>\n            {item.icon && <Icon src={item.icon} />}\n            <Text>{item.label}</Text>\n          </Item>\n        )}\n      </ActionGroup>\n      <DialogContainer onDismiss={() => setActiveAction(null)}>\n        {activeAction && (\n          <AlertDialog\n            title={replace(activeAction.messages.promptTitle, list, { itemLabel })}\n            cancelLabel=\"Cancel\"\n            primaryActionLabel={replace(activeAction.messages.promptConfirmLabel, list, {\n              itemLabel,\n            })}\n            onPrimaryAction={async () => {\n              await onTryAction(activeAction, true)\n            }}\n          >\n            {replace(activeAction.messages.prompt, list, { itemLabel })}\n          </AlertDialog>\n        )}\n      </DialogContainer>\n\n      <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n      </DialogContainer>\n    </Fragment>\n  )\n}\n\nexport function ColumnLayout(props: HTMLAttributes<HTMLDivElement>) {\n  return (\n    // this container must be relative to catch absolute children\n    // particularly the \"expanded\" document-field, which needs a height of 100%\n    <Container position=\"relative\" height=\"100%\">\n      <div\n        className={css({\n          display: 'grid',\n          columnGap: tokenSchema.size.space.xlarge,\n          gridTemplateAreas: '\"main\" \"sidebar\" \"toolbar\"',\n\n          [breakpointQueries.above.tablet]: {\n            gridTemplateColumns: `2fr minmax(${tokenSchema.size.scale[3600]}, 1fr)`,\n            gridTemplateAreas: '\"main sidebar\" \"toolbar toolbar\"',\n          },\n        })}\n        {...props}\n      />\n    </Container>\n  )\n}\n\nexport function StickySidebar(props: HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={css({\n        gridArea: 'sidebar',\n        marginTop: tokenSchema.size.space.xlarge,\n\n        [breakpointQueries.above.tablet]: {\n          alignSelf: 'start',\n          marginBottom: tokenSchema.size.element.xlarge,\n          // sync with toolbar height\n          paddingBottom: tokenSchema.size.element.xlarge,\n          position: 'sticky',\n          top: tokenSchema.size.space.xlarge,\n        },\n      })}\n      {...props}\n    />\n  )\n}\n\nexport function BaseToolbar(props: { children: ReactNode }) {\n  return (\n    <Grid\n      backgroundColor=\"surface\"\n      columns=\"subgrid\"\n      gridArea=\"toolbar\"\n      insetBottom={0}\n      marginTop=\"xlarge\"\n      position={{ tablet: 'sticky' }}\n      zIndex={20}\n      UNSAFE_className={css({\n        // fuzzy mask sidebar fields, which slide behind the un-bordered portion\n        // of the sticky toolbar\n        [breakpointQueries.above.tablet]: {\n          '&::after': {\n            boxShadow: `0 -4px 4px 1px ${tokenSchema.color.background.surface}`,\n            content: '\"\"',\n          },\n        },\n      })}\n    >\n      <HStack\n        alignItems=\"center\"\n        borderTop=\"neutral\"\n        gap=\"regular\"\n        height=\"element.xlarge\"\n        UNSAFE_className={css({\n          // stretch horizontally to ensure field focus-rings are covered\n          [breakpointQueries.above.mobile]: {\n            backgroundColor: tokenSchema.color.background.surface,\n            marginInline: `calc(${tokenSchema.size.alias.focusRing} * -1)`,\n            paddingInline: tokenSchema.size.alias.focusRing,\n          },\n        })}\n      >\n        {props.children}\n      </HStack>\n    </Grid>\n  )\n}",
            "output_extracted": "import { useRouter } from 'next/router'\nimport type { HTMLAttributes, ReactNode } from 'react'\nimport { Fragment, useMemo, useState } from 'react'\n\nimport { ActionGroup } from '@keystar/ui/action-group'\nimport { Breadcrumbs, Item } from '@keystar/ui/breadcrumbs'\nimport { AlertDialog, DialogContainer } from '@keystar/ui/dialog'\nimport { Icon } from '@keystar/ui/icon'\nimport { allIcons as KeystarIcons } from '@keystar/ui/icon/all'\nimport { Grid, HStack } from '@keystar/ui/layout'\nimport { breakpointQueries, css, tokenSchema } from '@keystar/ui/style'\nimport { toastQueue } from '@keystar/ui/toast'\nimport { Heading, Text } from '@keystar/ui/typography'\nimport { gql, type TypedDocumentNode, useApolloClient } from '../../../../admin-ui/apollo'\nimport { Container, CONTAINER_MAX } from '../../../../admin-ui/components/Container'\nimport { ErrorDetailsDialog } from '../../../../admin-ui/components/Errors'\nimport type { ActionMeta, ListMeta } from '../../../../types'\n\nexport function ItemPageHeader({\n  list,\n  item,\n  label,\n  title = label,\n  onAction,\n}: {\n  list: ListMeta\n  item: Record<string, unknown> | null\n  label: string\n  title: string\n  onAction: ((action: ActionMeta, resultId: string) => void) | null\n}) {\n  const router = useRouter()\n  const actions = list.actions.filter(action => action.itemView.actionMode !== 'hidden')\n\n  return (\n    <Grid\n      // fill space; take over layout from the `PageContainer` flex wrapper\n      flex\n      // make sure actions don't run into the primary element, even though it'll truncate\n      gap=\"medium\"\n      // best efforts to ensure actions collapse first, then the title/breadcrumbs may truncate\n      columns={`minmax(50cqw, auto) minmax(${tokenSchema.size.element.regular}, max-content)`}\n      // grid areas required because the `ActionGroup` implements focus\n      // sentinels (span) before and after the root element\n      areas={['primary secondary']}\n      // treat this area like a container\n      minWidth={0}\n      maxWidth={CONTAINER_MAX}\n    >\n      {list.isSingleton ? (\n        <Heading elementType=\"h1\" size=\"small\" gridArea=\"primary\" truncate>\n          {list.label}\n        </Heading>\n      ) : (\n        <>\n          <Breadcrumbs size=\"medium\" gridArea=\"primary\">\n            <Item href={`/${list.path}`}>{list.label}</Item>\n            <Item href={router.asPath}>{label}</Item>\n          </Breadcrumbs>\n\n          {/* Every page must have an H1 for accessibility. */}\n          <Text elementType=\"h1\" visuallyHidden>\n            {title}\n          </Text>\n        </>\n      )}\n\n      {item && onAction && actions.length > 0 && (\n        <ItemActions list={list} item={item} actions={actions} onAction={onAction} />\n      )}\n    </Grid>\n  )\n}\n\nfunction replace(\n  s: string,\n  list: ListMeta,\n  args: {\n    itemLabel?: string\n  }\n) {\n  if (s.includes('{Singular}')) s = s.replaceAll('{Singular}', list.singular)\n  if (s.includes('{Plural}')) s = s.replaceAll('{Plural}', list.plural)\n  if (s.includes('{singular}')) s = s.replaceAll('{singular}', list.singular.toLowerCase())\n  if (s.includes('{plural}')) s = s.replaceAll('{plural}', list.plural.toLowerCase())\n  if ('itemLabel' in args) s = s.replaceAll('{itemLabel}', args.itemLabel ?? '')\n  return s\n}\n\nfunction ItemActions({\n  list,\n  item,\n  actions,\n  onAction,\n}: {\n  list: ListMeta\n  item: Record<string, unknown>\n  actions: ActionMeta[]\n  onAction: (action: ActionMeta, resultId: string | null) => void\n}) {\n  const apolloClient = useApolloClient()\n  const actionItems = useMemo(\n    () =>\n      actions.map(action => ({\n        id: action.key,\n        label: action.label,\n        icon: action.icon ? KeystarIcons[action.icon] : null,\n      })),\n    [actions]\n  )\n  const [errorDialogValue, setErrorDialogValue] = useState<Error | null>(null)\n  const [activeAction, setActiveAction] = useState<ActionMeta | null>(null)\n  const itemLabel_ = item[list.labelField] ?? item.id\n  const itemLabel = typeof itemLabel_ === 'string' ? itemLabel_ : (item.id as string)\n\n  const disabledKeys = useMemo(\n    () =>\n      actions.filter(action => action.itemView.actionMode === 'disabled').map(action => action.key),\n    [actions]\n  )\n\n  async function onTryAction(action: ActionMeta, confirmed: boolean) {\n    setActiveAction(null)\n\n    if (!confirmed && !action.itemView.hidePrompt) {\n      setActiveAction(action)\n      return\n    }\n\n    const { messages: m } = action\n    try {\n      const data = await apolloClient.mutate({\n        mutation: gql`mutation ${action.graphql.names.one}($id: ID!) {\n            result: ${action.graphql.names.one}(where: { id: $id }) {\n              id\n            }\n          }` as TypedDocumentNode<{ result: { id: string } }, { id: string }>,\n        variables: { id: item.id as string },\n      })\n\n      if (!action.itemView.hideToast) {\n        toastQueue.neutral(replace(m.success, list, { itemLabel }), { timeout: 5000 })\n      }\n\n      onAction(action, data.data?.result?.id)\n    } catch (err: any) {\n      toastQueue.critical(replace(m.fail, list, { itemLabel }), {\n        actionLabel: 'Details',\n        onAction: () => setErrorDialogValue(err),\n        shouldCloseOnAction: true,\n      })\n    }\n  }\n\n  return (\n    <Fragment>\n      <ActionGroup\n        gridArea=\"secondary\"\n        disabledKeys={disabledKeys}\n        overflowMode=\"collapse\"\n        items={actionItems}\n        onAction={key => {\n          const action = list.actions.find(action => action.key === key)\n          if (!action) return\n          onTryAction(action, false)\n        }}\n      >\n        {item => (\n          <Item textValue={item.label}>\n            {item.icon && <Icon src={item.icon} />}\n            <Text>{item.label}</Text>\n          </Item>\n        )}\n      </ActionGroup>\n      <DialogContainer onDismiss={() => setActiveAction(null)}>\n        {activeAction && (\n          <AlertDialog\n            title={replace(activeAction.messages.promptTitle, list, { itemLabel })}\n            cancelLabel=\"Cancel\"\n            primaryActionLabel={replace(activeAction.messages.promptConfirmLabel, list, {\n              itemLabel,\n            })}\n            onPrimaryAction={async () => {\n              await onTryAction(activeAction, true)\n            }}\n          >\n            {replace(activeAction.messages.prompt, list, { itemLabel })}\n          </AlertDialog>\n        )}\n      </DialogContainer>\n\n      <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n      </DialogContainer>\n    </Fragment>\n  )\n}\n\nexport function ColumnLayout(props: HTMLAttributes<HTMLDivElement>) {\n  return (\n    // this container must be relative to catch absolute children\n    // particularly the \"expanded\" document-field, which needs a height of 100%\n    <Container position=\"relative\" height=\"100%\">\n      <div\n        className={css({\n          display: 'grid',\n          columnGap: tokenSchema.size.space.xlarge,\n          gridTemplateAreas: '\"main\" \"sidebar\" \"toolbar\"',\n\n          [breakpointQueries.above.tablet]: {\n            gridTemplateColumns: `2fr minmax(${tokenSchema.size.scale[3600]}, 1fr)`,\n            gridTemplateAreas: '\"main sidebar\" \"toolbar toolbar\"',\n          },\n        })}\n        {...props}\n      />\n    </Container>\n  )\n}\n\nexport function StickySidebar(props: HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={css({\n        gridArea: 'sidebar',\n        marginTop: tokenSchema.size.space.xlarge,\n\n        [breakpointQueries.above.tablet]: {\n          alignSelf: 'start',\n          marginBottom: tokenSchema.size.element.xlarge,\n          // sync with toolbar height\n          paddingBottom: tokenSchema.size.element.xlarge,\n          position: 'sticky',\n          top: tokenSchema.size.space.xlarge,\n        },\n      })}\n      {...props}\n    />\n  )\n}\n\nexport function BaseToolbar(props: { children: ReactNode }) {\n  return (\n    <Grid\n      backgroundColor=\"surface\"\n      columns=\"subgrid\"\n      gridArea=\"toolbar\"\n      insetBottom={0}\n      marginTop=\"xlarge\"\n      position={{ tablet: 'sticky' }}\n      zIndex={20}\n      UNSAFE_className={css({\n        // fuzzy mask sidebar fields, which slide behind the un-bordered portion\n        // of the sticky toolbar\n        [breakpointQueries.above.tablet]: {\n          '&::after': {\n            boxShadow: `0 -4px 4px 1px ${tokenSchema.color.background.surface}`,\n            content: '\"\"',\n          },\n        },\n      })}\n    >\n      <HStack\n        alignItems=\"center\"\n        borderTop=\"neutral\"\n        gap=\"regular\"\n        height=\"element.xlarge\"\n        UNSAFE_className={css({\n          // stretch horizontally to ensure field focus-rings are covered\n          [breakpointQueries.above.mobile]: {\n            backgroundColor: tokenSchema.color.background.surface,\n            marginInline: `calc(${tokenSchema.size.alias.focusRing} * -1)`,\n            paddingInline: tokenSchema.size.alias.focusRing,\n          },\n        })}\n      >\n        {props.children}\n      </HStack>\n    </Grid>\n  )\n}",
            "cost": 0.089465
        },
        "keystonejs__keystone.052f5b1b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/index.tsx": {
            "output": "import router, { useRouter } from 'next/router'\nimport {\n  type FormEvent,\n  Fragment,\n  type PropsWithChildren,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\n\nimport { Button } from '@keystar/ui/button'\nimport { AlertDialog, DialogContainer, DialogTrigger } from '@keystar/ui/dialog'\nimport { Icon } from '@keystar/ui/icon'\nimport { fileWarningIcon } from '@keystar/ui/icon/icons/fileWarningIcon'\nimport { Box, VStack } from '@keystar/ui/layout'\nimport { ProgressCircle } from '@keystar/ui/progress'\nimport { SlotProvider } from '@keystar/ui/slots'\nimport { toastQueue } from '@keystar/ui/toast'\nimport { Heading, Text } from '@keystar/ui/typography'\n\nimport { CombinedGraphQLErrors, gql, useMutation } from '../../../../admin-ui/apollo'\nimport { CreateButtonLink } from '../../../../admin-ui/components/CreateButtonLink'\nimport { ErrorDetailsDialog } from '../../../../admin-ui/components/Errors'\nimport { GraphQLErrorNotice } from '../../../../admin-ui/components/GraphQLErrorNotice'\nimport { PageContainer } from '../../../../admin-ui/components/PageContainer'\nimport { useList, useListItem } from '../../../../admin-ui/context'\nimport {\n  deserializeItemToValue,\n  Fields,\n  serializeValueToOperationItem,\n  useHasChanges,\n  useInvalidFields,\n} from '../../../../admin-ui/utils'\nimport type {\n  ActionMeta,\n  BaseListTypeInfo,\n  ConditionalFilter,\n  ConditionalFilterCase,\n  ListMeta,\n} from '../../../../types'\nimport { BaseToolbar, ColumnLayout, ItemPageHeader, StickySidebar } from './common'\n\ntype ItemPageProps = {\n  listKey: string\n}\n\nfunction useEventCallback<Func extends (...args: any[]) => unknown>(callback: Func): Func {\n  const callbackRef = useRef(callback)\n  const cb = useCallback((...args: any[]) => {\n    return callbackRef.current(...args)\n  }, [])\n  useEffect(() => {\n    callbackRef.current = callback\n  })\n  return cb as any\n}\n\nfunction DeleteButton({\n  list,\n  itemId,\n  itemLabel,\n}: {\n  list: ListMeta\n  itemId: string\n  itemLabel: string\n}) {\n  const [errorDialogValue, setErrorDialogValue] = useState<Error | null>(null)\n  const router = useRouter()\n  const [deleteItem] = useMutation(\n    gql`mutation ($id: ID!) {\n      ${list.graphql.names.deleteMutationName}(where: { id: $id }) {\n        id\n      }\n    }`,\n    { variables: { id: itemId } }\n  )\n\n  return (\n    <Fragment>\n      <DialogTrigger>\n        <Button tone=\"critical\">Delete</Button>\n        <AlertDialog\n          tone=\"critical\"\n          title=\"Delete item\"\n          cancelLabel=\"Cancel\"\n          primaryActionLabel=\"Yes, delete\"\n          onPrimaryAction={async () => {\n            try {\n              await deleteItem()\n            } catch (err: any) {\n              toastQueue.critical('Unable to delete item.', {\n                actionLabel: 'Details',\n                onAction: () => setErrorDialogValue(err),\n                shouldCloseOnAction: true,\n              })\n              return\n            }\n\n            toastQueue.neutral(`${list.singular} deleted.`, {\n              timeout: 5000,\n            })\n            router.push(list.isSingleton ? '/' : `/${list.path}`)\n          }}\n        >\n          <Text>\n            Are you sure you want to delete <strong style={{ fontWeight: 600 }}>{itemLabel}</strong>\n            ? This action cannot be undone.\n          </Text>\n        </AlertDialog>\n      </DialogTrigger>\n\n      <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n      </DialogContainer>\n    </Fragment>\n  )\n}\n\nfunction ItemNotFound(props: PropsWithChildren) {\n  return (\n    <VStack\n      alignItems=\"center\"\n      backgroundColor=\"surface\"\n      borderRadius=\"medium\"\n      gap=\"large\"\n      justifyContent=\"center\"\n      minHeight=\"scale.3000\"\n      padding=\"xlarge\"\n    >\n      <Icon src={fileWarningIcon} color=\"neutralEmphasis\" size=\"large\" />\n      <Heading align=\"center\">Not found</Heading>\n      <SlotProvider slots={{ text: { align: 'center', maxWidth: 'scale.5000' } }}>\n        {props.children}\n      </SlotProvider>\n    </VStack>\n  )\n}\n\nfunction ResetButton(props: { onReset: () => void; hasChanges?: boolean }) {\n  return (\n    <DialogTrigger>\n      <Button tone=\"accent\" isDisabled={!props.hasChanges}>\n        Reset\n      </Button>\n      <AlertDialog\n        title=\"Reset changes\"\n        cancelLabel=\"Cancel\"\n        primaryActionLabel=\"Yes, reset\"\n        autoFocusButton=\"primary\"\n        onPrimaryAction={props.onReset}\n      >\n        Are you sure? Lost changes cannot be recovered.\n      </AlertDialog>\n    </DialogTrigger>\n  )\n}\n\nfunction ItemForm({\n  listKey,\n  initialValue,\n  itemLabel,\n  onSaveSuccess,\n  fieldModes,\n  fieldPositions,\n  isRequireds,\n}: {\n  listKey: string\n  initialValue: Record<string, unknown>\n  itemLabel: string\n  onSaveSuccess: () => void\n  fieldModes: Record<string, ConditionalFilter<'edit' | 'read' | 'hidden', BaseListTypeInfo>>\n  isRequireds: Record<string, ConditionalFilterCase<BaseListTypeInfo>>\n  fieldPositions: Record<string, 'form' | 'sidebar'>\n}) {\n  const list = useList(listKey)\n  const itemId = initialValue.id as string\n  const [errorDialogValue, setErrorDialogValue] = useState<Error | null>(null)\n  const [update, { loading, error }] = useMutation(\n    gql`mutation ($id: ID!, $data: ${list.graphql.names.updateInputName}!) {\n      item: ${list.graphql.names.updateMutationName}(where: { id: $id }, data: $data) {\n        id\n      }\n    }`,\n    { errorPolicy: 'all' }\n  )\n\n  const [value, setValue] = useState(() => initialValue)\n  function resetValueState() {\n    setValue(() => initialValue)\n  }\n  useEffect(() => resetValueState(), [initialValue])\n\n  const invalidFields = useInvalidFields(list.fields, value, isRequireds)\n  const [forceValidation, setForceValidation] = useState(false)\n  const onSave = useEventCallback(async (e: FormEvent<HTMLFormElement>) => {\n    if (e.target !== e.currentTarget) return\n    e.preventDefault()\n    const newForceValidation = invalidFields.size !== 0\n    setForceValidation(newForceValidation)\n    if (newForceValidation) return\n\n    const { error: _error } = await update({\n      variables: {\n        id: itemId,\n        data: serializeValueToOperationItem('update', list.fields, value, initialValue),\n      },\n    })\n\n    const error = CombinedGraphQLErrors.is(_error)\n      ? _error.errors.find(x => x.path === undefined || x.path?.length === 1)\n      : _error\n    if (error) {\n      toastQueue.critical('Unable to save item', {\n        actionLabel: 'Details',\n        onAction: () => setErrorDialogValue(new Error(error.message)),\n        shouldCloseOnAction: true,\n      })\n      return\n    }\n\n    toastQueue.positive(`Saved changes to ${list.singular.toLocaleLowerCase()}`, {\n      timeout: 5000,\n    })\n\n    onSaveSuccess()\n  })\n\n  const hasChangedFields = useHasChanges('update', list.fields, value, initialValue)\n\n  return (\n    <Fragment>\n      <form onSubmit={onSave} style={{ display: 'contents' }}>\n        {/*\n          Workaround for react-aria \"bug\" where pressing enter in a form field\n          moves focus to the submit button.\n          See: https://github.com/adobe/react-spectrum/issues/5940\n        */}\n        <button type=\"submit\" style={{ display: 'none' }} />\n        <VStack gap=\"large\" gridArea=\"main\" marginTop=\"xlarge\" minWidth={0}>\n          <GraphQLErrorNotice\n            errors={\n              CombinedGraphQLErrors.is(error)\n                ? error.errors.filter(x => x.path === undefined || x.path?.length === 1)\n                : [error]\n            }\n          />\n          <Fields\n            view=\"itemView\"\n            position=\"form\"\n            fields={list.fields}\n            groups={list.groups}\n            forceValidation={forceValidation}\n            invalidFields={invalidFields}\n            fieldModes={fieldModes}\n            fieldPositions={fieldPositions}\n            onChange={useCallback(value => setValue(value), [setValue])}\n            value={value}\n            isRequireds={isRequireds}\n          />\n        </VStack>\n\n        <StickySidebar>\n          <Fields\n            view=\"itemView\"\n            position=\"sidebar\"\n            fields={list.fields}\n            groups={list.groups}\n            forceValidation={forceValidation}\n            invalidFields={invalidFields}\n            onChange={useCallback(value => setValue(value), [setValue])}\n            value={value}\n            fieldModes={fieldModes}\n            fieldPositions={fieldPositions}\n            isRequireds={isRequireds}\n          />\n        </StickySidebar>\n\n        <BaseToolbar>\n          <Button\n            isDisabled={!hasChangedFields}\n            isPending={loading}\n            prominence=\"high\"\n            type=\"submit\"\n          >\n            Save\n          </Button>\n          <ResetButton hasChanges={hasChangedFields} onReset={resetValueState} />\n          <Box flex />\n          {!list.hideDelete ? (\n            <DeleteButton list={list} itemId={itemId} itemLabel={itemLabel} />\n          ) : null}\n        </BaseToolbar>\n      </form>\n\n      <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n      </DialogContainer>\n    </Fragment>\n  )\n}\n\nexport const getItemPage = (props: ItemPageProps) => () => <ItemPage {...props} />\n\nfunction ItemPage({ listKey }: ItemPageProps) {\n  const list = useList(listKey)\n  const id_ = useRouter().query.id\n  const [itemId] = Array.isArray(id_) ? id_ : [id_]\n  const { data, error, loading, refetch } = useListItem(listKey, itemId ?? null)\n  const item = data?.item\n  const itemLabel_ = item?.[list.labelField] ?? item?.id\n  const itemLabel = typeof itemLabel_ === 'string' ? itemLabel_ : (itemId ?? '')\n\n  const pageLoading = loading || itemId === undefined\n  const pageLabel = itemLabel || itemId\n  const pageTitle = list.isSingleton || typeof pageLabel !== 'string' ? list.label : pageLabel\n  const initialValue = useMemo(() => {\n    if (!item) return null\n    return deserializeItemToValue(list.fields, item)\n  }, [list.fields, data?.item])\n\n  const { fieldModes, fieldPositions, isRequireds } = useMemo(() => {\n    const fieldModes = Object.fromEntries(\n      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.fieldMode])\n    )\n    const fieldPositions = Object.fromEntries(\n      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.fieldPosition])\n    )\n    const isRequireds = Object.fromEntries(\n      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.isRequired])\n    )\n    for (const field of data?.keystone.adminMeta.list?.fields ?? []) {\n      if (field.itemView) {\n        fieldModes[field.key] = field.itemView.fieldMode\n        fieldPositions[field.key] = field.itemView.fieldPosition\n        isRequireds[field.key] = field.itemView.isRequired\n      }\n    }\n    return { fieldModes, fieldPositions, isRequireds }\n  }, [data?.keystone.adminMeta, list.fields])\n\n  function onAction(action: ActionMeta, resultId: string | null) {\n    const { navigation } = action.itemView\n\n    if ((navigation === 'follow' && resultId === itemId) || navigation === 'refetch') {\n      refetch()\n    } else if (navigation === 'follow' && resultId) {\n      router.push(`/${list.path}/${resultId}`)\n    } else {\n      router.push(list.isSingleton ? '/' : `/${list.path}`)\n    }\n  }\n\n  return (\n    <PageContainer\n      title={pageTitle}\n      header={\n        <ItemPageHeader\n          list={list}\n          label={typeof pageLabel !== 'string' ? 'Loading...' : pageLabel}\n          title={pageTitle}\n          item={item ?? null}\n          onAction={onAction}\n        />\n      }\n    >\n      {pageLoading ? (\n        <VStack height=\"100%\" alignItems=\"center\" justifyContent=\"center\">\n          <ProgressCircle aria-label=\"loading item data\" size=\"large\" isIndeterminate />\n        </VStack>\n      ) : (\n        <ColumnLayout>\n          <Box marginY=\"xlarge\">\n            <GraphQLErrorNotice errors={[error]} />\n            {item == null &&\n              (list.isSingleton ? (\n                itemId === '1' ? (\n                  <ItemNotFound>\n                    <Text>\"{list.label}\" doesn't exist, or you don't have access to it.</Text>\n                    {!list.hideCreate && <CreateButtonLink list={list} />}\n                  </ItemNotFound>\n                ) : (\n                  <ItemNotFound>\n                    <Text>\n                      An item with ID <strong>\"{itemId}\"</strong> does not exist.\n                    </Text>\n                  </ItemNotFound>\n                )\n              ) : (\n                <ItemNotFound>\n                  <Text>\n                    The item with ID <strong>\"{itemId}\"</strong> doesn't exist, or you don't have\n                    access to it.\n                  </Text>\n                </ItemNotFound>\n              ))}\n          </Box>\n          {initialValue && (\n            <ItemForm\n              fieldModes={fieldModes}\n              fieldPositions={fieldPositions}\n              isRequireds={isRequireds}\n              listKey={listKey}\n              itemLabel={itemLabel}\n              initialValue={initialValue}\n              onSaveSuccess={refetch}\n            />\n          )}\n        </ColumnLayout>\n      )}\n    </PageContainer>\n  )\n}",
            "output_extracted": "import router, { useRouter } from 'next/router'\nimport {\n  type FormEvent,\n  Fragment,\n  type PropsWithChildren,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\n\nimport { Button } from '@keystar/ui/button'\nimport { AlertDialog, DialogContainer, DialogTrigger } from '@keystar/ui/dialog'\nimport { Icon } from '@keystar/ui/icon'\nimport { fileWarningIcon } from '@keystar/ui/icon/icons/fileWarningIcon'\nimport { Box, VStack } from '@keystar/ui/layout'\nimport { ProgressCircle } from '@keystar/ui/progress'\nimport { SlotProvider } from '@keystar/ui/slots'\nimport { toastQueue } from '@keystar/ui/toast'\nimport { Heading, Text } from '@keystar/ui/typography'\n\nimport { CombinedGraphQLErrors, gql, useMutation } from '../../../../admin-ui/apollo'\nimport { CreateButtonLink } from '../../../../admin-ui/components/CreateButtonLink'\nimport { ErrorDetailsDialog } from '../../../../admin-ui/components/Errors'\nimport { GraphQLErrorNotice } from '../../../../admin-ui/components/GraphQLErrorNotice'\nimport { PageContainer } from '../../../../admin-ui/components/PageContainer'\nimport { useList, useListItem } from '../../../../admin-ui/context'\nimport {\n  deserializeItemToValue,\n  Fields,\n  serializeValueToOperationItem,\n  useHasChanges,\n  useInvalidFields,\n} from '../../../../admin-ui/utils'\nimport type {\n  ActionMeta,\n  BaseListTypeInfo,\n  ConditionalFilter,\n  ConditionalFilterCase,\n  ListMeta,\n} from '../../../../types'\nimport { BaseToolbar, ColumnLayout, ItemPageHeader, StickySidebar } from './common'\n\ntype ItemPageProps = {\n  listKey: string\n}\n\nfunction useEventCallback<Func extends (...args: any[]) => unknown>(callback: Func): Func {\n  const callbackRef = useRef(callback)\n  const cb = useCallback((...args: any[]) => {\n    return callbackRef.current(...args)\n  }, [])\n  useEffect(() => {\n    callbackRef.current = callback\n  })\n  return cb as any\n}\n\nfunction DeleteButton({\n  list,\n  itemId,\n  itemLabel,\n}: {\n  list: ListMeta\n  itemId: string\n  itemLabel: string\n}) {\n  const [errorDialogValue, setErrorDialogValue] = useState<Error | null>(null)\n  const router = useRouter()\n  const [deleteItem] = useMutation(\n    gql`mutation ($id: ID!) {\n      ${list.graphql.names.deleteMutationName}(where: { id: $id }) {\n        id\n      }\n    }`,\n    { variables: { id: itemId } }\n  )\n\n  return (\n    <Fragment>\n      <DialogTrigger>\n        <Button tone=\"critical\">Delete</Button>\n        <AlertDialog\n          tone=\"critical\"\n          title=\"Delete item\"\n          cancelLabel=\"Cancel\"\n          primaryActionLabel=\"Yes, delete\"\n          onPrimaryAction={async () => {\n            try {\n              await deleteItem()\n            } catch (err: any) {\n              toastQueue.critical('Unable to delete item.', {\n                actionLabel: 'Details',\n                onAction: () => setErrorDialogValue(err),\n                shouldCloseOnAction: true,\n              })\n              return\n            }\n\n            toastQueue.neutral(`${list.singular} deleted.`, {\n              timeout: 5000,\n            })\n            router.push(list.isSingleton ? '/' : `/${list.path}`)\n          }}\n        >\n          <Text>\n            Are you sure you want to delete <strong style={{ fontWeight: 600 }}>{itemLabel}</strong>\n            ? This action cannot be undone.\n          </Text>\n        </AlertDialog>\n      </DialogTrigger>\n\n      <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n      </DialogContainer>\n    </Fragment>\n  )\n}\n\nfunction ItemNotFound(props: PropsWithChildren) {\n  return (\n    <VStack\n      alignItems=\"center\"\n      backgroundColor=\"surface\"\n      borderRadius=\"medium\"\n      gap=\"large\"\n      justifyContent=\"center\"\n      minHeight=\"scale.3000\"\n      padding=\"xlarge\"\n    >\n      <Icon src={fileWarningIcon} color=\"neutralEmphasis\" size=\"large\" />\n      <Heading align=\"center\">Not found</Heading>\n      <SlotProvider slots={{ text: { align: 'center', maxWidth: 'scale.5000' } }}>\n        {props.children}\n      </SlotProvider>\n    </VStack>\n  )\n}\n\nfunction ResetButton(props: { onReset: () => void; hasChanges?: boolean }) {\n  return (\n    <DialogTrigger>\n      <Button tone=\"accent\" isDisabled={!props.hasChanges}>\n        Reset\n      </Button>\n      <AlertDialog\n        title=\"Reset changes\"\n        cancelLabel=\"Cancel\"\n        primaryActionLabel=\"Yes, reset\"\n        autoFocusButton=\"primary\"\n        onPrimaryAction={props.onReset}\n      >\n        Are you sure? Lost changes cannot be recovered.\n      </AlertDialog>\n    </DialogTrigger>\n  )\n}\n\nfunction ItemForm({\n  listKey,\n  initialValue,\n  itemLabel,\n  onSaveSuccess,\n  fieldModes,\n  fieldPositions,\n  isRequireds,\n}: {\n  listKey: string\n  initialValue: Record<string, unknown>\n  itemLabel: string\n  onSaveSuccess: () => void\n  fieldModes: Record<string, ConditionalFilter<'edit' | 'read' | 'hidden', BaseListTypeInfo>>\n  isRequireds: Record<string, ConditionalFilterCase<BaseListTypeInfo>>\n  fieldPositions: Record<string, 'form' | 'sidebar'>\n}) {\n  const list = useList(listKey)\n  const itemId = initialValue.id as string\n  const [errorDialogValue, setErrorDialogValue] = useState<Error | null>(null)\n  const [update, { loading, error }] = useMutation(\n    gql`mutation ($id: ID!, $data: ${list.graphql.names.updateInputName}!) {\n      item: ${list.graphql.names.updateMutationName}(where: { id: $id }, data: $data) {\n        id\n      }\n    }`,\n    { errorPolicy: 'all' }\n  )\n\n  const [value, setValue] = useState(() => initialValue)\n  function resetValueState() {\n    setValue(() => initialValue)\n  }\n  useEffect(() => resetValueState(), [initialValue])\n\n  const invalidFields = useInvalidFields(list.fields, value, isRequireds)\n  const [forceValidation, setForceValidation] = useState(false)\n  const onSave = useEventCallback(async (e: FormEvent<HTMLFormElement>) => {\n    if (e.target !== e.currentTarget) return\n    e.preventDefault()\n    const newForceValidation = invalidFields.size !== 0\n    setForceValidation(newForceValidation)\n    if (newForceValidation) return\n\n    const { error: _error } = await update({\n      variables: {\n        id: itemId,\n        data: serializeValueToOperationItem('update', list.fields, value, initialValue),\n      },\n    })\n\n    const error = CombinedGraphQLErrors.is(_error)\n      ? _error.errors.find(x => x.path === undefined || x.path?.length === 1)\n      : _error\n    if (error) {\n      toastQueue.critical('Unable to save item', {\n        actionLabel: 'Details',\n        onAction: () => setErrorDialogValue(new Error(error.message)),\n        shouldCloseOnAction: true,\n      })\n      return\n    }\n\n    toastQueue.positive(`Saved changes to ${list.singular.toLocaleLowerCase()}`, {\n      timeout: 5000,\n    })\n\n    onSaveSuccess()\n  })\n\n  const hasChangedFields = useHasChanges('update', list.fields, value, initialValue)\n\n  return (\n    <Fragment>\n      <form onSubmit={onSave} style={{ display: 'contents' }}>\n        {/*\n          Workaround for react-aria \"bug\" where pressing enter in a form field\n          moves focus to the submit button.\n          See: https://github.com/adobe/react-spectrum/issues/5940\n        */}\n        <button type=\"submit\" style={{ display: 'none' }} />\n        <VStack gap=\"large\" gridArea=\"main\" marginTop=\"xlarge\" minWidth={0}>\n          <GraphQLErrorNotice\n            errors={\n              CombinedGraphQLErrors.is(error)\n                ? error.errors.filter(x => x.path === undefined || x.path?.length === 1)\n                : [error]\n            }\n          />\n          <Fields\n            view=\"itemView\"\n            position=\"form\"\n            fields={list.fields}\n            groups={list.groups}\n            forceValidation={forceValidation}\n            invalidFields={invalidFields}\n            fieldModes={fieldModes}\n            fieldPositions={fieldPositions}\n            onChange={useCallback(value => setValue(value), [setValue])}\n            value={value}\n            isRequireds={isRequireds}\n          />\n        </VStack>\n\n        <StickySidebar>\n          <Fields\n            view=\"itemView\"\n            position=\"sidebar\"\n            fields={list.fields}\n            groups={list.groups}\n            forceValidation={forceValidation}\n            invalidFields={invalidFields}\n            onChange={useCallback(value => setValue(value), [setValue])}\n            value={value}\n            fieldModes={fieldModes}\n            fieldPositions={fieldPositions}\n            isRequireds={isRequireds}\n          />\n        </StickySidebar>\n\n        <BaseToolbar>\n          <Button\n            isDisabled={!hasChangedFields}\n            isPending={loading}\n            prominence=\"high\"\n            type=\"submit\"\n          >\n            Save\n          </Button>\n          <ResetButton hasChanges={hasChangedFields} onReset={resetValueState} />\n          <Box flex />\n          {!list.hideDelete ? (\n            <DeleteButton list={list} itemId={itemId} itemLabel={itemLabel} />\n          ) : null}\n        </BaseToolbar>\n      </form>\n\n      <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n      </DialogContainer>\n    </Fragment>\n  )\n}\n\nexport const getItemPage = (props: ItemPageProps) => () => <ItemPage {...props} />\n\nfunction ItemPage({ listKey }: ItemPageProps) {\n  const list = useList(listKey)\n  const id_ = useRouter().query.id\n  const [itemId] = Array.isArray(id_) ? id_ : [id_]\n  const { data, error, loading, refetch } = useListItem(listKey, itemId ?? null)\n  const item = data?.item\n  const itemLabel_ = item?.[list.labelField] ?? item?.id\n  const itemLabel = typeof itemLabel_ === 'string' ? itemLabel_ : (itemId ?? '')\n\n  const pageLoading = loading || itemId === undefined\n  const pageLabel = itemLabel || itemId\n  const pageTitle = list.isSingleton || typeof pageLabel !== 'string' ? list.label : pageLabel\n  const initialValue = useMemo(() => {\n    if (!item) return null\n    return deserializeItemToValue(list.fields, item)\n  }, [list.fields, data?.item])\n\n  const { fieldModes, fieldPositions, isRequireds } = useMemo(() => {\n    const fieldModes = Object.fromEntries(\n      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.fieldMode])\n    )\n    const fieldPositions = Object.fromEntries(\n      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.fieldPosition])\n    )\n    const isRequireds = Object.fromEntries(\n      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.isRequired])\n    )\n    for (const field of data?.keystone.adminMeta.list?.fields ?? []) {\n      if (field.itemView) {\n        fieldModes[field.key] = field.itemView.fieldMode\n        fieldPositions[field.key] = field.itemView.fieldPosition\n        isRequireds[field.key] = field.itemView.isRequired\n      }\n    }\n    return { fieldModes, fieldPositions, isRequireds }\n  }, [data?.keystone.adminMeta, list.fields])\n\n  function onAction(action: ActionMeta, resultId: string | null) {\n    const { navigation } = action.itemView\n\n    if ((navigation === 'follow' && resultId === itemId) || navigation === 'refetch') {\n      refetch()\n    } else if (navigation === 'follow' && resultId) {\n      router.push(`/${list.path}/${resultId}`)\n    } else {\n      router.push(list.isSingleton ? '/' : `/${list.path}`)\n    }\n  }\n\n  return (\n    <PageContainer\n      title={pageTitle}\n      header={\n        <ItemPageHeader\n          list={list}\n          label={typeof pageLabel !== 'string' ? 'Loading...' : pageLabel}\n          title={pageTitle}\n          item={item ?? null}\n          onAction={onAction}\n        />\n      }\n    >\n      {pageLoading ? (\n        <VStack height=\"100%\" alignItems=\"center\" justifyContent=\"center\">\n          <ProgressCircle aria-label=\"loading item data\" size=\"large\" isIndeterminate />\n        </VStack>\n      ) : (\n        <ColumnLayout>\n          <Box marginY=\"xlarge\">\n            <GraphQLErrorNotice errors={[error]} />\n            {item == null &&\n              (list.isSingleton ? (\n                itemId === '1' ? (\n                  <ItemNotFound>\n                    <Text>\"{list.label}\" doesn't exist, or you don't have access to it.</Text>\n                    {!list.hideCreate && <CreateButtonLink list={list} />}\n                  </ItemNotFound>\n                ) : (\n                  <ItemNotFound>\n                    <Text>\n                      An item with ID <strong>\"{itemId}\"</strong> does not exist.\n                    </Text>\n                  </ItemNotFound>\n                )\n              ) : (\n                <ItemNotFound>\n                  <Text>\n                    The item with ID <strong>\"{itemId}\"</strong> doesn't exist, or you don't have\n                    access to it.\n                  </Text>\n                </ItemNotFound>\n              ))}\n          </Box>\n          {initialValue && (\n            <ItemForm\n              fieldModes={fieldModes}\n              fieldPositions={fieldPositions}\n              isRequireds={isRequireds}\n              listKey={listKey}\n              itemLabel={itemLabel}\n              initialValue={initialValue}\n              onSaveSuccess={refetch}\n            />\n          )}\n        </ColumnLayout>\n      )}\n    </PageContainer>\n  )\n}",
            "cost": 0.13202
        },
        "keystonejs__keystone.052f5b1b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/index.tsx": {
            "output": "import isDeepEqual from 'fast-deep-equal'\nimport { useRouter } from 'next/router'\nimport type { ParsedUrlQuery, ParsedUrlQueryInput } from 'querystring'\nimport { type FormEvent, type Key, Fragment, useEffect, useId, useMemo, useState } from 'react'\n\nimport { ActionBar, ActionBarContainer, Item } from '@keystar/ui/action-bar'\nimport { ActionButton, Button, ButtonGroup } from '@keystar/ui/button'\nimport { AlertDialog, Dialog, DialogContainer, DialogTrigger } from '@keystar/ui/dialog'\nimport { Icon } from '@keystar/ui/icon'\nimport { allIcons as KeystarIcons } from '@keystar/ui/icon/all'\nimport { chevronDownIcon } from '@keystar/ui/icon/icons/chevronDownIcon'\nimport { searchXIcon } from '@keystar/ui/icon/icons/searchXIcon'\nimport { textSelectIcon } from '@keystar/ui/icon/icons/textSelectIcon'\nimport { undo2Icon } from '@keystar/ui/icon/icons/undo2Icon'\nimport { Flex, HStack, VStack } from '@keystar/ui/layout'\nimport { Menu, MenuTrigger } from '@keystar/ui/menu'\nimport { ProgressCircle } from '@keystar/ui/progress'\nimport { SearchField } from '@keystar/ui/search-field'\nimport { Content } from '@keystar/ui/slots'\nimport { css, tokenSchema } from '@keystar/ui/style'\nimport {\n  type SortDescriptor,\n  Cell,\n  Column,\n  Row,\n  TableBody,\n  TableHeader,\n  TableView,\n} from '@keystar/ui/table'\nimport { toastQueue } from '@keystar/ui/toast'\nimport { Tooltip, TooltipTrigger } from '@keystar/ui/tooltip'\nimport { Heading, Text } from '@keystar/ui/typography'\n\nimport type { TypedDocumentNode } from '../../../../admin-ui/apollo'\nimport { gql, useMutation, useQuery } from '../../../../admin-ui/apollo'\nimport { CreateButtonLink } from '../../../../admin-ui/components/CreateButtonLink'\nimport { EmptyState } from '../../../../admin-ui/components/EmptyState'\nimport { GraphQLErrorNotice } from '../../../../admin-ui/components/GraphQLErrorNotice'\nimport { PageContainer } from '../../../../admin-ui/components/PageContainer'\nimport { useList } from '../../../../admin-ui/context'\nimport { useSearchFilter } from '../../../../fields/types/relationship/views/useFilter'\nimport type { ActionMeta, FieldMeta, JSONValue, ListMeta } from '../../../../types'\nimport { FilterAdd } from './FilterAdd'\nimport { PaginationControls, snapValueToClosest } from './PaginationControls'\nimport { Tag } from './Tag'\n\ntype ListPageProps = { listKey: string }\nexport type Filter = {\n  field: string\n  type: string\n  value: JSONValue\n}\n\nfunction FilterTag({\n  filter,\n  field,\n  onChange,\n  onRemove,\n}: {\n  filter: Filter\n  field: FieldMeta\n  onChange: (filter: Filter) => void\n  onRemove: () => void\n}) {\n  const Label = field.controller.filter!.Label\n  const tagElement = (\n    <Tag onRemove={onRemove}>\n      <Text>\n        <span>{field.label} </span>\n        <Label\n          label={field.controller.filter!.types[filter.type].label}\n          type={filter.type}\n          value={filter.value}\n        />\n      </Text>\n    </Tag>\n  )\n\n  // TODO: Special \"empty\" types need to be documented somewhere. Filters that\n  // have no editable value, basically `null` or `!null`. Which offers:\n  // * better DX \u2014 we can avoid weird nullable types and UIs that don't make sense\n  // * better UX \u2014 users don't have to jump through mental hoops, like \"is not exactly\" + submit empty field\n  if (filter.type === 'empty' || filter.type === 'not_empty') return tagElement\n\n  return (\n    <DialogTrigger type=\"popover\" mobileType=\"tray\">\n      {tagElement}\n      {onDismiss => (\n        <FilterEdit onChange={onChange} onDismiss={onDismiss} field={field} filter={filter} />\n      )}\n    </DialogTrigger>\n  )\n}\n\nfunction FilterEdit({\n  filter,\n  field,\n  onChange: onAdd,\n  onDismiss,\n}: {\n  filter: Filter\n  field: FieldMeta\n  onChange: (filter: Filter) => void\n  onDismiss: () => void\n}) {\n  const formId = useId()\n  const [value, setValue] = useState(filter.value)\n  const onSubmit = (event: FormEvent) => {\n    if (event.target !== event.currentTarget) return\n    event.preventDefault()\n\n    onAdd({\n      ...filter,\n      value,\n    })\n    onDismiss()\n  }\n\n  const Filter = field.controller.filter!.Filter\n  const filterTypeLabel = field.controller.filter?.types[filter.type].label\n\n  return (\n    <Dialog>\n      <Heading>{field.label}</Heading>\n      <Content>\n        <form onSubmit={onSubmit} id={formId}>\n          <Filter\n            autoFocus\n            context=\"edit\"\n            typeLabel={filterTypeLabel}\n            onChange={setValue}\n            type={filter.type}\n            value={value}\n          />\n        </form>\n      </Content>\n      <ButtonGroup>\n        <Button onPress={onDismiss}>Cancel</Button>\n        <Button type=\"submit\" prominence=\"high\" form={formId}>\n          Save\n        </Button>\n      </ButtonGroup>\n    </Dialog>\n  )\n}\n\nfunction getFilters(list: ListMeta, query: ParsedUrlQueryInput): Filter[] {\n  const param_ = query.filter\n  const params = Array.isArray(param_) ? param_ : typeof param_ === 'string' ? [param_] : []\n\n  if (!params.length) {\n    if (!list.initialFilter) return []\n\n    const filters: Filter[] = []\n    for (const [fieldKey, filter] of Object.entries(list.initialFilter)) {\n      const { controller } = list.fields[fieldKey]\n      for (const f of controller.filter?.parseGraphQL(filter as any as never) ?? []) {\n        filters.push({\n          field: fieldKey,\n          ...f,\n        })\n      }\n    }\n\n    return filters\n  }\n\n  const filters: Filter[] = []\n  for (const [fieldPath, field] of Object.entries(list.fields)) {\n    if (!field.isFilterable) continue\n    if (!field.controller.filter) continue\n\n    for (const filterType in field.controller.filter.types) {\n      const prefix = `${fieldPath}_${filterType}`\n      for (const queryFilter of params) {\n        if (!queryFilter.startsWith(prefix)) continue\n\n        if (queryFilter === prefix) {\n          filters.push({\n            type: filterType,\n            field: fieldPath,\n            value: null,\n          })\n          continue\n        }\n\n        const queryValue = queryFilter.slice(prefix.length + 1)\n        try {\n          const value = JSON.parse(queryValue)\n          filters.push({\n            type: filterType,\n            field: fieldPath,\n            value,\n          })\n        } catch (e) {\n          console.error('Error parsing filter', queryFilter)\n        }\n      }\n    }\n  }\n\n  return filters\n}\n\nfunction getSort(list: ListMeta, query: ParsedUrlQueryInput): SortDescriptor | null {\n  const param = typeof query.sortBy === 'string' ? query.sortBy : null\n  if (param === '') return null\n  if (!param) {\n    if (!list.initialSort) return null\n    return {\n      column: list.initialSort.field,\n      direction: list.initialSort.direction === 'ASC' ? 'ascending' : 'descending',\n    }\n  }\n\n  const fieldKey = param.startsWith('-') ? param.slice(1) : param\n  const direction = param.startsWith('-') ? 'descending' : 'ascending'\n  const field = list.fields[fieldKey]\n  if (!field) return null\n  if (!field.isOrderable) return null\n\n  return {\n    column: fieldKey,\n    direction,\n  }\n}\n\nfunction getCurrentPage(_: ListMeta, query: ParsedUrlQuery) {\n  const currentPage = Number(query.page)\n  if (Number.isNaN(currentPage) || currentPage < 1) return 1\n  return currentPage\n}\n\nfunction getPageSize(list: ListMeta, query: ParsedUrlQuery) {\n  const pageSize = Number(query.pageSize)\n  if (Number.isNaN(pageSize) || pageSize < 1) return list.pageSize\n  return snapValueToClosest(pageSize)\n}\n\nfunction getColumns(list: ListMeta, query: ParsedUrlQueryInput): string[] {\n  const param_ = query.column\n  const params = Array.isArray(param_) ? param_ : typeof param_ === 'string' ? [param_] : []\n  if (!params.length) return list.initialColumns\n  return params\n}\n\nexport const getListPage = (props: ListPageProps) => () => <ListPage {...props} />\n\ntype Selection = Set<string | number> | 'all'\nfunction ListPage({ listKey }: ListPageProps) {\n  const localStorageListKey = `keystone.list.${listKey}.list.page.info`\n\n  const list = useList(listKey)\n  const { query, replace, isReady } = useRouter()\n  const [sort, setSort] = useState<SortDescriptor | null>(() => getSort(list, {}))\n  const [columns, setColumns] = useState<string[]>(list.initialColumns)\n  const [filters, setFilters] = useState<Filter[]>(() => getFilters(list, {}))\n  const [currentPage, setCurrentPage] = useState<number>(1)\n  const [pageSize, setPageSize] = useState<number>(list.pageSize)\n  const [searchString, setSearchString] = useState('')\n  const [selectedItems, setSelectedItems] = useState<Selection>(() => new Set([]))\n  const [activeAction, setActiveAction] = useState<Key | null>(null)\n  const dirty = useMemo(() => {\n    const defaultFilters = getFilters(list, {})\n    const defaultSort = getSort(list, {})\n    return (\n      !!searchString ||\n      !isDeepEqual(filters, defaultFilters) ||\n      !isDeepEqual(sort, defaultSort) ||\n      !isDeepEqual(columns, list.initialColumns)\n    )\n  }, [searchString, filters, sort, columns, list.initialColumns])\n\n  useEffect(() => {\n    if (!isReady) return\n    if (loaded) return\n    let localStorageQuery\n    try {\n      localStorageQuery = JSON.parse(localStorage.getItem(localStorageListKey) ?? '{}')\n    } catch {}\n\n    setSort(getSort(list, { ...localStorageQuery, ...query }))\n    setColumns(getColumns(list, { ...localStorageQuery, ...query }))\n    setFilters(getFilters(list, { ...localStorageQuery, ...query }))\n    setCurrentPage(getCurrentPage(list, { ...localStorageQuery, ...query }))\n    setPageSize(getPageSize(list, { ...localStorageQuery, ...query }))\n    setSearchString(typeof query.search === 'string' ? query.search : '')\n    setLoaded(true)\n  }, [list, isReady])\n\n  useEffect(() => {\n    if (!isReady) return\n    if (!loaded) return // TODO: stop this race condition properly\n    const updatedQuery: ParsedUrlQueryInput = {\n      ...(columns.length ? { column: columns } : {}),\n      ...(sort ? { sortBy: sort.direction === 'ascending' ? sort.column : `-${sort.column}` } : {}),\n      ...(filters.length\n        ? {\n            filter: (function () {\n              const result: string[] = []\n              for (const filter of filters) {\n                if (filter.type === 'not_empty' || filter.type === 'empty') {\n                  result.push(`${filter.field}_${filter.type}`)\n                  continue\n                }\n\n                result.push(`${filter.field}_${filter.type}_${JSON.stringify(filter.value)}`)\n              }\n              return result\n            })(),\n          }\n        : {}),\n      ...(currentPage > 1 ? { page: currentPage } : {}),\n      ...(pageSize !== list.pageSize ? { pageSize } : {}),\n      ...(searchString ? { search: searchString } : {}),\n    }\n\n    localStorage.setItem(localStorageListKey, JSON.stringify(updatedQuery))\n    replace({ query: updatedQuery })\n  }, [columns, sort, filters, currentPage, pageSize, searchString, list])\n\n  const allowCreate = !(list.hideCreate ?? true)\n  const isConstrained = Boolean(filters.length || query.search)\n  const readableFields = Object.values(list.fields).map(f => ({\n    id: f.key,\n    value: f.key,\n    label: f.label,\n    isDisabled: f.listView.fieldMode === 'read',\n  }))\n  const shownFields = columns.map(fieldKey => list.fields[fieldKey]).filter(Boolean)\n  const where = useMemo(\n    () =>\n      filters.map(filter => {\n        return list.fields[filter.field].controller.filter!.graphql({\n          type: filter.type,\n          value: filter.value,\n        })\n      }),\n    [list, filters]\n  )\n\n  const search = useSearchFilter(searchString, list, list.initialSearchFields)\n  const { data, error, refetch, loading } = useQuery(\n    useMemo((): TypedDocumentNode<{\n      items: Record<string, unknown>[] | null\n      count: number | null\n    }> => {\n      const selectedGqlFields = shownFields\n        .filter(field => field.key !== 'id') // id is always included\n        .map(field => field.controller.graphqlSelection)\n        .join('\\n')\n\n      // TODO: less interpolation\n      return gql`\n        query (\n          $where: ${list.graphql.names.whereInputName},\n          $take: Int!,\n          $skip: Int!,\n          $orderBy: [${list.graphql.names.listOrderName}!]\n        ) {\n          items: ${list.graphql.names.listQueryName}(\n            where: $where,\n            take: $take,\n            skip: $skip,\n            orderBy: $orderBy\n          ) {\n            id\n            ${selectedGqlFields}\n          }\n          count: ${list.graphql.names.listQueryCountName}(where: $where)\n        }\n      `\n    }, [list, shownFields]),\n    {\n      fetchPolicy: 'cache-and-network',\n      errorPolicy: 'all',\n      variables: {\n        where: {\n          ...(where.length ? { AND: where } : {}),\n          ...(search.length ? { OR: search } : {}),\n        },\n        take: pageSize,\n        skip: (currentPage - 1) * pageSize,\n        orderBy: sort\n          ? [\n              {\n                [sort.column]: sort.direction === 'ascending' ? 'asc' : 'desc',\n              },\n            ]\n          : undefined,\n      },\n    }\n  )\n\n  useEffect(() => {\n    if (typeof data?.count !== 'number') return\n\n    const lastPage = Math.max(Math.ceil(data.count / pageSize), 1)\n    if (currentPage > lastPage) {\n      setCurrentPage(lastPage)\n    }\n  }, [data])\n\n  const selectedItemIds = (\n    selectedItems === 'all' ? (data?.items?.map(item => item.id) ?? []) : Array.from(selectedItems)\n  ).map(String)\n  const isEmpty = Boolean(data?.count === 0 && !isConstrained)\n  const headers = shownFields.map(field => {\n    return {\n      id: field.",
            "output_extracted": "import isDeepEqual from 'fast-deep-equal'\nimport { useRouter } from 'next/router'\nimport type { ParsedUrlQuery, ParsedUrlQueryInput } from 'querystring'\nimport { type FormEvent, type Key, Fragment, useEffect, useId, useMemo, useState } from 'react'\n\nimport { ActionBar, ActionBarContainer, Item } from '@keystar/ui/action-bar'\nimport { ActionButton, Button, ButtonGroup } from '@keystar/ui/button'\nimport { AlertDialog, Dialog, DialogContainer, DialogTrigger } from '@keystar/ui/dialog'\nimport { Icon } from '@keystar/ui/icon'\nimport { allIcons as KeystarIcons } from '@keystar/ui/icon/all'\nimport { chevronDownIcon } from '@keystar/ui/icon/icons/chevronDownIcon'\nimport { searchXIcon } from '@keystar/ui/icon/icons/searchXIcon'\nimport { textSelectIcon } from '@keystar/ui/icon/icons/textSelectIcon'\nimport { undo2Icon } from '@keystar/ui/icon/icons/undo2Icon'\nimport { Flex, HStack, VStack } from '@keystar/ui/layout'\nimport { Menu, MenuTrigger } from '@keystar/ui/menu'\nimport { ProgressCircle } from '@keystar/ui/progress'\nimport { SearchField } from '@keystar/ui/search-field'\nimport { Content } from '@keystar/ui/slots'\nimport { css, tokenSchema } from '@keystar/ui/style'\nimport {\n  type SortDescriptor,\n  Cell,\n  Column,\n  Row,\n  TableBody,\n  TableHeader,\n  TableView,\n} from '@keystar/ui/table'\nimport { toastQueue } from '@keystar/ui/toast'\nimport { Tooltip, TooltipTrigger } from '@keystar/ui/tooltip'\nimport { Heading, Text } from '@keystar/ui/typography'\n\nimport type { TypedDocumentNode } from '../../../../admin-ui/apollo'\nimport { gql, useMutation, useQuery } from '../../../../admin-ui/apollo'\nimport { CreateButtonLink } from '../../../../admin-ui/components/CreateButtonLink'\nimport { EmptyState } from '../../../../admin-ui/components/EmptyState'\nimport { GraphQLErrorNotice } from '../../../../admin-ui/components/GraphQLErrorNotice'\nimport { PageContainer } from '../../../../admin-ui/components/PageContainer'\nimport { useList } from '../../../../admin-ui/context'\nimport { useSearchFilter } from '../../../../fields/types/relationship/views/useFilter'\nimport type { ActionMeta, FieldMeta, JSONValue, ListMeta } from '../../../../types'\nimport { FilterAdd } from './FilterAdd'\nimport { PaginationControls, snapValueToClosest } from './PaginationControls'\nimport { Tag } from './Tag'\n\ntype ListPageProps = { listKey: string }\nexport type Filter = {\n  field: string\n  type: string\n  value: JSONValue\n}\n\nfunction FilterTag({\n  filter,\n  field,\n  onChange,\n  onRemove,\n}: {\n  filter: Filter\n  field: FieldMeta\n  onChange: (filter: Filter) => void\n  onRemove: () => void\n}) {\n  const Label = field.controller.filter!.Label\n  const tagElement = (\n    <Tag onRemove={onRemove}>\n      <Text>\n        <span>{field.label} </span>\n        <Label\n          label={field.controller.filter!.types[filter.type].label}\n          type={filter.type}\n          value={filter.value}\n        />\n      </Text>\n    </Tag>\n  )\n\n  // TODO: Special \"empty\" types need to be documented somewhere. Filters that\n  // have no editable value, basically `null` or `!null`. Which offers:\n  // * better DX \u2014 we can avoid weird nullable types and UIs that don't make sense\n  // * better UX \u2014 users don't have to jump through mental hoops, like \"is not exactly\" + submit empty field\n  if (filter.type === 'empty' || filter.type === 'not_empty') return tagElement\n\n  return (\n    <DialogTrigger type=\"popover\" mobileType=\"tray\">\n      {tagElement}\n      {onDismiss => (\n        <FilterEdit onChange={onChange} onDismiss={onDismiss} field={field} filter={filter} />\n      )}\n    </DialogTrigger>\n  )\n}\n\nfunction FilterEdit({\n  filter,\n  field,\n  onChange: onAdd,\n  onDismiss,\n}: {\n  filter: Filter\n  field: FieldMeta\n  onChange: (filter: Filter) => void\n  onDismiss: () => void\n}) {\n  const formId = useId()\n  const [value, setValue] = useState(filter.value)\n  const onSubmit = (event: FormEvent) => {\n    if (event.target !== event.currentTarget) return\n    event.preventDefault()\n\n    onAdd({\n      ...filter,\n      value,\n    })\n    onDismiss()\n  }\n\n  const Filter = field.controller.filter!.Filter\n  const filterTypeLabel = field.controller.filter?.types[filter.type].label\n\n  return (\n    <Dialog>\n      <Heading>{field.label}</Heading>\n      <Content>\n        <form onSubmit={onSubmit} id={formId}>\n          <Filter\n            autoFocus\n            context=\"edit\"\n            typeLabel={filterTypeLabel}\n            onChange={setValue}\n            type={filter.type}\n            value={value}\n          />\n        </form>\n      </Content>\n      <ButtonGroup>\n        <Button onPress={onDismiss}>Cancel</Button>\n        <Button type=\"submit\" prominence=\"high\" form={formId}>\n          Save\n        </Button>\n      </ButtonGroup>\n    </Dialog>\n  )\n}\n\nfunction getFilters(list: ListMeta, query: ParsedUrlQueryInput): Filter[] {\n  const param_ = query.filter\n  const params = Array.isArray(param_) ? param_ : typeof param_ === 'string' ? [param_] : []\n\n  if (!params.length) {\n    if (!list.initialFilter) return []\n\n    const filters: Filter[] = []\n    for (const [fieldKey, filter] of Object.entries(list.initialFilter)) {\n      const { controller } = list.fields[fieldKey]\n      for (const f of controller.filter?.parseGraphQL(filter as any as never) ?? []) {\n        filters.push({\n          field: fieldKey,\n          ...f,\n        })\n      }\n    }\n\n    return filters\n  }\n\n  const filters: Filter[] = []\n  for (const [fieldPath, field] of Object.entries(list.fields)) {\n    if (!field.isFilterable) continue\n    if (!field.controller.filter) continue\n\n    for (const filterType in field.controller.filter.types) {\n      const prefix = `${fieldPath}_${filterType}`\n      for (const queryFilter of params) {\n        if (!queryFilter.startsWith(prefix)) continue\n\n        if (queryFilter === prefix) {\n          filters.push({\n            type: filterType,\n            field: fieldPath,\n            value: null,\n          })\n          continue\n        }\n\n        const queryValue = queryFilter.slice(prefix.length + 1)\n        try {\n          const value = JSON.parse(queryValue)\n          filters.push({\n            type: filterType,\n            field: fieldPath,\n            value,\n          })\n        } catch (e) {\n          console.error('Error parsing filter', queryFilter)\n        }\n      }\n    }\n  }\n\n  return filters\n}\n\nfunction getSort(list: ListMeta, query: ParsedUrlQueryInput): SortDescriptor | null {\n  const param = typeof query.sortBy === 'string' ? query.sortBy : null\n  if (param === '') return null\n  if (!param) {\n    if (!list.initialSort) return null\n    return {\n      column: list.initialSort.field,\n      direction: list.initialSort.direction === 'ASC' ? 'ascending' : 'descending',\n    }\n  }\n\n  const fieldKey = param.startsWith('-') ? param.slice(1) : param\n  const direction = param.startsWith('-') ? 'descending' : 'ascending'\n  const field = list.fields[fieldKey]\n  if (!field) return null\n  if (!field.isOrderable) return null\n\n  return {\n    column: fieldKey,\n    direction,\n  }\n}\n\nfunction getCurrentPage(_: ListMeta, query: ParsedUrlQuery) {\n  const currentPage = Number(query.page)\n  if (Number.isNaN(currentPage) || currentPage < 1) return 1\n  return currentPage\n}\n\nfunction getPageSize(list: ListMeta, query: ParsedUrlQuery) {\n  const pageSize = Number(query.pageSize)\n  if (Number.isNaN(pageSize) || pageSize < 1) return list.pageSize\n  return snapValueToClosest(pageSize)\n}\n\nfunction getColumns(list: ListMeta, query: ParsedUrlQueryInput): string[] {\n  const param_ = query.column\n  const params = Array.isArray(param_) ? param_ : typeof param_ === 'string' ? [param_] : []\n  if (!params.length) return list.initialColumns\n  return params\n}\n\nexport const getListPage = (props: ListPageProps) => () => <ListPage {...props} />\n\ntype Selection = Set<string | number> | 'all'\nfunction ListPage({ listKey }: ListPageProps) {\n  const localStorageListKey = `keystone.list.${listKey}.list.page.info`\n\n  const list = useList(listKey)\n  const { query, replace, isReady } = useRouter()\n  const [sort, setSort] = useState<SortDescriptor | null>(() => getSort(list, {}))\n  const [columns, setColumns] = useState<string[]>(list.initialColumns)\n  const [filters, setFilters] = useState<Filter[]>(() => getFilters(list, {}))\n  const [currentPage, setCurrentPage] = useState<number>(1)\n  const [pageSize, setPageSize] = useState<number>(list.pageSize)\n  const [searchString, setSearchString] = useState('')\n  const [selectedItems, setSelectedItems] = useState<Selection>(() => new Set([]))\n  const [activeAction, setActiveAction] = useState<Key | null>(null)\n  const dirty = useMemo(() => {\n    const defaultFilters = getFilters(list, {})\n    const defaultSort = getSort(list, {})\n    return (\n      !!searchString ||\n      !isDeepEqual(filters, defaultFilters) ||\n      !isDeepEqual(sort, defaultSort) ||\n      !isDeepEqual(columns, list.initialColumns)\n    )\n  }, [searchString, filters, sort, columns, list.initialColumns])\n\n  useEffect(() => {\n    if (!isReady) return\n    if (loaded) return\n    let localStorageQuery\n    try {\n      localStorageQuery = JSON.parse(localStorage.getItem(localStorageListKey) ?? '{}')\n    } catch {}\n\n    setSort(getSort(list, { ...localStorageQuery, ...query }))\n    setColumns(getColumns(list, { ...localStorageQuery, ...query }))\n    setFilters(getFilters(list, { ...localStorageQuery, ...query }))\n    setCurrentPage(getCurrentPage(list, { ...localStorageQuery, ...query }))\n    setPageSize(getPageSize(list, { ...localStorageQuery, ...query }))\n    setSearchString(typeof query.search === 'string' ? query.search : '')\n    setLoaded(true)\n  }, [list, isReady])\n\n  useEffect(() => {\n    if (!isReady) return\n    if (!loaded) return // TODO: stop this race condition properly\n    const updatedQuery: ParsedUrlQueryInput = {\n      ...(columns.length ? { column: columns } : {}),\n      ...(sort ? { sortBy: sort.direction === 'ascending' ? sort.column : `-${sort.column}` } : {}),\n      ...(filters.length\n        ? {\n            filter: (function () {\n              const result: string[] = []\n              for (const filter of filters) {\n                if (filter.type === 'not_empty' || filter.type === 'empty') {\n                  result.push(`${filter.field}_${filter.type}`)\n                  continue\n                }\n\n                result.push(`${filter.field}_${filter.type}_${JSON.stringify(filter.value)}`)\n              }\n              return result\n            })(),\n          }\n        : {}),\n      ...(currentPage > 1 ? { page: currentPage } : {}),\n      ...(pageSize !== list.pageSize ? { pageSize } : {}),\n      ...(searchString ? { search: searchString } : {}),\n    }\n\n    localStorage.setItem(localStorageListKey, JSON.stringify(updatedQuery))\n    replace({ query: updatedQuery })\n  }, [columns, sort, filters, currentPage, pageSize, searchString, list])\n\n  const allowCreate = !(list.hideCreate ?? true)\n  const isConstrained = Boolean(filters.length || query.search)\n  const readableFields = Object.values(list.fields).map(f => ({\n    id: f.key,\n    value: f.key,\n    label: f.label,\n    isDisabled: f.listView.fieldMode === 'read',\n  }))\n  const shownFields = columns.map(fieldKey => list.fields[fieldKey]).filter(Boolean)\n  const where = useMemo(\n    () =>\n      filters.map(filter => {\n        return list.fields[filter.field].controller.filter!.graphql({\n          type: filter.type,\n          value: filter.value,\n        })\n      }),\n    [list, filters]\n  )\n\n  const search = useSearchFilter(searchString, list, list.initialSearchFields)\n  const { data, error, refetch, loading } = useQuery(\n    useMemo((): TypedDocumentNode<{\n      items: Record<string, unknown>[] | null\n      count: number | null\n    }> => {\n      const selectedGqlFields = shownFields\n        .filter(field => field.key !== 'id') // id is always included\n        .map(field => field.controller.graphqlSelection)\n        .join('\\n')\n\n      // TODO: less interpolation\n      return gql`\n        query (\n          $where: ${list.graphql.names.whereInputName},\n          $take: Int!,\n          $skip: Int!,\n          $orderBy: [${list.graphql.names.listOrderName}!]\n        ) {\n          items: ${list.graphql.names.listQueryName}(\n            where: $where,\n            take: $take,\n            skip: $skip,\n            orderBy: $orderBy\n          ) {\n            id\n            ${selectedGqlFields}\n          }\n          count: ${list.graphql.names.listQueryCountName}(where: $where)\n        }\n      `\n    }, [list, shownFields]),\n    {\n      fetchPolicy: 'cache-and-network',\n      errorPolicy: 'all',\n      variables: {\n        where: {\n          ...(where.length ? { AND: where } : {}),\n          ...(search.length ? { OR: search } : {}),\n        },\n        take: pageSize,\n        skip: (currentPage - 1) * pageSize,\n        orderBy: sort\n          ? [\n              {\n                [sort.column]: sort.direction === 'ascending' ? 'asc' : 'desc',\n              },\n            ]\n          : undefined,\n      },\n    }\n  )\n\n  useEffect(() => {\n    if (typeof data?.count !== 'number') return\n\n    const lastPage = Math.max(Math.ceil(data.count / pageSize), 1)\n    if (currentPage > lastPage) {\n      setCurrentPage(lastPage)\n    }\n  }, [data])\n\n  const selectedItemIds = (\n    selectedItems === 'all' ? (data?.items?.map(item => item.id) ?? []) : Array.from(selectedItems)\n  ).map(String)\n  const isEmpty = Boolean(data?.count === 0 && !isConstrained)\n  const headers = shownFields.map(field => {\n    return {\n      id: field.",
            "cost": 0.161035
        },
        "keystonejs__keystone.052f5b1b/packages/core/src/admin-ui/components/Errors.tsx": {
            "output": "import { Component, type ReactNode } from 'react'\n\nimport { Button } from '@keystar/ui/button'\nimport { Dialog } from '@keystar/ui/dialog'\nimport { Icon } from '@keystar/ui/icon'\nimport { alertTriangleIcon } from '@keystar/ui/icon/icons/alertTriangleIcon'\nimport { Box, Grid, VStack } from '@keystar/ui/layout'\nimport { Content, SlotProvider } from '@keystar/ui/slots'\nimport { css, tokenSchema } from '@keystar/ui/style'\nimport { Heading, Text } from '@keystar/ui/typography'\n\ntype ErrorBoundaryProps = {\n  children: ReactNode\n}\ntype ErrorBoundaryState = {\n  error?: any\n  hasError: boolean\n  isReloading: boolean\n}\n\nexport class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  state: ErrorBoundaryState = { hasError: false, isReloading: false }\n  static getDerivedStateFromError(error: any) {\n    return { error, hasError: true }\n  }\n  reloadPage = () => {\n    this.setState({ isReloading: true })\n    window.location.reload()\n  }\n  render() {\n    if (this.state.hasError) {\n      return (\n        <ErrorContainer>\n          <Icon color=\"neutral\" src={alertTriangleIcon} size=\"large\" />\n          <Heading elementType=\"h1\" margin={0}>\n            Unknown error\n          </Heading>\n          <Text>\n            Something went wrong, please try reloading the page. If the problem persists contact\n            your system administrator.\n          </Text>\n          <Button\n            // isPending={this.state.isReloading}\n            prominence=\"high\"\n            onPress={this.reloadPage}\n          >\n            Reload page\n          </Button>\n        </ErrorContainer>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\ntype ErrorContainerProps = {\n  children: ReactNode\n}\n\nconst errorContainerSlots = {\n  heading: { align: 'center', margin: 0 },\n  text: { align: 'center' },\n} as const\n\nexport function ErrorContainer({ children }: ErrorContainerProps) {\n  return (\n    <Grid minHeight=\"100vh\" minWidth=\"100vw\" alignItems=\"center\" justifyContent=\"center\">\n      <VStack\n        alignItems=\"center\"\n        backgroundColor=\"canvas\"\n        border=\"neutral\"\n        borderRadius=\"large\"\n        gap=\"xlarge\"\n        margin=\"xlarge\"\n        minWidth=\"container.xsmall\"\n        maxWidth=\"container.small\"\n        padding=\"xxlarge\"\n      >\n        <SlotProvider slots={errorContainerSlots}>{children}</SlotProvider>\n      </VStack>\n    </Grid>\n  )\n}\n\nexport function ErrorDetailsDialog({ error }: { error: Error }) {\n  const { message, stack } = error\n  return (\n    <Dialog>\n      <Heading>Error details</Heading>\n      <Content>\n        <VStack gap=\"large\">\n          <Text weight=\"medium\">{message}</Text>\n          {stack && (\n            <Box\n              elementType=\"pre\"\n              backgroundColor=\"critical\"\n              borderRadius=\"regular\"\n              maxHeight=\"100%\"\n              padding=\"medium\"\n              overflow=\"auto\"\n            >\n              <Text\n                color=\"critical\"\n                trim={false}\n                UNSAFE_className={css({\n                  fontFamily: tokenSchema.typography.fontFamily.code,\n                })}\n              >\n                {stack}\n              </Text>\n            </Box>\n          )}\n        </VStack>\n      </Content>\n    </Dialog>\n  )\n}",
            "output_extracted": "import { Component, type ReactNode } from 'react'\n\nimport { Button } from '@keystar/ui/button'\nimport { Dialog } from '@keystar/ui/dialog'\nimport { Icon } from '@keystar/ui/icon'\nimport { alertTriangleIcon } from '@keystar/ui/icon/icons/alertTriangleIcon'\nimport { Box, Grid, VStack } from '@keystar/ui/layout'\nimport { Content, SlotProvider } from '@keystar/ui/slots'\nimport { css, tokenSchema } from '@keystar/ui/style'\nimport { Heading, Text } from '@keystar/ui/typography'\n\ntype ErrorBoundaryProps = {\n  children: ReactNode\n}\ntype ErrorBoundaryState = {\n  error?: any\n  hasError: boolean\n  isReloading: boolean\n}\n\nexport class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  state: ErrorBoundaryState = { hasError: false, isReloading: false }\n  static getDerivedStateFromError(error: any) {\n    return { error, hasError: true }\n  }\n  reloadPage = () => {\n    this.setState({ isReloading: true })\n    window.location.reload()\n  }\n  render() {\n    if (this.state.hasError) {\n      return (\n        <ErrorContainer>\n          <Icon color=\"neutral\" src={alertTriangleIcon} size=\"large\" />\n          <Heading elementType=\"h1\" margin={0}>\n            Unknown error\n          </Heading>\n          <Text>\n            Something went wrong, please try reloading the page. If the problem persists contact\n            your system administrator.\n          </Text>\n          <Button\n            // isPending={this.state.isReloading}\n            prominence=\"high\"\n            onPress={this.reloadPage}\n          >\n            Reload page\n          </Button>\n        </ErrorContainer>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\ntype ErrorContainerProps = {\n  children: ReactNode\n}\n\nconst errorContainerSlots = {\n  heading: { align: 'center', margin: 0 },\n  text: { align: 'center' },\n} as const\n\nexport function ErrorContainer({ children }: ErrorContainerProps) {\n  return (\n    <Grid minHeight=\"100vh\" minWidth=\"100vw\" alignItems=\"center\" justifyContent=\"center\">\n      <VStack\n        alignItems=\"center\"\n        backgroundColor=\"canvas\"\n        border=\"neutral\"\n        borderRadius=\"large\"\n        gap=\"xlarge\"\n        margin=\"xlarge\"\n        minWidth=\"container.xsmall\"\n        maxWidth=\"container.small\"\n        padding=\"xxlarge\"\n      >\n        <SlotProvider slots={errorContainerSlots}>{children}</SlotProvider>\n      </VStack>\n    </Grid>\n  )\n}\n\nexport function ErrorDetailsDialog({ error }: { error: Error }) {\n  const { message, stack } = error\n  return (\n    <Dialog>\n      <Heading>Error details</Heading>\n      <Content>\n        <VStack gap=\"large\">\n          <Text weight=\"medium\">{message}</Text>\n          {stack && (\n            <Box\n              elementType=\"pre\"\n              backgroundColor=\"critical\"\n              borderRadius=\"regular\"\n              maxHeight=\"100%\"\n              padding=\"medium\"\n              overflow=\"auto\"\n            >\n              <Text\n                color=\"critical\"\n                trim={false}\n                UNSAFE_className={css({\n                  fontFamily: tokenSchema.typography.fontFamily.code,\n                })}\n              >\n                {stack}\n              </Text>\n            </Box>\n          )}\n        </VStack>\n      </Content>\n    </Dialog>\n  )\n}",
            "cost": 0.03536
        },
        "keystonejs__keystone.052f5b1b/packages/core/src/admin-ui/context.tsx": {
            "output": "import UploadLink from 'apollo-upload-client/UploadHttpLink.mjs'\nimport NextHead from 'next/head'\nimport { type ReactNode, createContext, useContext, useEffect, useMemo } from 'react'\n\nimport { ClientSideOnlyDocumentElement, KeystarProvider } from '@keystar/ui/core'\nimport { injectGlobal, tokenSchema } from '@keystar/ui/style'\nimport { Toaster } from '@keystar/ui/toast'\nimport { useRouter } from '@keystone-6/core/admin-ui/router'\n\nimport { snapValueToClosest } from '../___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/PaginationControls'\nimport type {\n  AdminConfig,\n  BaseListTypeInfo,\n  ConditionalFilter,\n  ConditionalFilterCase,\n  FieldViews,\n  ListMeta,\n} from '../types'\nimport { type AdminMetaQuery, adminMetaQuery } from './admin-meta-graphql'\nimport {\n  ApolloClient,\n  ApolloProvider,\n  type ErrorLike,\n  InMemoryCache,\n  gql,\n  useQuery,\n} from './apollo'\n\ntype KeystoneContextType = {\n  adminConfig: AdminConfig | null\n  apiPath: string | null\n  error?: ErrorLike | null\n  fieldViews: FieldViews\n  lists: { [list: string]: ListMeta }\n}\n\nconst KeystoneContext = createContext<KeystoneContextType>({\n  adminConfig: null,\n  apiPath: null,\n  lists: {},\n  fieldViews: {},\n})\n\ntype KeystoneProviderProps = {\n  adminConfig: AdminConfig\n  apiPath: string\n  fieldViews: FieldViews\n  children: ReactNode\n}\n\nconst expectedExports = new Set(['Field', 'controller'])\n\nfunction InternalKeystoneProvider({\n  adminConfig,\n  apiPath,\n  fieldViews,\n  children,\n}: KeystoneProviderProps) {\n  const { push: navigate } = useRouter()\n  const keystarRouter = useMemo(() => ({ navigate }), [navigate])\n  const { data, loading, error } = useQuery<AdminMetaQuery>(adminMetaQuery, {\n    errorPolicy: 'all',\n  })\n  const listsData = data?.keystone?.adminMeta?.lists\n  const lists = useMemo(() => {\n    if (!listsData) return\n    if (error) return\n\n    const lists: KeystoneContextType['lists'] = {}\n\n    for (const listData of listsData) {\n      lists[listData.key] = {\n        ...listData,\n        pageSize: snapValueToClosest(listData.pageSize ?? 50),\n        fields: {},\n        groups: [],\n      }\n\n      for (const field of listData.fields) {\n        for (const exportName of expectedExports) {\n          if ((fieldViews[field.viewsIndex] as any)[exportName] === undefined) {\n            throw new Error(\n              `The view for the field at ${listData.key}.${field.key} is missing the ${exportName} export`\n            )\n          }\n        }\n\n        const views = { ...fieldViews[field.viewsIndex] }\n        const customViews: Record<string, any> = {}\n        if (field.customViewsIndex !== null) {\n          const customViewsSource: FieldViews[number] & Record<string, any> =\n            fieldViews[field.customViewsIndex]\n          const allowedExportsOnCustomViews = new Set(views.allowedExportsOnCustomViews)\n          for (const exportName in customViewsSource) {\n            if (allowedExportsOnCustomViews.has(exportName)) {\n              customViews[exportName] = customViewsSource[exportName]\n            } else if (expectedExports.has(exportName)) {\n              ;(views as any)[exportName] = customViewsSource[exportName]\n            }\n          }\n        }\n\n        lists[listData.key].fields[field.key] = {\n          ...field,\n          createView: {\n            fieldMode: field.createView?.fieldMode ?? null,\n            isRequired: field.createView?.isRequired ?? false,\n          },\n          itemView: {\n            fieldMode: field.itemView?.fieldMode ?? null,\n            fieldPosition: field.itemView?.fieldPosition ?? null,\n            isRequired: field.itemView?.isRequired ?? false,\n          },\n          listView: {\n            fieldMode: field.listView?.fieldMode ?? null,\n          },\n          views,\n          controller: views.controller({\n            listKey: listData.key,\n            fieldKey: field.key,\n            label: field.label,\n            description: field.description,\n            fieldMeta: field.fieldMeta,\n            customViews,\n          }),\n        }\n      }\n\n      for (const group of listData.groups) {\n        lists[listData.key].groups.push({\n          label: group.label,\n          description: group.description,\n          fields: group.fields.map(field => lists[listData.key].fields[field.key]),\n        })\n      }\n    }\n\n    return lists\n  }, [listsData, error, fieldViews])\n\n  // TODO: remove this once studio is fully migrated to keystar-ui\n  useEffect(() => {\n    injectGlobal({\n      body: {\n        fontFamily: tokenSchema.typography.fontFamily.base,\n      },\n\n      // [1] reset all box sizing to border-box\n      // [2] default borders so you can add a border by specifying just the width\n      '*, ::before, ::after': {\n        // boxSizing: 'border-box', // this breaks some things in keystar-ui\u2026\n        borderWidth: 0,\n        borderStyle: 'solid',\n        borderColor: tokenSchema.color.border.neutral,\n      },\n    })\n  }, [])\n\n  // TODO\n  if (loading) return null\n  //   if (!meta) return null\n  return (\n    <KeystarProvider router={keystarRouter}>\n      <ClientSideOnlyDocumentElement bodyBackground=\"surface\" />\n      <NextHead>\n        <meta key=\"viewport\" name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <link\n          href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap\"\n          rel=\"stylesheet\"\n        />\n      </NextHead>\n\n      <KeystoneContext.Provider\n        value={{\n          adminConfig,\n          apiPath,\n          fieldViews,\n          lists: lists ?? {},\n          error: error ?? null,\n        }}\n      >\n        {children}\n      </KeystoneContext.Provider>\n      <Toaster />\n    </KeystarProvider>\n  )\n}\n\nexport function KeystoneProvider(props: KeystoneProviderProps) {\n  const apolloClient = useMemo(\n    () =>\n      new ApolloClient({\n        cache: new InMemoryCache(),\n        link: new UploadLink({\n          uri: props.apiPath,\n          headers: { 'Apollo-Require-Preflight': 'true' },\n        }),\n      }),\n    [props.apiPath]\n  )\n\n  return (\n    <ApolloProvider client={apolloClient}>\n      <InternalKeystoneProvider {...props} />\n    </ApolloProvider>\n  )\n}\n\nexport function useKeystone() {\n  return useContext(KeystoneContext)\n}\n\nexport function useList(listKey: string) {\n  const { lists } = useKeystone()\n  const list = lists?.[listKey]\n  if (!list) throw new Error(`Unknown list ${listKey}`)\n  return list\n}\n\nexport function useField(listKey: string, fieldKey: string) {\n  const list = useList(listKey)\n  const field = list.fields[fieldKey]\n  if (!field) throw new Error(`Unknown field ${listKey}.${fieldKey}`)\n  return field\n}\n\n// TODO useContext?\nexport function useListItem(\n  listKey: string,\n  itemId: string | null\n): useQuery.Result<\n  {\n    item: Record<string, unknown> | null\n    keystone: {\n      adminMeta: {\n        list: {\n          fields: {\n            key: string\n            itemView: {\n              fieldMode: ConditionalFilter<'edit' | 'read' | 'hidden', BaseListTypeInfo>\n              fieldPosition: 'form' | 'sidebar'\n              isRequired: ConditionalFilterCase<BaseListTypeInfo>\n            } | null\n          }[]\n        } | null\n      }\n    }\n  },\n  { id: string | null; listKey: string }\n> {\n  const list = useList(listKey)\n  const query = useMemo(() => {\n    const selectedFields = Object.values(list.fields)\n      .filter(field => {\n        if (field.key === 'id') return true\n        return field.itemView.fieldMode !== 'hidden'\n      })\n      .map(field => field.controller.graphqlSelection)\n      .join('\\n')\n\n    return gql`\n      query KsFetchItem ($listKey: String!, $id: ID!) {\n        keystone {\n          adminMeta {\n            list(key: $listKey, itemId: $id) {\n              fields {\n                key\n                itemView {\n                  fieldMode\n                  fieldPosition\n                  isRequired\n                }\n              }\n              actions {\n                itemView {\n                  actionMode\n                }\n              }\n            }\n          }\n        }\n        item: ${list.graphql.names.itemQueryName}(where: { id: $id }) {\n          ${selectedFields}\n        }\n      }\n    `\n  }, [list])\n\n  return useQuery(query, {\n    errorPolicy: 'all',\n    skip: itemId === null,\n    variables: {\n      listKey,\n      id: itemId,\n    },\n  })\n}",
            "output_extracted": "import UploadLink from 'apollo-upload-client/UploadHttpLink.mjs'\nimport NextHead from 'next/head'\nimport { type ReactNode, createContext, useContext, useEffect, useMemo } from 'react'\n\nimport { ClientSideOnlyDocumentElement, KeystarProvider } from '@keystar/ui/core'\nimport { injectGlobal, tokenSchema } from '@keystar/ui/style'\nimport { Toaster } from '@keystar/ui/toast'\nimport { useRouter } from '@keystone-6/core/admin-ui/router'\n\nimport { snapValueToClosest } from '../___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/PaginationControls'\nimport type {\n  AdminConfig,\n  BaseListTypeInfo,\n  ConditionalFilter,\n  ConditionalFilterCase,\n  FieldViews,\n  ListMeta,\n} from '../types'\nimport { type AdminMetaQuery, adminMetaQuery } from './admin-meta-graphql'\nimport {\n  ApolloClient,\n  ApolloProvider,\n  type ErrorLike,\n  InMemoryCache,\n  gql,\n  useQuery,\n} from './apollo'\n\ntype KeystoneContextType = {\n  adminConfig: AdminConfig | null\n  apiPath: string | null\n  error?: ErrorLike | null\n  fieldViews: FieldViews\n  lists: { [list: string]: ListMeta }\n}\n\nconst KeystoneContext = createContext<KeystoneContextType>({\n  adminConfig: null,\n  apiPath: null,\n  lists: {},\n  fieldViews: {},\n})\n\ntype KeystoneProviderProps = {\n  adminConfig: AdminConfig\n  apiPath: string\n  fieldViews: FieldViews\n  children: ReactNode\n}\n\nconst expectedExports = new Set(['Field', 'controller'])\n\nfunction InternalKeystoneProvider({\n  adminConfig,\n  apiPath,\n  fieldViews,\n  children,\n}: KeystoneProviderProps) {\n  const { push: navigate } = useRouter()\n  const keystarRouter = useMemo(() => ({ navigate }), [navigate])\n  const { data, loading, error } = useQuery<AdminMetaQuery>(adminMetaQuery, {\n    errorPolicy: 'all',\n  })\n  const listsData = data?.keystone?.adminMeta?.lists\n  const lists = useMemo(() => {\n    if (!listsData) return\n    if (error) return\n\n    const lists: KeystoneContextType['lists'] = {}\n\n    for (const listData of listsData) {\n      lists[listData.key] = {\n        ...listData,\n        pageSize: snapValueToClosest(listData.pageSize ?? 50),\n        fields: {},\n        groups: [],\n      }\n\n      for (const field of listData.fields) {\n        for (const exportName of expectedExports) {\n          if ((fieldViews[field.viewsIndex] as any)[exportName] === undefined) {\n            throw new Error(\n              `The view for the field at ${listData.key}.${field.key} is missing the ${exportName} export`\n            )\n          }\n        }\n\n        const views = { ...fieldViews[field.viewsIndex] }\n        const customViews: Record<string, any> = {}\n        if (field.customViewsIndex !== null) {\n          const customViewsSource: FieldViews[number] & Record<string, any> =\n            fieldViews[field.customViewsIndex]\n          const allowedExportsOnCustomViews = new Set(views.allowedExportsOnCustomViews)\n          for (const exportName in customViewsSource) {\n            if (allowedExportsOnCustomViews.has(exportName)) {\n              customViews[exportName] = customViewsSource[exportName]\n            } else if (expectedExports.has(exportName)) {\n              ;(views as any)[exportName] = customViewsSource[exportName]\n            }\n          }\n        }\n\n        lists[listData.key].fields[field.key] = {\n          ...field,\n          createView: {\n            fieldMode: field.createView?.fieldMode ?? null,\n            isRequired: field.createView?.isRequired ?? false,\n          },\n          itemView: {\n            fieldMode: field.itemView?.fieldMode ?? null,\n            fieldPosition: field.itemView?.fieldPosition ?? null,\n            isRequired: field.itemView?.isRequired ?? false,\n          },\n          listView: {\n            fieldMode: field.listView?.fieldMode ?? null,\n          },\n          views,\n          controller: views.controller({\n            listKey: listData.key,\n            fieldKey: field.key,\n            label: field.label,\n            description: field.description,\n            fieldMeta: field.fieldMeta,\n            customViews,\n          }),\n        }\n      }\n\n      for (const group of listData.groups) {\n        lists[listData.key].groups.push({\n          label: group.label,\n          description: group.description,\n          fields: group.fields.map(field => lists[listData.key].fields[field.key]),\n        })\n      }\n    }\n\n    return lists\n  }, [listsData, error, fieldViews])\n\n  // TODO: remove this once studio is fully migrated to keystar-ui\n  useEffect(() => {\n    injectGlobal({\n      body: {\n        fontFamily: tokenSchema.typography.fontFamily.base,\n      },\n\n      // [1] reset all box sizing to border-box\n      // [2] default borders so you can add a border by specifying just the width\n      '*, ::before, ::after': {\n        // boxSizing: 'border-box', // this breaks some things in keystar-ui\u2026\n        borderWidth: 0,\n        borderStyle: 'solid',\n        borderColor: tokenSchema.color.border.neutral,\n      },\n    })\n  }, [])\n\n  // TODO\n  if (loading) return null\n  //   if (!meta) return null\n  return (\n    <KeystarProvider router={keystarRouter}>\n      <ClientSideOnlyDocumentElement bodyBackground=\"surface\" />\n      <NextHead>\n        <meta key=\"viewport\" name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <link\n          href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap\"\n          rel=\"stylesheet\"\n        />\n      </NextHead>\n\n      <KeystoneContext.Provider\n        value={{\n          adminConfig,\n          apiPath,\n          fieldViews,\n          lists: lists ?? {},\n          error: error ?? null,\n        }}\n      >\n        {children}\n      </KeystoneContext.Provider>\n      <Toaster />\n    </KeystarProvider>\n  )\n}\n\nexport function KeystoneProvider(props: KeystoneProviderProps) {\n  const apolloClient = useMemo(\n    () =>\n      new ApolloClient({\n        cache: new InMemoryCache(),\n        link: new UploadLink({\n          uri: props.apiPath,\n          headers: { 'Apollo-Require-Preflight': 'true' },\n        }),\n      }),\n    [props.apiPath]\n  )\n\n  return (\n    <ApolloProvider client={apolloClient}>\n      <InternalKeystoneProvider {...props} />\n    </ApolloProvider>\n  )\n}\n\nexport function useKeystone() {\n  return useContext(KeystoneContext)\n}\n\nexport function useList(listKey: string) {\n  const { lists } = useKeystone()\n  const list = lists?.[listKey]\n  if (!list) throw new Error(`Unknown list ${listKey}`)\n  return list\n}\n\nexport function useField(listKey: string, fieldKey: string) {\n  const list = useList(listKey)\n  const field = list.fields[fieldKey]\n  if (!field) throw new Error(`Unknown field ${listKey}.${fieldKey}`)\n  return field\n}\n\n// TODO useContext?\nexport function useListItem(\n  listKey: string,\n  itemId: string | null\n): useQuery.Result<\n  {\n    item: Record<string, unknown> | null\n    keystone: {\n      adminMeta: {\n        list: {\n          fields: {\n            key: string\n            itemView: {\n              fieldMode: ConditionalFilter<'edit' | 'read' | 'hidden', BaseListTypeInfo>\n              fieldPosition: 'form' | 'sidebar'\n              isRequired: ConditionalFilterCase<BaseListTypeInfo>\n            } | null\n          }[]\n        } | null\n      }\n    }\n  },\n  { id: string | null; listKey: string }\n> {\n  const list = useList(listKey)\n  const query = useMemo(() => {\n    const selectedFields = Object.values(list.fields)\n      .filter(field => {\n        if (field.key === 'id') return true\n        return field.itemView.fieldMode !== 'hidden'\n      })\n      .map(field => field.controller.graphqlSelection)\n      .join('\\n')\n\n    return gql`\n      query KsFetchItem ($listKey: String!, $id: ID!) {\n        keystone {\n          adminMeta {\n            list(key: $listKey, itemId: $id) {\n              fields {\n                key\n                itemView {\n                  fieldMode\n                  fieldPosition\n                  isRequired\n                }\n              }\n              actions {\n                itemView {\n                  actionMode\n                }\n              }\n            }\n          }\n        }\n        item: ${list.graphql.names.itemQueryName}(where: { id: $id }) {\n          ${selectedFields}\n        }\n      }\n    `\n  }, [list])\n\n  return useQuery(query, {\n    errorPolicy: 'all',\n    skip: itemId === null,\n    variables: {\n      listKey,\n      id: itemId,\n    },\n  })\n}",
            "cost": 0.079545
        },
        "keystonejs__keystone.052f5b1b/tests/admin-ui-tests/list-view-crud.test.ts": {
            "output": "import type { Browser, Page } from 'playwright'\n\nimport { adminUITests, deleteAllData, makeGqlRequest } from './utils'\n\nadminUITests('./tests/test-projects/crud-notifications', browserType => {\n  let browser: Browser = undefined as any\n  let page: Page = undefined as any\n\n  beforeAll(async () => {\n    browser = await browserType.launch()\n    page = await browser.newPage()\n  })\n  beforeEach(async () => {\n    // Drop the database\n    await deleteAllData('./tests/test-projects/crud-notifications')\n  })\n\n  test('Complete deletion success, only shows the successful deletion prompt', async () => {\n    // hack for gql syntax highlighting\n    const gql = String.raw\n    const query = gql`\n      mutation CreateTaskItem {\n        createTask(data: { label: \"you can delete me\" }) {\n          id\n          label\n        }\n      }\n    `\n    await makeGqlRequest(query)\n    await page.goto('http://localhost:3000/tasks')\n    await page.getByRole('checkbox', { name: 'Select you can delete me' }).click()\n    await page.getByRole('button', { name: 'Delete' }).click()\n    await page.getByRole('button', { name: 'Yes, delete' }).click()\n    const alertDialog = page.locator('[role=alertdialog][aria-modal=false]')\n    await alertDialog.waitFor()\n    expect(await alertDialog.innerText()).toBe('Deleted 1 task.')\n  })\n\n  test('Complete deletion failure, only shows the successful failure prompt', async () => {\n    // hack for gql syntax highlighting\n    const gql = String.raw\n    const query = gql`\n      mutation CreateTaskItem {\n        createTask(data: { label: \"do not delete\" }) {\n          id\n          label\n        }\n      }\n    `\n    await makeGqlRequest(query)\n    await page.goto('http://localhost:3000/tasks')\n    await page.getByRole('checkbox', { name: 'Select do not delete' }).click()\n    await page.getByRole('button', { name: 'Delete' }).click()\n    await page.getByRole('button', { name: 'Yes, delete' }).click()\n    const alertDialog = page.locator('[role=alertdialog][aria-modal=false]')\n    await alertDialog.waitFor()\n    expect(await alertDialog.innerText()).toBe('Unable to delete 1 task.\\nDetails')\n  })\n\n  test('Partial deletion failure', async () => {\n    // hack for gql syntax highlighting\n    const gql = String.raw\n    const query = gql`\n      mutation CreateTaskItems($data: [TaskCreateInput!]!) {\n        createTasks(data: $data) {\n          id\n          label\n        }\n      }\n    `\n    const variables = {\n      data: Array.from(Array(75).keys()).map(key => {\n        if (key >= 50) {\n          return {\n            label: `delete me ${key - 50}`,\n          }\n        } else {\n          return {\n            label: `do not delete ${key}`,\n          }\n        }\n      }),\n    }\n    await makeGqlRequest(query, variables)\n    await page.goto('http://localhost:3000/tasks?sortBy=label&page=1')\n    await page.getByRole('checkbox', { name: 'Select All' }).click()\n    await page.getByRole('button', { name: 'Delete' }).click()\n    await page.getByRole('button', { name: 'Yes, delete' }).click()\n    const alertDialog = page.locator('[role=alertdialog][aria-modal=false]')\n    await alertDialog.waitFor()\n\n    expect(await alertDialog.innerText()).toBe('Unable to delete 25 tasks.')\n\n    await alertDialog.getByRole('button', { name: 'Close' }).click()\n    await page\n      .locator('[role=alertdialog][aria-modal=false]:has-text(\"Deleted 25 tasks.\")')\n      .waitFor()\n  })\n  afterAll(async () => {\n    await browser.close()\n  })\n})",
            "output_extracted": "import type { Browser, Page } from 'playwright'\n\nimport { adminUITests, deleteAllData, makeGqlRequest } from './utils'\n\nadminUITests('./tests/test-projects/crud-notifications', browserType => {\n  let browser: Browser = undefined as any\n  let page: Page = undefined as any\n\n  beforeAll(async () => {\n    browser = await browserType.launch()\n    page = await browser.newPage()\n  })\n  beforeEach(async () => {\n    // Drop the database\n    await deleteAllData('./tests/test-projects/crud-notifications')\n  })\n\n  test('Complete deletion success, only shows the successful deletion prompt', async () => {\n    // hack for gql syntax highlighting\n    const gql = String.raw\n    const query = gql`\n      mutation CreateTaskItem {\n        createTask(data: { label: \"you can delete me\" }) {\n          id\n          label\n        }\n      }\n    `\n    await makeGqlRequest(query)\n    await page.goto('http://localhost:3000/tasks')\n    await page.getByRole('checkbox', { name: 'Select you can delete me' }).click()\n    await page.getByRole('button', { name: 'Delete' }).click()\n    await page.getByRole('button', { name: 'Yes, delete' }).click()\n    const alertDialog = page.locator('[role=alertdialog][aria-modal=false]')\n    await alertDialog.waitFor()\n    expect(await alertDialog.innerText()).toBe('Deleted 1 task.')\n  })\n\n  test('Complete deletion failure, only shows the successful failure prompt', async () => {\n    // hack for gql syntax highlighting\n    const gql = String.raw\n    const query = gql`\n      mutation CreateTaskItem {\n        createTask(data: { label: \"do not delete\" }) {\n          id\n          label\n        }\n      }\n    `\n    await makeGqlRequest(query)\n    await page.goto('http://localhost:3000/tasks')\n    await page.getByRole('checkbox', { name: 'Select do not delete' }).click()\n    await page.getByRole('button', { name: 'Delete' }).click()\n    await page.getByRole('button', { name: 'Yes, delete' }).click()\n    const alertDialog = page.locator('[role=alertdialog][aria-modal=false]')\n    await alertDialog.waitFor()\n    expect(await alertDialog.innerText()).toBe('Unable to delete 1 task.\\nDetails')\n  })\n\n  test('Partial deletion failure', async () => {\n    // hack for gql syntax highlighting\n    const gql = String.raw\n    const query = gql`\n      mutation CreateTaskItems($data: [TaskCreateInput!]!) {\n        createTasks(data: $data) {\n          id\n          label\n        }\n      }\n    `\n    const variables = {\n      data: Array.from(Array(75).keys()).map(key => {\n        if (key >= 50) {\n          return {\n            label: `delete me ${key - 50}`,\n          }\n        } else {\n          return {\n            label: `do not delete ${key}`,\n          }\n        }\n      }),\n    }\n    await makeGqlRequest(query, variables)\n    await page.goto('http://localhost:3000/tasks?sortBy=label&page=1')\n    await page.getByRole('checkbox', { name: 'Select All' }).click()\n    await page.getByRole('button', { name: 'Delete' }).click()\n    await page.getByRole('button', { name: 'Yes, delete' }).click()\n    const alertDialog = page.locator('[role=alertdialog][aria-modal=false]')\n    await alertDialog.waitFor()\n\n    expect(await alertDialog.innerText()).toBe('Unable to delete 25 tasks.')\n\n    await alertDialog.getByRole('button', { name: 'Close' }).click()\n    await page\n      .locator('[role=alertdialog][aria-modal=false]:has-text(\"Deleted 25 tasks.\")')\n      .waitFor()\n  })\n  afterAll(async () => {\n    await browser.close()\n  })\n})",
            "cost": 0.03623
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "keystonejs__keystone-9691",
        "repo": "keystonejs/keystone",
        "pull_number": 9691,
        "base_commit": "052f5b1bfdc76868125722ea385c59ffae7eb000",
        "patch": "diff --git a/examples/actions/schema.ts b/examples/actions/schema.ts\nindex afa3d2f94c9..33263c0cac0 100644\n--- a/examples/actions/schema.ts\n+++ b/examples/actions/schema.ts\n@@ -67,6 +67,7 @@ export const lists = {\n         access: allowAll,\n         async resolve({ actionKey, where }, context) {\n           console.log(`${actionKey}`, JSON.stringify({ where }))\n+          // throw new Error('Random failure, try again')\n           return await context.db.Post.updateOne({\n             where,\n             data: {\n@@ -88,7 +89,7 @@ export const lists = {\n             promptMany: 'Are you sure you want to report {count} {singular|plural}?',\n             promptConfirmLabel: 'Yes, report',\n             promptConfirmLabelMany: 'Yes, report {count} {singular|plural}',\n-            fail: 'Could not report {singular}',\n+            fail: 'Could not report {singular} \u201c{itemLabel}\u201d',\n             failMany: 'Could not report {countFail} {singular|plural}',\n             success: '{Singular} reported',\n             successMany: 'Successfully reported {countSuccess} {singular|plural}',\ndiff --git a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/CreateItemPage/index.tsx b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/CreateItemPage/index.tsx\nindex ac994c696e2..9cc74187358 100644\n--- a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/CreateItemPage/index.tsx\n+++ b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/CreateItemPage/index.tsx\n@@ -25,6 +25,7 @@ function CreateItemPage({ listKey }: { listKey: string }) {\n       header={\n         <ItemPageHeader\n           list={list}\n+          actions={[]}\n           label=\"Create\"\n           title={`Create ${list.singular}`}\n           item={null}\ndiff --git a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/common.tsx b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/common.tsx\nindex e84f38c26f7..2212bb40f87 100644\n--- a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/common.tsx\n+++ b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/common.tsx\n@@ -18,19 +18,20 @@ import type { ActionMeta, ListMeta } from '../../../../types'\n \n export function ItemPageHeader({\n   list,\n+  actions,\n   item,\n   label,\n   title = label,\n   onAction,\n }: {\n   list: ListMeta\n+  actions: ActionMeta[]\n   item: Record<string, unknown> | null\n   label: string\n   title: string\n   onAction: ((action: ActionMeta, resultId: string) => void) | null\n }) {\n   const router = useRouter()\n-  const actions = list.actions.filter(action => action.itemView.actionMode !== 'hidden')\n \n   return (\n     <Grid\n@@ -87,6 +88,11 @@ function replace(\n   return s\n }\n \n+type ActionError = {\n+  action: ActionMeta\n+  error: Error\n+}\n+\n function ItemActions({\n   list,\n   item,\n@@ -108,7 +114,7 @@ function ItemActions({\n       })),\n     [actions]\n   )\n-  const [errorDialogValue, setErrorDialogValue] = useState<Error | null>(null)\n+  const [actionError, setActionError] = useState<ActionError | null>(null)\n   const [activeAction, setActiveAction] = useState<ActionMeta | null>(null)\n   const itemLabel_ = item[list.labelField] ?? item.id\n   const itemLabel = typeof itemLabel_ === 'string' ? itemLabel_ : (item.id as string)\n@@ -143,10 +149,10 @@ function ItemActions({\n       }\n \n       onAction(action, data.data?.result?.id)\n-    } catch (err: any) {\n+    } catch (error: any) {\n       toastQueue.critical(replace(m.fail, list, { itemLabel }), {\n         actionLabel: 'Details',\n-        onAction: () => setErrorDialogValue(err),\n+        onAction: () => setActionError({ action, error }),\n         shouldCloseOnAction: true,\n       })\n     }\n@@ -189,8 +195,13 @@ function ItemActions({\n         )}\n       </DialogContainer>\n \n-      <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n-        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n+      <DialogContainer onDismiss={() => setActionError(null)} isDismissable>\n+        {actionError && (\n+          <ErrorDetailsDialog\n+            title={replace(actionError.action.messages.fail, list, { itemLabel })}\n+            error={actionError.error}\n+          />\n+        )}\n       </DialogContainer>\n     </Fragment>\n   )\ndiff --git a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/index.tsx b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/index.tsx\nindex 6b6d6fa327c..f0a6b823b6e 100644\n--- a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/index.tsx\n+++ b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/index.tsx\n@@ -90,7 +90,7 @@ function DeleteButton({\n             try {\n               await deleteItem()\n             } catch (err: any) {\n-              toastQueue.critical('Unable to delete item.', {\n+              toastQueue.critical('Unable to delete item', {\n                 actionLabel: 'Details',\n                 onAction: () => setErrorDialogValue(err),\n                 shouldCloseOnAction: true,\n@@ -112,7 +112,9 @@ function DeleteButton({\n       </DialogTrigger>\n \n       <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n-        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n+        {errorDialogValue && (\n+          <ErrorDetailsDialog title=\"Unable to delete item\" error={errorDialogValue} />\n+        )}\n       </DialogContainer>\n     </Fragment>\n   )\n@@ -176,7 +178,7 @@ function ItemForm({\n }) {\n   const list = useList(listKey)\n   const itemId = initialValue.id as string\n-  const [errorDialogValue, setErrorDialogValue] = useState<Error | null>(null)\n+  const [updateError, setUpdateError] = useState<Error | null>(null)\n   const [update, { loading, error }] = useMutation(\n     gql`mutation ($id: ID!, $data: ${list.graphql.names.updateInputName}!) {\n       item: ${list.graphql.names.updateMutationName}(where: { id: $id }, data: $data) {\n@@ -212,13 +214,13 @@ function ItemForm({\n     if (error) {\n       toastQueue.critical('Unable to save item', {\n         actionLabel: 'Details',\n-        onAction: () => setErrorDialogValue(new Error(error.message)),\n+        onAction: () => setUpdateError(new Error(error.message)),\n         shouldCloseOnAction: true,\n       })\n       return\n     }\n \n-    toastQueue.positive(`Saved changes to ${list.singular.toLocaleLowerCase()}`, {\n+    toastQueue.positive(`Saved changes to ${list.singular.toLocaleLowerCase()}.`, {\n       timeout: 5000,\n     })\n \n@@ -293,8 +295,8 @@ function ItemForm({\n         </BaseToolbar>\n       </form>\n \n-      <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n-        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n+      <DialogContainer onDismiss={() => setUpdateError(null)} isDismissable>\n+        {updateError && <ErrorDetailsDialog title=\"Unable to save item\" error={updateError} />}\n       </DialogContainer>\n     </Fragment>\n   )\n@@ -319,24 +321,47 @@ function ItemPage({ listKey }: ItemPageProps) {\n     return deserializeItemToValue(list.fields, item)\n   }, [list.fields, data?.item])\n \n-  const { fieldModes, fieldPositions, isRequireds } = useMemo(() => {\n+  const { actionsInContext, fieldModes, fieldPositions, isRequireds } = useMemo(() => {\n+    const actionModes = Object.fromEntries(\n+      Object.entries(list.actions).map(([k, v]) => [k, v.itemView.actionMode])\n+    )\n     const fieldModes = Object.fromEntries(\n-      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.fieldMode])\n+      Object.entries(list.fields).map(([k, v]) => [k, v.itemView.fieldMode])\n     )\n     const fieldPositions = Object.fromEntries(\n-      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.fieldPosition])\n+      Object.entries(list.fields).map(([k, v]) => [k, v.itemView.fieldPosition])\n     )\n     const isRequireds = Object.fromEntries(\n-      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.isRequired])\n+      Object.entries(list.fields).map(([k, v]) => [k, v.itemView.isRequired])\n     )\n     for (const field of data?.keystone.adminMeta.list?.fields ?? []) {\n-      if (field.itemView) {\n-        fieldModes[field.key] = field.itemView.fieldMode\n-        fieldPositions[field.key] = field.itemView.fieldPosition\n-        isRequireds[field.key] = field.itemView.isRequired\n-      }\n+      if (!field.itemView) continue\n+      fieldModes[field.key] = field.itemView.fieldMode\n+      fieldPositions[field.key] = field.itemView.fieldPosition\n+      isRequireds[field.key] = field.itemView.isRequired\n+    }\n+    for (const action of data?.keystone.adminMeta.list?.actions ?? []) {\n+      if (!action.itemView) continue\n+      actionModes[action.key] = action.itemView.actionMode\n+    }\n+\n+    // actions within context of an item\n+    const actionsInContext = list.actions\n+      .map(action => ({\n+        ...action,\n+        itemView: {\n+          ...action.itemView,\n+          actionMode: actionModes[action.key],\n+        },\n+      }))\n+      .filter(action => action.itemView.actionMode !== 'hidden')\n+\n+    return {\n+      actionsInContext,\n+      fieldModes,\n+      fieldPositions,\n+      isRequireds,\n     }\n-    return { fieldModes, fieldPositions, isRequireds }\n   }, [data?.keystone.adminMeta, list.fields])\n \n   function onAction(action: ActionMeta, resultId: string | null) {\n@@ -357,6 +382,7 @@ function ItemPage({ listKey }: ItemPageProps) {\n       header={\n         <ItemPageHeader\n           list={list}\n+          actions={actionsInContext}\n           label={typeof pageLabel !== 'string' ? 'Loading...' : pageLabel}\n           title={pageTitle}\n           item={item ?? null}\ndiff --git a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/index.tsx b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/index.tsx\nindex 40de6267865..f42d56bc3b5 100644\n--- a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/index.tsx\n+++ b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/index.tsx\n@@ -1,4 +1,5 @@\n import isDeepEqual from 'fast-deep-equal'\n+import type { GraphQLFormattedError } from 'graphql'\n import { useRouter } from 'next/router'\n import type { ParsedUrlQuery, ParsedUrlQueryInput } from 'querystring'\n import { type FormEvent, type Key, Fragment, useEffect, useId, useMemo, useState } from 'react'\n@@ -12,7 +13,7 @@ import { chevronDownIcon } from '@keystar/ui/icon/icons/chevronDownIcon'\n import { searchXIcon } from '@keystar/ui/icon/icons/searchXIcon'\n import { textSelectIcon } from '@keystar/ui/icon/icons/textSelectIcon'\n import { undo2Icon } from '@keystar/ui/icon/icons/undo2Icon'\n-import { Flex, HStack, VStack } from '@keystar/ui/layout'\n+import { Box, Flex, HStack, VStack } from '@keystar/ui/layout'\n import { Menu, MenuTrigger } from '@keystar/ui/menu'\n import { ProgressCircle } from '@keystar/ui/progress'\n import { SearchField } from '@keystar/ui/search-field'\n@@ -31,6 +32,8 @@ import { toastQueue } from '@keystar/ui/toast'\n import { Tooltip, TooltipTrigger } from '@keystar/ui/tooltip'\n import { Heading, Text } from '@keystar/ui/typography'\n \n+import { TextLink } from '@keystar/ui/link'\n+import { Notice } from '@keystar/ui/notice'\n import type { TypedDocumentNode } from '../../../../admin-ui/apollo'\n import { gql, useMutation, useQuery } from '../../../../admin-ui/apollo'\n import { CreateButtonLink } from '../../../../admin-ui/components/CreateButtonLink'\n@@ -251,7 +254,7 @@ function ListPage({ listKey }: ListPageProps) {\n   const localStorageListKey = `keystone.list.${listKey}.list.page.info`\n \n   const list = useList(listKey)\n-  const { query, replace, isReady } = useRouter()\n+  const { query, replace: routerReplace, isReady } = useRouter()\n   const [sort, setSort] = useState<SortDescriptor | null>(() => getSort(list, {}))\n   const [columns, setColumns] = useState<string[]>(list.initialColumns)\n   const [filters, setFilters] = useState<Filter[]>(() => getFilters(list, {}))\n@@ -260,6 +263,7 @@ function ListPage({ listKey }: ListPageProps) {\n   const [searchString, setSearchString] = useState('')\n   const [selectedItems, setSelectedItems] = useState<Selection>(() => new Set([]))\n   const [activeAction, setActiveAction] = useState<Key | null>(null)\n+  const [actionResult, setActionResult] = useState<ActionErrorResult | null>(null)\n   const dirty = useMemo(() => {\n     const defaultFilters = getFilters(list, {})\n     const defaultSort = getSort(list, {})\n@@ -313,7 +317,7 @@ function ListPage({ listKey }: ListPageProps) {\n     }\n \n     localStorage.setItem(localStorageListKey, JSON.stringify(updatedQuery))\n-    replace({ query: updatedQuery })\n+    routerReplace({ query: updatedQuery })\n   }, [columns, sort, filters, currentPage, pageSize, searchString, list])\n \n   const allowCreate = !(list.hideCreate ?? true)\n@@ -655,15 +659,75 @@ function ListPage({ listKey }: ListPageProps) {\n                   itemIds={selectedItemIds}\n                   {...action}\n                   list={list}\n-                  onSuccess={() => {\n+                  onSuccess={remaining => {\n                     refetch()\n-                    setSelectedItems(new Set())\n+                    setSelectedItems(remaining)\n                   }}\n+                  onErrors={setActionResult}\n                 />\n               )\n             })\n             .pop()}\n         </DialogContainer>\n+        <DialogContainer onDismiss={() => setActionResult(null)} isDismissable>\n+          {actionResult ? (\n+            <Dialog>\n+              <Heading>Error details for {actionResult.action.label} action</Heading>\n+              <Content>\n+                <VStack gap=\"large\">\n+                  {[\n+                    ...(function* () {\n+                      const { action, errors: actionErrors } = actionResult\n+                      for (const [itemId, itemActionErrors] of Object.entries(actionErrors)) {\n+                        const item = data?.items?.find(i => i.id === itemId) ?? null\n+                        const itemLabel = (item?.[list.labelField] as string | null) ?? itemId\n+                        const href = `/${list.path}/${itemId}`\n+\n+                        for (const error of itemActionErrors) {\n+                          yield (\n+                            <VStack key={itemId} gap=\"regular\">\n+                              <Notice tone=\"critical\">\n+                                <Content>\n+                                  <Text>\n+                                    You might try running the action again from{' '}\n+                                    <TextLink href={href}>\n+                                      the {list.singular.toLowerCase()}.\n+                                    </TextLink>\n+                                  </Text>\n+                                  <Box\n+                                    elementType=\"pre\"\n+                                    backgroundColor=\"critical\"\n+                                    borderRadius=\"regular\"\n+                                    maxHeight=\"100%\"\n+                                    overflow=\"auto\"\n+                                  >\n+                                    <Text\n+                                      color=\"critical\"\n+                                      UNSAFE_className={css({\n+                                        fontFamily: tokenSchema.typography.fontFamily.code,\n+                                      })}\n+                                    >\n+                                      {error.message}\n+                                    </Text>\n+                                  </Box>\n+                                </Content>\n+                                <div>\n+                                  <Heading>\n+                                    {replace(action.messages.fail, list, { itemLabel }, false)}\n+                                  </Heading>\n+                                </div>\n+                              </Notice>\n+                            </VStack>\n+                          )\n+                        }\n+                      }\n+                    })(),\n+                  ]}\n+                </VStack>\n+              </Content>\n+            </Dialog>\n+          ) : null}\n+        </DialogContainer>\n       </VStack>\n     </PageContainer>\n   )\n@@ -711,15 +775,23 @@ function replace(\n   return s\n }\n \n+type ActionErrors = Record<string, GraphQLFormattedError[]>\n+type ActionErrorResult = {\n+  action: ActionMeta\n+  errors: ActionErrors\n+}\n+\n function ActionItemsDialog({\n   list,\n   itemIds,\n   onSuccess,\n+  onErrors,\n   ...action\n }: {\n   list: ListMeta\n   itemIds: string[]\n-  onSuccess: (remaining: string[]) => void\n+  onSuccess: (remaining: Set<string>) => void\n+  onErrors: (result: ActionErrorResult) => void\n } & ActionMeta) {\n   const [actionOnItems] = useMutation<{ results?: ({ id: string } | null)[] }>(\n     gql`mutation($where: [${list.graphql.names.whereUniqueInputName}!]!) {\n@@ -736,13 +808,22 @@ function ActionItemsDialog({\n \n   async function onTryAction() {\n     try {\n-      const { data, errors } = await actionOnItems()\n-      const failed = itemIds.filter(id => !data?.results?.some(x => x?.id === id))\n-      const countSuccess = itemIds.length - failed.length\n-      const countFail = failed.length\n+      const { errors } = await actionOnItems()\n+      const countFail = errors?.length ?? 0\n+      const countSuccess = itemIds.length - countFail\n+      const failed = new Set<string>()\n+      const actionErrors: ActionErrors = {}\n+      for (const error of errors ?? []) {\n+        const i = error.path?.[1]\n+        if (typeof i !== 'number') continue\n+        const itemId = itemIds[i]\n+\n+        failed.add(itemId)\n+        actionErrors[itemId] ??= []\n+        actionErrors[itemId].push(error)\n+      }\n \n-      // if there are errors\n-      if (failed.length || errors?.length) {\n+      if (countFail) {\n         toastQueue.critical(\n           replace(\n             m.failMany,\n@@ -754,7 +835,11 @@ function ActionItemsDialog({\n             },\n             countFail > 1\n           ),\n-          { timeout: 5000 }\n+          {\n+            actionLabel: 'Details',\n+            onAction: () => onErrors({ action, errors: actionErrors }),\n+            shouldCloseOnAction: true,\n+          }\n         )\n       }\n \ndiff --git a/packages/core/src/admin-ui/components/Errors.tsx b/packages/core/src/admin-ui/components/Errors.tsx\nindex f77ee7f0273..493a480e7d2 100644\n--- a/packages/core/src/admin-ui/components/Errors.tsx\n+++ b/packages/core/src/admin-ui/components/Errors.tsx\n@@ -5,6 +5,7 @@ import { Dialog } from '@keystar/ui/dialog'\n import { Icon } from '@keystar/ui/icon'\n import { alertTriangleIcon } from '@keystar/ui/icon/icons/alertTriangleIcon'\n import { Box, Grid, VStack } from '@keystar/ui/layout'\n+import { Notice } from '@keystar/ui/notice'\n import { Content, SlotProvider } from '@keystar/ui/slots'\n import { css, tokenSchema } from '@keystar/ui/style'\n import { Heading, Text } from '@keystar/ui/typography'\n@@ -83,26 +84,34 @@ export function ErrorContainer({ children }: ErrorContainerProps) {\n   )\n }\n \n-export function ErrorDetailsDialog({ error }: { error: Error }) {\n+export function ErrorDetailsDialog({ title, error }: { title: string; error: Error }) {\n   const { message, stack } = error\n   return (\n     <Dialog>\n       <Heading>Error details</Heading>\n       <Content>\n-        <VStack gap=\"large\">\n-          <Text weight=\"medium\">{message}</Text>\n-          {stack && (\n+        <Notice tone=\"critical\">\n+          <Content>\n+            <Text weight=\"medium\">{message}</Text>\n             <Box\n               elementType=\"pre\"\n               backgroundColor=\"critical\"\n               borderRadius=\"regular\"\n               maxHeight=\"100%\"\n-              padding=\"medium\"\n               overflow=\"auto\"\n             >\n               <Text\n                 color=\"critical\"\n-                trim={false}\n+                UNSAFE_className={css({\n+                  fontFamily: tokenSchema.typography.fontFamily.code,\n+                })}\n+              >\n+                {message}\n+              </Text>\n+              <Text\n+                color=\"critical\"\n+                marginTop=\"small\"\n+                size=\"small\"\n                 UNSAFE_className={css({\n                   fontFamily: tokenSchema.typography.fontFamily.code,\n                 })}\n@@ -110,8 +119,11 @@ export function ErrorDetailsDialog({ error }: { error: Error }) {\n                 {stack}\n               </Text>\n             </Box>\n-          )}\n-        </VStack>\n+          </Content>\n+          <div>\n+            <Heading>{title}</Heading>\n+          </div>\n+        </Notice>\n       </Content>\n     </Dialog>\n   )\ndiff --git a/packages/core/src/admin-ui/context.tsx b/packages/core/src/admin-ui/context.tsx\nindex 43668c17c3f..a481db6ef01 100644\n--- a/packages/core/src/admin-ui/context.tsx\n+++ b/packages/core/src/admin-ui/context.tsx\n@@ -237,6 +237,12 @@ export function useListItem(\n               isRequired: ConditionalFilterCase<BaseListTypeInfo>\n             } | null\n           }[]\n+          actions: {\n+            key: string\n+            itemView: {\n+              actionMode: ConditionalFilter<'enabled' | 'disabled' | 'hidden', BaseListTypeInfo>\n+            } | null\n+          }[]\n         } | null\n       }\n     }\ndiff --git a/tests/admin-ui-tests/list-view-crud.test.ts b/tests/admin-ui-tests/list-view-crud.test.ts\nindex 54448dd9121..cd694596edd 100644\n--- a/tests/admin-ui-tests/list-view-crud.test.ts\n+++ b/tests/admin-ui-tests/list-view-crud.test.ts\n@@ -88,7 +88,7 @@ adminUITests('./tests/test-projects/crud-notifications', browserType => {\n     await page.getByRole('button', { name: 'Yes, delete' }).click()\n     const alertDialog = page.locator('[role=alertdialog][aria-modal=false]')\n     await alertDialog.waitFor()\n-    expect(await alertDialog.innerText()).toBe('Unable to delete 25 tasks.')\n+    expect(await alertDialog.innerText()).toBe('Unable to delete 25 tasks.\\nDetails')\n     await alertDialog.getByRole('button', { name: 'Close' }).click()\n     await page\n       .locator('[role=alertdialog][aria-modal=false]:has-text(\"Deleted 25 tasks.\")')\n",
        "test_patch": "",
        "problem_statement": "",
        "hints_text": "",
        "created_at": "2025-08-28T05:20:50Z",
        "issue_numbers": [],
        "pr_mirror": "keystonejs__keystone.052f5b1b"
    }
}