{
    "cost": 0.13882,
    "rewrites": {
        "axios__axios.ef36347f/lib/adapters/http.js": {
            "output": "'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport proxyFromEnv from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport {VERSION} from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport {EventEmitter} from 'events';\nimport formDataToStream from \"../helpers/formDataToStream.js\";\nimport readBlob from \"../helpers/readBlob.js\";\nimport ZlibHeaderTransformStream from '../helpers/ZlibHeaderTransformStream.js';\nimport callbackify from \"../helpers/callbackify.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\n\nconst zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH\n};\n\nconst brotliOptions = {\n  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n}\n\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\n\nconst {http: httpFollow, https: httpsFollow} = followRedirects;\n\nconst isHttps = /https:?/;\n\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n\nconst flushOnFinish = (stream, [throttled, flush]) => {\n  stream\n    .on('end', flush)\n    .on('error', flush);\n\n  return throttled;\n}\n\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\nfunction dispatchBeforeRedirect(options, responseDetails) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options, responseDetails);\n  }\n}\n\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    const proxyUrl = proxyFromEnv.getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n      const base64 = Buffer\n        .from(proxy.auth, 'utf8')\n        .toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost;\n    // Replace 'host' since options is not a URL object\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\nconst isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process';\n\n// temporary hotfix\n\nconst wrapAsync = (asyncExecutor) => {\n  return new Promise((resolve, reject) => {\n    let onDone;\n    let isDone;\n\n    const done = (value, isRejected) => {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    }\n\n    const _resolve = (value) => {\n      done(value);\n      resolve(value);\n    };\n\n    const _reject = (reason) => {\n      done(reason, true);\n      reject(reason);\n    }\n\n    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);\n  })\n};\n\nconst resolveFamily = ({address, family}) => {\n  if (!utils.isString(address)) {\n    throw TypeError('address must be a string');\n  }\n  return ({\n    address,\n    family: family || (address.indexOf('.') < 0 ? 6 : 4)\n  });\n}\n\nconst buildAddressEntry = (address, family) => resolveFamily(utils.isObject(address) ? address : {address, family});\n\n/*eslint consistent-return:0*/\nexport default isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n    let {data, lookup, family} = config;\n    const {responseType, responseEncoding} = config;\n    const method = config.method.toUpperCase();\n    let isDone;\n    let rejected = false;\n    let req;\n\n    if (lookup) {\n      const _lookup = callbackify(lookup, (value) => utils.isArray(value) ? value : [value]);\n      // hotfix to support opt.all option which is required for node 20.x\n      lookup = (hostname, opt, cb) => {\n        _lookup(hostname, opt, (err, arg0, arg1) => {\n          if (err) {\n            return cb(err);\n          }\n\n          const addresses = utils.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];\n\n          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);\n        });\n      }\n    }\n\n    // temporary internal emitter until the AxiosRequest class will be implemented\n    const emitter = new EventEmitter();\n\n    const onFinished = () => {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      emitter.removeAllListeners();\n    }\n\n    onDone((value, isRejected) => {\n      isDone = true;\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n    });\n\n    function abort(reason) {\n      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once('abort', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    }\n\n    // Parse url\n    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          convertedData = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: new AxiosHeaders(),\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError(\n        'Unsupported protocol ' + protocol,\n        AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize();\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n\n    const {onUploadProgress, onDownloadProgress} = config;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined;\n\n    // support for spec compliant FormData objects\n    if (utils.isSpecCompliantForm(data)) {\n      const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n\n      data = formDataToStream(data, (formHeaders) => {\n        headers.set(formHeaders);\n      }, {\n        tag: `axios-${VERSION}-boundary`,\n        boundary: userBoundary && userBoundary[1] || undefined\n      });\n      // support for https://www.npmjs.com/package/form-data api\n    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n\n      if (!headers.hasContentLength()) {\n        try {\n          const knownLength = await util.promisify(data.getLength).call(data);\n          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n          /*eslint no-empty:0*/\n        } catch (e) {\n        }\n      }\n    } else if (utils.isBlob(data) || utils.isFile(data)) {\n      data.size && headers.setContentType(data.type || 'application/octet-stream');\n      headers.setContentLength(data.size || 0);\n      data = stream.Readable.from(readBlob(data));\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers.setContentLength(data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError(\n          'Request body larger than maxBodyLength limit',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n    }\n\n    const contentLength = utils.toFiniteNumber(headers.getContentLength());\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {objectMode: false});\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n\n      onUploadProgress && data.on('progress', flushOnFinish(\n        data,\n        progressEventDecorator(\n          contentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)\n        )\n      ));\n    }\n\n    // HTTP basic authentication\n    let auth = undefined;\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n\n    let path;\n\n    try {\n      path = buildURL(\n        parsed.pathname + parsed.search,\n        config.params,\n        config.paramsSerializer\n      ).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set(\n      'Accept-Encoding',\n      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false\n      );\n\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth,\n      protocol,\n      family,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    };\n\n    // cacheable-lookup integration hotfix\n    !utils.isUndefined(lookup) && (options.lookup = lookup);\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname.startsWith(\"[\") ? parsed.hostname.slice(1, -1) : parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol",
            "output_extracted": "'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport proxyFromEnv from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport {VERSION} from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport {EventEmitter} from 'events';\nimport formDataToStream from \"../helpers/formDataToStream.js\";\nimport readBlob from \"../helpers/readBlob.js\";\nimport ZlibHeaderTransformStream from '../helpers/ZlibHeaderTransformStream.js';\nimport callbackify from \"../helpers/callbackify.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\n\nconst zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH\n};\n\nconst brotliOptions = {\n  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n}\n\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\n\nconst {http: httpFollow, https: httpsFollow} = followRedirects;\n\nconst isHttps = /https:?/;\n\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n\nconst flushOnFinish = (stream, [throttled, flush]) => {\n  stream\n    .on('end', flush)\n    .on('error', flush);\n\n  return throttled;\n}\n\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\nfunction dispatchBeforeRedirect(options, responseDetails) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options, responseDetails);\n  }\n}\n\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    const proxyUrl = proxyFromEnv.getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n      const base64 = Buffer\n        .from(proxy.auth, 'utf8')\n        .toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost;\n    // Replace 'host' since options is not a URL object\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\nconst isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process';\n\n// temporary hotfix\n\nconst wrapAsync = (asyncExecutor) => {\n  return new Promise((resolve, reject) => {\n    let onDone;\n    let isDone;\n\n    const done = (value, isRejected) => {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    }\n\n    const _resolve = (value) => {\n      done(value);\n      resolve(value);\n    };\n\n    const _reject = (reason) => {\n      done(reason, true);\n      reject(reason);\n    }\n\n    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);\n  })\n};\n\nconst resolveFamily = ({address, family}) => {\n  if (!utils.isString(address)) {\n    throw TypeError('address must be a string');\n  }\n  return ({\n    address,\n    family: family || (address.indexOf('.') < 0 ? 6 : 4)\n  });\n}\n\nconst buildAddressEntry = (address, family) => resolveFamily(utils.isObject(address) ? address : {address, family});\n\n/*eslint consistent-return:0*/\nexport default isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n    let {data, lookup, family} = config;\n    const {responseType, responseEncoding} = config;\n    const method = config.method.toUpperCase();\n    let isDone;\n    let rejected = false;\n    let req;\n\n    if (lookup) {\n      const _lookup = callbackify(lookup, (value) => utils.isArray(value) ? value : [value]);\n      // hotfix to support opt.all option which is required for node 20.x\n      lookup = (hostname, opt, cb) => {\n        _lookup(hostname, opt, (err, arg0, arg1) => {\n          if (err) {\n            return cb(err);\n          }\n\n          const addresses = utils.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];\n\n          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);\n        });\n      }\n    }\n\n    // temporary internal emitter until the AxiosRequest class will be implemented\n    const emitter = new EventEmitter();\n\n    const onFinished = () => {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      emitter.removeAllListeners();\n    }\n\n    onDone((value, isRejected) => {\n      isDone = true;\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n    });\n\n    function abort(reason) {\n      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once('abort', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    }\n\n    // Parse url\n    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          convertedData = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: new AxiosHeaders(),\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError(\n        'Unsupported protocol ' + protocol,\n        AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize();\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n\n    const {onUploadProgress, onDownloadProgress} = config;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined;\n\n    // support for spec compliant FormData objects\n    if (utils.isSpecCompliantForm(data)) {\n      const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n\n      data = formDataToStream(data, (formHeaders) => {\n        headers.set(formHeaders);\n      }, {\n        tag: `axios-${VERSION}-boundary`,\n        boundary: userBoundary && userBoundary[1] || undefined\n      });\n      // support for https://www.npmjs.com/package/form-data api\n    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n\n      if (!headers.hasContentLength()) {\n        try {\n          const knownLength = await util.promisify(data.getLength).call(data);\n          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n          /*eslint no-empty:0*/\n        } catch (e) {\n        }\n      }\n    } else if (utils.isBlob(data) || utils.isFile(data)) {\n      data.size && headers.setContentType(data.type || 'application/octet-stream');\n      headers.setContentLength(data.size || 0);\n      data = stream.Readable.from(readBlob(data));\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers.setContentLength(data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError(\n          'Request body larger than maxBodyLength limit',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n    }\n\n    const contentLength = utils.toFiniteNumber(headers.getContentLength());\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {objectMode: false});\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n\n      onUploadProgress && data.on('progress', flushOnFinish(\n        data,\n        progressEventDecorator(\n          contentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)\n        )\n      ));\n    }\n\n    // HTTP basic authentication\n    let auth = undefined;\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n\n    let path;\n\n    try {\n      path = buildURL(\n        parsed.pathname + parsed.search,\n        config.params,\n        config.paramsSerializer\n      ).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set(\n      'Accept-Encoding',\n      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false\n      );\n\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth,\n      protocol,\n      family,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    };\n\n    // cacheable-lookup integration hotfix\n    !utils.isUndefined(lookup) && (options.lookup = lookup);\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname.startsWith(\"[\") ? parsed.hostname.slice(1, -1) : parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol",
            "cost": 0.13882
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "repo": "axios/axios",
        "pull_number": 7206,
        "instance_id": "axios__axios.ef36347f.7206",
        "issue_numbers": [
            "6113"
        ],
        "base_commit": "ef36347f",
        "patch": "diff --git a/lib/adapters/http.js b/lib/adapters/http.js\nindex 524c278505..ccc89be66d 100755\n--- a/lib/adapters/http.js\n+++ b/lib/adapters/http.js\n@@ -858,6 +858,9 @@ export default isHttpAdapterSupported && function httpAdapter(config) {\n           req\n         ));\n       });\n+    } else {\n+      // explicitly reset the socket timeout value for a possible `keep-alive` request\n+      req.setTimeout(0);\n     }\n \n \n",
        "test_patch": "diff --git a/test/unit/adapters/http.js b/test/unit/adapters/http.js\nindex 6c4375a50b..864d29a3c5 100644\n--- a/test/unit/adapters/http.js\n+++ b/test/unit/adapters/http.js\n@@ -2682,6 +2682,21 @@ describe('supports http with nodejs', function () {\n       assert.strictEqual(await getStream(err.response.data), 'OK');\n     }\n   });\n+\n+  describe('keep-alive', () => {\n+    it('should not fail with \"socket hang up\" when using timeouts', async () => {\n+      server = await startHTTPServer(async (req, res) => {\n+        if (req.url === '/wait') {\n+          await new Promise(resolve => setTimeout(resolve, 5000));\n+        }\n+        res.end('ok');\n+      })\n+\n+      const baseURL = LOCAL_SERVER_URL;\n+      await axios.get('/1', {baseURL, timeout: 1000});\n+      await axios.get(`/wait`, {baseURL, timeout: 0});\n+    }, 15000);\n+  });\n });\n \n \n",
        "problem_statement": "HTTP Keep-alive, \"socket hang up\"  ECONNERR on a long-running second request\n### Describe the bug\r\n\r\nOn keep-alive connections, if a timeout value is given to the first request but not on subsequent requests, the subsequent requests will eventually throw a \"socket hang up\" error.\r\n\r\n### To Reproduce\r\n\r\n```js\r\nconst http = require('http');\r\nconst axios = require('axios');\r\n\r\ndescribe('socket hang up', () => {\r\n    let server;\r\n    beforeAll(done => {\r\n        server = http.createServer(async (req, res) => {\r\n            if (req.url === '/wait') {\r\n                await new Promise(resolve => setTimeout(resolve, 5000));\r\n            }\r\n            res.end('ok');\r\n        });\r\n        server.listen(3000, done);\r\n    });\r\n\r\n    afterAll(done => {\r\n        server.close(done);\r\n    });\r\n\r\n    it('will fail with \"socket hang up\"', async () => {\r\n        const baseURL = `http://localhost:3000`;\r\n        await axios.get('/1', {baseURL, timeout: 1000});\r\n        await axios.get(`/wait`, {baseURL, timeout: 0});\r\n    }, 15000);\r\n});\r\n```\r\n\r\n### Code snippet\r\n\r\n_No response_\r\n\r\n### Expected behavior\r\n\r\n1. \"socket hang up\" is misleading because it indicates the server closed the connection (in this bug the opposite is true)\r\n2. One would not expect that a timeout would keep running after a request has completed. This is a (quite major IMO) footgun.\r\n\r\n### Axios Version\r\n\r\n0.22.0 - 1.6.2\r\n\r\n### Adapter Version\r\n\r\nHTTP\r\n\r\n### Browser\r\n\r\n_No response_\r\n\r\n### Browser Version\r\n\r\n_No response_\r\n\r\n### Node.js Version\r\n\r\n20.9.0\r\n\r\n### OS\r\n\r\nOSX 14\r\n\r\n### Additional Library Versions\r\n\r\n_No response_\r\n\r\n### Additional context/Screenshots\r\n\r\n<img width=\"1456\" alt=\"tcpdump\" src=\"https://github.com/axios/axios/assets/100387231/a64c6544-4551-46ad-bb3e-1d9a6e9102b6\">\r\n\n",
        "hints_text": "We're also affected by this bug.\nCheers! I am affected with same bug, but can only reproduce it at Node 20.10, fallback to Node 18.18 works fine.\nThe cause of this issue is the way `follow-redirects` implements timeout. It has problems when dealing with keep-alive connections. A simple fix is to remove the `timeout` event handler when the request finishes, but I'm not sure this will work for all use-cases, as that library is mostly geared towards earlier node versions.\nSame issue here. Is there any workaround except a dumb retry?\n> Same issue here. Is there any workaround except a dumb retry?\r\n\r\n@NaZaRKIN123 Something like this would work:\r\n\r\n```typescript\r\naxios.defaults.httpAgent = new Agent({ keepAlive: false });\r\n```\r\n\r\n\nI can confirm that the workaround provided by @snarky-puppy worked for us \ud83d\ude4f\nThanks for the detail investigation. The keepAlive is needed on my project in order to reduce latency\r\nIn case we disable `follow-redirects`, would that be solved?\n+1\n+1\n+1\n+1\n> Cheers! I am affected with same bug, but can only reproduce it at Node 20.10, fallback to Node 18.18 works fine.\r\n\r\nThis is because of #6536. Short summary: Node.js changed its default Keep-Alive behavior after Node.js 18.\nI try following code in next.js _app.tsx, but not worked:\r\n\r\n```typescript\r\n// _app.tsx\r\nif (typeof window === 'undefined') {\r\n  /**\r\n   * @see https://github.com/axios/axios/issues/6113#issuecomment-1909291937\r\n   */\r\n  async function fixAxiosKeepAlive() {\r\n    const { default: axios } = await import('axios');\r\n    const { Agent } = await import('https');\r\n    axios.defaults.httpAgent = new Agent({ keepAlive: false });\r\n  }\r\n  fixAxiosKeepAlive();\r\n}\r\n```\r\n\r\nBecause of this issue, we have to revert from node 20 to 18, or we may try to remove the axios from our project. \n> ```ts\r\n> axios.defaults.httpsAgent = new Agent({ keepAlive: false });\r\n> ```\r\n@tjx666 you should replace `httpsAgent` (and `httpAgent` too if you use http, but it's a different class)\r\n\n+1\n+1\n+1\n+1\n+1\nAs I understand the issue is cause by a difference of default value between nodejs >= 20 and axios using follow-redirects.\r\nSo why we dont set up on node_modules/axios/dist/node/axios.cjs (I know its not the right place, the right place is near defaults into lib/defaults/index.js) a default value for matching default configuration of nodejs like this.\r\n\r\n```\r\n3002     if (config.insecureHTTPParser) {\r\n3003       options.insecureHTTPParser = config.insecureHTTPParser;\r\n3004     }\r\n\r\n3005     if (!options.agents.http) {                                                                              \r\n3006       options.agents.http = new http.Agent({ keepAlive: true, scheduling: 'lifo', timeout: 5000 });      \r\n3007       options.agents.https = new https.Agent({ keepAlive: true, scheduling: 'lifo', timeout: 5000 });\r\n3008     }\r\n\r\n```\r\n in this case if no agents are provide we will use agent by default with keepalive = true?\r\n\r\nI know that I can add for settings this default on my code, but I have to update many service, So I am wondering why this is not do on axios.\r\n\r\n```\r\naxios.defaults.httpAgent = new http.Agent({ keepAlive: true, scheduling: 'lifo', timeout: 5000 });\r\naxios.defaults.httpsAgent = new https.Agent({ keepAlive: true, scheduling: 'lifo', timeout: 5000 });\r\n```\r\n\r\nUsing \"axios-retry\" or \"node-fetch\" is not really for me a workaround, \r\n\r\n- retry will multiply call for nothing\r\n- and node-fetch is forget completely axios.\r\n\r\nUpdating all my code is a shame.\r\n\r\n\r\n\r\n\r\n\nI decide to never use axios because this serious issue\nsame thing for me, I took the opportunity to switch to native `fetch`.\nby doing like this its works like a charm\r\n\r\n```\r\ndiff --git a/lib/adapters/http.js b/lib/adapters/http.js\r\nindex da0a42d..6bd82a3 100755\r\n--- a/lib/adapters/http.js\r\n+++ b/lib/adapters/http.js\r\n@@ -413,7 +413,7 @@ export default isHttpAdapterSupported && function httpAdapter(config) {\r\n       path,\r\n       method: method,\r\n       headers: headers.toJSON(),\r\n-      agents: { http: config.httpAgent, https: config.httpsAgent },\r\n+      agents: { http: typeof config.httpAgent === 'function' ? config.httpAgent(http) : config.httpAgent, https: typeof config.httpsAgent === 'function' ? config.httpsAgent(https) : config.httpsAgent },\r\n       auth,\r\n       protocol,\r\n       family,\r\n@@ -434,7 +434,7 @@ export default isHttpAdapterSupported && function httpAdapter(config) {\r\n \r\n     let transport;\r\n     const isHttpsRequest = isHttps.test(options.protocol);\r\n-    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\r\n+    options.agent = isHttpsRequest ? (typeof config.httpsAgent === 'function' ? config.httpsAgent(https) : config.httpsAgent) : (typeof config.httpAgent === 'function' ? config.httpAgent(http) : config.httpAgent);\r\n     if (config.transport) {\r\n       transport = config.transport;\r\n     } else if (config.maxRedirects === 0) {\r\ndiff --git a/lib/defaults/index.js b/lib/defaults/index.js\r\nindex e543fea..7e9782e 100644\r\n--- a/lib/defaults/index.js\r\n+++ b/lib/defaults/index.js\r\n@@ -151,7 +151,10 @@ const defaults = {\r\n       'Accept': 'application/json, text/plain, */*',\r\n       'Content-Type': undefined\r\n     }\r\n-  }\r\n+  },\r\n+\r\n+  httpAgent: (http) => new http.Agent({ keepAlive: true, scheduling: 'lifo', timeout: 5000 }),\r\n+  httpsAgent: (https) => new https.Agent({ keepAlive: true, scheduling: 'lifo', timeout: 5000 })\r\n };\r\n \r\n utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\r\n\r\n```\r\nThe idea is to setup defaut agent as nodejs do since version 20\r\n\nwill start looking into how we can fix this\nsame issue\nHello, just find out the same issue was causing a socket hangup today. Fix from @snarky-puppy solved the issue.\r\n\r\nI think a lot of people is guessing if should switch to a native solution based on what's happening here.\nany updates on this guys?\n> will start looking into how we can fix this\n\nHello Guys, how are you? Do you have updates?\n> > Same issue here. Is there any workaround except a dumb retry?\n> \n> [@NaZaRKIN123](https://github.com/NaZaRKIN123) Something like this would work:\n> \n> axios.defaults.httpAgent = new Agent({ keepAlive: false });\n\n@NaZaRKIN123 Why would this fix it if the default is a disabled keepAlive? \ud83e\udd14  \n\nInterestingly, I tried it for some endpoints and haven't got any new alerts since then. But I cannot reason or justify this change yet \ud83e\udd14  Both [Axios](https://github.com/axios/axios/blob/32c7bcc0f233285ba27dec73a4b1e81fb7a219b3/README.md?plain=1#L546-L550) and [Node's HTTP agent](https://nodejs.org/api/http.html#new-agentoptions) have the keepAlive disabled by default.\n> Why would this fix it if the default is a disabled keepAlive? \n\n@7onn This problem is caused by the fact that in node v20 [they turned on the keep-alive option on the default HTTP agent](https://github.com/nodejs/node/blob/a7f648c8ba77b542dff20e717ab3e005425fa1a6/lib/_http_agent.js#L546), while their default scheduling algorithm has a fairly high probability of race conditions, in which the client may get a nearly expired socket that has actually already been closed on the server side, which causes a socket usage error. \n\n```js\nconst instance = axios.create({\n  httpAgent: new http.Agent({ keepAlive: false}),\n  httpsAgent: new https.Agent({ keepAlive: false})\n});\n```\nIt would be hard to fix anything from the Axios side, since this is a problem inside the node.js, unless you write your own UserAgent and scheduler, which would be useless as soon as the node maintainers fixed this problem, so it was logical to just wait and manually disable `keepAlive`.\nFrom what I can see in the node.js codebase, [5 months ago they finally pushed a fix](https://github.com/nodejs/node/blame/5c83957601e16137c0ef925191435199bb8d40e1/lib/_http_agent.js#L482C2-L490) to provide a hard-coded 1000ms safety time window, which I believe should solve the problem in most cases.\n\n\n\n\n\n\nI use it actually for react native and experimenting that same delay for continuous request, are any way tho change that of keepAlive on axios for react native?\nclosing as per @DigitalBrainJS comment, will add this to be documented\nas of 2025/9/15,  axios 0.22.0+  {keepAlive: false}  do not work for me.  \nBut 0.21.4 is working.\nThe api is just about 10 seconds, not too long,  so tricky\n\n\n-----\nas of 2025/9/17, this should work.  I my project,  httpsAgent is set in another request which is not set keepAlive:false,   after reset all httpsAgent  httpAgent, It works for http request.  but not for https request.\n\n-----\nthis bug have existed for many years,  use fetch instead finally. This should be axios and nodejs compatibility bug. Upgrate to nodejs v20.19.5 still not work.\n@DigitalBrainJS According to [this PR](https://github.com/nodejs/node/pull/55170) the [\"fix\"](https://github.com/nodejs/node/blame/5c83957601e16137c0ef925191435199bb8d40e1/lib/_http_agent.js#L482C2-L490) in node you mentioned made it into node 20.18.0. We are running on node 20.18.0 with axios 1.9.0 and still receive a lot of ECONNERR and \"socket hang up\" errors in production. \n\nSince axios is supporting `fetch` since 1.7.0 it might be best option to switch the adapter to `fetch`, which then uses `undici` under the hood in node which according to [this thread](https://github.com/nodejs/node/issues/47130) does not have such issues.\n\nWe are currently in the process of rolling this out to our production environment. So I will report in a few weeks whether this switch fixed our problems. \n@yss14 thanks, please update us when you are ready!\n@jasonsaayman I can already give you an update on this, since the change is now rolled out for a few days on our production environment.\nUnfortunately, this didn't solve the problem for use. The errors now reported by Sentry turned into undici specific socket errors `other side closed`. So it seems like we have a different problem in our microservice infrastructure which I now have to investigate further.",
        "created_at": "2025-11-03T22:52:03Z",
        "pr_mirror": "axios__axios.ef36347f"
    }
}