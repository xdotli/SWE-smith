{
    "cost": 0.113925,
    "rewrites": {
        "dubinc__dub.main/apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts": {
            "output": "import { detectDuplicatePayoutMethodFraud } from \"@/lib/api/fraud/detect-duplicate-payout-method-fraud\";\nimport { stripe } from \"@/lib/stripe\";\nimport { sendBatchEmail, sendEmail } from \"@dub/email\";\nimport ConnectedPayoutMethod from \"@dub/email/templates/connected-payout-method\";\nimport DuplicatePayoutMethod from \"@dub/email/templates/duplicate-payout-method\";\nimport { prisma } from \"@dub/prisma\";\nimport { log } from \"@dub/utils\";\nimport Stripe from \"stripe\";\n\nexport async function accountUpdated(event: Stripe.Event) {\n  const account = event.data.object as Stripe.Account;\n\n  const { country, payouts_enabled: payoutsEnabled } = account;\n\n  const partner = await prisma.partner.findUnique({\n    where: {\n      stripeConnectId: account.id,\n    },\n    select: {\n      id: true,\n      stripeConnectId: true,\n      email: true,\n      payoutsEnabledAt: true,\n      payoutMethodHash: true,\n    },\n  });\n\n  if (!partner) {\n    return `Partner with stripeConnectId ${account.id} not found, skipping...`;\n  }\n\n  if (!payoutsEnabled) {\n    if (partner.payoutsEnabledAt || partner.payoutMethodHash) {\n      await prisma.partner.update({\n        where: {\n          id: partner.id,\n        },\n        data: {\n          payoutsEnabledAt: null,\n          payoutMethodHash: null,\n        },\n      });\n      return `Payouts disabled, updated partner ${partner.email} (${partner.stripeConnectId}) with payoutsEnabledAt and payoutMethodHash null`;\n    }\n    return `No change in payout status for ${partner.email} (${partner.stripeConnectId}), skipping...`;\n  }\n\n  const { data: externalAccounts } = await stripe.accounts.listExternalAccounts(\n    partner.stripeConnectId!,\n  );\n\n  const defaultExternalAccount = externalAccounts.find(\n    (account) => account.default_for_currency,\n  );\n\n  if (!defaultExternalAccount) {\n    // this should never happen, but just in case\n    await log({\n      message: `Expected at least 1 external account for partner ${partner.email} (${partner.stripeConnectId}), none found`,\n      type: \"errors\",\n    });\n    return `Expected at least 1 external account for partner ${partner.email} (${partner.stripeConnectId}), none found`;\n  }\n\n  const { payoutMethodHash } = await prisma.partner.update({\n    where: {\n      stripeConnectId: account.id,\n    },\n    data: {\n      country,\n      payoutsEnabledAt: partner.payoutsEnabledAt\n        ? undefined // Don't update if already set\n        : new Date(),\n      payoutMethodHash: defaultExternalAccount.fingerprint,\n    },\n  });\n\n  if (payoutMethodHash) {\n    const { isPayoutMethodDuplicate, duplicatePartners } =\n      await detectDuplicatePayoutMethodFraud(payoutMethodHash);\n\n    // Send confirmation email only if this is the first time connecting a bank account and no fraud detected\n    if (\n      partner.email &&\n      !partner.payoutsEnabledAt &&\n      !isPayoutMethodDuplicate &&\n      defaultExternalAccount.object === \"bank_account\"\n    ) {\n      await sendEmail({\n        variant: \"notifications\",\n        subject: \"Successfully connected payout method\",\n        to: partner.email,\n        react: ConnectedPayoutMethod({\n          email: partner.email,\n          payoutMethod: {\n            account_holder_name: defaultExternalAccount.account_holder_name,\n            bank_name: defaultExternalAccount.bank_name,\n            last4: defaultExternalAccount.last4,\n            routing_number: defaultExternalAccount.routing_number,\n          },\n        }),\n      });\n    }\n\n    // Notify all partners using the same bank account about duplicate payout method\n    if (\n      isPayoutMethodDuplicate &&\n      duplicatePartners.length > 0 &&\n      defaultExternalAccount.object === \"bank_account\"\n    ) {\n      await sendBatchEmail(\n        duplicatePartners.map((partner) => ({\n          variant: \"notifications\",\n          subject: \"Duplicate payout method detected\",\n          to: partner.email!,\n          react: DuplicatePayoutMethod({\n            email: partner.email!,\n            payoutMethod: {\n              account_holder_name: defaultExternalAccount.account_holder_name,\n              bank_name: defaultExternalAccount.bank_name,\n              last4: defaultExternalAccount.last4,\n              routing_number: defaultExternalAccount.routing_number,\n            },\n          }),\n        })),\n      );\n    }\n  }\n\n  return `Updated partner ${partner.email} (${partner.stripeConnectId}) with country ${country}, payoutsEnabledAt set, payoutMethodHash ${defaultExternalAccount.fingerprint}`;\n}",
            "output_extracted": "import { detectDuplicatePayoutMethodFraud } from \"@/lib/api/fraud/detect-duplicate-payout-method-fraud\";\nimport { stripe } from \"@/lib/stripe\";\nimport { sendBatchEmail, sendEmail } from \"@dub/email\";\nimport ConnectedPayoutMethod from \"@dub/email/templates/connected-payout-method\";\nimport DuplicatePayoutMethod from \"@dub/email/templates/duplicate-payout-method\";\nimport { prisma } from \"@dub/prisma\";\nimport { log } from \"@dub/utils\";\nimport Stripe from \"stripe\";\n\nexport async function accountUpdated(event: Stripe.Event) {\n  const account = event.data.object as Stripe.Account;\n\n  const { country, payouts_enabled: payoutsEnabled } = account;\n\n  const partner = await prisma.partner.findUnique({\n    where: {\n      stripeConnectId: account.id,\n    },\n    select: {\n      id: true,\n      stripeConnectId: true,\n      email: true,\n      payoutsEnabledAt: true,\n      payoutMethodHash: true,\n    },\n  });\n\n  if (!partner) {\n    return `Partner with stripeConnectId ${account.id} not found, skipping...`;\n  }\n\n  if (!payoutsEnabled) {\n    if (partner.payoutsEnabledAt || partner.payoutMethodHash) {\n      await prisma.partner.update({\n        where: {\n          id: partner.id,\n        },\n        data: {\n          payoutsEnabledAt: null,\n          payoutMethodHash: null,\n        },\n      });\n      return `Payouts disabled, updated partner ${partner.email} (${partner.stripeConnectId}) with payoutsEnabledAt and payoutMethodHash null`;\n    }\n    return `No change in payout status for ${partner.email} (${partner.stripeConnectId}), skipping...`;\n  }\n\n  const { data: externalAccounts } = await stripe.accounts.listExternalAccounts(\n    partner.stripeConnectId!,\n  );\n\n  const defaultExternalAccount = externalAccounts.find(\n    (account) => account.default_for_currency,\n  );\n\n  if (!defaultExternalAccount) {\n    // this should never happen, but just in case\n    await log({\n      message: `Expected at least 1 external account for partner ${partner.email} (${partner.stripeConnectId}), none found`,\n      type: \"errors\",\n    });\n    return `Expected at least 1 external account for partner ${partner.email} (${partner.stripeConnectId}), none found`;\n  }\n\n  const { payoutMethodHash } = await prisma.partner.update({\n    where: {\n      stripeConnectId: account.id,\n    },\n    data: {\n      country,\n      payoutsEnabledAt: partner.payoutsEnabledAt\n        ? undefined // Don't update if already set\n        : new Date(),\n      payoutMethodHash: defaultExternalAccount.fingerprint,\n    },\n  });\n\n  if (payoutMethodHash) {\n    const { isPayoutMethodDuplicate, duplicatePartners } =\n      await detectDuplicatePayoutMethodFraud(payoutMethodHash);\n\n    // Send confirmation email only if this is the first time connecting a bank account and no fraud detected\n    if (\n      partner.email &&\n      !partner.payoutsEnabledAt &&\n      !isPayoutMethodDuplicate &&\n      defaultExternalAccount.object === \"bank_account\"\n    ) {\n      await sendEmail({\n        variant: \"notifications\",\n        subject: \"Successfully connected payout method\",\n        to: partner.email,\n        react: ConnectedPayoutMethod({\n          email: partner.email,\n          payoutMethod: {\n            account_holder_name: defaultExternalAccount.account_holder_name,\n            bank_name: defaultExternalAccount.bank_name,\n            last4: defaultExternalAccount.last4,\n            routing_number: defaultExternalAccount.routing_number,\n          },\n        }),\n      });\n    }\n\n    // Notify all partners using the same bank account about duplicate payout method\n    if (\n      isPayoutMethodDuplicate &&\n      duplicatePartners.length > 0 &&\n      defaultExternalAccount.object === \"bank_account\"\n    ) {\n      await sendBatchEmail(\n        duplicatePartners.map((partner) => ({\n          variant: \"notifications\",\n          subject: \"Duplicate payout method detected\",\n          to: partner.email!,\n          react: DuplicatePayoutMethod({\n            email: partner.email!,\n            payoutMethod: {\n              account_holder_name: defaultExternalAccount.account_holder_name,\n              bank_name: defaultExternalAccount.bank_name,\n              last4: defaultExternalAccount.last4,\n              routing_number: defaultExternalAccount.routing_number,\n            },\n          }),\n        })),\n      );\n    }\n  }\n\n  return `Updated partner ${partner.email} (${partner.stripeConnectId}) with country ${country}, payoutsEnabledAt set, payoutMethodHash ${defaultExternalAccount.fingerprint}`;\n}",
            "cost": 0.046745
        },
        "dubinc__dub.main/apps/web/tests/fraud/index.test.ts": {
            "output": "import { Customer, TrackLeadResponse } from \"@/lib/types\";\nimport { fraudEventSchemas } from \"@/lib/zod/schemas/fraud\";\nimport { FraudRuleType } from \"@prisma/client\";\nimport { randomCustomer, retry } from \"tests/utils/helpers\";\nimport { HttpClient } from \"tests/utils/http\";\nimport {\n  E2E_FRAUD_PARTNER,\n  E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN,\n  E2E_TRACK_CLICK_HEADERS,\n} from \"tests/utils/resource\";\nimport { describe, expect, test } from \"vitest\";\nimport { z } from \"zod\";\nimport { IntegrationHarness } from \"../utils/integration\";\n\ndescribe.concurrent(\"/fraud/**\", async () => {\n  const h = new IntegrationHarness();\n  const { http } = await h.init();\n\n  test(\"FraudRuleType = customerEmailMatch\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.customerEmailMatch;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = {\n      ...randomCustomer(),\n      email: E2E_FRAUD_PARTNER.email, // same email as partner\n    };\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"customerEmailMatch\",\n    });\n  });\n\n  test(\"FraudRuleType = customerEmailSuspiciousDomain\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.customerEmailSuspiciousDomain;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer({ emailDomain: \"email-temp.com\" });\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"customerEmailSuspiciousDomain\",\n    });\n  });\n\n  test(\"FraudRuleType = referralSourceBanned\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.referralSourceBanned;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n        referer: `https://${E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN}`,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer();\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"referralSourceBanned\",\n    });\n  });\n\n  test(\"FraudRuleType = paidTrafficDetected\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.paidTrafficDetected;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n        url: \"https://dub.co/paid-traffic?gclid=1234567890&gad_source=1\",\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer();\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"paidTrafficDetected\",\n    });\n  });\n});\n\nconst verifyFraudEvent = async ({\n  http,\n  customer,\n  ruleType,\n}: {\n  http: HttpClient;\n  customer: Pick<Customer, \"externalId\">;\n  ruleType: FraudRuleType;\n}) => {\n  // Resolve customerId from customerExternalID\n  const { data: customers } = await http.get<Customer[]>({\n    path: \"/customers\",\n    query: { externalId: customer.externalId },\n  });\n\n  expect(customers.length).toBeGreaterThan(0);\n\n  // Wait until fraud event is available\n  const fraudEvent = await waitForFraudEvent({\n    http,\n    customerId: customers[0].id,\n    ruleType,\n  });\n\n  // Assert fraud event shape\n  expect(fraudEvent).toStrictEqual({\n    createdAt: expect.any(String),\n    customer: expect.objectContaining({\n      id: customers[0].id,\n      name: customers[0].name,\n      email: customers[0].email,\n      avatar: customers[0].avatar,\n    }),\n    ...(ruleType === \"paidTrafficDetected\" && {\n      metadata: {\n        source: \"google\",\n        url: \"https://dub.co/paid-traffic?gclid=1234567890&gad_source=1\",\n      },\n    }),\n    ...(ruleType === \"referralSourceBanned\" && {\n      metadata: {\n        source: E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN,\n      },\n    }),\n  });\n};\n\nasync function waitForFraudEvent({\n  http,\n  customerId,\n  ruleType,\n}: {\n  http: HttpClient;\n  customerId: string;\n  ruleType: FraudRuleType;\n}) {\n  return await retry(\n    async () => {\n      const { data } = await http.get<\n        z.infer<(typeof fraudEventSchemas)[keyof typeof fraudEventSchemas]>[]\n      >({\n        path: \"/fraud/events\",\n        query: {\n          customerId,\n          type: ruleType,\n        },\n      });\n\n      if (!data.length) {\n        throw new Error(\"Fraud event not ready.\");\n      }\n\n      return data[0];\n    },\n    { retries: 10, interval: 300 },\n  );\n}",
            "output_extracted": "import { Customer, TrackLeadResponse } from \"@/lib/types\";\nimport { fraudEventSchemas } from \"@/lib/zod/schemas/fraud\";\nimport { FraudRuleType } from \"@prisma/client\";\nimport { randomCustomer, retry } from \"tests/utils/helpers\";\nimport { HttpClient } from \"tests/utils/http\";\nimport {\n  E2E_FRAUD_PARTNER,\n  E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN,\n  E2E_TRACK_CLICK_HEADERS,\n} from \"tests/utils/resource\";\nimport { describe, expect, test } from \"vitest\";\nimport { z } from \"zod\";\nimport { IntegrationHarness } from \"../utils/integration\";\n\ndescribe.concurrent(\"/fraud/**\", async () => {\n  const h = new IntegrationHarness();\n  const { http } = await h.init();\n\n  test(\"FraudRuleType = customerEmailMatch\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.customerEmailMatch;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = {\n      ...randomCustomer(),\n      email: E2E_FRAUD_PARTNER.email, // same email as partner\n    };\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"customerEmailMatch\",\n    });\n  });\n\n  test(\"FraudRuleType = customerEmailSuspiciousDomain\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.customerEmailSuspiciousDomain;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer({ emailDomain: \"email-temp.com\" });\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"customerEmailSuspiciousDomain\",\n    });\n  });\n\n  test(\"FraudRuleType = referralSourceBanned\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.referralSourceBanned;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n        referer: `https://${E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN}`,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer();\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"referralSourceBanned\",\n    });\n  });\n\n  test(\"FraudRuleType = paidTrafficDetected\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.paidTrafficDetected;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n        url: \"https://dub.co/paid-traffic?gclid=1234567890&gad_source=1\",\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer();\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"paidTrafficDetected\",\n    });\n  });\n});\n\nconst verifyFraudEvent = async ({\n  http,\n  customer,\n  ruleType,\n}: {\n  http: HttpClient;\n  customer: Pick<Customer, \"externalId\">;\n  ruleType: FraudRuleType;\n}) => {\n  // Resolve customerId from customerExternalID\n  const { data: customers } = await http.get<Customer[]>({\n    path: \"/customers\",\n    query: { externalId: customer.externalId },\n  });\n\n  expect(customers.length).toBeGreaterThan(0);\n\n  // Wait until fraud event is available\n  const fraudEvent = await waitForFraudEvent({\n    http,\n    customerId: customers[0].id,\n    ruleType,\n  });\n\n  // Assert fraud event shape\n  expect(fraudEvent).toStrictEqual({\n    createdAt: expect.any(String),\n    customer: expect.objectContaining({\n      id: customers[0].id,\n      name: customers[0].name,\n      email: customers[0].email,\n      avatar: customers[0].avatar,\n    }),\n    ...(ruleType === \"paidTrafficDetected\" && {\n      metadata: {\n        source: \"google\",\n        url: \"https://dub.co/paid-traffic?gclid=1234567890&gad_source=1\",\n      },\n    }),\n    ...(ruleType === \"referralSourceBanned\" && {\n      metadata: {\n        source: E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN,\n      },\n    }),\n  });\n};\n\nasync function waitForFraudEvent({\n  http,\n  customerId,\n  ruleType,\n}: {\n  http: HttpClient;\n  customerId: string;\n  ruleType: FraudRuleType;\n}) {\n  return await retry(\n    async () => {\n      const { data } = await http.get<\n        z.infer<(typeof fraudEventSchemas)[keyof typeof fraudEventSchemas]>[]\n      >({\n        path: \"/fraud/events\",\n        query: {\n          customerId,\n          type: ruleType,\n        },\n      });\n\n      if (!data.length) {\n        throw new Error(\"Fraud event not ready.\");\n      }\n\n      return data[0];\n    },\n    { retries: 10, interval: 300 },\n  );\n}",
            "cost": 0.06718
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "dubinc__dub.main.3166",
        "repo": "dubinc/dub",
        "base_commit": "beac3b75f8feb4b1a78fd33801c5544adbfaaad9",
        "head_commit": "80cd6686263776db53a8e3c339f82f199bd2f76b",
        "title": "Retry stripe payouts after account verification",
        "merged_at": "2025-11-27T07:50:16Z",
        "html_url": "https://github.com/dubinc/dub/pull/3166",
        "test_files": [
            "apps/web/tests/fraud/index.test.ts"
        ],
        "code_files": [
            "apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts"
        ],
        "total_changes": 30,
        "num_files": 2,
        "pull_number": 3166,
        "patch": "diff --git a/apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts b/apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts\nindex dc63bac2cde..dc9e139f5ba 100644\n--- a/apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts\n+++ b/apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts\n@@ -1,9 +1,14 @@\n import { createFraudEvents } from \"@/lib/api/fraud/create-fraud-events\";\n+import { qstash } from \"@/lib/cron\";\n import { stripe } from \"@/lib/stripe\";\n import { prisma } from \"@dub/prisma\";\n-import { log } from \"@dub/utils\";\n+import { APP_DOMAIN_WITH_NGROK, log } from \"@dub/utils\";\n import Stripe from \"stripe\";\n \n+const queue = qstash.queue({\n+  queueName: \"withdraw-stripe-balance\",\n+});\n+\n export async function accountUpdated(event: Stripe.Event) {\n   const account = event.data.object as Stripe.Account;\n \n@@ -110,5 +115,26 @@ export async function accountUpdated(event: Stripe.Event) {\n     }\n   }\n \n+  // Retry payouts that got stuck when the account was restricted (e.g: payout sent but paused\n+  // due to verification requirements). Once payouts are re-enabled, queue them for processing.\n+  const pendingPayouts = await prisma.payout.count({\n+    where: {\n+      partnerId: partner.id,\n+      status: \"sent\",\n+      mode: \"internal\",\n+    },\n+  });\n+\n+  if (pendingPayouts > 0) {\n+    await queue.enqueueJSON({\n+      url: `${APP_DOMAIN_WITH_NGROK}/api/cron/payouts/balance-available`,\n+      deduplicationId: event.id,\n+      method: \"POST\",\n+      body: {\n+        stripeAccount: partner.stripeConnectId,\n+      },\n+    });\n+  }\n+\n   return `Updated partner ${partner.email} (${partner.stripeConnectId}) with country ${country}, payoutsEnabledAt set, payoutMethodHash ${defaultExternalAccount.fingerprint}`;\n }\ndiff --git a/apps/web/tests/fraud/index.test.ts b/apps/web/tests/fraud/index.test.ts\nindex 27354a54165..e788eec903e 100644\n--- a/apps/web/tests/fraud/index.test.ts\n+++ b/apps/web/tests/fraud/index.test.ts\n@@ -254,6 +254,6 @@ async function waitForFraudEvent({\n \n       return data[0];\n     },\n-    { retries: 10, interval: 300 },\n+    { retries: 10, interval: 600 },\n   );\n }\n",
        "pr_mirror": "dubinc__dub.main"
    }
}