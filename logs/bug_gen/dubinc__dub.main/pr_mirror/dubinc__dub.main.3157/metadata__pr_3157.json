{
    "cost": 0.41189000000000003,
    "rewrites": {
        "dubinc__dub.main/apps/web/app/(ee)/api/customers/[id]/route.ts": {
            "output": "import { getCustomerOrThrow } from \"@/lib/api/customers/get-customer-or-throw\";\nimport { transformCustomer } from \"@/lib/api/customers/transform-customer\";\nimport { DubApiError } from \"@/lib/api/errors\";\nimport { parseRequestBody } from \"@/lib/api/utils\";\nimport { withWorkspace } from \"@/lib/auth\";\nimport { isStored, storage } from \"@/lib/storage\";\nimport {\n  CustomerEnrichedSchema,\n  CustomerSchema,\n  getCustomersQuerySchema,\n  updateCustomerBodySchema,\n} from \"@/lib/zod/schemas/customers\";\nimport { prisma } from \"@dub/prisma\";\nimport { nanoid, R2_URL } from \"@dub/utils\";\nimport { waitUntil } from \"@vercel/functions\";\nimport { NextResponse } from \"next/server\";\n\n// GET /api/customers/:id \u2013 Get a customer by ID\nexport const GET = withWorkspace(\n  async ({ workspace, params, searchParams }) => {\n    const { id } = params;\n    const { includeExpandedFields } =\n      getCustomersQuerySchema.parse(searchParams);\n\n    const customer = await getCustomerOrThrow(\n      {\n        id,\n        workspaceId: workspace.id,\n      },\n      {\n        includeExpandedFields,\n      },\n    );\n\n    const responseSchema = includeExpandedFields\n      ? CustomerEnrichedSchema\n      : CustomerSchema;\n\n    return NextResponse.json(responseSchema.parse(transformCustomer(customer)));\n  },\n  {\n    requiredPlan: [\n      \"business\",\n      \"business plus\",\n      \"business extra\",\n      \"business max\",\n      \"advanced\",\n      \"enterprise\",\n    ],\n  },\n);\n\n// PATCH /api/customers/:id \u2013 Update a customer by ID\nexport const PATCH = withWorkspace(\n  async ({ workspace, params, req, searchParams }) => {\n    const { id } = params;\n    const { includeExpandedFields } =\n      getCustomersQuerySchema.parse(searchParams);\n\n    const { name, email, avatar, externalId } = updateCustomerBodySchema.parse(\n      await parseRequestBody(req),\n    );\n\n    const customer = await getCustomerOrThrow(\n      {\n        id,\n        workspaceId: workspace.id,\n      },\n      {\n        includeExpandedFields,\n      },\n    );\n\n    const oldCustomerAvatar = customer.avatar;\n\n    // we need to persist the customer avatar to R2 if:\n    // 1. it's different from the old avatar\n    // 2. it's not stored in R2 already\n    const finalCustomerAvatar =\n      avatar && avatar !== oldCustomerAvatar && !isStored(avatar)\n        ? `${R2_URL}/customers/${customer.id}/avatar_${nanoid(7)}`\n        : avatar;\n\n    try {\n      const updatedCustomer = await prisma.customer.update({\n        where: {\n          id: customer.id,\n        },\n        data: {\n          name,\n          email,\n          avatar: finalCustomerAvatar,\n          externalId,\n        },\n      });\n\n      if (avatar && !isStored(avatar) && finalCustomerAvatar) {\n        waitUntil(\n          Promise.allSettled([\n            storage.upload({\n              key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n              body: avatar,\n              opts: {\n                width: 128,\n                height: 128,\n              },\n            }),\n            oldCustomerAvatar &&\n              isStored(oldCustomerAvatar) &&\n              storage.delete({\n                key: oldCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n              }),\n          ]),\n        );\n      }\n\n      const responseSchema = includeExpandedFields\n        ? CustomerEnrichedSchema\n        : CustomerSchema;\n\n      return NextResponse.json(\n        responseSchema.parse(\n          transformCustomer({\n            ...customer,\n            ...updatedCustomer,\n          }),\n        ),\n      );\n    } catch (error) {\n      if (error.code === \"P2002\") {\n        throw new DubApiError({\n          code: \"conflict\",\n          message: \"A customer with this external ID already exists.\",\n        });\n      }\n\n      throw new DubApiError({\n        code: \"unprocessable_entity\",\n        message: error.message,\n      });\n    }\n  },\n  {\n    requiredPlan: [\n      \"business\",\n      \"business plus\",\n      \"business extra\",\n      \"business max\",\n      \"advanced\",\n      \"enterprise\",\n    ],\n  },\n);\n\n// DELETE /api/customers/:id \u2013 Delete a customer by ID\nexport const DELETE = withWorkspace(\n  async ({ workspace, params }) => {\n    const { id } = params;\n\n    const customer = await getCustomerOrThrow({\n      id,\n      workspaceId: workspace.id,\n    });\n\n    await prisma.customer.delete({\n      where: {\n        id: customer.id,\n      },\n    });\n\n    if (customer.avatar && isStored(customer.avatar)) {\n      storage.delete({ key: customer.avatar.replace(`${R2_URL}/`, \"\") });\n    }\n\n    return NextResponse.json({\n      id: customer.id,\n    });\n  },\n  {\n    requiredPlan: [\n      \"business\",\n      \"business plus\",\n      \"business extra\",\n      \"business max\",\n      \"advanced\",\n      \"enterprise\",\n    ],\n  },\n);",
            "output_extracted": "import { getCustomerOrThrow } from \"@/lib/api/customers/get-customer-or-throw\";\nimport { transformCustomer } from \"@/lib/api/customers/transform-customer\";\nimport { DubApiError } from \"@/lib/api/errors\";\nimport { parseRequestBody } from \"@/lib/api/utils\";\nimport { withWorkspace } from \"@/lib/auth\";\nimport { isStored, storage } from \"@/lib/storage\";\nimport {\n  CustomerEnrichedSchema,\n  CustomerSchema,\n  getCustomersQuerySchema,\n  updateCustomerBodySchema,\n} from \"@/lib/zod/schemas/customers\";\nimport { prisma } from \"@dub/prisma\";\nimport { nanoid, R2_URL } from \"@dub/utils\";\nimport { waitUntil } from \"@vercel/functions\";\nimport { NextResponse } from \"next/server\";\n\n// GET /api/customers/:id \u2013 Get a customer by ID\nexport const GET = withWorkspace(\n  async ({ workspace, params, searchParams }) => {\n    const { id } = params;\n    const { includeExpandedFields } =\n      getCustomersQuerySchema.parse(searchParams);\n\n    const customer = await getCustomerOrThrow(\n      {\n        id,\n        workspaceId: workspace.id,\n      },\n      {\n        includeExpandedFields,\n      },\n    );\n\n    const responseSchema = includeExpandedFields\n      ? CustomerEnrichedSchema\n      : CustomerSchema;\n\n    return NextResponse.json(responseSchema.parse(transformCustomer(customer)));\n  },\n  {\n    requiredPlan: [\n      \"business\",\n      \"business plus\",\n      \"business extra\",\n      \"business max\",\n      \"advanced\",\n      \"enterprise\",\n    ],\n  },\n);\n\n// PATCH /api/customers/:id \u2013 Update a customer by ID\nexport const PATCH = withWorkspace(\n  async ({ workspace, params, req, searchParams }) => {\n    const { id } = params;\n    const { includeExpandedFields } =\n      getCustomersQuerySchema.parse(searchParams);\n\n    const { name, email, avatar, externalId } = updateCustomerBodySchema.parse(\n      await parseRequestBody(req),\n    );\n\n    const customer = await getCustomerOrThrow(\n      {\n        id,\n        workspaceId: workspace.id,\n      },\n      {\n        includeExpandedFields,\n      },\n    );\n\n    const oldCustomerAvatar = customer.avatar;\n\n    // we need to persist the customer avatar to R2 if:\n    // 1. it's different from the old avatar\n    // 2. it's not stored in R2 already\n    const finalCustomerAvatar =\n      avatar && avatar !== oldCustomerAvatar && !isStored(avatar)\n        ? `${R2_URL}/customers/${customer.id}/avatar_${nanoid(7)}`\n        : avatar;\n\n    try {\n      const updatedCustomer = await prisma.customer.update({\n        where: {\n          id: customer.id,\n        },\n        data: {\n          name,\n          email,\n          avatar: finalCustomerAvatar,\n          externalId,\n        },\n      });\n\n      if (avatar && !isStored(avatar) && finalCustomerAvatar) {\n        waitUntil(\n          Promise.allSettled([\n            storage.upload({\n              key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n              body: avatar,\n              opts: {\n                width: 128,\n                height: 128,\n              },\n            }),\n            oldCustomerAvatar &&\n              isStored(oldCustomerAvatar) &&\n              storage.delete({\n                key: oldCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n              }),\n          ]),\n        );\n      }\n\n      const responseSchema = includeExpandedFields\n        ? CustomerEnrichedSchema\n        : CustomerSchema;\n\n      return NextResponse.json(\n        responseSchema.parse(\n          transformCustomer({\n            ...customer,\n            ...updatedCustomer,\n          }),\n        ),\n      );\n    } catch (error) {\n      if (error.code === \"P2002\") {\n        throw new DubApiError({\n          code: \"conflict\",\n          message: \"A customer with this external ID already exists.\",\n        });\n      }\n\n      throw new DubApiError({\n        code: \"unprocessable_entity\",\n        message: error.message,\n      });\n    }\n  },\n  {\n    requiredPlan: [\n      \"business\",\n      \"business plus\",\n      \"business extra\",\n      \"business max\",\n      \"advanced\",\n      \"enterprise\",\n    ],\n  },\n);\n\n// DELETE /api/customers/:id \u2013 Delete a customer by ID\nexport const DELETE = withWorkspace(\n  async ({ workspace, params }) => {\n    const { id } = params;\n\n    const customer = await getCustomerOrThrow({\n      id,\n      workspaceId: workspace.id,\n    });\n\n    await prisma.customer.delete({\n      where: {\n        id: customer.id,\n      },\n    });\n\n    if (customer.avatar && isStored(customer.avatar)) {\n      storage.delete({ key: customer.avatar.replace(`${R2_URL}/`, \"\") });\n    }\n\n    return NextResponse.json({\n      id: customer.id,\n    });\n  },\n  {\n    requiredPlan: [\n      \"business\",\n      \"business plus\",\n      \"business extra\",\n      \"business max\",\n      \"advanced\",\n      \"enterprise\",\n    ],\n  },\n);",
            "cost": 0.04761
        },
        "dubinc__dub.main/apps/web/app/(ee)/api/customers/route.ts": {
            "output": "import { createId } from \"@/lib/api/create-id\";\nimport { transformCustomer } from \"@/lib/api/customers/transform-customer\";\nimport { DubApiError } from \"@/lib/api/errors\";\nimport { parseRequestBody } from \"@/lib/api/utils\";\nimport { withWorkspace } from \"@/lib/auth\";\nimport { generateRandomName } from \"@/lib/names\";\nimport { isStored, storage } from \"@/lib/storage\";\nimport {\n  createCustomerBodySchema,\n  CustomerEnrichedSchema,\n  CustomerSchema,\n  getCustomersQuerySchemaExtended,\n} from \"@/lib/zod/schemas/customers\";\nimport { DiscountSchemaWithDeprecatedFields } from \"@/lib/zod/schemas/discount\";\nimport { prisma, sanitizeFullTextSearch } from \"@dub/prisma\";\nimport { nanoid, R2_URL } from \"@dub/utils\";\nimport {\n  Customer,\n  Discount,\n  Link,\n  Partner,\n  Program,\n  ProgramEnrollment,\n} from \"@prisma/client\";\nimport { waitUntil } from \"@vercel/functions\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\ninterface CustomerResponse extends Customer {\n  link: Link & {\n    programEnrollment: ProgramEnrollment & {\n      program: Program;\n      partner: Partner;\n      discount: Discount | null;\n    };\n  };\n}\n\n// GET /api/customers \u2013 Get all customers\nexport const GET = withWorkspace(\n  async ({ workspace, searchParams }) => {\n    const {\n      email,\n      externalId,\n      search,\n      country,\n      linkId,\n      includeExpandedFields,\n      page,\n      pageSize,\n      customerIds,\n      sortBy,\n      sortOrder,\n    } = getCustomersQuerySchemaExtended.parse(searchParams);\n\n    const customers = (await prisma.customer.findMany({\n      where: {\n        ...(customerIds\n          ? {\n              id: { in: customerIds },\n            }\n          : {}),\n        projectId: workspace.id,\n        ...(email\n          ? { email }\n          : externalId\n            ? { externalId }\n            : search\n              ? search.includes(\"@\")\n                ? { email: search }\n                : {\n                    email: { search: sanitizeFullTextSearch(search) },\n                    name: { search: sanitizeFullTextSearch(search) },\n                  }\n              : {}),\n        ...(country && {\n          country,\n        }),\n        ...(linkId && {\n          linkId,\n        }),\n      },\n      orderBy: {\n        [sortBy]: sortOrder,\n      },\n      skip: (page - 1) * pageSize,\n      take: pageSize,\n      ...(includeExpandedFields\n        ? {\n            include: {\n              link: {\n                include: {\n                  programEnrollment: {\n                    include: {\n                      partner: {\n                        select: {\n                          id: true,\n                          name: true,\n                          email: true,\n                          image: true,\n                        },\n                      },\n                      discount: true,\n                    },\n                  },\n                },\n              },\n            },\n          }\n        : {}),\n    })) as CustomerResponse[];\n\n    const responseSchema = includeExpandedFields\n      ? CustomerEnrichedSchema.merge(\n          z.object({\n            discount: DiscountSchemaWithDeprecatedFields,\n          }),\n        )\n      : CustomerSchema;\n\n    const response = responseSchema\n      .array()\n      .parse(customers.map(transformCustomer));\n\n    return NextResponse.json(response);\n  },\n  {\n    requiredPlan: [\n      \"business\",\n      \"business plus\",\n      \"business extra\",\n      \"business max\",\n      \"advanced\",\n      \"enterprise\",\n    ],\n  },\n);\n\n// POST /api/customers \u2013 Create a customer\nexport const POST = withWorkspace(\n  async ({ req, workspace }) => {\n    const { email, name, avatar, externalId, stripeCustomerId } =\n      createCustomerBodySchema.parse(await parseRequestBody(req));\n\n    const customerId = createId({ prefix: \"cus_\" });\n    const finalCustomerName = name || email || generateRandomName();\n    const finalCustomerAvatar =\n      avatar && !isStored(avatar)\n        ? `${R2_URL}/customers/${customerId}/avatar_${nanoid(7)}`\n        : avatar;\n\n    try {\n      const customer = await prisma.customer.create({\n        data: {\n          id: customerId,\n          name: finalCustomerName,\n          email,\n          avatar: finalCustomerAvatar,\n          externalId,\n          stripeCustomerId,\n          projectId: workspace.id,\n          projectConnectId: workspace.stripeConnectId,\n        },\n      });\n\n      if (avatar && !isStored(avatar) && finalCustomerAvatar) {\n        waitUntil(\n          storage.upload({\n            key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n            body: avatar,\n            opts: {\n              width: 128,\n              height: 128,\n            },\n          }),\n        );\n      }\n\n      return NextResponse.json(\n        CustomerSchema.parse(transformCustomer(customer)),\n        {\n          status: 201,\n        },\n      );\n    } catch (error) {\n      if (error.code === \"P2002\") {\n        throw new DubApiError({\n          code: \"conflict\",\n          message: \"A customer with this external ID already exists.\",\n        });\n      }\n\n      throw new DubApiError({\n        code: \"unprocessable_entity\",\n        message: error.message,\n      });\n    }\n  },\n  {\n    requiredPlan: [\n      \"business\",\n      \"business plus\",\n      \"business extra\",\n      \"business max\",\n      \"advanced\",\n      \"enterprise\",\n    ],\n  },\n);",
            "output_extracted": "import { createId } from \"@/lib/api/create-id\";\nimport { transformCustomer } from \"@/lib/api/customers/transform-customer\";\nimport { DubApiError } from \"@/lib/api/errors\";\nimport { parseRequestBody } from \"@/lib/api/utils\";\nimport { withWorkspace } from \"@/lib/auth\";\nimport { generateRandomName } from \"@/lib/names\";\nimport { isStored, storage } from \"@/lib/storage\";\nimport {\n  createCustomerBodySchema,\n  CustomerEnrichedSchema,\n  CustomerSchema,\n  getCustomersQuerySchemaExtended,\n} from \"@/lib/zod/schemas/customers\";\nimport { DiscountSchemaWithDeprecatedFields } from \"@/lib/zod/schemas/discount\";\nimport { prisma, sanitizeFullTextSearch } from \"@dub/prisma\";\nimport { nanoid, R2_URL } from \"@dub/utils\";\nimport {\n  Customer,\n  Discount,\n  Link,\n  Partner,\n  Program,\n  ProgramEnrollment,\n} from \"@prisma/client\";\nimport { waitUntil } from \"@vercel/functions\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\ninterface CustomerResponse extends Customer {\n  link: Link & {\n    programEnrollment: ProgramEnrollment & {\n      program: Program;\n      partner: Partner;\n      discount: Discount | null;\n    };\n  };\n}\n\n// GET /api/customers \u2013 Get all customers\nexport const GET = withWorkspace(\n  async ({ workspace, searchParams }) => {\n    const {\n      email,\n      externalId,\n      search,\n      country,\n      linkId,\n      includeExpandedFields,\n      page,\n      pageSize,\n      customerIds,\n      sortBy,\n      sortOrder,\n    } = getCustomersQuerySchemaExtended.parse(searchParams);\n\n    const customers = (await prisma.customer.findMany({\n      where: {\n        ...(customerIds\n          ? {\n              id: { in: customerIds },\n            }\n          : {}),\n        projectId: workspace.id,\n        ...(email\n          ? { email }\n          : externalId\n            ? { externalId }\n            : search\n              ? search.includes(\"@\")\n                ? { email: search }\n                : {\n                    email: { search: sanitizeFullTextSearch(search) },\n                    name: { search: sanitizeFullTextSearch(search) },\n                  }\n              : {}),\n        ...(country && {\n          country,\n        }),\n        ...(linkId && {\n          linkId,\n        }),\n      },\n      orderBy: {\n        [sortBy]: sortOrder,\n      },\n      skip: (page - 1) * pageSize,\n      take: pageSize,\n      ...(includeExpandedFields\n        ? {\n            include: {\n              link: {\n                include: {\n                  programEnrollment: {\n                    include: {\n                      partner: {\n                        select: {\n                          id: true,\n                          name: true,\n                          email: true,\n                          image: true,\n                        },\n                      },\n                      discount: true,\n                    },\n                  },\n                },\n              },\n            },\n          }\n        : {}),\n    })) as CustomerResponse[];\n\n    const responseSchema = includeExpandedFields\n      ? CustomerEnrichedSchema.merge(\n          z.object({\n            discount: DiscountSchemaWithDeprecatedFields,\n          }),\n        )\n      : CustomerSchema;\n\n    const response = responseSchema\n      .array()\n      .parse(customers.map(transformCustomer));\n\n    return NextResponse.json(response);\n  },\n  {\n    requiredPlan: [\n      \"business\",\n      \"business plus\",\n      \"business extra\",\n      \"business max\",\n      \"advanced\",\n      \"enterprise\",\n    ],\n  },\n);\n\n// POST /api/customers \u2013 Create a customer\nexport const POST = withWorkspace(\n  async ({ req, workspace }) => {\n    const { email, name, avatar, externalId, stripeCustomerId } =\n      createCustomerBodySchema.parse(await parseRequestBody(req));\n\n    const customerId = createId({ prefix: \"cus_\" });\n    const finalCustomerName = name || email || generateRandomName();\n    const finalCustomerAvatar =\n      avatar && !isStored(avatar)\n        ? `${R2_URL}/customers/${customerId}/avatar_${nanoid(7)}`\n        : avatar;\n\n    try {\n      const customer = await prisma.customer.create({\n        data: {\n          id: customerId,\n          name: finalCustomerName,\n          email,\n          avatar: finalCustomerAvatar,\n          externalId,\n          stripeCustomerId,\n          projectId: workspace.id,\n          projectConnectId: workspace.stripeConnectId,\n        },\n      });\n\n      if (avatar && !isStored(avatar) && finalCustomerAvatar) {\n        waitUntil(\n          storage.upload({\n            key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n            body: avatar,\n            opts: {\n              width: 128,\n              height: 128,\n            },\n          }),\n        );\n      }\n\n      return NextResponse.json(\n        CustomerSchema.parse(transformCustomer(customer)),\n        {\n          status: 201,\n        },\n      );\n    } catch (error) {\n      if (error.code === \"P2002\") {\n        throw new DubApiError({\n          code: \"conflict\",\n          message: \"A customer with this external ID already exists.\",\n        });\n      }\n\n      throw new DubApiError({\n        code: \"unprocessable_entity\",\n        message: error.message,\n      });\n    }\n  },\n  {\n    requiredPlan: [\n      \"business\",\n      \"business plus\",\n      \"business extra\",\n      \"business max\",\n      \"advanced\",\n      \"enterprise\",\n    ],\n  },\n);",
            "cost": 0.05078
        },
        "dubinc__dub.main/apps/web/lib/api/conversions/track-lead.ts": {
            "output": "import { createId } from \"@/lib/api/create-id\";\nimport { DubApiError } from \"@/lib/api/errors\";\nimport { detectAndRecordFraudEvent } from \"@/lib/api/fraud/detect-record-fraud-event\";\nimport { includeTags } from \"@/lib/api/links/include-tags\";\nimport { generateRandomName } from \"@/lib/names\";\nimport { createPartnerCommission } from \"@/lib/partners/create-partner-commission\";\nimport { isStored, storage } from \"@/lib/storage\";\nimport { getClickEvent, recordLead } from \"@/lib/tinybird\";\nimport { logConversionEvent } from \"@/lib/tinybird/log-conversion-events\";\nimport { WebhookPartner, WorkspaceProps } from \"@/lib/types\";\nimport { redis } from \"@/lib/upstash\";\nimport { sendWorkspaceWebhook } from \"@/lib/webhook/publish\";\nimport { transformLeadEventData } from \"@/lib/webhook/transform\";\nimport {\n  trackLeadRequestSchema,\n  trackLeadResponseSchema,\n} from \"@/lib/zod/schemas/leads\";\nimport { prisma } from \"@dub/prisma\";\nimport { Link, WorkflowTrigger } from \"@dub/prisma/client\";\nimport { nanoid, pick, R2_URL } from \"@dub/utils\";\nimport { waitUntil } from \"@vercel/functions\";\nimport { z } from \"zod\";\nimport { syncPartnerLinksStats } from \"../partners/sync-partner-links-stats\";\nimport { executeWorkflows } from \"../workflows/execute-workflows\";\n\ntype TrackLeadParams = z.input<typeof trackLeadRequestSchema> & {\n  rawBody: any;\n  workspace: Pick<WorkspaceProps, \"id\" | \"stripeConnectId\" | \"webhookEnabled\">;\n};\n\nexport const trackLead = async ({\n  clickId,\n  eventName,\n  customerExternalId,\n  customerName,\n  customerEmail,\n  customerAvatar,\n  mode,\n  eventQuantity,\n  metadata,\n  rawBody,\n  workspace,\n}: TrackLeadParams) => {\n  // try to find the customer to use if it exists\n  let customer = await prisma.customer.findUnique({\n    where: {\n      projectId_externalId: {\n        projectId: workspace.id,\n        externalId: customerExternalId,\n      },\n    },\n  });\n  let link: Link | null = null;\n\n  // if clickId is an empty string, use the existing customer's clickId if it exists\n  // otherwise, throw an error (this is for mode=\"deferred\" lead tracking)\n  if (!clickId) {\n    if (!customer || !customer.clickId) {\n      throw new DubApiError({\n        code: \"bad_request\",\n        message:\n          \"The `clickId` property was not provided in the request, and no existing customer with the provided `customerExternalId` was found.\",\n      });\n    }\n\n    clickId = customer.clickId;\n  }\n\n  const stringifiedEventName = eventName.toLowerCase().replaceAll(\" \", \"-\");\n  const finalCustomerId = createId({ prefix: \"cus_\" });\n  const finalCustomerName =\n    customerName || customerEmail || generateRandomName();\n  const finalCustomerAvatar =\n    customerAvatar && !isStored(customerAvatar)\n      ? `${R2_URL}/customers/${finalCustomerId}/avatar_${nanoid(7)}`\n      : customerAvatar;\n\n  let isDuplicateEvent = false;\n\n  // if not deferred mode, we need to deduplicate lead events \u2013 only record 1 unique event for the same customer and event name\n  // TODO: Maybe we can replace this to rely only on MySQL directly since we're checking the customer above?\n  if (mode !== \"deferred\") {\n    const res = await redis.set(\n      `trackLead:${workspace.id}:${customerExternalId}:${stringifiedEventName}`,\n      {\n        timestamp: Date.now(),\n        clickId,\n        eventName,\n        customerExternalId,\n        customerName,\n        customerEmail,\n        customerAvatar,\n      },\n      {\n        ex: 60 * 60 * 24 * 7, // cache for 1 week\n        nx: true,\n      },\n    );\n    // if res = null it means the key was already set\n    isDuplicateEvent = res === null ? true : false;\n  }\n\n  // if it's not a duplicate event\n  // (e.g. mode === 'deferred' or it's regular mode but the first time processing this event)\n  // we can proceed with the lead tracking process\n  if (!isDuplicateEvent) {\n    // First, we need to find the click event\n    const clickData = await getClickEvent({ clickId });\n\n    // if there is no click data, throw an error\n    if (!clickData) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Click event not found for clickId: ${clickId}`,\n      });\n    }\n\n    // get the referral link from the from the clickData\n    link = await prisma.link.findUnique({\n      where: {\n        id: clickData.link_id,\n      },\n    });\n\n    if (!link) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link not found for clickId: ${clickId}`,\n      });\n    }\n\n    if (link.projectId !== workspace.id) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link ${link.id} for clickId ${clickId} does not belong to the workspace`,\n      });\n    }\n\n    if (link.disabledAt) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link ${link.id} for clickId ${clickId} is disabled, lead not tracked`,\n      });\n    }\n\n    const leadEventId = nanoid(16);\n\n    // Create a function to prepare the lead event payload\n    const createLeadEventPayload = (customerId: string) => {\n      const basePayload = {\n        ...clickData,\n        workspace_id: clickData.workspace_id || workspace.id, // in case for some reason the click event doesn't have workspace_id\n        event_id: leadEventId,\n        event_name: eventName,\n        customer_id: customerId,\n        metadata: metadata ? JSON.stringify(metadata) : \"\",\n      };\n\n      return eventQuantity\n        ? Array(eventQuantity)\n            .fill(null)\n            .map(() => ({\n              ...basePayload,\n              event_id: nanoid(16),\n            }))\n        : basePayload;\n    };\n\n    // if the customer doesn't exist in our MySQL DB yet, upsert it\n    // (here we're doing upsert and not create in case of race conditions)\n    if (!customer) {\n      customer = await prisma.customer.upsert({\n        where: {\n          projectId_externalId: {\n            projectId: workspace.id,\n            externalId: customerExternalId,\n          },\n        },\n        create: {\n          id: finalCustomerId,\n          name: finalCustomerName,\n          email: customerEmail,\n          avatar: finalCustomerAvatar,\n          externalId: customerExternalId,\n          projectId: workspace.id,\n          projectConnectId: workspace.stripeConnectId,\n          clickId: clickData.click_id,\n          linkId: clickData.link_id,\n          country: clickData.country,\n          clickedAt: new Date(clickData.timestamp + \"Z\"),\n        },\n        update: {},\n      });\n    }\n\n    // if wait mode, record the lead event synchronously\n    if (mode === \"wait\") {\n      const leadEventPayload = createLeadEventPayload(customer.id);\n      const cacheLeadEventPayload = Array.isArray(leadEventPayload)\n        ? leadEventPayload[0]\n        : leadEventPayload;\n\n      await Promise.all([\n        // Cache the latest lead event for 5 minutes because the ingested event is not available immediately on Tinybird\n        // we're setting two keys because we want to support the use case where the customer has multiple lead events\n        redis.set(`leadCache:${customer.id}`, cacheLeadEventPayload, {\n          ex: 60 * 5,\n        }),\n\n        redis.set(\n          `leadCache:${customer.id}:${stringifiedEventName}`,\n          cacheLeadEventPayload,\n          {\n            ex: 60 * 5,\n          },\n        ),\n      ]);\n    }\n\n    waitUntil(\n      (async () => {\n        // for deferred mode, we defer the lead event creation to a subsequent request\n        if (mode !== \"deferred\") {\n          await recordLead(createLeadEventPayload(customer.id));\n        }\n\n        // track the conversion event in our logs\n        await logConversionEvent({\n          workspace_id: workspace.id,\n          link_id: clickData.link_id,\n          path: \"/track/lead\",\n          body: JSON.stringify(rawBody),\n        });\n\n        if (\n          customerAvatar &&\n          !isStored(customerAvatar) &&\n          finalCustomerAvatar\n        ) {\n          // persist customer avatar to R2\n          await storage.upload({\n            key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n            body: customerAvatar,\n            opts: {\n              width: 128,\n              height: 128,\n            },\n          });\n        }\n\n        // if not deferred mode, process the following right away:\n        // - update link, workspace, and customer stats\n        // - for partner links, create partner commission and execute workflows\n        // - send lead.created webhook\n\n        if (mode !== \"deferred\") {\n          const [updatedLink, _project] = await Promise.all([\n            // update link leads count\n            prisma.link.update({\n              where: {\n                id: clickData.link_id,\n              },\n              data: {\n                leads: {\n                  increment: eventQuantity ?? 1,\n                },\n                lastLeadAt: new Date(),\n              },\n              include: includeTags,\n            }),\n\n            // update workspace events usage\n            prisma.project.update({\n              where: {\n                id: workspace.id,\n              },\n              data: {\n                usage: {\n                  increment: eventQuantity ?? 1,\n                },\n              },\n            }),\n          ]);\n          link = updatedLink; // update the link variable to the latest version\n\n          let webhookPartner: WebhookPartner | undefined;\n\n          if (link.programId && link.partnerId && customer) {\n            const createdCommission = await createPartnerCommission({\n              event: \"lead\",\n              programId: link.programId,\n              partnerId: link.partnerId,\n              linkId: link.id,\n              eventId: leadEventId,\n              customerId: customer.id,\n              quantity: eventQuantity ?? 1,\n              context: {\n                customer: {\n                  country: customer.country,\n                },\n              },\n            });\n\n            webhookPartner = createdCommission?.webhookPartner;\n\n            await Promise.allSettled([\n              executeWorkflows({\n                trigger: WorkflowTrigger.leadRecorded,\n                context: {\n                  programId: link.programId,\n                  partnerId: link.partnerId,\n                  current: {\n                    leads: 1,\n                  },\n                },\n              }),\n\n              syncPartnerLinksStats({\n                partnerId: link.partnerId,\n                programId: link.programId,\n                eventType: \"lead\",\n              }),\n\n              webhookPartner &&\n                detectAndRecordFraudEvent({\n                  program: { id: link.programId },\n                  partner: pick(webhookPartner, [\"id\", \"email\", \"name\"]),\n                  customer: pick(customer, [\"id\", \"email\", \"name\"]),\n                  commission: { id: createdCommission.commission?.id },\n                  link: pick(link, [\"id\"]),\n                  click: pick(clickData, [\"url\", \"referer\"]),\n                  event: { id: leadEventId },\n                }),\n            ]);\n          }\n\n          await sendWorkspaceWebhook({\n            trigger: \"lead.created\",\n            data: transformLeadEventData({\n              ...clickData,\n              eventName,\n              link,\n              customer,\n              partner: webhookPartner,\n              metadata,\n            }),\n            workspace,\n          });\n        }\n      })(),\n    );\n  }\n\n  return trackLeadResponseSchema.parse({\n    click: {\n      id: clickId,\n    },\n    link,\n    customer: customer ?? {\n      name: finalCustomerName,\n      email: customerEmail || null,\n      avatar: finalCustomerAvatar || null,\n      externalId: customerExternalId,\n    },\n  });\n};",
            "output_extracted": "import { createId } from \"@/lib/api/create-id\";\nimport { DubApiError } from \"@/lib/api/errors\";\nimport { detectAndRecordFraudEvent } from \"@/lib/api/fraud/detect-record-fraud-event\";\nimport { includeTags } from \"@/lib/api/links/include-tags\";\nimport { generateRandomName } from \"@/lib/names\";\nimport { createPartnerCommission } from \"@/lib/partners/create-partner-commission\";\nimport { isStored, storage } from \"@/lib/storage\";\nimport { getClickEvent, recordLead } from \"@/lib/tinybird\";\nimport { logConversionEvent } from \"@/lib/tinybird/log-conversion-events\";\nimport { WebhookPartner, WorkspaceProps } from \"@/lib/types\";\nimport { redis } from \"@/lib/upstash\";\nimport { sendWorkspaceWebhook } from \"@/lib/webhook/publish\";\nimport { transformLeadEventData } from \"@/lib/webhook/transform\";\nimport {\n  trackLeadRequestSchema,\n  trackLeadResponseSchema,\n} from \"@/lib/zod/schemas/leads\";\nimport { prisma } from \"@dub/prisma\";\nimport { Link, WorkflowTrigger } from \"@dub/prisma/client\";\nimport { nanoid, pick, R2_URL } from \"@dub/utils\";\nimport { waitUntil } from \"@vercel/functions\";\nimport { z } from \"zod\";\nimport { syncPartnerLinksStats } from \"../partners/sync-partner-links-stats\";\nimport { executeWorkflows } from \"../workflows/execute-workflows\";\n\ntype TrackLeadParams = z.input<typeof trackLeadRequestSchema> & {\n  rawBody: any;\n  workspace: Pick<WorkspaceProps, \"id\" | \"stripeConnectId\" | \"webhookEnabled\">;\n};\n\nexport const trackLead = async ({\n  clickId,\n  eventName,\n  customerExternalId,\n  customerName,\n  customerEmail,\n  customerAvatar,\n  mode,\n  eventQuantity,\n  metadata,\n  rawBody,\n  workspace,\n}: TrackLeadParams) => {\n  // try to find the customer to use if it exists\n  let customer = await prisma.customer.findUnique({\n    where: {\n      projectId_externalId: {\n        projectId: workspace.id,\n        externalId: customerExternalId,\n      },\n    },\n  });\n  let link: Link | null = null;\n\n  // if clickId is an empty string, use the existing customer's clickId if it exists\n  // otherwise, throw an error (this is for mode=\"deferred\" lead tracking)\n  if (!clickId) {\n    if (!customer || !customer.clickId) {\n      throw new DubApiError({\n        code: \"bad_request\",\n        message:\n          \"The `clickId` property was not provided in the request, and no existing customer with the provided `customerExternalId` was found.\",\n      });\n    }\n\n    clickId = customer.clickId;\n  }\n\n  const stringifiedEventName = eventName.toLowerCase().replaceAll(\" \", \"-\");\n  const finalCustomerId = createId({ prefix: \"cus_\" });\n  const finalCustomerName =\n    customerName || customerEmail || generateRandomName();\n  const finalCustomerAvatar =\n    customerAvatar && !isStored(customerAvatar)\n      ? `${R2_URL}/customers/${finalCustomerId}/avatar_${nanoid(7)}`\n      : customerAvatar;\n\n  let isDuplicateEvent = false;\n\n  // if not deferred mode, we need to deduplicate lead events \u2013 only record 1 unique event for the same customer and event name\n  // TODO: Maybe we can replace this to rely only on MySQL directly since we're checking the customer above?\n  if (mode !== \"deferred\") {\n    const res = await redis.set(\n      `trackLead:${workspace.id}:${customerExternalId}:${stringifiedEventName}`,\n      {\n        timestamp: Date.now(),\n        clickId,\n        eventName,\n        customerExternalId,\n        customerName,\n        customerEmail,\n        customerAvatar,\n      },\n      {\n        ex: 60 * 60 * 24 * 7, // cache for 1 week\n        nx: true,\n      },\n    );\n    // if res = null it means the key was already set\n    isDuplicateEvent = res === null ? true : false;\n  }\n\n  // if it's not a duplicate event\n  // (e.g. mode === 'deferred' or it's regular mode but the first time processing this event)\n  // we can proceed with the lead tracking process\n  if (!isDuplicateEvent) {\n    // First, we need to find the click event\n    const clickData = await getClickEvent({ clickId });\n\n    // if there is no click data, throw an error\n    if (!clickData) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Click event not found for clickId: ${clickId}`,\n      });\n    }\n\n    // get the referral link from the from the clickData\n    link = await prisma.link.findUnique({\n      where: {\n        id: clickData.link_id,\n      },\n    });\n\n    if (!link) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link not found for clickId: ${clickId}`,\n      });\n    }\n\n    if (link.projectId !== workspace.id) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link ${link.id} for clickId ${clickId} does not belong to the workspace`,\n      });\n    }\n\n    if (link.disabledAt) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link ${link.id} for clickId ${clickId} is disabled, lead not tracked`,\n      });\n    }\n\n    const leadEventId = nanoid(16);\n\n    // Create a function to prepare the lead event payload\n    const createLeadEventPayload = (customerId: string) => {\n      const basePayload = {\n        ...clickData,\n        workspace_id: clickData.workspace_id || workspace.id, // in case for some reason the click event doesn't have workspace_id\n        event_id: leadEventId,\n        event_name: eventName,\n        customer_id: customerId,\n        metadata: metadata ? JSON.stringify(metadata) : \"\",\n      };\n\n      return eventQuantity\n        ? Array(eventQuantity)\n            .fill(null)\n            .map(() => ({\n              ...basePayload,\n              event_id: nanoid(16),\n            }))\n        : basePayload;\n    };\n\n    // if the customer doesn't exist in our MySQL DB yet, upsert it\n    // (here we're doing upsert and not create in case of race conditions)\n    if (!customer) {\n      customer = await prisma.customer.upsert({\n        where: {\n          projectId_externalId: {\n            projectId: workspace.id,\n            externalId: customerExternalId,\n          },\n        },\n        create: {\n          id: finalCustomerId,\n          name: finalCustomerName,\n          email: customerEmail,\n          avatar: finalCustomerAvatar,\n          externalId: customerExternalId,\n          projectId: workspace.id,\n          projectConnectId: workspace.stripeConnectId,\n          clickId: clickData.click_id,\n          linkId: clickData.link_id,\n          country: clickData.country,\n          clickedAt: new Date(clickData.timestamp + \"Z\"),\n        },\n        update: {},\n      });\n    }\n\n    // if wait mode, record the lead event synchronously\n    if (mode === \"wait\") {\n      const leadEventPayload = createLeadEventPayload(customer.id);\n      const cacheLeadEventPayload = Array.isArray(leadEventPayload)\n        ? leadEventPayload[0]\n        : leadEventPayload;\n\n      await Promise.all([\n        // Cache the latest lead event for 5 minutes because the ingested event is not available immediately on Tinybird\n        // we're setting two keys because we want to support the use case where the customer has multiple lead events\n        redis.set(`leadCache:${customer.id}`, cacheLeadEventPayload, {\n          ex: 60 * 5,\n        }),\n\n        redis.set(\n          `leadCache:${customer.id}:${stringifiedEventName}`,\n          cacheLeadEventPayload,\n          {\n            ex: 60 * 5,\n          },\n        ),\n      ]);\n    }\n\n    waitUntil(\n      (async () => {\n        // for deferred mode, we defer the lead event creation to a subsequent request\n        if (mode !== \"deferred\") {\n          await recordLead(createLeadEventPayload(customer.id));\n        }\n\n        // track the conversion event in our logs\n        await logConversionEvent({\n          workspace_id: workspace.id,\n          link_id: clickData.link_id,\n          path: \"/track/lead\",\n          body: JSON.stringify(rawBody),\n        });\n\n        if (\n          customerAvatar &&\n          !isStored(customerAvatar) &&\n          finalCustomerAvatar\n        ) {\n          // persist customer avatar to R2\n          await storage.upload({\n            key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n            body: customerAvatar,\n            opts: {\n              width: 128,\n              height: 128,\n            },\n          });\n        }\n\n        // if not deferred mode, process the following right away:\n        // - update link, workspace, and customer stats\n        // - for partner links, create partner commission and execute workflows\n        // - send lead.created webhook\n\n        if (mode !== \"deferred\") {\n          const [updatedLink, _project] = await Promise.all([\n            // update link leads count\n            prisma.link.update({\n              where: {\n                id: clickData.link_id,\n              },\n              data: {\n                leads: {\n                  increment: eventQuantity ?? 1,\n                },\n                lastLeadAt: new Date(),\n              },\n              include: includeTags,\n            }),\n\n            // update workspace events usage\n            prisma.project.update({\n              where: {\n                id: workspace.id,\n              },\n              data: {\n                usage: {\n                  increment: eventQuantity ?? 1,\n                },\n              },\n            }),\n          ]);\n          link = updatedLink; // update the link variable to the latest version\n\n          let webhookPartner: WebhookPartner | undefined;\n\n          if (link.programId && link.partnerId && customer) {\n            const createdCommission = await createPartnerCommission({\n              event: \"lead\",\n              programId: link.programId,\n              partnerId: link.partnerId,\n              linkId: link.id,\n              eventId: leadEventId,\n              customerId: customer.id,\n              quantity: eventQuantity ?? 1,\n              context: {\n                customer: {\n                  country: customer.country,\n                },\n              },\n            });\n\n            webhookPartner = createdCommission?.webhookPartner;\n\n            await Promise.allSettled([\n              executeWorkflows({\n                trigger: WorkflowTrigger.leadRecorded,\n                context: {\n                  programId: link.programId,\n                  partnerId: link.partnerId,\n                  current: {\n                    leads: 1,\n                  },\n                },\n              }),\n\n              syncPartnerLinksStats({\n                partnerId: link.partnerId,\n                programId: link.programId,\n                eventType: \"lead\",\n              }),\n\n              webhookPartner &&\n                detectAndRecordFraudEvent({\n                  program: { id: link.programId },\n                  partner: pick(webhookPartner, [\"id\", \"email\", \"name\"]),\n                  customer: pick(customer, [\"id\", \"email\", \"name\"]),\n                  commission: { id: createdCommission.commission?.id },\n                  link: pick(link, [\"id\"]),\n                  click: pick(clickData, [\"url\", \"referer\"]),\n                  event: { id: leadEventId },\n                }),\n            ]);\n          }\n\n          await sendWorkspaceWebhook({\n            trigger: \"lead.created\",\n            data: transformLeadEventData({\n              ...clickData,\n              eventName,\n              link,\n              customer,\n              partner: webhookPartner,\n              metadata,\n            }),\n            workspace,\n          });\n        }\n      })(),\n    );\n  }\n\n  return trackLeadResponseSchema.parse({\n    click: {\n      id: clickId,\n    },\n    link,\n    customer: customer ?? {\n      name: finalCustomerName,\n      email: customerEmail || null,\n      avatar: finalCustomerAvatar || null,\n      externalId: customerExternalId,\n    },\n  });\n};",
            "cost": 0.10282000000000001
        },
        "dubinc__dub.main/apps/web/lib/api/conversions/track-sale.ts": {
            "output": "import { convertCurrency } from \"@/lib/analytics/convert-currency\";\nimport { isFirstConversion } from \"@/lib/analytics/is-first-conversion\";\nimport { DubApiError } from \"@/lib/api/errors\";\nimport { detectAndRecordFraudEvent } from \"@/lib/api/fraud/detect-record-fraud-event\";\nimport { includeTags } from \"@/lib/api/links/include-tags\";\nimport { generateRandomName } from \"@/lib/names\";\nimport { createPartnerCommission } from \"@/lib/partners/create-partner-commission\";\nimport { isStored, storage } from \"@/lib/storage\";\nimport {\n  getClickEvent,\n  getLeadEvent,\n  recordLead,\n  recordSale,\n} from \"@/lib/tinybird\";\nimport { logConversionEvent } from \"@/lib/tinybird/log-conversion-events\";\nimport { LeadEventTB, WebhookPartner, WorkspaceProps } from \"@/lib/types\";\nimport { redis } from \"@/lib/upstash\";\nimport { sendWorkspaceWebhook } from \"@/lib/webhook/publish\";\nimport {\n  transformLeadEventData,\n  transformSaleEventData,\n} from \"@/lib/webhook/transform\";\nimport {\n  trackSaleRequestSchema,\n  trackSaleResponseSchema,\n} from \"@/lib/zod/schemas/sales\";\nimport { prisma } from \"@dub/prisma\";\nimport { Customer, WorkflowTrigger } from \"@dub/prisma/client\";\nimport { nanoid, pick, R2_URL } from \"@dub/utils\";\nimport { waitUntil } from \"@vercel/functions\";\nimport { z } from \"zod\";\nimport { createId } from \"../create-id\";\nimport { syncPartnerLinksStats } from \"../partners/sync-partner-links-stats\";\nimport { executeWorkflows } from \"../workflows/execute-workflows\";\ntype TrackSaleParams = z.input<typeof trackSaleRequestSchema> & {\n  rawBody: any;\n  workspace: Pick<WorkspaceProps, \"id\" | \"stripeConnectId\" | \"webhookEnabled\">;\n};\n\nexport const trackSale = async ({\n  clickId,\n  customerExternalId,\n  customerName,\n  customerEmail,\n  customerAvatar,\n  amount,\n  currency = \"usd\",\n  eventName,\n  paymentProcessor,\n  invoiceId,\n  leadEventName,\n  metadata,\n  rawBody,\n  workspace,\n}: TrackSaleParams) => {\n  let existingCustomer: Customer | null = null;\n  let newCustomer: Customer | null = null;\n  let leadEventData: LeadEventTB | null = null;\n\n  // Return idempotent response if invoiceId is already processed\n  if (invoiceId) {\n    const cachedResponse = await redis.get(\n      `trackSale:${workspace.id}:invoiceId:${invoiceId}`,\n    );\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n  }\n\n  // Find existing customer\n  existingCustomer = await prisma.customer.findUnique({\n    where: {\n      projectId_externalId: {\n        projectId: workspace.id,\n        externalId: customerExternalId,\n      },\n    },\n  });\n\n  // Existing customer is found, find the lead event to associate the sale with\n  if (existingCustomer) {\n    const leadEvent = await getLeadEvent({\n      customerId: existingCustomer.id,\n      eventName: leadEventName,\n    });\n\n    if (!leadEvent || leadEvent.data.length === 0) {\n      // Check cache to see if the lead event exists\n      // if leadEventName is provided, we only check for that specific event\n      // otherwise, we check for all cached lead events for that customer\n\n      const cachedLeadEvent = await redis.get<LeadEventTB>(\n        `leadCache:${existingCustomer.id}${leadEventName ? `:${leadEventName.toLowerCase().replaceAll(\" \", \"-\")}` : \"\"}`,\n      );\n\n      if (!cachedLeadEvent) {\n        const errorMessage = `Lead event not found for externalId: ${customerExternalId} and leadEventName: ${leadEventName}`;\n\n        waitUntil(\n          logConversionEvent({\n            workspace_id: workspace.id,\n            path: \"/track/sale\",\n            body: JSON.stringify(rawBody),\n            error: errorMessage,\n          }),\n        );\n\n        throw new DubApiError({\n          code: \"not_found\",\n          message: errorMessage,\n        });\n      }\n\n      leadEventData = {\n        ...cachedLeadEvent,\n        workspace_id: cachedLeadEvent.workspace_id || workspace.id, // in case for some reason the lead event doesn't have workspace_id\n      };\n    } else {\n      leadEventData = {\n        ...leadEvent.data[0],\n        workspace_id: leadEvent.data[0].workspace_id || workspace.id, // in case for some reason the lead event doesn't have workspace_id\n      };\n    }\n  }\n\n  // No existing customer is found, find the click event and create a new customer (for direct sale tracking)\n  else {\n    if (!clickId) {\n      waitUntil(\n        logConversionEvent({\n          workspace_id: workspace.id,\n          path: \"/track/sale\",\n          body: JSON.stringify(rawBody),\n          error: `No existing customer with the provided customerExternalId (${customerExternalId}) was found, and there was no clickId provided for direct sale tracking.`,\n        }),\n      );\n\n      return {\n        eventName,\n        customer: null,\n        sale: null,\n      };\n    }\n\n    // Find the click event for the given clickId\n    const clickData = await getClickEvent({\n      clickId,\n    });\n\n    if (!clickData) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Click event not found for clickId: ${clickId}`,\n      });\n    }\n\n    // Create a new customer\n    const link = await prisma.link.findUnique({\n      where: {\n        id: clickData.link_id,\n      },\n      select: {\n        id: true,\n        projectId: true,\n        disabledAt: true,\n      },\n    });\n\n    if (!link) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link not found for clickId: ${clickData.click_id}`,\n      });\n    }\n\n    if (link.projectId !== workspace.id) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link ${link.id} for clickId ${clickData.click_id} does not belong to the workspace`,\n      });\n    }\n\n    if (link.disabledAt) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link ${link.id} for clickId ${clickData.click_id} is disabled, sale not tracked`,\n      });\n    }\n\n    const finalCustomerId = createId({ prefix: \"cus_\" });\n    const finalCustomerName =\n      customerName || customerEmail || generateRandomName();\n    const finalCustomerAvatar =\n      customerAvatar && !isStored(customerAvatar)\n        ? `${R2_URL}/customers/${finalCustomerId}/avatar_${nanoid(7)}`\n        : customerAvatar;\n\n    newCustomer = await prisma.customer.create({\n      data: {\n        id: finalCustomerId,\n        name: finalCustomerName,\n        email: customerEmail,\n        avatar: finalCustomerAvatar,\n        externalId: customerExternalId,\n        linkId: clickData.link_id,\n        clickId: clickData.click_id,\n        country: clickData.country,\n        projectId: workspace.id,\n        projectConnectId: workspace.stripeConnectId,\n        clickedAt: new Date(clickData.timestamp + \"Z\"),\n      },\n    });\n\n    if (customerAvatar && !isStored(customerAvatar) && finalCustomerAvatar) {\n      // persist customer avatar to R2 if it's not already stored\n      waitUntil(\n        storage.upload({\n          key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n          body: customerAvatar,\n          opts: {\n            width: 128,\n            height: 128,\n          },\n        }),\n      );\n    }\n\n    leadEventData = {\n      ...clickData,\n      event_id: nanoid(16),\n      // if leadEventName is provided, use it, otherwise use \"Sign up\"\n      event_name: leadEventName ?? \"Sign up\",\n      customer_id: newCustomer.id,\n      metadata: metadata ? JSON.stringify(metadata) : \"\",\n    };\n  }\n\n  const customer = existingCustomer ?? newCustomer;\n\n  // This should never happen, but just in case\n  if (!customer) {\n    waitUntil(\n      logConversionEvent({\n        workspace_id: workspace.id,\n        path: \"/track/sale\",\n        body: JSON.stringify(rawBody),\n        error: `Customer not found for customerExternalId: ${customerExternalId}`,\n      }),\n    );\n\n    return {\n      eventName,\n      customer: null,\n      sale: null,\n    };\n  }\n\n  const [_, trackedSale] = await Promise.all([\n    newCustomer &&\n      _trackLead({\n        workspace,\n        leadEventData,\n        customer: newCustomer,\n      }),\n\n    _trackSale({\n      amount,\n      currency,\n      eventName,\n      paymentProcessor,\n      invoiceId,\n      metadata,\n      rawBody,\n      workspace,\n      leadEventData,\n      customer,\n    }),\n  ]);\n\n  return trackedSale;\n};\n\n// Track the lead event\nconst _trackLead = async ({\n  workspace,\n  leadEventData,\n  customer,\n}: Pick<TrackSaleParams, \"workspace\"> & {\n  leadEventData: LeadEventTB | null;\n  customer: Customer;\n}) => {\n  if (!leadEventData) {\n    throw new DubApiError({\n      code: \"not_found\",\n      message: `Lead event data not found for the customer ${customer.id}`,\n    });\n  }\n\n  waitUntil(\n    (async () => {\n      const [_leadEvent, link, _workspace] = await Promise.all([\n        // Record the lead event for the customer\n        recordLead({\n          ...leadEventData,\n          workspace_id: leadEventData.workspace_id || workspace.id, // in case for some reason the lead event doesn't have workspace_id\n        }),\n\n        // Update link leads count + lastLeadAt date\n        prisma.link.update({\n          where: {\n            id: leadEventData.link_id,\n          },\n          data: {\n            leads: {\n              increment: 1,\n            },\n            lastLeadAt: new Date(),\n          },\n          include: includeTags,\n        }),\n\n        // Update workspace events usage\n        prisma.project.update({\n          where: {\n            id: workspace.id,\n          },\n          data: {\n            usage: {\n              increment: 1,\n            },\n          },\n        }),\n      ]);\n\n      // Create partner commission and execute workflows\n      if (link.programId && link.partnerId && customer) {\n        const { commission, webhookPartner } = await createPartnerCommission({\n          event: \"lead\",\n          programId: link.programId,\n          partnerId: link.partnerId,\n          linkId: link.id,\n          eventId: leadEventData.event_id,\n          customerId: customer.id,\n          quantity: 1,\n          context: {\n            customer: {\n              country: customer.country,\n            },\n          },\n        });\n\n        await Promise.allSettled([\n          executeWorkflows({\n            trigger: WorkflowTrigger.leadRecorded,\n            context: {\n              programId: link.programId,\n              partnerId: link.partnerId,\n              current: {\n                leads: 1,\n              },\n            },\n          }),\n\n          syncPartnerLinksStats({\n            partnerId: link.partnerId,\n            programId: link.programId,\n            eventType: \"lead\",\n          }),\n\n          webhookPartner &&\n            detectAndRecordFraudEvent({\n              program: { id: link.programId },\n              partner: pick(webhookPartner, [\"id\", \"email\", \"name\"]),\n              customer: pick(customer, [\"id\", \"email\", \"name\"]),\n              commission: { id: commission?.id },\n              link: pick(link, [\"id\"]),\n              click: pick(leadEventData, [\"url\", \"referer\"]),\n              event: { id: leadEventData.event_id },\n            }),\n        ]);\n      }\n\n      // Send workspace webhook\n      const webhookPayload = transformLeadEventData({\n        ...leadEventData,\n        link,\n        customer,\n      });\n\n      await sendWorkspaceWebhook({\n        trigger: \"lead.created\",\n        data: webhookPayload,\n        workspace,\n      });\n    })(),\n  );\n};\n\n// Track the sale event\nconst _trackSale = async ({\n  amount,\n  currency = \"usd\",\n  eventName,\n  paymentProcessor,\n  invoiceId,\n  metadata,\n  rawBody,\n  workspace,\n  leadEventData,\n  customer,\n}: Omit<TrackSaleParams, \"customerExternalId\"> & {\n  leadEventData: LeadEventTB | null;\n  customer: Customer;\n}) => {\n  if (!leadEventData) {\n    throw new DubApiError({\n      code: \"not_found\",\n      message: `Lead event data not found for the customer ${customer.id}`,\n    });\n  }\n\n  // Skip if amount is 0 or less\n  if (amount <= 0) {\n    waitUntil(\n      logConversionEvent({\n        workspace_id: workspace.id,\n        path: \"/track/sale\",\n        body: JSON.stringify(rawBody),\n        error: `Sale amount is ${amount}, skipping...`,\n      }),\n    );\n\n    return {\n      eventName,\n      customer: null,\n      sale: null,\n    };\n  }\n\n  // if currency is not USD, convert it to USD based on the current FX rate\n  // TODO: allow custom \"defaultCurrency\" on workspace table in the future\n  if (currency !== \"usd\") {\n    const { currency: convertedCurrency, amount: convertedAmount } =\n      await convertCurrency({\n        currency,\n        amount,\n      });\n\n    currency = convertedCurrency;\n    amount = convertedAmount;\n  }\n\n  const saleData = {\n    ...leadEventData,\n    workspace_id: leadEventData.workspace_id || workspace.id, // in case for some reason the lead event doesn't have workspace_id\n    event_id: nanoid(16),\n    event_name: eventName,\n    customer_id: customer.id,\n    payment_processor: paymentProcessor,\n    amount,\n    currency,\n    invoice_id: invoiceId || \"\",\n    metadata: metadata ? JSON.stringify(metadata) : \"\",\n    timestamp: undefined,\n  };\n\n  const firstConversionFlag = isFirstConversion({\n    customer,\n    linkId: saleData.link_id,\n  });\n\n  waitUntil(\n    (async () => {\n      const [_sale, link] = await Promise.all([\n        // Record sale event\n        recordSale(saleData),\n\n        // Update link conversions, sales, and saleAmount\n        prisma.link.update({\n          where: {\n            id: saleData.link_id,\n          },\n          data: {\n            ...(firstConversionFlag && {\n              conversions: {\n                increment: 1,\n              },\n              lastConversionAt: new Date(),\n            }),\n            sales: {\n              increment: 1,\n            },\n            saleAmount: {\n              increment: amount,\n            },\n          },\n          include: includeTags,\n        }),\n\n        // Update workspace events usage\n        prisma.project.update({\n          where: {\n            id: workspace.id,\n          },\n          data: {\n            usage: {\n              increment: 1,\n            },\n          },\n        }),\n\n        // Update customer sales count\n        prisma.customer.update({\n          where: {\n            id: customer.",
            "output_extracted": "import { convertCurrency } from \"@/lib/analytics/convert-currency\";\nimport { isFirstConversion } from \"@/lib/analytics/is-first-conversion\";\nimport { DubApiError } from \"@/lib/api/errors\";\nimport { detectAndRecordFraudEvent } from \"@/lib/api/fraud/detect-record-fraud-event\";\nimport { includeTags } from \"@/lib/api/links/include-tags\";\nimport { generateRandomName } from \"@/lib/names\";\nimport { createPartnerCommission } from \"@/lib/partners/create-partner-commission\";\nimport { isStored, storage } from \"@/lib/storage\";\nimport {\n  getClickEvent,\n  getLeadEvent,\n  recordLead,\n  recordSale,\n} from \"@/lib/tinybird\";\nimport { logConversionEvent } from \"@/lib/tinybird/log-conversion-events\";\nimport { LeadEventTB, WebhookPartner, WorkspaceProps } from \"@/lib/types\";\nimport { redis } from \"@/lib/upstash\";\nimport { sendWorkspaceWebhook } from \"@/lib/webhook/publish\";\nimport {\n  transformLeadEventData,\n  transformSaleEventData,\n} from \"@/lib/webhook/transform\";\nimport {\n  trackSaleRequestSchema,\n  trackSaleResponseSchema,\n} from \"@/lib/zod/schemas/sales\";\nimport { prisma } from \"@dub/prisma\";\nimport { Customer, WorkflowTrigger } from \"@dub/prisma/client\";\nimport { nanoid, pick, R2_URL } from \"@dub/utils\";\nimport { waitUntil } from \"@vercel/functions\";\nimport { z } from \"zod\";\nimport { createId } from \"../create-id\";\nimport { syncPartnerLinksStats } from \"../partners/sync-partner-links-stats\";\nimport { executeWorkflows } from \"../workflows/execute-workflows\";\ntype TrackSaleParams = z.input<typeof trackSaleRequestSchema> & {\n  rawBody: any;\n  workspace: Pick<WorkspaceProps, \"id\" | \"stripeConnectId\" | \"webhookEnabled\">;\n};\n\nexport const trackSale = async ({\n  clickId,\n  customerExternalId,\n  customerName,\n  customerEmail,\n  customerAvatar,\n  amount,\n  currency = \"usd\",\n  eventName,\n  paymentProcessor,\n  invoiceId,\n  leadEventName,\n  metadata,\n  rawBody,\n  workspace,\n}: TrackSaleParams) => {\n  let existingCustomer: Customer | null = null;\n  let newCustomer: Customer | null = null;\n  let leadEventData: LeadEventTB | null = null;\n\n  // Return idempotent response if invoiceId is already processed\n  if (invoiceId) {\n    const cachedResponse = await redis.get(\n      `trackSale:${workspace.id}:invoiceId:${invoiceId}`,\n    );\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n  }\n\n  // Find existing customer\n  existingCustomer = await prisma.customer.findUnique({\n    where: {\n      projectId_externalId: {\n        projectId: workspace.id,\n        externalId: customerExternalId,\n      },\n    },\n  });\n\n  // Existing customer is found, find the lead event to associate the sale with\n  if (existingCustomer) {\n    const leadEvent = await getLeadEvent({\n      customerId: existingCustomer.id,\n      eventName: leadEventName,\n    });\n\n    if (!leadEvent || leadEvent.data.length === 0) {\n      // Check cache to see if the lead event exists\n      // if leadEventName is provided, we only check for that specific event\n      // otherwise, we check for all cached lead events for that customer\n\n      const cachedLeadEvent = await redis.get<LeadEventTB>(\n        `leadCache:${existingCustomer.id}${leadEventName ? `:${leadEventName.toLowerCase().replaceAll(\" \", \"-\")}` : \"\"}`,\n      );\n\n      if (!cachedLeadEvent) {\n        const errorMessage = `Lead event not found for externalId: ${customerExternalId} and leadEventName: ${leadEventName}`;\n\n        waitUntil(\n          logConversionEvent({\n            workspace_id: workspace.id,\n            path: \"/track/sale\",\n            body: JSON.stringify(rawBody),\n            error: errorMessage,\n          }),\n        );\n\n        throw new DubApiError({\n          code: \"not_found\",\n          message: errorMessage,\n        });\n      }\n\n      leadEventData = {\n        ...cachedLeadEvent,\n        workspace_id: cachedLeadEvent.workspace_id || workspace.id, // in case for some reason the lead event doesn't have workspace_id\n      };\n    } else {\n      leadEventData = {\n        ...leadEvent.data[0],\n        workspace_id: leadEvent.data[0].workspace_id || workspace.id, // in case for some reason the lead event doesn't have workspace_id\n      };\n    }\n  }\n\n  // No existing customer is found, find the click event and create a new customer (for direct sale tracking)\n  else {\n    if (!clickId) {\n      waitUntil(\n        logConversionEvent({\n          workspace_id: workspace.id,\n          path: \"/track/sale\",\n          body: JSON.stringify(rawBody),\n          error: `No existing customer with the provided customerExternalId (${customerExternalId}) was found, and there was no clickId provided for direct sale tracking.`,\n        }),\n      );\n\n      return {\n        eventName,\n        customer: null,\n        sale: null,\n      };\n    }\n\n    // Find the click event for the given clickId\n    const clickData = await getClickEvent({\n      clickId,\n    });\n\n    if (!clickData) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Click event not found for clickId: ${clickId}`,\n      });\n    }\n\n    // Create a new customer\n    const link = await prisma.link.findUnique({\n      where: {\n        id: clickData.link_id,\n      },\n      select: {\n        id: true,\n        projectId: true,\n        disabledAt: true,\n      },\n    });\n\n    if (!link) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link not found for clickId: ${clickData.click_id}`,\n      });\n    }\n\n    if (link.projectId !== workspace.id) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link ${link.id} for clickId ${clickData.click_id} does not belong to the workspace`,\n      });\n    }\n\n    if (link.disabledAt) {\n      throw new DubApiError({\n        code: \"not_found\",\n        message: `Link ${link.id} for clickId ${clickData.click_id} is disabled, sale not tracked`,\n      });\n    }\n\n    const finalCustomerId = createId({ prefix: \"cus_\" });\n    const finalCustomerName =\n      customerName || customerEmail || generateRandomName();\n    const finalCustomerAvatar =\n      customerAvatar && !isStored(customerAvatar)\n        ? `${R2_URL}/customers/${finalCustomerId}/avatar_${nanoid(7)}`\n        : customerAvatar;\n\n    newCustomer = await prisma.customer.create({\n      data: {\n        id: finalCustomerId,\n        name: finalCustomerName,\n        email: customerEmail,\n        avatar: finalCustomerAvatar,\n        externalId: customerExternalId,\n        linkId: clickData.link_id,\n        clickId: clickData.click_id,\n        country: clickData.country,\n        projectId: workspace.id,\n        projectConnectId: workspace.stripeConnectId,\n        clickedAt: new Date(clickData.timestamp + \"Z\"),\n      },\n    });\n\n    if (customerAvatar && !isStored(customerAvatar) && finalCustomerAvatar) {\n      // persist customer avatar to R2 if it's not already stored\n      waitUntil(\n        storage.upload({\n          key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n          body: customerAvatar,\n          opts: {\n            width: 128,\n            height: 128,\n          },\n        }),\n      );\n    }\n\n    leadEventData = {\n      ...clickData,\n      event_id: nanoid(16),\n      // if leadEventName is provided, use it, otherwise use \"Sign up\"\n      event_name: leadEventName ?? \"Sign up\",\n      customer_id: newCustomer.id,\n      metadata: metadata ? JSON.stringify(metadata) : \"\",\n    };\n  }\n\n  const customer = existingCustomer ?? newCustomer;\n\n  // This should never happen, but just in case\n  if (!customer) {\n    waitUntil(\n      logConversionEvent({\n        workspace_id: workspace.id,\n        path: \"/track/sale\",\n        body: JSON.stringify(rawBody),\n        error: `Customer not found for customerExternalId: ${customerExternalId}`,\n      }),\n    );\n\n    return {\n      eventName,\n      customer: null,\n      sale: null,\n    };\n  }\n\n  const [_, trackedSale] = await Promise.all([\n    newCustomer &&\n      _trackLead({\n        workspace,\n        leadEventData,\n        customer: newCustomer,\n      }),\n\n    _trackSale({\n      amount,\n      currency,\n      eventName,\n      paymentProcessor,\n      invoiceId,\n      metadata,\n      rawBody,\n      workspace,\n      leadEventData,\n      customer,\n    }),\n  ]);\n\n  return trackedSale;\n};\n\n// Track the lead event\nconst _trackLead = async ({\n  workspace,\n  leadEventData,\n  customer,\n}: Pick<TrackSaleParams, \"workspace\"> & {\n  leadEventData: LeadEventTB | null;\n  customer: Customer;\n}) => {\n  if (!leadEventData) {\n    throw new DubApiError({\n      code: \"not_found\",\n      message: `Lead event data not found for the customer ${customer.id}`,\n    });\n  }\n\n  waitUntil(\n    (async () => {\n      const [_leadEvent, link, _workspace] = await Promise.all([\n        // Record the lead event for the customer\n        recordLead({\n          ...leadEventData,\n          workspace_id: leadEventData.workspace_id || workspace.id, // in case for some reason the lead event doesn't have workspace_id\n        }),\n\n        // Update link leads count + lastLeadAt date\n        prisma.link.update({\n          where: {\n            id: leadEventData.link_id,\n          },\n          data: {\n            leads: {\n              increment: 1,\n            },\n            lastLeadAt: new Date(),\n          },\n          include: includeTags,\n        }),\n\n        // Update workspace events usage\n        prisma.project.update({\n          where: {\n            id: workspace.id,\n          },\n          data: {\n            usage: {\n              increment: 1,\n            },\n          },\n        }),\n      ]);\n\n      // Create partner commission and execute workflows\n      if (link.programId && link.partnerId && customer) {\n        const { commission, webhookPartner } = await createPartnerCommission({\n          event: \"lead\",\n          programId: link.programId,\n          partnerId: link.partnerId,\n          linkId: link.id,\n          eventId: leadEventData.event_id,\n          customerId: customer.id,\n          quantity: 1,\n          context: {\n            customer: {\n              country: customer.country,\n            },\n          },\n        });\n\n        await Promise.allSettled([\n          executeWorkflows({\n            trigger: WorkflowTrigger.leadRecorded,\n            context: {\n              programId: link.programId,\n              partnerId: link.partnerId,\n              current: {\n                leads: 1,\n              },\n            },\n          }),\n\n          syncPartnerLinksStats({\n            partnerId: link.partnerId,\n            programId: link.programId,\n            eventType: \"lead\",\n          }),\n\n          webhookPartner &&\n            detectAndRecordFraudEvent({\n              program: { id: link.programId },\n              partner: pick(webhookPartner, [\"id\", \"email\", \"name\"]),\n              customer: pick(customer, [\"id\", \"email\", \"name\"]),\n              commission: { id: commission?.id },\n              link: pick(link, [\"id\"]),\n              click: pick(leadEventData, [\"url\", \"referer\"]),\n              event: { id: leadEventData.event_id },\n            }),\n        ]);\n      }\n\n      // Send workspace webhook\n      const webhookPayload = transformLeadEventData({\n        ...leadEventData,\n        link,\n        customer,\n      });\n\n      await sendWorkspaceWebhook({\n        trigger: \"lead.created\",\n        data: webhookPayload,\n        workspace,\n      });\n    })(),\n  );\n};\n\n// Track the sale event\nconst _trackSale = async ({\n  amount,\n  currency = \"usd\",\n  eventName,\n  paymentProcessor,\n  invoiceId,\n  metadata,\n  rawBody,\n  workspace,\n  leadEventData,\n  customer,\n}: Omit<TrackSaleParams, \"customerExternalId\"> & {\n  leadEventData: LeadEventTB | null;\n  customer: Customer;\n}) => {\n  if (!leadEventData) {\n    throw new DubApiError({\n      code: \"not_found\",\n      message: `Lead event data not found for the customer ${customer.id}`,\n    });\n  }\n\n  // Skip if amount is 0 or less\n  if (amount <= 0) {\n    waitUntil(\n      logConversionEvent({\n        workspace_id: workspace.id,\n        path: \"/track/sale\",\n        body: JSON.stringify(rawBody),\n        error: `Sale amount is ${amount}, skipping...`,\n      }),\n    );\n\n    return {\n      eventName,\n      customer: null,\n      sale: null,\n    };\n  }\n\n  // if currency is not USD, convert it to USD based on the current FX rate\n  // TODO: allow custom \"defaultCurrency\" on workspace table in the future\n  if (currency !== \"usd\") {\n    const { currency: convertedCurrency, amount: convertedAmount } =\n      await convertCurrency({\n        currency,\n        amount,\n      });\n\n    currency = convertedCurrency;\n    amount = convertedAmount;\n  }\n\n  const saleData = {\n    ...leadEventData,\n    workspace_id: leadEventData.workspace_id || workspace.id, // in case for some reason the lead event doesn't have workspace_id\n    event_id: nanoid(16),\n    event_name: eventName,\n    customer_id: customer.id,\n    payment_processor: paymentProcessor,\n    amount,\n    currency,\n    invoice_id: invoiceId || \"\",\n    metadata: metadata ? JSON.stringify(metadata) : \"\",\n    timestamp: undefined,\n  };\n\n  const firstConversionFlag = isFirstConversion({\n    customer,\n    linkId: saleData.link_id,\n  });\n\n  waitUntil(\n    (async () => {\n      const [_sale, link] = await Promise.all([\n        // Record sale event\n        recordSale(saleData),\n\n        // Update link conversions, sales, and saleAmount\n        prisma.link.update({\n          where: {\n            id: saleData.link_id,\n          },\n          data: {\n            ...(firstConversionFlag && {\n              conversions: {\n                increment: 1,\n              },\n              lastConversionAt: new Date(),\n            }),\n            sales: {\n              increment: 1,\n            },\n            saleAmount: {\n              increment: amount,\n            },\n          },\n          include: includeTags,\n        }),\n\n        // Update workspace events usage\n        prisma.project.update({\n          where: {\n            id: workspace.id,\n          },\n          data: {\n            usage: {\n              increment: 1,\n            },\n          },\n        }),\n\n        // Update customer sales count\n        prisma.customer.update({\n          where: {\n            id: customer.",
            "cost": 0.13353
        },
        "dubinc__dub.main/apps/web/lib/openapi/customers/index.ts": {
            "output": "import { ZodOpenApiPathsObject } from \"zod-openapi\";\nimport { createCustomer } from \"./create-customer\";\nimport { deleteCustomer } from \"./delete-customer\";\nimport { getCustomer } from \"./get-customer\";\nimport { getCustomers } from \"./get-customers\";\nimport { updateCustomer } from \"./update-customer\";\n\nexport const customersPaths: ZodOpenApiPathsObject = {\n  \"/customers\": {\n    get: getCustomers,\n    post: createCustomer,\n  },\n  \"/customers/{id}\": {\n    get: getCustomer,\n    patch: updateCustomer,\n    delete: deleteCustomer,\n  },\n};",
            "output_extracted": "import { ZodOpenApiPathsObject } from \"zod-openapi\";\nimport { createCustomer } from \"./create-customer\";\nimport { deleteCustomer } from \"./delete-customer\";\nimport { getCustomer } from \"./get-customer\";\nimport { getCustomers } from \"./get-customers\";\nimport { updateCustomer } from \"./update-customer\";\n\nexport const customersPaths: ZodOpenApiPathsObject = {\n  \"/customers\": {\n    get: getCustomers,\n    post: createCustomer,\n  },\n  \"/customers/{id}\": {\n    get: getCustomer,\n    patch: updateCustomer,\n    delete: deleteCustomer,\n  },\n};",
            "cost": 0.009795000000000002
        },
        "dubinc__dub.main/apps/web/tests/fraud/index.test.ts": {
            "output": "import { Customer, TrackLeadResponse } from \"@/lib/types\";\nimport { fraudEventSchemas } from \"@/lib/zod/schemas/fraud\";\nimport { FraudRuleType } from \"@prisma/client\";\nimport { randomCustomer, retry } from \"tests/utils/helpers\";\nimport { HttpClient } from \"tests/utils/http\";\nimport {\n  E2E_FRAUD_PARTNER,\n  E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN,\n  E2E_TRACK_CLICK_HEADERS,\n} from \"tests/utils/resource\";\nimport { describe, expect, test } from \"vitest\";\nimport { z } from \"zod\";\nimport { IntegrationHarness } from \"../utils/integration\";\n\ndescribe.concurrent(\"/fraud/**\", async () => {\n  const h = new IntegrationHarness();\n  const { http } = await h.init();\n\n  test(\"FraudRuleType = customerEmailMatch\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.customerEmailMatch;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = {\n      ...randomCustomer(),\n      email: E2E_FRAUD_PARTNER.email, // same email as partner\n    };\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"customerEmailMatch\",\n    });\n  });\n\n  test(\"FraudRuleType = customerEmailSuspiciousDomain\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.customerEmailSuspiciousDomain;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer({ emailDomain: \"email-temp.com\" });\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"customerEmailSuspiciousDomain\",\n    });\n  });\n\n  test(\"FraudRuleType = referralSourceBanned\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.referralSourceBanned;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n        referer: `https://${E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN}`,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer();\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"referralSourceBanned\",\n    });\n  });\n\n  test(\"FraudRuleType = paidTrafficDetected\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.paidTrafficDetected;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n        url: \"https://dub.co/paid-traffic?gclid=1234567890&gad_source=1\",\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer();\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"paidTrafficDetected\",\n    });\n  });\n});\n\nconst verifyFraudEvent = async ({\n  http,\n  customer,\n  ruleType,\n}: {\n  http: HttpClient;\n  customer: Pick<Customer, \"externalId\">;\n  ruleType: FraudRuleType;\n}) => {\n  // Resolve customerId from customerExternalID\n  const { data: customers } = await http.get<Customer[]>({\n    path: \"/customers\",\n    query: { externalId: customer.externalId },\n  });\n\n  expect(customers.length).toBeGreaterThan(0);\n\n  // Wait until fraud event is available\n  const fraudEvent = await waitForFraudEvent({\n    http,\n    customerId: customers[0].id,\n    ruleType,\n  });\n\n  // Assert fraud event shape\n  expect(fraudEvent).toStrictEqual({\n    createdAt: expect.any(String),\n    customer: expect.objectContaining({\n      id: customers[0].id,\n      name: customers[0].name,\n      email: customers[0].email,\n      avatar: customers[0].avatar,\n    }),\n    ...(ruleType === \"paidTrafficDetected\" && {\n      metadata: {\n        source: \"google\",\n        url: \"https://dub.co/paid-traffic?gclid=1234567890&gad_source=1\",\n      },\n    }),\n    ...(ruleType === \"referralSourceBanned\" && {\n      metadata: {\n        source: E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN,\n      },\n    }),\n  });\n};\n\nasync function waitForFraudEvent({\n  http,\n  customerId,\n  ruleType,\n}: {\n  http: HttpClient;\n  customerId: string;\n  ruleType: FraudRuleType;\n}) {\n  return await retry(\n    async () => {\n      const { data } = await http.get<\n        z.infer<(typeof fraudEventSchemas)[keyof typeof fraudEventSchemas]>[]\n      >({\n        path: \"/fraud/events\",\n        query: {\n          customerId,\n          type: ruleType,\n        },\n      });\n\n      if (!data.length) {\n        throw new Error(\"Fraud event not ready.\");\n      }\n\n      return data[0];\n    },\n    { retries: 10, interval: 600 },\n  );\n}",
            "output_extracted": "import { Customer, TrackLeadResponse } from \"@/lib/types\";\nimport { fraudEventSchemas } from \"@/lib/zod/schemas/fraud\";\nimport { FraudRuleType } from \"@prisma/client\";\nimport { randomCustomer, retry } from \"tests/utils/helpers\";\nimport { HttpClient } from \"tests/utils/http\";\nimport {\n  E2E_FRAUD_PARTNER,\n  E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN,\n  E2E_TRACK_CLICK_HEADERS,\n} from \"tests/utils/resource\";\nimport { describe, expect, test } from \"vitest\";\nimport { z } from \"zod\";\nimport { IntegrationHarness } from \"../utils/integration\";\n\ndescribe.concurrent(\"/fraud/**\", async () => {\n  const h = new IntegrationHarness();\n  const { http } = await h.init();\n\n  test(\"FraudRuleType = customerEmailMatch\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.customerEmailMatch;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = {\n      ...randomCustomer(),\n      email: E2E_FRAUD_PARTNER.email, // same email as partner\n    };\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"customerEmailMatch\",\n    });\n  });\n\n  test(\"FraudRuleType = customerEmailSuspiciousDomain\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.customerEmailSuspiciousDomain;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer({ emailDomain: \"email-temp.com\" });\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"customerEmailSuspiciousDomain\",\n    });\n  });\n\n  test(\"FraudRuleType = referralSourceBanned\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.referralSourceBanned;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n        referer: `https://${E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN}`,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer();\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"referralSourceBanned\",\n    });\n  });\n\n  test(\"FraudRuleType = paidTrafficDetected\", async () => {\n    const clickLink = E2E_FRAUD_PARTNER.links.paidTrafficDetected;\n\n    // Track a click\n    const clickResponse = await http.post<{ clickId: string }>({\n      path: \"/track/click\",\n      headers: {\n        ...E2E_TRACK_CLICK_HEADERS,\n      },\n      body: {\n        domain: clickLink.domain,\n        key: clickLink.key,\n        url: \"https://dub.co/paid-traffic?gclid=1234567890&gad_source=1\",\n      },\n    });\n\n    const trackedClickId = clickResponse.data.clickId;\n\n    // Track a lead\n    const customer = randomCustomer();\n\n    await http.post<TrackLeadResponse>({\n      path: \"/track/lead\",\n      body: {\n        eventName: \"Signup\",\n        clickId: trackedClickId,\n        customerId: customer.externalId,\n        customerName: customer.name,\n        customerEmail: customer.email,\n        customerAvatar: customer.avatar,\n      },\n    });\n\n    await verifyFraudEvent({\n      http,\n      customer,\n      ruleType: \"paidTrafficDetected\",\n    });\n  });\n});\n\nconst verifyFraudEvent = async ({\n  http,\n  customer,\n  ruleType,\n}: {\n  http: HttpClient;\n  customer: Pick<Customer, \"externalId\">;\n  ruleType: FraudRuleType;\n}) => {\n  // Resolve customerId from customerExternalID\n  const { data: customers } = await http.get<Customer[]>({\n    path: \"/customers\",\n    query: { externalId: customer.externalId },\n  });\n\n  expect(customers.length).toBeGreaterThan(0);\n\n  // Wait until fraud event is available\n  const fraudEvent = await waitForFraudEvent({\n    http,\n    customerId: customers[0].id,\n    ruleType,\n  });\n\n  // Assert fraud event shape\n  expect(fraudEvent).toStrictEqual({\n    createdAt: expect.any(String),\n    customer: expect.objectContaining({\n      id: customers[0].id,\n      name: customers[0].name,\n      email: customers[0].email,\n      avatar: customers[0].avatar,\n    }),\n    ...(ruleType === \"paidTrafficDetected\" && {\n      metadata: {\n        source: \"google\",\n        url: \"https://dub.co/paid-traffic?gclid=1234567890&gad_source=1\",\n      },\n    }),\n    ...(ruleType === \"referralSourceBanned\" && {\n      metadata: {\n        source: E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN,\n      },\n    }),\n  });\n};\n\nasync function waitForFraudEvent({\n  http,\n  customerId,\n  ruleType,\n}: {\n  http: HttpClient;\n  customerId: string;\n  ruleType: FraudRuleType;\n}) {\n  return await retry(\n    async () => {\n      const { data } = await http.get<\n        z.infer<(typeof fraudEventSchemas)[keyof typeof fraudEventSchemas]>[]\n      >({\n        path: \"/fraud/events\",\n        query: {\n          customerId,\n          type: ruleType,\n        },\n      });\n\n      if (!data.length) {\n        throw new Error(\"Fraud event not ready.\");\n      }\n\n      return data[0];\n    },\n    { retries: 10, interval: 600 },\n  );\n}",
            "cost": 0.067355
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "dubinc__dub.main.3157",
        "repo": "dubinc/dub",
        "base_commit": "63b1aa50622b3ebb8d0e25f8e808a3617ac8ecef",
        "head_commit": "9b96829db9afc48b068b9f86f66e6ea890db785c",
        "title": "Catch R2 upload error to avoid breaking conversion tracking",
        "merged_at": "2025-11-26T03:57:36Z",
        "html_url": "https://github.com/dubinc/dub/pull/3157",
        "test_files": [
            "apps/web/tests/fraud/index.test.ts"
        ],
        "code_files": [
            "apps/web/app/(ee)/api/customers/[id]/route.ts",
            "apps/web/app/(ee)/api/customers/route.ts",
            "apps/web/lib/api/conversions/track-lead.ts",
            "apps/web/lib/api/conversions/track-sale.ts",
            "apps/web/lib/openapi/customers/create-customer.ts",
            "apps/web/lib/openapi/customers/index.ts"
        ],
        "total_changes": 147,
        "num_files": 7,
        "pull_number": 3157,
        "patch": "diff --git a/apps/web/app/(ee)/api/customers/[id]/route.ts b/apps/web/app/(ee)/api/customers/[id]/route.ts\nindex c071e34e861..6e15be6f9c6 100644\n--- a/apps/web/app/(ee)/api/customers/[id]/route.ts\n+++ b/apps/web/app/(ee)/api/customers/[id]/route.ts\n@@ -96,21 +96,30 @@ export const PATCH = withWorkspace(\n \n       if (avatar && !isStored(avatar) && finalCustomerAvatar) {\n         waitUntil(\n-          Promise.allSettled([\n-            storage.upload({\n+          storage\n+            .upload({\n               key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n               body: avatar,\n               opts: {\n                 width: 128,\n                 height: 128,\n               },\n+            })\n+            .then(() => {\n+              if (oldCustomerAvatar && isStored(oldCustomerAvatar)) {\n+                storage.delete({\n+                  key: oldCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n+                });\n+              }\n+            })\n+            .catch(async (error) => {\n+              console.error(\"Error persisting customer avatar to R2\", error);\n+              // if the avatar fails to upload to R2, set the avatar to null in the database\n+              await prisma.customer.update({\n+                where: { id: customer.id },\n+                data: { avatar: null },\n+              });\n             }),\n-            oldCustomerAvatar &&\n-              isStored(oldCustomerAvatar) &&\n-              storage.delete({\n-                key: oldCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n-              }),\n-          ]),\n         );\n       }\n \ndiff --git a/apps/web/app/(ee)/api/customers/route.ts b/apps/web/app/(ee)/api/customers/route.ts\nindex e8583bd759a..ecdeb52892c 100644\n--- a/apps/web/app/(ee)/api/customers/route.ts\n+++ b/apps/web/app/(ee)/api/customers/route.ts\n@@ -165,14 +165,27 @@ export const POST = withWorkspace(\n \n       if (avatar && !isStored(avatar) && finalCustomerAvatar) {\n         waitUntil(\n-          storage.upload({\n-            key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n-            body: avatar,\n-            opts: {\n-              width: 128,\n-              height: 128,\n-            },\n-          }),\n+          storage\n+            .upload({\n+              key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n+              body: avatar,\n+              opts: {\n+                width: 128,\n+                height: 128,\n+              },\n+            })\n+            .catch(async (error) => {\n+              console.error(\"Error persisting customer avatar to R2\", error);\n+              // if the avatar fails to upload to R2, set the avatar to null in the database\n+              await prisma.customer.update({\n+                where: {\n+                  id: customer.id,\n+                },\n+                data: {\n+                  avatar: null,\n+                },\n+              });\n+            }),\n         );\n       }\n \ndiff --git a/apps/web/lib/api/conversions/track-lead.ts b/apps/web/lib/api/conversions/track-lead.ts\nindex efe241234de..f940dafe4e4 100644\n--- a/apps/web/lib/api/conversions/track-lead.ts\n+++ b/apps/web/lib/api/conversions/track-lead.ts\n@@ -238,14 +238,25 @@ export const trackLead = async ({\n           finalCustomerAvatar\n         ) {\n           // persist customer avatar to R2\n-          await storage.upload({\n-            key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n-            body: customerAvatar,\n-            opts: {\n-              width: 128,\n-              height: 128,\n-            },\n-          });\n+          await storage\n+            .upload({\n+              key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n+              body: customerAvatar,\n+              opts: {\n+                width: 128,\n+                height: 128,\n+              },\n+            })\n+            .catch(async (error) => {\n+              console.error(\"Error persisting customer avatar to R2\", error);\n+              // if the avatar fails to upload to R2, set the avatar to null in the database\n+              if (customer) {\n+                await prisma.customer.update({\n+                  where: { id: customer.id },\n+                  data: { avatar: null },\n+                });\n+              }\n+            });\n         }\n \n         // if not deferred mode, process the following right away:\ndiff --git a/apps/web/lib/api/conversions/track-sale.ts b/apps/web/lib/api/conversions/track-sale.ts\nindex 87bc7613326..a6edaa83b05 100644\n--- a/apps/web/lib/api/conversions/track-sale.ts\n+++ b/apps/web/lib/api/conversions/track-sale.ts\n@@ -214,14 +214,25 @@ export const trackSale = async ({\n     if (customerAvatar && !isStored(customerAvatar) && finalCustomerAvatar) {\n       // persist customer avatar to R2 if it's not already stored\n       waitUntil(\n-        storage.upload({\n-          key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n-          body: customerAvatar,\n-          opts: {\n-            width: 128,\n-            height: 128,\n-          },\n-        }),\n+        storage\n+          .upload({\n+            key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n+            body: customerAvatar,\n+            opts: {\n+              width: 128,\n+              height: 128,\n+            },\n+          })\n+          .catch(async (error) => {\n+            console.error(\"Error persisting customer avatar to R2\", error);\n+            // if the avatar fails to upload to R2, set the avatar to null in the database\n+            if (newCustomer) {\n+              await prisma.customer.update({\n+                where: { id: newCustomer.id },\n+                data: { avatar: null },\n+              });\n+            }\n+          }),\n       );\n     }\n \ndiff --git a/apps/web/lib/openapi/customers/create-customer.ts b/apps/web/lib/openapi/customers/create-customer.ts\ndeleted file mode 100644\nindex d80e6f70abf..00000000000\n--- a/apps/web/lib/openapi/customers/create-customer.ts\n+++ /dev/null\n@@ -1,35 +0,0 @@\n-import { openApiErrorResponses } from \"@/lib/openapi/responses\";\n-import { ZodOpenApiOperationObject } from \"zod-openapi\";\n-import {\n-  createCustomerBodySchema,\n-  CustomerEnrichedSchema,\n-} from \"../../zod/schemas/customers\";\n-\n-export const createCustomer: ZodOpenApiOperationObject = {\n-  operationId: \"createCustomer\",\n-  \"x-speakeasy-name-override\": \"create\",\n-  summary: \"Create a customer\",\n-  description:\n-    \"[Deprecated]: Customer creation can only be done via tracking a lead event. Use the /track/lead endpoint instead.\",\n-  deprecated: true,\n-  requestBody: {\n-    content: {\n-      \"application/json\": {\n-        schema: createCustomerBodySchema,\n-      },\n-    },\n-  },\n-  responses: {\n-    \"201\": {\n-      description: \"The customer was created.\",\n-      content: {\n-        \"application/json\": {\n-          schema: CustomerEnrichedSchema,\n-        },\n-      },\n-    },\n-    ...openApiErrorResponses,\n-  },\n-  tags: [\"Customers\"],\n-  security: [{ token: [] }],\n-};\ndiff --git a/apps/web/lib/openapi/customers/index.ts b/apps/web/lib/openapi/customers/index.ts\nindex 0cc5eb085f0..dd5015a8c3f 100644\n--- a/apps/web/lib/openapi/customers/index.ts\n+++ b/apps/web/lib/openapi/customers/index.ts\n@@ -1,5 +1,4 @@\n import { ZodOpenApiPathsObject } from \"zod-openapi\";\n-import { createCustomer } from \"./create-customer\";\n import { deleteCustomer } from \"./delete-customer\";\n import { getCustomer } from \"./get-customer\";\n import { getCustomers } from \"./get-customers\";\n@@ -8,7 +7,6 @@ import { updateCustomer } from \"./update-customer\";\n export const customersPaths: ZodOpenApiPathsObject = {\n   \"/customers\": {\n     get: getCustomers,\n-    post: createCustomer,\n   },\n   \"/customers/{id}\": {\n     get: getCustomer,\ndiff --git a/apps/web/tests/fraud/index.test.ts b/apps/web/tests/fraud/index.test.ts\nindex 5ec68ae360c..cc2c5c50afc 100644\n--- a/apps/web/tests/fraud/index.test.ts\n+++ b/apps/web/tests/fraud/index.test.ts\n@@ -11,7 +11,7 @@ import {\n import { describe, expect, test } from \"vitest\";\n import { IntegrationHarness } from \"../utils/integration\";\n \n-describe.concurrent(\"/fraud/**\", async () => {\n+describe.skip.concurrent(\"/fraud/**\", async () => {\n   const h = new IntegrationHarness();\n   const { http } = await h.init();\n \n",
        "pr_mirror": "dubinc__dub.main"
    }
}