{
    "cost": 0.548825,
    "rewrites": {
        "hoppscotch__hoppscotch.main/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts": {
            "output": "import { UseGuards } from '@nestjs/common';\nimport {\n  Args,\n  ID,\n  Mutation,\n  Parent,\n  ResolveField,\n  Resolver,\n  Query,\n} from '@nestjs/graphql';\nimport { GqlThrottlerGuard } from 'src/guards/gql-throttler.guard';\nimport { PublishedDocs, PublishedDocsCollection } from './published-docs.model';\nimport { GqlAuthGuard } from 'src/guards/gql-auth.guard';\nimport { GqlUser } from 'src/decorators/gql-user.decorator';\nimport {\n  CreatePublishedDocsArgs,\n  UpdatePublishedDocsArgs,\n} from './input-type.args';\nimport { User } from 'src/user/user.model';\nimport { PublishedDocsService } from './published-docs.service';\nimport * as E from 'fp-ts/Either';\nimport { throwErr } from 'src/utils';\nimport { GqlTeamMemberGuard } from 'src/team/guards/gql-team-member.guard';\nimport { OffsetPaginationArgs } from 'src/types/input-types.args';\nimport { RequiresTeamRole } from 'src/team/decorators/requires-team-role.decorator';\nimport { TeamAccessRole } from 'src/team/team.model';\n\n@UseGuards(GqlThrottlerGuard)\n@Resolver(() => PublishedDocs)\nexport class PublishedDocsResolver {\n  constructor(private readonly publishedDocsService: PublishedDocsService) {}\n\n  // Resolve Fields\n\n  @ResolveField(() => User, {\n    description: 'Returns the creator of the published document',\n  })\n  async creator(@Parent() publishedDocs: PublishedDocs): Promise<User> {\n    const creator = await this.publishedDocsService.getPublishedDocsCreator(\n      publishedDocs.id,\n    );\n\n    if (E.isLeft(creator)) throwErr(creator.left);\n    return {\n      ...creator.right,\n      currentGQLSession: JSON.stringify(creator.right.currentGQLSession),\n      currentRESTSession: JSON.stringify(creator.right.currentRESTSession),\n    };\n  }\n\n  @ResolveField(() => PublishedDocsCollection, {\n    description: 'Returns the collection of the published document',\n    nullable: true,\n  })\n  async collection(\n    @Parent() publishedDocs: PublishedDocs,\n  ): Promise<PublishedDocsCollection | null> {\n    const collection =\n      await this.publishedDocsService.getPublishedDocsCollection(\n        publishedDocs.id,\n      );\n\n    if (E.isLeft(collection)) throwErr(collection.left);\n    return collection.right;\n  }\n\n  // Queries\n\n  @Query(() => PublishedDocs, {\n    description: 'Get a published document by ID',\n  })\n  @UseGuards(GqlAuthGuard)\n  async publishedDoc(\n    @GqlUser() user: User,\n    @Args({\n      name: 'id',\n      type: () => ID,\n      description: 'Id of the published document to fetch',\n    })\n    id: string,\n  ) {\n    const doc = await this.publishedDocsService.getPublishedDocByID(id, user);\n\n    if (E.isLeft(doc)) throwErr(doc.left);\n    return doc.right;\n  }\n\n  @Query(() => [PublishedDocs], {\n    description: 'Get all published documents of a user',\n  })\n  @UseGuards(GqlAuthGuard)\n  async userPublishedDocsList(\n    @GqlUser() user: User,\n    @Args() args: OffsetPaginationArgs,\n  ) {\n    const docs = await this.publishedDocsService.getAllUserPublishedDocs(\n      user.uid,\n      args,\n    );\n    return docs;\n  }\n\n  @Query(() => [PublishedDocs], {\n    description: 'Get all published documents',\n  })\n  @UseGuards(GqlAuthGuard, GqlTeamMemberGuard)\n  @RequiresTeamRole(\n    TeamAccessRole.VIEWER,\n    TeamAccessRole.EDITOR,\n    TeamAccessRole.OWNER,\n  )\n  async teamPublishedDocsList(\n    @Args({\n      name: 'teamID',\n      type: () => ID,\n      description: 'Id of the team to add to',\n    })\n    teamID: string,\n    @Args({\n      name: 'collectionID',\n      type: () => ID,\n      description: 'Id of the collection to add to',\n      nullable: true,\n    })\n    collectionID: string | undefined,\n    @Args() args: OffsetPaginationArgs,\n  ) {\n    const docs = await this.publishedDocsService.getAllTeamPublishedDocs(\n      teamID,\n      collectionID,\n      args,\n    );\n    return docs;\n  }\n\n  // Mutations\n\n  @Mutation(() => PublishedDocs, {\n    description: 'Create a new published document',\n  })\n  @UseGuards(GqlAuthGuard)\n  async createPublishedDoc(\n    @GqlUser() user: User,\n    @Args({\n      name: 'args',\n      type: () => CreatePublishedDocsArgs,\n      description: 'Arguments for creating a published document',\n    })\n    args: CreatePublishedDocsArgs,\n  ) {\n    const newDoc = await this.publishedDocsService.createPublishedDoc(\n      args,\n      user,\n    );\n\n    if (E.isLeft(newDoc)) throwErr(newDoc.left);\n    return newDoc.right;\n  }\n\n  @Mutation(() => PublishedDocs, {\n    description: 'Update an existing published document',\n  })\n  @UseGuards(GqlAuthGuard)\n  async updatePublishedDoc(\n    @GqlUser() user: User,\n    @Args({\n      name: 'id',\n      description: 'ID of the published document to update',\n      type: () => ID,\n    })\n    id: string,\n    @Args({\n      name: 'args',\n      type: () => UpdatePublishedDocsArgs,\n      description: 'Arguments for updating a published document',\n    })\n    args: UpdatePublishedDocsArgs,\n  ) {\n    const updatedDoc = await this.publishedDocsService.updatePublishedDoc(\n      id,\n      args,\n      user,\n    );\n\n    if (E.isLeft(updatedDoc)) throwErr(updatedDoc.left);\n    return updatedDoc.right;\n  }\n\n  @Mutation(() => Boolean, {\n    description: 'Delete a published document by ID',\n  })\n  @UseGuards(GqlAuthGuard)\n  async deletePublishedDoc(\n    @GqlUser() user: User,\n    @Args({\n      name: 'id',\n      description: 'ID of the published document to delete',\n      type: () => ID,\n    })\n    id: string,\n  ) {\n    const result = await this.publishedDocsService.deletePublishedDoc(id, user);\n\n    if (E.isLeft(result)) throwErr(result.left);\n    return result.right;\n  }\n}",
            "output_extracted": "import { UseGuards } from '@nestjs/common';\nimport {\n  Args,\n  ID,\n  Mutation,\n  Parent,\n  ResolveField,\n  Resolver,\n  Query,\n} from '@nestjs/graphql';\nimport { GqlThrottlerGuard } from 'src/guards/gql-throttler.guard';\nimport { PublishedDocs, PublishedDocsCollection } from './published-docs.model';\nimport { GqlAuthGuard } from 'src/guards/gql-auth.guard';\nimport { GqlUser } from 'src/decorators/gql-user.decorator';\nimport {\n  CreatePublishedDocsArgs,\n  UpdatePublishedDocsArgs,\n} from './input-type.args';\nimport { User } from 'src/user/user.model';\nimport { PublishedDocsService } from './published-docs.service';\nimport * as E from 'fp-ts/Either';\nimport { throwErr } from 'src/utils';\nimport { GqlTeamMemberGuard } from 'src/team/guards/gql-team-member.guard';\nimport { OffsetPaginationArgs } from 'src/types/input-types.args';\nimport { RequiresTeamRole } from 'src/team/decorators/requires-team-role.decorator';\nimport { TeamAccessRole } from 'src/team/team.model';\n\n@UseGuards(GqlThrottlerGuard)\n@Resolver(() => PublishedDocs)\nexport class PublishedDocsResolver {\n  constructor(private readonly publishedDocsService: PublishedDocsService) {}\n\n  // Resolve Fields\n\n  @ResolveField(() => User, {\n    description: 'Returns the creator of the published document',\n  })\n  async creator(@Parent() publishedDocs: PublishedDocs): Promise<User> {\n    const creator = await this.publishedDocsService.getPublishedDocsCreator(\n      publishedDocs.id,\n    );\n\n    if (E.isLeft(creator)) throwErr(creator.left);\n    return {\n      ...creator.right,\n      currentGQLSession: JSON.stringify(creator.right.currentGQLSession),\n      currentRESTSession: JSON.stringify(creator.right.currentRESTSession),\n    };\n  }\n\n  @ResolveField(() => PublishedDocsCollection, {\n    description: 'Returns the collection of the published document',\n    nullable: true,\n  })\n  async collection(\n    @Parent() publishedDocs: PublishedDocs,\n  ): Promise<PublishedDocsCollection | null> {\n    const collection =\n      await this.publishedDocsService.getPublishedDocsCollection(\n        publishedDocs.id,\n      );\n\n    if (E.isLeft(collection)) throwErr(collection.left);\n    return collection.right;\n  }\n\n  // Queries\n\n  @Query(() => PublishedDocs, {\n    description: 'Get a published document by ID',\n  })\n  @UseGuards(GqlAuthGuard)\n  async publishedDoc(\n    @GqlUser() user: User,\n    @Args({\n      name: 'id',\n      type: () => ID,\n      description: 'Id of the published document to fetch',\n    })\n    id: string,\n  ) {\n    const doc = await this.publishedDocsService.getPublishedDocByID(id, user);\n\n    if (E.isLeft(doc)) throwErr(doc.left);\n    return doc.right;\n  }\n\n  @Query(() => [PublishedDocs], {\n    description: 'Get all published documents of a user',\n  })\n  @UseGuards(GqlAuthGuard)\n  async userPublishedDocsList(\n    @GqlUser() user: User,\n    @Args() args: OffsetPaginationArgs,\n  ) {\n    const docs = await this.publishedDocsService.getAllUserPublishedDocs(\n      user.uid,\n      args,\n    );\n    return docs;\n  }\n\n  @Query(() => [PublishedDocs], {\n    description: 'Get all published documents',\n  })\n  @UseGuards(GqlAuthGuard, GqlTeamMemberGuard)\n  @RequiresTeamRole(\n    TeamAccessRole.VIEWER,\n    TeamAccessRole.EDITOR,\n    TeamAccessRole.OWNER,\n  )\n  async teamPublishedDocsList(\n    @Args({\n      name: 'teamID',\n      type: () => ID,\n      description: 'Id of the team to add to',\n    })\n    teamID: string,\n    @Args({\n      name: 'collectionID',\n      type: () => ID,\n      description: 'Id of the collection to add to',\n      nullable: true,\n    })\n    collectionID: string | undefined,\n    @Args() args: OffsetPaginationArgs,\n  ) {\n    const docs = await this.publishedDocsService.getAllTeamPublishedDocs(\n      teamID,\n      collectionID,\n      args,\n    );\n    return docs;\n  }\n\n  // Mutations\n\n  @Mutation(() => PublishedDocs, {\n    description: 'Create a new published document',\n  })\n  @UseGuards(GqlAuthGuard)\n  async createPublishedDoc(\n    @GqlUser() user: User,\n    @Args({\n      name: 'args',\n      type: () => CreatePublishedDocsArgs,\n      description: 'Arguments for creating a published document',\n    })\n    args: CreatePublishedDocsArgs,\n  ) {\n    const newDoc = await this.publishedDocsService.createPublishedDoc(\n      args,\n      user,\n    );\n\n    if (E.isLeft(newDoc)) throwErr(newDoc.left);\n    return newDoc.right;\n  }\n\n  @Mutation(() => PublishedDocs, {\n    description: 'Update an existing published document',\n  })\n  @UseGuards(GqlAuthGuard)\n  async updatePublishedDoc(\n    @GqlUser() user: User,\n    @Args({\n      name: 'id',\n      description: 'ID of the published document to update',\n      type: () => ID,\n    })\n    id: string,\n    @Args({\n      name: 'args',\n      type: () => UpdatePublishedDocsArgs,\n      description: 'Arguments for updating a published document',\n    })\n    args: UpdatePublishedDocsArgs,\n  ) {\n    const updatedDoc = await this.publishedDocsService.updatePublishedDoc(\n      id,\n      args,\n      user,\n    );\n\n    if (E.isLeft(updatedDoc)) throwErr(updatedDoc.left);\n    return updatedDoc.right;\n  }\n\n  @Mutation(() => Boolean, {\n    description: 'Delete a published document by ID',\n  })\n  @UseGuards(GqlAuthGuard)\n  async deletePublishedDoc(\n    @GqlUser() user: User,\n    @Args({\n      name: 'id',\n      description: 'ID of the published document to delete',\n      type: () => ID,\n    })\n    id: string,\n  ) {\n    const result = await this.publishedDocsService.deletePublishedDoc(id, user);\n\n    if (E.isLeft(result)) throwErr(result.left);\n    return result.right;\n  }\n}",
            "cost": 0.061195000000000006
        },
        "hoppscotch__hoppscotch.main/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts": {
            "output": "import { PublishedDocs as DBPublishedDocs } from 'src/generated/prisma/client';\nimport { mockDeep, mockReset } from 'jest-mock-extended';\nimport {\n  PUBLISHED_DOCS_CREATION_FAILED,\n  PUBLISHED_DOCS_DELETION_FAILED,\n  PUBLISHED_DOCS_INVALID_COLLECTION,\n  PUBLISHED_DOCS_NOT_FOUND,\n  PUBLISHED_DOCS_UPDATE_FAILED,\n  TEAM_INVALID_ID,\n} from 'src/errors';\nimport * as E from 'fp-ts/Either';\nimport { PrismaService } from 'src/prisma/prisma.service';\nimport { User } from 'src/user/user.model';\nimport { WorkspaceType } from 'src/types/WorkspaceTypes';\nimport { PublishedDocsService } from './published-docs.service';\nimport { PublishedDocs } from './published-docs.model';\nimport { UserCollectionService } from 'src/user-collection/user-collection.service';\nimport { TeamCollectionService } from 'src/team-collection/team-collection.service';\nimport {\n  CreatePublishedDocsArgs,\n  UpdatePublishedDocsArgs,\n} from './input-type.args';\nimport { TeamAccessRole } from 'src/team/team.model';\nimport { TreeLevel } from './published-docs.dto';\nimport { ConfigService } from '@nestjs/config';\n\nconst mockPrisma = mockDeep<PrismaService>();\nconst mockUserCollectionService = mockDeep<UserCollectionService>();\nconst mockTeamCollectionService = mockDeep<TeamCollectionService>();\nconst mockConfigService = mockDeep<ConfigService>();\n\nconst publishedDocsService = new PublishedDocsService(\n  mockPrisma,\n  mockUserCollectionService,\n  mockTeamCollectionService,\n  mockConfigService,\n);\n\nconst currentTime = new Date();\n\nconst user: User = {\n  uid: '123344',\n  email: 'dwight@dundermifflin.com',\n  displayName: 'Dwight Schrute',\n  photoURL: 'https://en.wikipedia.org/wiki/Dwight_Schrute',\n  isAdmin: false,\n  lastLoggedOn: currentTime,\n  lastActiveOn: currentTime,\n  createdOn: currentTime,\n  currentGQLSession: JSON.stringify({}),\n  currentRESTSession: JSON.stringify({}),\n};\n\nconst userPublishedDoc: DBPublishedDocs = {\n  id: 'pub_doc_1',\n  title: 'User API Documentation',\n  version: '1.0.0',\n  autoSync: true,\n  documentTree: {},\n  workspaceType: WorkspaceType.USER,\n  workspaceID: user.uid,\n  collectionID: 'collection_1',\n  creatorUid: user.uid,\n  metadata: {},\n  createdOn: currentTime,\n  updatedOn: currentTime,\n};\n\nconst userPublishedDocCasted: PublishedDocs = {\n  id: userPublishedDoc.id,\n  title: userPublishedDoc.title,\n  version: userPublishedDoc.version,\n  autoSync: userPublishedDoc.autoSync,\n  documentTree: JSON.stringify(userPublishedDoc.documentTree),\n  workspaceType: userPublishedDoc.workspaceType,\n  workspaceID: userPublishedDoc.workspaceID,\n  metadata: JSON.stringify(userPublishedDoc.metadata),\n  createdOn: userPublishedDoc.createdOn,\n  updatedOn: userPublishedDoc.updatedOn,\n  url: `${mockConfigService.get('VITE_BASE_URL')}/view/${userPublishedDoc.id}/${userPublishedDoc.version}`,\n};\n\nconst teamPublishedDoc: DBPublishedDocs = {\n  id: 'pub_doc_2',\n  title: 'Team API Documentation',\n  version: '1.0.0',\n  autoSync: true,\n  documentTree: {},\n  workspaceType: WorkspaceType.TEAM,\n  workspaceID: 'team_1',\n  collectionID: 'team_collection_1',\n  creatorUid: user.uid,\n  metadata: {},\n  createdOn: currentTime,\n  updatedOn: currentTime,\n};\n\nconst teamPublishedDocCasted: PublishedDocs = {\n  id: teamPublishedDoc.id,\n  title: teamPublishedDoc.title,\n  version: teamPublishedDoc.version,\n  autoSync: teamPublishedDoc.autoSync,\n  documentTree: JSON.stringify(teamPublishedDoc.documentTree),\n  workspaceType: teamPublishedDoc.workspaceType,\n  workspaceID: teamPublishedDoc.workspaceID,\n  metadata: JSON.stringify(teamPublishedDoc.metadata),\n  createdOn: teamPublishedDoc.createdOn,\n  updatedOn: teamPublishedDoc.updatedOn,\n  url: `${mockConfigService.get('VITE_BASE_URL')}/view/${teamPublishedDoc.id}/${teamPublishedDoc.version}`,\n};\n\nbeforeEach(() => {\n  mockReset(mockPrisma);\n});\n\ndescribe('getPublishedDocByID', () => {\n  test('should return a published document with valid ID and user access', async () => {\n    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n\n    const result = await publishedDocsService.getPublishedDocByID(\n      userPublishedDoc.id,\n      user,\n    );\n    expect(E.isRight(result)).toBe(true);\n    if (E.isRight(result)) {\n      expect(result.right).toMatchObject(userPublishedDocCasted);\n    }\n  });\n\n  test('should throw PUBLISHED_DOCS_NOT_FOUND when ID is invalid', async () => {\n    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);\n\n    const result = await publishedDocsService.getPublishedDocByID(\n      'invalid_id',\n      user,\n    );\n    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n  });\n\n  test('should throw PUBLISHED_DOCS_NOT_FOUND when user does not have access', async () => {\n    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({\n      ...userPublishedDoc,\n      creatorUid: 'different_user',\n    });\n\n    const result = await publishedDocsService.getPublishedDocByID(\n      userPublishedDoc.id,\n      user,\n    );\n    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n  });\n\n  test('should return team published document when user has team access', async () => {\n    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n\n    const result = await publishedDocsService.getPublishedDocByID(\n      teamPublishedDoc.id,\n      user,\n    );\n    expect(E.isRight(result)).toBe(true);\n    if (E.isRight(result)) {\n      expect(result.right).toMatchObject(teamPublishedDocCasted);\n    }\n  });\n\n  test('should throw PUBLISHED_DOCS_NOT_FOUND when user does not have team access', async () => {\n    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n    mockPrisma.team.findFirst.mockResolvedValueOnce(null);\n\n    const result = await publishedDocsService.getPublishedDocByID(\n      teamPublishedDoc.id,\n      user,\n    );\n    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n  });\n});\n\ndescribe('getAllUserPublishedDocs', () => {\n  test('should return a list of user published documents with pagination', async () => {\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([userPublishedDoc]);\n\n    const result = await publishedDocsService.getAllUserPublishedDocs(\n      user.uid,\n      { skip: 0, take: 10 },\n    );\n    expect(result).toHaveLength(1);\n    expect(result[0]).toMatchObject(userPublishedDocCasted);\n  });\n\n  test('should return an empty array when no documents found', async () => {\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);\n\n    const result = await publishedDocsService.getAllUserPublishedDocs(\n      user.uid,\n      { skip: 0, take: 10 },\n    );\n    expect(result).toEqual([]);\n  });\n\n  test('should return paginated results correctly', async () => {\n    const docs = [userPublishedDoc, { ...userPublishedDoc, id: 'pub_doc_3' }];\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([docs[0]]);\n\n    const result = await publishedDocsService.getAllUserPublishedDocs(\n      user.uid,\n      { skip: 0, take: 1 },\n    );\n    expect(result).toHaveLength(1);\n  });\n});\n\ndescribe('getAllTeamPublishedDocs', () => {\n  test('should return a list of team published documents with pagination', async () => {\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n\n    const result = await publishedDocsService.getAllTeamPublishedDocs(\n      'team_1',\n      'team_collection_1',\n      { skip: 0, take: 10 },\n    );\n    expect(result).toHaveLength(1);\n    expect(result[0]).toMatchObject(teamPublishedDocCasted);\n  });\n\n  test('should return an empty array when no team documents found', async () => {\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);\n\n    const result = await publishedDocsService.getAllTeamPublishedDocs(\n      'team_1',\n      'team_collection_1',\n      { skip: 0, take: 10 },\n    );\n    expect(result).toEqual([]);\n  });\n\n  test('should filter by teamID and collectionID correctly', async () => {\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n\n    await publishedDocsService.getAllTeamPublishedDocs(\n      'team_1',\n      'team_collection_1',\n      { skip: 0, take: 10 },\n    );\n\n    expect(mockPrisma.publishedDocs.findMany).toHaveBeenCalledWith({\n      where: {\n        workspaceType: WorkspaceType.TEAM,\n        workspaceID: 'team_1',\n        collectionID: 'team_collection_1',\n      },\n      skip: 0,\n      take: 10,\n      orderBy: {\n        createdOn: 'desc',\n      },\n    });\n  });\n});\n\ndescribe('createPublishedDoc', () => {\n  const createArgs: CreatePublishedDocsArgs = {\n    title: 'New API Documentation',\n    version: '1.0.0',\n    autoSync: true,\n    workspaceType: WorkspaceType.USER,\n    workspaceID: user.uid,\n    collectionID: 'collection_1',\n    metadata: '{}',\n  };\n\n  test('should successfully create a user published document with valid inputs', async () => {\n    mockPrisma.userCollection.findUnique.mockResolvedValueOnce({\n      id: 'collection_1',\n      userUid: user.uid,\n    } as any);\n    mockPrisma.publishedDocs.create.mockResolvedValueOnce(userPublishedDoc);\n\n    const result = await publishedDocsService.createPublishedDoc(\n      createArgs,\n      user,\n    );\n    expect(E.isRight(result)).toBe(true);\n    if (E.isRight(result)) {\n      expect(result.right).toMatchObject(userPublishedDocCasted);\n    }\n  });\n\n  test('should successfully create a team published document with valid inputs', async () => {\n    const teamArgs: CreatePublishedDocsArgs = {\n      ...createArgs,\n      workspaceType: WorkspaceType.TEAM,\n      workspaceID: 'team_1',\n      collectionID: 'team_collection_1',\n    };\n\n    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n    mockPrisma.teamCollection.findUnique.mockResolvedValueOnce({\n      id: 'team_collection_1',\n      teamID: 'team_1',\n    } as any);\n    mockPrisma.publishedDocs.create.mockResolvedValueOnce(teamPublishedDoc);\n\n    const result = await publishedDocsService.createPublishedDoc(\n      teamArgs,\n      user,\n    );\n    expect(E.isRight(result)).toBe(true);\n    if (E.isRight(result)) {\n      expect(result.right).toMatchObject(teamPublishedDocCasted);\n    }\n  });\n\n  test('should throw TEAM_INVALID_ID when team ID is invalid', async () => {\n    const teamArgs: CreatePublishedDocsArgs = {\n      ...createArgs,\n      workspaceType: WorkspaceType.TEAM,\n      workspaceID: '',\n    };\n\n    const result = await publishedDocsService.createPublishedDoc(\n      teamArgs,\n      user,\n    );\n    expect(result).toEqualLeft(TEAM_INVALID_ID);\n  });\n\n  test('should throw TEAM_INVALID_ID when user does not have team access', async () => {\n    const teamArgs: CreatePublishedDocsArgs = {\n      ...createArgs,\n      workspaceType: WorkspaceType.TEAM,\n      workspaceID: 'team_1',\n    };\n\n    mockPrisma.team.findFirst.mockResolvedValueOnce(null);\n\n    const result = await publishedDocsService.createPublishedDoc(\n      teamArgs,\n      user,\n    );\n    expect(result).toEqualLeft(TEAM_INVALID_ID);\n  });\n\n  test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when user collection is invalid', async () => {\n    mockPrisma.userCollection.findUnique.mockResolvedValueOnce(null);\n\n    const result = await publishedDocsService.createPublishedDoc(\n      createArgs,\n      user,\n    );\n    expect(result).toEqualLeft(PUBLISHED_DOCS_INVALID_COLLECTION);\n  });\n\n  test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when team collection is invalid', async () => {\n    const teamArgs: CreatePublishedDocsArgs = {\n      ...createArgs,\n      workspaceType: WorkspaceType.TEAM,\n      workspaceID: 'team_1',\n      collectionID: 'invalid_collection',\n    };\n\n    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n    mockPrisma.teamCollection.findUnique.mockResolvedValueOnce(null);\n\n    const result = await publishedDocsService.createPublishedDoc(\n      teamArgs,\n      user,\n    );\n    expect(result).toEqualLeft(PUBLISHED_DOCS_INVALID_COLLECTION);\n  });\n\n  test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when collection does not belong to user', async () => {\n    // When Prisma queries with",
            "output_extracted": "import { PublishedDocs as DBPublishedDocs } from 'src/generated/prisma/client';\nimport { mockDeep, mockReset } from 'jest-mock-extended';\nimport {\n  PUBLISHED_DOCS_CREATION_FAILED,\n  PUBLISHED_DOCS_DELETION_FAILED,\n  PUBLISHED_DOCS_INVALID_COLLECTION,\n  PUBLISHED_DOCS_NOT_FOUND,\n  PUBLISHED_DOCS_UPDATE_FAILED,\n  TEAM_INVALID_ID,\n} from 'src/errors';\nimport * as E from 'fp-ts/Either';\nimport { PrismaService } from 'src/prisma/prisma.service';\nimport { User } from 'src/user/user.model';\nimport { WorkspaceType } from 'src/types/WorkspaceTypes';\nimport { PublishedDocsService } from './published-docs.service';\nimport { PublishedDocs } from './published-docs.model';\nimport { UserCollectionService } from 'src/user-collection/user-collection.service';\nimport { TeamCollectionService } from 'src/team-collection/team-collection.service';\nimport {\n  CreatePublishedDocsArgs,\n  UpdatePublishedDocsArgs,\n} from './input-type.args';\nimport { TeamAccessRole } from 'src/team/team.model';\nimport { TreeLevel } from './published-docs.dto';\nimport { ConfigService } from '@nestjs/config';\n\nconst mockPrisma = mockDeep<PrismaService>();\nconst mockUserCollectionService = mockDeep<UserCollectionService>();\nconst mockTeamCollectionService = mockDeep<TeamCollectionService>();\nconst mockConfigService = mockDeep<ConfigService>();\n\nconst publishedDocsService = new PublishedDocsService(\n  mockPrisma,\n  mockUserCollectionService,\n  mockTeamCollectionService,\n  mockConfigService,\n);\n\nconst currentTime = new Date();\n\nconst user: User = {\n  uid: '123344',\n  email: 'dwight@dundermifflin.com',\n  displayName: 'Dwight Schrute',\n  photoURL: 'https://en.wikipedia.org/wiki/Dwight_Schrute',\n  isAdmin: false,\n  lastLoggedOn: currentTime,\n  lastActiveOn: currentTime,\n  createdOn: currentTime,\n  currentGQLSession: JSON.stringify({}),\n  currentRESTSession: JSON.stringify({}),\n};\n\nconst userPublishedDoc: DBPublishedDocs = {\n  id: 'pub_doc_1',\n  title: 'User API Documentation',\n  version: '1.0.0',\n  autoSync: true,\n  documentTree: {},\n  workspaceType: WorkspaceType.USER,\n  workspaceID: user.uid,\n  collectionID: 'collection_1',\n  creatorUid: user.uid,\n  metadata: {},\n  createdOn: currentTime,\n  updatedOn: currentTime,\n};\n\nconst userPublishedDocCasted: PublishedDocs = {\n  id: userPublishedDoc.id,\n  title: userPublishedDoc.title,\n  version: userPublishedDoc.version,\n  autoSync: userPublishedDoc.autoSync,\n  documentTree: JSON.stringify(userPublishedDoc.documentTree),\n  workspaceType: userPublishedDoc.workspaceType,\n  workspaceID: userPublishedDoc.workspaceID,\n  metadata: JSON.stringify(userPublishedDoc.metadata),\n  createdOn: userPublishedDoc.createdOn,\n  updatedOn: userPublishedDoc.updatedOn,\n  url: `${mockConfigService.get('VITE_BASE_URL')}/view/${userPublishedDoc.id}/${userPublishedDoc.version}`,\n};\n\nconst teamPublishedDoc: DBPublishedDocs = {\n  id: 'pub_doc_2',\n  title: 'Team API Documentation',\n  version: '1.0.0',\n  autoSync: true,\n  documentTree: {},\n  workspaceType: WorkspaceType.TEAM,\n  workspaceID: 'team_1',\n  collectionID: 'team_collection_1',\n  creatorUid: user.uid,\n  metadata: {},\n  createdOn: currentTime,\n  updatedOn: currentTime,\n};\n\nconst teamPublishedDocCasted: PublishedDocs = {\n  id: teamPublishedDoc.id,\n  title: teamPublishedDoc.title,\n  version: teamPublishedDoc.version,\n  autoSync: teamPublishedDoc.autoSync,\n  documentTree: JSON.stringify(teamPublishedDoc.documentTree),\n  workspaceType: teamPublishedDoc.workspaceType,\n  workspaceID: teamPublishedDoc.workspaceID,\n  metadata: JSON.stringify(teamPublishedDoc.metadata),\n  createdOn: teamPublishedDoc.createdOn,\n  updatedOn: teamPublishedDoc.updatedOn,\n  url: `${mockConfigService.get('VITE_BASE_URL')}/view/${teamPublishedDoc.id}/${teamPublishedDoc.version}`,\n};\n\nbeforeEach(() => {\n  mockReset(mockPrisma);\n});\n\ndescribe('getPublishedDocByID', () => {\n  test('should return a published document with valid ID and user access', async () => {\n    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n\n    const result = await publishedDocsService.getPublishedDocByID(\n      userPublishedDoc.id,\n      user,\n    );\n    expect(E.isRight(result)).toBe(true);\n    if (E.isRight(result)) {\n      expect(result.right).toMatchObject(userPublishedDocCasted);\n    }\n  });\n\n  test('should throw PUBLISHED_DOCS_NOT_FOUND when ID is invalid', async () => {\n    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);\n\n    const result = await publishedDocsService.getPublishedDocByID(\n      'invalid_id',\n      user,\n    );\n    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n  });\n\n  test('should throw PUBLISHED_DOCS_NOT_FOUND when user does not have access', async () => {\n    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({\n      ...userPublishedDoc,\n      creatorUid: 'different_user',\n    });\n\n    const result = await publishedDocsService.getPublishedDocByID(\n      userPublishedDoc.id,\n      user,\n    );\n    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n  });\n\n  test('should return team published document when user has team access', async () => {\n    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n\n    const result = await publishedDocsService.getPublishedDocByID(\n      teamPublishedDoc.id,\n      user,\n    );\n    expect(E.isRight(result)).toBe(true);\n    if (E.isRight(result)) {\n      expect(result.right).toMatchObject(teamPublishedDocCasted);\n    }\n  });\n\n  test('should throw PUBLISHED_DOCS_NOT_FOUND when user does not have team access', async () => {\n    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n    mockPrisma.team.findFirst.mockResolvedValueOnce(null);\n\n    const result = await publishedDocsService.getPublishedDocByID(\n      teamPublishedDoc.id,\n      user,\n    );\n    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n  });\n});\n\ndescribe('getAllUserPublishedDocs', () => {\n  test('should return a list of user published documents with pagination', async () => {\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([userPublishedDoc]);\n\n    const result = await publishedDocsService.getAllUserPublishedDocs(\n      user.uid,\n      { skip: 0, take: 10 },\n    );\n    expect(result).toHaveLength(1);\n    expect(result[0]).toMatchObject(userPublishedDocCasted);\n  });\n\n  test('should return an empty array when no documents found', async () => {\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);\n\n    const result = await publishedDocsService.getAllUserPublishedDocs(\n      user.uid,\n      { skip: 0, take: 10 },\n    );\n    expect(result).toEqual([]);\n  });\n\n  test('should return paginated results correctly', async () => {\n    const docs = [userPublishedDoc, { ...userPublishedDoc, id: 'pub_doc_3' }];\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([docs[0]]);\n\n    const result = await publishedDocsService.getAllUserPublishedDocs(\n      user.uid,\n      { skip: 0, take: 1 },\n    );\n    expect(result).toHaveLength(1);\n  });\n});\n\ndescribe('getAllTeamPublishedDocs', () => {\n  test('should return a list of team published documents with pagination', async () => {\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n\n    const result = await publishedDocsService.getAllTeamPublishedDocs(\n      'team_1',\n      'team_collection_1',\n      { skip: 0, take: 10 },\n    );\n    expect(result).toHaveLength(1);\n    expect(result[0]).toMatchObject(teamPublishedDocCasted);\n  });\n\n  test('should return an empty array when no team documents found', async () => {\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);\n\n    const result = await publishedDocsService.getAllTeamPublishedDocs(\n      'team_1',\n      'team_collection_1',\n      { skip: 0, take: 10 },\n    );\n    expect(result).toEqual([]);\n  });\n\n  test('should filter by teamID and collectionID correctly', async () => {\n    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n\n    await publishedDocsService.getAllTeamPublishedDocs(\n      'team_1',\n      'team_collection_1',\n      { skip: 0, take: 10 },\n    );\n\n    expect(mockPrisma.publishedDocs.findMany).toHaveBeenCalledWith({\n      where: {\n        workspaceType: WorkspaceType.TEAM,\n        workspaceID: 'team_1',\n        collectionID: 'team_collection_1',\n      },\n      skip: 0,\n      take: 10,\n      orderBy: {\n        createdOn: 'desc',\n      },\n    });\n  });\n});\n\ndescribe('createPublishedDoc', () => {\n  const createArgs: CreatePublishedDocsArgs = {\n    title: 'New API Documentation',\n    version: '1.0.0',\n    autoSync: true,\n    workspaceType: WorkspaceType.USER,\n    workspaceID: user.uid,\n    collectionID: 'collection_1',\n    metadata: '{}',\n  };\n\n  test('should successfully create a user published document with valid inputs', async () => {\n    mockPrisma.userCollection.findUnique.mockResolvedValueOnce({\n      id: 'collection_1',\n      userUid: user.uid,\n    } as any);\n    mockPrisma.publishedDocs.create.mockResolvedValueOnce(userPublishedDoc);\n\n    const result = await publishedDocsService.createPublishedDoc(\n      createArgs,\n      user,\n    );\n    expect(E.isRight(result)).toBe(true);\n    if (E.isRight(result)) {\n      expect(result.right).toMatchObject(userPublishedDocCasted);\n    }\n  });\n\n  test('should successfully create a team published document with valid inputs', async () => {\n    const teamArgs: CreatePublishedDocsArgs = {\n      ...createArgs,\n      workspaceType: WorkspaceType.TEAM,\n      workspaceID: 'team_1',\n      collectionID: 'team_collection_1',\n    };\n\n    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n    mockPrisma.teamCollection.findUnique.mockResolvedValueOnce({\n      id: 'team_collection_1',\n      teamID: 'team_1',\n    } as any);\n    mockPrisma.publishedDocs.create.mockResolvedValueOnce(teamPublishedDoc);\n\n    const result = await publishedDocsService.createPublishedDoc(\n      teamArgs,\n      user,\n    );\n    expect(E.isRight(result)).toBe(true);\n    if (E.isRight(result)) {\n      expect(result.right).toMatchObject(teamPublishedDocCasted);\n    }\n  });\n\n  test('should throw TEAM_INVALID_ID when team ID is invalid', async () => {\n    const teamArgs: CreatePublishedDocsArgs = {\n      ...createArgs,\n      workspaceType: WorkspaceType.TEAM,\n      workspaceID: '',\n    };\n\n    const result = await publishedDocsService.createPublishedDoc(\n      teamArgs,\n      user,\n    );\n    expect(result).toEqualLeft(TEAM_INVALID_ID);\n  });\n\n  test('should throw TEAM_INVALID_ID when user does not have team access', async () => {\n    const teamArgs: CreatePublishedDocsArgs = {\n      ...createArgs,\n      workspaceType: WorkspaceType.TEAM,\n      workspaceID: 'team_1',\n    };\n\n    mockPrisma.team.findFirst.mockResolvedValueOnce(null);\n\n    const result = await publishedDocsService.createPublishedDoc(\n      teamArgs,\n      user,\n    );\n    expect(result).toEqualLeft(TEAM_INVALID_ID);\n  });\n\n  test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when user collection is invalid', async () => {\n    mockPrisma.userCollection.findUnique.mockResolvedValueOnce(null);\n\n    const result = await publishedDocsService.createPublishedDoc(\n      createArgs,\n      user,\n    );\n    expect(result).toEqualLeft(PUBLISHED_DOCS_INVALID_COLLECTION);\n  });\n\n  test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when team collection is invalid', async () => {\n    const teamArgs: CreatePublishedDocsArgs = {\n      ...createArgs,\n      workspaceType: WorkspaceType.TEAM,\n      workspaceID: 'team_1',\n      collectionID: 'invalid_collection',\n    };\n\n    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n    mockPrisma.teamCollection.findUnique.mockResolvedValueOnce(null);\n\n    const result = await publishedDocsService.createPublishedDoc(\n      teamArgs,\n      user,\n    );\n    expect(result).toEqualLeft(PUBLISHED_DOCS_INVALID_COLLECTION);\n  });\n\n  test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when collection does not belong to user', async () => {\n    // When Prisma queries with",
            "cost": 0.180095
        },
        "hoppscotch__hoppscotch.main/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts": {
            "output": "import { Injectable } from '@nestjs/common';\nimport {\n  CreatePublishedDocsArgs,\n  UpdatePublishedDocsArgs,\n} from './input-type.args';\nimport { PrismaService } from 'src/prisma/prisma.service';\nimport { PublishedDocs as DbPublishedDocs } from 'src/generated/prisma/client';\nimport { TeamAccessRole } from 'src/team/team.model';\nimport { User } from 'src/user/user.model';\nimport { WorkspaceType } from 'src/types/WorkspaceTypes';\nimport {\n  PUBLISHED_DOCS_CREATION_FAILED,\n  PUBLISHED_DOCS_DELETION_FAILED,\n  PUBLISHED_DOCS_INVALID_COLLECTION,\n  PUBLISHED_DOCS_NOT_FOUND,\n  PUBLISHED_DOCS_UPDATE_FAILED,\n  TEAM_INVALID_ID,\n  USERS_NOT_FOUND,\n} from 'src/errors';\nimport * as E from 'fp-ts/Either';\nimport { PublishedDocs } from './published-docs.model';\nimport { OffsetPaginationArgs } from 'src/types/input-types.args';\nimport { stringToJson } from 'src/utils';\nimport { UserCollectionService } from 'src/user-collection/user-collection.service';\nimport { TeamCollectionService } from 'src/team-collection/team-collection.service';\nimport { GetPublishedDocsQueryDto, TreeLevel } from './published-docs.dto';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class PublishedDocsService {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly userCollectionService: UserCollectionService,\n    private readonly teamCollectionService: TeamCollectionService,\n    private readonly configService: ConfigService,\n  ) {}\n\n  /**\n   * Cast database PublishedDocs to GraphQL PublishedDocs\n   */\n  private cast(doc: DbPublishedDocs): PublishedDocs {\n    return {\n      ...doc,\n      documentTree: JSON.stringify(doc.documentTree),\n      metadata: JSON.stringify(doc.metadata),\n      url: `${this.configService.get('VITE_BASE_URL')}/view/${doc.id}/${doc.version}`,\n    };\n  }\n\n  /**\n   * Check if user has access to a team with specific roles\n   */\n  private async checkTeamAccess(\n    teamId: string,\n    userUid: string,\n    requiredRoles: TeamAccessRole[],\n  ): Promise<boolean> {\n    const team = await this.prisma.team.findFirst({\n      where: {\n        id: teamId,\n        members: {\n          some: { userUid, role: { in: requiredRoles } },\n        },\n      },\n    });\n    return team ? true : false;\n  }\n\n  /**\n   * Validate workspace access permission and existence\n   */\n  private async validateWorkspace(\n    user: User,\n    input: { workspaceType: WorkspaceType; workspaceID: string },\n  ) {\n    if (input.workspaceType === WorkspaceType.TEAM) {\n      if (!input.workspaceID) return E.left(TEAM_INVALID_ID);\n\n      const hasAccess = await this.checkTeamAccess(\n        input.workspaceID,\n        user.uid,\n        [TeamAccessRole.OWNER, TeamAccessRole.EDITOR],\n      );\n\n      if (!hasAccess) return E.left(TEAM_INVALID_ID);\n    }\n\n    return E.right(true);\n  }\n\n  /**\n   * Validate collection exists and user has access\n   */\n  private async validateCollection(\n    user: User,\n    input: {\n      workspaceType: WorkspaceType;\n      workspaceID: string;\n      collectionID: string;\n    },\n  ) {\n    if (input.workspaceType === WorkspaceType.TEAM) {\n      const collection = await this.prisma.teamCollection.findUnique({\n        where: { id: input.collectionID, teamID: input.workspaceID },\n      });\n      return collection\n        ? E.right(collection)\n        : E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n    } else if (input.workspaceType === WorkspaceType.USER) {\n      const collection = await this.prisma.userCollection.findUnique({\n        where: { id: input.collectionID, userUid: user.uid },\n      });\n      return collection\n        ? E.right(collection)\n        : E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n    }\n\n    return E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n  }\n\n  /**\n   * Check if user has access to a published docs with specific roles\n   */\n  async checkPublishedDocsAccess(\n    publishedDocs: DbPublishedDocs,\n    userUid: string,\n    requiredRoles: TeamAccessRole[] = [\n      TeamAccessRole.OWNER,\n      TeamAccessRole.EDITOR,\n      TeamAccessRole.VIEWER,\n    ],\n  ): Promise<boolean> {\n    if (publishedDocs.workspaceType === WorkspaceType.USER) {\n      return publishedDocs.creatorUid === userUid;\n    } else if (publishedDocs.workspaceType === WorkspaceType.TEAM) {\n      return this.checkTeamAccess(\n        publishedDocs.workspaceID,\n        userUid,\n        requiredRoles,\n      );\n    }\n    return false;\n  }\n\n  /**\n   * (Field resolver)\n   * Get the creator of a mock server\n   */\n  async getPublishedDocsCreator(id: string) {\n    const publishedDocs = await this.prisma.publishedDocs.findUnique({\n      where: { id },\n    });\n    if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n    const user = await this.prisma.user.findUnique({\n      where: { uid: publishedDocs.creatorUid },\n    });\n    if (!user) return E.left(USERS_NOT_FOUND);\n\n    return E.right(user);\n  }\n\n  /**\n   * (Field resolver)\n   * Get the collection of a published document\n   */\n  async getPublishedDocsCollection(id: string) {\n    const publishedDocs = await this.prisma.publishedDocs.findUnique({\n      where: { id },\n    });\n    if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n    if (publishedDocs.workspaceType === WorkspaceType.USER) {\n      const collection = await this.prisma.userCollection.findUnique({\n        where: { id: publishedDocs.collectionID },\n      });\n      if (!collection) return E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n      return E.right(collection);\n    } else if (publishedDocs.workspaceType === WorkspaceType.TEAM) {\n      const collection = await this.prisma.teamCollection.findUnique({\n        where: { id: publishedDocs.collectionID },\n      });\n      if (!collection) return E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n      return E.right(collection);\n    }\n\n    return E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n  }\n\n  /**\n   * Get a published document by ID\n   */\n  async getPublishedDocByID(id: string, user: User) {\n    const publishedDocs = await this.prisma.publishedDocs.findUnique({\n      where: { id },\n    });\n    if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n    // Check access permissions\n    const hasAccess = await this.checkPublishedDocsAccess(\n      publishedDocs,\n      user.uid,\n    );\n    if (!hasAccess) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n    return E.right(this.cast(publishedDocs));\n  }\n\n  /**\n   * Get a published document by ID for public access (unauthenticated)\n   * @param id - The ID of the published document\n   * @param query - Query parameters specifying tree level\n   */\n  async getPublishedDocByIDPublic(\n    id: string,\n    query: GetPublishedDocsQueryDto,\n  ): Promise<E.Either<string, PublishedDocs>> {\n    const publishedDocs = await this.prisma.publishedDocs.findUnique({\n      where: { id },\n    });\n    if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n    // if autoSync is enabled, fetch from the collection directly\n    if (publishedDocs.autoSync) {\n      const collectionResult =\n        publishedDocs.workspaceType === WorkspaceType.USER\n          ? await this.userCollectionService.exportUserCollectionToJSONObject(\n              publishedDocs.creatorUid,\n              publishedDocs.collectionID,\n              query.tree === TreeLevel.FULL,\n            )\n          : await this.teamCollectionService.exportCollectionToJSONObject(\n              publishedDocs.workspaceID,\n              publishedDocs.collectionID,\n              query.tree === TreeLevel.FULL,\n            );\n\n      if (E.isLeft(collectionResult)) return E.left(collectionResult.left);\n\n      return E.right(\n        this.cast({\n          ...publishedDocs,\n          documentTree: JSON.parse(JSON.stringify(collectionResult.right)),\n        }),\n      );\n    }\n\n    return E.right(this.cast(publishedDocs));\n  }\n\n  /**\n   * Get all published documents for a user with pagination\n   * @param userUid - The UID of the user\n   * @param args - Pagination arguments\n   */\n  async getAllUserPublishedDocs(userUid: string, args: OffsetPaginationArgs) {\n    const docs = await this.prisma.publishedDocs.findMany({\n      where: {\n        workspaceType: WorkspaceType.USER,\n        creatorUid: userUid,\n      },\n      skip: args.skip,\n      take: args.take,\n      orderBy: {\n        createdOn: 'desc',\n      },\n    });\n\n    return docs.map((doc) => this.cast(doc));\n  }\n\n  /**\n   * Get all published documents for a team and collection with pagination\n   */\n  async getAllTeamPublishedDocs(\n    teamID: string,\n    collectionID: string | undefined,\n    args: OffsetPaginationArgs,\n  ) {\n    const docs = await this.prisma.publishedDocs.findMany({\n      where: {\n        workspaceType: WorkspaceType.TEAM,\n        workspaceID: teamID,\n        collectionID: collectionID,\n      },\n      skip: args.skip,\n      take: args.take,\n      orderBy: {\n        createdOn: 'desc',\n      },\n    });\n\n    return docs.map((doc) => this.cast(doc));\n  }\n\n  /**\n   * Create a new published document\n   * @param args - Arguments for creating the published document\n   * @param user - The user creating the published document\n   */\n  async createPublishedDoc(args: CreatePublishedDocsArgs, user: User) {\n    try {\n      // Validate workspace type and ID\n      const workspaceValidation = await this.validateWorkspace(user, {\n        workspaceType: args.workspaceType,\n        workspaceID: args.workspaceID,\n      });\n      if (E.isLeft(workspaceValidation)) {\n        return E.left(workspaceValidation.left);\n      }\n\n      // Validate collection exists and user has access\n      const collectionValidation = await this.validateCollection(user, {\n        workspaceType: args.workspaceType,\n        workspaceID: args.workspaceID,\n        collectionID: args.collectionID,\n      });\n      if (E.isLeft(collectionValidation)) {\n        return E.left(collectionValidation.left);\n      }\n\n      // Parse metadata\n      const metadata = stringToJson(args.metadata);\n      if (E.isLeft(metadata)) return E.left(metadata.left);\n\n      // Create published document\n      const newPublishedDoc = await this.prisma.publishedDocs.create({\n        data: {\n          title: args.title,\n          collectionID: args.collectionID,\n          creatorUid: user.uid,\n          version: args.version,\n          autoSync: args.autoSync,\n          workspaceType: args.workspaceType,\n          workspaceID:\n            args.workspaceType === WorkspaceType.TEAM\n              ? args.workspaceID\n              : user.uid,\n          metadata: metadata.right,\n        },\n      });\n\n      return E.right(this.cast(newPublishedDoc));\n    } catch (error) {\n      console.error('Error creating published document:', error);\n      return E.left(PUBLISHED_DOCS_CREATION_FAILED);\n    }\n  }\n\n  /**\n   * Update an existing published document\n   * @param id - The ID of the published document to update\n   * @param args - Arguments for updating the published document\n   * @param user - The user updating the published document\n   */\n  async updatePublishedDoc(\n    id: string,\n    args: UpdatePublishedDocsArgs,\n    user: User,\n  ): Promise<E.Either<string, PublishedDocs>> {\n    try {\n      const publishedDocs = await this.prisma.publishedDocs.findUnique({\n        where: { id },\n      });\n      if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n      // Check access permissions based on workspace type (only OWNER and EDITOR can update)\n      const hasAccess = await this.checkPublishedDocsAccess(\n        publishedDocs,\n        user.uid,\n        [TeamAccessRole.OWNER, TeamAccessRole.EDITOR],\n      );\n      if (!hasAccess) return E.left(PUBLISHED_DOCS_UPDATE_FAILED);\n\n      //Parse metadata if provided\n      let metadata: E.Either<string, any>;\n      if (args.metadata) {\n        metadata = stringToJson(args.metadata);\n        if (E.isLeft(metadata)) return E.left(metadata.left);\n      }\n\n      // Update published document\n      const updatedPublishedDoc = await this.prisma.publishedDocs.update({\n        where: { id },\n        data: {\n          title: args.title,\n          version: args.version,\n          autoSync: args.autoSync,\n          metadata:\n            metadata && E.isRight(metadata) ? metadata.right : undefined,\n        },\n      });\n\n      return E.right(this.cast(updatedPublishedDoc));\n    } catch (error) {\n      console.error('Error updating published document:', error);\n      return E.left(PUBLISHED_DOCS_UPDATE_FAILED);\n    }\n  }\n\n  /** Delete a published document\n   * @param id - The ID of the published document to delete\n   * @param user - The user deleting the published document\n   */\n  async deletePublishedDoc(id: string, user: User) {\n    try {\n      const publishedDocs = await this.prisma.publishedDocs.findUnique({\n        where: { id },\n      });\n      if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n      // Check access permissions based on workspace type (only OWNER and EDITOR can update)\n      const hasAccess = await this.checkPublishedDocsAccess(\n        publishedDocs,\n        user.uid,\n        [TeamAccessRole.OWNER, TeamAccessRole.EDITOR],\n      );\n      if (!hasAccess) return E.left(PUBLISHED_DOCS_DELETION_FAILED);\n\n      await this.prisma.publishedDocs.delete({\n        where: { id },",
            "output_extracted": "import { Injectable } from '@nestjs/common';\nimport {\n  CreatePublishedDocsArgs,\n  UpdatePublishedDocsArgs,\n} from './input-type.args';\nimport { PrismaService } from 'src/prisma/prisma.service';\nimport { PublishedDocs as DbPublishedDocs } from 'src/generated/prisma/client';\nimport { TeamAccessRole } from 'src/team/team.model';\nimport { User } from 'src/user/user.model';\nimport { WorkspaceType } from 'src/types/WorkspaceTypes';\nimport {\n  PUBLISHED_DOCS_CREATION_FAILED,\n  PUBLISHED_DOCS_DELETION_FAILED,\n  PUBLISHED_DOCS_INVALID_COLLECTION,\n  PUBLISHED_DOCS_NOT_FOUND,\n  PUBLISHED_DOCS_UPDATE_FAILED,\n  TEAM_INVALID_ID,\n  USERS_NOT_FOUND,\n} from 'src/errors';\nimport * as E from 'fp-ts/Either';\nimport { PublishedDocs } from './published-docs.model';\nimport { OffsetPaginationArgs } from 'src/types/input-types.args';\nimport { stringToJson } from 'src/utils';\nimport { UserCollectionService } from 'src/user-collection/user-collection.service';\nimport { TeamCollectionService } from 'src/team-collection/team-collection.service';\nimport { GetPublishedDocsQueryDto, TreeLevel } from './published-docs.dto';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class PublishedDocsService {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly userCollectionService: UserCollectionService,\n    private readonly teamCollectionService: TeamCollectionService,\n    private readonly configService: ConfigService,\n  ) {}\n\n  /**\n   * Cast database PublishedDocs to GraphQL PublishedDocs\n   */\n  private cast(doc: DbPublishedDocs): PublishedDocs {\n    return {\n      ...doc,\n      documentTree: JSON.stringify(doc.documentTree),\n      metadata: JSON.stringify(doc.metadata),\n      url: `${this.configService.get('VITE_BASE_URL')}/view/${doc.id}/${doc.version}`,\n    };\n  }\n\n  /**\n   * Check if user has access to a team with specific roles\n   */\n  private async checkTeamAccess(\n    teamId: string,\n    userUid: string,\n    requiredRoles: TeamAccessRole[],\n  ): Promise<boolean> {\n    const team = await this.prisma.team.findFirst({\n      where: {\n        id: teamId,\n        members: {\n          some: { userUid, role: { in: requiredRoles } },\n        },\n      },\n    });\n    return team ? true : false;\n  }\n\n  /**\n   * Validate workspace access permission and existence\n   */\n  private async validateWorkspace(\n    user: User,\n    input: { workspaceType: WorkspaceType; workspaceID: string },\n  ) {\n    if (input.workspaceType === WorkspaceType.TEAM) {\n      if (!input.workspaceID) return E.left(TEAM_INVALID_ID);\n\n      const hasAccess = await this.checkTeamAccess(\n        input.workspaceID,\n        user.uid,\n        [TeamAccessRole.OWNER, TeamAccessRole.EDITOR],\n      );\n\n      if (!hasAccess) return E.left(TEAM_INVALID_ID);\n    }\n\n    return E.right(true);\n  }\n\n  /**\n   * Validate collection exists and user has access\n   */\n  private async validateCollection(\n    user: User,\n    input: {\n      workspaceType: WorkspaceType;\n      workspaceID: string;\n      collectionID: string;\n    },\n  ) {\n    if (input.workspaceType === WorkspaceType.TEAM) {\n      const collection = await this.prisma.teamCollection.findUnique({\n        where: { id: input.collectionID, teamID: input.workspaceID },\n      });\n      return collection\n        ? E.right(collection)\n        : E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n    } else if (input.workspaceType === WorkspaceType.USER) {\n      const collection = await this.prisma.userCollection.findUnique({\n        where: { id: input.collectionID, userUid: user.uid },\n      });\n      return collection\n        ? E.right(collection)\n        : E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n    }\n\n    return E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n  }\n\n  /**\n   * Check if user has access to a published docs with specific roles\n   */\n  async checkPublishedDocsAccess(\n    publishedDocs: DbPublishedDocs,\n    userUid: string,\n    requiredRoles: TeamAccessRole[] = [\n      TeamAccessRole.OWNER,\n      TeamAccessRole.EDITOR,\n      TeamAccessRole.VIEWER,\n    ],\n  ): Promise<boolean> {\n    if (publishedDocs.workspaceType === WorkspaceType.USER) {\n      return publishedDocs.creatorUid === userUid;\n    } else if (publishedDocs.workspaceType === WorkspaceType.TEAM) {\n      return this.checkTeamAccess(\n        publishedDocs.workspaceID,\n        userUid,\n        requiredRoles,\n      );\n    }\n    return false;\n  }\n\n  /**\n   * (Field resolver)\n   * Get the creator of a mock server\n   */\n  async getPublishedDocsCreator(id: string) {\n    const publishedDocs = await this.prisma.publishedDocs.findUnique({\n      where: { id },\n    });\n    if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n    const user = await this.prisma.user.findUnique({\n      where: { uid: publishedDocs.creatorUid },\n    });\n    if (!user) return E.left(USERS_NOT_FOUND);\n\n    return E.right(user);\n  }\n\n  /**\n   * (Field resolver)\n   * Get the collection of a published document\n   */\n  async getPublishedDocsCollection(id: string) {\n    const publishedDocs = await this.prisma.publishedDocs.findUnique({\n      where: { id },\n    });\n    if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n    if (publishedDocs.workspaceType === WorkspaceType.USER) {\n      const collection = await this.prisma.userCollection.findUnique({\n        where: { id: publishedDocs.collectionID },\n      });\n      if (!collection) return E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n      return E.right(collection);\n    } else if (publishedDocs.workspaceType === WorkspaceType.TEAM) {\n      const collection = await this.prisma.teamCollection.findUnique({\n        where: { id: publishedDocs.collectionID },\n      });\n      if (!collection) return E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n      return E.right(collection);\n    }\n\n    return E.left(PUBLISHED_DOCS_INVALID_COLLECTION);\n  }\n\n  /**\n   * Get a published document by ID\n   */\n  async getPublishedDocByID(id: string, user: User) {\n    const publishedDocs = await this.prisma.publishedDocs.findUnique({\n      where: { id },\n    });\n    if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n    // Check access permissions\n    const hasAccess = await this.checkPublishedDocsAccess(\n      publishedDocs,\n      user.uid,\n    );\n    if (!hasAccess) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n    return E.right(this.cast(publishedDocs));\n  }\n\n  /**\n   * Get a published document by ID for public access (unauthenticated)\n   * @param id - The ID of the published document\n   * @param query - Query parameters specifying tree level\n   */\n  async getPublishedDocByIDPublic(\n    id: string,\n    query: GetPublishedDocsQueryDto,\n  ): Promise<E.Either<string, PublishedDocs>> {\n    const publishedDocs = await this.prisma.publishedDocs.findUnique({\n      where: { id },\n    });\n    if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n    // if autoSync is enabled, fetch from the collection directly\n    if (publishedDocs.autoSync) {\n      const collectionResult =\n        publishedDocs.workspaceType === WorkspaceType.USER\n          ? await this.userCollectionService.exportUserCollectionToJSONObject(\n              publishedDocs.creatorUid,\n              publishedDocs.collectionID,\n              query.tree === TreeLevel.FULL,\n            )\n          : await this.teamCollectionService.exportCollectionToJSONObject(\n              publishedDocs.workspaceID,\n              publishedDocs.collectionID,\n              query.tree === TreeLevel.FULL,\n            );\n\n      if (E.isLeft(collectionResult)) return E.left(collectionResult.left);\n\n      return E.right(\n        this.cast({\n          ...publishedDocs,\n          documentTree: JSON.parse(JSON.stringify(collectionResult.right)),\n        }),\n      );\n    }\n\n    return E.right(this.cast(publishedDocs));\n  }\n\n  /**\n   * Get all published documents for a user with pagination\n   * @param userUid - The UID of the user\n   * @param args - Pagination arguments\n   */\n  async getAllUserPublishedDocs(userUid: string, args: OffsetPaginationArgs) {\n    const docs = await this.prisma.publishedDocs.findMany({\n      where: {\n        workspaceType: WorkspaceType.USER,\n        creatorUid: userUid,\n      },\n      skip: args.skip,\n      take: args.take,\n      orderBy: {\n        createdOn: 'desc',\n      },\n    });\n\n    return docs.map((doc) => this.cast(doc));\n  }\n\n  /**\n   * Get all published documents for a team and collection with pagination\n   */\n  async getAllTeamPublishedDocs(\n    teamID: string,\n    collectionID: string | undefined,\n    args: OffsetPaginationArgs,\n  ) {\n    const docs = await this.prisma.publishedDocs.findMany({\n      where: {\n        workspaceType: WorkspaceType.TEAM,\n        workspaceID: teamID,\n        collectionID: collectionID,\n      },\n      skip: args.skip,\n      take: args.take,\n      orderBy: {\n        createdOn: 'desc',\n      },\n    });\n\n    return docs.map((doc) => this.cast(doc));\n  }\n\n  /**\n   * Create a new published document\n   * @param args - Arguments for creating the published document\n   * @param user - The user creating the published document\n   */\n  async createPublishedDoc(args: CreatePublishedDocsArgs, user: User) {\n    try {\n      // Validate workspace type and ID\n      const workspaceValidation = await this.validateWorkspace(user, {\n        workspaceType: args.workspaceType,\n        workspaceID: args.workspaceID,\n      });\n      if (E.isLeft(workspaceValidation)) {\n        return E.left(workspaceValidation.left);\n      }\n\n      // Validate collection exists and user has access\n      const collectionValidation = await this.validateCollection(user, {\n        workspaceType: args.workspaceType,\n        workspaceID: args.workspaceID,\n        collectionID: args.collectionID,\n      });\n      if (E.isLeft(collectionValidation)) {\n        return E.left(collectionValidation.left);\n      }\n\n      // Parse metadata\n      const metadata = stringToJson(args.metadata);\n      if (E.isLeft(metadata)) return E.left(metadata.left);\n\n      // Create published document\n      const newPublishedDoc = await this.prisma.publishedDocs.create({\n        data: {\n          title: args.title,\n          collectionID: args.collectionID,\n          creatorUid: user.uid,\n          version: args.version,\n          autoSync: args.autoSync,\n          workspaceType: args.workspaceType,\n          workspaceID:\n            args.workspaceType === WorkspaceType.TEAM\n              ? args.workspaceID\n              : user.uid,\n          metadata: metadata.right,\n        },\n      });\n\n      return E.right(this.cast(newPublishedDoc));\n    } catch (error) {\n      console.error('Error creating published document:', error);\n      return E.left(PUBLISHED_DOCS_CREATION_FAILED);\n    }\n  }\n\n  /**\n   * Update an existing published document\n   * @param id - The ID of the published document to update\n   * @param args - Arguments for updating the published document\n   * @param user - The user updating the published document\n   */\n  async updatePublishedDoc(\n    id: string,\n    args: UpdatePublishedDocsArgs,\n    user: User,\n  ): Promise<E.Either<string, PublishedDocs>> {\n    try {\n      const publishedDocs = await this.prisma.publishedDocs.findUnique({\n        where: { id },\n      });\n      if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n      // Check access permissions based on workspace type (only OWNER and EDITOR can update)\n      const hasAccess = await this.checkPublishedDocsAccess(\n        publishedDocs,\n        user.uid,\n        [TeamAccessRole.OWNER, TeamAccessRole.EDITOR],\n      );\n      if (!hasAccess) return E.left(PUBLISHED_DOCS_UPDATE_FAILED);\n\n      //Parse metadata if provided\n      let metadata: E.Either<string, any>;\n      if (args.metadata) {\n        metadata = stringToJson(args.metadata);\n        if (E.isLeft(metadata)) return E.left(metadata.left);\n      }\n\n      // Update published document\n      const updatedPublishedDoc = await this.prisma.publishedDocs.update({\n        where: { id },\n        data: {\n          title: args.title,\n          version: args.version,\n          autoSync: args.autoSync,\n          metadata:\n            metadata && E.isRight(metadata) ? metadata.right : undefined,\n        },\n      });\n\n      return E.right(this.cast(updatedPublishedDoc));\n    } catch (error) {\n      console.error('Error updating published document:', error);\n      return E.left(PUBLISHED_DOCS_UPDATE_FAILED);\n    }\n  }\n\n  /** Delete a published document\n   * @param id - The ID of the published document to delete\n   * @param user - The user deleting the published document\n   */\n  async deletePublishedDoc(id: string, user: User) {\n    try {\n      const publishedDocs = await this.prisma.publishedDocs.findUnique({\n        where: { id },\n      });\n      if (!publishedDocs) return E.left(PUBLISHED_DOCS_NOT_FOUND);\n\n      // Check access permissions based on workspace type (only OWNER and EDITOR can update)\n      const hasAccess = await this.checkPublishedDocsAccess(\n        publishedDocs,\n        user.uid,\n        [TeamAccessRole.OWNER, TeamAccessRole.EDITOR],\n      );\n      if (!hasAccess) return E.left(PUBLISHED_DOCS_DELETION_FAILED);\n\n      await this.prisma.publishedDocs.delete({\n        where: { id },",
            "cost": 0.138525
        },
        "hoppscotch__hoppscotch.main/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts": {
            "output": "import { ConflictException, Injectable } from '@nestjs/common';\nimport {\n  USER_COLL_DEST_SAME,\n  USER_COLL_IS_PARENT_COLL,\n  USER_COLL_NOT_FOUND,\n  USER_COLL_NOT_SAME_TYPE,\n  USER_COLL_NOT_SAME_USER,\n  USER_COLL_REORDERING_FAILED,\n  USER_COLL_SAME_NEXT_COLL,\n  USER_COLL_SHORT_TITLE,\n  USER_COLL_ALREADY_ROOT,\n  USER_NOT_FOUND,\n  USER_NOT_OWNER,\n  USER_COLL_INVALID_JSON,\n  USER_COLL_DATA_INVALID,\n  USER_COLLECTION_CREATION_FAILED,\n} from 'src/errors';\nimport { PrismaService } from 'src/prisma/prisma.service';\nimport { AuthUser } from 'src/types/AuthUser';\nimport * as E from 'fp-ts/Either';\nimport * as O from 'fp-ts/Option';\nimport { PubSubService } from 'src/pubsub/pubsub.service';\nimport {\n  Prisma,\n  UserCollection,\n  ReqType as DBReqType,\n} from 'src/generated/prisma/client';\nimport {\n  UserCollection as UserCollectionModel,\n  UserCollectionExportJSONData,\n  UserCollectionDuplicatedData,\n} from './user-collections.model';\nimport { ReqType } from 'src/types/RequestTypes';\nimport {\n  delay,\n  isValidLength,\n  stringToJson,\n  transformCollectionData,\n} from 'src/utils';\nimport { CollectionFolder } from 'src/types/CollectionFolder';\nimport { PrismaError } from 'src/prisma/prisma-error-codes';\nimport { SortOptions } from 'src/types/SortOptions';\nimport { UserRequest } from 'src/user-request/user-request.model';\n\n@Injectable()\nexport class UserCollectionService {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly pubsub: PubSubService,\n  ) {}\n\n  TITLE_LENGTH = 1;\n  MAX_RETRIES = 5; // Maximum number of retries for database transactions\n\n  /**\n   * Typecast a database UserCollection to a UserCollection model\n   * @param userCollection database UserCollection\n   * @returns UserCollection model\n   */\n  private cast(collection: UserCollection) {\n    const data = transformCollectionData(collection.data);\n\n    return <UserCollectionModel>{\n      id: collection.id,\n      title: collection.title,\n      type: collection.type,\n      parentID: collection.parentID,\n      userID: collection.userUid,\n      data,\n    };\n  }\n\n  /**\n   * Check to see if Collection belongs to User\n   *\n   * @param collectionID The collection ID\n   * @param userID The User ID\n   * @returns An Option of a Boolean\n   */\n  private async isOwnerCheck(collectionID: string, userID: string) {\n    try {\n      await this.prisma.userCollection.findFirstOrThrow({\n        where: {\n          id: collectionID,\n          userUid: userID,\n        },\n      });\n\n      return O.some(true);\n    } catch (error) {\n      return O.none;\n    }\n  }\n\n  /**\n   * Get User of given Collection ID\n   *\n   * @param collectionID The collection ID\n   * @returns User of given Collection ID\n   */\n  async getUserOfCollection(collectionID: string) {\n    try {\n      const userCollection = await this.prisma.userCollection.findUniqueOrThrow(\n        {\n          where: {\n            id: collectionID,\n          },\n          include: {\n            user: true,\n          },\n        },\n      );\n      return E.right(userCollection.user);\n    } catch (error) {\n      return E.left(USER_NOT_FOUND);\n    }\n  }\n\n  /**\n   * Get parent of given Collection ID\n   *\n   * @param collectionID The collection ID\n   * @returns Parent UserCollection of given Collection ID\n   */\n  async getParentOfUserCollection(collectionID: string) {\n    const { parent } = await this.prisma.userCollection.findUnique({\n      where: {\n        id: collectionID,\n      },\n      include: {\n        parent: true,\n      },\n    });\n\n    return !parent ? null : this.cast(parent);\n  }\n\n  /**\n   * Get child collections of given Collection ID\n   *\n   * @param collectionID The collection ID\n   * @param cursor collectionID for pagination\n   * @param take Number of items we want returned\n   * @param type Type of UserCollection\n   * @returns A list of child collections\n   */\n  async getChildrenOfUserCollection(\n    collectionID: string,\n    cursor: string | null,\n    take: number,\n    type: ReqType,\n  ) {\n    const res = await this.prisma.userCollection.findMany({\n      where: {\n        parentID: collectionID,\n        type: type,\n      },\n      orderBy: {\n        orderIndex: 'asc',\n      },\n      take: take, // default: 10\n      skip: cursor ? 1 : 0,\n      cursor: cursor ? { id: cursor } : undefined,\n    });\n\n    const childCollections = res.map((childCollection) =>\n      this.cast(childCollection),\n    );\n\n    return childCollections;\n  }\n\n  /**\n   * Get collection details\n   *\n   * @param collectionID The collection ID\n   * @returns An Either of the Collection details\n   */\n  async getUserCollection(collectionID: string) {\n    try {\n      const userCollection = await this.prisma.userCollection.findUniqueOrThrow(\n        { where: { id: collectionID } },\n      );\n      return E.right(userCollection);\n    } catch (error) {\n      return E.left(USER_COLL_NOT_FOUND);\n    }\n  }\n\n  /**\n   * Create a new UserCollection\n   *\n   * @param user The User object\n   * @param title The title of new UserCollection\n   * @param parentID The parent collectionID (null if root collection)\n   * @param type Type of Collection we want to create (REST/GQL)\n   * @returns\n   */\n  async createUserCollection(\n    user: AuthUser,\n    title: string,\n    data: string | null = null,\n    parentID: string | null,\n    type: ReqType,\n  ) {\n    const isTitleValid = isValidLength(title, this.TITLE_LENGTH);\n    if (!isTitleValid) return E.left(USER_COLL_SHORT_TITLE);\n\n    if (data === '') return E.left(USER_COLL_DATA_INVALID);\n    if (data) {\n      const jsonReq = stringToJson(data);\n      if (E.isLeft(jsonReq)) return E.left(USER_COLL_DATA_INVALID);\n      data = jsonReq.right;\n    }\n\n    // If creating a child collection\n    if (parentID !== null) {\n      const parentCollection = await this.getUserCollection(parentID);\n      if (E.isLeft(parentCollection)) return E.left(parentCollection.left);\n\n      // Check to see if parentUserCollectionID belongs to this User\n      if (parentCollection.right.userUid !== user.uid)\n        return E.left(USER_NOT_OWNER);\n\n      // Check to see if parent collection is of the same type of new collection being created\n      if (parentCollection.right.type !== type)\n        return E.left(USER_COLL_NOT_SAME_TYPE);\n    }\n\n    let userCollection: UserCollection = null;\n    try {\n      userCollection = await this.prisma.$transaction(async (tx) => {\n        try {\n          // lock the rows\n          await this.prisma.lockTableExclusive(tx, 'UserCollection');\n\n          // fetch last user collection\n          const lastUserCollection = await tx.userCollection.findFirst({\n            where: { userUid: user.uid, parentID },\n            orderBy: { orderIndex: 'desc' },\n            select: { orderIndex: true },\n          });\n\n          // create new user collection\n          return tx.userCollection.create({\n            data: {\n              title: title,\n              type: type,\n              user: { connect: { uid: user.uid } },\n              parent: parentID ? { connect: { id: parentID } } : undefined,\n              data: data ?? undefined,\n              orderIndex: lastUserCollection\n                ? lastUserCollection.orderIndex + 1\n                : 1,\n            },\n          });\n        } catch (error) {\n          throw new ConflictException(error);\n        }\n      });\n    } catch (error) {\n      console.error(\n        'Error from UserCollectionService.createUserCollection',\n        error,\n      );\n      return E.left(USER_COLLECTION_CREATION_FAILED);\n    }\n\n    await this.pubsub.publish(\n      `user_coll/${user.uid}/created`,\n      this.cast(userCollection),\n    );\n\n    return E.right(this.cast(userCollection));\n  }\n\n  /**\n   *\n   * @param user The User Object\n   * @param cursor collectionID for pagination\n   * @param take Number of items we want returned\n   * @param type Type of UserCollection\n   * @returns A list of root UserCollections\n   */\n  async getUserRootCollections(\n    user: AuthUser,\n    cursor: string | null,\n    take: number,\n    type: ReqType,\n  ) {\n    const res = await this.prisma.userCollection.findMany({\n      where: {\n        userUid: user.uid,\n        parentID: null,\n        type: type,\n      },\n      orderBy: {\n        orderIndex: 'asc',\n      },\n      take: take, // default: 10\n      skip: cursor ? 1 : 0,\n      cursor: cursor ? { id: cursor } : undefined,\n    });\n\n    const userCollections = res.map((childCollection) =>\n      this.cast(childCollection),\n    );\n\n    return userCollections;\n  }\n\n  /**\n   *\n   * @param user The User Object\n   * @param userCollectionID The User UID\n   * @param cursor collectionID for pagination\n   * @param take Number of items we want returned\n   * @param type Type of UserCollection\n   * @returns A list of child UserCollections\n   */\n  async getUserChildCollections(\n    user: AuthUser,\n    userCollectionID: string,\n    cursor: string | null,\n    take: number,\n    type: ReqType,\n  ) {\n    const res = await this.prisma.userCollection.findMany({\n      where: {\n        userUid: user.uid,\n        parentID: userCollectionID,\n        type: type,\n      },\n      take: take, // default: 10\n      skip: cursor ? 1 : 0,\n      cursor: cursor ? { id: cursor } : undefined,\n    });\n\n    const childCollections = res.map((childCollection) =>\n      this.cast(childCollection),\n    );\n\n    return childCollections;\n  }\n\n  /**\n   * @deprecated Use updateUserCollection method instead\n   * Update the title of a UserCollection\n   *\n   * @param newTitle The new title of collection\n   * @param userCollectionID The Collection Id\n   * @param userID The User UID\n   * @returns An Either of the updated UserCollection\n   */\n  async renameUserCollection(\n    newTitle: string,\n    userCollectionID: string,\n    userID: string,\n  ) {\n    const isTitleValid = isValidLength(newTitle, this.TITLE_LENGTH);\n    if (!isTitleValid) return E.left(USER_COLL_SHORT_TITLE);\n\n    // Check to see is the collection belongs to the user\n    const isOwner = await this.isOwnerCheck(userCollectionID, userID);\n    if (O.isNone(isOwner)) return E.left(USER_NOT_OWNER);\n\n    try {\n      const updatedUserCollection = await this.prisma.userCollection.update({\n        where: { id: userCollectionID },\n        data: { title: newTitle },\n      });\n\n      this.pubsub.publish(\n        `user_coll/${updatedUserCollection.userUid}/updated`,\n        this.cast(updatedUserCollection),\n      );\n\n      return E.right(this.cast(updatedUserCollection));\n    } catch (error) {\n      return E.left(USER_COLL_NOT_FOUND);\n    }\n  }\n\n  /**\n   * Delete child collection and requests of a UserCollection\n   *\n   * @param collectionID The Collection Id\n   * @returns A Boolean of deletion status\n   */\n  private async deleteCollectionData(collection: UserCollection) {\n    // Get all child collections in collectionID\n    const childCollectionList = await this.prisma.userCollection.findMany({\n      where: {\n        parentID: collection.id,\n      },\n    });\n\n    // Delete child collections\n    await Promise.all(\n      childCollectionList.map((coll) =>\n        this.deleteUserCollection(coll.id, coll.userUid),\n      ),\n    );\n\n    // Delete all requests in collectionID\n    await this.prisma.userRequest.deleteMany({\n      where: {\n        collectionID: collection.id,\n      },\n    });\n\n    // Update orderIndexes in userCollection table for user\n    const isDeleted = await this.removeCollectionAndUpdateSiblingsOrderIndex(\n      collection,\n      { gt: collection.orderIndex },\n      { decrement: 1 },\n    );\n    if (E.isLeft(isDeleted)) return E.left(isDeleted.left);\n\n    this.pubsub.publish(`user_coll/${collection.userUid}/deleted`, {\n      id: collection.id,\n      type: ReqType[collection.type],\n    });\n\n    return E.right(true);\n  }\n\n  /**\n   * Delete a UserCollection\n   *\n   * @param collectionID The Collection Id\n   * @param userID The User UID\n   * @returns An Either of Boolean of deletion status\n   */\n  async deleteUserCollection(collectionID: string, userID: string) {\n    // Get collection details of collectionID\n    const collection = await this.getUserCollection(collectionID);\n    if (E.isLeft(collection)) return E.left(USER_COLL_NOT_FOUND);\n\n    // Check to see is the collection belongs to the user\n    if (collection.right.userUid !== userID) return E.left(USER_NOT_OWNER);\n\n    // Delete all child collections and requests in the collection\n    const collectionData = await this.deleteCollectionData(collection.right);\n    if (E.isLeft(collectionData)) return E.left(collectionData.left);\n\n    return E.right(true);\n  }\n\n  /**\n   * Change parentID of UserCollection's\n\n   * @param collection The collection that is being moved\n   * @param newParentID The new parent's collection ID or change to root collection\n   * @returns If successful return an Either of collection or error message\n   */\n  private async changeParentAndUpdateOrderIndex(\n    collection: UserCollection,\n    newParentID: string | null,\n  ) {\n    let updatedCollection: UserCollection = null;\n\n    try {\n      await this.prisma.$transaction(async (tx) => {\n        try {\n          // fetch last collection\n          const lastCollectionUnderNewParent =\n            await tx.userCollection.findFirst({\n              where: { userUid: collection.userUid, parentID: newParentID },\n              orderBy: { orderIndex: 'desc' },\n            });\n\n          // update collection's parentID and orderIndex\n          updatedCollection = await tx.userCollection.update({\n            where: { id: collection.id },\n            data: {\n              // if parentCollectionID == null, collection becomes root collection\n              // if parentCollectionID != null, collection becomes child collection\n              parentID: newParentID,\n              orderIndex: lastCollectionUnderNewParent\n                ? lastCollectionUnderNewPar",
            "output_extracted": "import { ConflictException, Injectable } from '@nestjs/common';\nimport {\n  USER_COLL_DEST_SAME,\n  USER_COLL_IS_PARENT_COLL,\n  USER_COLL_NOT_FOUND,\n  USER_COLL_NOT_SAME_TYPE,\n  USER_COLL_NOT_SAME_USER,\n  USER_COLL_REORDERING_FAILED,\n  USER_COLL_SAME_NEXT_COLL,\n  USER_COLL_SHORT_TITLE,\n  USER_COLL_ALREADY_ROOT,\n  USER_NOT_FOUND,\n  USER_NOT_OWNER,\n  USER_COLL_INVALID_JSON,\n  USER_COLL_DATA_INVALID,\n  USER_COLLECTION_CREATION_FAILED,\n} from 'src/errors';\nimport { PrismaService } from 'src/prisma/prisma.service';\nimport { AuthUser } from 'src/types/AuthUser';\nimport * as E from 'fp-ts/Either';\nimport * as O from 'fp-ts/Option';\nimport { PubSubService } from 'src/pubsub/pubsub.service';\nimport {\n  Prisma,\n  UserCollection,\n  ReqType as DBReqType,\n} from 'src/generated/prisma/client';\nimport {\n  UserCollection as UserCollectionModel,\n  UserCollectionExportJSONData,\n  UserCollectionDuplicatedData,\n} from './user-collections.model';\nimport { ReqType } from 'src/types/RequestTypes';\nimport {\n  delay,\n  isValidLength,\n  stringToJson,\n  transformCollectionData,\n} from 'src/utils';\nimport { CollectionFolder } from 'src/types/CollectionFolder';\nimport { PrismaError } from 'src/prisma/prisma-error-codes';\nimport { SortOptions } from 'src/types/SortOptions';\nimport { UserRequest } from 'src/user-request/user-request.model';\n\n@Injectable()\nexport class UserCollectionService {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly pubsub: PubSubService,\n  ) {}\n\n  TITLE_LENGTH = 1;\n  MAX_RETRIES = 5; // Maximum number of retries for database transactions\n\n  /**\n   * Typecast a database UserCollection to a UserCollection model\n   * @param userCollection database UserCollection\n   * @returns UserCollection model\n   */\n  private cast(collection: UserCollection) {\n    const data = transformCollectionData(collection.data);\n\n    return <UserCollectionModel>{\n      id: collection.id,\n      title: collection.title,\n      type: collection.type,\n      parentID: collection.parentID,\n      userID: collection.userUid,\n      data,\n    };\n  }\n\n  /**\n   * Check to see if Collection belongs to User\n   *\n   * @param collectionID The collection ID\n   * @param userID The User ID\n   * @returns An Option of a Boolean\n   */\n  private async isOwnerCheck(collectionID: string, userID: string) {\n    try {\n      await this.prisma.userCollection.findFirstOrThrow({\n        where: {\n          id: collectionID,\n          userUid: userID,\n        },\n      });\n\n      return O.some(true);\n    } catch (error) {\n      return O.none;\n    }\n  }\n\n  /**\n   * Get User of given Collection ID\n   *\n   * @param collectionID The collection ID\n   * @returns User of given Collection ID\n   */\n  async getUserOfCollection(collectionID: string) {\n    try {\n      const userCollection = await this.prisma.userCollection.findUniqueOrThrow(\n        {\n          where: {\n            id: collectionID,\n          },\n          include: {\n            user: true,\n          },\n        },\n      );\n      return E.right(userCollection.user);\n    } catch (error) {\n      return E.left(USER_NOT_FOUND);\n    }\n  }\n\n  /**\n   * Get parent of given Collection ID\n   *\n   * @param collectionID The collection ID\n   * @returns Parent UserCollection of given Collection ID\n   */\n  async getParentOfUserCollection(collectionID: string) {\n    const { parent } = await this.prisma.userCollection.findUnique({\n      where: {\n        id: collectionID,\n      },\n      include: {\n        parent: true,\n      },\n    });\n\n    return !parent ? null : this.cast(parent);\n  }\n\n  /**\n   * Get child collections of given Collection ID\n   *\n   * @param collectionID The collection ID\n   * @param cursor collectionID for pagination\n   * @param take Number of items we want returned\n   * @param type Type of UserCollection\n   * @returns A list of child collections\n   */\n  async getChildrenOfUserCollection(\n    collectionID: string,\n    cursor: string | null,\n    take: number,\n    type: ReqType,\n  ) {\n    const res = await this.prisma.userCollection.findMany({\n      where: {\n        parentID: collectionID,\n        type: type,\n      },\n      orderBy: {\n        orderIndex: 'asc',\n      },\n      take: take, // default: 10\n      skip: cursor ? 1 : 0,\n      cursor: cursor ? { id: cursor } : undefined,\n    });\n\n    const childCollections = res.map((childCollection) =>\n      this.cast(childCollection),\n    );\n\n    return childCollections;\n  }\n\n  /**\n   * Get collection details\n   *\n   * @param collectionID The collection ID\n   * @returns An Either of the Collection details\n   */\n  async getUserCollection(collectionID: string) {\n    try {\n      const userCollection = await this.prisma.userCollection.findUniqueOrThrow(\n        { where: { id: collectionID } },\n      );\n      return E.right(userCollection);\n    } catch (error) {\n      return E.left(USER_COLL_NOT_FOUND);\n    }\n  }\n\n  /**\n   * Create a new UserCollection\n   *\n   * @param user The User object\n   * @param title The title of new UserCollection\n   * @param parentID The parent collectionID (null if root collection)\n   * @param type Type of Collection we want to create (REST/GQL)\n   * @returns\n   */\n  async createUserCollection(\n    user: AuthUser,\n    title: string,\n    data: string | null = null,\n    parentID: string | null,\n    type: ReqType,\n  ) {\n    const isTitleValid = isValidLength(title, this.TITLE_LENGTH);\n    if (!isTitleValid) return E.left(USER_COLL_SHORT_TITLE);\n\n    if (data === '') return E.left(USER_COLL_DATA_INVALID);\n    if (data) {\n      const jsonReq = stringToJson(data);\n      if (E.isLeft(jsonReq)) return E.left(USER_COLL_DATA_INVALID);\n      data = jsonReq.right;\n    }\n\n    // If creating a child collection\n    if (parentID !== null) {\n      const parentCollection = await this.getUserCollection(parentID);\n      if (E.isLeft(parentCollection)) return E.left(parentCollection.left);\n\n      // Check to see if parentUserCollectionID belongs to this User\n      if (parentCollection.right.userUid !== user.uid)\n        return E.left(USER_NOT_OWNER);\n\n      // Check to see if parent collection is of the same type of new collection being created\n      if (parentCollection.right.type !== type)\n        return E.left(USER_COLL_NOT_SAME_TYPE);\n    }\n\n    let userCollection: UserCollection = null;\n    try {\n      userCollection = await this.prisma.$transaction(async (tx) => {\n        try {\n          // lock the rows\n          await this.prisma.lockTableExclusive(tx, 'UserCollection');\n\n          // fetch last user collection\n          const lastUserCollection = await tx.userCollection.findFirst({\n            where: { userUid: user.uid, parentID },\n            orderBy: { orderIndex: 'desc' },\n            select: { orderIndex: true },\n          });\n\n          // create new user collection\n          return tx.userCollection.create({\n            data: {\n              title: title,\n              type: type,\n              user: { connect: { uid: user.uid } },\n              parent: parentID ? { connect: { id: parentID } } : undefined,\n              data: data ?? undefined,\n              orderIndex: lastUserCollection\n                ? lastUserCollection.orderIndex + 1\n                : 1,\n            },\n          });\n        } catch (error) {\n          throw new ConflictException(error);\n        }\n      });\n    } catch (error) {\n      console.error(\n        'Error from UserCollectionService.createUserCollection',\n        error,\n      );\n      return E.left(USER_COLLECTION_CREATION_FAILED);\n    }\n\n    await this.pubsub.publish(\n      `user_coll/${user.uid}/created`,\n      this.cast(userCollection),\n    );\n\n    return E.right(this.cast(userCollection));\n  }\n\n  /**\n   *\n   * @param user The User Object\n   * @param cursor collectionID for pagination\n   * @param take Number of items we want returned\n   * @param type Type of UserCollection\n   * @returns A list of root UserCollections\n   */\n  async getUserRootCollections(\n    user: AuthUser,\n    cursor: string | null,\n    take: number,\n    type: ReqType,\n  ) {\n    const res = await this.prisma.userCollection.findMany({\n      where: {\n        userUid: user.uid,\n        parentID: null,\n        type: type,\n      },\n      orderBy: {\n        orderIndex: 'asc',\n      },\n      take: take, // default: 10\n      skip: cursor ? 1 : 0,\n      cursor: cursor ? { id: cursor } : undefined,\n    });\n\n    const userCollections = res.map((childCollection) =>\n      this.cast(childCollection),\n    );\n\n    return userCollections;\n  }\n\n  /**\n   *\n   * @param user The User Object\n   * @param userCollectionID The User UID\n   * @param cursor collectionID for pagination\n   * @param take Number of items we want returned\n   * @param type Type of UserCollection\n   * @returns A list of child UserCollections\n   */\n  async getUserChildCollections(\n    user: AuthUser,\n    userCollectionID: string,\n    cursor: string | null,\n    take: number,\n    type: ReqType,\n  ) {\n    const res = await this.prisma.userCollection.findMany({\n      where: {\n        userUid: user.uid,\n        parentID: userCollectionID,\n        type: type,\n      },\n      take: take, // default: 10\n      skip: cursor ? 1 : 0,\n      cursor: cursor ? { id: cursor } : undefined,\n    });\n\n    const childCollections = res.map((childCollection) =>\n      this.cast(childCollection),\n    );\n\n    return childCollections;\n  }\n\n  /**\n   * @deprecated Use updateUserCollection method instead\n   * Update the title of a UserCollection\n   *\n   * @param newTitle The new title of collection\n   * @param userCollectionID The Collection Id\n   * @param userID The User UID\n   * @returns An Either of the updated UserCollection\n   */\n  async renameUserCollection(\n    newTitle: string,\n    userCollectionID: string,\n    userID: string,\n  ) {\n    const isTitleValid = isValidLength(newTitle, this.TITLE_LENGTH);\n    if (!isTitleValid) return E.left(USER_COLL_SHORT_TITLE);\n\n    // Check to see is the collection belongs to the user\n    const isOwner = await this.isOwnerCheck(userCollectionID, userID);\n    if (O.isNone(isOwner)) return E.left(USER_NOT_OWNER);\n\n    try {\n      const updatedUserCollection = await this.prisma.userCollection.update({\n        where: { id: userCollectionID },\n        data: { title: newTitle },\n      });\n\n      this.pubsub.publish(\n        `user_coll/${updatedUserCollection.userUid}/updated`,\n        this.cast(updatedUserCollection),\n      );\n\n      return E.right(this.cast(updatedUserCollection));\n    } catch (error) {\n      return E.left(USER_COLL_NOT_FOUND);\n    }\n  }\n\n  /**\n   * Delete child collection and requests of a UserCollection\n   *\n   * @param collectionID The Collection Id\n   * @returns A Boolean of deletion status\n   */\n  private async deleteCollectionData(collection: UserCollection) {\n    // Get all child collections in collectionID\n    const childCollectionList = await this.prisma.userCollection.findMany({\n      where: {\n        parentID: collection.id,\n      },\n    });\n\n    // Delete child collections\n    await Promise.all(\n      childCollectionList.map((coll) =>\n        this.deleteUserCollection(coll.id, coll.userUid),\n      ),\n    );\n\n    // Delete all requests in collectionID\n    await this.prisma.userRequest.deleteMany({\n      where: {\n        collectionID: collection.id,\n      },\n    });\n\n    // Update orderIndexes in userCollection table for user\n    const isDeleted = await this.removeCollectionAndUpdateSiblingsOrderIndex(\n      collection,\n      { gt: collection.orderIndex },\n      { decrement: 1 },\n    );\n    if (E.isLeft(isDeleted)) return E.left(isDeleted.left);\n\n    this.pubsub.publish(`user_coll/${collection.userUid}/deleted`, {\n      id: collection.id,\n      type: ReqType[collection.type],\n    });\n\n    return E.right(true);\n  }\n\n  /**\n   * Delete a UserCollection\n   *\n   * @param collectionID The Collection Id\n   * @param userID The User UID\n   * @returns An Either of Boolean of deletion status\n   */\n  async deleteUserCollection(collectionID: string, userID: string) {\n    // Get collection details of collectionID\n    const collection = await this.getUserCollection(collectionID);\n    if (E.isLeft(collection)) return E.left(USER_COLL_NOT_FOUND);\n\n    // Check to see is the collection belongs to the user\n    if (collection.right.userUid !== userID) return E.left(USER_NOT_OWNER);\n\n    // Delete all child collections and requests in the collection\n    const collectionData = await this.deleteCollectionData(collection.right);\n    if (E.isLeft(collectionData)) return E.left(collectionData.left);\n\n    return E.right(true);\n  }\n\n  /**\n   * Change parentID of UserCollection's\n\n   * @param collection The collection that is being moved\n   * @param newParentID The new parent's collection ID or change to root collection\n   * @returns If successful return an Either of collection or error message\n   */\n  private async changeParentAndUpdateOrderIndex(\n    collection: UserCollection,\n    newParentID: string | null,\n  ) {\n    let updatedCollection: UserCollection = null;\n\n    try {\n      await this.prisma.$transaction(async (tx) => {\n        try {\n          // fetch last collection\n          const lastCollectionUnderNewParent =\n            await tx.userCollection.findFirst({\n              where: { userUid: collection.userUid, parentID: newParentID },\n              orderBy: { orderIndex: 'desc' },\n            });\n\n          // update collection's parentID and orderIndex\n          updatedCollection = await tx.userCollection.update({\n            where: { id: collection.id },\n            data: {\n              // if parentCollectionID == null, collection becomes root collection\n              // if parentCollectionID != null, collection becomes child collection\n              parentID: newParentID,\n              orderIndex: lastCollectionUnderNewParent\n                ? lastCollectionUnderNewPar",
            "cost": 0.16901
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "hoppscotch__hoppscotch.main.5624",
        "repo": "hoppscotch/hoppscotch",
        "base_commit": "217563e7ddf63ef83eea2b27762ea0d2113b8d2e",
        "head_commit": "0a70615eab82ef724121c7620ec57f405fe65627",
        "title": "hotfix: clean up published docs with deleted collections",
        "merged_at": "2025-12-02T08:07:08Z",
        "html_url": "https://github.com/hoppscotch/hoppscotch/pull/5624",
        "test_files": [
            "packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts"
        ],
        "code_files": [
            "packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts",
            "packages/hoppscotch-backend/src/published-docs/published-docs.service.ts",
            "packages/hoppscotch-backend/src/user-collection/user-collection.service.ts"
        ],
        "total_changes": 294,
        "num_files": 4,
        "pull_number": 5624,
        "patch": "diff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts\nindex 0f038bd6ba..11e72ec2c8 100644\n--- a/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts\n+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts\n@@ -34,6 +34,7 @@ export class PublishedDocsResolver {\n \n   @ResolveField(() => User, {\n     description: 'Returns the creator of the published document',\n+    nullable: true,\n   })\n   async creator(@Parent() publishedDocs: PublishedDocs): Promise<User> {\n     const creator = await this.publishedDocsService.getPublishedDocsCreator(\n@@ -41,11 +42,7 @@ export class PublishedDocsResolver {\n     );\n \n     if (E.isLeft(creator)) throwErr(creator.left);\n-    return {\n-      ...creator.right,\n-      currentGQLSession: JSON.stringify(creator.right.currentGQLSession),\n-      currentRESTSession: JSON.stringify(creator.right.currentRESTSession),\n-    };\n+    return creator.right;\n   }\n \n   @ResolveField(() => PublishedDocsCollection, {\ndiff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts\nindex 624517fb83..e532eb6194 100644\n--- a/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts\n+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts\n@@ -47,8 +47,8 @@ const user: User = {\n   lastLoggedOn: currentTime,\n   lastActiveOn: currentTime,\n   createdOn: currentTime,\n-  currentGQLSession: JSON.stringify({}),\n-  currentRESTSession: JSON.stringify({}),\n+  currentGQLSession: {} as any,\n+  currentRESTSession: {} as any,\n };\n \n const userPublishedDoc: DBPublishedDocs = {\n@@ -179,6 +179,9 @@ describe('getPublishedDocByID', () => {\n describe('getAllUserPublishedDocs', () => {\n   test('should return a list of user published documents with pagination', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([userPublishedDoc]);\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n+      { id: 'collection_1' },\n+    ] as any);\n \n     const result = await publishedDocsService.getAllUserPublishedDocs(\n       user.uid,\n@@ -190,6 +193,7 @@ describe('getAllUserPublishedDocs', () => {\n \n   test('should return an empty array when no documents found', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([]);\n \n     const result = await publishedDocsService.getAllUserPublishedDocs(\n       user.uid,\n@@ -201,6 +205,9 @@ describe('getAllUserPublishedDocs', () => {\n   test('should return paginated results correctly', async () => {\n     const docs = [userPublishedDoc, { ...userPublishedDoc, id: 'pub_doc_3' }];\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([docs[0]]);\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n+      { id: 'collection_1' },\n+    ] as any);\n \n     const result = await publishedDocsService.getAllUserPublishedDocs(\n       user.uid,\n@@ -208,11 +215,94 @@ describe('getAllUserPublishedDocs', () => {\n     );\n     expect(result).toHaveLength(1);\n   });\n+\n+  test('should filter out published docs with non-existent collections', async () => {\n+    const doc1 = {\n+      ...userPublishedDoc,\n+      id: 'pub_doc_1',\n+      collectionID: 'collection_1',\n+    };\n+    const doc2 = {\n+      ...userPublishedDoc,\n+      id: 'pub_doc_2',\n+      collectionID: 'collection_2',\n+    };\n+    const doc3 = {\n+      ...userPublishedDoc,\n+      id: 'pub_doc_3',\n+      collectionID: 'collection_3',\n+    };\n+\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2, doc3]);\n+    // Only collection_1 and collection_3 exist\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n+      { id: 'collection_1' },\n+      { id: 'collection_3' },\n+    ] as any);\n+\n+    const result = await publishedDocsService.getAllUserPublishedDocs(\n+      user.uid,\n+      { skip: 0, take: 10 },\n+    );\n+\n+    // Should only return docs with existing collections\n+    expect(result).toHaveLength(2);\n+    expect(result.map((d) => d.id)).toEqual(['pub_doc_1', 'pub_doc_3']);\n+  });\n+\n+  test('should delete published docs with non-existent collections', async () => {\n+    const doc1 = {\n+      ...userPublishedDoc,\n+      id: 'pub_doc_1',\n+      collectionID: 'collection_1',\n+    };\n+    const doc2 = {\n+      ...userPublishedDoc,\n+      id: 'pub_doc_2',\n+      collectionID: 'collection_deleted',\n+    };\n+\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2]);\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n+      { id: 'collection_1' },\n+    ] as any);\n+    mockPrisma.publishedDocs.deleteMany.mockResolvedValueOnce({\n+      count: 1,\n+    } as any);\n+\n+    await publishedDocsService.getAllUserPublishedDocs(user.uid, {\n+      skip: 0,\n+      take: 10,\n+    });\n+\n+    expect(mockPrisma.publishedDocs.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        id: { in: ['pub_doc_2'] },\n+      },\n+    });\n+  });\n+\n+  test('should not call deleteMany when all collections exist', async () => {\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([userPublishedDoc]);\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n+      { id: 'collection_1' },\n+    ] as any);\n+\n+    await publishedDocsService.getAllUserPublishedDocs(user.uid, {\n+      skip: 0,\n+      take: 10,\n+    });\n+\n+    expect(mockPrisma.publishedDocs.deleteMany).not.toHaveBeenCalled();\n+  });\n });\n \n describe('getAllTeamPublishedDocs', () => {\n   test('should return a list of team published documents with pagination', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n+      { id: 'team_collection_1' },\n+    ] as any);\n \n     const result = await publishedDocsService.getAllTeamPublishedDocs(\n       'team_1',\n@@ -225,6 +315,7 @@ describe('getAllTeamPublishedDocs', () => {\n \n   test('should return an empty array when no team documents found', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([]);\n \n     const result = await publishedDocsService.getAllTeamPublishedDocs(\n       'team_1',\n@@ -236,6 +327,9 @@ describe('getAllTeamPublishedDocs', () => {\n \n   test('should filter by teamID and collectionID correctly', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n+      { id: 'team_collection_1' },\n+    ] as any);\n \n     await publishedDocsService.getAllTeamPublishedDocs(\n       'team_1',\n@@ -256,6 +350,88 @@ describe('getAllTeamPublishedDocs', () => {\n       },\n     });\n   });\n+\n+  test('should filter out published docs with non-existent team collections', async () => {\n+    const doc1 = {\n+      ...teamPublishedDoc,\n+      id: 'pub_doc_1',\n+      collectionID: 'team_collection_1',\n+    };\n+    const doc2 = {\n+      ...teamPublishedDoc,\n+      id: 'pub_doc_2',\n+      collectionID: 'team_collection_2',\n+    };\n+    const doc3 = {\n+      ...teamPublishedDoc,\n+      id: 'pub_doc_3',\n+      collectionID: 'team_collection_3',\n+    };\n+\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2, doc3]);\n+    // Only team_collection_1 and team_collection_3 exist\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n+      { id: 'team_collection_1' },\n+      { id: 'team_collection_3' },\n+    ] as any);\n+\n+    const result = await publishedDocsService.getAllTeamPublishedDocs(\n+      'team_1',\n+      undefined,\n+      { skip: 0, take: 10 },\n+    );\n+\n+    // Should only return docs with existing collections\n+    expect(result).toHaveLength(2);\n+    expect(result.map((d) => d.id)).toEqual(['pub_doc_1', 'pub_doc_3']);\n+  });\n+\n+  test('should delete published docs with non-existent team collections', async () => {\n+    const doc1 = {\n+      ...teamPublishedDoc,\n+      id: 'pub_doc_1',\n+      collectionID: 'team_collection_1',\n+    };\n+    const doc2 = {\n+      ...teamPublishedDoc,\n+      id: 'pub_doc_2',\n+      collectionID: 'team_collection_deleted',\n+    };\n+\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2]);\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n+      { id: 'team_collection_1' },\n+    ] as any);\n+    mockPrisma.publishedDocs.deleteMany.mockResolvedValueOnce({\n+      count: 1,\n+    } as any);\n+\n+    await publishedDocsService.getAllTeamPublishedDocs('team_1', undefined, {\n+      skip: 0,\n+      take: 10,\n+    });\n+\n+    expect(mockPrisma.publishedDocs.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        id: { in: ['pub_doc_2'] },\n+      },\n+    });\n+  });\n+\n+  test('should not call deleteMany when all team collections exist', async () => {\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n+      { id: 'team_collection_1' },\n+    ] as any);\n+\n+    await publishedDocsService.getAllTeamPublishedDocs(\n+      'team_1',\n+      'team_collection_1',\n+      { skip: 0, take: 10 },\n+    );\n+\n+    expect(mockPrisma.publishedDocs.deleteMany).not.toHaveBeenCalled();\n+  });\n });\n \n describe('createPublishedDoc', () => {\n@@ -650,7 +826,14 @@ describe('getPublishedDocsCreator', () => {\n     const result = await publishedDocsService.getPublishedDocsCreator(\n       userPublishedDoc.id,\n     );\n-    expect(result).toEqualRight(user);\n+\n+    const expectedUser = {\n+      ...user,\n+      currentGQLSession: JSON.stringify(user.currentGQLSession),\n+      currentRESTSession: JSON.stringify(user.currentRESTSession),\n+    };\n+\n+    expect(result).toEqualRight(expectedUser);\n   });\n \n   test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {\ndiff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts\nindex 215e2fcc7c..43e5001f64 100644\n--- a/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts\n+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts\n@@ -14,8 +14,9 @@ import {\n   PUBLISHED_DOCS_INVALID_COLLECTION,\n   PUBLISHED_DOCS_NOT_FOUND,\n   PUBLISHED_DOCS_UPDATE_FAILED,\n+  TEAM_INVALID_COLL_ID,\n   TEAM_INVALID_ID,\n-  USERS_NOT_FOUND,\n+  USER_COLL_NOT_FOUND,\n } from 'src/errors';\n import * as E from 'fp-ts/Either';\n import { PublishedDocs } from './published-docs.model';\n@@ -155,9 +156,16 @@ export class PublishedDocsService {\n     const user = await this.prisma.user.findUnique({\n       where: { uid: publishedDocs.creatorUid },\n     });\n-    if (!user) return E.left(USERS_NOT_FOUND);\n \n-    return E.right(user);\n+    const creator = user\n+      ? {\n+          ...user,\n+          currentGQLSession: JSON.stringify(user.currentGQLSession),\n+          currentRESTSession: JSON.stringify(user.currentRESTSession),\n+        }\n+      : null;\n+\n+    return E.right(creator);\n   }\n \n   /**\n@@ -235,7 +243,20 @@ export class PublishedDocsService {\n               query.tree === TreeLevel.FULL,\n             );\n \n-      if (E.isLeft(collectionResult)) return E.left(collectionResult.left);\n+      if (E.isLeft(collectionResult)) {\n+        // Delete the published doc if its collection is missing\n+        const isCollectionNotFound =\n+          collectionResult.left === USER_COLL_NOT_FOUND ||\n+          collectionResult.left === TEAM_INVALID_COLL_ID;\n+\n+        if (isCollectionNotFound) {\n+          await this.prisma.publishedDocs.delete({\n+            where: { id: publishedDocs.id },\n+          });\n+        }\n+\n+        return E.left(collectionResult.left);\n+      }\n \n       return E.right(\n         this.cast({\n@@ -248,6 +269,26 @@ export class PublishedDocsService {\n     return E.right(this.cast(publishedDocs));\n   }\n \n+  /**\n+   * Cleanup orphaned published documents whose collections no longer exist\n+   */\n+  private async cleanupOrphanedPublishedDocs<\n+    T extends { id: string; collectionID: string },\n+  >(docs: T[], existingCollectionIDs: Set<string>): Promise<T[]> {\n+    const docsToDelete = docs.filter(\n+      (doc) => !existingCollectionIDs.has(doc.collectionID),\n+    );\n+\n+    if (docsToDelete.length > 0) {\n+      const idsToDelete = docsToDelete.map((doc) => doc.id);\n+      this.prisma.publishedDocs.deleteMany({\n+        where: { id: { in: idsToDelete } },\n+      });\n+    }\n+\n+    return docs.filter((doc) => existingCollectionIDs.has(doc.collectionID));\n+  }\n+\n   /**\n    * Get all published documents for a user with pagination\n    * @param userUid - The UID of the user\n@@ -266,7 +307,29 @@ export class PublishedDocsService {\n       },\n     });\n \n-    return docs.map((doc) => this.cast(doc));\n+    if (docs.length === 0) return [];\n+\n+    // Cross-check if all collections exist\n+    const collectionIDs = docs.map((doc) => doc.collectionID);\n+    const existingCollections = await this.prisma.userCollection.findMany({\n+      where: {\n+        id: { in: collectionIDs },\n+        userUid,\n+      },\n+      select: { id: true },\n+    });\n+\n+    const existingCollectionIDs = new Set(\n+      existingCollections.map((col) => col.id),\n+    );\n+\n+    const validDocs = await this.cleanupOrphanedPublishedDocs<DbPublishedDocs>(\n+      docs,\n+      existingCollectionIDs,\n+    );\n+\n+    // Return only docs with existing collections\n+    return validDocs.map((doc) => this.cast(doc));\n   }\n \n   /**\n@@ -290,7 +353,29 @@ export class PublishedDocsService {\n       },\n     });\n \n-    return docs.map((doc) => this.cast(doc));\n+    if (docs.length === 0) return [];\n+\n+    // Cross-check if all collections exist\n+    const collectionIDs = docs.map((doc) => doc.collectionID);\n+    const existingCollections = await this.prisma.teamCollection.findMany({\n+      where: {\n+        id: { in: collectionIDs },\n+        teamID,\n+      },\n+      select: { id: true },\n+    });\n+\n+    const existingCollectionIDs = new Set(\n+      existingCollections.map((col) => col.id),\n+    );\n+\n+    const validDocs = await this.cleanupOrphanedPublishedDocs<DbPublishedDocs>(\n+      docs,\n+      existingCollectionIDs,\n+    );\n+\n+    // Return only docs with existing collections\n+    return validDocs.map((doc) => this.cast(doc));\n   }\n \n   /**\ndiff --git a/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts b/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts\nindex 5d89c04b88..270c441b0f 100644\n--- a/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts\n+++ b/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts\n@@ -40,7 +40,6 @@ import {\n import { CollectionFolder } from 'src/types/CollectionFolder';\n import { PrismaError } from 'src/prisma/prisma-error-codes';\n import { SortOptions } from 'src/types/SortOptions';\n-import { UserRequest } from 'src/user-request/user-request.model';\n \n @Injectable()\n export class UserCollectionService {\n",
        "pr_mirror": "hoppscotch__hoppscotch.main"
    }
}