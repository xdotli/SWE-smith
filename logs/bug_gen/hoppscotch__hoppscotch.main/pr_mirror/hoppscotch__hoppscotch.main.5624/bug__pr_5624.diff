diff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts
index 11e72ec..363c04c 100644
--- a/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts
+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts
@@ -34,7 +34,6 @@ export class PublishedDocsResolver {
 
   @ResolveField(() => User, {
     description: 'Returns the creator of the published document',
-    nullable: true,
   })
   async creator(@Parent() publishedDocs: PublishedDocs): Promise<User> {
     const creator = await this.publishedDocsService.getPublishedDocsCreator(
@@ -42,11 +41,16 @@ export class PublishedDocsResolver {
     );
 
     if (E.isLeft(creator)) throwErr(creator.left);
-    return creator.right;
+    return {
+      ...creator.right,
+      currentGQLSession: JSON.stringify(creator.right.currentGQLSession),
+      currentRESTSession: JSON.stringify(creator.right.currentRESTSession),
+    };
   }
 
   @ResolveField(() => PublishedDocsCollection, {
     description: 'Returns the collection of the published document',
+    nullable: true,
   })
   async collection(
     @Parent() publishedDocs: PublishedDocs,
@@ -200,4 +204,4 @@ export class PublishedDocsResolver {
     if (E.isLeft(result)) throwErr(result.left);
     return result.right;
   }
-}
+}
\ No newline at end of file
diff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts
index e532eb6..4c1fc4b 100644
--- a/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts
+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts
@@ -47,8 +47,8 @@ const user: User = {
   lastLoggedOn: currentTime,
   lastActiveOn: currentTime,
   createdOn: currentTime,
-  currentGQLSession: {} as any,
-  currentRESTSession: {} as any,
+  currentGQLSession: JSON.stringify({}),
+  currentRESTSession: JSON.stringify({}),
 };
 
 const userPublishedDoc: DBPublishedDocs = {
@@ -179,9 +179,6 @@ describe('getPublishedDocByID', () => {
 describe('getAllUserPublishedDocs', () => {
   test('should return a list of user published documents with pagination', async () => {
     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([userPublishedDoc]);
-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([
-      { id: 'collection_1' },
-    ] as any);
 
     const result = await publishedDocsService.getAllUserPublishedDocs(
       user.uid,
@@ -193,7 +190,6 @@ describe('getAllUserPublishedDocs', () => {
 
   test('should return an empty array when no documents found', async () => {
     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);
-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([]);
 
     const result = await publishedDocsService.getAllUserPublishedDocs(
       user.uid,
@@ -205,9 +201,6 @@ describe('getAllUserPublishedDocs', () => {
   test('should return paginated results correctly', async () => {
     const docs = [userPublishedDoc, { ...userPublishedDoc, id: 'pub_doc_3' }];
     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([docs[0]]);
-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([
-      { id: 'collection_1' },
-    ] as any);
 
     const result = await publishedDocsService.getAllUserPublishedDocs(
       user.uid,
@@ -215,94 +208,11 @@ describe('getAllUserPublishedDocs', () => {
     );
     expect(result).toHaveLength(1);
   });
-
-  test('should filter out published docs with non-existent collections', async () => {
-    const doc1 = {
-      ...userPublishedDoc,
-      id: 'pub_doc_1',
-      collectionID: 'collection_1',
-    };
-    const doc2 = {
-      ...userPublishedDoc,
-      id: 'pub_doc_2',
-      collectionID: 'collection_2',
-    };
-    const doc3 = {
-      ...userPublishedDoc,
-      id: 'pub_doc_3',
-      collectionID: 'collection_3',
-    };
-
-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2, doc3]);
-    // Only collection_1 and collection_3 exist
-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([
-      { id: 'collection_1' },
-      { id: 'collection_3' },
-    ] as any);
-
-    const result = await publishedDocsService.getAllUserPublishedDocs(
-      user.uid,
-      { skip: 0, take: 10 },
-    );
-
-    // Should only return docs with existing collections
-    expect(result).toHaveLength(2);
-    expect(result.map((d) => d.id)).toEqual(['pub_doc_1', 'pub_doc_3']);
-  });
-
-  test('should delete published docs with non-existent collections', async () => {
-    const doc1 = {
-      ...userPublishedDoc,
-      id: 'pub_doc_1',
-      collectionID: 'collection_1',
-    };
-    const doc2 = {
-      ...userPublishedDoc,
-      id: 'pub_doc_2',
-      collectionID: 'collection_deleted',
-    };
-
-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2]);
-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([
-      { id: 'collection_1' },
-    ] as any);
-    mockPrisma.publishedDocs.deleteMany.mockResolvedValueOnce({
-      count: 1,
-    } as any);
-
-    await publishedDocsService.getAllUserPublishedDocs(user.uid, {
-      skip: 0,
-      take: 10,
-    });
-
-    expect(mockPrisma.publishedDocs.deleteMany).toHaveBeenCalledWith({
-      where: {
-        id: { in: ['pub_doc_2'] },
-      },
-    });
-  });
-
-  test('should not call deleteMany when all collections exist', async () => {
-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([userPublishedDoc]);
-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([
-      { id: 'collection_1' },
-    ] as any);
-
-    await publishedDocsService.getAllUserPublishedDocs(user.uid, {
-      skip: 0,
-      take: 10,
-    });
-
-    expect(mockPrisma.publishedDocs.deleteMany).not.toHaveBeenCalled();
-  });
 });
 
 describe('getAllTeamPublishedDocs', () => {
   test('should return a list of team published documents with pagination', async () => {
     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);
-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([
-      { id: 'team_collection_1' },
-    ] as any);
 
     const result = await publishedDocsService.getAllTeamPublishedDocs(
       'team_1',
@@ -315,7 +225,6 @@ describe('getAllTeamPublishedDocs', () => {
 
   test('should return an empty array when no team documents found', async () => {
     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);
-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([]);
 
     const result = await publishedDocsService.getAllTeamPublishedDocs(
       'team_1',
@@ -327,9 +236,6 @@ describe('getAllTeamPublishedDocs', () => {
 
   test('should filter by teamID and collectionID correctly', async () => {
     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);
-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([
-      { id: 'team_collection_1' },
-    ] as any);
 
     await publishedDocsService.getAllTeamPublishedDocs(
       'team_1',
@@ -350,88 +256,6 @@ describe('getAllTeamPublishedDocs', () => {
       },
     });
   });
-
-  test('should filter out published docs with non-existent team collections', async () => {
-    const doc1 = {
-      ...teamPublishedDoc,
-      id: 'pub_doc_1',
-      collectionID: 'team_collection_1',
-    };
-    const doc2 = {
-      ...teamPublishedDoc,
-      id: 'pub_doc_2',
-      collectionID: 'team_collection_2',
-    };
-    const doc3 = {
-      ...teamPublishedDoc,
-      id: 'pub_doc_3',
-      collectionID: 'team_collection_3',
-    };
-
-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2, doc3]);
-    // Only team_collection_1 and team_collection_3 exist
-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([
-      { id: 'team_collection_1' },
-      { id: 'team_collection_3' },
-    ] as any);
-
-    const result = await publishedDocsService.getAllTeamPublishedDocs(
-      'team_1',
-      undefined,
-      { skip: 0, take: 10 },
-    );
-
-    // Should only return docs with existing collections
-    expect(result).toHaveLength(2);
-    expect(result.map((d) => d.id)).toEqual(['pub_doc_1', 'pub_doc_3']);
-  });
-
-  test('should delete published docs with non-existent team collections', async () => {
-    const doc1 = {
-      ...teamPublishedDoc,
-      id: 'pub_doc_1',
-      collectionID: 'team_collection_1',
-    };
-    const doc2 = {
-      ...teamPublishedDoc,
-      id: 'pub_doc_2',
-      collectionID: 'team_collection_deleted',
-    };
-
-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2]);
-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([
-      { id: 'team_collection_1' },
-    ] as any);
-    mockPrisma.publishedDocs.deleteMany.mockResolvedValueOnce({
-      count: 1,
-    } as any);
-
-    await publishedDocsService.getAllTeamPublishedDocs('team_1', undefined, {
-      skip: 0,
-      take: 10,
-    });
-
-    expect(mockPrisma.publishedDocs.deleteMany).toHaveBeenCalledWith({
-      where: {
-        id: { in: ['pub_doc_2'] },
-      },
-    });
-  });
-
-  test('should not call deleteMany when all team collections exist', async () => {
-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);
-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([
-      { id: 'team_collection_1' },
-    ] as any);
-
-    await publishedDocsService.getAllTeamPublishedDocs(
-      'team_1',
-      'team_collection_1',
-      { skip: 0, take: 10 },
-    );
-
-    expect(mockPrisma.publishedDocs.deleteMany).not.toHaveBeenCalled();
-  });
 });
 
 describe('createPublishedDoc', () => {
@@ -546,541 +370,4 @@ describe('createPublishedDoc', () => {
   });
 
   test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when collection does not belong to user', async () => {
-    // When Prisma queries with where: { id: 'collection_1', userUid: user.uid }
-    // and the collection doesn't belong to the user, it returns null
-    mockPrisma.userCollection.findUnique.mockResolvedValueOnce(null);
-
-    const result = await publishedDocsService.createPublishedDoc(
-      createArgs,
-      user,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_INVALID_COLLECTION);
-  });
-
-  test('should throw error when metadata is invalid JSON', async () => {
-    mockPrisma.userCollection.findUnique.mockResolvedValueOnce({
-      id: 'collection_1',
-      userUid: user.uid,
-    } as any);
-
-    const result = await publishedDocsService.createPublishedDoc(
-      { ...createArgs, metadata: '{invalid' },
-      user,
-    );
-    expect(E.isLeft(result)).toBe(true);
-  });
-
-  test('should throw PUBLISHED_DOCS_CREATION_FAILED on database error', async () => {
-    mockPrisma.userCollection.findUnique.mockResolvedValueOnce({
-      id: 'collection_1',
-      userUid: user.uid,
-    } as any);
-    mockPrisma.publishedDocs.create.mockRejectedValueOnce(
-      new Error('Database error'),
-    );
-
-    const result = await publishedDocsService.createPublishedDoc(
-      createArgs,
-      user,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_CREATION_FAILED);
-  });
-});
-
-describe('updatePublishedDoc', () => {
-  const updateArgs: UpdatePublishedDocsArgs = {
-    title: 'Updated API Documentation',
-    version: '2.0.0',
-    autoSync: false,
-    metadata: '{"key": "value"}',
-  };
-
-  test('should successfully update a published document with valid inputs', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);
-    mockPrisma.publishedDocs.update.mockResolvedValueOnce({
-      ...userPublishedDoc,
-      title: updateArgs.title,
-      version: updateArgs.version,
-      autoSync: updateArgs.autoSync,
-    });
-
-    const result = await publishedDocsService.updatePublishedDoc(
-      userPublishedDoc.id,
-      updateArgs,
-      user,
-    );
-
-    expect(E.isRight(result)).toBe(true);
-    if (E.isRight(result)) {
-      expect(result.right.title).toBe(updateArgs.title);
-      expect(result.right.version).toBe(updateArgs.version);
-      expect(result.right.autoSync).toBe(updateArgs.autoSync);
-    }
-  });
-
-  test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);
-
-    const result = await publishedDocsService.updatePublishedDoc(
-      'invalid_id',
-      updateArgs,
-      user,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);
-  });
-
-  test('should throw PUBLISHED_DOCS_UPDATE_FAILED when user does not have access', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({
-      ...userPublishedDoc,
-      creatorUid: 'different_user',
-    });
-
-    const result = await publishedDocsService.updatePublishedDoc(
-      userPublishedDoc.id,
-      updateArgs,
-      user,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_UPDATE_FAILED);
-  });
-
-  test('should throw PUBLISHED_DOCS_UPDATE_FAILED when user is not OWNER or EDITOR of team', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);
-    mockPrisma.team.findFirst.mockResolvedValueOnce(null);
-
-    const result = await publishedDocsService.updatePublishedDoc(
-      teamPublishedDoc.id,
-      updateArgs,
-      user,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_UPDATE_FAILED);
-  });
-
-  test('should successfully update team published document when user has OWNER role', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);
-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);
-    mockPrisma.publishedDocs.update.mockResolvedValueOnce({
-      ...teamPublishedDoc,
-      title: updateArgs.title,
-    });
-
-    const result = await publishedDocsService.updatePublishedDoc(
-      teamPublishedDoc.id,
-      updateArgs,
-      user,
-    );
-
-    expect(E.isRight(result)).toBe(true);
-  });
-
-  test('should successfully update team published document when user has EDITOR role', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);
-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);
-    mockPrisma.publishedDocs.update.mockResolvedValueOnce({
-      ...teamPublishedDoc,
-      title: updateArgs.title,
-    });
-
-    const result = await publishedDocsService.updatePublishedDoc(
-      teamPublishedDoc.id,
-      updateArgs,
-      user,
-    );
-
-    expect(E.isRight(result)).toBe(true);
-  });
-
-  test('should throw error when metadata is invalid JSON', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);
-
-    const result = await publishedDocsService.updatePublishedDoc(
-      userPublishedDoc.id,
-      { ...updateArgs, metadata: '{invalid' },
-      user,
-    );
-    expect(E.isLeft(result)).toBe(true);
-  });
-
-  test('should update only provided fields', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);
-    mockPrisma.publishedDocs.update.mockResolvedValueOnce({
-      ...userPublishedDoc,
-      title: 'Only Title Updated',
-    });
-
-    const result = await publishedDocsService.updatePublishedDoc(
-      userPublishedDoc.id,
-      { title: 'Only Title Updated' },
-      user,
-    );
-
-    expect(E.isRight(result)).toBe(true);
-    if (E.isRight(result)) {
-      expect(result.right.title).toBe('Only Title Updated');
-    }
-  });
-
-  test('should throw PUBLISHED_DOCS_UPDATE_FAILED on database error', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);
-    mockPrisma.publishedDocs.update.mockRejectedValueOnce(
-      new Error('Database error'),
-    );
-
-    const result = await publishedDocsService.updatePublishedDoc(
-      userPublishedDoc.id,
-      updateArgs,
-      user,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_UPDATE_FAILED);
-  });
-});
-
-describe('deletePublishedDoc', () => {
-  test('should successfully delete a user published document', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);
-    mockPrisma.publishedDocs.delete.mockResolvedValueOnce(userPublishedDoc);
-
-    const result = await publishedDocsService.deletePublishedDoc(
-      userPublishedDoc.id,
-      user,
-    );
-    expect(result).toEqualRight(true);
-  });
-
-  test('should successfully delete a team published document when user has OWNER role', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);
-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);
-    mockPrisma.publishedDocs.delete.mockResolvedValueOnce(teamPublishedDoc);
-
-    const result = await publishedDocsService.deletePublishedDoc(
-      teamPublishedDoc.id,
-      user,
-    );
-    expect(result).toEqualRight(true);
-  });
-
-  test('should successfully delete a team published document when user has EDITOR role', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);
-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);
-    mockPrisma.publishedDocs.delete.mockResolvedValueOnce(teamPublishedDoc);
-
-    const result = await publishedDocsService.deletePublishedDoc(
-      teamPublishedDoc.id,
-      user,
-    );
-    expect(result).toEqualRight(true);
-  });
-
-  test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);
-
-    const result = await publishedDocsService.deletePublishedDoc(
-      'invalid_id',
-      user,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);
-  });
-
-  test('should throw PUBLISHED_DOCS_DELETION_FAILED when user does not have access', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({
-      ...userPublishedDoc,
-      creatorUid: 'different_user',
-    });
-
-    const result = await publishedDocsService.deletePublishedDoc(
-      userPublishedDoc.id,
-      user,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_DELETION_FAILED);
-  });
-
-  test('should throw PUBLISHED_DOCS_DELETION_FAILED when user is not OWNER or EDITOR of team', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);
-    mockPrisma.team.findFirst.mockResolvedValueOnce(null);
-
-    const result = await publishedDocsService.deletePublishedDoc(
-      teamPublishedDoc.id,
-      user,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_DELETION_FAILED);
-  });
-
-  test('should throw PUBLISHED_DOCS_DELETION_FAILED on database error', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);
-    mockPrisma.publishedDocs.delete.mockRejectedValueOnce(
-      new Error('Database error'),
-    );
-
-    const result = await publishedDocsService.deletePublishedDoc(
-      userPublishedDoc.id,
-      user,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_DELETION_FAILED);
-  });
-});
-
-describe('getPublishedDocsCreator', () => {
-  test('should return the creator of a published document', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);
-    mockPrisma.user.findUnique.mockResolvedValueOnce(user as any);
-
-    const result = await publishedDocsService.getPublishedDocsCreator(
-      userPublishedDoc.id,
-    );
-
-    const expectedUser = {
-      ...user,
-      currentGQLSession: JSON.stringify(user.currentGQLSession),
-      currentRESTSession: JSON.stringify(user.currentRESTSession),
-    };
-
-    expect(result).toEqualRight(expectedUser);
-  });
-
-  test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);
-
-    const result =
-      await publishedDocsService.getPublishedDocsCreator('invalid_id');
-    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);
-  });
-});
-
-describe('getPublishedDocsCollection', () => {
-  test('should return user collection for user workspace published document', async () => {
-    const userCollection = {
-      id: 'collection_1',
-      userUid: user.uid,
-      title: 'My Collection',
-    };
-
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);
-    mockPrisma.userCollection.findUnique.mockResolvedValueOnce(
-      userCollection as any,
-    );
-
-    const result = await publishedDocsService.getPublishedDocsCollection(
-      userPublishedDoc.id,
-    );
-    expect(result).toEqualRight(userCollection);
-  });
-
-  test('should return team collection for team workspace published document', async () => {
-    const teamCollection = {
-      id: 'team_collection_1',
-      teamID: 'team_1',
-      title: 'Team Collection',
-    };
-
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);
-    mockPrisma.teamCollection.findUnique.mockResolvedValueOnce(
-      teamCollection as any,
-    );
-
-    const result = await publishedDocsService.getPublishedDocsCollection(
-      teamPublishedDoc.id,
-    );
-    expect(result).toEqualRight(teamCollection);
-  });
-
-  test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);
-
-    const result =
-      await publishedDocsService.getPublishedDocsCollection('invalid_id');
-    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);
-  });
-
-  test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when user collection is not found', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);
-    mockPrisma.userCollection.findUnique.mockResolvedValueOnce(null);
-
-    const result = await publishedDocsService.getPublishedDocsCollection(
-      userPublishedDoc.id,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_INVALID_COLLECTION);
-  });
-
-  test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when team collection is not found', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);
-    mockPrisma.teamCollection.findUnique.mockResolvedValueOnce(null);
-
-    const result = await publishedDocsService.getPublishedDocsCollection(
-      teamPublishedDoc.id,
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_INVALID_COLLECTION);
-  });
-});
-
-describe('checkPublishedDocsAccess', () => {
-  test('should return true for user workspace when user is the creator', async () => {
-    const result = await publishedDocsService.checkPublishedDocsAccess(
-      userPublishedDoc,
-      user.uid,
-    );
-    expect(result).toBe(true);
-  });
-
-  test('should return false for user workspace when user is not the creator', async () => {
-    const result = await publishedDocsService.checkPublishedDocsAccess(
-      userPublishedDoc,
-      'different_user',
-    );
-    expect(result).toBe(false);
-  });
-
-  test('should return true for team workspace when user has required role', async () => {
-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);
-
-    const result = await publishedDocsService.checkPublishedDocsAccess(
-      teamPublishedDoc,
-      user.uid,
-      [TeamAccessRole.OWNER],
-    );
-    expect(result).toBe(true);
-  });
-
-  test('should return false for team workspace when user does not have required role', async () => {
-    mockPrisma.team.findFirst.mockResolvedValueOnce(null);
-
-    const result = await publishedDocsService.checkPublishedDocsAccess(
-      teamPublishedDoc,
-      user.uid,
-      [TeamAccessRole.OWNER],
-    );
-    expect(result).toBe(false);
-  });
-
-  test('should check for VIEWER role by default', async () => {
-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);
-
-    const result = await publishedDocsService.checkPublishedDocsAccess(
-      teamPublishedDoc,
-      user.uid,
-    );
-    expect(result).toBe(true);
-
-    expect(mockPrisma.team.findFirst).toHaveBeenCalledWith({
-      where: {
-        id: 'team_1',
-        members: {
-          some: {
-            userUid: user.uid,
-            role: {
-              in: [
-                TeamAccessRole.OWNER,
-                TeamAccessRole.EDITOR,
-                TeamAccessRole.VIEWER,
-              ],
-            },
-          },
-        },
-      },
-    });
-  });
-});
-
-describe('getPublishedDocByIDPublic', () => {
-  test('should return collection data when autoSync is enabled for user workspace', async () => {
-    const collectionData = {
-      id: 'collection_1',
-      name: 'Test Collection',
-      folders: [],
-      requests: [],
-    };
-
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({
-      ...userPublishedDoc,
-      autoSync: true,
-    });
-    mockUserCollectionService.exportUserCollectionToJSONObject.mockResolvedValueOnce(
-      E.right(collectionData as any),
-    );
-
-    const result = await publishedDocsService.getPublishedDocByIDPublic(
-      userPublishedDoc.id,
-      { tree: TreeLevel.FULL },
-    );
-
-    expect(result).toMatchObject(
-      E.right({
-        ...userPublishedDocCasted,
-        documentTree: JSON.stringify(collectionData),
-      }),
-    );
-  });
-
-  test('should return collection data when autoSync is enabled for team workspace', async () => {
-    const collectionData = {
-      id: 'team_collection_1',
-      name: 'Team Test Collection',
-      folders: [],
-      requests: [],
-    };
-
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({
-      ...teamPublishedDoc,
-      autoSync: true,
-    });
-    mockTeamCollectionService.exportCollectionToJSONObject.mockResolvedValueOnce(
-      E.right(collectionData as any),
-    );
-
-    const result = await publishedDocsService.getPublishedDocByIDPublic(
-      teamPublishedDoc.id,
-      { tree: TreeLevel.FULL },
-    );
-
-    expect(result).toMatchObject(
-      E.right({
-        ...teamPublishedDocCasted,
-        documentTree: JSON.stringify(collectionData),
-      }),
-    );
-  });
-
-  test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);
-
-    const result = await publishedDocsService.getPublishedDocByIDPublic(
-      'invalid_id',
-      { tree: TreeLevel.FULL },
-    );
-    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);
-  });
-
-  test('should call exportUserCollectionToJSONObject with correct parameters', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({
-      ...userPublishedDoc,
-      autoSync: true,
-    });
-    mockUserCollectionService.exportUserCollectionToJSONObject.mockResolvedValueOnce(
-      E.right({} as any),
-    );
-
-    await publishedDocsService.getPublishedDocByIDPublic(userPublishedDoc.id, {
-      tree: TreeLevel.FULL,
-    } as any);
-
-    expect(
-      mockUserCollectionService.exportUserCollectionToJSONObject,
-    ).toHaveBeenCalledWith(user.uid, 'collection_1', true);
-  });
-
-  test('should call exportCollectionToJSONObject with correct parameters', async () => {
-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({
-      ...teamPublishedDoc,
-      autoSync: true,
-    });
-    mockTeamCollectionService.exportCollectionToJSONObject.mockResolvedValueOnce(
-      E.right({} as any),
-    );
-
-    await publishedDocsService.getPublishedDocByIDPublic(teamPublishedDoc.id, {
-      tree: TreeLevel.FULL,
-    });
-
-    expect(
-      mockTeamCollectionService.exportCollectionToJSONObject,
-    ).toHaveBeenCalledWith('team_1', 'team_collection_1', true);
-  });
-});
+    // When Prisma queries with
\ No newline at end of file
diff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts
index 43e5001..d162525 100644
--- a/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts
+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts
@@ -14,9 +14,8 @@ import {
   PUBLISHED_DOCS_INVALID_COLLECTION,
   PUBLISHED_DOCS_NOT_FOUND,
   PUBLISHED_DOCS_UPDATE_FAILED,
-  TEAM_INVALID_COLL_ID,
   TEAM_INVALID_ID,
-  USER_COLL_NOT_FOUND,
+  USERS_NOT_FOUND,
 } from 'src/errors';
 import * as E from 'fp-ts/Either';
 import { PublishedDocs } from './published-docs.model';
@@ -156,16 +155,9 @@ export class PublishedDocsService {
     const user = await this.prisma.user.findUnique({
       where: { uid: publishedDocs.creatorUid },
     });
+    if (!user) return E.left(USERS_NOT_FOUND);
 
-    const creator = user
-      ? {
-          ...user,
-          currentGQLSession: JSON.stringify(user.currentGQLSession),
-          currentRESTSession: JSON.stringify(user.currentRESTSession),
-        }
-      : null;
-
-    return E.right(creator);
+    return E.right(user);
   }
 
   /**
@@ -243,20 +235,7 @@ export class PublishedDocsService {
               query.tree === TreeLevel.FULL,
             );
 
-      if (E.isLeft(collectionResult)) {
-        // Delete the published doc if its collection is missing
-        const isCollectionNotFound =
-          collectionResult.left === USER_COLL_NOT_FOUND ||
-          collectionResult.left === TEAM_INVALID_COLL_ID;
-
-        if (isCollectionNotFound) {
-          await this.prisma.publishedDocs.delete({
-            where: { id: publishedDocs.id },
-          });
-        }
-
-        return E.left(collectionResult.left);
-      }
+      if (E.isLeft(collectionResult)) return E.left(collectionResult.left);
 
       return E.right(
         this.cast({
@@ -269,26 +248,6 @@ export class PublishedDocsService {
     return E.right(this.cast(publishedDocs));
   }
 
-  /**
-   * Cleanup orphaned published documents whose collections no longer exist
-   */
-  private async cleanupOrphanedPublishedDocs<
-    T extends { id: string; collectionID: string },
-  >(docs: T[], existingCollectionIDs: Set<string>): Promise<T[]> {
-    const docsToDelete = docs.filter(
-      (doc) => !existingCollectionIDs.has(doc.collectionID),
-    );
-
-    if (docsToDelete.length > 0) {
-      const idsToDelete = docsToDelete.map((doc) => doc.id);
-      this.prisma.publishedDocs.deleteMany({
-        where: { id: { in: idsToDelete } },
-      });
-    }
-
-    return docs.filter((doc) => existingCollectionIDs.has(doc.collectionID));
-  }
-
   /**
    * Get all published documents for a user with pagination
    * @param userUid - The UID of the user
@@ -307,29 +266,7 @@ export class PublishedDocsService {
       },
     });
 
-    if (docs.length === 0) return [];
-
-    // Cross-check if all collections exist
-    const collectionIDs = docs.map((doc) => doc.collectionID);
-    const existingCollections = await this.prisma.userCollection.findMany({
-      where: {
-        id: { in: collectionIDs },
-        userUid,
-      },
-      select: { id: true },
-    });
-
-    const existingCollectionIDs = new Set(
-      existingCollections.map((col) => col.id),
-    );
-
-    const validDocs = await this.cleanupOrphanedPublishedDocs<DbPublishedDocs>(
-      docs,
-      existingCollectionIDs,
-    );
-
-    // Return only docs with existing collections
-    return validDocs.map((doc) => this.cast(doc));
+    return docs.map((doc) => this.cast(doc));
   }
 
   /**
@@ -353,29 +290,7 @@ export class PublishedDocsService {
       },
     });
 
-    if (docs.length === 0) return [];
-
-    // Cross-check if all collections exist
-    const collectionIDs = docs.map((doc) => doc.collectionID);
-    const existingCollections = await this.prisma.teamCollection.findMany({
-      where: {
-        id: { in: collectionIDs },
-        teamID,
-      },
-      select: { id: true },
-    });
-
-    const existingCollectionIDs = new Set(
-      existingCollections.map((col) => col.id),
-    );
-
-    const validDocs = await this.cleanupOrphanedPublishedDocs<DbPublishedDocs>(
-      docs,
-      existingCollectionIDs,
-    );
-
-    // Return only docs with existing collections
-    return validDocs.map((doc) => this.cast(doc));
+    return docs.map((doc) => this.cast(doc));
   }
 
   /**
@@ -503,13 +418,4 @@ export class PublishedDocsService {
       if (!hasAccess) return E.left(PUBLISHED_DOCS_DELETION_FAILED);
 
       await this.prisma.publishedDocs.delete({
-        where: { id },
-      });
-
-      return E.right(true);
-    } catch (error) {
-      console.error('Error deleting published document:', error);
-      return E.left(PUBLISHED_DOCS_DELETION_FAILED);
-    }
-  }
-}
+        where: { id },
\ No newline at end of file
diff --git a/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts b/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts
index 270c441..69f850c 100644
--- a/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts
+++ b/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts
@@ -40,6 +40,7 @@ import {
 import { CollectionFolder } from 'src/types/CollectionFolder';
 import { PrismaError } from 'src/prisma/prisma-error-codes';
 import { SortOptions } from 'src/types/SortOptions';
+import { UserRequest } from 'src/user-request/user-request.model';
 
 @Injectable()
 export class UserCollectionService {
@@ -477,914 +478,4 @@ export class UserCollectionService {
               // if parentCollectionID != null, collection becomes child collection
               parentID: newParentID,
               orderIndex: lastCollectionUnderNewParent
-                ? lastCollectionUnderNewParent.orderIndex + 1
-                : 1,
-            },
-          });
-
-          // decrement orderIndex of all next sibling collections from original collection
-          await tx.userCollection.updateMany({
-            where: {
-              parentID: collection.parentID,
-              orderIndex: { gt: collection.orderIndex },
-            },
-            data: { orderIndex: { decrement: 1 } },
-          });
-        } catch (error) {
-          throw new ConflictException(error);
-        }
-      });
-
-      return E.right(updatedCollection);
-    } catch (error) {
-      console.error(
-        'Error from UserCollectionService.changeParentAndUpdateOrderIndex:',
-        error,
-      );
-      return E.left(USER_COLL_REORDERING_FAILED);
-    }
-  }
-
-  /**
-   * Check if collection is parent of destCollection
-   *
-   * @param collection The ID of collection being moved
-   * @param destCollection The ID of collection into which we are moving target collection into
-   * @returns An Option of boolean, is parent or not
-   */
-  private async isParent(
-    collection: UserCollection,
-    destCollection: UserCollection,
-  ): Promise<O.Option<boolean>> {
-    // Check if collection and destCollection are same
-    if (collection === destCollection) {
-      return O.none;
-    }
-    if (destCollection.parentID !== null) {
-      // Check if ID of collection is same as parent of destCollection
-      if (destCollection.parentID === collection.id) {
-        return O.none;
-      }
-      // Get collection details of collection one step above in the tree i.e the parent collection
-      const parentCollection = await this.getUserCollection(
-        destCollection.parentID,
-      );
-      if (E.isLeft(parentCollection)) {
-        return O.none;
-      }
-      // Call isParent again now with parent collection
-      return await this.isParent(collection, parentCollection.right);
-    } else {
-      return O.some(true);
-    }
-  }
-
-  /**
-   * Delete collection and Update the OrderIndex of all collections in given parentID
-   * @param collection The collection to delete
-   * @param orderIndexCondition Condition to decide what collections will be updated
-   * @param dataCondition Increment/Decrement OrderIndex condition
-   * @returns A Collection with updated OrderIndexes
-   */
-  private async removeCollectionAndUpdateSiblingsOrderIndex(
-    collection: UserCollection,
-    orderIndexCondition: Prisma.IntFilter,
-    dataCondition: Prisma.IntFieldUpdateOperationsInput,
-  ) {
-    let retryCount = 0;
-    while (retryCount < this.MAX_RETRIES) {
-      try {
-        await this.prisma.$transaction(async (tx) => {
-          try {
-            // lock the rows
-            await this.prisma.lockTableExclusive(tx, 'UserCollection');
-
-            await tx.userCollection.delete({
-              where: { id: collection.id },
-            });
-
-            // update orderIndexes
-            await tx.userCollection.updateMany({
-              where: {
-                parentID: collection.parentID,
-                orderIndex: orderIndexCondition,
-              },
-              data: { orderIndex: dataCondition },
-            });
-          } catch (error) {
-            throw new ConflictException(error);
-          }
-        });
-
-        break;
-      } catch (error) {
-        console.error(
-          'Error from UserCollectionService.updateOrderIndex:',
-          error,
-        );
-        retryCount++;
-        if (
-          retryCount >= this.MAX_RETRIES ||
-          (error.code !== PrismaError.UNIQUE_CONSTRAINT_VIOLATION &&
-            error.code !== PrismaError.TRANSACTION_DEADLOCK &&
-            error.code !== PrismaError.TRANSACTION_TIMEOUT) // return for all DB error except deadlocks, unique constraint violations, transaction timeouts
-        )
-          return E.left(USER_COLL_REORDERING_FAILED);
-
-        await delay(retryCount * 100);
-        console.debug(`Retrying... (${retryCount})`);
-      }
-    }
-
-    return E.right(true);
-  }
-
-  /**
-   * Move UserCollection into root or another collection
-   *
-   * @param userCollectionID The ID of collection being moved
-   * @param destCollectionID The ID of collection the target collection is being moved into or move target collection to root
-   * @param userID The User UID
-   * @returns An Either of the moved UserCollection
-   */
-  async moveUserCollection(
-    userCollectionID: string,
-    destCollectionID: string | null,
-    userID: string,
-  ) {
-    // Get collection details of collectionID
-    const collection = await this.getUserCollection(userCollectionID);
-    if (E.isLeft(collection)) return E.left(USER_COLL_NOT_FOUND);
-
-    // Check to see is the collection belongs to the user
-    if (collection.right.userUid !== userID) return E.left(USER_NOT_OWNER);
-
-    // destCollectionID == null i.e move collection to root
-    if (!destCollectionID) {
-      if (!collection.right.parentID) {
-        // collection is a root collection
-        // Throw error if collection is already a root collection
-        return E.left(USER_COLL_ALREADY_ROOT);
-      }
-
-      // Change parent from child to root i.e child collection becomes a root collection
-      // Move child collection into root and update orderIndexes for child userCollections
-      const updatedCollection = await this.changeParentAndUpdateOrderIndex(
-        collection.right,
-        null,
-      );
-      if (E.isLeft(updatedCollection)) return E.left(updatedCollection.left);
-
-      this.pubsub.publish(
-        `user_coll/${collection.right.userUid}/moved`,
-        this.cast(updatedCollection.right),
-      );
-
-      return E.right(this.cast(updatedCollection.right));
-    }
-
-    // destCollectionID != null i.e move into another collection
-    if (userCollectionID === destCollectionID) {
-      // Throw error if collectionID and destCollectionID are the same
-      return E.left(USER_COLL_DEST_SAME);
-    }
-
-    // Get collection details of destCollectionID
-    const destCollection = await this.getUserCollection(destCollectionID);
-    if (E.isLeft(destCollection)) return E.left(USER_COLL_NOT_FOUND);
-
-    // Check if collection and destCollection belong to the same collection type
-    if (collection.right.type !== destCollection.right.type) {
-      return E.left(USER_COLL_NOT_SAME_TYPE);
-    }
-
-    // Check if collection and destCollection belong to the same user account
-    if (collection.right.userUid !== destCollection.right.userUid) {
-      return E.left(USER_COLL_NOT_SAME_USER);
-    }
-
-    // Check if collection is present on the parent tree for destCollection
-    const checkIfParent = await this.isParent(
-      collection.right,
-      destCollection.right,
-    );
-    if (O.isNone(checkIfParent)) {
-      return E.left(USER_COLL_IS_PARENT_COLL);
-    }
-
-    // Change parent from null to teamCollection i.e collection becomes a child collection
-    // Move root/child collection into another child collection and update orderIndexes of the previous parent
-    const updatedCollection = await this.changeParentAndUpdateOrderIndex(
-      collection.right,
-      destCollection.right.id,
-    );
-    if (E.isLeft(updatedCollection)) return E.left(updatedCollection.left);
-
-    this.pubsub.publish(
-      `user_coll/${collection.right.userUid}/moved`,
-      this.cast(updatedCollection.right),
-    );
-
-    return E.right(this.cast(updatedCollection.right));
-  }
-
-  /**
-   * Find the number of child collections present in collectionID
-   *
-   * @param collectionID The Collection ID
-   * @returns Number of collections
-   */
-  getCollectionCount(collectionID: string): Promise<number> {
-    return this.prisma.userCollection.count({
-      where: { parentID: collectionID },
-    });
-  }
-
-  /**
-   * Update order of root or child collectionID's
-   *
-   * @param collectionID The ID of collection being re-ordered
-   * @param nextCollectionID The ID of collection that is after the moved collection in its new position
-   * @param userID The User UID
-   * @returns If successful return an Either of true
-   */
-  async updateUserCollectionOrder(
-    collectionID: string,
-    nextCollectionID: string | null,
-    userID: string,
-  ) {
-    // Throw error if collectionID and nextCollectionID are the same
-    if (collectionID === nextCollectionID)
-      return E.left(USER_COLL_SAME_NEXT_COLL);
-
-    // Get collection details of collectionID
-    const collection = await this.getUserCollection(collectionID);
-    if (E.isLeft(collection)) return E.left(USER_COLL_NOT_FOUND);
-
-    // Check to see is the collection belongs to the user
-    if (collection.right.userUid !== userID) return E.left(USER_NOT_OWNER);
-
-    if (!nextCollectionID) {
-      // nextCollectionID == null i.e move collection to the end of the list
-      try {
-        await this.prisma.$transaction(async (tx) => {
-          try {
-            // Step 0: lock the rows
-            await this.prisma.acquireLocks(
-              tx,
-              'UserCollection',
-              userID,
-              collection.right.parentID,
-            );
-
-            // Step 1: Decrement orderIndex of all items that come after collection.orderIndex till end of list of items
-            const collectionInTx = await tx.userCollection.findFirst({
-              where: { id: collectionID },
-              select: { orderIndex: true },
-            });
-            await tx.userCollection.updateMany({
-              where: {
-                parentID: collection.right.parentID,
-                orderIndex: { gte: collectionInTx.orderIndex + 1 },
-              },
-              data: { orderIndex: { decrement: 1 } },
-            });
-
-            // Step 2: Update orderIndex of collection to length of list
-            await tx.userCollection.update({
-              where: { id: collection.right.id },
-              data: {
-                orderIndex: await this.getCollectionCount(
-                  collection.right.parentID,
-                ),
-              },
-            });
-          } catch (error) {
-            throw new ConflictException(error);
-          }
-        });
-
-        this.pubsub.publish(
-          `user_coll/${collection.right.userUid}/order_updated`,
-          {
-            userCollection: this.cast(collection.right),
-            nextUserCollection: null,
-          },
-        );
-
-        return E.right(true);
-      } catch (error) {
-        return E.left(USER_COLL_REORDERING_FAILED);
-      }
-    }
-
-    // nextCollectionID != null i.e move to a certain position
-    // Get collection details of nextCollectionID
-    const subsequentCollection = await this.getUserCollection(nextCollectionID);
-    if (E.isLeft(subsequentCollection)) return E.left(USER_COLL_NOT_FOUND);
-
-    if (collection.right.userUid !== subsequentCollection.right.userUid)
-      return E.left(USER_COLL_NOT_SAME_USER);
-
-    // Check if collection and subsequentCollection belong to the same collection type
-    if (collection.right.type !== subsequentCollection.right.type) {
-      return E.left(USER_COLL_NOT_SAME_TYPE);
-    }
-
-    try {
-      await this.prisma.$transaction(async (tx) => {
-        try {
-          // Step 0: lock the rows
-          await this.prisma.acquireLocks(
-            tx,
-            'UserCollection',
-            userID,
-            subsequentCollection.right.parentID,
-          );
-
-          // subsequentCollectionInTx and subsequentCollection are same, just to make sure, orderIndex value is concrete
-          const collectionInTx = await tx.userCollection.findFirst({
-            where: { id: collectionID },
-            select: { orderIndex: true },
-          });
-          const subsequentCollectionInTx = await tx.userCollection.findFirst({
-            where: { id: nextCollectionID },
-            select: { orderIndex: true },
-          });
-
-          // Step 1: Determine if we are moving collection up or down the list
-          const isMovingUp =
-            subsequentCollectionInTx.orderIndex < collectionInTx.orderIndex;
-
-          // Step 2: Update OrderIndex of items in list depending on moving up or down
-          const updateFrom = isMovingUp
-            ? subsequentCollectionInTx.orderIndex
-            : collectionInTx.orderIndex + 1;
-
-          const updateTo = isMovingUp
-            ? collectionInTx.orderIndex - 1
-            : subsequentCollectionInTx.orderIndex - 1;
-
-          await tx.userCollection.updateMany({
-            where: {
-              parentID: collection.right.parentID,
-              orderIndex: { gte: updateFrom, lte: updateTo },
-            },
-            data: {
-              orderIndex: isMovingUp ? { increment: 1 } : { decrement: 1 },
-            },
-          });
-
-          // Step 3: Update OrderIndex of collection
-          await tx.userCollection.update({
-            where: { id: collection.right.id },
-            data: {
-              orderIndex: isMovingUp
-                ? subsequentCollectionInTx.orderIndex
-                : subsequentCollectionInTx.orderIndex - 1,
-            },
-          });
-        } catch (error) {
-          throw new ConflictException(error);
-        }
-      });
-
-      this.pubsub.publish(
-        `user_coll/${collection.right.userUid}/order_updated`,
-        {
-          userCollection: this.cast(collection.right),
-          nextUserCollection: this.cast(subsequentCollection.right),
-        },
-      );
-
-      return E.right(true);
-    } catch (error) {
-      return E.left(USER_COLL_REORDERING_FAILED);
-    }
-  }
-
-  /**
-   * Generate a JSON containing all the contents of a collection
-   *
-   * @param userUID The User UID
-   * @param collectionID The Collection ID
-   * @param withChildren Whether to include child collections and their requests
-   * @returns A JSON string containing all the contents of a collection
-   */
-  async exportUserCollectionToJSONObject(
-    userUID: string,
-    collectionID: string,
-    withChildren: boolean = true,
-  ): Promise<E.Left<string> | E.Right<CollectionFolder>> {
-    // Get Collection details
-    const collection = await this.getUserCollection(collectionID);
-    if (E.isLeft(collection)) return E.left(collection.left);
-
-    const childrenCollectionObjects: CollectionFolder[] = [];
-    if (withChildren) {
-      // Get all child collections whose parentID === collectionID
-      const childCollectionList = await this.prisma.userCollection.findMany({
-        where: {
-          parentID: collectionID,
-          userUid: userUID,
-        },
-        orderBy: {
-          orderIndex: 'asc',
-        },
-      });
-
-      // Create a list of child collection and request data ready for export
-      for (const coll of childCollectionList) {
-        const result = await this.exportUserCollectionToJSONObject(
-          userUID,
-          coll.id,
-        );
-        if (E.isLeft(result)) return E.left(result.left);
-
-        childrenCollectionObjects.push(result.right);
-      }
-    }
-
-    // Fetch all child requests that belong to collectionID
-    const requests = await this.prisma.userRequest.findMany({
-      where: {
-        userUid: userUID,
-        collectionID,
-      },
-      orderBy: {
-        orderIndex: 'asc',
-      },
-    });
-
-    const data = transformCollectionData(collection.right.data);
-
-    const result: CollectionFolder = {
-      id: collection.right.id,
-      name: collection.right.title,
-      folders: childrenCollectionObjects,
-      requests: requests.map((x) => {
-        return {
-          id: x.id,
-          name: x.title,
-          ...(x.request as Record<string, unknown>), // type casting x.request of type Prisma.JSONValue to an object to enable spread
-        };
-      }),
-      data,
-    };
-
-    return E.right(result);
-  }
-
-  /**
-   * Generate a JSON containing all the contents of collections and requests of a team
-   *
-   * @param userUID The User UID
-   * @returns A JSON string containing all the contents of collections and requests of a team
-   */
-  async exportUserCollectionsToJSON(
-    userUID: string,
-    collectionID: string | null,
-    reqType: ReqType,
-  ) {
-    // Get all child collections details
-    const childCollectionList = await this.prisma.userCollection.findMany({
-      where: {
-        userUid: userUID,
-        parentID: collectionID,
-        type: reqType,
-      },
-      orderBy: {
-        orderIndex: 'asc',
-      },
-    });
-
-    // Create a list of child collection and request data ready for export
-    const collectionListObjects: CollectionFolder[] = [];
-    for (const coll of childCollectionList) {
-      const result = await this.exportUserCollectionToJSONObject(
-        userUID,
-        coll.id,
-      );
-      if (E.isLeft(result)) return E.left(result.left);
-
-      collectionListObjects.push(result.right);
-    }
-
-    // If collectionID is not null, return JSON stringified data for specific collection
-    if (collectionID) {
-      // Get Details of collection
-      const parentCollection = await this.getUserCollection(collectionID);
-      if (E.isLeft(parentCollection)) return E.left(parentCollection.left);
-
-      if (parentCollection.right.type !== reqType)
-        return E.left(USER_COLL_NOT_SAME_TYPE);
-
-      // Fetch all child requests that belong to collectionID
-      const requests = await this.prisma.userRequest.findMany({
-        where: {
-          userUid: userUID,
-          collectionID: parentCollection.right.id,
-        },
-        orderBy: {
-          orderIndex: 'asc',
-        },
-      });
-
-      return E.right(<UserCollectionExportJSONData>{
-        exportedCollection: JSON.stringify({
-          id: parentCollection.right.id,
-          name: parentCollection.right.title,
-          folders: collectionListObjects,
-          requests: requests.map((x) => {
-            return {
-              id: x.id,
-              name: x.title,
-              ...(x.request as Record<string, unknown>), // type casting x.request of type Prisma.JSONValue to an object to enable spread
-            };
-          }),
-          data: JSON.stringify(parentCollection.right.data),
-        }),
-        collectionType: parentCollection.right.type,
-      });
-    }
-
-    return E.right(<UserCollectionExportJSONData>{
-      exportedCollection: JSON.stringify(collectionListObjects),
-      collectionType: reqType,
-    });
-  }
-
-  /**
-   * Generate a Prisma query object representation of a collection and its child collections and requests
-   *
-   * @param folder CollectionFolder from client
-   * @param userID The User ID
-   * @param orderIndex Initial OrderIndex of
-   * @param reqType The Type of Collection
-   * @returns A Prisma query object to create a collection, its child collections and requests
-   */
-  private generatePrismaQueryObj(
-    folder: CollectionFolder,
-    userID: string,
-    orderIndex: number,
-    reqType: DBReqType,
-  ): Prisma.UserCollectionCreateInput {
-    // Parse collection data if it exists
-    let data = null;
-    if (folder.data) {
-      try {
-        data =
-          typeof folder.data === 'string'
-            ? JSON.parse(folder.data)
-            : folder.data;
-      } catch (error) {
-        // If data parsing fails, log error and continue without data
-        console.error('Failed to parse collection data:', error);
-      }
-    }
-
-    return {
-      title: folder.name,
-      data,
-      user: {
-        connect: {
-          uid: userID,
-        },
-      },
-      requests: {
-        create: folder.requests.map((r, index) => ({
-          title: r.name,
-          user: {
-            connect: {
-              uid: userID,
-            },
-          },
-          type: reqType,
-          request: r,
-          orderIndex: index + 1,
-        })),
-      },
-      orderIndex: orderIndex,
-      type: reqType,
-      children: {
-        create: folder.folders.map((f, index) =>
-          this.generatePrismaQueryObj(f, userID, index + 1, reqType),
-        ),
-      },
-    };
-  }
-
-  /**
-   * Create new UserCollections and UserRequests from JSON string
-   *
-   * @param jsonString The JSON string of the content
-   * @param userID The User ID
-   * @param destCollectionID The Collection ID
-   * @param reqType The Type of Collection
-   * @param isCollectionDuplication Boolean to publish collection create event on designated channel
-   * @returns An Either of a Boolean if the creation operation was successful
-   */
-  async importCollectionsFromJSON(
-    jsonString: string,
-    userID: string,
-    destCollectionID: string | null,
-    reqType: DBReqType,
-    isCollectionDuplication = false,
-  ) {
-    // Check to see if jsonString is valid
-    const collectionsList = stringToJson<CollectionFolder[]>(jsonString);
-    if (E.isLeft(collectionsList)) return E.left(USER_COLL_INVALID_JSON);
-
-    // Check to see if parsed jsonString is an array
-    if (!Array.isArray(collectionsList.right))
-      return E.left(USER_COLL_INVALID_JSON);
-
-    // Check to see if destCollectionID belongs to this User
-    if (destCollectionID) {
-      const parentCollection = await this.getUserCollection(destCollectionID);
-      if (E.isLeft(parentCollection)) return E.left(parentCollection.left);
-
-      // Check to see if parentUserCollectionID belongs to this User
-      if (parentCollection.right.userUid !== userID)
-        return E.left(USER_NOT_OWNER);
-
-      // Check to see if parent collection is of the same type of new collection being created
-      if (parentCollection.right.type !== reqType)
-        return E.left(USER_COLL_NOT_SAME_TYPE);
-    }
-
-    let userCollections: UserCollection[] = [];
-
-    try {
-      await this.prisma.$transaction(async (tx) => {
-        try {
-          // lock the rows
-          await this.prisma.lockTableExclusive(tx, 'UserCollection');
-
-          // Get the last order index
-          const lastCollection = await tx.userCollection.findFirst({
-            where: { userUid: userID, parentID: destCollectionID },
-            orderBy: { orderIndex: 'desc' },
-          });
-          let lastOrderIndex = lastCollection ? lastCollection.orderIndex : 0;
-
-          // Generate Prisma Query Object for all child collections in collectionsList
-          const queryList = collectionsList.right.map((x) =>
-            this.generatePrismaQueryObj(x, userID, ++lastOrderIndex, reqType),
-          );
-
-          const parent = destCollectionID
-            ? { connect: { id: destCollectionID } }
-            : undefined;
-
-          const promises = queryList.map((query) =>
-            tx.userCollection.create({
-              data: { ...query, parent },
-            }),
-          );
-
-          userCollections = await Promise.all(promises);
-        } catch (error) {
-          throw new ConflictException(error);
-        }
-      });
-    } catch (error) {
-      return E.left(USER_COLLECTION_CREATION_FAILED);
-    }
-
-    // Fetch nested collections after transaction is committed
-    const importedCollectionsWithChildren: CollectionFolder[] = [];
-    for (const userCollection of userCollections) {
-      const exportedCollectionJSON =
-        await this.exportUserCollectionToJSONObject(userID, userCollection.id);
-      if (E.isLeft(exportedCollectionJSON))
-        return E.left(exportedCollectionJSON.left);
-      importedCollectionsWithChildren.push(exportedCollectionJSON.right);
-    }
-
-    if (isCollectionDuplication) {
-      const duplicatedCollectionData = await this.fetchCollectionData(
-        userCollections[0].id,
-      );
-      if (E.isRight(duplicatedCollectionData)) {
-        this.pubsub.publish(
-          `user_coll/${userID}/duplicated`,
-          duplicatedCollectionData.right,
-        );
-      }
-    } else {
-      userCollections.forEach((collection) =>
-        this.pubsub.publish(
-          `user_coll/${userID}/created`,
-          this.cast(collection),
-        ),
-      );
-    }
-
-    return E.right({
-      exportedCollection: JSON.stringify(importedCollectionsWithChildren),
-      collectionType: reqType,
-    } as UserCollectionExportJSONData);
-  }
-
-  /**
-   * Update a UserCollection
-   *
-   * @param newTitle The new title of collection
-   * @param userCollectionID The Collection Id
-   * @param userID The User UID
-   * @returns An Either of the updated UserCollection
-   */
-  async updateUserCollection(
-    newTitle: string = null,
-    collectionData: string | null = null,
-    userCollectionID: string,
-    userID: string,
-  ) {
-    if (collectionData === '') return E.left(USER_COLL_DATA_INVALID);
-
-    if (collectionData) {
-      const jsonReq = stringToJson(collectionData);
-      if (E.isLeft(jsonReq)) return E.left(USER_COLL_DATA_INVALID);
-      collectionData = jsonReq.right;
-    }
-
-    if (newTitle != null) {
-      const isTitleValid = isValidLength(newTitle, this.TITLE_LENGTH);
-      if (!isTitleValid) return E.left(USER_COLL_SHORT_TITLE);
-    }
-
-    // Check to see is the collection belongs to the user
-    const isOwner = await this.isOwnerCheck(userCollectionID, userID);
-    if (O.isNone(isOwner)) return E.left(USER_NOT_OWNER);
-
-    try {
-      const updatedUserCollection = await this.prisma.userCollection.update({
-        where: {
-          id: userCollectionID,
-        },
-        data: {
-          data: collectionData ?? undefined,
-          title: newTitle ?? undefined,
-        },
-      });
-
-      this.pubsub.publish(
-        `user_coll/${updatedUserCollection.userUid}/updated`,
-        this.cast(updatedUserCollection),
-      );
-
-      return E.right(this.cast(updatedUserCollection));
-    } catch (error) {
-      return E.left(USER_COLL_NOT_FOUND);
-    }
-  }
-
-  /**
-   * Duplicate a User Collection
-   *
-   * @param collectionID The Collection ID
-   * @returns Boolean of duplication status
-   */
-  async duplicateUserCollection(
-    collectionID: string,
-    userID: string,
-    reqType: DBReqType,
-  ) {
-    const collection = await this.getUserCollection(collectionID);
-    if (E.isLeft(collection)) return E.left(USER_COLL_NOT_FOUND);
-
-    if (collection.right.userUid !== userID) return E.left(USER_NOT_OWNER);
-    if (collection.right.type !== reqType)
-      return E.left(USER_COLL_NOT_SAME_TYPE);
-
-    const collectionJSONObject = await this.exportUserCollectionToJSONObject(
-      collection.right.userUid,
-      collectionID,
-    );
-    if (E.isLeft(collectionJSONObject))
-      return E.left(collectionJSONObject.left);
-
-    const result = await this.importCollectionsFromJSON(
-      JSON.stringify([
-        {
-          ...collectionJSONObject.right,
-          name: `${collection.right.title} - Duplicate`,
-        },
-      ]),
-      userID,
-      collection.right.parentID,
-      reqType,
-      true,
-    );
-    if (E.isLeft(result)) return E.left(result.left as string);
-
-    return E.right(true);
-  }
-
-  /**
-   * Generates a JSON containing all the contents of a collection
-   *
-   * @param collection Collection whose details we want to fetch
-   * @returns A JSON string containing all the contents of a collection
-   */
-  private async fetchCollectionData(
-    collectionID: string,
-  ): Promise<E.Left<string> | E.Right<UserCollectionDuplicatedData>> {
-    const collection = await this.getUserCollection(collectionID);
-    if (E.isLeft(collection)) return E.left(collection.left);
-
-    const { id, title, data, type, parentID, userUid } = collection.right;
-    const orderIndex = 'asc';
-
-    const [childCollections, requests] = await Promise.all([
-      this.prisma.userCollection.findMany({
-        where: { parentID: id },
-        orderBy: { orderIndex },
-      }),
-      this.prisma.userRequest.findMany({
-        where: { collectionID: id },
-        orderBy: { orderIndex },
-      }),
-    ]);
-
-    const childCollectionDataList = await Promise.all(
-      childCollections.map(({ id }) => this.fetchCollectionData(id)),
-    );
-
-    const failedChildData = childCollectionDataList.find(E.isLeft);
-    if (failedChildData) return E.left(failedChildData.left);
-
-    const childCollectionsJSONStr = JSON.stringify(
-      (childCollectionDataList as E.Right<UserCollectionDuplicatedData>[]).map(
-        (childCollection) => childCollection.right,
-      ),
-    );
-
-    const transformedRequests = requests.map((requestObj) => ({
-      ...requestObj,
-      request: JSON.stringify(requestObj.request),
-    }));
-
-    return E.right(<UserCollectionDuplicatedData>{
-      id,
-      title,
-      data,
-      type,
-      parentID,
-      userID: userUid,
-      childCollections: childCollectionsJSONStr,
-      requests: transformedRequests,
-    });
-  }
-
-  /**
-   * Sort collections in a parent collection
-   * @param userID The User UID
-   * @param parentID The ID of the parent collection or null for root collections
-   * @param sortBy The sorting option
-   * @returns An Either of a Boolean if the sorting operation was successful
-   */
-  async sortUserCollections(
-    userID: string,
-    parentID: string | null,
-    sortBy: SortOptions,
-  ) {
-    // Handle all sort options, including a default
-    let orderBy: Prisma.Enumerable<Prisma.UserCollectionOrderByWithRelationInput>;
-    if (sortBy === SortOptions.TITLE_ASC) {
-      orderBy = { title: 'asc' };
-    } else if (sortBy === SortOptions.TITLE_DESC) {
-      orderBy = { title: 'desc' };
-    } else {
-      orderBy = { orderIndex: 'asc' };
-    }
-
-    try {
-      await this.prisma.$transaction(async (tx) => {
-        await this.prisma.acquireLocks(tx, 'UserCollection', userID, parentID);
-
-        const collections = await tx.userCollection.findMany({
-          where: { userUid: userID, parentID },
-          orderBy,
-          select: { id: true },
-        });
-
-        const promises = collections.map((coll, index) =>
-          tx.userCollection.update({
-            where: { id: coll.id },
-            data: { orderIndex: index + 1 },
-          }),
-        );
-        await Promise.all(promises);
-      });
-    } catch (error) {
-      console.error('Error from UserCollectionService.sortUserCollections:', {
-        error,
-      });
-      return E.left(USER_COLL_REORDERING_FAILED);
-    }
-
-    return E.right(true);
-  }
-}
+                ? lastCollectionUnderNewPar
\ No newline at end of file
