diff --git a/packages/hoppscotch-backend/src/team/team.service.spec.ts b/packages/hoppscotch-backend/src/team/team.service.spec.ts
index 6126405..36cca93 100644
--- a/packages/hoppscotch-backend/src/team/team.service.spec.ts
+++ b/packages/hoppscotch-backend/src/team/team.service.spec.ts
@@ -361,8 +361,8 @@ describe('renameTeam', () => {
     ).resolves.toEqualLeft(TEAM_INVALID_ID);
   });
 
-  test('rejects for new team name empty with TEAM_NAME_INVALID', () => {
-    const newTeamName = '';
+  test('rejects for new team name length < 6 with TEAM_NAME_INVALID', () => {
+    const newTeamName = 'smol';
 
     // Prisma doesn't care about the team name length, so it will resolve
     mockPrisma.team.update.mockResolvedValue({
@@ -443,553 +443,4 @@ describe('updateTeamAccessRole', () => {
     });
 
     // Prisma doesn't care if it goes through
-    mockPrisma.teamMember.update.mockResolvedValue(dbTeamMember);
-
-    return expect(
-      teamService.updateTeamAccessRole(
-        dbTeamMember.teamID,
-        dbTeamMember.userUid,
-        TeamAccessRole[dbTeamMember.role],
-      ),
-    ).resolves.toEqualLeft(TEAM_ONLY_ONE_OWNER);
-  });
-
-  test('resolves if you change the status of the sole owner to owner status (no change)', () => {
-    mockPrisma.teamMember.count.mockResolvedValue(1);
-    mockPrisma.teamMember.findUnique.mockResolvedValue({
-      ...dbTeamMember,
-      role: TeamAccessRole.OWNER,
-    });
-    mockPrisma.teamMember.update.mockResolvedValue({
-      ...dbTeamMember,
-      role: TeamAccessRole.OWNER,
-    });
-
-    return expect(
-      teamService.updateTeamAccessRole(
-        dbTeamMember.teamID,
-        dbTeamMember.userUid,
-        TeamAccessRole[TeamAccessRole.OWNER],
-      ),
-    ).resolves.toBeDefined();
-  });
-
-  test('resolves if you change the status of an owner but there are other owners', async () => {
-    mockPrisma.teamMember.count.mockResolvedValue(2);
-    mockPrisma.teamMember.findUnique.mockResolvedValue({
-      ...dbTeamMember,
-      role: TeamAccessRole.OWNER,
-    });
-    mockPrisma.teamMember.update.mockResolvedValue(dbTeamMember);
-
-    // Set another user as the owner
-    await teamService.updateTeamAccessRole(
-      dbTeamMember.teamID,
-      'testuid2',
-      TeamAccessRole.OWNER,
-    );
-
-    await expect(
-      teamService.updateTeamAccessRole(
-        dbTeamMember.teamID,
-        dbTeamMember.userUid,
-        TeamAccessRole[dbTeamMember.role],
-      ),
-    ).resolves.toBeDefined();
-  });
-
-  test('fires "team/<team_id>/member_updated" pubsub message with correct payload', async () => {
-    const newRole = TeamAccessRole.EDITOR;
-
-    mockPrisma.teamMember.count.mockResolvedValue(2);
-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);
-    mockPrisma.teamMember.update.mockResolvedValue({
-      ...dbTeamMember,
-      role: newRole,
-    });
-
-    await teamService.updateTeamAccessRole(
-      dbTeamMember.teamID,
-      dbTeamMember.userUid,
-      newRole,
-    );
-
-    expect(mockPubSub.publish).toHaveBeenCalledWith(
-      `team/${dbTeamMember.teamID}/member_updated`,
-      {
-        ...teamMember,
-        role: newRole,
-      },
-    );
-  });
-});
-
-describe('leaveTeam', () => {
-  /*
-    Same scenario as above:
-      3 users (testuid1 thru 3) with respectively
-      OWNER, VIEWER and EDITOR roles in team with id 3170
-  */
-
-  test('removes the user if valid credentials given', async () => {
-    mockPrisma.teamMember.count.mockResolvedValue(2);
-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);
-    mockPrisma.teamMember.delete.mockResolvedValue(dbTeamMember);
-
-    await teamService.leaveTeam(dbTeamMember.teamID, dbTeamMember.userUid);
-
-    expect(mockPrisma.teamMember.delete).toHaveBeenCalledWith({
-      where: {
-        teamID_userUid: {
-          teamID: dbTeamMember.teamID,
-          userUid: dbTeamMember.userUid,
-        },
-      },
-    });
-  });
-
-  test('rejects if invalid teamId with TEAM_INVALID_ID_OR_USER', () => {
-    // Invalid team id will return 0 count
-    mockPrisma.teamMember.count.mockResolvedValue(0);
-
-    // getTeamMember returns null if no match
-    mockPrisma.teamMember.findUnique.mockResolvedValue(null);
-
-    // Deletion rejects with RecordNotFound when no match
-    mockPrisma.teamMember.delete.mockRejectedValue('RecordNotFound');
-
-    return expect(
-      teamService.leaveTeam('31700', dbTeamMember.userUid),
-    ).resolves.toEqualLeft(TEAM_INVALID_ID_OR_USER);
-  });
-
-  test('rejects if invalid userUid with TEAM_INVALID_ID_OR_USER', () => {
-    // Invalid team id will return proper count
-    mockPrisma.teamMember.count.mockResolvedValue(1);
-
-    // getTeamMember returns null if no match
-    mockPrisma.teamMember.findUnique.mockResolvedValue(null);
-
-    // Deletion rejects with RecordNotFound when no match
-    mockPrisma.teamMember.delete.mockRejectedValue('RecordNotFound');
-
-    return expect(
-      teamService.leaveTeam(dbTeamMember.teamID, 'testuid3'),
-    ).resolves.toEqualLeft(TEAM_INVALID_ID_OR_USER);
-  });
-
-  test('rejects if the removed user is the sole owner of the team with TEAM_ONLY_ONE_OWNER', () => {
-    mockPrisma.teamMember.count.mockResolvedValue(1);
-    mockPrisma.teamMember.findUnique.mockResolvedValue({
-      ...dbTeamMember,
-      role: TeamAccessRole.OWNER,
-    });
-
-    // Prisma does not care
-    mockPrisma.teamMember.delete.mockResolvedValue({
-      ...dbTeamMember,
-      role: TeamAccessRole.OWNER,
-    });
-
-    return expect(
-      teamService.leaveTeam(dbTeamMember.teamID, dbTeamMember.userUid),
-    ).resolves.toEqualLeft(TEAM_ONLY_ONE_OWNER);
-  });
-
-  test('resolves if the removed user is an owner (but not the sole) of the team', async () => {
-    mockPrisma.teamMember.count.mockResolvedValue(2);
-    mockPrisma.teamMember.findUnique.mockResolvedValue({
-      ...dbTeamMember,
-      role: TeamAccessRole.OWNER,
-    });
-    mockPrisma.teamMember.delete.mockResolvedValue({
-      ...dbTeamMember,
-      role: TeamAccessRole.OWNER,
-    });
-
-    await expect(
-      teamService.leaveTeam(dbTeamMember.teamID, dbTeamMember.userUid),
-    ).resolves.toEqualRight(true);
-  });
-
-  test('fires "team/<team_id>/member_removed" pubsub message with correct payload', async () => {
-    mockPrisma.teamMember.count.mockResolvedValue(2);
-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);
-    mockPrisma.teamMember.delete.mockResolvedValue(dbTeamMember);
-
-    await teamService.leaveTeam(dbTeamMember.teamID, dbTeamMember.userUid);
-
-    expect(mockPubSub.publish).toHaveBeenCalledWith(
-      `team/${dbTeamMember.teamID}/member_removed`,
-      dbTeamMember.userUid,
-    );
-  });
-});
-
-describe('createTeam', () => {
-  test('adds the new team to the db', async () => {
-    mockPrisma.team.create.mockResolvedValue(team);
-
-    await teamService.createTeam(team.name, dbTeamMember.userUid);
-
-    expect(mockPrisma.team.create).toHaveBeenCalledWith(
-      expect.objectContaining({
-        data: expect.objectContaining({
-          name: team.name,
-        }),
-      }),
-    );
-  });
-
-  test('adds the creator to team and set them as OWNER', async () => {
-    mockPrisma.team.create.mockResolvedValue(team);
-
-    await teamService.createTeam(team.name, dbTeamMember.userUid);
-
-    expect(mockPrisma.team.create).toHaveBeenCalledWith(
-      expect.objectContaining({
-        data: expect.objectContaining({
-          members: {
-            create: {
-              userUid: dbTeamMember.userUid,
-              role: TeamAccessRole.OWNER,
-            },
-          },
-        }),
-      }),
-    );
-  });
-
-  test('resolves with the team info', () => {
-    mockPrisma.team.create.mockResolvedValue(team);
-
-    return expect(
-      teamService.createTeam(team.name, dbTeamMember.userUid),
-    ).resolves.toEqualRight(expect.objectContaining(team));
-  });
-
-  test('rejects for team name empty with TEAM_NAME_INVALID', () => {
-    const newName = '';
-
-    // Prisma doesn't care
-    mockPrisma.team.create.mockResolvedValue({
-      ...team,
-      name: newName,
-    });
-
-    return expect(
-      teamService.createTeam(newName, dbTeamMember.userUid),
-    ).resolves.toEqualLeft(TEAM_NAME_INVALID);
-  });
-});
-
-describe('getTeamWithID', () => {
-  test('resolves for a proper team id with the proper details', () => {
-    mockPrisma.team.findUnique.mockResolvedValue(team);
-
-    return expect(teamService.getTeamWithID(team.id)).resolves.toEqual(
-      expect.objectContaining(team),
-    );
-  });
-
-  test('resolves for a invalid team id as null', () => {
-    // Prisma would reject with RecordNotFound
-    mockPrisma.team.findUnique.mockRejectedValue('RecordNotFound');
-
-    return expect(teamService.getTeamWithID('3171')).resolves.toBeNull();
-  });
-});
-
-describe('getTeamMember', () => {
-  test('resolves for a proper team id and user uid and returns the info', () => {
-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);
-
-    return expect(
-      teamService.getTeamMember(dbTeamMember.teamID, dbTeamMember.userUid),
-    ).resolves.toEqual(expect.objectContaining(teamMember));
-  });
-
-  test('resolves for a invalid team id and proper uid and returns null', () => {
-    // If not found, prisma rejects with RecordNotFound
-    mockPrisma.teamMember.findUnique.mockRejectedValue('RecordNotFound');
-
-    return expect(
-      teamService.getTeamMember(dbTeamMember.teamID, 'testuid'),
-    ).resolves.toBeNull();
-  });
-});
-
-describe('getRoleOfUserInTeam', () => {
-  test('resolves with the correct role value', () => {
-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);
-
-    return expect(
-      teamService.getRoleOfUserInTeam(
-        dbTeamMember.teamID,
-        dbTeamMember.userUid,
-      ),
-    ).resolves.toEqual(dbTeamMember.role);
-  });
-
-  test('resolves with null if user is not found in team', () => {
-    mockPrisma.teamMember.findUnique.mockRejectedValue('RecordNotFound');
-
-    return expect(
-      teamService.getRoleOfUserInTeam(dbTeamMember.teamID, 'nottestuid'),
-    ).resolves.toBeNull();
-  });
-
-  test('resolves with null if team does not exist', () => {
-    mockPrisma.teamMember.findUnique.mockRejectedValue('RecordNotFound');
-
-    return expect(
-      teamService.getRoleOfUserInTeam('invalidteam', dbTeamMember.userUid),
-    ).resolves.toBeNull();
-  });
-});
-
-describe('getMembersOfTeam', () => {
-  test('resolves for the team id and null cursor with the first page', async () => {
-    mockPrisma.teamMember.findMany.mockResolvedValue([]);
-    await teamService.getMembersOfTeam(team.id, null);
-
-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({
-      take: 10,
-      where: {
-        teamID: team.id,
-      },
-    });
-  });
-
-  test('resolves for the team id and proper cursor with pagination', async () => {
-    const cursor = 'secondpage';
-
-    mockPrisma.teamMember.findMany.mockResolvedValue([]);
-    await teamService.getMembersOfTeam(team.id, cursor);
-
-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({
-      take: 10,
-      skip: 1,
-      cursor: {
-        id: cursor,
-      },
-      where: {
-        teamID: team.id,
-      },
-    });
-  });
-
-  test('resolves with an empty array for invalid team id and null cursor', () => {
-    // findMany returns an empty array if no matches are found
-    mockPrisma.teamMember.findMany.mockResolvedValue([]);
-
-    return expect(
-      teamService.getMembersOfTeam('invalidteamid', null),
-    ).resolves.toHaveLength(0);
-  });
-
-  test('resolves with an empty array for an invalid team id and invalid cursor', () => {
-    // findMany returns an empty array if no matches are found
-    mockPrisma.teamMember.findMany.mockResolvedValue([]);
-
-    return expect(
-      teamService.getMembersOfTeam('invalidteamid', 'invalidcursor'),
-    ).resolves.toHaveLength(0);
-  });
-});
-
-describe('getTeamsOfUser', () => {
-  test('resolves with the first 10 elements when no cursor is given', async () => {
-    mockPrisma.teamMember.findMany.mockResolvedValue([]);
-
-    await teamService.getTeamsOfUser(dbTeamMember.userUid, null);
-
-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({
-      take: 10,
-      where: {
-        userUid: dbTeamMember.userUid,
-      },
-      include: {
-        team: true,
-      },
-    });
-  });
-
-  test('resolves as expected for paginated requests with cursor', async () => {
-    const cursor = 'secondpage';
-
-    mockPrisma.teamMember.findMany.mockResolvedValue([]);
-    await teamService.getTeamsOfUser(dbTeamMember.userUid, cursor);
-
-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({
-      take: 10,
-      skip: 1,
-      cursor: {
-        teamID_userUid: {
-          teamID: cursor,
-          userUid: dbTeamMember.userUid,
-        },
-      },
-      where: {
-        userUid: dbTeamMember.userUid,
-      },
-      include: {
-        team: true,
-      },
-    });
-  });
-
-  test('resolves with an empty array for an invalid cursor', () => {
-    // Invalid cursors return an empty array
-    mockPrisma.teamMember.findMany.mockResolvedValue([]);
-
-    return expect(
-      teamService.getTeamsOfUser(dbTeamMember.userUid, 'invalidcursor'),
-    ).resolves.toHaveLength(0);
-  });
-
-  test('resolves with an empty array for invalid user id and null cursor', () => {
-    mockPrisma.teamMember.findMany.mockResolvedValue([]);
-
-    return expect(
-      teamService.getTeamsOfUser('invalidid', null),
-    ).resolves.toHaveLength(0);
-  });
-
-  test('resolves with an empty array for invalid user id and invalid cursor', () => {
-    mockPrisma.teamMember.findMany.mockResolvedValue([]);
-
-    return expect(
-      teamService.getTeamsOfUser('invalidId', 'invalidCursor'),
-    ).resolves.toHaveLength(0);
-  });
-});
-
-describe('deleteUserFromAllTeams', () => {
-  test('should return undefined when a valid uid is passed and user is deleted from all teams', async () => {
-    mockPrisma.teamMember.findMany.mockResolvedValue([dbTeamMember]);
-    mockPrisma.teamMember.count.mockResolvedValue(2);
-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);
-
-    const result = await teamService.deleteUserFromAllTeams(
-      dbTeamMember.userUid,
-    )();
-
-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({
-      where: {
-        userUid: dbTeamMember.userUid,
-      },
-    });
-
-    expect(result).toBeUndefined();
-  });
-
-  test('should return undefined when user has no data or the uid is invalid', async () => {
-    mockPrisma.teamMember.findMany.mockResolvedValue([]);
-
-    const result = await teamService.deleteUserFromAllTeams(
-      dbTeamMember.userUid,
-    )();
-
-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({
-      where: {
-        userUid: dbTeamMember.userUid,
-      },
-    });
-
-    expect(result).toBeUndefined();
-  });
-
-  test('should reject when user is an OWNER in a team with only 1 member', async () => {
-    mockPrisma.teamMember.findMany.mockResolvedValue([dbTeamMember]);
-    mockPrisma.teamMember.count.mockResolvedValue(1);
-    mockPrisma.teamMember.findUnique.mockResolvedValue({
-      ...dbTeamMember,
-      role: TeamAccessRole.OWNER,
-    });
-
-    const result = teamService.deleteUserFromAllTeams(dbTeamMember.userUid)();
-
-    await expect(result).rejects.toThrow(TEAM_ONLY_ONE_OWNER);
-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({
-      where: {
-        userUid: dbTeamMember.userUid,
-      },
-    });
-  });
-
-  test('should reject when a valid uid is passed but fetching teamMember details errors out', async () => {
-    mockPrisma.teamMember.findMany.mockResolvedValue([
-      {
-        ...dbTeamMember,
-        role: TeamAccessRole.OWNER,
-      },
-    ]);
-    mockPrisma.teamMember.count.mockResolvedValue(2);
-
-    // findUnique while getTeamMember() is called errors out
-    mockPrisma.teamMember.findUnique.mockRejectedValueOnce('NotFoundError');
-
-    const result = teamService.deleteUserFromAllTeams(dbTeamMember.userUid);
-
-    await expect(result).rejects.toThrow(TEAM_INVALID_ID_OR_USER);
-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({
-      where: {
-        userUid: dbTeamMember.userUid,
-      },
-    });
-  });
-});
-
-describe('fetchAllTeams', () => {
-  test('should resolve right and return 20 teams when cursor is null', async () => {
-    mockPrisma.team.findMany.mockResolvedValueOnce(teams);
-
-    const result = await teamService.fetchAllTeams(null, 20);
-    expect(result).toEqual(teams);
-  });
-  test('should resolve right and return next 20 teams when cursor is provided', async () => {
-    mockPrisma.team.findMany.mockResolvedValueOnce(teams);
-
-    const result = await teamService.fetchAllTeams('teamID', 20);
-    expect(result).toEqual(teams);
-  });
-  test('should resolve left and return an empty array when users not found', async () => {
-    mockPrisma.team.findMany.mockResolvedValueOnce([]);
-
-    const result = await teamService.fetchAllTeams(null, 20);
-    expect(result).toEqual([]);
-  });
-});
-
-describe('getCountOfMembersInTeam', () => {
-  test('should resolve right and return a total team member count ', async () => {
-    mockPrisma.teamMember.count.mockResolvedValueOnce(2);
-    const result = await teamService.getCountOfMembersInTeam(team.id);
-    expect(mockPrisma.teamMember.count).toHaveBeenCalledWith({
-      where: {
-        teamID: team.id,
-      },
-    });
-    expect(result).toEqual(2);
-  });
-  test('should resolve left and return an error when no team members found', async () => {
-    mockPrisma.teamMember.count.mockResolvedValueOnce(0);
-    const result = await teamService.getCountOfMembersInTeam(team.id);
-    expect(mockPrisma.teamMember.count).toHaveBeenCalledWith({
-      where: {
-        teamID: team.id,
-      },
-    });
-    expect(result).toEqual(0);
-  });
-
-  describe('getTeamsCount', () => {
-    test('should return count of all teams in the organization', async () => {
-      mockPrisma.team.count.mockResolvedValueOnce(10);
-
-      const result = await teamService.getTeamsCount();
-      expect(result).toEqual(10);
-    });
-  });
-});
+    mockPrisma.teamMember.update.
\ No newline at end of file
diff --git a/packages/hoppscotch-backend/src/team/team.service.ts b/packages/hoppscotch-backend/src/team/team.service.ts
index bad4bd1..4ea377a 100644
--- a/packages/hoppscotch-backend/src/team/team.service.ts
+++ b/packages/hoppscotch-backend/src/team/team.service.ts
@@ -125,6 +125,11 @@ export class TeamService implements UserDataHandler, OnModuleInit {
     return E.right(true);
   }
 
+  validateTeamName(title: string): E.Left<string> | E.Right<boolean> {
+    if (!title || title.length < 6) return E.left(TEAM_NAME_INVALID);
+    return E.right(true);
+  }
+
   async renameTeam(
     teamID: string,
     newName: string,
@@ -499,48 +504,4 @@ export class TeamService implements UserDataHandler, OnModuleInit {
         cursor: {
           id: cursor,
         },
-        where: {
-          teamID,
-        },
-      });
-    }
-
-    const members = teamMembers.map(
-      (entry) =>
-        <TeamMember>{
-          membershipID: entry.id,
-          userUid: entry.userUid,
-          role: TeamAccessRole[entry.role],
-        },
-    );
-
-    return this.filterMismatchedUsers(teamID, members);
-  }
-
-  /**
-   * Fetch all the teams in the `Team` table based on cursor
-   * @param cursorID string of teamID or undefined
-   * @param take number of items to query
-   * @returns an array of `Team` object
-   */
-  async fetchAllTeams(cursorID: string, take: number) {
-    const options = {
-      skip: cursorID ? 1 : 0,
-      take: take,
-      cursor: cursorID ? { id: cursorID } : undefined,
-    };
-
-    const fetchedTeams = await this.prisma.team.findMany(options);
-    return fetchedTeams;
-  }
-
-  /**
-   * Fetch list of all the Teams in the DB
-   *
-   * @returns number of teams in the org
-   */
-  async getTeamsCount() {
-    const teamsCount = await this.prisma.team.count();
-    return teamsCount;
-  }
-}
+        where
\ No newline at end of file
diff --git a/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts b/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts
index 26182ec..eb6260a 100644
--- a/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts
+++ b/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts
@@ -6,8 +6,8 @@ interface TeamNameBrand {
 
 export const TeamNameCodec = t.brand(
   t.string,
-  (x): x is t.Branded<string, TeamNameBrand> => x.trim() !== "",
+  (x): x is t.Branded<string, TeamNameBrand> => x.trim().length >= 6,
   "TeamName"
 )
 
-export type TeamName = t.TypeOf<typeof TeamNameCodec>
+export type TeamName = t.TypeOf<typeof TeamNameCodec>
\ No newline at end of file
