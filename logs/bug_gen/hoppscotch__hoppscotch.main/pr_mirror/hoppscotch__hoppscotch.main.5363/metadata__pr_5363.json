{
    "cost": 0.29383000000000004,
    "rewrites": {
        "hoppscotch__hoppscotch.main/packages/hoppscotch-backend/src/team/team.service.spec.ts": {
            "output": "import { TeamService } from './team.service';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { Team, TeamMember, TeamAccessRole } from './team.model';\nimport { TeamMember as DbTeamMember } from 'src/generated/prisma/client';\nimport {\n  USER_NOT_FOUND,\n  TEAM_INVALID_ID,\n  TEAM_NAME_INVALID,\n  TEAM_ONLY_ONE_OWNER,\n  TEAM_INVALID_ID_OR_USER,\n} from '../errors';\nimport { mockDeep, mockReset } from 'jest-mock-extended';\nimport * as O from 'fp-ts/Option';\n\nconst mockPrisma = mockDeep<PrismaService>();\n\nconst mockUserService = {\n  findUserByEmail: jest.fn(),\n  getUserForUID: jest.fn(),\n  authenticateWithIDToken: jest.fn(),\n};\n\nconst mockPubSub = {\n  publish: jest.fn().mockResolvedValue(null),\n};\n\nconst teamService = new TeamService(\n  mockPrisma as any,\n  mockUserService as any,\n  mockPubSub as any,\n);\n\nbeforeEach(async () => {\n  mockReset(mockPrisma);\n});\n\nconst team: Team = {\n  id: 'teamID',\n  name: 'teamName',\n};\n\nconst teams: Team[] = [\n  {\n    id: 'teamID',\n    name: 'teamName',\n  },\n  {\n    id: 'teamID2',\n    name: 'teamName2',\n  },\n];\nconst dbTeamMember: DbTeamMember = {\n  id: 'teamMemberID',\n  role: TeamAccessRole.VIEWER,\n  userUid: 'userUid',\n  teamID: team.id,\n};\nconst teamMember: TeamMember = {\n  membershipID: dbTeamMember.id,\n  role: TeamAccessRole[dbTeamMember.role],\n  userUid: dbTeamMember.userUid,\n};\n\ndescribe('getCountOfUsersWithRoleInTeam', () => {\n  test('resolves to the correct count of owners in a team', async () => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    mockPrisma.teamMember.count.mockResolvedValue(2);\n\n    await expect(\n      teamService.getCountOfUsersWithRoleInTeam(\n        dbTeamMember.teamID,\n        TeamAccessRole.OWNER,\n      ),\n    ).resolves.toEqual(2);\n\n    expect(mockPrisma.teamMember.count).toHaveBeenCalledWith({\n      where: {\n        teamID: dbTeamMember.teamID,\n        role: TeamAccessRole.OWNER,\n      },\n    });\n  });\n\n  test('resolves to the correct count of viewers in a team', async () => {\n    mockPrisma.teamMember.count.mockResolvedValue(2);\n\n    await expect(\n      teamService.getCountOfUsersWithRoleInTeam(\n        dbTeamMember.teamID,\n        TeamAccessRole.VIEWER,\n      ),\n    ).resolves.toEqual(2);\n\n    expect(mockPrisma.teamMember.count).toHaveBeenCalledWith({\n      where: {\n        teamID: dbTeamMember.teamID,\n        role: TeamAccessRole.VIEWER,\n      },\n    });\n  });\n\n  test('resolves to the correct count of editors in a team', async () => {\n    mockPrisma.teamMember.count.mockResolvedValue(2);\n\n    await expect(\n      teamService.getCountOfUsersWithRoleInTeam(\n        dbTeamMember.teamID,\n        TeamAccessRole.EDITOR,\n      ),\n    ).resolves.toEqual(2);\n\n    expect(mockPrisma.teamMember.count).toHaveBeenCalledWith({\n      where: {\n        teamID: dbTeamMember.teamID,\n        role: TeamAccessRole.EDITOR,\n      },\n    });\n  });\n});\n\ndescribe('addMemberToTeam', () => {\n  test('resolves when proper team id is given', () => {\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    expect(\n      teamService.addMemberToTeam(\n        dbTeamMember.teamID,\n        dbTeamMember.userUid,\n        TeamAccessRole[dbTeamMember.role],\n      ),\n    ).resolves.toEqual(expect.objectContaining(teamMember));\n  });\n\n  test('makes the update in the database', async () => {\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    await teamService.addMemberToTeam(\n      dbTeamMember.teamID,\n      dbTeamMember.userUid,\n      TeamAccessRole[dbTeamMember.role],\n    );\n\n    expect(mockPrisma.teamMember.create).toHaveBeenCalledWith({\n      data: {\n        userUid: dbTeamMember.userUid,\n        team: {\n          connect: {\n            id: dbTeamMember.teamID,\n          },\n        },\n        role: TeamAccessRole[dbTeamMember.role],\n      },\n    });\n  });\n\n  test('fires \"team/<team_id>/member_added\" pubsub message with correct payload', async () => {\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    const member = await teamService.addMemberToTeam(\n      dbTeamMember.teamID,\n      dbTeamMember.userUid,\n      TeamAccessRole[dbTeamMember.role],\n    );\n\n    expect(mockPubSub.publish).toHaveBeenCalledWith(\n      `team/${dbTeamMember.teamID}/member_added`,\n      member,\n    );\n  });\n});\n\ndescribe('addMemberToTeamWithEmail', () => {\n  afterEach(() => {\n    mockUserService.findUserByEmail.mockClear();\n    mockUserService.authenticateWithIDToken.mockClear();\n    mockUserService.authenticateWithIDToken.mockClear();\n  });\n\n  test('resolves when user with email exists', () => {\n    mockUserService.findUserByEmail.mockResolvedValueOnce(\n      O.some({\n        uid: dbTeamMember.userUid,\n      }),\n    );\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    const result = teamService.addMemberToTeamWithEmail(\n      dbTeamMember.teamID,\n      'test@hoppscotch.io',\n      TeamAccessRole[dbTeamMember.role],\n    );\n    return expect(result).resolves.toBeDefined();\n  });\n\n  test(\"rejects with user with email doesn't exist with USER_NOT_FOUND\", () => {\n    mockUserService.findUserByEmail.mockResolvedValue(O.none);\n\n    const result = teamService.addMemberToTeamWithEmail(\n      dbTeamMember.teamID,\n      'test@hoppscotch.io',\n      TeamAccessRole[dbTeamMember.role],\n    );\n    return expect(result).resolves.toEqualLeft(USER_NOT_FOUND);\n  });\n\n  test('makes update in the database', async () => {\n    mockUserService.findUserByEmail.mockResolvedValueOnce(\n      O.some({\n        uid: dbTeamMember.userUid,\n      }),\n    );\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    await teamService.addMemberToTeamWithEmail(\n      dbTeamMember.teamID,\n      'test@hoppscotch.io',\n      TeamAccessRole[dbTeamMember.role],\n    );\n\n    expect(mockPrisma.teamMember.create).toHaveBeenCalledWith({\n      data: {\n        userUid: dbTeamMember.userUid,\n        team: {\n          connect: {\n            id: dbTeamMember.teamID,\n          },\n        },\n        role: TeamAccessRole[dbTeamMember.role],\n      },\n    });\n  });\n\n  test('fires \"team/<team_id>/member_added\" pubsub message with correct payload', async () => {\n    mockUserService.findUserByEmail.mockResolvedValueOnce(\n      O.some({\n        uid: dbTeamMember.userUid,\n      }),\n    );\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    await teamService.addMemberToTeamWithEmail(\n      dbTeamMember.teamID,\n      'test@hoppscotch.io',\n      TeamAccessRole[dbTeamMember.role],\n    );\n\n    expect(mockPubSub.publish).toHaveBeenCalledWith(\n      `team/${dbTeamMember.teamID}/member_added`,\n      teamMember,\n    );\n  });\n});\n\ndescribe('deleteTeam', () => {\n  test('resolves for proper deletion', async () => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    mockPrisma.team.findUnique.mockResolvedValue(team);\n    mockPrisma.teamMember.deleteMany.mockResolvedValue({\n      count: 10,\n    });\n    mockPrisma.team.delete.mockResolvedValue(team);\n\n    const result = await teamService.deleteTeam(team.id);\n    return expect(result).toEqualRight(true);\n  });\n\n  test('performs deletion on database', async () => {\n    mockPrisma.team.findUnique.mockResolvedValue(team);\n    mockPrisma.teamMember.deleteMany.mockResolvedValue({\n      count: 10,\n    });\n    mockPrisma.team.delete.mockResolvedValue(team);\n\n    await teamService.deleteTeam(team.id);\n\n    expect(mockPrisma.team.delete).toHaveBeenCalledWith({\n      where: {\n        id: team.id,\n      },\n    });\n  });\n\n  test('rejects for invalid team id', async () => {\n    mockPrisma.team.findUnique.mockResolvedValue(null);\n\n    // If invalid team ID, team member deletes nothing (count 0)\n    mockPrisma.teamMember.deleteMany.mockResolvedValue({\n      count: 0,\n    });\n\n    // TODO: Confirm RecordNotFound works like this\n    mockPrisma.team.delete.mockRejectedValue('RecordNotFound');\n\n    // Team will not find and reject\n    const result = await teamService.deleteTeam(team.id);\n    return expect(result).toEqualLeft(TEAM_INVALID_ID);\n  });\n});\n\ndescribe('renameTeam', () => {\n  test('resolves for proper rename', () => {\n    const newTeamName = 'Rename';\n\n    mockPrisma.team.update.mockResolvedValue({\n      ...team,\n      name: newTeamName,\n    });\n\n    return expect(\n      teamService.renameTeam(team.id, newTeamName),\n    ).resolves.toBeDefined();\n  });\n\n  test('resolves with team structure', () => {\n    const newTeamName = 'Rename';\n\n    mockPrisma.team.update.mockResolvedValue({\n      ...team,\n      name: newTeamName,\n    });\n\n    return expect(\n      teamService.renameTeam(team.id, newTeamName),\n    ).resolves.toEqualRight(\n      expect.objectContaining({\n        ...team,\n        name: newTeamName,\n      }),\n    );\n  });\n\n  test('performs rename on database', async () => {\n    const newTeamName = 'Rename';\n\n    mockPrisma.team.update.mockResolvedValue({\n      ...team,\n      name: newTeamName,\n    });\n\n    await teamService.renameTeam(team.id, newTeamName);\n\n    expect(mockPrisma.team.update).toHaveBeenCalledWith({\n      where: {\n        id: team.id,\n      },\n      data: {\n        name: newTeamName,\n      },\n    });\n  });\n\n  test('rejects for invalid team id with TEAM_INVALID_ID', () => {\n    const newTeamName = 'Rename';\n    // If invalid team id, update fails with RecordNotFound\n    mockPrisma.team.update.mockRejectedValue('RecordNotFound');\n\n    return expect(\n      teamService.renameTeam(team.id, newTeamName),\n    ).resolves.toEqualLeft(TEAM_INVALID_ID);\n  });\n\n  test('rejects for new team name length < 6 with TEAM_NAME_INVALID', () => {\n    const newTeamName = 'smol';\n\n    // Prisma doesn't care about the team name length, so it will resolve\n    mockPrisma.team.update.mockResolvedValue({\n      ...team,\n      name: newTeamName,\n    });\n\n    return expect(\n      teamService.renameTeam(team.id, newTeamName),\n    ).resolves.toEqualLeft(TEAM_NAME_INVALID);\n  });\n});\n\ndescribe('updateTeamAccessRole', () => {\n  /**\n   * Test Scenario:\n   * 3 users (testuid1 thru 3) having each of the roles\n   * (OWNER, VIEWER, EDITOR)\n   * in Team with id 3170\n   */\n\n  test('updates the role', async () => {\n    const newRole = TeamAccessRole.EDITOR;\n\n    mockPrisma.teamMember.count.mockResolvedValue(1);\n    mockPrisma.teamMember.findUnique.mockResolvedValue({\n      ...dbTeamMember,\n      role: TeamAccessRole[dbTeamMember.role],\n    });\n    mockPrisma.teamMember.update.mockResolvedValue({\n      ...dbTeamMember,\n      role: newRole,\n    });\n\n    await teamService.updateTeamAccessRole(\n      dbTeamMember.teamID,\n      dbTeamMember.userUid,\n      newRole,\n    );\n\n    expect(mockPrisma.teamMember.update).toHaveBeenCalledWith({\n      where: {\n        teamID_userUid: {\n          teamID: dbTeamMember.teamID,\n          userUid: dbTeamMember.userUid,\n        },\n      },\n      data: {\n        role: newRole,\n      },\n    });\n  });\n\n  test('returns the updated details', () => {\n    const newRole = TeamAccessRole.EDITOR;\n\n    mockPrisma.teamMember.count.mockResolvedValue(1);\n    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);\n    mockPrisma.teamMember.update.mockResolvedValue({\n      ...dbTeamMember,\n      role: newRole,\n    });\n\n    return expect(\n      teamService.updateTeamAccessRole(\n        dbTeamMember.teamID,\n        dbTeamMember.userUid,\n        newRole,\n      ),\n    ).resolves.toEqualRight({ ...teamMember, role: newRole });\n  });\n\n  test('rejects if you change the status of the sole owner to non-owner status with TEAM_ONLY_ONE_OWNER', () => {\n    mockPrisma.teamMember.count.mockResolvedValue(1);\n    mockPrisma.teamMember.findUnique.mockResolvedValue({\n      ...dbTeamMember,\n      role: TeamAccessRole.OWNER,\n    });\n\n    // Prisma doesn't care if it goes through\n    mockPrisma.teamMember.update.",
            "output_extracted": "import { TeamService } from './team.service';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { Team, TeamMember, TeamAccessRole } from './team.model';\nimport { TeamMember as DbTeamMember } from 'src/generated/prisma/client';\nimport {\n  USER_NOT_FOUND,\n  TEAM_INVALID_ID,\n  TEAM_NAME_INVALID,\n  TEAM_ONLY_ONE_OWNER,\n  TEAM_INVALID_ID_OR_USER,\n} from '../errors';\nimport { mockDeep, mockReset } from 'jest-mock-extended';\nimport * as O from 'fp-ts/Option';\n\nconst mockPrisma = mockDeep<PrismaService>();\n\nconst mockUserService = {\n  findUserByEmail: jest.fn(),\n  getUserForUID: jest.fn(),\n  authenticateWithIDToken: jest.fn(),\n};\n\nconst mockPubSub = {\n  publish: jest.fn().mockResolvedValue(null),\n};\n\nconst teamService = new TeamService(\n  mockPrisma as any,\n  mockUserService as any,\n  mockPubSub as any,\n);\n\nbeforeEach(async () => {\n  mockReset(mockPrisma);\n});\n\nconst team: Team = {\n  id: 'teamID',\n  name: 'teamName',\n};\n\nconst teams: Team[] = [\n  {\n    id: 'teamID',\n    name: 'teamName',\n  },\n  {\n    id: 'teamID2',\n    name: 'teamName2',\n  },\n];\nconst dbTeamMember: DbTeamMember = {\n  id: 'teamMemberID',\n  role: TeamAccessRole.VIEWER,\n  userUid: 'userUid',\n  teamID: team.id,\n};\nconst teamMember: TeamMember = {\n  membershipID: dbTeamMember.id,\n  role: TeamAccessRole[dbTeamMember.role],\n  userUid: dbTeamMember.userUid,\n};\n\ndescribe('getCountOfUsersWithRoleInTeam', () => {\n  test('resolves to the correct count of owners in a team', async () => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    mockPrisma.teamMember.count.mockResolvedValue(2);\n\n    await expect(\n      teamService.getCountOfUsersWithRoleInTeam(\n        dbTeamMember.teamID,\n        TeamAccessRole.OWNER,\n      ),\n    ).resolves.toEqual(2);\n\n    expect(mockPrisma.teamMember.count).toHaveBeenCalledWith({\n      where: {\n        teamID: dbTeamMember.teamID,\n        role: TeamAccessRole.OWNER,\n      },\n    });\n  });\n\n  test('resolves to the correct count of viewers in a team', async () => {\n    mockPrisma.teamMember.count.mockResolvedValue(2);\n\n    await expect(\n      teamService.getCountOfUsersWithRoleInTeam(\n        dbTeamMember.teamID,\n        TeamAccessRole.VIEWER,\n      ),\n    ).resolves.toEqual(2);\n\n    expect(mockPrisma.teamMember.count).toHaveBeenCalledWith({\n      where: {\n        teamID: dbTeamMember.teamID,\n        role: TeamAccessRole.VIEWER,\n      },\n    });\n  });\n\n  test('resolves to the correct count of editors in a team', async () => {\n    mockPrisma.teamMember.count.mockResolvedValue(2);\n\n    await expect(\n      teamService.getCountOfUsersWithRoleInTeam(\n        dbTeamMember.teamID,\n        TeamAccessRole.EDITOR,\n      ),\n    ).resolves.toEqual(2);\n\n    expect(mockPrisma.teamMember.count).toHaveBeenCalledWith({\n      where: {\n        teamID: dbTeamMember.teamID,\n        role: TeamAccessRole.EDITOR,\n      },\n    });\n  });\n});\n\ndescribe('addMemberToTeam', () => {\n  test('resolves when proper team id is given', () => {\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    expect(\n      teamService.addMemberToTeam(\n        dbTeamMember.teamID,\n        dbTeamMember.userUid,\n        TeamAccessRole[dbTeamMember.role],\n      ),\n    ).resolves.toEqual(expect.objectContaining(teamMember));\n  });\n\n  test('makes the update in the database', async () => {\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    await teamService.addMemberToTeam(\n      dbTeamMember.teamID,\n      dbTeamMember.userUid,\n      TeamAccessRole[dbTeamMember.role],\n    );\n\n    expect(mockPrisma.teamMember.create).toHaveBeenCalledWith({\n      data: {\n        userUid: dbTeamMember.userUid,\n        team: {\n          connect: {\n            id: dbTeamMember.teamID,\n          },\n        },\n        role: TeamAccessRole[dbTeamMember.role],\n      },\n    });\n  });\n\n  test('fires \"team/<team_id>/member_added\" pubsub message with correct payload', async () => {\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    const member = await teamService.addMemberToTeam(\n      dbTeamMember.teamID,\n      dbTeamMember.userUid,\n      TeamAccessRole[dbTeamMember.role],\n    );\n\n    expect(mockPubSub.publish).toHaveBeenCalledWith(\n      `team/${dbTeamMember.teamID}/member_added`,\n      member,\n    );\n  });\n});\n\ndescribe('addMemberToTeamWithEmail', () => {\n  afterEach(() => {\n    mockUserService.findUserByEmail.mockClear();\n    mockUserService.authenticateWithIDToken.mockClear();\n    mockUserService.authenticateWithIDToken.mockClear();\n  });\n\n  test('resolves when user with email exists', () => {\n    mockUserService.findUserByEmail.mockResolvedValueOnce(\n      O.some({\n        uid: dbTeamMember.userUid,\n      }),\n    );\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    const result = teamService.addMemberToTeamWithEmail(\n      dbTeamMember.teamID,\n      'test@hoppscotch.io',\n      TeamAccessRole[dbTeamMember.role],\n    );\n    return expect(result).resolves.toBeDefined();\n  });\n\n  test(\"rejects with user with email doesn't exist with USER_NOT_FOUND\", () => {\n    mockUserService.findUserByEmail.mockResolvedValue(O.none);\n\n    const result = teamService.addMemberToTeamWithEmail(\n      dbTeamMember.teamID,\n      'test@hoppscotch.io',\n      TeamAccessRole[dbTeamMember.role],\n    );\n    return expect(result).resolves.toEqualLeft(USER_NOT_FOUND);\n  });\n\n  test('makes update in the database', async () => {\n    mockUserService.findUserByEmail.mockResolvedValueOnce(\n      O.some({\n        uid: dbTeamMember.userUid,\n      }),\n    );\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    await teamService.addMemberToTeamWithEmail(\n      dbTeamMember.teamID,\n      'test@hoppscotch.io',\n      TeamAccessRole[dbTeamMember.role],\n    );\n\n    expect(mockPrisma.teamMember.create).toHaveBeenCalledWith({\n      data: {\n        userUid: dbTeamMember.userUid,\n        team: {\n          connect: {\n            id: dbTeamMember.teamID,\n          },\n        },\n        role: TeamAccessRole[dbTeamMember.role],\n      },\n    });\n  });\n\n  test('fires \"team/<team_id>/member_added\" pubsub message with correct payload', async () => {\n    mockUserService.findUserByEmail.mockResolvedValueOnce(\n      O.some({\n        uid: dbTeamMember.userUid,\n      }),\n    );\n    mockPrisma.teamMember.create.mockResolvedValue(dbTeamMember);\n\n    await teamService.addMemberToTeamWithEmail(\n      dbTeamMember.teamID,\n      'test@hoppscotch.io',\n      TeamAccessRole[dbTeamMember.role],\n    );\n\n    expect(mockPubSub.publish).toHaveBeenCalledWith(\n      `team/${dbTeamMember.teamID}/member_added`,\n      teamMember,\n    );\n  });\n});\n\ndescribe('deleteTeam', () => {\n  test('resolves for proper deletion', async () => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    mockPrisma.team.findUnique.mockResolvedValue(team);\n    mockPrisma.teamMember.deleteMany.mockResolvedValue({\n      count: 10,\n    });\n    mockPrisma.team.delete.mockResolvedValue(team);\n\n    const result = await teamService.deleteTeam(team.id);\n    return expect(result).toEqualRight(true);\n  });\n\n  test('performs deletion on database', async () => {\n    mockPrisma.team.findUnique.mockResolvedValue(team);\n    mockPrisma.teamMember.deleteMany.mockResolvedValue({\n      count: 10,\n    });\n    mockPrisma.team.delete.mockResolvedValue(team);\n\n    await teamService.deleteTeam(team.id);\n\n    expect(mockPrisma.team.delete).toHaveBeenCalledWith({\n      where: {\n        id: team.id,\n      },\n    });\n  });\n\n  test('rejects for invalid team id', async () => {\n    mockPrisma.team.findUnique.mockResolvedValue(null);\n\n    // If invalid team ID, team member deletes nothing (count 0)\n    mockPrisma.teamMember.deleteMany.mockResolvedValue({\n      count: 0,\n    });\n\n    // TODO: Confirm RecordNotFound works like this\n    mockPrisma.team.delete.mockRejectedValue('RecordNotFound');\n\n    // Team will not find and reject\n    const result = await teamService.deleteTeam(team.id);\n    return expect(result).toEqualLeft(TEAM_INVALID_ID);\n  });\n});\n\ndescribe('renameTeam', () => {\n  test('resolves for proper rename', () => {\n    const newTeamName = 'Rename';\n\n    mockPrisma.team.update.mockResolvedValue({\n      ...team,\n      name: newTeamName,\n    });\n\n    return expect(\n      teamService.renameTeam(team.id, newTeamName),\n    ).resolves.toBeDefined();\n  });\n\n  test('resolves with team structure', () => {\n    const newTeamName = 'Rename';\n\n    mockPrisma.team.update.mockResolvedValue({\n      ...team,\n      name: newTeamName,\n    });\n\n    return expect(\n      teamService.renameTeam(team.id, newTeamName),\n    ).resolves.toEqualRight(\n      expect.objectContaining({\n        ...team,\n        name: newTeamName,\n      }),\n    );\n  });\n\n  test('performs rename on database', async () => {\n    const newTeamName = 'Rename';\n\n    mockPrisma.team.update.mockResolvedValue({\n      ...team,\n      name: newTeamName,\n    });\n\n    await teamService.renameTeam(team.id, newTeamName);\n\n    expect(mockPrisma.team.update).toHaveBeenCalledWith({\n      where: {\n        id: team.id,\n      },\n      data: {\n        name: newTeamName,\n      },\n    });\n  });\n\n  test('rejects for invalid team id with TEAM_INVALID_ID', () => {\n    const newTeamName = 'Rename';\n    // If invalid team id, update fails with RecordNotFound\n    mockPrisma.team.update.mockRejectedValue('RecordNotFound');\n\n    return expect(\n      teamService.renameTeam(team.id, newTeamName),\n    ).resolves.toEqualLeft(TEAM_INVALID_ID);\n  });\n\n  test('rejects for new team name length < 6 with TEAM_NAME_INVALID', () => {\n    const newTeamName = 'smol';\n\n    // Prisma doesn't care about the team name length, so it will resolve\n    mockPrisma.team.update.mockResolvedValue({\n      ...team,\n      name: newTeamName,\n    });\n\n    return expect(\n      teamService.renameTeam(team.id, newTeamName),\n    ).resolves.toEqualLeft(TEAM_NAME_INVALID);\n  });\n});\n\ndescribe('updateTeamAccessRole', () => {\n  /**\n   * Test Scenario:\n   * 3 users (testuid1 thru 3) having each of the roles\n   * (OWNER, VIEWER, EDITOR)\n   * in Team with id 3170\n   */\n\n  test('updates the role', async () => {\n    const newRole = TeamAccessRole.EDITOR;\n\n    mockPrisma.teamMember.count.mockResolvedValue(1);\n    mockPrisma.teamMember.findUnique.mockResolvedValue({\n      ...dbTeamMember,\n      role: TeamAccessRole[dbTeamMember.role],\n    });\n    mockPrisma.teamMember.update.mockResolvedValue({\n      ...dbTeamMember,\n      role: newRole,\n    });\n\n    await teamService.updateTeamAccessRole(\n      dbTeamMember.teamID,\n      dbTeamMember.userUid,\n      newRole,\n    );\n\n    expect(mockPrisma.teamMember.update).toHaveBeenCalledWith({\n      where: {\n        teamID_userUid: {\n          teamID: dbTeamMember.teamID,\n          userUid: dbTeamMember.userUid,\n        },\n      },\n      data: {\n        role: newRole,\n      },\n    });\n  });\n\n  test('returns the updated details', () => {\n    const newRole = TeamAccessRole.EDITOR;\n\n    mockPrisma.teamMember.count.mockResolvedValue(1);\n    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);\n    mockPrisma.teamMember.update.mockResolvedValue({\n      ...dbTeamMember,\n      role: newRole,\n    });\n\n    return expect(\n      teamService.updateTeamAccessRole(\n        dbTeamMember.teamID,\n        dbTeamMember.userUid,\n        newRole,\n      ),\n    ).resolves.toEqualRight({ ...teamMember, role: newRole });\n  });\n\n  test('rejects if you change the status of the sole owner to non-owner status with TEAM_ONLY_ONE_OWNER', () => {\n    mockPrisma.teamMember.count.mockResolvedValue(1);\n    mockPrisma.teamMember.findUnique.mockResolvedValue({\n      ...dbTeamMember,\n      role: TeamAccessRole.OWNER,\n    });\n\n    // Prisma doesn't care if it goes through\n    mockPrisma.teamMember.update.",
            "cost": 0.15701
        },
        "hoppscotch__hoppscotch.main/packages/hoppscotch-backend/src/team/team.service.ts": {
            "output": "import { Injectable, OnModuleInit } from '@nestjs/common';\nimport { TeamMember, TeamAccessRole, Team } from './team.model';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { TeamMember as DbTeamMember } from 'src/generated/prisma/client';\nimport { UserService } from '../user/user.service';\nimport { UserDataHandler } from 'src/user/user.data.handler';\nimport {\n  TEAM_NAME_INVALID,\n  TEAM_ONLY_ONE_OWNER,\n  USER_NOT_FOUND,\n  TEAM_INVALID_ID,\n  TEAM_INVALID_ID_OR_USER,\n  TEAM_MEMBER_NOT_FOUND,\n  USER_IS_OWNER,\n} from '../errors';\nimport { PubSubService } from '../pubsub/pubsub.service';\nimport { flow, pipe } from 'fp-ts/function';\nimport * as TE from 'fp-ts/TaskEither';\nimport * as TO from 'fp-ts/TaskOption';\nimport * as O from 'fp-ts/Option';\nimport * as E from 'fp-ts/Either';\nimport * as T from 'fp-ts/Task';\nimport * as A from 'fp-ts/Array';\nimport { isValidLength, throwErr } from 'src/utils';\nimport { AuthUser } from '../types/AuthUser';\n\n@Injectable()\nexport class TeamService implements UserDataHandler, OnModuleInit {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly userService: UserService,\n    private readonly pubsub: PubSubService,\n  ) {}\n\n  TITLE_LENGTH = 1;\n\n  onModuleInit() {\n    this.userService.registerUserDataHandler(this);\n  }\n\n  canAllowUserDeletion(user: AuthUser): TO.TaskOption<string> {\n    return pipe(\n      this.isUserSoleOwnerInAnyTeam(user.uid),\n      TO.fromTask,\n      TO.chain((isOwner) => (isOwner ? TO.some(USER_IS_OWNER) : TO.none)),\n    );\n  }\n\n  onUserDelete(user: AuthUser): T.Task<void> {\n    return this.deleteUserFromAllTeams(user.uid);\n  }\n\n  async getCountOfUsersWithRoleInTeam(\n    teamID: string,\n    role: TeamAccessRole,\n  ): Promise<number> {\n    return await this.prisma.teamMember.count({\n      where: {\n        teamID,\n        role,\n      },\n    });\n  }\n\n  async addMemberToTeamWithEmail(\n    teamID: string,\n    email: string,\n    role: TeamAccessRole,\n  ): Promise<E.Left<string> | E.Right<TeamMember>> {\n    const user = await this.userService.findUserByEmail(email);\n    if (O.isNone(user)) return E.left(USER_NOT_FOUND);\n\n    const teamMember = await this.addMemberToTeam(teamID, user.value.uid, role);\n    return E.right(teamMember);\n  }\n\n  async addMemberToTeam(\n    teamID: string,\n    uid: string,\n    role: TeamAccessRole,\n  ): Promise<TeamMember> {\n    const teamMember = await this.prisma.teamMember.create({\n      data: {\n        userUid: uid,\n        team: {\n          connect: {\n            id: teamID,\n          },\n        },\n        role: role,\n      },\n    });\n\n    const member: TeamMember = {\n      membershipID: teamMember.id,\n      userUid: teamMember.userUid,\n      role: TeamAccessRole[teamMember.role],\n    };\n\n    this.pubsub.publish(`team/${teamID}/member_added`, member);\n\n    return member;\n  }\n\n  async deleteTeam(teamID: string): Promise<E.Left<string> | E.Right<boolean>> {\n    const team = await this.prisma.team.findUnique({\n      where: {\n        id: teamID,\n      },\n    });\n    if (!team) return E.left(TEAM_INVALID_ID);\n\n    await this.prisma.teamMember.deleteMany({\n      where: {\n        teamID: teamID,\n      },\n    });\n\n    await this.prisma.team.delete({\n      where: {\n        id: teamID,\n      },\n    });\n\n    return E.right(true);\n  }\n\n  validateTeamName(title: string): E.Left<string> | E.Right<boolean> {\n    if (!title || title.length < 6) return E.left(TEAM_NAME_INVALID);\n    return E.right(true);\n  }\n\n  async renameTeam(\n    teamID: string,\n    newName: string,\n  ): Promise<E.Left<string> | E.Right<Team>> {\n    const isValidTitle = isValidLength(newName, this.TITLE_LENGTH);\n    if (!isValidTitle) return E.left(TEAM_NAME_INVALID);\n\n    try {\n      const updatedTeam = await this.prisma.team.update({\n        where: {\n          id: teamID,\n        },\n        data: {\n          name: newName,\n        },\n      });\n      return E.right(updatedTeam);\n    } catch (e) {\n      // Prisma update errors out if it can't find the record\n      return E.left(TEAM_INVALID_ID);\n    }\n  }\n\n  async updateTeamAccessRole(\n    teamID: string,\n    userUid: string,\n    newRole: TeamAccessRole,\n  ): Promise<E.Left<string> | E.Right<TeamMember>> {\n    const ownerCount = await this.prisma.teamMember.count({\n      where: {\n        teamID,\n        role: TeamAccessRole.OWNER,\n      },\n    });\n\n    const member = await this.prisma.teamMember.findUnique({\n      where: {\n        teamID_userUid: {\n          teamID,\n          userUid,\n        },\n      },\n    });\n\n    if (!member) return E.left(TEAM_MEMBER_NOT_FOUND);\n    if (\n      member.role === TeamAccessRole.OWNER &&\n      newRole != TeamAccessRole.OWNER &&\n      ownerCount === 1\n    ) {\n      return E.left(TEAM_ONLY_ONE_OWNER);\n    }\n\n    const result = await this.prisma.teamMember.update({\n      where: {\n        teamID_userUid: {\n          teamID,\n          userUid,\n        },\n      },\n      data: {\n        role: newRole,\n      },\n    });\n\n    const updatedMember: TeamMember = {\n      membershipID: result.id,\n      userUid: result.userUid,\n      role: TeamAccessRole[result.role],\n    };\n\n    this.pubsub.publish(`team/${teamID}/member_updated`, updatedMember);\n\n    return E.right(updatedMember);\n  }\n\n  async leaveTeam(\n    teamID: string,\n    userUid: string,\n  ): Promise<E.Left<string> | E.Right<boolean>> {\n    const ownerCount = await this.prisma.teamMember.count({\n      where: {\n        teamID,\n        role: TeamAccessRole.OWNER,\n      },\n    });\n\n    const member = await this.getTeamMember(teamID, userUid);\n    if (!member) return E.left(TEAM_INVALID_ID_OR_USER);\n\n    if (ownerCount === 1 && member.role === TeamAccessRole.OWNER) {\n      return E.left(TEAM_ONLY_ONE_OWNER);\n    }\n\n    try {\n      await this.prisma.teamMember.delete({\n        where: {\n          teamID_userUid: {\n            userUid,\n            teamID,\n          },\n        },\n      });\n    } catch (e) {\n      // Record not found\n      return E.left(TEAM_INVALID_ID_OR_USER);\n    }\n\n    this.pubsub.publish(`team/${teamID}/member_removed`, userUid);\n\n    return E.right(true);\n  }\n\n  async createTeam(\n    name: string,\n    creatorUid: string,\n  ): Promise<E.Left<string> | E.Right<Team>> {\n    const isValidName = isValidLength(name, this.TITLE_LENGTH);\n    if (!isValidName) return E.left(TEAM_NAME_INVALID);\n\n    const team = await this.prisma.team.create({\n      data: {\n        name: name,\n        members: {\n          create: {\n            userUid: creatorUid,\n            role: TeamAccessRole.OWNER,\n          },\n        },\n      },\n    });\n\n    return E.right(team);\n  }\n\n  async getTeamsOfUser(uid: string, cursor: string | null): Promise<Team[]> {\n    if (!cursor) {\n      const entries = await this.prisma.teamMember.findMany({\n        take: 10,\n        where: {\n          userUid: uid,\n        },\n        include: {\n          team: true,\n        },\n      });\n\n      return entries.map((entry) => entry.team);\n    } else {\n      const entries = await this.prisma.teamMember.findMany({\n        take: 10,\n        skip: 1,\n        cursor: {\n          teamID_userUid: {\n            teamID: cursor,\n            userUid: uid,\n          },\n        },\n        where: {\n          userUid: uid,\n        },\n        include: {\n          team: true,\n        },\n      });\n      return entries.map((entry) => entry.team);\n    }\n  }\n\n  async getTeamWithID(teamID: string): Promise<Team | null> {\n    try {\n      const team = await this.prisma.team.findUnique({\n        where: {\n          id: teamID,\n        },\n      });\n\n      return team;\n    } catch (_e) {\n      return null;\n    }\n  }\n\n  getTeamWithIDTE(teamID: string): TE.TaskEither<'team/invalid_id', Team> {\n    return pipe(\n      () => this.getTeamWithID(teamID),\n      TE.fromTask,\n      TE.chain(\n        TE.fromPredicate(\n          (x): x is Team => !!x,\n          () => TEAM_INVALID_ID,\n        ),\n      ),\n    );\n  }\n\n  /**\n   * Filters out team members that we weren't able to match\n   * (also deletes the membership)\n   * @param members Members to filter against\n   */\n  async filterMismatchedUsers(\n    teamID: string,\n    members: TeamMember[],\n  ): Promise<TeamMember[]> {\n    const memberUsers = await Promise.all(\n      members.map(async (member) => {\n        const user = await this.userService.findUserById(member.userUid);\n\n        // // TODO:Investigate if a race condition exists that deletes user from teams.\n        // // Delete the membership if the user doesnt exist\n        // if (!user) this.leaveTeam(teamID, member.userUid);\n\n        if (O.isSome(user)) return member;\n        else return null;\n      }),\n    );\n\n    return memberUsers.filter((x) => x !== null) as TeamMember[];\n  }\n\n  async getTeamMember(\n    teamID: string,\n    userUid: string,\n  ): Promise<TeamMember | null> {\n    try {\n      const teamMember = await this.prisma.teamMember.findUnique({\n        where: {\n          teamID_userUid: {\n            teamID,\n            userUid,\n          },\n        },\n      });\n\n      if (!teamMember) return null;\n\n      return <TeamMember>{\n        membershipID: teamMember.id,\n        userUid: userUid,\n        role: TeamAccessRole[teamMember.role],\n      };\n    } catch (e) {\n      return null;\n    }\n  }\n\n  getTeamMemberTE(teamID: string, userUid: string) {\n    return pipe(\n      () => this.getTeamMember(teamID, userUid),\n      TE.fromTask,\n      TE.chain(\n        TE.fromPredicate(\n          (x): x is TeamMember => !!x,\n          () => TEAM_MEMBER_NOT_FOUND,\n        ),\n      ),\n    );\n  }\n\n  async getRoleOfUserInTeam(\n    teamID: string,\n    userUid: string,\n  ): Promise<TeamAccessRole | null> {\n    const teamMember = await this.getTeamMember(teamID, userUid);\n    return teamMember ? teamMember.role : null;\n  }\n\n  isUserSoleOwnerInAnyTeam(uid: string): T.Task<boolean> {\n    return async () => {\n      // Find all teams where the user is an OWNER\n      const userOwnedTeams = await this.prisma.teamMember.findMany({\n        where: {\n          userUid: uid,\n          role: TeamAccessRole.OWNER,\n        },\n        select: {\n          teamID: true,\n        },\n      });\n\n      for (const userOwnedTeam of userOwnedTeams) {\n        const ownerCount = await this.prisma.teamMember.count({\n          where: {\n            teamID: userOwnedTeam.teamID,\n            role: TeamAccessRole.OWNER,\n          },\n        });\n\n        // early return true if the user is the sole owner\n        if (ownerCount === 1) return true;\n      }\n\n      // return false if the user is not the sole owner in any team\n      return false;\n    };\n  }\n\n  deleteUserFromAllTeams(uid: string) {\n    return pipe(\n      () =>\n        this.prisma.teamMember.findMany({\n          where: {\n            userUid: uid,\n          },\n        }),\n      T.chainFirst(\n        flow(\n          A.map((member) => async () => {\n            const res = await this.leaveTeam(member.teamID, uid);\n            if (E.isLeft(res)) throwErr(res.left);\n            return E.right(res);\n          }),\n          T.sequenceArray,\n        ),\n      ),\n      T.map(() => undefined),\n    );\n  }\n\n  async getTeamMembers(teamID: string): Promise<TeamMember[]> {\n    const dbTeamMembers = await this.prisma.teamMember.findMany({\n      where: {\n        teamID,\n      },\n    });\n\n    const members = dbTeamMembers.map(\n      (entry) =>\n        <TeamMember>{\n          membershipID: entry.id,\n          userUid: entry.userUid,\n          role: TeamAccessRole[entry.role],\n        },\n    );\n\n    return this.filterMismatchedUsers(teamID, members);\n  }\n\n  /**\n   * Get a count of members in a team\n   * @param teamID Team ID\n   * @returns a count of members in a team\n   */\n  async getCountOfMembersInTeam(teamID: string) {\n    const memberCount = await this.prisma.teamMember.count({\n      where: {\n        teamID: teamID,\n      },\n    });\n\n    return memberCount;\n  }\n\n  async getMembersOfTeam(\n    teamID: string,\n    cursor: string | null,\n  ): Promise<TeamMember[]> {\n    let teamMembers: DbTeamMember[];\n\n    if (!cursor) {\n      teamMembers = await this.prisma.teamMember.findMany({\n        take: 10,\n        where: {\n          teamID,\n        },\n      });\n    } else {\n      teamMembers = await this.prisma.teamMember.findMany({\n        take: 10,\n        skip: 1,\n        cursor: {\n          id: cursor,\n        },\n        where",
            "output_extracted": "import { Injectable, OnModuleInit } from '@nestjs/common';\nimport { TeamMember, TeamAccessRole, Team } from './team.model';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { TeamMember as DbTeamMember } from 'src/generated/prisma/client';\nimport { UserService } from '../user/user.service';\nimport { UserDataHandler } from 'src/user/user.data.handler';\nimport {\n  TEAM_NAME_INVALID,\n  TEAM_ONLY_ONE_OWNER,\n  USER_NOT_FOUND,\n  TEAM_INVALID_ID,\n  TEAM_INVALID_ID_OR_USER,\n  TEAM_MEMBER_NOT_FOUND,\n  USER_IS_OWNER,\n} from '../errors';\nimport { PubSubService } from '../pubsub/pubsub.service';\nimport { flow, pipe } from 'fp-ts/function';\nimport * as TE from 'fp-ts/TaskEither';\nimport * as TO from 'fp-ts/TaskOption';\nimport * as O from 'fp-ts/Option';\nimport * as E from 'fp-ts/Either';\nimport * as T from 'fp-ts/Task';\nimport * as A from 'fp-ts/Array';\nimport { isValidLength, throwErr } from 'src/utils';\nimport { AuthUser } from '../types/AuthUser';\n\n@Injectable()\nexport class TeamService implements UserDataHandler, OnModuleInit {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly userService: UserService,\n    private readonly pubsub: PubSubService,\n  ) {}\n\n  TITLE_LENGTH = 1;\n\n  onModuleInit() {\n    this.userService.registerUserDataHandler(this);\n  }\n\n  canAllowUserDeletion(user: AuthUser): TO.TaskOption<string> {\n    return pipe(\n      this.isUserSoleOwnerInAnyTeam(user.uid),\n      TO.fromTask,\n      TO.chain((isOwner) => (isOwner ? TO.some(USER_IS_OWNER) : TO.none)),\n    );\n  }\n\n  onUserDelete(user: AuthUser): T.Task<void> {\n    return this.deleteUserFromAllTeams(user.uid);\n  }\n\n  async getCountOfUsersWithRoleInTeam(\n    teamID: string,\n    role: TeamAccessRole,\n  ): Promise<number> {\n    return await this.prisma.teamMember.count({\n      where: {\n        teamID,\n        role,\n      },\n    });\n  }\n\n  async addMemberToTeamWithEmail(\n    teamID: string,\n    email: string,\n    role: TeamAccessRole,\n  ): Promise<E.Left<string> | E.Right<TeamMember>> {\n    const user = await this.userService.findUserByEmail(email);\n    if (O.isNone(user)) return E.left(USER_NOT_FOUND);\n\n    const teamMember = await this.addMemberToTeam(teamID, user.value.uid, role);\n    return E.right(teamMember);\n  }\n\n  async addMemberToTeam(\n    teamID: string,\n    uid: string,\n    role: TeamAccessRole,\n  ): Promise<TeamMember> {\n    const teamMember = await this.prisma.teamMember.create({\n      data: {\n        userUid: uid,\n        team: {\n          connect: {\n            id: teamID,\n          },\n        },\n        role: role,\n      },\n    });\n\n    const member: TeamMember = {\n      membershipID: teamMember.id,\n      userUid: teamMember.userUid,\n      role: TeamAccessRole[teamMember.role],\n    };\n\n    this.pubsub.publish(`team/${teamID}/member_added`, member);\n\n    return member;\n  }\n\n  async deleteTeam(teamID: string): Promise<E.Left<string> | E.Right<boolean>> {\n    const team = await this.prisma.team.findUnique({\n      where: {\n        id: teamID,\n      },\n    });\n    if (!team) return E.left(TEAM_INVALID_ID);\n\n    await this.prisma.teamMember.deleteMany({\n      where: {\n        teamID: teamID,\n      },\n    });\n\n    await this.prisma.team.delete({\n      where: {\n        id: teamID,\n      },\n    });\n\n    return E.right(true);\n  }\n\n  validateTeamName(title: string): E.Left<string> | E.Right<boolean> {\n    if (!title || title.length < 6) return E.left(TEAM_NAME_INVALID);\n    return E.right(true);\n  }\n\n  async renameTeam(\n    teamID: string,\n    newName: string,\n  ): Promise<E.Left<string> | E.Right<Team>> {\n    const isValidTitle = isValidLength(newName, this.TITLE_LENGTH);\n    if (!isValidTitle) return E.left(TEAM_NAME_INVALID);\n\n    try {\n      const updatedTeam = await this.prisma.team.update({\n        where: {\n          id: teamID,\n        },\n        data: {\n          name: newName,\n        },\n      });\n      return E.right(updatedTeam);\n    } catch (e) {\n      // Prisma update errors out if it can't find the record\n      return E.left(TEAM_INVALID_ID);\n    }\n  }\n\n  async updateTeamAccessRole(\n    teamID: string,\n    userUid: string,\n    newRole: TeamAccessRole,\n  ): Promise<E.Left<string> | E.Right<TeamMember>> {\n    const ownerCount = await this.prisma.teamMember.count({\n      where: {\n        teamID,\n        role: TeamAccessRole.OWNER,\n      },\n    });\n\n    const member = await this.prisma.teamMember.findUnique({\n      where: {\n        teamID_userUid: {\n          teamID,\n          userUid,\n        },\n      },\n    });\n\n    if (!member) return E.left(TEAM_MEMBER_NOT_FOUND);\n    if (\n      member.role === TeamAccessRole.OWNER &&\n      newRole != TeamAccessRole.OWNER &&\n      ownerCount === 1\n    ) {\n      return E.left(TEAM_ONLY_ONE_OWNER);\n    }\n\n    const result = await this.prisma.teamMember.update({\n      where: {\n        teamID_userUid: {\n          teamID,\n          userUid,\n        },\n      },\n      data: {\n        role: newRole,\n      },\n    });\n\n    const updatedMember: TeamMember = {\n      membershipID: result.id,\n      userUid: result.userUid,\n      role: TeamAccessRole[result.role],\n    };\n\n    this.pubsub.publish(`team/${teamID}/member_updated`, updatedMember);\n\n    return E.right(updatedMember);\n  }\n\n  async leaveTeam(\n    teamID: string,\n    userUid: string,\n  ): Promise<E.Left<string> | E.Right<boolean>> {\n    const ownerCount = await this.prisma.teamMember.count({\n      where: {\n        teamID,\n        role: TeamAccessRole.OWNER,\n      },\n    });\n\n    const member = await this.getTeamMember(teamID, userUid);\n    if (!member) return E.left(TEAM_INVALID_ID_OR_USER);\n\n    if (ownerCount === 1 && member.role === TeamAccessRole.OWNER) {\n      return E.left(TEAM_ONLY_ONE_OWNER);\n    }\n\n    try {\n      await this.prisma.teamMember.delete({\n        where: {\n          teamID_userUid: {\n            userUid,\n            teamID,\n          },\n        },\n      });\n    } catch (e) {\n      // Record not found\n      return E.left(TEAM_INVALID_ID_OR_USER);\n    }\n\n    this.pubsub.publish(`team/${teamID}/member_removed`, userUid);\n\n    return E.right(true);\n  }\n\n  async createTeam(\n    name: string,\n    creatorUid: string,\n  ): Promise<E.Left<string> | E.Right<Team>> {\n    const isValidName = isValidLength(name, this.TITLE_LENGTH);\n    if (!isValidName) return E.left(TEAM_NAME_INVALID);\n\n    const team = await this.prisma.team.create({\n      data: {\n        name: name,\n        members: {\n          create: {\n            userUid: creatorUid,\n            role: TeamAccessRole.OWNER,\n          },\n        },\n      },\n    });\n\n    return E.right(team);\n  }\n\n  async getTeamsOfUser(uid: string, cursor: string | null): Promise<Team[]> {\n    if (!cursor) {\n      const entries = await this.prisma.teamMember.findMany({\n        take: 10,\n        where: {\n          userUid: uid,\n        },\n        include: {\n          team: true,\n        },\n      });\n\n      return entries.map((entry) => entry.team);\n    } else {\n      const entries = await this.prisma.teamMember.findMany({\n        take: 10,\n        skip: 1,\n        cursor: {\n          teamID_userUid: {\n            teamID: cursor,\n            userUid: uid,\n          },\n        },\n        where: {\n          userUid: uid,\n        },\n        include: {\n          team: true,\n        },\n      });\n      return entries.map((entry) => entry.team);\n    }\n  }\n\n  async getTeamWithID(teamID: string): Promise<Team | null> {\n    try {\n      const team = await this.prisma.team.findUnique({\n        where: {\n          id: teamID,\n        },\n      });\n\n      return team;\n    } catch (_e) {\n      return null;\n    }\n  }\n\n  getTeamWithIDTE(teamID: string): TE.TaskEither<'team/invalid_id', Team> {\n    return pipe(\n      () => this.getTeamWithID(teamID),\n      TE.fromTask,\n      TE.chain(\n        TE.fromPredicate(\n          (x): x is Team => !!x,\n          () => TEAM_INVALID_ID,\n        ),\n      ),\n    );\n  }\n\n  /**\n   * Filters out team members that we weren't able to match\n   * (also deletes the membership)\n   * @param members Members to filter against\n   */\n  async filterMismatchedUsers(\n    teamID: string,\n    members: TeamMember[],\n  ): Promise<TeamMember[]> {\n    const memberUsers = await Promise.all(\n      members.map(async (member) => {\n        const user = await this.userService.findUserById(member.userUid);\n\n        // // TODO:Investigate if a race condition exists that deletes user from teams.\n        // // Delete the membership if the user doesnt exist\n        // if (!user) this.leaveTeam(teamID, member.userUid);\n\n        if (O.isSome(user)) return member;\n        else return null;\n      }),\n    );\n\n    return memberUsers.filter((x) => x !== null) as TeamMember[];\n  }\n\n  async getTeamMember(\n    teamID: string,\n    userUid: string,\n  ): Promise<TeamMember | null> {\n    try {\n      const teamMember = await this.prisma.teamMember.findUnique({\n        where: {\n          teamID_userUid: {\n            teamID,\n            userUid,\n          },\n        },\n      });\n\n      if (!teamMember) return null;\n\n      return <TeamMember>{\n        membershipID: teamMember.id,\n        userUid: userUid,\n        role: TeamAccessRole[teamMember.role],\n      };\n    } catch (e) {\n      return null;\n    }\n  }\n\n  getTeamMemberTE(teamID: string, userUid: string) {\n    return pipe(\n      () => this.getTeamMember(teamID, userUid),\n      TE.fromTask,\n      TE.chain(\n        TE.fromPredicate(\n          (x): x is TeamMember => !!x,\n          () => TEAM_MEMBER_NOT_FOUND,\n        ),\n      ),\n    );\n  }\n\n  async getRoleOfUserInTeam(\n    teamID: string,\n    userUid: string,\n  ): Promise<TeamAccessRole | null> {\n    const teamMember = await this.getTeamMember(teamID, userUid);\n    return teamMember ? teamMember.role : null;\n  }\n\n  isUserSoleOwnerInAnyTeam(uid: string): T.Task<boolean> {\n    return async () => {\n      // Find all teams where the user is an OWNER\n      const userOwnedTeams = await this.prisma.teamMember.findMany({\n        where: {\n          userUid: uid,\n          role: TeamAccessRole.OWNER,\n        },\n        select: {\n          teamID: true,\n        },\n      });\n\n      for (const userOwnedTeam of userOwnedTeams) {\n        const ownerCount = await this.prisma.teamMember.count({\n          where: {\n            teamID: userOwnedTeam.teamID,\n            role: TeamAccessRole.OWNER,\n          },\n        });\n\n        // early return true if the user is the sole owner\n        if (ownerCount === 1) return true;\n      }\n\n      // return false if the user is not the sole owner in any team\n      return false;\n    };\n  }\n\n  deleteUserFromAllTeams(uid: string) {\n    return pipe(\n      () =>\n        this.prisma.teamMember.findMany({\n          where: {\n            userUid: uid,\n          },\n        }),\n      T.chainFirst(\n        flow(\n          A.map((member) => async () => {\n            const res = await this.leaveTeam(member.teamID, uid);\n            if (E.isLeft(res)) throwErr(res.left);\n            return E.right(res);\n          }),\n          T.sequenceArray,\n        ),\n      ),\n      T.map(() => undefined),\n    );\n  }\n\n  async getTeamMembers(teamID: string): Promise<TeamMember[]> {\n    const dbTeamMembers = await this.prisma.teamMember.findMany({\n      where: {\n        teamID,\n      },\n    });\n\n    const members = dbTeamMembers.map(\n      (entry) =>\n        <TeamMember>{\n          membershipID: entry.id,\n          userUid: entry.userUid,\n          role: TeamAccessRole[entry.role],\n        },\n    );\n\n    return this.filterMismatchedUsers(teamID, members);\n  }\n\n  /**\n   * Get a count of members in a team\n   * @param teamID Team ID\n   * @returns a count of members in a team\n   */\n  async getCountOfMembersInTeam(teamID: string) {\n    const memberCount = await this.prisma.teamMember.count({\n      where: {\n        teamID: teamID,\n      },\n    });\n\n    return memberCount;\n  }\n\n  async getMembersOfTeam(\n    teamID: string,\n    cursor: string | null,\n  ): Promise<TeamMember[]> {\n    let teamMembers: DbTeamMember[];\n\n    if (!cursor) {\n      teamMembers = await this.prisma.teamMember.findMany({\n        take: 10,\n        where: {\n          teamID,\n        },\n      });\n    } else {\n      teamMembers = await this.prisma.teamMember.findMany({\n        take: 10,\n        skip: 1,\n        cursor: {\n          id: cursor,\n        },\n        where",
            "cost": 0.12901500000000002
        },
        "hoppscotch__hoppscotch.main/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts": {
            "output": "import * as t from \"io-ts\"\n\ninterface TeamNameBrand {\n  readonly TeamName: unique symbol\n}\n\nexport const TeamNameCodec = t.brand(\n  t.string,\n  (x): x is t.Branded<string, TeamNameBrand> => x.trim().length >= 6,\n  \"TeamName\"\n)\n\nexport type TeamName = t.TypeOf<typeof TeamNameCodec>",
            "output_extracted": "import * as t from \"io-ts\"\n\ninterface TeamNameBrand {\n  readonly TeamName: unique symbol\n}\n\nexport const TeamNameCodec = t.brand(\n  t.string,\n  (x): x is t.Branded<string, TeamNameBrand> => x.trim().length >= 6,\n  \"TeamName\"\n)\n\nexport type TeamName = t.TypeOf<typeof TeamNameCodec>",
            "cost": 0.007805
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "hoppscotch__hoppscotch.main.5363",
        "repo": "hoppscotch/hoppscotch",
        "base_commit": "aac4c5b34b833b3bf463d20091c903c645de533c",
        "head_commit": "13f119ed3dbc1c0ea4a7cd7e796dc9d7b3d2fa37",
        "title": "feat: remove minimum length restriction on shared workspace names",
        "merged_at": "2025-09-02T08:18:29Z",
        "html_url": "https://github.com/hoppscotch/hoppscotch/pull/5363",
        "test_files": [
            "packages/hoppscotch-backend/src/team/team.service.spec.ts"
        ],
        "code_files": [
            "packages/hoppscotch-backend/src/team/team.service.ts",
            "packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts"
        ],
        "total_changes": 14,
        "num_files": 4,
        "pull_number": 5363,
        "patch": "diff --git a/packages/hoppscotch-backend/src/team/team.service.spec.ts b/packages/hoppscotch-backend/src/team/team.service.spec.ts\nindex 44954535001..5fa2e2ffd4f 100644\n--- a/packages/hoppscotch-backend/src/team/team.service.spec.ts\n+++ b/packages/hoppscotch-backend/src/team/team.service.spec.ts\n@@ -361,8 +361,8 @@ describe('renameTeam', () => {\n     ).resolves.toEqualLeft(TEAM_INVALID_ID);\n   });\n \n-  test('rejects for new team name length < 6 with TEAM_NAME_INVALID', () => {\n-    const newTeamName = 'smol';\n+  test('rejects for new team name empty with TEAM_NAME_INVALID', () => {\n+    const newTeamName = '';\n \n     // Prisma doesn't care about the team name length, so it will resolve\n     mockPrisma.team.update.mockResolvedValue({\n@@ -668,8 +668,8 @@ describe('createTeam', () => {\n     ).resolves.toEqualRight(expect.objectContaining(team));\n   });\n \n-  test('rejects for team name length < 6 with TEAM_NAME_INVALID', () => {\n-    const newName = 'smol';\n+  test('rejects for team name empty with TEAM_NAME_INVALID', () => {\n+    const newName = '';\n \n     // Prisma doesn't care\n     mockPrisma.team.create.mockResolvedValue({\ndiff --git a/packages/hoppscotch-backend/src/team/team.service.ts b/packages/hoppscotch-backend/src/team/team.service.ts\nindex 96d3112e7a0..11ea9613fdf 100644\n--- a/packages/hoppscotch-backend/src/team/team.service.ts\n+++ b/packages/hoppscotch-backend/src/team/team.service.ts\n@@ -124,7 +124,7 @@ export class TeamService implements UserDataHandler, OnModuleInit {\n   }\n \n   validateTeamName(title: string): E.Left<string> | E.Right<boolean> {\n-    if (!title || title.length < 6) return E.left(TEAM_NAME_INVALID);\n+    if (!title || title.trim() === '') return E.left(TEAM_NAME_INVALID);\n     return E.right(true);\n   }\n \ndiff --git a/packages/hoppscotch-common/locales/en.json b/packages/hoppscotch-common/locales/en.json\nindex e5527b1caa4..7c4c60cfc53 100644\n--- a/packages/hoppscotch-common/locales/en.json\n+++ b/packages/hoppscotch-common/locales/en.json\n@@ -1521,7 +1521,7 @@\n     \"member_role_updated\": \"User roles updated\",\n     \"members\": \"Members\",\n     \"more_members\": \"+{count} more\",\n-    \"name_length_insufficient\": \"Workspace name should be at least 6 characters long\",\n+    \"name_length_insufficient\": \"Workspace name should not be empty\",\n     \"name_updated\": \"Workspace name updated\",\n     \"new\": \"New Workspace\",\n     \"new_created\": \"New workspace created\",\ndiff --git a/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts b/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts\nindex bbcdb6c0af8..26182eca31b 100644\n--- a/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts\n+++ b/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts\n@@ -6,7 +6,7 @@ interface TeamNameBrand {\n \n export const TeamNameCodec = t.brand(\n   t.string,\n-  (x): x is t.Branded<string, TeamNameBrand> => x.trim().length >= 6,\n+  (x): x is t.Branded<string, TeamNameBrand> => x.trim() !== \"\",\n   \"TeamName\"\n )\n \n",
        "pr_mirror": "hoppscotch__hoppscotch.main"
    }
}