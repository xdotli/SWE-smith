{
    "cost": 0.376715,
    "rewrites": {
        "hoppscotch__hoppscotch.main/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts": {
            "output": "import { describe, expect, vi, it, beforeEach, afterEach } from \"vitest\"\nimport { TestContainer } from \"dioc/testing\"\nimport { WorkspaceService } from \"../workspace.service\"\nimport { setPlatformDef } from \"~/platform\"\nimport { BehaviorSubject } from \"rxjs\"\nimport { effectScope, nextTick } from \"vue\"\n\nconst listAdapterMock = vi.hoisted(() => ({\n  isInitialized: false,\n  initialize: vi.fn(() => {\n    listAdapterMock.isInitialized = true\n  }),\n  dispose: vi.fn(() => {\n    listAdapterMock.isInitialized = false\n  }),\n  fetchList: vi.fn(),\n}))\n\nvi.mock(\"~/helpers/teams/TeamListAdapter\", () => ({\n  default: class {\n    isInitialized = listAdapterMock.isInitialized\n    initialize = listAdapterMock.initialize\n    dispose = listAdapterMock.dispose\n    fetchList = listAdapterMock.fetchList\n  },\n}))\n\n// Mock TeamCollectionsService to prevent i18n dependency issues\nvi.mock(\"../team-collection.service\", () => ({\n  TeamCollectionsService: class MockTeamCollectionsService {\n    static readonly ID = \"TEAM_COLLECTIONS_SERVICE\"\n\n    changeTeamID = vi.fn()\n    clearCollections = vi.fn()\n\n    onServiceInit = vi.fn()\n  },\n}))\n\n// Mock DocumentationService\nvi.mock(\"../documentation.service\", () => ({\n  DocumentationService: class MockDocumentationService {\n    static readonly ID = \"DOCUMENTATION_SERVICE\"\n\n    fetchTeamPublishedDocs = vi.fn()\n    fetchUserPublishedDocs = vi.fn()\n\n    onServiceInit = vi.fn()\n  },\n}))\n\ndescribe(\"WorkspaceService\", () => {\n  const platformMock = {\n    auth: {\n      getCurrentUserStream: vi.fn(),\n      getCurrentUser: vi.fn(),\n      waitProbableLoginToConfirm: vi.fn().mockResolvedValue(undefined),\n    },\n  }\n\n  beforeEach(() => {\n    // @ts-expect-error - We're mocking the platform\n    setPlatformDef(platformMock)\n\n    platformMock.auth.getCurrentUserStream.mockReturnValue(\n      new BehaviorSubject(null)\n    )\n\n    platformMock.auth.getCurrentUser.mockReturnValue(null)\n  })\n\n  describe(\"Initialization\", () => {\n    it(\"should initialize with the personal workspace selected\", () => {\n      const container = new TestContainer()\n\n      const service = container.bind(WorkspaceService)\n\n      expect(service.currentWorkspace.value).toEqual({ type: \"personal\" })\n    })\n  })\n\n  describe(\"updateWorkspaceTeamName\", () => {\n    it(\"should update the workspace team name if the current workspace is a team workspace\", () => {\n      const container = new TestContainer()\n\n      const service = container.bind(WorkspaceService)\n\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"test\",\n        teamName: \"before update\",\n        role: null,\n      })\n\n      service.updateWorkspaceTeamName(\"test\")\n\n      expect(service.currentWorkspace.value).toEqual({\n        type: \"team\",\n        teamID: \"test\",\n        teamName: \"test\",\n        role: null,\n      })\n    })\n\n    it(\"should not update the workspace team name if the current workspace is a personal workspace\", () => {\n      const container = new TestContainer()\n\n      const service = container.bind(WorkspaceService)\n\n      service.changeWorkspace({\n        type: \"personal\",\n      })\n\n      service.updateWorkspaceTeamName(\"test\")\n\n      expect(service.currentWorkspace.value).toEqual({ type: \"personal\" })\n    })\n  })\n\n  describe(\"changeWorkspace\", () => {\n    it(\"updates the current workspace value to the given workspace\", () => {\n      const container = new TestContainer()\n\n      const service = container.bind(WorkspaceService)\n\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"test\",\n        teamName: \"test\",\n        role: null,\n      })\n\n      expect(service.currentWorkspace.value).toEqual({\n        type: \"team\",\n        teamID: \"test\",\n        teamName: \"test\",\n        role: null,\n      })\n    })\n  })\n\n  describe(\"acquireTeamListAdapter\", () => {\n    beforeEach(() => {\n      vi.useFakeTimers()\n      listAdapterMock.fetchList.mockClear()\n    })\n\n    afterEach(() => {\n      vi.clearAllTimers()\n    })\n\n    it(\"should not poll if the polling time is null\", () => {\n      const container = new TestContainer()\n\n      listAdapterMock.isInitialized = true // We need to initialize the list adapter before we can use it\n      const service = container.bind(WorkspaceService)\n\n      service.acquireTeamListAdapter(null)\n      vi.advanceTimersByTime(100000)\n\n      expect(listAdapterMock.fetchList).not.toHaveBeenCalled()\n    })\n\n    it(\"should not poll if the polling time is not null and user not logged in\", async () => {\n      const container = new TestContainer()\n\n      const service = container.bind(WorkspaceService)\n\n      service.acquireTeamListAdapter(100)\n      await nextTick()\n      vi.advanceTimersByTime(110)\n\n      platformMock.auth.getCurrentUser.mockReturnValue(null)\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject(null)\n      )\n\n      expect(listAdapterMock.fetchList).not.toHaveBeenCalled()\n    })\n\n    it(\"should poll if the polling time is not null and the user is logged in\", async () => {\n      const container = new TestContainer()\n\n      listAdapterMock.isInitialized = true // We need to initialize the list adapter before we can use it\n\n      platformMock.auth.getCurrentUser.mockReturnValue({\n        id: \"test\",\n      })\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ id: \"test\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n\n      const adapter = service.acquireTeamListAdapter(100)\n      await nextTick()\n      vi.advanceTimersByTime(100)\n\n      expect(adapter!.fetchList).toHaveBeenCalledOnce()\n    })\n\n    it(\"emits 'managed-team-list-adapter-polled' when the service polls the adapter\", async () => {\n      const container = new TestContainer()\n\n      listAdapterMock.isInitialized = true\n\n      platformMock.auth.getCurrentUser.mockReturnValue({\n        id: \"test\",\n      })\n\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ id: \"test\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n\n      const eventFn = vi.fn()\n      const sub = service.getEventStream().subscribe(eventFn)\n\n      service.acquireTeamListAdapter(100)\n      await nextTick()\n      vi.advanceTimersByTime(100)\n\n      expect(eventFn).toHaveBeenCalledOnce()\n      expect(eventFn).toHaveBeenCalledWith({\n        type: \"managed-team-list-adapter-polled\",\n      })\n\n      sub.unsubscribe()\n    })\n\n    it(\"stops polling when the Vue effect scope is disposed and there is no more polling locks\", async () => {\n      const container = new TestContainer()\n\n      listAdapterMock.isInitialized = true\n\n      platformMock.auth.getCurrentUser.mockReturnValue({\n        id: \"test\",\n      })\n\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ id: \"test\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n      listAdapterMock.fetchList.mockClear() // Reset the counters\n\n      const scopeHandle = effectScope()\n      scopeHandle.run(() => {\n        service.acquireTeamListAdapter(100)\n      })\n\n      await nextTick()\n      vi.advanceTimersByTime(100)\n\n      expect(listAdapterMock.fetchList).toHaveBeenCalledOnce()\n      listAdapterMock.fetchList.mockClear()\n\n      scopeHandle.stop()\n\n      await nextTick()\n      vi.advanceTimersByTime(100)\n\n      expect(listAdapterMock.fetchList).not.toHaveBeenCalled()\n    })\n  })\n\n  describe(\"Workspace Synchronization\", () => {\n    it(\"should call changeTeamID and fetchTeamPublishedDocs when workspace changes to a team workspace\", async () => {\n      const container = new TestContainer()\n\n      // Mock user for this test\n      platformMock.auth.getCurrentUser.mockReturnValue({ uid: \"test-user\" })\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ uid: \"test-user\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n\n      // Access the mocks\n      const teamCollectionServiceMock = (service as any).teamCollectionService\n      const documentationServiceMock = (service as any).documentationService\n\n      // Change to team workspace\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"team-123\",\n        teamName: \"Test Team\",\n        role: null,\n      })\n\n      await nextTick()\n\n      expect(teamCollectionServiceMock.changeTeamID).toHaveBeenCalledWith(\n        \"team-123\"\n      )\n      expect(\n        documentationServiceMock.fetchTeamPublishedDocs\n      ).toHaveBeenCalledWith(\"team-123\")\n    })\n\n    it(\"should call clearCollections and fetchUserPublishedDocs when workspace changes to personal workspace\", async () => {\n      const container = new TestContainer()\n\n      // Mock user for this test\n      platformMock.auth.getCurrentUser.mockReturnValue({ uid: \"test-user\" })\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ uid: \"test-user\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n\n      // Start with a team workspace\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"team-123\",\n        teamName: \"Test Team\",\n        role: null,\n      })\n\n      await nextTick()\n\n      const teamCollectionServiceMock = (service as any).teamCollectionService\n      const documentationServiceMock = (service as any).documentationService\n\n      teamCollectionServiceMock.clearCollections.mockClear()\n      documentationServiceMock.fetchUserPublishedDocs.mockClear()\n\n      // Change to personal workspace\n      service.changeWorkspace({\n        type: \"personal\",\n      })\n\n      await nextTick()\n\n      expect(teamCollectionServiceMock.clearCollections).toHaveBeenCalled()\n      expect(documentationServiceMock.fetchUserPublishedDocs).toHaveBeenCalled()\n    })\n\n    it(\"should call clearCollections and fetchUserPublishedDocs when workspace changes to team workspace without teamID\", async () => {\n      const container = new TestContainer()\n\n      // Mock user for this test\n      platformMock.auth.getCurrentUser.mockReturnValue({ uid: \"test-user\" })\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ uid: \"test-user\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n\n      const teamCollectionServiceMock = (service as any).teamCollectionService\n      const documentationServiceMock = (service as any).documentationService\n\n      // Change to team workspace without teamID\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"\",\n        teamName: \"Test Team\",\n        role: null,\n      })\n\n      await nextTick()\n\n      expect(teamCollectionServiceMock.clearCollections).toHaveBeenCalled()\n      expect(documentationServiceMock.fetchUserPublishedDocs).toHaveBeenCalled()\n    })\n\n    it(\"should not sync when workspaces are effectively the same\", async () => {\n      const container = new TestContainer()\n      const service = container.bind(WorkspaceService)\n\n      // Start with a team workspace\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"team-123\",\n        teamName: \"Test Team\",\n        role: null,\n      })\n\n      await nextTick()\n\n      const teamCollectionServiceMock = (service as any).teamCollectionService\n      const documentationServiceMock = (service as any).documentationService\n\n      teamCollectionServiceMock.changeTeamID.mockClear()\n      documentationServiceMock.fetchTeamPublishedDocs.mockClear()\n\n      // Change to same team workspace (different name, same ID)\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"team-123\",\n        teamName: \"Updated Team Name\",\n        role: null,\n      })\n\n      await nextTick()\n\n      // Should not call sync methods again since it's the same team\n      expect(teamCollectionServiceMock.changeTeamID).not.toHaveBeenCalled()\n      expect(\n        documentationServiceMock.fetchTeamPublishedDocs\n      ).not.toHaveBeenCalled()\n    })\n\n    it(\"should handle errors during synchronization gracefully\", async () => {\n      const container = new TestContainer()\n      const service = container.bind(WorkspaceService)\n\n      const teamCollectionServiceMock = (service as any).teamCollectionService\n      teamCollectionServiceMock.changeTeamID.mockImplementation(() => {\n        throw new Error(\"Sync failed\")\n      })\n\n      const consoleSpy = vi.spyOn(console, \"error\").mockImplementation(() => {})\n\n      // Change to team workspace (should not throw)\n      expect(() => {\n        service.changeWorkspace({\n          type: \"team\",\n          teamID: \"team-123\",\n          teamName: \"Test Team\",\n          role: null,\n        })\n      }).not.toThrow()\n\n      await nextTick()\n\n      expect(consoleSpy).toHaveBeenCalledWith(\n        \"Failed to sync workspace data:\",\n        expect.any(Error)\n      )\n\n      consoleSpy.mockRestore()\n    })\n\n    it(\"should fetch user published docs only when user is authenticated\", async () => {\n      // Case 1: No user\n      platformMock.auth.getCurrentUser.mockReturnValue(null)\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject(null)\n      )\n      const container1 = new TestContainer()\n      const service1 = container1.bind(WorkspaceService)\n      const docMock1 = (service1 as any).documentationService\n      docMock1.fetchUserPublishedDocs.mockClear()\n\n      service1.changeWorkspace({ type: \"personal\" })\n      await nextTick()\n      expect(docMock1.fetchUserPublishedDocs).not.toHaveBeenCalled()\n\n      // Case 2: With user\n      platformMock.auth.getCurrentUser.mockReturnValue({ uid: \"test-user\" })\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ uid: \"test-user\" })\n      )\n      const container2 = new TestContainer()\n      const service2 = container2.bind(WorkspaceService)\n      const docMock2 = (service2 as any).documentationService\n\n      // We check if it was called on initialization\n      await nextTick()\n      expect(docMock2.fetchUserPublishedDocs).toHaveBeenCalled()\n    })\n  })\n\n  describe(\"areWorkspacesEqual\", () => {\n    let service: WorkspaceService\n\n    beforeEach(() => {\n      const container = new TestContainer()\n      service = container.bind(WorkspaceService)\n    })\n\n    it(\"should return false when newWorkspace is undefined\", () => {",
            "output_extracted": "import { describe, expect, vi, it, beforeEach, afterEach } from \"vitest\"\nimport { TestContainer } from \"dioc/testing\"\nimport { WorkspaceService } from \"../workspace.service\"\nimport { setPlatformDef } from \"~/platform\"\nimport { BehaviorSubject } from \"rxjs\"\nimport { effectScope, nextTick } from \"vue\"\n\nconst listAdapterMock = vi.hoisted(() => ({\n  isInitialized: false,\n  initialize: vi.fn(() => {\n    listAdapterMock.isInitialized = true\n  }),\n  dispose: vi.fn(() => {\n    listAdapterMock.isInitialized = false\n  }),\n  fetchList: vi.fn(),\n}))\n\nvi.mock(\"~/helpers/teams/TeamListAdapter\", () => ({\n  default: class {\n    isInitialized = listAdapterMock.isInitialized\n    initialize = listAdapterMock.initialize\n    dispose = listAdapterMock.dispose\n    fetchList = listAdapterMock.fetchList\n  },\n}))\n\n// Mock TeamCollectionsService to prevent i18n dependency issues\nvi.mock(\"../team-collection.service\", () => ({\n  TeamCollectionsService: class MockTeamCollectionsService {\n    static readonly ID = \"TEAM_COLLECTIONS_SERVICE\"\n\n    changeTeamID = vi.fn()\n    clearCollections = vi.fn()\n\n    onServiceInit = vi.fn()\n  },\n}))\n\n// Mock DocumentationService\nvi.mock(\"../documentation.service\", () => ({\n  DocumentationService: class MockDocumentationService {\n    static readonly ID = \"DOCUMENTATION_SERVICE\"\n\n    fetchTeamPublishedDocs = vi.fn()\n    fetchUserPublishedDocs = vi.fn()\n\n    onServiceInit = vi.fn()\n  },\n}))\n\ndescribe(\"WorkspaceService\", () => {\n  const platformMock = {\n    auth: {\n      getCurrentUserStream: vi.fn(),\n      getCurrentUser: vi.fn(),\n      waitProbableLoginToConfirm: vi.fn().mockResolvedValue(undefined),\n    },\n  }\n\n  beforeEach(() => {\n    // @ts-expect-error - We're mocking the platform\n    setPlatformDef(platformMock)\n\n    platformMock.auth.getCurrentUserStream.mockReturnValue(\n      new BehaviorSubject(null)\n    )\n\n    platformMock.auth.getCurrentUser.mockReturnValue(null)\n  })\n\n  describe(\"Initialization\", () => {\n    it(\"should initialize with the personal workspace selected\", () => {\n      const container = new TestContainer()\n\n      const service = container.bind(WorkspaceService)\n\n      expect(service.currentWorkspace.value).toEqual({ type: \"personal\" })\n    })\n  })\n\n  describe(\"updateWorkspaceTeamName\", () => {\n    it(\"should update the workspace team name if the current workspace is a team workspace\", () => {\n      const container = new TestContainer()\n\n      const service = container.bind(WorkspaceService)\n\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"test\",\n        teamName: \"before update\",\n        role: null,\n      })\n\n      service.updateWorkspaceTeamName(\"test\")\n\n      expect(service.currentWorkspace.value).toEqual({\n        type: \"team\",\n        teamID: \"test\",\n        teamName: \"test\",\n        role: null,\n      })\n    })\n\n    it(\"should not update the workspace team name if the current workspace is a personal workspace\", () => {\n      const container = new TestContainer()\n\n      const service = container.bind(WorkspaceService)\n\n      service.changeWorkspace({\n        type: \"personal\",\n      })\n\n      service.updateWorkspaceTeamName(\"test\")\n\n      expect(service.currentWorkspace.value).toEqual({ type: \"personal\" })\n    })\n  })\n\n  describe(\"changeWorkspace\", () => {\n    it(\"updates the current workspace value to the given workspace\", () => {\n      const container = new TestContainer()\n\n      const service = container.bind(WorkspaceService)\n\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"test\",\n        teamName: \"test\",\n        role: null,\n      })\n\n      expect(service.currentWorkspace.value).toEqual({\n        type: \"team\",\n        teamID: \"test\",\n        teamName: \"test\",\n        role: null,\n      })\n    })\n  })\n\n  describe(\"acquireTeamListAdapter\", () => {\n    beforeEach(() => {\n      vi.useFakeTimers()\n      listAdapterMock.fetchList.mockClear()\n    })\n\n    afterEach(() => {\n      vi.clearAllTimers()\n    })\n\n    it(\"should not poll if the polling time is null\", () => {\n      const container = new TestContainer()\n\n      listAdapterMock.isInitialized = true // We need to initialize the list adapter before we can use it\n      const service = container.bind(WorkspaceService)\n\n      service.acquireTeamListAdapter(null)\n      vi.advanceTimersByTime(100000)\n\n      expect(listAdapterMock.fetchList).not.toHaveBeenCalled()\n    })\n\n    it(\"should not poll if the polling time is not null and user not logged in\", async () => {\n      const container = new TestContainer()\n\n      const service = container.bind(WorkspaceService)\n\n      service.acquireTeamListAdapter(100)\n      await nextTick()\n      vi.advanceTimersByTime(110)\n\n      platformMock.auth.getCurrentUser.mockReturnValue(null)\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject(null)\n      )\n\n      expect(listAdapterMock.fetchList).not.toHaveBeenCalled()\n    })\n\n    it(\"should poll if the polling time is not null and the user is logged in\", async () => {\n      const container = new TestContainer()\n\n      listAdapterMock.isInitialized = true // We need to initialize the list adapter before we can use it\n\n      platformMock.auth.getCurrentUser.mockReturnValue({\n        id: \"test\",\n      })\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ id: \"test\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n\n      const adapter = service.acquireTeamListAdapter(100)\n      await nextTick()\n      vi.advanceTimersByTime(100)\n\n      expect(adapter!.fetchList).toHaveBeenCalledOnce()\n    })\n\n    it(\"emits 'managed-team-list-adapter-polled' when the service polls the adapter\", async () => {\n      const container = new TestContainer()\n\n      listAdapterMock.isInitialized = true\n\n      platformMock.auth.getCurrentUser.mockReturnValue({\n        id: \"test\",\n      })\n\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ id: \"test\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n\n      const eventFn = vi.fn()\n      const sub = service.getEventStream().subscribe(eventFn)\n\n      service.acquireTeamListAdapter(100)\n      await nextTick()\n      vi.advanceTimersByTime(100)\n\n      expect(eventFn).toHaveBeenCalledOnce()\n      expect(eventFn).toHaveBeenCalledWith({\n        type: \"managed-team-list-adapter-polled\",\n      })\n\n      sub.unsubscribe()\n    })\n\n    it(\"stops polling when the Vue effect scope is disposed and there is no more polling locks\", async () => {\n      const container = new TestContainer()\n\n      listAdapterMock.isInitialized = true\n\n      platformMock.auth.getCurrentUser.mockReturnValue({\n        id: \"test\",\n      })\n\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ id: \"test\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n      listAdapterMock.fetchList.mockClear() // Reset the counters\n\n      const scopeHandle = effectScope()\n      scopeHandle.run(() => {\n        service.acquireTeamListAdapter(100)\n      })\n\n      await nextTick()\n      vi.advanceTimersByTime(100)\n\n      expect(listAdapterMock.fetchList).toHaveBeenCalledOnce()\n      listAdapterMock.fetchList.mockClear()\n\n      scopeHandle.stop()\n\n      await nextTick()\n      vi.advanceTimersByTime(100)\n\n      expect(listAdapterMock.fetchList).not.toHaveBeenCalled()\n    })\n  })\n\n  describe(\"Workspace Synchronization\", () => {\n    it(\"should call changeTeamID and fetchTeamPublishedDocs when workspace changes to a team workspace\", async () => {\n      const container = new TestContainer()\n\n      // Mock user for this test\n      platformMock.auth.getCurrentUser.mockReturnValue({ uid: \"test-user\" })\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ uid: \"test-user\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n\n      // Access the mocks\n      const teamCollectionServiceMock = (service as any).teamCollectionService\n      const documentationServiceMock = (service as any).documentationService\n\n      // Change to team workspace\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"team-123\",\n        teamName: \"Test Team\",\n        role: null,\n      })\n\n      await nextTick()\n\n      expect(teamCollectionServiceMock.changeTeamID).toHaveBeenCalledWith(\n        \"team-123\"\n      )\n      expect(\n        documentationServiceMock.fetchTeamPublishedDocs\n      ).toHaveBeenCalledWith(\"team-123\")\n    })\n\n    it(\"should call clearCollections and fetchUserPublishedDocs when workspace changes to personal workspace\", async () => {\n      const container = new TestContainer()\n\n      // Mock user for this test\n      platformMock.auth.getCurrentUser.mockReturnValue({ uid: \"test-user\" })\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ uid: \"test-user\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n\n      // Start with a team workspace\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"team-123\",\n        teamName: \"Test Team\",\n        role: null,\n      })\n\n      await nextTick()\n\n      const teamCollectionServiceMock = (service as any).teamCollectionService\n      const documentationServiceMock = (service as any).documentationService\n\n      teamCollectionServiceMock.clearCollections.mockClear()\n      documentationServiceMock.fetchUserPublishedDocs.mockClear()\n\n      // Change to personal workspace\n      service.changeWorkspace({\n        type: \"personal\",\n      })\n\n      await nextTick()\n\n      expect(teamCollectionServiceMock.clearCollections).toHaveBeenCalled()\n      expect(documentationServiceMock.fetchUserPublishedDocs).toHaveBeenCalled()\n    })\n\n    it(\"should call clearCollections and fetchUserPublishedDocs when workspace changes to team workspace without teamID\", async () => {\n      const container = new TestContainer()\n\n      // Mock user for this test\n      platformMock.auth.getCurrentUser.mockReturnValue({ uid: \"test-user\" })\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ uid: \"test-user\" })\n      )\n\n      const service = container.bind(WorkspaceService)\n\n      const teamCollectionServiceMock = (service as any).teamCollectionService\n      const documentationServiceMock = (service as any).documentationService\n\n      // Change to team workspace without teamID\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"\",\n        teamName: \"Test Team\",\n        role: null,\n      })\n\n      await nextTick()\n\n      expect(teamCollectionServiceMock.clearCollections).toHaveBeenCalled()\n      expect(documentationServiceMock.fetchUserPublishedDocs).toHaveBeenCalled()\n    })\n\n    it(\"should not sync when workspaces are effectively the same\", async () => {\n      const container = new TestContainer()\n      const service = container.bind(WorkspaceService)\n\n      // Start with a team workspace\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"team-123\",\n        teamName: \"Test Team\",\n        role: null,\n      })\n\n      await nextTick()\n\n      const teamCollectionServiceMock = (service as any).teamCollectionService\n      const documentationServiceMock = (service as any).documentationService\n\n      teamCollectionServiceMock.changeTeamID.mockClear()\n      documentationServiceMock.fetchTeamPublishedDocs.mockClear()\n\n      // Change to same team workspace (different name, same ID)\n      service.changeWorkspace({\n        type: \"team\",\n        teamID: \"team-123\",\n        teamName: \"Updated Team Name\",\n        role: null,\n      })\n\n      await nextTick()\n\n      // Should not call sync methods again since it's the same team\n      expect(teamCollectionServiceMock.changeTeamID).not.toHaveBeenCalled()\n      expect(\n        documentationServiceMock.fetchTeamPublishedDocs\n      ).not.toHaveBeenCalled()\n    })\n\n    it(\"should handle errors during synchronization gracefully\", async () => {\n      const container = new TestContainer()\n      const service = container.bind(WorkspaceService)\n\n      const teamCollectionServiceMock = (service as any).teamCollectionService\n      teamCollectionServiceMock.changeTeamID.mockImplementation(() => {\n        throw new Error(\"Sync failed\")\n      })\n\n      const consoleSpy = vi.spyOn(console, \"error\").mockImplementation(() => {})\n\n      // Change to team workspace (should not throw)\n      expect(() => {\n        service.changeWorkspace({\n          type: \"team\",\n          teamID: \"team-123\",\n          teamName: \"Test Team\",\n          role: null,\n        })\n      }).not.toThrow()\n\n      await nextTick()\n\n      expect(consoleSpy).toHaveBeenCalledWith(\n        \"Failed to sync workspace data:\",\n        expect.any(Error)\n      )\n\n      consoleSpy.mockRestore()\n    })\n\n    it(\"should fetch user published docs only when user is authenticated\", async () => {\n      // Case 1: No user\n      platformMock.auth.getCurrentUser.mockReturnValue(null)\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject(null)\n      )\n      const container1 = new TestContainer()\n      const service1 = container1.bind(WorkspaceService)\n      const docMock1 = (service1 as any).documentationService\n      docMock1.fetchUserPublishedDocs.mockClear()\n\n      service1.changeWorkspace({ type: \"personal\" })\n      await nextTick()\n      expect(docMock1.fetchUserPublishedDocs).not.toHaveBeenCalled()\n\n      // Case 2: With user\n      platformMock.auth.getCurrentUser.mockReturnValue({ uid: \"test-user\" })\n      platformMock.auth.getCurrentUserStream.mockReturnValue(\n        new BehaviorSubject({ uid: \"test-user\" })\n      )\n      const container2 = new TestContainer()\n      const service2 = container2.bind(WorkspaceService)\n      const docMock2 = (service2 as any).documentationService\n\n      // We check if it was called on initialization\n      await nextTick()\n      expect(docMock2.fetchUserPublishedDocs).toHaveBeenCalled()\n    })\n  })\n\n  describe(\"areWorkspacesEqual\", () => {\n    let service: WorkspaceService\n\n    beforeEach(() => {\n      const container = new TestContainer()\n      service = container.bind(WorkspaceService)\n    })\n\n    it(\"should return false when newWorkspace is undefined\", () => {",
            "cost": 0.14148
        },
        "hoppscotch__hoppscotch.main/packages/hoppscotch-common/src/services/team-collection.service.ts": {
            "output": "import * as E from \"fp-ts/Either\"\nimport { Subscription } from \"rxjs\"\nimport {\n  HoppCollectionVariable,\n  HoppRESTAuth,\n  HoppRESTHeader,\n  translateToNewRequest,\n} from \"@hoppscotch/data\"\nimport { pull, remove } from \"lodash-es\"\nimport { Subscription as WSubscription } from \"wonka\"\nimport {\n  RootCollectionsOfTeamDocument,\n  TeamCollectionAddedDocument,\n  TeamCollectionUpdatedDocument,\n  TeamCollectionRemovedDocument,\n  TeamRequestAddedDocument,\n  TeamRequestUpdatedDocument,\n  TeamRequestDeletedDocument,\n  GetCollectionChildrenDocument,\n  GetCollectionRequestsDocument,\n  TeamRequestMovedDocument,\n  TeamCollectionMovedDocument,\n  TeamRequestOrderUpdatedDocument,\n  TeamCollectionOrderUpdatedDocument,\n  TeamRootCollectionsSortedDocument,\n  TeamChildCollectionSortedDocument,\n} from \"~/helpers/backend/graphql\"\nimport { SecretEnvironmentService } from \"~/services/secret-environment.service\"\nimport { CurrentValueService } from \"~/services/current-environment-value.service\"\nimport { TeamCollection } from \"~/helpers/teams/TeamCollection\"\nimport { TeamRequest } from \"~/helpers/teams/TeamRequest\"\nimport { runGQLQuery, runGQLSubscription } from \"~/helpers/backend/GQLClient\"\nimport { HoppInheritedProperty } from \"~/helpers/types/HoppInheritedProperties\"\nimport { WorkspaceService } from \"./workspace.service\"\nimport { ref, watch } from \"vue\"\nimport { Service } from \"dioc\"\nimport { updateInheritedPropertiesForAffectedRequests } from \"~/helpers/collection/collection\"\n\nexport const TEAMS_BACKEND_PAGE_SIZE = 10\n\nconst findParentOfColl = (\n  tree: TeamCollection[],\n  collID: string,\n  currentParent?: TeamCollection\n): TeamCollection | null => {\n  for (const coll of tree) {\n    // If the root is parent, return null\n    if (coll.id === collID) return currentParent || null\n\n    // Else run it in children\n    if (coll.children) {\n      const result = findParentOfColl(coll.children, collID, coll)\n      if (result) return result\n    }\n  }\n\n  return null\n}\n\nconst findCollInTree = (\n  tree: TeamCollection[],\n  targetID: string\n): TeamCollection | null => {\n  for (const coll of tree) {\n    if (coll.id === targetID) return coll\n\n    if (coll.children) {\n      const result = findCollInTree(coll.children, targetID)\n      if (result) return result\n    }\n  }\n\n  return null\n}\n\nconst deleteCollInTree = (tree: TeamCollection[], targetID: string) => {\n  const parent = findParentOfColl(tree, targetID)\n\n  if (parent && parent.children) {\n    parent.children = parent.children.filter((coll) => coll.id !== targetID)\n  }\n\n  const el = findCollInTree(tree, targetID)\n  if (!el) return\n\n  pull(tree, el)\n}\n\nconst updateCollInTree = (\n  tree: TeamCollection[],\n  updateColl: Partial<TeamCollection> & Pick<TeamCollection, \"id\">\n) => {\n  const el = findCollInTree(tree, updateColl.id)\n  if (!el) return\n  Object.assign(el, updateColl)\n}\n\nconst findReqInTree = (\n  tree: TeamCollection[],\n  reqID: string\n): TeamRequest | null => {\n  for (const coll of tree) {\n    if (coll.requests) {\n      const match = coll.requests.find((req) => req.id === reqID)\n      if (match) return match\n    }\n\n    if (coll.children) {\n      const match = findReqInTree(coll.children, reqID)\n      if (match) return match\n    }\n  }\n\n  return null\n}\n\nconst findCollWithReqIDInTree = (\n  tree: TeamCollection[],\n  reqID: string\n): TeamCollection | null => {\n  for (const coll of tree) {\n    if (coll.requests) {\n      if (coll.requests.find((req) => req.id === reqID)) return coll\n    }\n\n    if (coll.children) {\n      const result = findCollWithReqIDInTree(coll.children, reqID)\n      if (result) return result\n    }\n  }\n\n  return null\n}\n\nexport class TeamCollectionsService extends Service<void> {\n  public static readonly ID = \"TEAM_COLLECTIONS_SERVICE\"\n\n  //collection variables current value and secret value services\n  private secretEnvironmentService = this.bind(SecretEnvironmentService)\n  private currentEnvironmentValueService = this.bind(CurrentValueService)\n\n  private workspaceService = this.bind(WorkspaceService)\n\n  private teamID: string | null = null\n\n  public collections = ref<TeamCollection[]>([])\n  public loadingCollections = ref<string[]>([])\n  public pendingTeamCollectionPath = ref<string | null>(null)\n\n  private entityIDs: Set<string> = new Set()\n\n  private teamCollectionAdded$: Subscription | null = null\n  private teamCollectionUpdated$: Subscription | null = null\n  private teamCollectionRemoved$: Subscription | null = null\n  private teamRequestAdded$: Subscription | null = null\n  private teamRequestUpdated$: Subscription | null = null\n  private teamRequestDeleted$: Subscription | null = null\n  private teamRequestMoved$: Subscription | null = null\n  private teamCollectionMoved$: Subscription | null = null\n  private teamRequestOrderUpdated$: Subscription | null = null\n  private teamCollectionOrderUpdated$: Subscription | null = null\n  private teamRootCollectionSorted$: Subscription | null = null\n  private teamChildCollectionSorted$: Subscription | null = null\n\n  private teamCollectionAddedSub: WSubscription | null = null\n  private teamCollectionUpdatedSub: WSubscription | null = null\n  private teamCollectionRemovedSub: WSubscription | null = null\n  private teamRequestAddedSub: WSubscription | null = null\n  private teamRequestUpdatedSub: WSubscription | null = null\n  private teamRequestDeletedSub: WSubscription | null = null\n  private teamRequestMovedSub: WSubscription | null = null\n  private teamCollectionMovedSub: WSubscription | null = null\n  private teamRequestOrderUpdatedSub: WSubscription | null = null\n  private teamCollectionOrderUpdatedSub: WSubscription | null = null\n  private teamRootCollectionSortedSub: WSubscription | null = null\n  private teamChildCollectionSortedSub: WSubscription | null = null\n\n  override onServiceInit() {\n    // Watch for team change and update the collections accordingly\n    watch(\n      () => this.workspaceService.currentWorkspace,\n      (workspace) => {\n        if (workspace.value.type === \"team\" && workspace.value.teamID) {\n          this.changeTeamID(workspace.value.teamID)\n        } else {\n          this.clearCollections()\n        }\n      },\n      { immediate: true, deep: true }\n    )\n\n    // Watch for completion of loading (when all loading flags are cleared) to update inherited properties once\n    watch(\n      () => this.loadingCollections.value.length,\n      (loadingCount) => {\n        if (\n          loadingCount === 0 &&\n          this.pendingTeamCollectionPath.value &&\n          this.collections.value.length > 0\n        ) {\n          updateInheritedPropertiesForAffectedRequests(\n            this.pendingTeamCollectionPath.value,\n            \"rest\"\n          )\n          this.pendingTeamCollectionPath.value = null\n        }\n      }\n    )\n  }\n\n  changeTeamID(newTeamID: string | null) {\n    this.teamID = newTeamID\n    this.collections.value = []\n    this.entityIDs.clear()\n\n    this.loadingCollections.value = []\n\n    this.unsubscribeSubscriptions()\n\n    if (this.teamID) this.initialize()\n  }\n\n  /**\n   * Unsubscribes from the subscriptions\n   * NOTE: Once this is called, no new updates to the tree will be detected\n   */\n  unsubscribeSubscriptions() {\n    this.teamCollectionAdded$?.unsubscribe()\n    this.teamCollectionUpdated$?.unsubscribe()\n    this.teamCollectionRemoved$?.unsubscribe()\n    this.teamRequestAdded$?.unsubscribe()\n    this.teamRequestDeleted$?.unsubscribe()\n    this.teamRequestUpdated$?.unsubscribe()\n    this.teamRequestMoved$?.unsubscribe()\n    this.teamCollectionMoved$?.unsubscribe()\n    this.teamRequestOrderUpdated$?.unsubscribe()\n    this.teamCollectionOrderUpdated$?.unsubscribe()\n    this.teamRootCollectionSorted$?.unsubscribe()\n    this.teamChildCollectionSorted$?.unsubscribe()\n\n    this.teamCollectionAddedSub?.unsubscribe()\n    this.teamCollectionUpdatedSub?.unsubscribe()\n    this.teamCollectionRemovedSub?.unsubscribe()\n    this.teamRequestAddedSub?.unsubscribe()\n    this.teamRequestDeletedSub?.unsubscribe()\n    this.teamRequestUpdatedSub?.unsubscribe()\n    this.teamRequestMovedSub?.unsubscribe()\n    this.teamCollectionMovedSub?.unsubscribe()\n    this.teamRequestOrderUpdatedSub?.unsubscribe()\n    this.teamCollectionOrderUpdatedSub?.unsubscribe()\n    this.teamRootCollectionSortedSub?.unsubscribe()\n    this.teamChildCollectionSortedSub?.unsubscribe()\n  }\n\n  private async initialize() {\n    await this.loadRootCollections()\n    this.registerSubscriptions()\n  }\n\n  /**\n   * Performs addition of a collection to the tree\n   *\n   * @param {TeamCollection} collection - The collection to add to the tree\n   * @param {string | null} parentCollectionID - The parent of the new collection, pass null if this collection is in root\n   */\n  private addCollection(\n    collection: TeamCollection,\n    parentCollectionID: string | null\n  ) {\n    // Check if we have it already in the entity tree, if so, we don't need it again\n    if (this.entityIDs.has(`collection-${collection.id}`)) return\n\n    const tree = this.collections.value\n\n    if (!parentCollectionID) {\n      tree.push(collection)\n    } else {\n      const parentCollection = findCollInTree(tree, parentCollectionID)\n\n      if (!parentCollection) return\n\n      // Prevent adding child collections to a collection that has not been expanded yet incoming from GQL subscription, during import, etc\n      // Hence, add entries to the pre-existing list without setting 'children' if it is `null'\n      if (parentCollection.children !== null) {\n        parentCollection.children.push(collection)\n      }\n    }\n\n    // Add to entity ids set\n    this.entityIDs.add(`collection-${collection.id}`)\n\n    this.collections.value = tree\n  }\n\n  private clearCollections() {\n    this.collections.value = []\n    this.entityIDs.clear()\n    this.loadingCollections.value = []\n    this.unsubscribeSubscriptions()\n    this.teamID = null\n  }\n\n  /**\n   * Loads the root collections of the current team\n   * @param replace Whether to replace the existing collections or append to them\n   * We might want to replace when we are reloading the collections like when sorting the whole root collections\n   */\n  private async loadRootCollections(replace = false) {\n    if (this.teamID === null) throw new Error(\"Team ID is null\")\n\n    this.loadingCollections.value.push(\"root\")\n\n    const totalCollections: TeamCollection[] = []\n\n    while (true) {\n      const result = await runGQLQuery({\n        query: RootCollectionsOfTeamDocument,\n        variables: {\n          teamID: this.teamID,\n          cursor:\n            totalCollections.length > 0\n              ? totalCollections[totalCollections.length - 1].id\n              : undefined,\n        },\n      })\n\n      if (E.isLeft(result)) {\n        this.loadingCollections.value = this.loadingCollections.value.filter(\n          (x) => x !== \"root\"\n        )\n\n        throw new Error(\n          `Error fetching root collections: ${result.left?.error}`\n        )\n      }\n\n      if (replace) {\n        this.collections.value = []\n        this.entityIDs.clear()\n\n        totalCollections.push(\n          ...result.right.rootCollectionsOfTeam.map(\n            (x: any) =>\n              <TeamCollection>{\n                ...x,\n                children: null,\n                requests: null,\n              }\n          )\n        )\n      } else {\n        totalCollections.push(\n          ...result.right.rootCollectionsOfTeam.map(\n            (x: any) =>\n              <TeamCollection>{\n                ...x,\n                children: null,\n                requests: null,\n              }\n          )\n        )\n      }\n\n      if (result.right.rootCollectionsOfTeam.length !== TEAMS_BACKEND_PAGE_SIZE)\n        break\n    }\n\n    this.loadingCollections.value = this.loadingCollections.value.filter(\n      (x) => x !== \"root\"\n    )\n\n    // Add all the collections to the entity ids list\n    totalCollections.forEach((coll) =>\n      this.entityIDs.add(`collection-${coll.id}`)\n    )\n\n    this.collections.value.push(...totalCollections)\n  }\n\n  /**\n   * Updates an existing collection in tree\n   *\n   * @param {Partial<TeamCollection> & Pick<TeamCollection, \"id\">} collectionUpdate - Object defining the fields that need to be updated (ID is required to find the target)\n   */\n  private updateCollection(\n    collectionUpdate: Partial<TeamCollection> & Pick<TeamCollection, \"id\">\n  ) {\n    const tree = this.collections.value\n\n    updateCollInTree(tree, collectionUpdate)\n\n    this.collections.value = tree\n  }\n\n  /**\n   * Removes a collection from the tree\n   *\n   * @param {string} collectionID - ID of the collection to remove\n   */\n  private removeCollection(collectionID: string) {\n    const tree = this.collections.value\n\n    deleteCollInTree(tree, collectionID)\n\n    this.entityIDs.delete(`collection-${collectionID}`)\n\n    this.collections.value = tree\n  }\n\n  /**\n   * Adds a request to the tree\n   *\n   * @param {TeamRequest} request - The request to add to the tree\n   */\n  private addRequest(request: TeamRequest) {\n    // Check if we have it already in the entity tree, if so, we don't need it again\n    if (this.entityIDs.has(`request-${request.id}`)) return\n\n    const tree = this.collections.value\n\n    // Check if we have the collection (if not, then not loaded?)\n    const coll = findCollInTree(tree, request.collectionID)\n    if (!coll) return // Ignore add request\n\n    // Collection is not expanded\n    if (!coll.requests) return\n\n    // Collection is expanded hence append request\n    coll.requests.push(request)\n\n    // Update the Entity IDs list\n    this.entityIDs.add(`request-${request.id}`)\n\n    this.collections.value = tree\n  }\n\n  /**\n   * Updates the request in tree\n   *\n   * @param {Partial<TeamRequest> & Pick<TeamRequest, 'id'>} requestUpdate - Object defining all the fields to update in request (ID of the request is required)\n   */\n  private updateRequest(\n    requestUpdate: Partial<TeamRequest> & Pick<TeamRequest, \"id\">\n  ) {\n    const tree = this.collections.value\n\n    //",
            "output_extracted": "import * as E from \"fp-ts/Either\"\nimport { Subscription } from \"rxjs\"\nimport {\n  HoppCollectionVariable,\n  HoppRESTAuth,\n  HoppRESTHeader,\n  translateToNewRequest,\n} from \"@hoppscotch/data\"\nimport { pull, remove } from \"lodash-es\"\nimport { Subscription as WSubscription } from \"wonka\"\nimport {\n  RootCollectionsOfTeamDocument,\n  TeamCollectionAddedDocument,\n  TeamCollectionUpdatedDocument,\n  TeamCollectionRemovedDocument,\n  TeamRequestAddedDocument,\n  TeamRequestUpdatedDocument,\n  TeamRequestDeletedDocument,\n  GetCollectionChildrenDocument,\n  GetCollectionRequestsDocument,\n  TeamRequestMovedDocument,\n  TeamCollectionMovedDocument,\n  TeamRequestOrderUpdatedDocument,\n  TeamCollectionOrderUpdatedDocument,\n  TeamRootCollectionsSortedDocument,\n  TeamChildCollectionSortedDocument,\n} from \"~/helpers/backend/graphql\"\nimport { SecretEnvironmentService } from \"~/services/secret-environment.service\"\nimport { CurrentValueService } from \"~/services/current-environment-value.service\"\nimport { TeamCollection } from \"~/helpers/teams/TeamCollection\"\nimport { TeamRequest } from \"~/helpers/teams/TeamRequest\"\nimport { runGQLQuery, runGQLSubscription } from \"~/helpers/backend/GQLClient\"\nimport { HoppInheritedProperty } from \"~/helpers/types/HoppInheritedProperties\"\nimport { WorkspaceService } from \"./workspace.service\"\nimport { ref, watch } from \"vue\"\nimport { Service } from \"dioc\"\nimport { updateInheritedPropertiesForAffectedRequests } from \"~/helpers/collection/collection\"\n\nexport const TEAMS_BACKEND_PAGE_SIZE = 10\n\nconst findParentOfColl = (\n  tree: TeamCollection[],\n  collID: string,\n  currentParent?: TeamCollection\n): TeamCollection | null => {\n  for (const coll of tree) {\n    // If the root is parent, return null\n    if (coll.id === collID) return currentParent || null\n\n    // Else run it in children\n    if (coll.children) {\n      const result = findParentOfColl(coll.children, collID, coll)\n      if (result) return result\n    }\n  }\n\n  return null\n}\n\nconst findCollInTree = (\n  tree: TeamCollection[],\n  targetID: string\n): TeamCollection | null => {\n  for (const coll of tree) {\n    if (coll.id === targetID) return coll\n\n    if (coll.children) {\n      const result = findCollInTree(coll.children, targetID)\n      if (result) return result\n    }\n  }\n\n  return null\n}\n\nconst deleteCollInTree = (tree: TeamCollection[], targetID: string) => {\n  const parent = findParentOfColl(tree, targetID)\n\n  if (parent && parent.children) {\n    parent.children = parent.children.filter((coll) => coll.id !== targetID)\n  }\n\n  const el = findCollInTree(tree, targetID)\n  if (!el) return\n\n  pull(tree, el)\n}\n\nconst updateCollInTree = (\n  tree: TeamCollection[],\n  updateColl: Partial<TeamCollection> & Pick<TeamCollection, \"id\">\n) => {\n  const el = findCollInTree(tree, updateColl.id)\n  if (!el) return\n  Object.assign(el, updateColl)\n}\n\nconst findReqInTree = (\n  tree: TeamCollection[],\n  reqID: string\n): TeamRequest | null => {\n  for (const coll of tree) {\n    if (coll.requests) {\n      const match = coll.requests.find((req) => req.id === reqID)\n      if (match) return match\n    }\n\n    if (coll.children) {\n      const match = findReqInTree(coll.children, reqID)\n      if (match) return match\n    }\n  }\n\n  return null\n}\n\nconst findCollWithReqIDInTree = (\n  tree: TeamCollection[],\n  reqID: string\n): TeamCollection | null => {\n  for (const coll of tree) {\n    if (coll.requests) {\n      if (coll.requests.find((req) => req.id === reqID)) return coll\n    }\n\n    if (coll.children) {\n      const result = findCollWithReqIDInTree(coll.children, reqID)\n      if (result) return result\n    }\n  }\n\n  return null\n}\n\nexport class TeamCollectionsService extends Service<void> {\n  public static readonly ID = \"TEAM_COLLECTIONS_SERVICE\"\n\n  //collection variables current value and secret value services\n  private secretEnvironmentService = this.bind(SecretEnvironmentService)\n  private currentEnvironmentValueService = this.bind(CurrentValueService)\n\n  private workspaceService = this.bind(WorkspaceService)\n\n  private teamID: string | null = null\n\n  public collections = ref<TeamCollection[]>([])\n  public loadingCollections = ref<string[]>([])\n  public pendingTeamCollectionPath = ref<string | null>(null)\n\n  private entityIDs: Set<string> = new Set()\n\n  private teamCollectionAdded$: Subscription | null = null\n  private teamCollectionUpdated$: Subscription | null = null\n  private teamCollectionRemoved$: Subscription | null = null\n  private teamRequestAdded$: Subscription | null = null\n  private teamRequestUpdated$: Subscription | null = null\n  private teamRequestDeleted$: Subscription | null = null\n  private teamRequestMoved$: Subscription | null = null\n  private teamCollectionMoved$: Subscription | null = null\n  private teamRequestOrderUpdated$: Subscription | null = null\n  private teamCollectionOrderUpdated$: Subscription | null = null\n  private teamRootCollectionSorted$: Subscription | null = null\n  private teamChildCollectionSorted$: Subscription | null = null\n\n  private teamCollectionAddedSub: WSubscription | null = null\n  private teamCollectionUpdatedSub: WSubscription | null = null\n  private teamCollectionRemovedSub: WSubscription | null = null\n  private teamRequestAddedSub: WSubscription | null = null\n  private teamRequestUpdatedSub: WSubscription | null = null\n  private teamRequestDeletedSub: WSubscription | null = null\n  private teamRequestMovedSub: WSubscription | null = null\n  private teamCollectionMovedSub: WSubscription | null = null\n  private teamRequestOrderUpdatedSub: WSubscription | null = null\n  private teamCollectionOrderUpdatedSub: WSubscription | null = null\n  private teamRootCollectionSortedSub: WSubscription | null = null\n  private teamChildCollectionSortedSub: WSubscription | null = null\n\n  override onServiceInit() {\n    // Watch for team change and update the collections accordingly\n    watch(\n      () => this.workspaceService.currentWorkspace,\n      (workspace) => {\n        if (workspace.value.type === \"team\" && workspace.value.teamID) {\n          this.changeTeamID(workspace.value.teamID)\n        } else {\n          this.clearCollections()\n        }\n      },\n      { immediate: true, deep: true }\n    )\n\n    // Watch for completion of loading (when all loading flags are cleared) to update inherited properties once\n    watch(\n      () => this.loadingCollections.value.length,\n      (loadingCount) => {\n        if (\n          loadingCount === 0 &&\n          this.pendingTeamCollectionPath.value &&\n          this.collections.value.length > 0\n        ) {\n          updateInheritedPropertiesForAffectedRequests(\n            this.pendingTeamCollectionPath.value,\n            \"rest\"\n          )\n          this.pendingTeamCollectionPath.value = null\n        }\n      }\n    )\n  }\n\n  changeTeamID(newTeamID: string | null) {\n    this.teamID = newTeamID\n    this.collections.value = []\n    this.entityIDs.clear()\n\n    this.loadingCollections.value = []\n\n    this.unsubscribeSubscriptions()\n\n    if (this.teamID) this.initialize()\n  }\n\n  /**\n   * Unsubscribes from the subscriptions\n   * NOTE: Once this is called, no new updates to the tree will be detected\n   */\n  unsubscribeSubscriptions() {\n    this.teamCollectionAdded$?.unsubscribe()\n    this.teamCollectionUpdated$?.unsubscribe()\n    this.teamCollectionRemoved$?.unsubscribe()\n    this.teamRequestAdded$?.unsubscribe()\n    this.teamRequestDeleted$?.unsubscribe()\n    this.teamRequestUpdated$?.unsubscribe()\n    this.teamRequestMoved$?.unsubscribe()\n    this.teamCollectionMoved$?.unsubscribe()\n    this.teamRequestOrderUpdated$?.unsubscribe()\n    this.teamCollectionOrderUpdated$?.unsubscribe()\n    this.teamRootCollectionSorted$?.unsubscribe()\n    this.teamChildCollectionSorted$?.unsubscribe()\n\n    this.teamCollectionAddedSub?.unsubscribe()\n    this.teamCollectionUpdatedSub?.unsubscribe()\n    this.teamCollectionRemovedSub?.unsubscribe()\n    this.teamRequestAddedSub?.unsubscribe()\n    this.teamRequestDeletedSub?.unsubscribe()\n    this.teamRequestUpdatedSub?.unsubscribe()\n    this.teamRequestMovedSub?.unsubscribe()\n    this.teamCollectionMovedSub?.unsubscribe()\n    this.teamRequestOrderUpdatedSub?.unsubscribe()\n    this.teamCollectionOrderUpdatedSub?.unsubscribe()\n    this.teamRootCollectionSortedSub?.unsubscribe()\n    this.teamChildCollectionSortedSub?.unsubscribe()\n  }\n\n  private async initialize() {\n    await this.loadRootCollections()\n    this.registerSubscriptions()\n  }\n\n  /**\n   * Performs addition of a collection to the tree\n   *\n   * @param {TeamCollection} collection - The collection to add to the tree\n   * @param {string | null} parentCollectionID - The parent of the new collection, pass null if this collection is in root\n   */\n  private addCollection(\n    collection: TeamCollection,\n    parentCollectionID: string | null\n  ) {\n    // Check if we have it already in the entity tree, if so, we don't need it again\n    if (this.entityIDs.has(`collection-${collection.id}`)) return\n\n    const tree = this.collections.value\n\n    if (!parentCollectionID) {\n      tree.push(collection)\n    } else {\n      const parentCollection = findCollInTree(tree, parentCollectionID)\n\n      if (!parentCollection) return\n\n      // Prevent adding child collections to a collection that has not been expanded yet incoming from GQL subscription, during import, etc\n      // Hence, add entries to the pre-existing list without setting 'children' if it is `null'\n      if (parentCollection.children !== null) {\n        parentCollection.children.push(collection)\n      }\n    }\n\n    // Add to entity ids set\n    this.entityIDs.add(`collection-${collection.id}`)\n\n    this.collections.value = tree\n  }\n\n  private clearCollections() {\n    this.collections.value = []\n    this.entityIDs.clear()\n    this.loadingCollections.value = []\n    this.unsubscribeSubscriptions()\n    this.teamID = null\n  }\n\n  /**\n   * Loads the root collections of the current team\n   * @param replace Whether to replace the existing collections or append to them\n   * We might want to replace when we are reloading the collections like when sorting the whole root collections\n   */\n  private async loadRootCollections(replace = false) {\n    if (this.teamID === null) throw new Error(\"Team ID is null\")\n\n    this.loadingCollections.value.push(\"root\")\n\n    const totalCollections: TeamCollection[] = []\n\n    while (true) {\n      const result = await runGQLQuery({\n        query: RootCollectionsOfTeamDocument,\n        variables: {\n          teamID: this.teamID,\n          cursor:\n            totalCollections.length > 0\n              ? totalCollections[totalCollections.length - 1].id\n              : undefined,\n        },\n      })\n\n      if (E.isLeft(result)) {\n        this.loadingCollections.value = this.loadingCollections.value.filter(\n          (x) => x !== \"root\"\n        )\n\n        throw new Error(\n          `Error fetching root collections: ${result.left?.error}`\n        )\n      }\n\n      if (replace) {\n        this.collections.value = []\n        this.entityIDs.clear()\n\n        totalCollections.push(\n          ...result.right.rootCollectionsOfTeam.map(\n            (x: any) =>\n              <TeamCollection>{\n                ...x,\n                children: null,\n                requests: null,\n              }\n          )\n        )\n      } else {\n        totalCollections.push(\n          ...result.right.rootCollectionsOfTeam.map(\n            (x: any) =>\n              <TeamCollection>{\n                ...x,\n                children: null,\n                requests: null,\n              }\n          )\n        )\n      }\n\n      if (result.right.rootCollectionsOfTeam.length !== TEAMS_BACKEND_PAGE_SIZE)\n        break\n    }\n\n    this.loadingCollections.value = this.loadingCollections.value.filter(\n      (x) => x !== \"root\"\n    )\n\n    // Add all the collections to the entity ids list\n    totalCollections.forEach((coll) =>\n      this.entityIDs.add(`collection-${coll.id}`)\n    )\n\n    this.collections.value.push(...totalCollections)\n  }\n\n  /**\n   * Updates an existing collection in tree\n   *\n   * @param {Partial<TeamCollection> & Pick<TeamCollection, \"id\">} collectionUpdate - Object defining the fields that need to be updated (ID is required to find the target)\n   */\n  private updateCollection(\n    collectionUpdate: Partial<TeamCollection> & Pick<TeamCollection, \"id\">\n  ) {\n    const tree = this.collections.value\n\n    updateCollInTree(tree, collectionUpdate)\n\n    this.collections.value = tree\n  }\n\n  /**\n   * Removes a collection from the tree\n   *\n   * @param {string} collectionID - ID of the collection to remove\n   */\n  private removeCollection(collectionID: string) {\n    const tree = this.collections.value\n\n    deleteCollInTree(tree, collectionID)\n\n    this.entityIDs.delete(`collection-${collectionID}`)\n\n    this.collections.value = tree\n  }\n\n  /**\n   * Adds a request to the tree\n   *\n   * @param {TeamRequest} request - The request to add to the tree\n   */\n  private addRequest(request: TeamRequest) {\n    // Check if we have it already in the entity tree, if so, we don't need it again\n    if (this.entityIDs.has(`request-${request.id}`)) return\n\n    const tree = this.collections.value\n\n    // Check if we have the collection (if not, then not loaded?)\n    const coll = findCollInTree(tree, request.collectionID)\n    if (!coll) return // Ignore add request\n\n    // Collection is not expanded\n    if (!coll.requests) return\n\n    // Collection is expanded hence append request\n    coll.requests.push(request)\n\n    // Update the Entity IDs list\n    this.entityIDs.add(`request-${request.id}`)\n\n    this.collections.value = tree\n  }\n\n  /**\n   * Updates the request in tree\n   *\n   * @param {Partial<TeamRequest> & Pick<TeamRequest, 'id'>} requestUpdate - Object defining all the fields to update in request (ID of the request is required)\n   */\n  private updateRequest(\n    requestUpdate: Partial<TeamRequest> & Pick<TeamRequest, \"id\">\n  ) {\n    const tree = this.collections.value\n\n    //",
            "cost": 0.16779500000000003
        },
        "hoppscotch__hoppscotch.main/packages/hoppscotch-common/src/services/workspace.service.ts": {
            "output": "import { tryOnScopeDispose, useIntervalFn } from \"@vueuse/core\"\nimport { Service } from \"dioc\"\nimport { computed, reactive, ref, watch, readonly } from \"vue\"\nimport { useStreamStatic } from \"~/composables/stream\"\nimport TeamListAdapter from \"~/helpers/teams/TeamListAdapter\"\nimport { platform } from \"~/platform\"\nimport { min } from \"lodash-es\"\nimport { TeamAccessRole } from \"~/helpers/backend/graphql\"\nimport { TeamCollectionsService } from \"./team-collection.service\"\nimport { DocumentationService } from \"./documentation.service\"\n\n/**\n * Defines a workspace and its information\n */\n\nexport type PersonalWorkspace = {\n  type: \"personal\"\n}\n\nexport type TeamWorkspace = {\n  type: \"team\"\n  teamID: string\n  teamName: string\n  role: TeamAccessRole | null | undefined\n}\n\nexport type Workspace = PersonalWorkspace | TeamWorkspace\n\nexport type WorkspaceServiceEvent = {\n  type: \"managed-team-list-adapter-polled\"\n}\n\n/**\n * This services manages workspace related data and actions in Hoppscotch.\n */\nexport class WorkspaceService extends Service<WorkspaceServiceEvent> {\n  public static readonly ID = \"WORKSPACE_SERVICE\"\n\n  private _currentWorkspace = ref<Workspace>({ type: \"personal\" })\n\n  /**\n   * A readonly reference to the currently selected workspace\n   */\n  public currentWorkspace = readonly(this._currentWorkspace)\n\n  private teamListAdapterLocks = reactive(new Map<number, number | null>())\n  private teamListAdapterLockTicker = 0 // Used to generate unique lock IDs\n  private managedTeamListAdapter = new TeamListAdapter(true, false)\n\n  private teamCollectionService = this.bind(TeamCollectionsService)\n  private documentationService = this.bind(DocumentationService)\n\n  private currentUser = useStreamStatic(\n    platform.auth.getCurrentUserStream(),\n    platform.auth.getCurrentUser(),\n    () => {\n      /* noop */\n    }\n  )[0]\n\n  private readonly pollingTime = computed(\n    () =>\n      min(Array.from(this.teamListAdapterLocks.values()).filter((x) => !!x)) ??\n      -1\n  )\n\n  override onServiceInit() {\n    // Dispose the managed team list adapter when the user logs out\n    // and initialize it when the user logs in\n    watch(\n      this.currentUser,\n      (user) => {\n        if (!user && this.managedTeamListAdapter.isInitialized) {\n          this.managedTeamListAdapter.dispose()\n        }\n\n        if (user && !this.managedTeamListAdapter.isInitialized) {\n          this.managedTeamListAdapter.initialize()\n        }\n      },\n      { immediate: true }\n    )\n\n    // Poll the managed team list adapter if the polling time is defined\n    const { pause: pauseListPoll, resume: resumeListPoll } = useIntervalFn(\n      () => {\n        if (this.managedTeamListAdapter.isInitialized) {\n          this.managedTeamListAdapter.fetchList()\n\n          this.emit({ type: \"managed-team-list-adapter-polled\" })\n        }\n      },\n      this.pollingTime,\n      { immediate: true }\n    )\n\n    // Pause and resume the polling when the polling time changes\n    watch(\n      this.pollingTime,\n      (pollingTime) => {\n        if (pollingTime === -1) {\n          pauseListPoll()\n        } else {\n          resumeListPoll()\n        }\n      },\n      { immediate: true }\n    )\n\n    // Watch for workspace changes and update team collection service and documentation service accordingly\n    this.setupWorkspaceSync()\n  }\n\n  /**\n   * Sets up synchronization between team collection service and documentation service.\n   * Ensures that team collections and published docs stay updated whenever\n   * the workspace or user changes.\n   *\n   * Fixes a bug where the initial fetch failed on cloud instances because\n   * authorization was null during user login. Now we wait for authentication\n   * to be ready before fetching team collections and published docs.\n   */\n  private setupWorkspaceSync() {\n    watch(\n      [this._currentWorkspace, this.currentUser],\n      async ([newWorkspace, user], [oldWorkspace, oldUser]) => {\n        // Skip if workspace and user haven't changed\n        if (\n          this.areWorkspacesEqual(newWorkspace, oldWorkspace) &&\n          user?.uid === oldUser?.uid\n        ) {\n          return\n        }\n\n        try {\n          // Ensure authentication is ready before fetching docs\n          if (user) {\n            await platform.auth.waitProbableLoginToConfirm()\n          }\n\n          if (newWorkspace?.type === \"team\" && newWorkspace.teamID) {\n            this.teamCollectionService.changeTeamID(newWorkspace.teamID)\n\n            if (user) {\n              await this.documentationService.fetchTeamPublishedDocs(\n                newWorkspace.teamID\n              )\n            }\n          } else {\n            this.teamCollectionService.clearCollections()\n\n            if (user) {\n              await this.documentationService.fetchUserPublishedDocs()\n            }\n          }\n        } catch (error) {\n          console.error(\"Failed to sync workspace data:\", error)\n        }\n      },\n      { immediate: true }\n    )\n  }\n\n  /**\n   * Checks if two workspaces are effectively equal to avoid unnecessary updates\n   *\n   * Note: Vue's watch API provides `undefined` as `oldValue` on the first callback\n   * invocation when using `{ immediate: true }`, since there is no previous value yet.\n   * This is why `oldWorkspace` has an optional type, while `newWorkspace` is always defined.\n   */\n  private areWorkspacesEqual(\n    newWorkspace: Workspace,\n    oldWorkspace?: Workspace\n  ): boolean {\n    if (!newWorkspace || !oldWorkspace) return false\n\n    // Both are personal workspaces\n    if (newWorkspace.type === \"personal\" && oldWorkspace.type === \"personal\")\n      return true\n\n    // Team workspaces are equal only if they share the same team ID\n    return (\n      newWorkspace.type === \"team\" &&\n      oldWorkspace.type === \"team\" &&\n      newWorkspace.teamID === oldWorkspace.teamID\n    )\n  }\n\n  // TODO: Update this function, its existence is pretty weird\n  /**\n   * Updates the name of the current workspace if it is a team workspace.\n   * @param newTeamName The new name of the team\n   */\n  public updateWorkspaceTeamName(newTeamName: string) {\n    if (this._currentWorkspace.value.type === \"team\") {\n      this._currentWorkspace.value = {\n        ...this._currentWorkspace.value,\n        teamName: newTeamName,\n      }\n    }\n  }\n\n  /**\n   * Changes the current workspace to the given workspace.\n   * @param workspace The new workspace\n   */\n  public changeWorkspace(workspace: Workspace) {\n    this._currentWorkspace.value = workspace\n  }\n\n  /**\n   * Acquires a team list adapter that is managed by the workspace service.\n   * The team list adapter is associated with a Vue Scope and will be disposed\n   * when the scope is disposed.\n   * @param pollDuration The duration between polls in milliseconds. If null, the team list adapter will not poll.\n   */\n  public acquireTeamListAdapter(pollDuration: number | null) {\n    const lockID = this.teamListAdapterLockTicker++\n\n    this.teamListAdapterLocks.set(lockID, pollDuration)\n\n    tryOnScopeDispose(() => {\n      this.teamListAdapterLocks.delete(lockID)\n    })\n\n    return this.managedTeamListAdapter\n  }\n}",
            "output_extracted": "import { tryOnScopeDispose, useIntervalFn } from \"@vueuse/core\"\nimport { Service } from \"dioc\"\nimport { computed, reactive, ref, watch, readonly } from \"vue\"\nimport { useStreamStatic } from \"~/composables/stream\"\nimport TeamListAdapter from \"~/helpers/teams/TeamListAdapter\"\nimport { platform } from \"~/platform\"\nimport { min } from \"lodash-es\"\nimport { TeamAccessRole } from \"~/helpers/backend/graphql\"\nimport { TeamCollectionsService } from \"./team-collection.service\"\nimport { DocumentationService } from \"./documentation.service\"\n\n/**\n * Defines a workspace and its information\n */\n\nexport type PersonalWorkspace = {\n  type: \"personal\"\n}\n\nexport type TeamWorkspace = {\n  type: \"team\"\n  teamID: string\n  teamName: string\n  role: TeamAccessRole | null | undefined\n}\n\nexport type Workspace = PersonalWorkspace | TeamWorkspace\n\nexport type WorkspaceServiceEvent = {\n  type: \"managed-team-list-adapter-polled\"\n}\n\n/**\n * This services manages workspace related data and actions in Hoppscotch.\n */\nexport class WorkspaceService extends Service<WorkspaceServiceEvent> {\n  public static readonly ID = \"WORKSPACE_SERVICE\"\n\n  private _currentWorkspace = ref<Workspace>({ type: \"personal\" })\n\n  /**\n   * A readonly reference to the currently selected workspace\n   */\n  public currentWorkspace = readonly(this._currentWorkspace)\n\n  private teamListAdapterLocks = reactive(new Map<number, number | null>())\n  private teamListAdapterLockTicker = 0 // Used to generate unique lock IDs\n  private managedTeamListAdapter = new TeamListAdapter(true, false)\n\n  private teamCollectionService = this.bind(TeamCollectionsService)\n  private documentationService = this.bind(DocumentationService)\n\n  private currentUser = useStreamStatic(\n    platform.auth.getCurrentUserStream(),\n    platform.auth.getCurrentUser(),\n    () => {\n      /* noop */\n    }\n  )[0]\n\n  private readonly pollingTime = computed(\n    () =>\n      min(Array.from(this.teamListAdapterLocks.values()).filter((x) => !!x)) ??\n      -1\n  )\n\n  override onServiceInit() {\n    // Dispose the managed team list adapter when the user logs out\n    // and initialize it when the user logs in\n    watch(\n      this.currentUser,\n      (user) => {\n        if (!user && this.managedTeamListAdapter.isInitialized) {\n          this.managedTeamListAdapter.dispose()\n        }\n\n        if (user && !this.managedTeamListAdapter.isInitialized) {\n          this.managedTeamListAdapter.initialize()\n        }\n      },\n      { immediate: true }\n    )\n\n    // Poll the managed team list adapter if the polling time is defined\n    const { pause: pauseListPoll, resume: resumeListPoll } = useIntervalFn(\n      () => {\n        if (this.managedTeamListAdapter.isInitialized) {\n          this.managedTeamListAdapter.fetchList()\n\n          this.emit({ type: \"managed-team-list-adapter-polled\" })\n        }\n      },\n      this.pollingTime,\n      { immediate: true }\n    )\n\n    // Pause and resume the polling when the polling time changes\n    watch(\n      this.pollingTime,\n      (pollingTime) => {\n        if (pollingTime === -1) {\n          pauseListPoll()\n        } else {\n          resumeListPoll()\n        }\n      },\n      { immediate: true }\n    )\n\n    // Watch for workspace changes and update team collection service and documentation service accordingly\n    this.setupWorkspaceSync()\n  }\n\n  /**\n   * Sets up synchronization between team collection service and documentation service.\n   * Ensures that team collections and published docs stay updated whenever\n   * the workspace or user changes.\n   *\n   * Fixes a bug where the initial fetch failed on cloud instances because\n   * authorization was null during user login. Now we wait for authentication\n   * to be ready before fetching team collections and published docs.\n   */\n  private setupWorkspaceSync() {\n    watch(\n      [this._currentWorkspace, this.currentUser],\n      async ([newWorkspace, user], [oldWorkspace, oldUser]) => {\n        // Skip if workspace and user haven't changed\n        if (\n          this.areWorkspacesEqual(newWorkspace, oldWorkspace) &&\n          user?.uid === oldUser?.uid\n        ) {\n          return\n        }\n\n        try {\n          // Ensure authentication is ready before fetching docs\n          if (user) {\n            await platform.auth.waitProbableLoginToConfirm()\n          }\n\n          if (newWorkspace?.type === \"team\" && newWorkspace.teamID) {\n            this.teamCollectionService.changeTeamID(newWorkspace.teamID)\n\n            if (user) {\n              await this.documentationService.fetchTeamPublishedDocs(\n                newWorkspace.teamID\n              )\n            }\n          } else {\n            this.teamCollectionService.clearCollections()\n\n            if (user) {\n              await this.documentationService.fetchUserPublishedDocs()\n            }\n          }\n        } catch (error) {\n          console.error(\"Failed to sync workspace data:\", error)\n        }\n      },\n      { immediate: true }\n    )\n  }\n\n  /**\n   * Checks if two workspaces are effectively equal to avoid unnecessary updates\n   *\n   * Note: Vue's watch API provides `undefined` as `oldValue` on the first callback\n   * invocation when using `{ immediate: true }`, since there is no previous value yet.\n   * This is why `oldWorkspace` has an optional type, while `newWorkspace` is always defined.\n   */\n  private areWorkspacesEqual(\n    newWorkspace: Workspace,\n    oldWorkspace?: Workspace\n  ): boolean {\n    if (!newWorkspace || !oldWorkspace) return false\n\n    // Both are personal workspaces\n    if (newWorkspace.type === \"personal\" && oldWorkspace.type === \"personal\")\n      return true\n\n    // Team workspaces are equal only if they share the same team ID\n    return (\n      newWorkspace.type === \"team\" &&\n      oldWorkspace.type === \"team\" &&\n      newWorkspace.teamID === oldWorkspace.teamID\n    )\n  }\n\n  // TODO: Update this function, its existence is pretty weird\n  /**\n   * Updates the name of the current workspace if it is a team workspace.\n   * @param newTeamName The new name of the team\n   */\n  public updateWorkspaceTeamName(newTeamName: string) {\n    if (this._currentWorkspace.value.type === \"team\") {\n      this._currentWorkspace.value = {\n        ...this._currentWorkspace.value,\n        teamName: newTeamName,\n      }\n    }\n  }\n\n  /**\n   * Changes the current workspace to the given workspace.\n   * @param workspace The new workspace\n   */\n  public changeWorkspace(workspace: Workspace) {\n    this._currentWorkspace.value = workspace\n  }\n\n  /**\n   * Acquires a team list adapter that is managed by the workspace service.\n   * The team list adapter is associated with a Vue Scope and will be disposed\n   * when the scope is disposed.\n   * @param pollDuration The duration between polls in milliseconds. If null, the team list adapter will not poll.\n   */\n  public acquireTeamListAdapter(pollDuration: number | null) {\n    const lockID = this.teamListAdapterLockTicker++\n\n    this.teamListAdapterLocks.set(lockID, pollDuration)\n\n    tryOnScopeDispose(() => {\n      this.teamListAdapterLocks.delete(lockID)\n    })\n\n    return this.managedTeamListAdapter\n  }\n}",
            "cost": 0.06744
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "hoppscotch__hoppscotch.main.5533",
        "repo": "hoppscotch/hoppscotch",
        "base_commit": "98f07f8a4c002926e24676af45067d911b589b58",
        "head_commit": "f5cc773f21e6a71da741f825dae7079416d9fe2b",
        "title": "fix: team collection not loading on route change",
        "merged_at": "2025-11-12T09:13:35Z",
        "html_url": "https://github.com/hoppscotch/hoppscotch/pull/5533",
        "test_files": [
            "packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts"
        ],
        "code_files": [
            "packages/hoppscotch-common/src/services/team-collection.service.ts",
            "packages/hoppscotch-common/src/services/workspace.service.ts"
        ],
        "total_changes": 337,
        "num_files": 3,
        "pull_number": 5533,
        "patch": "diff --git a/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts b/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts\nindex 6720df179e..7d049a39f2 100644\n--- a/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts\n+++ b/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts\n@@ -25,6 +25,18 @@ vi.mock(\"~/helpers/teams/TeamListAdapter\", () => ({\n   },\n }))\n \n+// Mock TeamCollectionsService to prevent i18n dependency issues\n+vi.mock(\"../team-collection.service\", () => ({\n+  TeamCollectionsService: class MockTeamCollectionsService {\n+    static readonly ID = \"TEAM_COLLECTIONS_SERVICE\"\n+\n+    changeTeamID = vi.fn()\n+    clearCollections = vi.fn()\n+\n+    onServiceInit = vi.fn()\n+  },\n+}))\n+\n describe(\"WorkspaceService\", () => {\n   const platformMock = {\n     auth: {\n@@ -239,4 +251,226 @@ describe(\"WorkspaceService\", () => {\n       expect(listAdapterMock.fetchList).not.toHaveBeenCalled()\n     })\n   })\n+\n+  describe(\"Team Collection Service Synchronization\", () => {\n+    it(\"should call changeTeamID when workspace changes to a team workspace\", async () => {\n+      const container = new TestContainer()\n+      const service = container.bind(WorkspaceService)\n+\n+      // Access the team collection service mock\n+      const teamCollectionServiceMock = (service as any).teamCollectionService\n+\n+      // Change to team workspace\n+      service.changeWorkspace({\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Test Team\",\n+        role: null,\n+      })\n+\n+      await nextTick()\n+\n+      expect(teamCollectionServiceMock.changeTeamID).toHaveBeenCalledWith(\n+        \"team-123\"\n+      )\n+    })\n+\n+    it(\"should call clearCollections when workspace changes to personal workspace\", async () => {\n+      const container = new TestContainer()\n+      const service = container.bind(WorkspaceService)\n+\n+      // Start with a team workspace\n+      service.changeWorkspace({\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Test Team\",\n+        role: null,\n+      })\n+\n+      await nextTick()\n+\n+      const teamCollectionServiceMock = (service as any).teamCollectionService\n+      teamCollectionServiceMock.clearCollections.mockClear()\n+\n+      // Change to personal workspace\n+      service.changeWorkspace({\n+        type: \"personal\",\n+      })\n+\n+      await nextTick()\n+\n+      expect(teamCollectionServiceMock.clearCollections).toHaveBeenCalled()\n+    })\n+\n+    it(\"should call clearCollections when workspace changes to team workspace without teamID\", async () => {\n+      const container = new TestContainer()\n+      const service = container.bind(WorkspaceService)\n+\n+      const teamCollectionServiceMock = (service as any).teamCollectionService\n+\n+      // Change to team workspace without teamID\n+      service.changeWorkspace({\n+        type: \"team\",\n+        teamID: \"\",\n+        teamName: \"Test Team\",\n+        role: null,\n+      })\n+\n+      await nextTick()\n+\n+      expect(teamCollectionServiceMock.clearCollections).toHaveBeenCalled()\n+    })\n+\n+    it(\"should not sync when workspaces are effectively the same\", async () => {\n+      const container = new TestContainer()\n+      const service = container.bind(WorkspaceService)\n+\n+      // Start with a team workspace\n+      service.changeWorkspace({\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Test Team\",\n+        role: null,\n+      })\n+\n+      await nextTick()\n+\n+      const teamCollectionServiceMock = (service as any).teamCollectionService\n+      teamCollectionServiceMock.changeTeamID.mockClear()\n+\n+      // Change to same team workspace (different name, same ID)\n+      service.changeWorkspace({\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Updated Team Name\",\n+        role: null,\n+      })\n+\n+      await nextTick()\n+\n+      // Should not call changeTeamID again since it's the same team\n+      expect(teamCollectionServiceMock.changeTeamID).not.toHaveBeenCalled()\n+    })\n+\n+    it(\"should handle errors during team collection service sync gracefully\", async () => {\n+      const container = new TestContainer()\n+      const service = container.bind(WorkspaceService)\n+\n+      const teamCollectionServiceMock = (service as any).teamCollectionService\n+      teamCollectionServiceMock.changeTeamID.mockImplementation(() => {\n+        throw new Error(\"Sync failed\")\n+      })\n+\n+      const consoleSpy = vi.spyOn(console, \"error\").mockImplementation(() => {})\n+\n+      // Change to team workspace (should not throw)\n+      expect(() => {\n+        service.changeWorkspace({\n+          type: \"team\",\n+          teamID: \"team-123\",\n+          teamName: \"Test Team\",\n+          role: null,\n+        })\n+      }).not.toThrow()\n+\n+      await nextTick()\n+\n+      expect(consoleSpy).toHaveBeenCalledWith(\n+        \"Failed to sync team collections:\",\n+        expect.any(Error)\n+      )\n+\n+      consoleSpy.mockRestore()\n+    })\n+  })\n+\n+  describe(\"areWorkspacesEqual\", () => {\n+    let service: WorkspaceService\n+\n+    beforeEach(() => {\n+      const container = new TestContainer()\n+      service = container.bind(WorkspaceService)\n+    })\n+\n+    it(\"should return false when newWorkspace is undefined\", () => {\n+      const result = (service as any).areWorkspacesEqual(undefined, {\n+        type: \"personal\",\n+      })\n+      expect(result).toBe(false)\n+    })\n+\n+    it(\"should return false when oldWorkspace is undefined\", () => {\n+      const result = (service as any).areWorkspacesEqual(\n+        { type: \"personal\" },\n+        undefined\n+      )\n+      expect(result).toBe(false)\n+    })\n+\n+    it(\"should return true when both workspaces are personal\", () => {\n+      const result = (service as any).areWorkspacesEqual(\n+        { type: \"personal\" },\n+        { type: \"personal\" }\n+      )\n+      expect(result).toBe(true)\n+    })\n+\n+    it(\"should return true when both workspaces are team workspaces with same teamID\", () => {\n+      const workspace1 = {\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Team A\",\n+        role: null,\n+      }\n+      const workspace2 = {\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Team A Updated\",\n+        role: null,\n+      }\n+\n+      const result = (service as any).areWorkspacesEqual(workspace1, workspace2)\n+      expect(result).toBe(true)\n+    })\n+\n+    it(\"should return false when team workspaces have different teamIDs\", () => {\n+      const workspace1 = {\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Team A\",\n+        role: null,\n+      }\n+      const workspace2 = {\n+        type: \"team\",\n+        teamID: \"team-456\",\n+        teamName: \"Team B\",\n+        role: null,\n+      }\n+\n+      const result = (service as any).areWorkspacesEqual(workspace1, workspace2)\n+      expect(result).toBe(false)\n+    })\n+\n+    it(\"should return false when one is personal and other is team workspace\", () => {\n+      const personalWorkspace = { type: \"personal\" }\n+      const teamWorkspace = {\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Team A\",\n+        role: null,\n+      }\n+\n+      const result1 = (service as any).areWorkspacesEqual(\n+        personalWorkspace,\n+        teamWorkspace\n+      )\n+      const result2 = (service as any).areWorkspacesEqual(\n+        teamWorkspace,\n+        personalWorkspace\n+      )\n+\n+      expect(result1).toBe(false)\n+      expect(result2).toBe(false)\n+    })\n+  })\n })\ndiff --git a/packages/hoppscotch-common/src/services/team-collection.service.ts b/packages/hoppscotch-common/src/services/team-collection.service.ts\nindex 0fcca76f5e..3ead4e43ec 100644\n--- a/packages/hoppscotch-common/src/services/team-collection.service.ts\n+++ b/packages/hoppscotch-common/src/services/team-collection.service.ts\n@@ -31,7 +31,6 @@ import { TeamCollection } from \"~/helpers/teams/TeamCollection\"\n import { TeamRequest } from \"~/helpers/teams/TeamRequest\"\n import { runGQLQuery, runGQLSubscription } from \"~/helpers/backend/GQLClient\"\n import { HoppInheritedProperty } from \"~/helpers/types/HoppInheritedProperties\"\n-import { WorkspaceService } from \"./workspace.service\"\n import { ref, watch } from \"vue\"\n import { Service } from \"dioc\"\n import { updateInheritedPropertiesForAffectedRequests } from \"~/helpers/collection/collection\"\n@@ -139,8 +138,6 @@ export class TeamCollectionsService extends Service<void> {\n   private secretEnvironmentService = this.bind(SecretEnvironmentService)\n   private currentEnvironmentValueService = this.bind(CurrentValueService)\n \n-  private workspaceService = this.bind(WorkspaceService)\n-\n   private teamID: string | null = null\n \n   public collections = ref<TeamCollection[]>([])\n@@ -176,20 +173,13 @@ export class TeamCollectionsService extends Service<void> {\n   private teamChildCollectionSortedSub: WSubscription | null = null\n \n   override onServiceInit() {\n-    // Watch for team change and update the collections accordingly\n-    watch(\n-      () => this.workspaceService.currentWorkspace,\n-      (workspace) => {\n-        if (workspace.value.type === \"team\" && workspace.value.teamID) {\n-          this.changeTeamID(workspace.value.teamID)\n-        } else {\n-          this.clearCollections()\n-        }\n-      },\n-      { immediate: true, deep: true }\n-    )\n+    this.collectionLoadingWatcher()\n+  }\n \n-    // Watch for completion of loading (when all loading flags are cleared) to update inherited properties once\n+  /**\n+   * Watches for loading collections and updates inherited properties once loading is done\n+   */\n+  private collectionLoadingWatcher() {\n     watch(\n       () => this.loadingCollections.value.length,\n       (loadingCount) => {\n@@ -208,7 +198,11 @@ export class TeamCollectionsService extends Service<void> {\n     )\n   }\n \n-  changeTeamID(newTeamID: string | null) {\n+  /**\n+   * Change the current team ID and resets the collections\n+   * @param newTeamID The new team ID to switch to\n+   */\n+  public changeTeamID(newTeamID: string | null) {\n     this.teamID = newTeamID\n     this.collections.value = []\n     this.entityIDs.clear()\n@@ -220,6 +214,17 @@ export class TeamCollectionsService extends Service<void> {\n     if (this.teamID) this.initialize()\n   }\n \n+  /**\n+   * Clears all collections and resets the service state\n+   */\n+  public clearCollections() {\n+    this.collections.value = []\n+    this.entityIDs.clear()\n+    this.loadingCollections.value = []\n+    this.unsubscribeSubscriptions()\n+    this.teamID = null\n+  }\n+\n   /**\n    * Unsubscribes from the subscriptions\n    * NOTE: Once this is called, no new updates to the tree will be detected\n@@ -292,14 +297,6 @@ export class TeamCollectionsService extends Service<void> {\n     this.collections.value = tree\n   }\n \n-  private clearCollections() {\n-    this.collections.value = []\n-    this.entityIDs.clear()\n-    this.loadingCollections.value = []\n-    this.unsubscribeSubscriptions()\n-    this.teamID = null\n-  }\n-\n   /**\n    * Loads the root collections of the current team\n    * @param replace Whether to replace the existing collections or append to them\ndiff --git a/packages/hoppscotch-common/src/services/workspace.service.ts b/packages/hoppscotch-common/src/services/workspace.service.ts\nindex bcf67c14a8..7bd3dbcb85 100644\n--- a/packages/hoppscotch-common/src/services/workspace.service.ts\n+++ b/packages/hoppscotch-common/src/services/workspace.service.ts\n@@ -6,6 +6,7 @@ import TeamListAdapter from \"~/helpers/teams/TeamListAdapter\"\n import { platform } from \"~/platform\"\n import { min } from \"lodash-es\"\n import { TeamAccessRole } from \"~/helpers/backend/graphql\"\n+import { TeamCollectionsService } from \"./team-collection.service\"\n \n /**\n  * Defines a workspace and its information\n@@ -45,6 +46,8 @@ export class WorkspaceService extends Service<WorkspaceServiceEvent> {\n   private teamListAdapterLockTicker = 0 // Used to generate unique lock IDs\n   private managedTeamListAdapter = new TeamListAdapter(true, false)\n \n+  private teamCollectionService = this.bind(TeamCollectionsService)\n+\n   private currentUser = useStreamStatic(\n     platform.auth.getCurrentUserStream(),\n     platform.auth.getCurrentUser(),\n@@ -101,6 +104,59 @@ export class WorkspaceService extends Service<WorkspaceServiceEvent> {\n       },\n       { immediate: true }\n     )\n+\n+    // Watch for workspace changes and update team collection service accordingly\n+    this.setupTeamCollectionServiceSync()\n+  }\n+\n+  /**\n+   * Sets up synchronization with team collection service\n+   * This ensures team collections are updated when workspace changes\n+   */\n+  private setupTeamCollectionServiceSync() {\n+    watch(\n+      this._currentWorkspace,\n+      (newWorkspace, oldWorkspace) => {\n+        // Skip update if workspaces are effectively the same\n+        if (this.areWorkspacesEqual(newWorkspace, oldWorkspace)) return\n+\n+        try {\n+          if (newWorkspace.type === \"team\" && newWorkspace.teamID) {\n+            this.teamCollectionService.changeTeamID(newWorkspace.teamID)\n+          } else {\n+            this.teamCollectionService.clearCollections()\n+          }\n+        } catch (error) {\n+          console.error(\"Failed to sync team collections:\", error)\n+        }\n+      },\n+      { immediate: true }\n+    )\n+  }\n+\n+  /**\n+   * Checks if two workspaces are effectively equal to avoid unnecessary updates\n+   *\n+   * Note: Vue's watch API provides `undefined` as `oldValue` on the first callback\n+   * invocation when using `{ immediate: true }`, since there is no previous value yet.\n+   * This is why `oldWorkspace` has an optional type, while `newWorkspace` is always defined.\n+   */\n+  private areWorkspacesEqual(\n+    newWorkspace: Workspace,\n+    oldWorkspace?: Workspace\n+  ): boolean {\n+    if (!newWorkspace || !oldWorkspace) return false\n+\n+    // Both are personal workspaces\n+    if (newWorkspace.type === \"personal\" && oldWorkspace.type === \"personal\")\n+      return true\n+\n+    // Team workspaces are equal only if they share the same team ID\n+    return (\n+      newWorkspace.type === \"team\" &&\n+      oldWorkspace.type === \"team\" &&\n+      newWorkspace.teamID === oldWorkspace.teamID\n+    )\n   }\n \n   // TODO: Update this function, its existence is pretty weird\n",
        "pr_mirror": "hoppscotch__hoppscotch.main"
    }
}