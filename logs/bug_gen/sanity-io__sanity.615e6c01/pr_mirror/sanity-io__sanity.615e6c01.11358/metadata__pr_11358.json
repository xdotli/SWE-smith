{
    "cost": 0.5816300000000001,
    "rewrites": {
        "sanity-io__sanity.615e6c01/dev/test-studio/schema/debug/objectsDebug.ts": {
            "output": "import {\n  defineArrayMember,\n  defineField,\n  defineType,\n  type InputProps,\n  type PortableTextInputProps,\n} from 'sanity'\n\nimport {SideBySideObjectInput, SideBySideObjectItem} from './components/SideBySideObjectInput'\nimport {PageBlockAnchor} from './PageBlockAnchor'\n\nconst animal = defineField({\n  type: 'object',\n  name: 'animal',\n  title: 'Animal',\n  fields: [\n    {\n      name: 'name',\n      type: 'string',\n      title: 'Animal name',\n    },\n    {\n      type: 'array',\n      name: 'description',\n      title: 'Description',\n      of: [\n        {type: 'block'},\n        {\n          type: 'object',\n          name: 'info',\n          fields: [\n            {\n              type: 'array',\n              name: 'item',\n              title: 'Item',\n              of: [\n                {\n                  type: 'object',\n                  name: 'property',\n                  title: 'Property',\n                  fields: [\n                    {\n                      type: 'string',\n                      name: 'title',\n                      title: 'Title',\n                      validation: (Rule) => Rule.required(),\n                    },\n                    {\n                      type: 'string',\n                      name: 'value',\n                      title: 'Value',\n                    },\n                    {\n                      type: 'array',\n                      name: 'description_two',\n                      title: 'Description Two',\n                      components: {\n                        input: (props: any) => {\n                          return props.renderDefault({...props, initialFullscreen: true})\n                        },\n                      },\n                      of: [\n                        {type: 'block'},\n                        {\n                          type: 'object',\n                          name: 'info_two',\n                          title: 'Info Two',\n                          fields: [\n                            {\n                              type: 'array',\n                              name: 'item_two',\n                              title: 'Item Two',\n                              of: [\n                                {\n                                  type: 'object',\n                                  name: 'property_two',\n                                  title: 'Property Two',\n                                  fields: [\n                                    {\n                                      type: 'string',\n                                      name: 'title_two',\n                                      title: 'Title Two',\n                                      validation: (Rule) => Rule.required(),\n                                    },\n                                    {\n                                      type: 'string',\n                                      name: 'value_two',\n                                      title: 'Value Two',\n                                    },\n                                    {\n                                      type: 'array',\n                                      name: 'description_three',\n                                      title: 'Description Three',\n                                      of: [\n                                        {type: 'block'},\n                                        {\n                                          type: 'object',\n                                          name: 'info_three',\n                                          title: 'Info Three',\n                                          fields: [\n                                            {\n                                              type: 'string',\n                                              name: 'title_three',\n                                              title: 'Title Three',\n                                            },\n                                          ],\n                                          components: {\n                                            input: (inputProps: any) => {\n                                              return inputProps.renderDefault(inputProps)\n                                            },\n                                          },\n                                        },\n                                      ],\n                                    },\n                                    {\n                                      type: 'internationalizedArrayString',\n                                      name: 'internationalizedArrayString',\n                                      title: 'Internationalized array string',\n                                    },\n\n                                    {\n                                      type: 'image',\n                                      name: 'imageChild',\n                                      title: 'Image',\n                                    },\n                                  ],\n                                },\n                              ],\n                            },\n                          ],\n                        },\n                        {\n                          type: 'image',\n                          name: 'image_two',\n                          title: 'Image',\n                        },\n                      ],\n                    },\n                    defineField({\n                      name: 'content',\n                      type: 'array',\n                      of: [\n                        defineArrayMember({\n                          name: 'something',\n                          type: 'block',\n                          of: [\n                            defineArrayMember({\n                              name: 'nested',\n                              type: 'object',\n                              fields: [\n                                defineField({\n                                  name: 'items',\n                                  type: 'array',\n                                  of: [\n                                    defineArrayMember({\n                                      name: 'item',\n                                      type: 'object',\n                                      fields: [\n                                        defineField({\n                                          name: 'deep',\n                                          type: 'array',\n                                          of: [\n                                            defineArrayMember({\n                                              type: 'block',\n                                              styles: [\n                                                {title: 'Normal', value: 'normal'},\n                                                {title: 'H2', value: 'h2'},\n                                                {title: 'H3', value: 'h3'},\n                                                {title: 'H4', value: 'h4'},\n                                              ],\n                                            }),\n                                          ],\n                                        }),\n                                      ],\n                                    }),\n                                  ],\n                                }),\n                              ],\n                            }),\n                          ],\n                        }),\n                      ],\n                    }),\n                  ],\n                },\n              ],\n            },\n            {\n              name: 'arrayOfObjects__deep',\n              type: 'array',\n              title: 'Array of objects',\n              of: [\n                {\n                  type: 'object',\n                  name: 'myObject',\n                  fields: [\n                    {\n                      name: 'string',\n                      type: 'string',\n                      title: 'String',\n                    },\n                  ],\n                },\n                {\n                  type: 'reference',\n                  name: 'author',\n                  title: 'Author',\n                  to: [{type: 'author'}],\n                },\n              ],\n            },\n          ],\n        },\n        {\n          type: 'image',\n          name: 'image',\n          title: 'Image',\n        },\n      ],\n    },\n    {\n      name: 'arrayOfObjects__flat',\n      type: 'array',\n      title: 'Array of objects',\n      of: [\n        {\n          type: 'object',\n          name: 'myObject',\n          fields: [\n            {\n              name: 'string',\n              type: 'string',\n              title: 'String',\n            },\n          ],\n        },\n        {\n          type: 'reference',\n          name: 'author',\n          title: 'Author',\n          to: [{type: 'author'}],\n        },\n        {\n          type: 'reference',\n          name: 'species',\n          title: 'Species',\n          to: [{type: 'species'}],\n        },\n      ],\n    },\n    {\n      type: 'array',\n      name: 'children',\n      title: 'Children',\n      of: [\n        {\n          type: 'object',\n          name: 'child',\n          fields: [\n            {\n              name: 'nameChild',\n              type: 'string',\n              title: 'Name Child',\n            },\n            {\n              type: 'internationalizedArrayString',\n              name: 'internationalizedArrayStringChild',\n              title: 'Internationalized array string',\n            },\n          ],\n        },\n      ],\n    },\n    {\n      type: 'array',\n      name: 'childrenWithComponents',\n      title: 'Children with components',\n      of: [\n        {\n          type: 'object',\n          name: 'child',\n          components: {\n            item: SideBySideObjectItem,\n            input: SideBySideObjectInput,\n          },\n          fields: [\n            {\n              name: 'nameChild',\n              type: 'string',\n              title: 'Name Child',\n            },\n            {\n              type: 'internationalizedArrayString',\n              name: 'internationalizedArrayStringChild',\n              title: 'Internationalized array string',\n            },\n          ],\n        },\n      ],\n    },\n    {\n      name: 'size',\n      type: 'object',\n      title: 'Size',\n      fields: [\n        {\n          name: 'width',\n          type: 'number',\n          title: 'Width',\n        },\n        {\n          name: 'height',\n          type: 'number',\n          title: 'Height',\n        },\n      ],\n    },\n    {\n      name: 'countries',\n      type: 'array',\n      title: 'Countries',\n      of: [\n        {\n          type: 'string',\n          title: 'Country',\n        },\n      ],\n    },\n    {\n      type: 'array',\n      name: 'friends',\n      of: [\n        {\n          type: 'object',\n          name: 'friend',\n          fields: [\n            {\n              name: 'name',\n              type: 'string',\n              title: 'Friend name',\n              validation: (Rule) => Rule.required(),\n            },\n            {\n              name: 'age',\n              type: 'number',\n              title: 'Friend age',\n            },\n            {\n              name: 'properties',\n              type: 'array',\n              title: 'Friend properties',\n              of: [\n                {\n                  type: 'object',\n                  name: 'property',\n                  title: 'Property',\n                  fields: [\n                    {\n                      type: 'string',\n                      name: 'title',\n                      title: 'Title',\n                    },\n                    {\n                      name: 'properties_b',\n                      type: 'array',\n                      title: 'Friend properties',\n                      of: [\n                        {\n                          type: 'object',\n                          name: 'property_b',\n                          title: 'Property',\n                          fields: [\n                            {\n                              type: 'string',\n                              name: 'title',\n                              title: 'Title',\n                            },\n                            {\n                              name: 'properties_c',\n                              type: 'array',\n                              title: 'Friend properties',\n                              of: [\n                                {\n                                  type: 'object',\n                                  name: 'property_d',\n                                  title: 'Property',\n                                  fields: [\n                                    {\n                                      type: 'string',\n                                      name: 'title',\n                                      title: 'Title',\n                                    },\n                                    {\n                                      type: 'internationalizedArrayString',\n                                      name: 'internationalizedArrayString',\n                                      title: 'Internationalized array string',\n                                    },\n                                    {\n                                      name: 'properties_d',\n                                      type: 'array',\n                                      title: 'Friend properties',\n                                      of: [\n                                        {\n                                          type: 'object',\n                                          name: 'property_b',\n                                          title: 'Property',\n                                          fields: [\n                                            {\n                                              type: 'string',\n                                              name: 'title',\n                                              title: 'Title',\n                                            },\n                                          ],\n                                        },\n                                      ],\n                                    },\n                                  ],\n                                },\n                              ],\n                            },\n                          ],\n                        },\n                      ],\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    },\n  ],\n})\n\nconst body = defineField({\n  type: 'array',\n  name: 'body',\n  title: 'Body',\n  of: [\n    {\n      type: 'block',\n      name: 'block',\n      title: 'Block',\n    },\n    defineArrayMember({\n      name: 'nested',\n      type: 'object',\n      fields: [\n        defineField({\n          name: 'items',\n          type: 'array',\n          of: [\n            defineArrayMember({\n              name: 'item',\n              type: 'object',\n              fields: [\n                defineField({\n                  name: 'deep',\n                  type: 'array',\n                  of: [\n                    defineArrayMember({\n                      type: 'block',\n                      styles: [\n                        {title: 'Normal', value: 'normal'},\n                        {title: 'H2', value: 'h2'},\n                        {title: 'H3', value: 'h3'},\n                        {title: 'H4', value: 'h4'},\n                      ],\n                    }),\n                  ],\n                  components: {\n                    input: (inputProps: InputProps) => {\n                      const editorProps = {\n                        ...inputProps,\n                        initialActive: false,\n                      } as PortableTextInputProps\n                      return inputProps.renderDefault(editorProps)\n                    },\n                  },\n                }),\n              ],\n            }),\n          ],\n\n          components: {\n            input: (inputProps: InputProps) => {\n              return inputProps.renderDefault({...inputProps, initialActive: false})\n            },\n          },\n        }),\n      ],\n    }),\n    animal,\n    defineArrayMember({\n      type: 'object',\n      name: 'arrayOfObjects',\n      fields: [\n        {\n          type: 'string',\n          name: 'string',\n          title: 'String',\n        },\n      ],\n      components: {\n        input: (inputProps: any) => {\n          return inputProps.renderDefault(inputProps)\n        },\n      },\n    }),\n  ],\n})\n\nconst pte = defineField({\n  name: 'pte',\n  type: 'object',\n  title: 'PTE',\n  fields: [\n    {\n      type: 'array',\n      name: 'body',\n      of: [{type: 'block'}, animal],\n    },\n  ],\n})\n\nconst animals = defineField({\n  type: 'array',\n  name: 'animals',\n  title: 'Animals',\n  of: [animal],\n})\n\nconst fieldsetArray = defineField({\n  type: 'array',\n  name: 'fieldsetArray',\n  title: 'Fieldset array',\n\n  fieldset: 'fieldset',\n\n  of: [\n    {\n      type: 'object',\n      name: 'myObject',\n      fields: [\n        {\n          name: 'string',\n          type: 'string',\n          title: 'String',\n        },\n      ],\n    },\n  ],\n})\n\nconst arrayOfImages = defineField({\n  type: 'array',\n  name: 'arrayOfImages',\n  title: 'Array of images',\n  of: [\n    {\n      type: 'image',\n      name: 'image',\n      title: 'Image',\n    },\n  ],\n})\n\nconst arrayOfFiles = defineField({\n  type: 'array',\n  name: 'arrayOfFiles',\n  title: 'Array of files',\n  of: [\n    {\n      type: 'file',\n      name: 'file',\n      title: 'File',\n    },\n  ],\n})\n\nconst arrayOfAnonymousObjects = defineField({\n  type: 'array',\n  name: 'arrayOfAnonymousObjects',\n  title: 'Array of anonymous objects',\n  of: [\n    {\n      type: 'object',\n      fields: [\n        {\n          name: 'anonymousString',\n          type: 'string',\n          title: 'Anonymous string',\n        },\n      ],\n    },\n  ],\n})\n\nconst objectWithArray = defineField({\n  type: 'object',\n  name: 'objectWithArray",
            "output_extracted": "import {\n  defineArrayMember,\n  defineField,\n  defineType,\n  type InputProps,\n  type PortableTextInputProps,\n} from 'sanity'\n\nimport {SideBySideObjectInput, SideBySideObjectItem} from './components/SideBySideObjectInput'\nimport {PageBlockAnchor} from './PageBlockAnchor'\n\nconst animal = defineField({\n  type: 'object',\n  name: 'animal',\n  title: 'Animal',\n  fields: [\n    {\n      name: 'name',\n      type: 'string',\n      title: 'Animal name',\n    },\n    {\n      type: 'array',\n      name: 'description',\n      title: 'Description',\n      of: [\n        {type: 'block'},\n        {\n          type: 'object',\n          name: 'info',\n          fields: [\n            {\n              type: 'array',\n              name: 'item',\n              title: 'Item',\n              of: [\n                {\n                  type: 'object',\n                  name: 'property',\n                  title: 'Property',\n                  fields: [\n                    {\n                      type: 'string',\n                      name: 'title',\n                      title: 'Title',\n                      validation: (Rule) => Rule.required(),\n                    },\n                    {\n                      type: 'string',\n                      name: 'value',\n                      title: 'Value',\n                    },\n                    {\n                      type: 'array',\n                      name: 'description_two',\n                      title: 'Description Two',\n                      components: {\n                        input: (props: any) => {\n                          return props.renderDefault({...props, initialFullscreen: true})\n                        },\n                      },\n                      of: [\n                        {type: 'block'},\n                        {\n                          type: 'object',\n                          name: 'info_two',\n                          title: 'Info Two',\n                          fields: [\n                            {\n                              type: 'array',\n                              name: 'item_two',\n                              title: 'Item Two',\n                              of: [\n                                {\n                                  type: 'object',\n                                  name: 'property_two',\n                                  title: 'Property Two',\n                                  fields: [\n                                    {\n                                      type: 'string',\n                                      name: 'title_two',\n                                      title: 'Title Two',\n                                      validation: (Rule) => Rule.required(),\n                                    },\n                                    {\n                                      type: 'string',\n                                      name: 'value_two',\n                                      title: 'Value Two',\n                                    },\n                                    {\n                                      type: 'array',\n                                      name: 'description_three',\n                                      title: 'Description Three',\n                                      of: [\n                                        {type: 'block'},\n                                        {\n                                          type: 'object',\n                                          name: 'info_three',\n                                          title: 'Info Three',\n                                          fields: [\n                                            {\n                                              type: 'string',\n                                              name: 'title_three',\n                                              title: 'Title Three',\n                                            },\n                                          ],\n                                          components: {\n                                            input: (inputProps: any) => {\n                                              return inputProps.renderDefault(inputProps)\n                                            },\n                                          },\n                                        },\n                                      ],\n                                    },\n                                    {\n                                      type: 'internationalizedArrayString',\n                                      name: 'internationalizedArrayString',\n                                      title: 'Internationalized array string',\n                                    },\n\n                                    {\n                                      type: 'image',\n                                      name: 'imageChild',\n                                      title: 'Image',\n                                    },\n                                  ],\n                                },\n                              ],\n                            },\n                          ],\n                        },\n                        {\n                          type: 'image',\n                          name: 'image_two',\n                          title: 'Image',\n                        },\n                      ],\n                    },\n                    defineField({\n                      name: 'content',\n                      type: 'array',\n                      of: [\n                        defineArrayMember({\n                          name: 'something',\n                          type: 'block',\n                          of: [\n                            defineArrayMember({\n                              name: 'nested',\n                              type: 'object',\n                              fields: [\n                                defineField({\n                                  name: 'items',\n                                  type: 'array',\n                                  of: [\n                                    defineArrayMember({\n                                      name: 'item',\n                                      type: 'object',\n                                      fields: [\n                                        defineField({\n                                          name: 'deep',\n                                          type: 'array',\n                                          of: [\n                                            defineArrayMember({\n                                              type: 'block',\n                                              styles: [\n                                                {title: 'Normal', value: 'normal'},\n                                                {title: 'H2', value: 'h2'},\n                                                {title: 'H3', value: 'h3'},\n                                                {title: 'H4', value: 'h4'},\n                                              ],\n                                            }),\n                                          ],\n                                        }),\n                                      ],\n                                    }),\n                                  ],\n                                }),\n                              ],\n                            }),\n                          ],\n                        }),\n                      ],\n                    }),\n                  ],\n                },\n              ],\n            },\n            {\n              name: 'arrayOfObjects__deep',\n              type: 'array',\n              title: 'Array of objects',\n              of: [\n                {\n                  type: 'object',\n                  name: 'myObject',\n                  fields: [\n                    {\n                      name: 'string',\n                      type: 'string',\n                      title: 'String',\n                    },\n                  ],\n                },\n                {\n                  type: 'reference',\n                  name: 'author',\n                  title: 'Author',\n                  to: [{type: 'author'}],\n                },\n              ],\n            },\n          ],\n        },\n        {\n          type: 'image',\n          name: 'image',\n          title: 'Image',\n        },\n      ],\n    },\n    {\n      name: 'arrayOfObjects__flat',\n      type: 'array',\n      title: 'Array of objects',\n      of: [\n        {\n          type: 'object',\n          name: 'myObject',\n          fields: [\n            {\n              name: 'string',\n              type: 'string',\n              title: 'String',\n            },\n          ],\n        },\n        {\n          type: 'reference',\n          name: 'author',\n          title: 'Author',\n          to: [{type: 'author'}],\n        },\n        {\n          type: 'reference',\n          name: 'species',\n          title: 'Species',\n          to: [{type: 'species'}],\n        },\n      ],\n    },\n    {\n      type: 'array',\n      name: 'children',\n      title: 'Children',\n      of: [\n        {\n          type: 'object',\n          name: 'child',\n          fields: [\n            {\n              name: 'nameChild',\n              type: 'string',\n              title: 'Name Child',\n            },\n            {\n              type: 'internationalizedArrayString',\n              name: 'internationalizedArrayStringChild',\n              title: 'Internationalized array string',\n            },\n          ],\n        },\n      ],\n    },\n    {\n      type: 'array',\n      name: 'childrenWithComponents',\n      title: 'Children with components',\n      of: [\n        {\n          type: 'object',\n          name: 'child',\n          components: {\n            item: SideBySideObjectItem,\n            input: SideBySideObjectInput,\n          },\n          fields: [\n            {\n              name: 'nameChild',\n              type: 'string',\n              title: 'Name Child',\n            },\n            {\n              type: 'internationalizedArrayString',\n              name: 'internationalizedArrayStringChild',\n              title: 'Internationalized array string',\n            },\n          ],\n        },\n      ],\n    },\n    {\n      name: 'size',\n      type: 'object',\n      title: 'Size',\n      fields: [\n        {\n          name: 'width',\n          type: 'number',\n          title: 'Width',\n        },\n        {\n          name: 'height',\n          type: 'number',\n          title: 'Height',\n        },\n      ],\n    },\n    {\n      name: 'countries',\n      type: 'array',\n      title: 'Countries',\n      of: [\n        {\n          type: 'string',\n          title: 'Country',\n        },\n      ],\n    },\n    {\n      type: 'array',\n      name: 'friends',\n      of: [\n        {\n          type: 'object',\n          name: 'friend',\n          fields: [\n            {\n              name: 'name',\n              type: 'string',\n              title: 'Friend name',\n              validation: (Rule) => Rule.required(),\n            },\n            {\n              name: 'age',\n              type: 'number',\n              title: 'Friend age',\n            },\n            {\n              name: 'properties',\n              type: 'array',\n              title: 'Friend properties',\n              of: [\n                {\n                  type: 'object',\n                  name: 'property',\n                  title: 'Property',\n                  fields: [\n                    {\n                      type: 'string',\n                      name: 'title',\n                      title: 'Title',\n                    },\n                    {\n                      name: 'properties_b',\n                      type: 'array',\n                      title: 'Friend properties',\n                      of: [\n                        {\n                          type: 'object',\n                          name: 'property_b',\n                          title: 'Property',\n                          fields: [\n                            {\n                              type: 'string',\n                              name: 'title',\n                              title: 'Title',\n                            },\n                            {\n                              name: 'properties_c',\n                              type: 'array',\n                              title: 'Friend properties',\n                              of: [\n                                {\n                                  type: 'object',\n                                  name: 'property_d',\n                                  title: 'Property',\n                                  fields: [\n                                    {\n                                      type: 'string',\n                                      name: 'title',\n                                      title: 'Title',\n                                    },\n                                    {\n                                      type: 'internationalizedArrayString',\n                                      name: 'internationalizedArrayString',\n                                      title: 'Internationalized array string',\n                                    },\n                                    {\n                                      name: 'properties_d',\n                                      type: 'array',\n                                      title: 'Friend properties',\n                                      of: [\n                                        {\n                                          type: 'object',\n                                          name: 'property_b',\n                                          title: 'Property',\n                                          fields: [\n                                            {\n                                              type: 'string',\n                                              name: 'title',\n                                              title: 'Title',\n                                            },\n                                          ],\n                                        },\n                                      ],\n                                    },\n                                  ],\n                                },\n                              ],\n                            },\n                          ],\n                        },\n                      ],\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ],\n    },\n  ],\n})\n\nconst body = defineField({\n  type: 'array',\n  name: 'body',\n  title: 'Body',\n  of: [\n    {\n      type: 'block',\n      name: 'block',\n      title: 'Block',\n    },\n    defineArrayMember({\n      name: 'nested',\n      type: 'object',\n      fields: [\n        defineField({\n          name: 'items',\n          type: 'array',\n          of: [\n            defineArrayMember({\n              name: 'item',\n              type: 'object',\n              fields: [\n                defineField({\n                  name: 'deep',\n                  type: 'array',\n                  of: [\n                    defineArrayMember({\n                      type: 'block',\n                      styles: [\n                        {title: 'Normal', value: 'normal'},\n                        {title: 'H2', value: 'h2'},\n                        {title: 'H3', value: 'h3'},\n                        {title: 'H4', value: 'h4'},\n                      ],\n                    }),\n                  ],\n                  components: {\n                    input: (inputProps: InputProps) => {\n                      const editorProps = {\n                        ...inputProps,\n                        initialActive: false,\n                      } as PortableTextInputProps\n                      return inputProps.renderDefault(editorProps)\n                    },\n                  },\n                }),\n              ],\n            }),\n          ],\n\n          components: {\n            input: (inputProps: InputProps) => {\n              return inputProps.renderDefault({...inputProps, initialActive: false})\n            },\n          },\n        }),\n      ],\n    }),\n    animal,\n    defineArrayMember({\n      type: 'object',\n      name: 'arrayOfObjects',\n      fields: [\n        {\n          type: 'string',\n          name: 'string',\n          title: 'String',\n        },\n      ],\n      components: {\n        input: (inputProps: any) => {\n          return inputProps.renderDefault(inputProps)\n        },\n      },\n    }),\n  ],\n})\n\nconst pte = defineField({\n  name: 'pte',\n  type: 'object',\n  title: 'PTE',\n  fields: [\n    {\n      type: 'array',\n      name: 'body',\n      of: [{type: 'block'}, animal],\n    },\n  ],\n})\n\nconst animals = defineField({\n  type: 'array',\n  name: 'animals',\n  title: 'Animals',\n  of: [animal],\n})\n\nconst fieldsetArray = defineField({\n  type: 'array',\n  name: 'fieldsetArray',\n  title: 'Fieldset array',\n\n  fieldset: 'fieldset',\n\n  of: [\n    {\n      type: 'object',\n      name: 'myObject',\n      fields: [\n        {\n          name: 'string',\n          type: 'string',\n          title: 'String',\n        },\n      ],\n    },\n  ],\n})\n\nconst arrayOfImages = defineField({\n  type: 'array',\n  name: 'arrayOfImages',\n  title: 'Array of images',\n  of: [\n    {\n      type: 'image',\n      name: 'image',\n      title: 'Image',\n    },\n  ],\n})\n\nconst arrayOfFiles = defineField({\n  type: 'array',\n  name: 'arrayOfFiles',\n  title: 'Array of files',\n  of: [\n    {\n      type: 'file',\n      name: 'file',\n      title: 'File',\n    },\n  ],\n})\n\nconst arrayOfAnonymousObjects = defineField({\n  type: 'array',\n  name: 'arrayOfAnonymousObjects',\n  title: 'Array of anonymous objects',\n  of: [\n    {\n      type: 'object',\n      fields: [\n        {\n          name: 'anonymousString',\n          type: 'string',\n          title: 'Anonymous string',\n        },\n      ],\n    },\n  ],\n})\n\nconst objectWithArray = defineField({\n  type: 'object',\n  name: 'objectWithArray",
            "cost": 0.14746
        },
        "sanity-io__sanity.615e6c01/e2e/tests/enhanced-object-dialog/componentItemSmoke.spec.ts": {
            "output": "import {expect} from '@playwright/test'\n\nimport {test} from '../../studio-test'\n\ntest.describe('Enhanced Object Dialog - schema with component item and input smoke test', () => {\n  test.beforeEach(async ({createDraftDocument}) => {\n    // wait for form to be attached\n    await createDraftDocument('/content/input-debug;objectsDebug')\n  })\n\n  test(`opening - when creating new item with custom components.item, the modal should open`, async ({\n    page,\n  }) => {\n    const button = page\n      .getByTestId('field-arrayofObjectsWithItem')\n      .getByTestId('add-single-object-button')\n    await expect(button).toBeEnabled()\n    await button.click()\n\n    await expect(page.getByTestId('nested-object-dialog')).toBeVisible()\n  })\n\n  test(`opening - when clicking the internationalized array string field, the modal should not open`, async ({\n    page,\n  }) => {\n    const input = page.getByTestId('field-greeting[_key==\"en\"].value').getByTestId('string-input')\n    await expect(input).toBeEnabled()\n    await input.click()\n    await input.fill('Test')\n\n    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n  })\n})",
            "output_extracted": "import {expect} from '@playwright/test'\n\nimport {test} from '../../studio-test'\n\ntest.describe('Enhanced Object Dialog - schema with component item and input smoke test', () => {\n  test.beforeEach(async ({createDraftDocument}) => {\n    // wait for form to be attached\n    await createDraftDocument('/content/input-debug;objectsDebug')\n  })\n\n  test(`opening - when creating new item with custom components.item, the modal should open`, async ({\n    page,\n  }) => {\n    const button = page\n      .getByTestId('field-arrayofObjectsWithItem')\n      .getByTestId('add-single-object-button')\n    await expect(button).toBeEnabled()\n    await button.click()\n\n    await expect(page.getByTestId('nested-object-dialog')).toBeVisible()\n  })\n\n  test(`opening - when clicking the internationalized array string field, the modal should not open`, async ({\n    page,\n  }) => {\n    const input = page.getByTestId('field-greeting[_key==\"en\"].value').getByTestId('string-input')\n    await expect(input).toBeEnabled()\n    await input.click()\n    await input.fill('Test')\n\n    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n  })\n})",
            "cost": 0.022365000000000003
        },
        "sanity-io__sanity.615e6c01/e2e/tests/enhanced-object-dialog/smoke.spec.ts": {
            "output": "import {expect} from '@playwright/test'\n\nimport {test} from '../../studio-test'\n\ntest.describe('Enhanced Object Dialog - open and close', () => {\n  test.beforeEach(async ({createDraftDocument}) => {\n    // wait for form to be attached\n    await createDraftDocument('/content/input-debug;objectsDebug')\n  })\n\n  test(`opening - when creating new array item, the tree editing modal should open`, async ({\n    page,\n  }) => {\n    await page.getByTestId('field-animals').getByRole('button', {name: 'Add item'}).click()\n\n    await expect(page.getByTestId('nested-object-dialog')).toBeVisible()\n  })\n\n  test(`closing - when the modal is open, clicking the 'done button' will close it`, async ({\n    page,\n    browserName,\n  }) => {\n    // For now, only test in Chromium due to flakiness in Firefox and WebKit\n    test.skip(browserName !== 'chromium')\n\n    await page.getByTestId('field-animals').getByRole('button', {name: 'Add item'}).click()\n    const modal = page.getByTestId('nested-object-dialog')\n\n    await expect(modal).toBeVisible()\n    await page.getByRole('button', {name: 'Close dialog'}).click()\n\n    await expect(modal).not.toBeVisible()\n  })\n})\n\ntest.describe('Enhanced Object Dialog - when disabled', () => {\n  test.beforeEach(async ({page, _testContext, browserName, baseURL}) => {\n    // Navigate to the browser-specific no-enhanced-dialog workspace\n    const workspacePath =\n      browserName === 'firefox' ? 'firefox-no-enhanced-dialog' : 'chromium-no-enhanced-dialog'\n    const baseUrl = new URL(baseURL || 'http://localhost:3339')\n    const id = _testContext.getUniqueDocumentId()\n\n    // Use absolute URL to navigate to the correct workspace\n    await page.goto(`${baseUrl.origin}/${workspacePath}/content/input-debug;objectsDebug;${id}`)\n    await page.locator('[data-testid=\"form-view\"]').waitFor({state: 'visible', timeout: 30_000})\n    await page\n      .locator('[data-testid=\"form-view\"]:not([data-read-only=\"true\"])')\n      .waitFor({state: 'visible', timeout: 30_000})\n  })\n\n  test(`when enhancedObjectDialog is disabled, the tree editing modal should NOT open`, async ({\n    page,\n  }) => {\n    await page.getByTestId('field-animals').getByRole('button', {name: 'Add item'}).click()\n\n    await expect(page.getByTestId('edit-portal-dialog')).toBeVisible()\n    // The enhanced dialog should not be visible\n    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n  })\n})",
            "output_extracted": "import {expect} from '@playwright/test'\n\nimport {test} from '../../studio-test'\n\ntest.describe('Enhanced Object Dialog - open and close', () => {\n  test.beforeEach(async ({createDraftDocument}) => {\n    // wait for form to be attached\n    await createDraftDocument('/content/input-debug;objectsDebug')\n  })\n\n  test(`opening - when creating new array item, the tree editing modal should open`, async ({\n    page,\n  }) => {\n    await page.getByTestId('field-animals').getByRole('button', {name: 'Add item'}).click()\n\n    await expect(page.getByTestId('nested-object-dialog')).toBeVisible()\n  })\n\n  test(`closing - when the modal is open, clicking the 'done button' will close it`, async ({\n    page,\n    browserName,\n  }) => {\n    // For now, only test in Chromium due to flakiness in Firefox and WebKit\n    test.skip(browserName !== 'chromium')\n\n    await page.getByTestId('field-animals').getByRole('button', {name: 'Add item'}).click()\n    const modal = page.getByTestId('nested-object-dialog')\n\n    await expect(modal).toBeVisible()\n    await page.getByRole('button', {name: 'Close dialog'}).click()\n\n    await expect(modal).not.toBeVisible()\n  })\n})\n\ntest.describe('Enhanced Object Dialog - when disabled', () => {\n  test.beforeEach(async ({page, _testContext, browserName, baseURL}) => {\n    // Navigate to the browser-specific no-enhanced-dialog workspace\n    const workspacePath =\n      browserName === 'firefox' ? 'firefox-no-enhanced-dialog' : 'chromium-no-enhanced-dialog'\n    const baseUrl = new URL(baseURL || 'http://localhost:3339')\n    const id = _testContext.getUniqueDocumentId()\n\n    // Use absolute URL to navigate to the correct workspace\n    await page.goto(`${baseUrl.origin}/${workspacePath}/content/input-debug;objectsDebug;${id}`)\n    await page.locator('[data-testid=\"form-view\"]').waitFor({state: 'visible', timeout: 30_000})\n    await page\n      .locator('[data-testid=\"form-view\"]:not([data-read-only=\"true\"])')\n      .waitFor({state: 'visible', timeout: 30_000})\n  })\n\n  test(`when enhancedObjectDialog is disabled, the tree editing modal should NOT open`, async ({\n    page,\n  }) => {\n    await page.getByTestId('field-animals').getByRole('button', {name: 'Add item'}).click()\n\n    await expect(page.getByTestId('edit-portal-dialog')).toBeVisible()\n    // The enhanced dialog should not be visible\n    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n  })\n})",
            "cost": 0.032105
        },
        "sanity-io__sanity.615e6c01/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayState.ts": {
            "output": "import {\n  type ArraySchemaType,\n  isArrayOfBlocksSchemaType,\n  isArrayOfObjectsSchemaType,\n  isObjectSchemaType,\n  isPrimitiveSchemaType,\n  isReferenceSchemaType,\n  type ObjectField,\n  type ObjectSchemaType,\n  type Path,\n  type SchemaType,\n} from '@sanity/types'\nimport {startsWith, toString} from '@sanity/util/paths'\n\nimport {getValueAtPath} from '../../../../../field/paths/helpers'\nimport {EMPTY_ARRAY} from '../../../../../util/empty'\nimport {getItemType} from '../../../../store/utils/getItemType'\nimport {type DialogItem} from '../../types'\nimport {findArrayTypePaths} from '../findArrayTypePaths'\nimport {getSchemaField} from '../getSchemaField'\nimport {hasCustomInputComponent} from '../hasCustomInputComponent'\nimport {isPathTextInPTEField} from '../isPathTextInPTEField'\nimport {buildArrayStatePTE} from './buildArrayStatePTE'\nimport {buildBreadcrumbsState} from './buildBreadcrumbsState'\nimport {type RecursiveProps, type TreeEditingState} from './buildTreeEditingState'\nimport {\n  getRelativePath,\n  isArrayItemSelected,\n  shouldBeInBreadcrumb,\n  shouldSkipSiblingCount,\n  validateRelativePathExists,\n} from './utils'\n\ninterface BuildArrayState {\n  /** The schema type of the array field  */\n  arraySchemaType: ArraySchemaType\n  /** The value of the array field */\n  arrayValue: Record<string, unknown>[]\n  /**  The value of the document */\n  documentValue: unknown\n  /** The current `openPath` */\n  openPath: Path\n  /** The recursive function to build the tree editing state for nested fields */\n  recursive: (props: RecursiveProps) => TreeEditingState\n  /** The root path of the array */\n  rootPath: Path\n  /** The root schema type to check for portable text fields */\n  rootSchemaType: ObjectSchemaType\n}\n\n/**\n * Build the tree editing state for an array field.\n */\nexport function buildArrayState(props: BuildArrayState): TreeEditingState {\n  const {\n    arraySchemaType,\n    arrayValue,\n    documentValue,\n    openPath,\n    rootPath,\n    recursive,\n    rootSchemaType,\n  } = props\n\n  let relativePath: Path = []\n  const menuItems: DialogItem[] = []\n  const breadcrumbs: DialogItem[] = []\n  const siblings = new Map<string, {count: number; index: number}>()\n\n  // This is specifically needed for Portable Text editors that are at a root level in the document\n  // In that case, and if the openPath points to a regular text block (such as when you write it), we return empty state\n  // Since this SHOULDN'T open the dialog\n  if (\n    isArrayOfBlocksSchemaType(arraySchemaType) &&\n    isPathTextInPTEField(rootSchemaType.fields, openPath, documentValue)\n  ) {\n    return {\n      breadcrumbs,\n      menuItems,\n      relativePath,\n      rootTitle: '',\n      siblings,\n    }\n  }\n\n  // Iterate over the values of the array field.\n  arrayValue.forEach((item, arrayIndex) => {\n    // Construct the path to the array item.\n    const itemPath = [...rootPath, {_key: item._key}] as Path\n\n    // Get the schema field for the array item.\n    const itemSchemaField = getItemType(arraySchemaType, item) as ObjectSchemaType\n\n    if (!itemSchemaField) return\n    // Skip references early, references are handled by the reference input and shouldn't open the enhanced dialog\n    if (isReferenceSchemaType(itemSchemaField)) return\n\n    // Check if this is the currently selected item and store its index\n    if (isArrayItemSelected(itemPath, openPath)) {\n      relativePath = getRelativePath(itemPath)\n    }\n\n    // Check if openPath is within this array item (for fields within the item)\n    // This needs to be less strict than the isArrayItemSelected check\n    // Because from a UI perspective we're still within the item\n    // Important: do NOT set siblings for Portable Text arrays (arrays of blocks) as we handle them differently\n    if (\n      item._key &&\n      startsWith(itemPath, openPath) &&\n      !isArrayOfBlocksSchemaType(arraySchemaType)\n    ) {\n      // Store sibling info on the parent array path (header reads parent of relativePath)\n      siblings.set(toString(rootPath), {count: arrayValue.length, index: arrayIndex + 1})\n    }\n\n    const childrenFields = itemSchemaField?.fields || []\n    const childrenMenuItems: DialogItem[] = []\n\n    if (\n      shouldBeInBreadcrumb(itemPath, openPath, documentValue) &&\n      !hasCustomInputComponent(rootSchemaType.fields, itemPath)\n    ) {\n      const breadcrumbsResult = buildBreadcrumbsState({\n        arraySchemaType,\n        arrayValue,\n        itemPath,\n        parentPath: rootPath,\n      })\n\n      breadcrumbs.push(breadcrumbsResult)\n    }\n\n    // Iterate over the fields of the array item to resolve any nested fields.\n    childrenFields.forEach((childField) => {\n      // Construct the path to the child field.\n      const childPath = [...itemPath, childField.name] as Path\n\n      // Get the value of the child field.\n      const childValue = getValueAtPath(documentValue, childPath)\n\n      // Skip references early, references are handled by the reference input and shouldn't open the enhanced dialog\n      if (isReferenceSchemaType(childField.type)) return\n\n      if (isArrayItemSelected(childPath, openPath)) {\n        relativePath = getRelativePath(childPath)\n      }\n\n      // If the child field is an object field, check if it contains any array fields.\n      // If there are array fields within the child field, recursively build the tree\n      // editing state for them.\n      if (isObjectSchemaType(childField.type)) {\n        // Find the paths of any array fields within the child field.\n        const arrayPaths = findArrayTypePaths(childField.type.fields)\n\n        // If there are no array fields within the child field, return early.\n        if (arrayPaths.length === 0) return\n\n        // Iterate over the paths of the array fields within the child field.\n        arrayPaths.forEach((arrayPath) => {\n          // Construct the path to the array field.\n          const fieldPath = [...childPath, ...arrayPath] as Path\n\n          // Get the schema field for the array field.\n          const nestedArrayField = getSchemaField(\n            childField.type,\n            toString(arrayPath),\n          ) as ObjectField<SchemaType>\n\n          // Get the value of the array field.\n          const arrayFieldValue_ = getValueAtPath(documentValue, fieldPath)\n          const arrayFieldValue = Array.isArray(arrayFieldValue_) ? arrayFieldValue_ : []\n\n          // If the array field has no value or tree editing is disabled, return early.\n          if (!arrayFieldValue.length) return\n\n          // Skip references early, references are handled by the reference input and shouldn't open the enhanced dialog\n          if (isReferenceSchemaType(nestedArrayField.type)) return\n\n          // If the child array field has custom components.input, skip building dialog\n          if (isArrayOfObjectsSchemaType(nestedArrayField.type)) {\n            const nestedArraySchemaType = nestedArrayField.type as ArraySchemaType\n          }\n\n          // Update the relative path if the array field is selected.\n          if (isArrayItemSelected(fieldPath, openPath)) {\n            relativePath = getRelativePath(fieldPath)\n          }\n\n          const updateNestedArrayIndex = (nestedItem: unknown, nestedIndex: number) => {\n            const nestedItemObj = nestedItem as Record<string, unknown>\n            const nestedItemPath = [...fieldPath, {_key: nestedItemObj._key}] as Path\n\n            // Check if openPath is within this nested array item (for fields within the item)\n            // Avoids setting siblings that we do not care about\n            if (startsWith(nestedItemPath, openPath)) {\n              siblings.set(toString(fieldPath), {\n                count: arrayFieldValue.length,\n                index: nestedIndex + 1,\n              })\n            }\n          }\n          arrayFieldValue.forEach(updateNestedArrayIndex)\n\n          // Recursively build the tree editing state for the array field.\n          const nestedArrayState = recursive({\n            documentValue,\n            path: fieldPath,\n            schemaType: nestedArrayField as ObjectSchemaType,\n          })\n\n          // Merge sibling counts from nested state\n          nestedArrayState.siblings.forEach((info, pathString) => {\n            siblings.set(pathString, info)\n          })\n\n          // Add the state of the array field to the children menu items.\n          childrenMenuItems.push({\n            children: nestedArrayState.menuItems,\n            parentSchemaType: childField.type,\n            path: fieldPath,\n            schemaType: nestedArrayField.type,\n            value: arrayFieldValue,\n          })\n        })\n      }\n\n      const isPortableText = isArrayOfBlocksSchemaType(childField.type)\n      const IsArrayOfObjects =\n        isArrayOfObjectsSchemaType(childField.type) && childValue && !isPortableText\n\n      // Handle regular arrays of objects (not portable text)\n      if (IsArrayOfObjects) {\n        const childArray = Array.isArray(childValue) ? childValue : []\n\n        // Check if any item in this array is selected and update the index\n        const updateChildArrayIndex = (childItem: unknown, childIndex: number) => {\n          const childItemObj = childItem as Record<string, unknown>\n          const childItemPath = [...childPath, {_key: childItemObj._key}] as Path\n          if (startsWith(childItemPath, openPath)) {\n            // When the parent array is a PTE (array of blocks) and this child array is the block's\n            // 'children' array, skip siblings so inline custom objects don't show siblings\n            const isBlockChildrenArray =\n              isArrayOfBlocksSchemaType(arraySchemaType) && childField.name === 'children'\n\n            if (!isBlockChildrenArray) {\n              siblings.set(toString(childPath), {count: childArray.length, index: childIndex + 1})\n            }\n          }\n        }\n        childArray.forEach(updateChildArrayIndex)\n\n        if (\n          shouldBeInBreadcrumb(childPath, openPath, documentValue) &&\n          !hasCustomInputComponent(rootSchemaType.fields, childPath)\n        ) {\n          const breadcrumbsResult = buildBreadcrumbsState({\n            arraySchemaType: childField.type as ArraySchemaType,\n            arrayValue: childValue as Record<string, unknown>[],\n            itemPath: childPath,\n            parentPath: itemPath,\n          })\n\n          breadcrumbs.push(breadcrumbsResult)\n        }\n\n        const childState = recursive({\n          documentValue,\n          path: childPath,\n          schemaType: childField as ObjectSchemaType,\n        })\n\n        // Merge sibling counts from child state\n        const childPathString = toString(childPath)\n        const skipChildArraySiblings = shouldSkipSiblingCount({\n          arraySchemaType,\n          fieldPath: childPath,\n        })\n\n        // If it's an inline custom object/object array/span, skip siblings\n        childState.siblings.forEach((info, pathString) => {\n          if (skipChildArraySiblings && pathString === childPathString) return\n          siblings.set(pathString, info)\n        })\n\n        childrenMenuItems.push({\n          children: childState?.menuItems || EMPTY_ARRAY,\n          parentSchemaType: itemSchemaField,\n          path: childPath,\n          schemaType: childField as ObjectSchemaType,\n          value: childValue,\n        })\n      }\n\n      // Handle portable text editors inside an array of objects\n      if (isPortableText) {\n        const pteResult = buildArrayStatePTE({\n          childField,\n          childPath,\n          childValue,\n          documentValue,\n          openPath,\n          recursive,\n          rootSchemaType,\n          breadcrumbs,\n          childrenMenuItems,\n        })\n\n        // Merge sibling counts from PTE result\n        pteResult.siblings.forEach((info, pathString) => {\n          siblings.set(pathString, info)\n        })\n\n        // This is needed for cases where new blocks are added to the array within a PTE\n        // This will make sure that the relative path is updated with the PTE path only when it should\n        if (\n          pteResult.relativePath &&\n          pteResult.relativePath !== null &&\n          relativePath.length === 0\n        ) {\n          relativePath = pteResult.relativePath\n        }\n      }\n    })\n\n    // Update the relative path if the array item is selected\n    // this is specifically done for the case where the array of objects is not nested (exists in the root of the document)\n    if (isArrayItemSelected(itemPath, openPath) && !isReferenceSchemaType(itemSchemaField?.type)) {\n      relativePath = getRelativePath(itemPath)\n    }\n\n    // In cases of primitive types, we don't want to show the menu items\n    // the menu items were used for the breadcrumbs for sibling navigation but it's not something we want to use right now explicitly\n    if (!isPrimitiveSchemaType(itemSchemaField?.type)) {\n      menuItems.push({\n        children: childrenMenuItems,\n        parentSchemaType: arraySchemaType,\n        path: itemPath as Path,\n        schemaType: itemSchemaField as ObjectSchemaType,\n        value: item,\n      })\n    }\n  })\n\n  // Final check: if relativePath points to a non-existent item, point to the parent array instead\n  // This handles new item creation and is especially important in deeply nested structures\n  // This prevents the dialog from attempting to navigate when the new key is not ready yet\n  relativePath = validateRelativePathExists(relativePath, documentValue) as Path\n\n  return {\n    breadcrumbs,\n    menuItems,\n    relativePath,\n    rootTitle: '',\n    siblings,\n  }\n}",
            "output_extracted": "import {\n  type ArraySchemaType,\n  isArrayOfBlocksSchemaType,\n  isArrayOfObjectsSchemaType,\n  isObjectSchemaType,\n  isPrimitiveSchemaType,\n  isReferenceSchemaType,\n  type ObjectField,\n  type ObjectSchemaType,\n  type Path,\n  type SchemaType,\n} from '@sanity/types'\nimport {startsWith, toString} from '@sanity/util/paths'\n\nimport {getValueAtPath} from '../../../../../field/paths/helpers'\nimport {EMPTY_ARRAY} from '../../../../../util/empty'\nimport {getItemType} from '../../../../store/utils/getItemType'\nimport {type DialogItem} from '../../types'\nimport {findArrayTypePaths} from '../findArrayTypePaths'\nimport {getSchemaField} from '../getSchemaField'\nimport {hasCustomInputComponent} from '../hasCustomInputComponent'\nimport {isPathTextInPTEField} from '../isPathTextInPTEField'\nimport {buildArrayStatePTE} from './buildArrayStatePTE'\nimport {buildBreadcrumbsState} from './buildBreadcrumbsState'\nimport {type RecursiveProps, type TreeEditingState} from './buildTreeEditingState'\nimport {\n  getRelativePath,\n  isArrayItemSelected,\n  shouldBeInBreadcrumb,\n  shouldSkipSiblingCount,\n  validateRelativePathExists,\n} from './utils'\n\ninterface BuildArrayState {\n  /** The schema type of the array field  */\n  arraySchemaType: ArraySchemaType\n  /** The value of the array field */\n  arrayValue: Record<string, unknown>[]\n  /**  The value of the document */\n  documentValue: unknown\n  /** The current `openPath` */\n  openPath: Path\n  /** The recursive function to build the tree editing state for nested fields */\n  recursive: (props: RecursiveProps) => TreeEditingState\n  /** The root path of the array */\n  rootPath: Path\n  /** The root schema type to check for portable text fields */\n  rootSchemaType: ObjectSchemaType\n}\n\n/**\n * Build the tree editing state for an array field.\n */\nexport function buildArrayState(props: BuildArrayState): TreeEditingState {\n  const {\n    arraySchemaType,\n    arrayValue,\n    documentValue,\n    openPath,\n    rootPath,\n    recursive,\n    rootSchemaType,\n  } = props\n\n  let relativePath: Path = []\n  const menuItems: DialogItem[] = []\n  const breadcrumbs: DialogItem[] = []\n  const siblings = new Map<string, {count: number; index: number}>()\n\n  // This is specifically needed for Portable Text editors that are at a root level in the document\n  // In that case, and if the openPath points to a regular text block (such as when you write it), we return empty state\n  // Since this SHOULDN'T open the dialog\n  if (\n    isArrayOfBlocksSchemaType(arraySchemaType) &&\n    isPathTextInPTEField(rootSchemaType.fields, openPath, documentValue)\n  ) {\n    return {\n      breadcrumbs,\n      menuItems,\n      relativePath,\n      rootTitle: '',\n      siblings,\n    }\n  }\n\n  // Iterate over the values of the array field.\n  arrayValue.forEach((item, arrayIndex) => {\n    // Construct the path to the array item.\n    const itemPath = [...rootPath, {_key: item._key}] as Path\n\n    // Get the schema field for the array item.\n    const itemSchemaField = getItemType(arraySchemaType, item) as ObjectSchemaType\n\n    if (!itemSchemaField) return\n    // Skip references early, references are handled by the reference input and shouldn't open the enhanced dialog\n    if (isReferenceSchemaType(itemSchemaField)) return\n\n    // Check if this is the currently selected item and store its index\n    if (isArrayItemSelected(itemPath, openPath)) {\n      relativePath = getRelativePath(itemPath)\n    }\n\n    // Check if openPath is within this array item (for fields within the item)\n    // This needs to be less strict than the isArrayItemSelected check\n    // Because from a UI perspective we're still within the item\n    // Important: do NOT set siblings for Portable Text arrays (arrays of blocks) as we handle them differently\n    if (\n      item._key &&\n      startsWith(itemPath, openPath) &&\n      !isArrayOfBlocksSchemaType(arraySchemaType)\n    ) {\n      // Store sibling info on the parent array path (header reads parent of relativePath)\n      siblings.set(toString(rootPath), {count: arrayValue.length, index: arrayIndex + 1})\n    }\n\n    const childrenFields = itemSchemaField?.fields || []\n    const childrenMenuItems: DialogItem[] = []\n\n    if (\n      shouldBeInBreadcrumb(itemPath, openPath, documentValue) &&\n      !hasCustomInputComponent(rootSchemaType.fields, itemPath)\n    ) {\n      const breadcrumbsResult = buildBreadcrumbsState({\n        arraySchemaType,\n        arrayValue,\n        itemPath,\n        parentPath: rootPath,\n      })\n\n      breadcrumbs.push(breadcrumbsResult)\n    }\n\n    // Iterate over the fields of the array item to resolve any nested fields.\n    childrenFields.forEach((childField) => {\n      // Construct the path to the child field.\n      const childPath = [...itemPath, childField.name] as Path\n\n      // Get the value of the child field.\n      const childValue = getValueAtPath(documentValue, childPath)\n\n      // Skip references early, references are handled by the reference input and shouldn't open the enhanced dialog\n      if (isReferenceSchemaType(childField.type)) return\n\n      if (isArrayItemSelected(childPath, openPath)) {\n        relativePath = getRelativePath(childPath)\n      }\n\n      // If the child field is an object field, check if it contains any array fields.\n      // If there are array fields within the child field, recursively build the tree\n      // editing state for them.\n      if (isObjectSchemaType(childField.type)) {\n        // Find the paths of any array fields within the child field.\n        const arrayPaths = findArrayTypePaths(childField.type.fields)\n\n        // If there are no array fields within the child field, return early.\n        if (arrayPaths.length === 0) return\n\n        // Iterate over the paths of the array fields within the child field.\n        arrayPaths.forEach((arrayPath) => {\n          // Construct the path to the array field.\n          const fieldPath = [...childPath, ...arrayPath] as Path\n\n          // Get the schema field for the array field.\n          const nestedArrayField = getSchemaField(\n            childField.type,\n            toString(arrayPath),\n          ) as ObjectField<SchemaType>\n\n          // Get the value of the array field.\n          const arrayFieldValue_ = getValueAtPath(documentValue, fieldPath)\n          const arrayFieldValue = Array.isArray(arrayFieldValue_) ? arrayFieldValue_ : []\n\n          // If the array field has no value or tree editing is disabled, return early.\n          if (!arrayFieldValue.length) return\n\n          // Skip references early, references are handled by the reference input and shouldn't open the enhanced dialog\n          if (isReferenceSchemaType(nestedArrayField.type)) return\n\n          // If the child array field has custom components.input, skip building dialog\n          if (isArrayOfObjectsSchemaType(nestedArrayField.type)) {\n            const nestedArraySchemaType = nestedArrayField.type as ArraySchemaType\n          }\n\n          // Update the relative path if the array field is selected.\n          if (isArrayItemSelected(fieldPath, openPath)) {\n            relativePath = getRelativePath(fieldPath)\n          }\n\n          const updateNestedArrayIndex = (nestedItem: unknown, nestedIndex: number) => {\n            const nestedItemObj = nestedItem as Record<string, unknown>\n            const nestedItemPath = [...fieldPath, {_key: nestedItemObj._key}] as Path\n\n            // Check if openPath is within this nested array item (for fields within the item)\n            // Avoids setting siblings that we do not care about\n            if (startsWith(nestedItemPath, openPath)) {\n              siblings.set(toString(fieldPath), {\n                count: arrayFieldValue.length,\n                index: nestedIndex + 1,\n              })\n            }\n          }\n          arrayFieldValue.forEach(updateNestedArrayIndex)\n\n          // Recursively build the tree editing state for the array field.\n          const nestedArrayState = recursive({\n            documentValue,\n            path: fieldPath,\n            schemaType: nestedArrayField as ObjectSchemaType,\n          })\n\n          // Merge sibling counts from nested state\n          nestedArrayState.siblings.forEach((info, pathString) => {\n            siblings.set(pathString, info)\n          })\n\n          // Add the state of the array field to the children menu items.\n          childrenMenuItems.push({\n            children: nestedArrayState.menuItems,\n            parentSchemaType: childField.type,\n            path: fieldPath,\n            schemaType: nestedArrayField.type,\n            value: arrayFieldValue,\n          })\n        })\n      }\n\n      const isPortableText = isArrayOfBlocksSchemaType(childField.type)\n      const IsArrayOfObjects =\n        isArrayOfObjectsSchemaType(childField.type) && childValue && !isPortableText\n\n      // Handle regular arrays of objects (not portable text)\n      if (IsArrayOfObjects) {\n        const childArray = Array.isArray(childValue) ? childValue : []\n\n        // Check if any item in this array is selected and update the index\n        const updateChildArrayIndex = (childItem: unknown, childIndex: number) => {\n          const childItemObj = childItem as Record<string, unknown>\n          const childItemPath = [...childPath, {_key: childItemObj._key}] as Path\n          if (startsWith(childItemPath, openPath)) {\n            // When the parent array is a PTE (array of blocks) and this child array is the block's\n            // 'children' array, skip siblings so inline custom objects don't show siblings\n            const isBlockChildrenArray =\n              isArrayOfBlocksSchemaType(arraySchemaType) && childField.name === 'children'\n\n            if (!isBlockChildrenArray) {\n              siblings.set(toString(childPath), {count: childArray.length, index: childIndex + 1})\n            }\n          }\n        }\n        childArray.forEach(updateChildArrayIndex)\n\n        if (\n          shouldBeInBreadcrumb(childPath, openPath, documentValue) &&\n          !hasCustomInputComponent(rootSchemaType.fields, childPath)\n        ) {\n          const breadcrumbsResult = buildBreadcrumbsState({\n            arraySchemaType: childField.type as ArraySchemaType,\n            arrayValue: childValue as Record<string, unknown>[],\n            itemPath: childPath,\n            parentPath: itemPath,\n          })\n\n          breadcrumbs.push(breadcrumbsResult)\n        }\n\n        const childState = recursive({\n          documentValue,\n          path: childPath,\n          schemaType: childField as ObjectSchemaType,\n        })\n\n        // Merge sibling counts from child state\n        const childPathString = toString(childPath)\n        const skipChildArraySiblings = shouldSkipSiblingCount({\n          arraySchemaType,\n          fieldPath: childPath,\n        })\n\n        // If it's an inline custom object/object array/span, skip siblings\n        childState.siblings.forEach((info, pathString) => {\n          if (skipChildArraySiblings && pathString === childPathString) return\n          siblings.set(pathString, info)\n        })\n\n        childrenMenuItems.push({\n          children: childState?.menuItems || EMPTY_ARRAY,\n          parentSchemaType: itemSchemaField,\n          path: childPath,\n          schemaType: childField as ObjectSchemaType,\n          value: childValue,\n        })\n      }\n\n      // Handle portable text editors inside an array of objects\n      if (isPortableText) {\n        const pteResult = buildArrayStatePTE({\n          childField,\n          childPath,\n          childValue,\n          documentValue,\n          openPath,\n          recursive,\n          rootSchemaType,\n          breadcrumbs,\n          childrenMenuItems,\n        })\n\n        // Merge sibling counts from PTE result\n        pteResult.siblings.forEach((info, pathString) => {\n          siblings.set(pathString, info)\n        })\n\n        // This is needed for cases where new blocks are added to the array within a PTE\n        // This will make sure that the relative path is updated with the PTE path only when it should\n        if (\n          pteResult.relativePath &&\n          pteResult.relativePath !== null &&\n          relativePath.length === 0\n        ) {\n          relativePath = pteResult.relativePath\n        }\n      }\n    })\n\n    // Update the relative path if the array item is selected\n    // this is specifically done for the case where the array of objects is not nested (exists in the root of the document)\n    if (isArrayItemSelected(itemPath, openPath) && !isReferenceSchemaType(itemSchemaField?.type)) {\n      relativePath = getRelativePath(itemPath)\n    }\n\n    // In cases of primitive types, we don't want to show the menu items\n    // the menu items were used for the breadcrumbs for sibling navigation but it's not something we want to use right now explicitly\n    if (!isPrimitiveSchemaType(itemSchemaField?.type)) {\n      menuItems.push({\n        children: childrenMenuItems,\n        parentSchemaType: arraySchemaType,\n        path: itemPath as Path,\n        schemaType: itemSchemaField as ObjectSchemaType,\n        value: item,\n      })\n    }\n  })\n\n  // Final check: if relativePath points to a non-existent item, point to the parent array instead\n  // This handles new item creation and is especially important in deeply nested structures\n  // This prevents the dialog from attempting to navigate when the new key is not ready yet\n  relativePath = validateRelativePathExists(relativePath, documentValue) as Path\n\n  return {\n    breadcrumbs,\n    menuItems,\n    relativePath,\n    rootTitle: '',\n    siblings,\n  }\n}",
            "cost": 0.112985
        },
        "sanity-io__sanity.615e6c01/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayStatePTE.ts": {
            "output": "import {\n  type ArraySchemaType,\n  isArrayOfBlocksSchemaType,\n  isArrayOfObjectsSchemaType,\n  isKeySegment,\n  isObjectSchemaType,\n  isReferenceSchemaType,\n  type ObjectField,\n  type ObjectSchemaType,\n  type Path,\n  type SchemaType,\n} from '@sanity/types'\nimport {startsWith} from '@sanity/util/paths'\n\nimport {getValueAtPath, pathToString} from '../../../../../field/paths/helpers'\nimport {EMPTY_ARRAY} from '../../../../../util/empty'\nimport {getItemType} from '../../../../store/utils/getItemType'\nimport {type DialogItem} from '../../types'\nimport {hasCustomInputComponent} from '../hasCustomInputComponent'\nimport {isPathTextInPTEField} from '../isPathTextInPTEField'\nimport {buildBreadcrumbsState} from './buildBreadcrumbsState'\nimport {type RecursiveProps, type TreeEditingState} from './buildTreeEditingState'\nimport {\n  getRelativePath,\n  isArrayItemSelected,\n  shouldBeInBreadcrumb,\n  shouldSkipSiblingCount,\n  validateRelativePathExists,\n} from './utils'\n\ninterface BuildArrayStatePTEProps {\n  /** The child field that is a portable text editor */\n  childField: ObjectField<SchemaType>\n  /** The child path to the portable text field */\n  childPath: Path\n  /** The value of the portable text field */\n  childValue: unknown\n  /** The value of the document */\n  documentValue: unknown\n  /** The current `openPath` */\n  openPath: Path\n  /** The recursive function to build the tree editing state for nested fields */\n  recursive: (props: RecursiveProps) => TreeEditingState\n  /** The root schema type to check for portable text fields */\n  rootSchemaType: ObjectSchemaType\n  /** The breadcrumbs array to add to */\n  breadcrumbs: DialogItem[]\n  /** The children menu items array to add to */\n  childrenMenuItems: DialogItem[]\n}\n\n/**\n * Build the state for a Portable Text Editor field.\n * This handles the special case of portable text blocks and their nested array fields.\n */\nexport function buildArrayStatePTE(props: BuildArrayStatePTEProps): {\n  relativePath: Path | null\n  breadcrumbs: DialogItem[]\n  childrenMenuItems: DialogItem[]\n  /** Map of path strings to their sibling arrays (including non-editable items, for example references)\n   * Starts at 1\n   */\n  siblings: Map<string, {count: number; index: number}>\n} {\n  const {\n    childField,\n    childPath,\n    childValue,\n    documentValue,\n    openPath,\n    recursive,\n    rootSchemaType,\n    breadcrumbs,\n    childrenMenuItems,\n  } = props\n\n  let relativePath: Path | null = null\n  const siblings = new Map<string, {count: number; index: number}>()\n\n  // Ensure we have an array to work with, even if empty\n  const portableTextValue = Array.isArray(childValue) ? childValue : []\n\n  // If openPath points to text content within this portable text field, we still need to process\n  // the PTE to build siblings for nested arrays, but we won't set a relativePath\n  const isTextContent = isPathTextInPTEField(rootSchemaType.fields, openPath, documentValue)\n  if (isTextContent) {\n    return {\n      breadcrumbs,\n      childrenMenuItems,\n      siblings,\n      relativePath: null,\n    }\n  }\n  // Process blocks within portable text\n  portableTextValue.forEach((block: unknown) => {\n    const blockObj = block as Record<string, unknown>\n    if (!blockObj._key || !blockObj._type) return\n\n    // Skip regular text blocks - only process custom object blocks\n    if (blockObj._type === 'block') return\n\n    const blockPath = [...childPath, {_key: blockObj._key}] as Path\n\n    // Get the block's schema type to check for custom components\n    const blockSchemaType = (childField.type as ArraySchemaType).of\n      ? getItemType(childField.type as ArraySchemaType, blockObj)\n      : null\n\n    if (!blockSchemaType) return\n\n    if (!blockSchemaType || !isObjectSchemaType(blockSchemaType)) return\n    if (!blockSchemaType.fields) return\n\n    // Skip references early, references are handled by the reference input and shouldn't open the enhanced dialog\n    if (isReferenceSchemaType(blockSchemaType)) return\n\n    // Check if openPath points to this block (for direct block editing like images)\n    // Set relativePath if openPath points directly to this block\n    if (isArrayItemSelected(blockPath, openPath)) {\n      relativePath = getRelativePath(blockPath)\n    }\n\n    // Add breadcrumb for the block if openPath starts with this block path\n    // This handles both direct block selection and nested paths within the block\n    const openPathStartsWithBlock = startsWith(blockPath, openPath)\n\n    if (\n      openPathStartsWithBlock &&\n      shouldBeInBreadcrumb(blockPath, openPath, documentValue) &&\n      !hasCustomInputComponent(rootSchemaType.fields, blockPath)\n    ) {\n      const blockBreadcrumb: DialogItem = {\n        children: EMPTY_ARRAY,\n        parentSchemaType: childField.type as ArraySchemaType,\n        path: blockPath,\n        schemaType: blockSchemaType,\n        value: blockObj,\n      }\n      breadcrumbs.push(blockBreadcrumb)\n    }\n\n    // Collect nested menu items for this block\n    const blockChildrenMenuItems: DialogItem[] = []\n\n    // Process array fields within the block\n    blockSchemaType.fields.forEach((blockField) => {\n      if (\n        isArrayOfObjectsSchemaType(blockField.type) &&\n        !isArrayOfBlocksSchemaType(blockField.type)\n      ) {\n        const blockFieldPath = [...blockPath, blockField.name] as Path\n        const blockFieldValue = getValueAtPath(documentValue, blockFieldPath)\n\n        // If it points to the block itself (in which case we redirect to the first array field)\n        // - this is the case for more nested levels of the PTE\n        const openPathPointsToArrayField = startsWith(blockFieldPath, openPath)\n\n        // This prevents overriding the block-level relativePath set above which is meant to be more general\n        if (openPathPointsToArrayField) {\n          // Check if openPath points to a reference item within this array\n          // References handle their own UI and shouldn't open the enhanced dialog\n          const lastSegment = openPath[openPath.length - 1]\n\n          if (isKeySegment(lastSegment)) {\n            // openPath points to a specific item in the array, check if it's a reference\n            // because if it is a reference, we don't want to set relativePath to open / keep the enhanced dialog open\n            const arrayFieldValue = Array.isArray(blockFieldValue) ? blockFieldValue : []\n            const targetItem = arrayFieldValue.find(\n              (item: unknown) =>\n                item &&\n                typeof item === 'object' &&\n                '_key' in item &&\n                item._key === lastSegment._key,\n            )\n\n            const itemSchemaType = targetItem\n              ? getItemType(blockField.type as ArraySchemaType, targetItem)\n              : null\n\n            // Skip setting relativePath for references\n            if (itemSchemaType && isReferenceSchemaType(itemSchemaType)) return\n          }\n\n          // Use openPath as relativePath for more precise targeting\n          // meaning that we in fact want to go deeper into the nested structure\n          relativePath = getRelativePath(openPath)\n          // Process array fields even if they're empty (for new blocks)\n          // But ensure the value is at least an empty array for processing\n          const arrayFieldValue = Array.isArray(blockFieldValue) ? blockFieldValue : []\n\n          if (\n            shouldBeInBreadcrumb(blockFieldPath, openPath, documentValue) &&\n            !hasCustomInputComponent(rootSchemaType.fields, blockFieldPath)\n          ) {\n            const breadcrumbsResult = buildBreadcrumbsState({\n              arraySchemaType: blockField.type as ArraySchemaType,\n              arrayValue: arrayFieldValue as Record<string, unknown>[],\n              itemPath: blockFieldPath,\n              parentPath: blockPath,\n            })\n            breadcrumbs.push(breadcrumbsResult)\n          }\n\n          // Build nested structure\n          const blockFieldState = recursive({\n            documentValue,\n            path: blockFieldPath,\n            schemaType: blockField as ObjectSchemaType,\n          })\n\n          // Merge sibling counts from nested state\n          const blockFieldPathString = pathToString(blockFieldPath)\n\n          // If it's an inline custom object/object array/span, skip siblings\n          const skipChildren = shouldSkipSiblingCount({\n            arraySchemaType: childField.type as ArraySchemaType,\n            fieldPath: blockFieldPath,\n          })\n\n          blockFieldState.siblings.forEach((info, pathString) => {\n            if (skipChildren && pathString === blockFieldPathString) return\n            siblings.set(pathString, info)\n          })\n\n          blockChildrenMenuItems.push({\n            children: blockFieldState?.menuItems || EMPTY_ARRAY,\n            parentSchemaType: blockSchemaType,\n            path: blockFieldPath,\n            schemaType: blockField as ObjectSchemaType,\n            value: arrayFieldValue,\n          })\n        }\n      }\n    })\n\n    if (isObjectSchemaType(blockSchemaType)) {\n      // Add this block as a menu item (similar to how buildArrayState adds array items)\n      childrenMenuItems.push({\n        children: blockChildrenMenuItems,\n        parentSchemaType: childField.type as ArraySchemaType,\n        path: blockPath,\n        schemaType: blockSchemaType,\n        value: blockObj,\n      })\n    }\n  })\n\n  // Final check: if relativePath points to a non-existent item, point to the parent array instead\n  // This handles new item creation (in portable text arrays) and is especially important in deeply nested level\n  // This prevents the dialog from attempting to navigate when the new key is not ready yet\n  // This is for deeply nested PTEs\n  relativePath = validateRelativePathExists(relativePath, documentValue)\n\n  return {\n    relativePath: isTextContent ? null : relativePath,\n    breadcrumbs,\n    childrenMenuItems,\n    siblings,\n  }\n}",
            "output_extracted": "import {\n  type ArraySchemaType,\n  isArrayOfBlocksSchemaType,\n  isArrayOfObjectsSchemaType,\n  isKeySegment,\n  isObjectSchemaType,\n  isReferenceSchemaType,\n  type ObjectField,\n  type ObjectSchemaType,\n  type Path,\n  type SchemaType,\n} from '@sanity/types'\nimport {startsWith} from '@sanity/util/paths'\n\nimport {getValueAtPath, pathToString} from '../../../../../field/paths/helpers'\nimport {EMPTY_ARRAY} from '../../../../../util/empty'\nimport {getItemType} from '../../../../store/utils/getItemType'\nimport {type DialogItem} from '../../types'\nimport {hasCustomInputComponent} from '../hasCustomInputComponent'\nimport {isPathTextInPTEField} from '../isPathTextInPTEField'\nimport {buildBreadcrumbsState} from './buildBreadcrumbsState'\nimport {type RecursiveProps, type TreeEditingState} from './buildTreeEditingState'\nimport {\n  getRelativePath,\n  isArrayItemSelected,\n  shouldBeInBreadcrumb,\n  shouldSkipSiblingCount,\n  validateRelativePathExists,\n} from './utils'\n\ninterface BuildArrayStatePTEProps {\n  /** The child field that is a portable text editor */\n  childField: ObjectField<SchemaType>\n  /** The child path to the portable text field */\n  childPath: Path\n  /** The value of the portable text field */\n  childValue: unknown\n  /** The value of the document */\n  documentValue: unknown\n  /** The current `openPath` */\n  openPath: Path\n  /** The recursive function to build the tree editing state for nested fields */\n  recursive: (props: RecursiveProps) => TreeEditingState\n  /** The root schema type to check for portable text fields */\n  rootSchemaType: ObjectSchemaType\n  /** The breadcrumbs array to add to */\n  breadcrumbs: DialogItem[]\n  /** The children menu items array to add to */\n  childrenMenuItems: DialogItem[]\n}\n\n/**\n * Build the state for a Portable Text Editor field.\n * This handles the special case of portable text blocks and their nested array fields.\n */\nexport function buildArrayStatePTE(props: BuildArrayStatePTEProps): {\n  relativePath: Path | null\n  breadcrumbs: DialogItem[]\n  childrenMenuItems: DialogItem[]\n  /** Map of path strings to their sibling arrays (including non-editable items, for example references)\n   * Starts at 1\n   */\n  siblings: Map<string, {count: number; index: number}>\n} {\n  const {\n    childField,\n    childPath,\n    childValue,\n    documentValue,\n    openPath,\n    recursive,\n    rootSchemaType,\n    breadcrumbs,\n    childrenMenuItems,\n  } = props\n\n  let relativePath: Path | null = null\n  const siblings = new Map<string, {count: number; index: number}>()\n\n  // Ensure we have an array to work with, even if empty\n  const portableTextValue = Array.isArray(childValue) ? childValue : []\n\n  // If openPath points to text content within this portable text field, we still need to process\n  // the PTE to build siblings for nested arrays, but we won't set a relativePath\n  const isTextContent = isPathTextInPTEField(rootSchemaType.fields, openPath, documentValue)\n  if (isTextContent) {\n    return {\n      breadcrumbs,\n      childrenMenuItems,\n      siblings,\n      relativePath: null,\n    }\n  }\n  // Process blocks within portable text\n  portableTextValue.forEach((block: unknown) => {\n    const blockObj = block as Record<string, unknown>\n    if (!blockObj._key || !blockObj._type) return\n\n    // Skip regular text blocks - only process custom object blocks\n    if (blockObj._type === 'block') return\n\n    const blockPath = [...childPath, {_key: blockObj._key}] as Path\n\n    // Get the block's schema type to check for custom components\n    const blockSchemaType = (childField.type as ArraySchemaType).of\n      ? getItemType(childField.type as ArraySchemaType, blockObj)\n      : null\n\n    if (!blockSchemaType) return\n\n    if (!blockSchemaType || !isObjectSchemaType(blockSchemaType)) return\n    if (!blockSchemaType.fields) return\n\n    // Skip references early, references are handled by the reference input and shouldn't open the enhanced dialog\n    if (isReferenceSchemaType(blockSchemaType)) return\n\n    // Check if openPath points to this block (for direct block editing like images)\n    // Set relativePath if openPath points directly to this block\n    if (isArrayItemSelected(blockPath, openPath)) {\n      relativePath = getRelativePath(blockPath)\n    }\n\n    // Add breadcrumb for the block if openPath starts with this block path\n    // This handles both direct block selection and nested paths within the block\n    const openPathStartsWithBlock = startsWith(blockPath, openPath)\n\n    if (\n      openPathStartsWithBlock &&\n      shouldBeInBreadcrumb(blockPath, openPath, documentValue) &&\n      !hasCustomInputComponent(rootSchemaType.fields, blockPath)\n    ) {\n      const blockBreadcrumb: DialogItem = {\n        children: EMPTY_ARRAY,\n        parentSchemaType: childField.type as ArraySchemaType,\n        path: blockPath,\n        schemaType: blockSchemaType,\n        value: blockObj,\n      }\n      breadcrumbs.push(blockBreadcrumb)\n    }\n\n    // Collect nested menu items for this block\n    const blockChildrenMenuItems: DialogItem[] = []\n\n    // Process array fields within the block\n    blockSchemaType.fields.forEach((blockField) => {\n      if (\n        isArrayOfObjectsSchemaType(blockField.type) &&\n        !isArrayOfBlocksSchemaType(blockField.type)\n      ) {\n        const blockFieldPath = [...blockPath, blockField.name] as Path\n        const blockFieldValue = getValueAtPath(documentValue, blockFieldPath)\n\n        // If it points to the block itself (in which case we redirect to the first array field)\n        // - this is the case for more nested levels of the PTE\n        const openPathPointsToArrayField = startsWith(blockFieldPath, openPath)\n\n        // This prevents overriding the block-level relativePath set above which is meant to be more general\n        if (openPathPointsToArrayField) {\n          // Check if openPath points to a reference item within this array\n          // References handle their own UI and shouldn't open the enhanced dialog\n          const lastSegment = openPath[openPath.length - 1]\n\n          if (isKeySegment(lastSegment)) {\n            // openPath points to a specific item in the array, check if it's a reference\n            // because if it is a reference, we don't want to set relativePath to open / keep the enhanced dialog open\n            const arrayFieldValue = Array.isArray(blockFieldValue) ? blockFieldValue : []\n            const targetItem = arrayFieldValue.find(\n              (item: unknown) =>\n                item &&\n                typeof item === 'object' &&\n                '_key' in item &&\n                item._key === lastSegment._key,\n            )\n\n            const itemSchemaType = targetItem\n              ? getItemType(blockField.type as ArraySchemaType, targetItem)\n              : null\n\n            // Skip setting relativePath for references\n            if (itemSchemaType && isReferenceSchemaType(itemSchemaType)) return\n          }\n\n          // Use openPath as relativePath for more precise targeting\n          // meaning that we in fact want to go deeper into the nested structure\n          relativePath = getRelativePath(openPath)\n          // Process array fields even if they're empty (for new blocks)\n          // But ensure the value is at least an empty array for processing\n          const arrayFieldValue = Array.isArray(blockFieldValue) ? blockFieldValue : []\n\n          if (\n            shouldBeInBreadcrumb(blockFieldPath, openPath, documentValue) &&\n            !hasCustomInputComponent(rootSchemaType.fields, blockFieldPath)\n          ) {\n            const breadcrumbsResult = buildBreadcrumbsState({\n              arraySchemaType: blockField.type as ArraySchemaType,\n              arrayValue: arrayFieldValue as Record<string, unknown>[],\n              itemPath: blockFieldPath,\n              parentPath: blockPath,\n            })\n            breadcrumbs.push(breadcrumbsResult)\n          }\n\n          // Build nested structure\n          const blockFieldState = recursive({\n            documentValue,\n            path: blockFieldPath,\n            schemaType: blockField as ObjectSchemaType,\n          })\n\n          // Merge sibling counts from nested state\n          const blockFieldPathString = pathToString(blockFieldPath)\n\n          // If it's an inline custom object/object array/span, skip siblings\n          const skipChildren = shouldSkipSiblingCount({\n            arraySchemaType: childField.type as ArraySchemaType,\n            fieldPath: blockFieldPath,\n          })\n\n          blockFieldState.siblings.forEach((info, pathString) => {\n            if (skipChildren && pathString === blockFieldPathString) return\n            siblings.set(pathString, info)\n          })\n\n          blockChildrenMenuItems.push({\n            children: blockFieldState?.menuItems || EMPTY_ARRAY,\n            parentSchemaType: blockSchemaType,\n            path: blockFieldPath,\n            schemaType: blockField as ObjectSchemaType,\n            value: arrayFieldValue,\n          })\n        }\n      }\n    })\n\n    if (isObjectSchemaType(blockSchemaType)) {\n      // Add this block as a menu item (similar to how buildArrayState adds array items)\n      childrenMenuItems.push({\n        children: blockChildrenMenuItems,\n        parentSchemaType: childField.type as ArraySchemaType,\n        path: blockPath,\n        schemaType: blockSchemaType,\n        value: blockObj,\n      })\n    }\n  })\n\n  // Final check: if relativePath points to a non-existent item, point to the parent array instead\n  // This handles new item creation (in portable text arrays) and is especially important in deeply nested level\n  // This prevents the dialog from attempting to navigate when the new key is not ready yet\n  // This is for deeply nested PTEs\n  relativePath = validateRelativePathExists(relativePath, documentValue)\n\n  return {\n    relativePath: isTextContent ? null : relativePath,\n    breadcrumbs,\n    childrenMenuItems,\n    siblings,\n  }\n}",
            "cost": 0.085305
        },
        "sanity-io__sanity.615e6c01/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildTreeEditingState.ts": {
            "output": "import {\n  type ArraySchemaType,\n  isArrayOfObjectsSchemaType,\n  type ObjectSchemaType,\n  type Path,\n} from '@sanity/types'\nimport {toString} from '@sanity/util/paths'\n\nimport {getValueAtPath} from '../../../../../field/paths/helpers'\nimport {getSchemaTypeTitle} from '../../../../../schema/helpers'\nimport {type DialogItem} from '../../types'\nimport {getRootPath} from '../getRootPath'\nimport {getSchemaField} from '../getSchemaField'\nimport {hasCustomInputComponent} from '../hasCustomInputComponent'\nimport {buildArrayState} from './buildArrayState'\n\nconst EMPTY_ARRAY: [] = []\n\nexport const EMPTY_TREE_STATE: TreeEditingState = {\n  breadcrumbs: EMPTY_ARRAY,\n  menuItems: EMPTY_ARRAY,\n  relativePath: EMPTY_ARRAY,\n  rootTitle: '',\n  siblings: new Map(),\n}\n\nexport interface BuildTreeEditingStateProps {\n  schemaType: ObjectSchemaType | ArraySchemaType\n  documentValue: unknown\n  openPath: Path\n}\n\nexport interface TreeEditingState {\n  /** The breadcrumbs for the tree editing state */\n  breadcrumbs: DialogItem[]\n  /** The menu items for the tree editing state */\n  menuItems: DialogItem[]\n  /**\n   * The relative path to the selected item in the tree editing state.\n   * It is used to determine which field to show in the form editor.\n   */\n  relativePath: Path\n  /** The title of the root field */\n  rootTitle: string\n  /** Map of path strings to their sibling arrays (including non-editable items, for example references)\n   * Starts at 1\n   */\n  siblings: Map<string, {count: number; index: number}>\n}\n\nexport interface RecursiveProps extends Omit<BuildTreeEditingStateProps, 'openPath'> {\n  path: Path\n}\n\nexport function buildTreeEditingState(props: BuildTreeEditingStateProps): TreeEditingState {\n  const {openPath} = props\n\n  const rootPath = getRootPath(openPath)\n  const rootField = getSchemaField(props.schemaType, toString(rootPath)) as ObjectSchemaType\n\n  // Safety check: if rootField or rootField.type is undefined, return empty state\n  if (!rootField?.type) {\n    return EMPTY_TREE_STATE\n  }\n\n  const rootTitle = getSchemaTypeTitle(rootField.type as ObjectSchemaType)\n\n  if (!isArrayOfObjectsSchemaType(rootField.type)) {\n    return EMPTY_TREE_STATE\n  }\n\n  let relativePath: Path = []\n  const breadcrumbs: DialogItem[] = []\n\n  const result = recursive({\n    schemaType: rootField,\n    documentValue: props.documentValue,\n    path: rootPath,\n  })\n\n  // If the child array field has custom components.input, skip building dialog\n  // but preserve breadcrumbs, menuItems, and siblings\n  if (hasCustomInputComponent((props.schemaType as ObjectSchemaType).fields || [], openPath)) {\n    const {menuItems, siblings} = result\n    return {\n      relativePath: EMPTY_ARRAY,\n      breadcrumbs,\n      menuItems: menuItems,\n      rootTitle,\n      siblings: siblings,\n    }\n  }\n\n  function recursive(recursiveProps: RecursiveProps): TreeEditingState {\n    const {schemaType, path, documentValue} = recursiveProps\n\n    const value = getValueAtPath(documentValue, path) as Array<Record<string, unknown>>\n    const arrayValue = Array.isArray(value) ? value : EMPTY_ARRAY\n    const arraySchemaType = schemaType?.type as ArraySchemaType\n\n    const arrayState = buildArrayState({\n      arraySchemaType,\n      arrayValue,\n      documentValue,\n      openPath,\n      // Pass the recursive function to the buildArrayState function\n      // to allow for recursive calls in the array items.\n      recursive,\n      rootPath: path,\n      // Needed in order to keep track of portable text fields and its items types\n      rootSchemaType: props.schemaType as ObjectSchemaType,\n    })\n\n    if (arrayState.relativePath.length > 0) {\n      relativePath = arrayState.relativePath\n    }\n\n    breadcrumbs.unshift(...arrayState.breadcrumbs)\n\n    return arrayState\n  }\n\n  return {\n    relativePath,\n    breadcrumbs,\n    menuItems: result.menuItems,\n    rootTitle,\n    siblings: result.siblings,\n  }\n}",
            "output_extracted": "import {\n  type ArraySchemaType,\n  isArrayOfObjectsSchemaType,\n  type ObjectSchemaType,\n  type Path,\n} from '@sanity/types'\nimport {toString} from '@sanity/util/paths'\n\nimport {getValueAtPath} from '../../../../../field/paths/helpers'\nimport {getSchemaTypeTitle} from '../../../../../schema/helpers'\nimport {type DialogItem} from '../../types'\nimport {getRootPath} from '../getRootPath'\nimport {getSchemaField} from '../getSchemaField'\nimport {hasCustomInputComponent} from '../hasCustomInputComponent'\nimport {buildArrayState} from './buildArrayState'\n\nconst EMPTY_ARRAY: [] = []\n\nexport const EMPTY_TREE_STATE: TreeEditingState = {\n  breadcrumbs: EMPTY_ARRAY,\n  menuItems: EMPTY_ARRAY,\n  relativePath: EMPTY_ARRAY,\n  rootTitle: '',\n  siblings: new Map(),\n}\n\nexport interface BuildTreeEditingStateProps {\n  schemaType: ObjectSchemaType | ArraySchemaType\n  documentValue: unknown\n  openPath: Path\n}\n\nexport interface TreeEditingState {\n  /** The breadcrumbs for the tree editing state */\n  breadcrumbs: DialogItem[]\n  /** The menu items for the tree editing state */\n  menuItems: DialogItem[]\n  /**\n   * The relative path to the selected item in the tree editing state.\n   * It is used to determine which field to show in the form editor.\n   */\n  relativePath: Path\n  /** The title of the root field */\n  rootTitle: string\n  /** Map of path strings to their sibling arrays (including non-editable items, for example references)\n   * Starts at 1\n   */\n  siblings: Map<string, {count: number; index: number}>\n}\n\nexport interface RecursiveProps extends Omit<BuildTreeEditingStateProps, 'openPath'> {\n  path: Path\n}\n\nexport function buildTreeEditingState(props: BuildTreeEditingStateProps): TreeEditingState {\n  const {openPath} = props\n\n  const rootPath = getRootPath(openPath)\n  const rootField = getSchemaField(props.schemaType, toString(rootPath)) as ObjectSchemaType\n\n  // Safety check: if rootField or rootField.type is undefined, return empty state\n  if (!rootField?.type) {\n    return EMPTY_TREE_STATE\n  }\n\n  const rootTitle = getSchemaTypeTitle(rootField.type as ObjectSchemaType)\n\n  if (!isArrayOfObjectsSchemaType(rootField.type)) {\n    return EMPTY_TREE_STATE\n  }\n\n  let relativePath: Path = []\n  const breadcrumbs: DialogItem[] = []\n\n  const result = recursive({\n    schemaType: rootField,\n    documentValue: props.documentValue,\n    path: rootPath,\n  })\n\n  // If the child array field has custom components.input, skip building dialog\n  // but preserve breadcrumbs, menuItems, and siblings\n  if (hasCustomInputComponent((props.schemaType as ObjectSchemaType).fields || [], openPath)) {\n    const {menuItems, siblings} = result\n    return {\n      relativePath: EMPTY_ARRAY,\n      breadcrumbs,\n      menuItems: menuItems,\n      rootTitle,\n      siblings: siblings,\n    }\n  }\n\n  function recursive(recursiveProps: RecursiveProps): TreeEditingState {\n    const {schemaType, path, documentValue} = recursiveProps\n\n    const value = getValueAtPath(documentValue, path) as Array<Record<string, unknown>>\n    const arrayValue = Array.isArray(value) ? value : EMPTY_ARRAY\n    const arraySchemaType = schemaType?.type as ArraySchemaType\n\n    const arrayState = buildArrayState({\n      arraySchemaType,\n      arrayValue,\n      documentValue,\n      openPath,\n      // Pass the recursive function to the buildArrayState function\n      // to allow for recursive calls in the array items.\n      recursive,\n      rootPath: path,\n      // Needed in order to keep track of portable text fields and its items types\n      rootSchemaType: props.schemaType as ObjectSchemaType,\n    })\n\n    if (arrayState.relativePath.length > 0) {\n      relativePath = arrayState.relativePath\n    }\n\n    breadcrumbs.unshift(...arrayState.breadcrumbs)\n\n    return arrayState\n  }\n\n  return {\n    relativePath,\n    breadcrumbs,\n    menuItems: result.menuItems,\n    rootTitle,\n    siblings: result.siblings,\n  }\n}",
            "cost": 0.0393
        },
        "sanity-io__sanity.615e6c01/packages/sanity/src/core/form/useDocumentForm.ts": {
            "output": "/* eslint-disable max-statements */\nimport {type SanityDocument} from '@sanity/client'\nimport {isActionEnabled} from '@sanity/schema/_internal'\nimport {useTelemetry} from '@sanity/telemetry/react'\nimport {\n  isKeySegment,\n  type ObjectSchemaType,\n  type Path,\n  type SanityDocumentLike,\n  type ValidationMarker,\n} from '@sanity/types'\nimport {pathFor} from '@sanity/util/paths'\nimport {throttle} from 'lodash'\nimport {type RefObject, useEffect, useInsertionEffect, useMemo, useRef, useState} from 'react'\nimport deepEquals from 'react-fast-compare'\n\nimport {useCanvasCompanionDoc} from '../canvas/actions/useCanvasCompanionDoc'\nimport {isSanityCreateLinkedDocument} from '../create/createUtils'\nimport {useReconnectingToast} from '../hooks'\nimport {type ConnectionState, useConnectionState} from '../hooks/useConnectionState'\nimport {useDocumentIdStack} from '../hooks/useDocumentIdStack'\nimport {useDocumentOperation} from '../hooks/useDocumentOperation'\nimport {useEditState} from '../hooks/useEditState'\nimport {useSchema} from '../hooks/useSchema'\nimport {useValidationStatus} from '../hooks/useValidationStatus'\nimport {getSelectedPerspective} from '../perspective/getSelectedPerspective'\nimport {type ReleaseId} from '../perspective/types'\nimport {useDocumentVersions} from '../releases/hooks/useDocumentVersions'\nimport {useDocumentVersionTypeSortedList} from '../releases/hooks/useDocumentVersionTypeSortedList'\nimport {useOnlyHasVersions} from '../releases/hooks/useOnlyHasVersions'\nimport {isReleaseDocument} from '../releases/store/types'\nimport {useActiveReleases} from '../releases/store/useActiveReleases'\nimport {getReleaseIdFromReleaseDocumentId} from '../releases/util/getReleaseIdFromReleaseDocumentId'\nimport {isGoingToUnpublish} from '../releases/util/isGoingToUnpublish'\nimport {isPublishedPerspective, isReleaseScheduledOrScheduling} from '../releases/util/util'\nimport {\n  type DocumentPresence,\n  type EditStateFor,\n  type InitialValueState,\n  type PermissionCheckResult,\n  selectUpstreamVersion,\n  useDocumentValuePermissions,\n  usePresenceStore,\n} from '../store'\nimport {isNewDocument} from '../store/_legacy/document/isNewDocument'\nimport {useWorkspace} from '../studio/workspace'\nimport {\n  EMPTY_ARRAY,\n  getDraftId,\n  getPublishedId,\n  getVersionFromId,\n  getVersionId,\n  useUnique,\n} from '../util'\nimport {\n  type FormState,\n  getExpandOperations,\n  type NodeChronologyProps,\n  type OnPathFocusPayload,\n  type PatchEvent,\n  setAtPath,\n  type StateTree,\n  toMutationPatches,\n  useFormState,\n} from '.'\nimport {CreatedDraft} from './__telemetry__/form.telemetry'\nimport {useComlinkViewHistory} from './useComlinkViewHistory'\n\ninterface DocumentFormOptions {\n  documentType: string\n  documentId: string\n  releaseId?: ReleaseId\n  initialValue?: InitialValueState\n  initialFocusPath?: Path\n  selectedPerspectiveName?: ReleaseId | 'published'\n  readOnly?: boolean | ((editState: EditStateFor) => boolean)\n  /**\n   * Usually the historical _rev value selected, if not defined, it will use the current document value\n   * so no comparison will be done.\n   */\n  comparisonValue?:\n    | Partial<SanityDocument>\n    | ((editState: EditStateFor) => Partial<SanityDocument>)\n    | null\n  onFocusPath?: (path: Path) => void\n  changesOpen?: boolean\n  /**\n   * Callback that allows to transform the value before it's passed to the form\n   * used by the <DocumentPaneProvider > to display the history values.\n   */\n  getFormDocumentValue?: (value: SanityDocumentLike) => SanityDocumentLike\n  displayInlineChanges?: boolean\n}\ninterface DocumentFormValue extends Pick<NodeChronologyProps, 'hasUpstreamVersion'> {\n  /**\n   * `EditStateFor` for the displayed document.\n   * */\n  editState: EditStateFor\n  /**\n   *  `EditStateFor` for the displayed document's upstream version.\n   */\n  upstreamEditState: EditStateFor\n  connectionState: ConnectionState\n  collapsedFieldSets: StateTree<boolean> | undefined\n  collapsedPaths: StateTree<boolean> | undefined\n  openPath: Path\n\n  ready: boolean\n  value: SanityDocumentLike\n  formState: FormState\n  focusPath: Path\n  validation: ValidationMarker[]\n  permissions: PermissionCheckResult | undefined\n  isPermissionsLoading: boolean\n  onBlur: (blurredPath: Path) => void\n  onFocus: (_nextFocusPath: Path, payload?: OnPathFocusPayload) => void\n  onSetCollapsedPath: (path: Path, collapsed: boolean) => void\n  onSetActiveFieldGroup: (path: Path, groupName: string) => void\n  onSetCollapsedFieldSet: (path: Path, collapsed: boolean) => void\n  onChange: (event: PatchEvent) => void\n  onPathOpen: (path: Path) => void\n  onProgrammaticFocus: (nextPath: Path) => void\n  formStateRef: RefObject<FormState>\n  schemaType: ObjectSchemaType\n}\n\n/**\n * @internal\n * Hook for creating a form state and combine it with the <FormBuilder>.\n * It will handle the connection state, edit state, validation, and presence.\n *\n * Use this as a base point to create your own form.\n */\nexport function useDocumentForm(options: DocumentFormOptions): DocumentFormValue {\n  const {\n    documentType,\n    getFormDocumentValue,\n    documentId,\n    initialValue,\n    changesOpen = false,\n    comparisonValue: comparisonValueRaw,\n    releaseId,\n    initialFocusPath,\n    selectedPerspectiveName,\n    readOnly: readOnlyProp,\n    onFocusPath,\n    displayInlineChanges,\n  } = options\n  const schema = useSchema()\n  const presenceStore = usePresenceStore()\n  const {data: releases} = useActiveReleases()\n  const {data: documentVersions} = useDocumentVersions({documentId})\n  const workspace = useWorkspace()\n\n  const enhancedObjectDialogEnabled = workspace.beta?.form?.enhancedObjectDialog?.enabled\n\n  const schemaType = schema.get(documentType) as ObjectSchemaType | undefined\n  if (!schemaType) {\n    throw new Error(`Schema type for '${documentType}' not found`)\n  }\n  const liveEdit = Boolean(schemaType.liveEdit)\n  const publishedId = getPublishedId(documentId)\n\n  const telemetry = useTelemetry()\n\n  // if it only has versions then we need to make sure that whatever the first document that is allowed\n  // is a version document, but also that it has the right order\n  // this will make sure that then the right document appears and so does the right chip within the document header\n  const {sortedDocumentList} = useDocumentVersionTypeSortedList({documentId})\n  const onlyHasVersions = useOnlyHasVersions({documentId})\n  const firstVersion =\n    sortedDocumentList.length > 0\n      ? documentVersions.find(\n          (id) =>\n            getVersionFromId(id) === getReleaseIdFromReleaseDocumentId(sortedDocumentList[0]._id),\n        )\n      : undefined\n\n  const activeDocumentReleaseId = useMemo(() => {\n    // if a document version exists with the selected release id, then it should use that\n    if (documentVersions.some((id) => getVersionFromId(id) === releaseId)) {\n      return releaseId\n    }\n\n    // check if the selected version is the only version, if it isn't and it doesn't exist in the release\n    // then it needs to use the documentVersions\n    if (releaseId && (!documentVersions || !onlyHasVersions)) {\n      return releaseId\n    }\n\n    return getVersionFromId(firstVersion ?? '')\n  }, [documentVersions, onlyHasVersions, releaseId, firstVersion])\n\n  const editState = useEditState(documentId, documentType, 'default', activeDocumentReleaseId)\n\n  const connectionState = useConnectionState(documentId, documentType, releaseId)\n  useReconnectingToast(connectionState === 'reconnecting')\n\n  const [focusPath, setFocusPath] = useState<Path>(initialFocusPath || EMPTY_ARRAY)\n\n  const value: SanityDocumentLike = useMemo(() => {\n    const baseValue = initialValue?.value || {_id: documentId, _type: documentType}\n    if (releaseId) {\n      // in cases where the current version is going to be unpublished, we need to show the published document\n      // this way, instead of showing the version that will stop existing, we show instead the published document with a fall back\n      if (editState.version && isGoingToUnpublish(editState.version)) {\n        return editState.published || baseValue\n      }\n      return editState.version || editState.draft || editState.published || baseValue\n    }\n    if (selectedPerspectiveName && isPublishedPerspective(selectedPerspectiveName)) {\n      return (\n        editState.published ||\n        (liveEdit\n          ? // If it's live edit and published perspective, add the initialValue\n            baseValue\n          : // If it's not live edit, the form needs to be empty in the draft state, don't show the initialValue\n            {_id: documentId, _type: documentType})\n      )\n    }\n    // if no version is selected, but there is only version, it should default to the version it finds\n    if (!selectedPerspectiveName && onlyHasVersions) {\n      return editState.version || editState.draft || editState.published || baseValue\n    }\n    return editState?.draft || editState?.published || baseValue\n  }, [\n    documentId,\n    documentType,\n    editState.draft,\n    editState.published,\n    editState.version,\n    initialValue,\n    liveEdit,\n    releaseId,\n    selectedPerspectiveName,\n    onlyHasVersions,\n  ])\n\n  const {validation: validationRaw} = useValidationStatus(value._id, documentType, releaseId)\n  const validation = useUnique(validationRaw)\n\n  const {previousId: upstreamId} = useDocumentIdStack({\n    strict: true,\n    displayed: value,\n    documentId,\n    editState,\n  })\n\n  const upstreamEditState = useEditState(\n    documentId,\n    documentType,\n    'low',\n    getVersionFromId(upstreamId ?? ''),\n  )\n\n  const comparisonValue = useMemo(() => {\n    if (typeof comparisonValueRaw === 'function') {\n      return comparisonValueRaw(upstreamEditState)\n    }\n    return comparisonValueRaw\n  }, [comparisonValueRaw, upstreamEditState])\n\n  const [presence, setPresence] = useState<DocumentPresence[]>([])\n  useEffect(() => {\n    const subscription = presenceStore\n      .documentPresence(value._id, {excludeVersions: true})\n      .subscribe((nextPresence) => {\n        setPresence(nextPresence)\n      })\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [presenceStore, value._id])\n\n  const [openPath, onSetOpenPath] = useState<Path>(EMPTY_ARRAY)\n  const [fieldGroupState, onSetFieldGroupState] = useState<StateTree<string>>()\n  const [collapsedPaths, onSetCollapsedPath] = useState<StateTree<boolean>>()\n  const [collapsedFieldSets, onSetCollapsedFieldSets] = useState<StateTree<boolean>>()\n\n  const handleOnSetCollapsedPath = (path: Path, collapsed: boolean) => {\n    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed))\n  }\n\n  const handleOnSetCollapsedFieldSet = (path: Path, collapsed: boolean) => {\n    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed))\n  }\n\n  const handleSetActiveFieldGroup = (path: Path, groupName: string) =>\n    onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName))\n\n  const requiredPermission = value._createdAt ? 'update' : 'create'\n  const targetDocumentId = releaseId\n    ? getVersionId(publishedId, releaseId)\n    : // in cases where there is a draft in a live edit, we need to use it so that it can be published\n      // in case if the user has permissions to do so otherwise just use the published id\n      liveEdit\n      ? editState?.draft?._id || publishedId\n      : getDraftId(documentId)\n  const docPermissionsInput = useMemo(() => {\n    return {\n      ...value,\n      _id: targetDocumentId,\n    }\n  }, [value, targetDocumentId])\n\n  const [permissions, isPermissionsLoading] = useDocumentValuePermissions({\n    document: docPermissionsInput,\n    permission: requiredPermission,\n  })\n\n  const isNonExistent = !value?._id\n  const isCreateLinked = isSanityCreateLinkedDocument(value)\n\n  const ready = connectionState === 'connected' && editState.ready && !initialValue?.loading\n\n  const selectedPerspective = useMemo(() => {\n    return getSelectedPerspective(selectedPerspectiveName, releases)\n  }, [selectedPerspectiveName, releases])\n\n  const isReleaseLocked = useMemo(\n    () =>\n      isReleaseDocument(selectedPerspective)\n        ? isReleaseScheduledOrScheduling(selectedPerspective)\n        : false,\n    [selectedPerspective],\n  )\n  const {isLinked} = useCanvasCompanionDoc(value._id)\n\n  // eslint-disable-next-line complexity\n  const readOnly = useMemo(() => {\n    const hasNoPermission = !isPermissionsLoading && !permissions?.granted\n    const updateActionDisabled = !isActionEnabled(schemaType!, 'update')\n    const createActionDisabled = isNonExistent && !isActionEnabled(schemaType!, 'create')\n    const reconnecting = connectionState === 'reconnecting'\n    const isLocked = editState.transactionSyncLock?.enabled\n    const willBeUnpublished = value ? isGoingToUnpublish(value) : false\n\n    // in cases where the document has no draft or published, but has a version,\n    // and that version doesn't match current pinned version\n    // we disable editing\n    if (\n      editState.version &&\n      !editState.draft &&\n      !editState.published &&\n      onlyHasVersions &&\n      selectedPerspectiveName !== getVersionFromId(editState.version._id) &&\n      isNewDocument(editState) === false\n    ) {\n      return true\n    }\n\n    // in cases where the document has drafts but the schema is live edit, there is a risk of data loss, so we disable editing in this case\n    if (liveEdit && editState.draft?._id) {\n      return true\n    }\n    if (!liveEdit && selectedPerspectiveName === 'published') {\n      return true\n    }\n\n    // If a release is selected, validate that the document id matches the selected release id.\n    //\n    // If the user is viewing a new document (a document that exists locally, but has not yet been\n    // created in the dataset), they are permitted to edit it, regardless of which perspective was\n    //",
            "output_extracted": "/* eslint-disable max-statements */\nimport {type SanityDocument} from '@sanity/client'\nimport {isActionEnabled} from '@sanity/schema/_internal'\nimport {useTelemetry} from '@sanity/telemetry/react'\nimport {\n  isKeySegment,\n  type ObjectSchemaType,\n  type Path,\n  type SanityDocumentLike,\n  type ValidationMarker,\n} from '@sanity/types'\nimport {pathFor} from '@sanity/util/paths'\nimport {throttle} from 'lodash'\nimport {type RefObject, useEffect, useInsertionEffect, useMemo, useRef, useState} from 'react'\nimport deepEquals from 'react-fast-compare'\n\nimport {useCanvasCompanionDoc} from '../canvas/actions/useCanvasCompanionDoc'\nimport {isSanityCreateLinkedDocument} from '../create/createUtils'\nimport {useReconnectingToast} from '../hooks'\nimport {type ConnectionState, useConnectionState} from '../hooks/useConnectionState'\nimport {useDocumentIdStack} from '../hooks/useDocumentIdStack'\nimport {useDocumentOperation} from '../hooks/useDocumentOperation'\nimport {useEditState} from '../hooks/useEditState'\nimport {useSchema} from '../hooks/useSchema'\nimport {useValidationStatus} from '../hooks/useValidationStatus'\nimport {getSelectedPerspective} from '../perspective/getSelectedPerspective'\nimport {type ReleaseId} from '../perspective/types'\nimport {useDocumentVersions} from '../releases/hooks/useDocumentVersions'\nimport {useDocumentVersionTypeSortedList} from '../releases/hooks/useDocumentVersionTypeSortedList'\nimport {useOnlyHasVersions} from '../releases/hooks/useOnlyHasVersions'\nimport {isReleaseDocument} from '../releases/store/types'\nimport {useActiveReleases} from '../releases/store/useActiveReleases'\nimport {getReleaseIdFromReleaseDocumentId} from '../releases/util/getReleaseIdFromReleaseDocumentId'\nimport {isGoingToUnpublish} from '../releases/util/isGoingToUnpublish'\nimport {isPublishedPerspective, isReleaseScheduledOrScheduling} from '../releases/util/util'\nimport {\n  type DocumentPresence,\n  type EditStateFor,\n  type InitialValueState,\n  type PermissionCheckResult,\n  selectUpstreamVersion,\n  useDocumentValuePermissions,\n  usePresenceStore,\n} from '../store'\nimport {isNewDocument} from '../store/_legacy/document/isNewDocument'\nimport {useWorkspace} from '../studio/workspace'\nimport {\n  EMPTY_ARRAY,\n  getDraftId,\n  getPublishedId,\n  getVersionFromId,\n  getVersionId,\n  useUnique,\n} from '../util'\nimport {\n  type FormState,\n  getExpandOperations,\n  type NodeChronologyProps,\n  type OnPathFocusPayload,\n  type PatchEvent,\n  setAtPath,\n  type StateTree,\n  toMutationPatches,\n  useFormState,\n} from '.'\nimport {CreatedDraft} from './__telemetry__/form.telemetry'\nimport {useComlinkViewHistory} from './useComlinkViewHistory'\n\ninterface DocumentFormOptions {\n  documentType: string\n  documentId: string\n  releaseId?: ReleaseId\n  initialValue?: InitialValueState\n  initialFocusPath?: Path\n  selectedPerspectiveName?: ReleaseId | 'published'\n  readOnly?: boolean | ((editState: EditStateFor) => boolean)\n  /**\n   * Usually the historical _rev value selected, if not defined, it will use the current document value\n   * so no comparison will be done.\n   */\n  comparisonValue?:\n    | Partial<SanityDocument>\n    | ((editState: EditStateFor) => Partial<SanityDocument>)\n    | null\n  onFocusPath?: (path: Path) => void\n  changesOpen?: boolean\n  /**\n   * Callback that allows to transform the value before it's passed to the form\n   * used by the <DocumentPaneProvider > to display the history values.\n   */\n  getFormDocumentValue?: (value: SanityDocumentLike) => SanityDocumentLike\n  displayInlineChanges?: boolean\n}\ninterface DocumentFormValue extends Pick<NodeChronologyProps, 'hasUpstreamVersion'> {\n  /**\n   * `EditStateFor` for the displayed document.\n   * */\n  editState: EditStateFor\n  /**\n   *  `EditStateFor` for the displayed document's upstream version.\n   */\n  upstreamEditState: EditStateFor\n  connectionState: ConnectionState\n  collapsedFieldSets: StateTree<boolean> | undefined\n  collapsedPaths: StateTree<boolean> | undefined\n  openPath: Path\n\n  ready: boolean\n  value: SanityDocumentLike\n  formState: FormState\n  focusPath: Path\n  validation: ValidationMarker[]\n  permissions: PermissionCheckResult | undefined\n  isPermissionsLoading: boolean\n  onBlur: (blurredPath: Path) => void\n  onFocus: (_nextFocusPath: Path, payload?: OnPathFocusPayload) => void\n  onSetCollapsedPath: (path: Path, collapsed: boolean) => void\n  onSetActiveFieldGroup: (path: Path, groupName: string) => void\n  onSetCollapsedFieldSet: (path: Path, collapsed: boolean) => void\n  onChange: (event: PatchEvent) => void\n  onPathOpen: (path: Path) => void\n  onProgrammaticFocus: (nextPath: Path) => void\n  formStateRef: RefObject<FormState>\n  schemaType: ObjectSchemaType\n}\n\n/**\n * @internal\n * Hook for creating a form state and combine it with the <FormBuilder>.\n * It will handle the connection state, edit state, validation, and presence.\n *\n * Use this as a base point to create your own form.\n */\nexport function useDocumentForm(options: DocumentFormOptions): DocumentFormValue {\n  const {\n    documentType,\n    getFormDocumentValue,\n    documentId,\n    initialValue,\n    changesOpen = false,\n    comparisonValue: comparisonValueRaw,\n    releaseId,\n    initialFocusPath,\n    selectedPerspectiveName,\n    readOnly: readOnlyProp,\n    onFocusPath,\n    displayInlineChanges,\n  } = options\n  const schema = useSchema()\n  const presenceStore = usePresenceStore()\n  const {data: releases} = useActiveReleases()\n  const {data: documentVersions} = useDocumentVersions({documentId})\n  const workspace = useWorkspace()\n\n  const enhancedObjectDialogEnabled = workspace.beta?.form?.enhancedObjectDialog?.enabled\n\n  const schemaType = schema.get(documentType) as ObjectSchemaType | undefined\n  if (!schemaType) {\n    throw new Error(`Schema type for '${documentType}' not found`)\n  }\n  const liveEdit = Boolean(schemaType.liveEdit)\n  const publishedId = getPublishedId(documentId)\n\n  const telemetry = useTelemetry()\n\n  // if it only has versions then we need to make sure that whatever the first document that is allowed\n  // is a version document, but also that it has the right order\n  // this will make sure that then the right document appears and so does the right chip within the document header\n  const {sortedDocumentList} = useDocumentVersionTypeSortedList({documentId})\n  const onlyHasVersions = useOnlyHasVersions({documentId})\n  const firstVersion =\n    sortedDocumentList.length > 0\n      ? documentVersions.find(\n          (id) =>\n            getVersionFromId(id) === getReleaseIdFromReleaseDocumentId(sortedDocumentList[0]._id),\n        )\n      : undefined\n\n  const activeDocumentReleaseId = useMemo(() => {\n    // if a document version exists with the selected release id, then it should use that\n    if (documentVersions.some((id) => getVersionFromId(id) === releaseId)) {\n      return releaseId\n    }\n\n    // check if the selected version is the only version, if it isn't and it doesn't exist in the release\n    // then it needs to use the documentVersions\n    if (releaseId && (!documentVersions || !onlyHasVersions)) {\n      return releaseId\n    }\n\n    return getVersionFromId(firstVersion ?? '')\n  }, [documentVersions, onlyHasVersions, releaseId, firstVersion])\n\n  const editState = useEditState(documentId, documentType, 'default', activeDocumentReleaseId)\n\n  const connectionState = useConnectionState(documentId, documentType, releaseId)\n  useReconnectingToast(connectionState === 'reconnecting')\n\n  const [focusPath, setFocusPath] = useState<Path>(initialFocusPath || EMPTY_ARRAY)\n\n  const value: SanityDocumentLike = useMemo(() => {\n    const baseValue = initialValue?.value || {_id: documentId, _type: documentType}\n    if (releaseId) {\n      // in cases where the current version is going to be unpublished, we need to show the published document\n      // this way, instead of showing the version that will stop existing, we show instead the published document with a fall back\n      if (editState.version && isGoingToUnpublish(editState.version)) {\n        return editState.published || baseValue\n      }\n      return editState.version || editState.draft || editState.published || baseValue\n    }\n    if (selectedPerspectiveName && isPublishedPerspective(selectedPerspectiveName)) {\n      return (\n        editState.published ||\n        (liveEdit\n          ? // If it's live edit and published perspective, add the initialValue\n            baseValue\n          : // If it's not live edit, the form needs to be empty in the draft state, don't show the initialValue\n            {_id: documentId, _type: documentType})\n      )\n    }\n    // if no version is selected, but there is only version, it should default to the version it finds\n    if (!selectedPerspectiveName && onlyHasVersions) {\n      return editState.version || editState.draft || editState.published || baseValue\n    }\n    return editState?.draft || editState?.published || baseValue\n  }, [\n    documentId,\n    documentType,\n    editState.draft,\n    editState.published,\n    editState.version,\n    initialValue,\n    liveEdit,\n    releaseId,\n    selectedPerspectiveName,\n    onlyHasVersions,\n  ])\n\n  const {validation: validationRaw} = useValidationStatus(value._id, documentType, releaseId)\n  const validation = useUnique(validationRaw)\n\n  const {previousId: upstreamId} = useDocumentIdStack({\n    strict: true,\n    displayed: value,\n    documentId,\n    editState,\n  })\n\n  const upstreamEditState = useEditState(\n    documentId,\n    documentType,\n    'low',\n    getVersionFromId(upstreamId ?? ''),\n  )\n\n  const comparisonValue = useMemo(() => {\n    if (typeof comparisonValueRaw === 'function') {\n      return comparisonValueRaw(upstreamEditState)\n    }\n    return comparisonValueRaw\n  }, [comparisonValueRaw, upstreamEditState])\n\n  const [presence, setPresence] = useState<DocumentPresence[]>([])\n  useEffect(() => {\n    const subscription = presenceStore\n      .documentPresence(value._id, {excludeVersions: true})\n      .subscribe((nextPresence) => {\n        setPresence(nextPresence)\n      })\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [presenceStore, value._id])\n\n  const [openPath, onSetOpenPath] = useState<Path>(EMPTY_ARRAY)\n  const [fieldGroupState, onSetFieldGroupState] = useState<StateTree<string>>()\n  const [collapsedPaths, onSetCollapsedPath] = useState<StateTree<boolean>>()\n  const [collapsedFieldSets, onSetCollapsedFieldSets] = useState<StateTree<boolean>>()\n\n  const handleOnSetCollapsedPath = (path: Path, collapsed: boolean) => {\n    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed))\n  }\n\n  const handleOnSetCollapsedFieldSet = (path: Path, collapsed: boolean) => {\n    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed))\n  }\n\n  const handleSetActiveFieldGroup = (path: Path, groupName: string) =>\n    onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName))\n\n  const requiredPermission = value._createdAt ? 'update' : 'create'\n  const targetDocumentId = releaseId\n    ? getVersionId(publishedId, releaseId)\n    : // in cases where there is a draft in a live edit, we need to use it so that it can be published\n      // in case if the user has permissions to do so otherwise just use the published id\n      liveEdit\n      ? editState?.draft?._id || publishedId\n      : getDraftId(documentId)\n  const docPermissionsInput = useMemo(() => {\n    return {\n      ...value,\n      _id: targetDocumentId,\n    }\n  }, [value, targetDocumentId])\n\n  const [permissions, isPermissionsLoading] = useDocumentValuePermissions({\n    document: docPermissionsInput,\n    permission: requiredPermission,\n  })\n\n  const isNonExistent = !value?._id\n  const isCreateLinked = isSanityCreateLinkedDocument(value)\n\n  const ready = connectionState === 'connected' && editState.ready && !initialValue?.loading\n\n  const selectedPerspective = useMemo(() => {\n    return getSelectedPerspective(selectedPerspectiveName, releases)\n  }, [selectedPerspectiveName, releases])\n\n  const isReleaseLocked = useMemo(\n    () =>\n      isReleaseDocument(selectedPerspective)\n        ? isReleaseScheduledOrScheduling(selectedPerspective)\n        : false,\n    [selectedPerspective],\n  )\n  const {isLinked} = useCanvasCompanionDoc(value._id)\n\n  // eslint-disable-next-line complexity\n  const readOnly = useMemo(() => {\n    const hasNoPermission = !isPermissionsLoading && !permissions?.granted\n    const updateActionDisabled = !isActionEnabled(schemaType!, 'update')\n    const createActionDisabled = isNonExistent && !isActionEnabled(schemaType!, 'create')\n    const reconnecting = connectionState === 'reconnecting'\n    const isLocked = editState.transactionSyncLock?.enabled\n    const willBeUnpublished = value ? isGoingToUnpublish(value) : false\n\n    // in cases where the document has no draft or published, but has a version,\n    // and that version doesn't match current pinned version\n    // we disable editing\n    if (\n      editState.version &&\n      !editState.draft &&\n      !editState.published &&\n      onlyHasVersions &&\n      selectedPerspectiveName !== getVersionFromId(editState.version._id) &&\n      isNewDocument(editState) === false\n    ) {\n      return true\n    }\n\n    // in cases where the document has drafts but the schema is live edit, there is a risk of data loss, so we disable editing in this case\n    if (liveEdit && editState.draft?._id) {\n      return true\n    }\n    if (!liveEdit && selectedPerspectiveName === 'published') {\n      return true\n    }\n\n    // If a release is selected, validate that the document id matches the selected release id.\n    //\n    // If the user is viewing a new document (a document that exists locally, but has not yet been\n    // created in the dataset), they are permitted to edit it, regardless of which perspective was\n    //",
            "cost": 0.14211000000000001
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "sanity-io__sanity.615e6c01.11358",
        "repo": "sanity-io/sanity",
        "base_commit": "615e6c01",
        "pull_number": 11358,
        "pr_number": 11358,
        "pr_url": "https://github.com/sanity-io/sanity/pull/11358",
        "title": "fix: allow for more flexibility for custom components? and using the enhanced object dialog",
        "patch": "diff --git a/dev/test-studio/schema/debug/customEnhancedObjectField.tsx b/dev/test-studio/schema/debug/customEnhancedObjectField.tsx\nnew file mode 100644\nindex 00000000000..1ffda66d5e8\n--- /dev/null\n+++ b/dev/test-studio/schema/debug/customEnhancedObjectField.tsx\n@@ -0,0 +1,10 @@\n+export const CustomEnhancedObjectField = (props: any) => {\n+  return (\n+    <div style={{border: '1px solid palegreen', borderRadius: 4}}>\n+      {props.renderDefault({\n+        ...props,\n+        title: undefined,\n+      })}\n+    </div>\n+  )\n+}\ndiff --git a/dev/test-studio/schema/debug/customEnhancedObjectInput.tsx b/dev/test-studio/schema/debug/customEnhancedObjectInput.tsx\nnew file mode 100644\nindex 00000000000..07c355ec88a\n--- /dev/null\n+++ b/dev/test-studio/schema/debug/customEnhancedObjectInput.tsx\n@@ -0,0 +1,3 @@\n+export const CustomEnhancedObjectInput = (props: any) => {\n+  return <div style={{border: '1px solid red', borderRadius: 4}}>{props.renderDefault(props)}</div>\n+}\ndiff --git a/dev/test-studio/schema/debug/objectsDebug.ts b/dev/test-studio/schema/debug/objectsDebug.ts\nindex d7a7a805ea4..a3f66fc8dde 100644\n--- a/dev/test-studio/schema/debug/objectsDebug.ts\n+++ b/dev/test-studio/schema/debug/objectsDebug.ts\n@@ -7,6 +7,8 @@ import {\n } from 'sanity'\n \n import {SideBySideObjectInput, SideBySideObjectItem} from './components/SideBySideObjectInput'\n+import {CustomEnhancedObjectField} from './customEnhancedObjectField'\n+import {CustomEnhancedObjectInput} from './customEnhancedObjectInput'\n import {PageBlockAnchor} from './PageBlockAnchor'\n \n const animal = defineField({\n@@ -19,6 +21,17 @@ const animal = defineField({\n       type: 'string',\n       title: 'Animal name',\n     },\n+    {\n+      name: 'arrayOfNumbersAnimals',\n+      type: 'array',\n+      title: 'Array of numbers animals',\n+      of: [\n+        {\n+          type: 'number',\n+          title: 'Number',\n+        },\n+      ],\n+    },\n     {\n       type: 'array',\n       name: 'description',\n@@ -248,6 +261,32 @@ const animal = defineField({\n         },\n       ],\n     },\n+    {\n+      name: 'arrayWithNoTitle',\n+      title: 'Array with custom field',\n+      type: 'array',\n+      components: {\n+        field: CustomEnhancedObjectField,\n+        input: CustomEnhancedObjectInput,\n+      },\n+      of: [\n+        {\n+          type: 'object',\n+          name: 'obj',\n+          title: 'Some object',\n+          fields: [\n+            {\n+              name: 'title',\n+              type: 'string',\n+            },\n+            {\n+              name: 'description',\n+              type: 'string',\n+            },\n+          ],\n+        },\n+      ],\n+    },\n     {\n       type: 'array',\n       name: 'children',\n@@ -938,6 +977,17 @@ export const objectsDebug = defineType({\n       name: 'title',\n       type: 'string',\n     },\n+    {\n+      name: 'arrayOfNumbers',\n+      type: 'array',\n+      title: 'Array of numbers',\n+      of: [\n+        {\n+          type: 'number',\n+          title: 'Number',\n+        },\n+      ],\n+    },\n     /** Internationalized array string */\n     defineField({\n       name: 'greeting',\n@@ -971,6 +1021,32 @@ export const objectsDebug = defineType({\n       ],\n     }),\n     animals,\n+    {\n+      name: 'arrayWithNoTitle_2',\n+      title: 'Array with custom field 2',\n+      type: 'array',\n+      components: {\n+        field: CustomEnhancedObjectField,\n+        input: CustomEnhancedObjectInput,\n+      },\n+      of: [\n+        {\n+          type: 'object',\n+          name: 'obj_2',\n+          title: 'Some object',\n+          fields: [\n+            {\n+              name: 'title',\n+              type: 'string',\n+            },\n+            {\n+              name: 'description',\n+              type: 'string',\n+            },\n+          ],\n+        },\n+      ],\n+    },\n     arrayOfMixedTypes,\n     body,\n     fieldsetArray,\ndiff --git a/e2e/tests/enhanced-object-dialog/componentItemSmoke.spec.ts b/e2e/tests/enhanced-object-dialog/componentItemSmoke.spec.ts\nindex 15c4e6f7221..68fb6e37261 100644\n--- a/e2e/tests/enhanced-object-dialog/componentItemSmoke.spec.ts\n+++ b/e2e/tests/enhanced-object-dialog/componentItemSmoke.spec.ts\n@@ -6,6 +6,7 @@ test.describe('Enhanced Object Dialog - schema with component item and input smo\n   test.beforeEach(async ({createDraftDocument}) => {\n     // wait for form to be attached\n     await createDraftDocument('/content/input-debug;objectsDebug')\n+    test.slow()\n   })\n \n   test(`opening - when creating new item with custom components.item, the modal should open`, async ({\n@@ -26,8 +27,59 @@ test.describe('Enhanced Object Dialog - schema with component item and input smo\n     const input = page.getByTestId('field-greeting[_key==\"en\"].value').getByTestId('string-input')\n     await expect(input).toBeEnabled()\n     await input.click()\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+\n     await input.fill('Test')\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+  })\n+\n+  test(`opening - when clicking the internationalized array string field, and click the next one, the modal should not open`, async ({\n+    page,\n+  }) => {\n+    const input = page.getByTestId('field-greeting[_key==\"en\"].value').getByTestId('string-input')\n+    await expect(input).toBeVisible()\n+    await expect(input).toBeEnabled()\n+    await input.click()\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+    await input.fill('Test')\n+\n+    await page.getByRole('button', {name: 'FR'}).click()\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+\n+    const inputFr = page.getByTestId('field-greeting[_key==\"fr\"].value').getByTestId('string-input')\n+    await expect(inputFr).toBeVisible()\n+    await expect(inputFr).toBeEnabled()\n+    await inputFr.click()\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+\n+    await inputFr.fill('Test but in french')\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+  })\n+\n+  test(`opening - when clicking a component?.field and component?.input it will open the dialog`, async ({\n+    page,\n+  }) => {\n+    const field = page\n+      .getByTestId('field-arrayWithNoTitle_2')\n+      .getByTestId('add-single-object-button')\n+    await expect(field).toBeEnabled()\n+    await field.click()\n+\n+    await expect(page.getByTestId('nested-object-dialog')).toBeVisible()\n+  })\n+\n+  test('should not open - when clicking an string input with the inline changes, it should not open the dialog', async ({\n+    page,\n+  }) => {\n+    // as string inputs become pte\n+\n+    await expect(page.getByTestId('pane-context-menu-button')).toBeVisible()\n+    await page.getByTestId('pane-context-menu-button').click()\n+    await expect(page.getByTestId('action-inlinechanges')).toBeVisible()\n+    await page.getByTestId('action-inlinechanges').click()\n \n+    await page.getByTestId('field-title').getByTestId('string-input-portable-text').click()\n+    await page.getByTestId('field-title').getByTestId('string-input-portable-text').fill('Test')\n     await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n   })\n })\ndiff --git a/e2e/tests/enhanced-object-dialog/smoke.spec.ts b/e2e/tests/enhanced-object-dialog/smoke.spec.ts\nindex 300eacd6108..f5a80763fbb 100644\n--- a/e2e/tests/enhanced-object-dialog/smoke.spec.ts\n+++ b/e2e/tests/enhanced-object-dialog/smoke.spec.ts\n@@ -27,8 +27,12 @@ test.describe('Enhanced Object Dialog - open and close', () => {\n     const modal = page.getByTestId('nested-object-dialog')\n \n     await expect(modal).toBeVisible()\n-    await page.getByRole('button', {name: 'Close dialog'}).click()\n+    await page\n+      .getByTestId(/^field-animals\\[_key==\"[^\"]+\"\\]\\.name$/)\n+      .getByTestId('string-input')\n+      .fill('Blue, the whale')\n \n+    await page.getByRole('button', {name: 'Close dialog'}).click()\n     await expect(modal).not.toBeVisible()\n   })\n })\n@@ -59,3 +63,43 @@ test.describe('Enhanced Object Dialog - when disabled', () => {\n     await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n   })\n })\n+\n+test.describe('Enhanced Object Dialog - when tab focusing on an array item', () => {\n+  test.beforeEach(async ({createDraftDocument, page}) => {\n+    // wait for form to be attached\n+    await createDraftDocument('/content/input-debug;objectsDebug')\n+\n+    await page.getByTestId('field-animals').getByRole('button', {name: 'Add item'}).click()\n+    const modal = page.getByTestId('nested-object-dialog')\n+\n+    await expect(modal).toBeVisible()\n+    await page\n+      .getByTestId(/^field-animals\\[_key==\"[^\"]+\"\\]\\.name$/)\n+      .getByTestId('string-input')\n+      .fill('Blue, the whale')\n+\n+    await page.getByRole('button', {name: 'Close dialog'}).click()\n+    await expect(modal).not.toBeVisible()\n+\n+    await page.getByTestId('field-animals').focus()\n+  })\n+\n+  test(`when tab focusing on an array item, the tree editing modal should not open`, async ({\n+    page,\n+  }) => {\n+    await page.keyboard.press('Tab')\n+    await page.keyboard.press('Tab')\n+\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+  })\n+\n+  test(`When pressing enter on an array item, the tree editing modal should open`, async ({\n+    page,\n+  }) => {\n+    await page.keyboard.press('Tab')\n+    await page.keyboard.press('Tab')\n+    await page.keyboard.press('Enter')\n+\n+    await expect(page.getByTestId('nested-object-dialog')).toBeVisible()\n+  })\n+})\ndiff --git a/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayState.ts b/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayState.ts\nindex d576933ae16..1633b775972 100644\n--- a/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayState.ts\n+++ b/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayState.ts\n@@ -18,7 +18,6 @@ import {getItemType} from '../../../../store/utils/getItemType'\n import {type DialogItem} from '../../types'\n import {findArrayTypePaths} from '../findArrayTypePaths'\n import {getSchemaField} from '../getSchemaField'\n-import {hasCustomInputComponent} from '../hasCustomInputComponent'\n import {isPathTextInPTEField} from '../isPathTextInPTEField'\n import {buildArrayStatePTE} from './buildArrayStatePTE'\n import {buildBreadcrumbsState} from './buildBreadcrumbsState'\n@@ -116,10 +115,7 @@ export function buildArrayState(props: BuildArrayState): TreeEditingState {\n     const childrenFields = itemSchemaField?.fields || []\n     const childrenMenuItems: DialogItem[] = []\n \n-    if (\n-      shouldBeInBreadcrumb(itemPath, openPath, documentValue) &&\n-      !hasCustomInputComponent(rootSchemaType.fields, itemPath)\n-    ) {\n+    if (shouldBeInBreadcrumb(itemPath, openPath, documentValue)) {\n       const breadcrumbsResult = buildBreadcrumbsState({\n         arraySchemaType,\n         arrayValue,\n@@ -249,10 +245,7 @@ export function buildArrayState(props: BuildArrayState): TreeEditingState {\n         }\n         childArray.forEach(updateChildArrayIndex)\n \n-        if (\n-          shouldBeInBreadcrumb(childPath, openPath, documentValue) &&\n-          !hasCustomInputComponent(rootSchemaType.fields, childPath)\n-        ) {\n+        if (shouldBeInBreadcrumb(childPath, openPath, documentValue)) {\n           const breadcrumbsResult = buildBreadcrumbsState({\n             arraySchemaType: childField.type as ArraySchemaType,\n             arrayValue: childValue as Record<string, unknown>[],\ndiff --git a/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayStatePTE.ts b/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayStatePTE.ts\nindex 3554d557d19..c9e7ca34a6f 100644\n--- a/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayStatePTE.ts\n+++ b/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayStatePTE.ts\n@@ -16,7 +16,6 @@ import {getValueAtPath, pathToString} from '../../../../../field/paths/helpers'\n import {EMPTY_ARRAY} from '../../../../../util/empty'\n import {getItemType} from '../../../../store/utils/getItemType'\n import {type DialogItem} from '../../types'\n-import {hasCustomInputComponent} from '../hasCustomInputComponent'\n import {isPathTextInPTEField} from '../isPathTextInPTEField'\n import {buildBreadcrumbsState} from './buildBreadcrumbsState'\n import {type RecursiveProps, type TreeEditingState} from './buildTreeEditingState'\n@@ -124,11 +123,7 @@ export function buildArrayStatePTE(props: BuildArrayStatePTEProps): {\n     // This handles both direct block selection and nested paths within the block\n     const openPathStartsWithBlock = startsWith(blockPath, openPath)\n \n-    if (\n-      openPathStartsWithBlock &&\n-      shouldBeInBreadcrumb(blockPath, openPath, documentValue) &&\n-      !hasCustomInputComponent(rootSchemaType.fields, blockPath)\n-    ) {\n+    if (openPathStartsWithBlock && shouldBeInBreadcrumb(blockPath, openPath, documentValue)) {\n       const blockBreadcrumb: DialogItem = {\n         children: EMPTY_ARRAY,\n         parentSchemaType: childField.type as ArraySchemaType,\n@@ -188,10 +183,7 @@ export function buildArrayStatePTE(props: BuildArrayStatePTEProps): {\n           // But ensure the value is at least an empty array for processing\n           const arrayFieldValue = Array.isArray(blockFieldValue) ? blockFieldValue : []\n \n-          if (\n-            shouldBeInBreadcrumb(blockFieldPath, openPath, documentValue) &&\n-            !hasCustomInputComponent(rootSchemaType.fields, blockFieldPath)\n-          ) {\n+          if (shouldBeInBreadcrumb(blockFieldPath, openPath, documentValue)) {\n             const breadcrumbsResult = buildBreadcrumbsState({\n               arraySchemaType: blockField.type as ArraySchemaType,\n               arrayValue: arrayFieldValue as Record<string, unknown>[],\ndiff --git a/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildTreeEditingState.ts b/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildTreeEditingState.ts\nindex 884d16e3559..5a796fe2c5f 100644\n--- a/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildTreeEditingState.ts\n+++ b/packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildTreeEditingState.ts\n@@ -11,7 +11,6 @@ import {getSchemaTypeTitle} from '../../../../../schema/helpers'\n import {type DialogItem} from '../../types'\n import {getRootPath} from '../getRootPath'\n import {getSchemaField} from '../getSchemaField'\n-import {hasCustomInputComponent} from '../hasCustomInputComponent'\n import {buildArrayState} from './buildArrayState'\n \n const EMPTY_ARRAY: [] = []\n@@ -78,19 +77,6 @@ export function buildTreeEditingState(props: BuildTreeEditingStateProps): TreeEd\n     path: rootPath,\n   })\n \n-  // If the child array field has custom components.input, skip building dialog\n-  // but preserve breadcrumbs, menuItems, and siblings\n-  if (hasCustomInputComponent((props.schemaType as ObjectSchemaType).fields || [], openPath)) {\n-    const {menuItems, siblings} = result\n-    return {\n-      relativePath: EMPTY_ARRAY,\n-      breadcrumbs,\n-      menuItems: menuItems,\n-      rootTitle,\n-      siblings: siblings,\n-    }\n-  }\n-\n   function recursive(recursiveProps: RecursiveProps): TreeEditingState {\n     const {schemaType, path, documentValue} = recursiveProps\n \ndiff --git a/packages/sanity/src/core/form/useDocumentForm.ts b/packages/sanity/src/core/form/useDocumentForm.ts\nindex b0c09b91e7b..8fb4175886d 100644\n--- a/packages/sanity/src/core/form/useDocumentForm.ts\n+++ b/packages/sanity/src/core/form/useDocumentForm.ts\n@@ -16,6 +16,7 @@ import deepEquals from 'react-fast-compare'\n \n import {useCanvasCompanionDoc} from '../canvas/actions/useCanvasCompanionDoc'\n import {isSanityCreateLinkedDocument} from '../create/createUtils'\n+import {pathToString} from '../field/paths/helpers'\n import {useReconnectingToast} from '../hooks'\n import {type ConnectionState, useConnectionState} from '../hooks/useConnectionState'\n import {useDocumentIdStack} from '../hooks/useDocumentIdStack'\n@@ -528,12 +529,26 @@ export function useDocumentForm(options: DocumentFormOptions): DocumentFormValue\n         if (!isKeySegment(lastSegment)) {\n           // For fields inside array items, find the last key segment to preserve context\n           const lastKeyIndex = nextFocusPath.findLastIndex((seg) => isKeySegment(seg))\n+          // We must preserve the context of the array item when focusing on an object field\n+          // As if we don't, then the open path will open the dialog when the object is simply focused,\n+          // Which is not what we want.\n           const newOpenPath =\n             lastKeyIndex >= 0\n               ? nextFocusPath.slice(0, lastKeyIndex + 1)\n               : nextFocusPath.slice(0, -1)\n \n-          handleSetOpenPath(pathFor(newOpenPath))\n+          /*\n+           * This checks if an element exists in the dom with the updated path.\n+           * There are situations where the element doesn't exist in the dom yet, for example:\n+           * (think internationalizedArrayString where clicking a button creates an input with the path \"en.value\")\n+           * And, in those cases, the open path will open the dialog when the button is pressed.\n+           * So, if an element exists in the dom with the updated path then it means\n+           * then we shouldn't update the open path\n+           */\n+          const elementExists = document.getElementById(`${pathToString(nextFocusPath)}`)\n+          if (!elementExists) {\n+            handleSetOpenPath(pathFor(newOpenPath))\n+          }\n         }\n       } else {\n         handleSetOpenPath(pathFor(nextFocusPath.slice(0, -1)))\n",
        "test_files": [
            "e2e/tests/enhanced-object-dialog/componentItemSmoke.spec.ts",
            "e2e/tests/enhanced-object-dialog/smoke.spec.ts"
        ],
        "code_files": [
            "dev/test-studio/schema/debug/customEnhancedObjectField.tsx",
            "dev/test-studio/schema/debug/customEnhancedObjectInput.tsx",
            "dev/test-studio/schema/debug/objectsDebug.ts",
            "packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayState.ts",
            "packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayStatePTE.ts",
            "packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildTreeEditingState.ts",
            "packages/sanity/src/core/form/useDocumentForm.ts"
        ],
        "changed_files": [
            {
                "filename": "dev/test-studio/schema/debug/customEnhancedObjectField.tsx",
                "status": "added",
                "additions": 10,
                "deletions": 0,
                "changes": 10,
                "patch": "@@ -0,0 +1,10 @@\n+export const CustomEnhancedObjectField = (props: any) => {\n+  return (\n+    <div style={{border: '1px solid palegreen', borderRadius: 4}}>\n+      {props.renderDefault({\n+        ...props,\n+        title: undefined,\n+      })}\n+    </div>\n+  )\n+}"
            },
            {
                "filename": "dev/test-studio/schema/debug/customEnhancedObjectInput.tsx",
                "status": "added",
                "additions": 3,
                "deletions": 0,
                "changes": 3,
                "patch": "@@ -0,0 +1,3 @@\n+export const CustomEnhancedObjectInput = (props: any) => {\n+  return <div style={{border: '1px solid red', borderRadius: 4}}>{props.renderDefault(props)}</div>\n+}"
            },
            {
                "filename": "dev/test-studio/schema/debug/objectsDebug.ts",
                "status": "modified",
                "additions": 76,
                "deletions": 0,
                "changes": 76,
                "patch": "@@ -7,6 +7,8 @@ import {\n } from 'sanity'\n \n import {SideBySideObjectInput, SideBySideObjectItem} from './components/SideBySideObjectInput'\n+import {CustomEnhancedObjectField} from './customEnhancedObjectField'\n+import {CustomEnhancedObjectInput} from './customEnhancedObjectInput'\n import {PageBlockAnchor} from './PageBlockAnchor'\n \n const animal = defineField({\n@@ -19,6 +21,17 @@ const animal = defineField({\n       type: 'string',\n       title: 'Animal name',\n     },\n+    {\n+      name: 'arrayOfNumbersAnimals',\n+      type: 'array',\n+      title: 'Array of numbers animals',\n+      of: [\n+        {\n+          type: 'number',\n+          title: 'Number',\n+        },\n+      ],\n+    },\n     {\n       type: 'array',\n       name: 'description',\n@@ -248,6 +261,32 @@ const animal = defineField({\n         },\n       ],\n     },\n+    {\n+      name: 'arrayWithNoTitle',\n+      title: 'Array with custom field',\n+      type: 'array',\n+      components: {\n+        field: CustomEnhancedObjectField,\n+        input: CustomEnhancedObjectInput,\n+      },\n+      of: [\n+        {\n+          type: 'object',\n+          name: 'obj',\n+          title: 'Some object',\n+          fields: [\n+            {\n+              name: 'title',\n+              type: 'string',\n+            },\n+            {\n+              name: 'description',\n+              type: 'string',\n+            },\n+          ],\n+        },\n+      ],\n+    },\n     {\n       type: 'array',\n       name: 'children',\n@@ -938,6 +977,17 @@ export const objectsDebug = defineType({\n       name: 'title',\n       type: 'string',\n     },\n+    {\n+      name: 'arrayOfNumbers',\n+      type: 'array',\n+      title: 'Array of numbers',\n+      of: [\n+        {\n+          type: 'number',\n+          title: 'Number',\n+        },\n+      ],\n+    },\n     /** Internationalized array string */\n     defineField({\n       name: 'greeting',\n@@ -971,6 +1021,32 @@ export const objectsDebug = defineType({\n       ],\n     }),\n     animals,\n+    {\n+      name: 'arrayWithNoTitle_2',\n+      title: 'Array with custom field 2',\n+      type: 'array',\n+      components: {\n+        field: CustomEnhancedObjectField,\n+        input: CustomEnhancedObjectInput,\n+      },\n+      of: [\n+        {\n+          type: 'object',\n+          name: 'obj_2',\n+          title: 'Some object',\n+          fields: [\n+            {\n+              name: 'title',\n+              type: 'string',\n+            },\n+            {\n+              name: 'description',\n+              type: 'string',\n+            },\n+          ],\n+        },\n+      ],\n+    },\n     arrayOfMixedTypes,\n     body,\n     fieldsetArray,"
            },
            {
                "filename": "e2e/tests/enhanced-object-dialog/componentItemSmoke.spec.ts",
                "status": "modified",
                "additions": 52,
                "deletions": 0,
                "changes": 52,
                "patch": "@@ -6,6 +6,7 @@ test.describe('Enhanced Object Dialog - schema with component item and input smo\n   test.beforeEach(async ({createDraftDocument}) => {\n     // wait for form to be attached\n     await createDraftDocument('/content/input-debug;objectsDebug')\n+    test.slow()\n   })\n \n   test(`opening - when creating new item with custom components.item, the modal should open`, async ({\n@@ -26,8 +27,59 @@ test.describe('Enhanced Object Dialog - schema with component item and input smo\n     const input = page.getByTestId('field-greeting[_key==\"en\"].value').getByTestId('string-input')\n     await expect(input).toBeEnabled()\n     await input.click()\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+\n     await input.fill('Test')\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+  })\n+\n+  test(`opening - when clicking the internationalized array string field, and click the next one, the modal should not open`, async ({\n+    page,\n+  }) => {\n+    const input = page.getByTestId('field-greeting[_key==\"en\"].value').getByTestId('string-input')\n+    await expect(input).toBeVisible()\n+    await expect(input).toBeEnabled()\n+    await input.click()\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+    await input.fill('Test')\n+\n+    await page.getByRole('button', {name: 'FR'}).click()\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+\n+    const inputFr = page.getByTestId('field-greeting[_key==\"fr\"].value').getByTestId('string-input')\n+    await expect(inputFr).toBeVisible()\n+    await expect(inputFr).toBeEnabled()\n+    await inputFr.click()\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+\n+    await inputFr.fill('Test but in french')\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+  })\n+\n+  test(`opening - when clicking a component?.field and component?.input it will open the dialog`, async ({\n+    page,\n+  }) => {\n+    const field = page\n+      .getByTestId('field-arrayWithNoTitle_2')\n+      .getByTestId('add-single-object-button')\n+    await expect(field).toBeEnabled()\n+    await field.click()\n+\n+    await expect(page.getByTestId('nested-object-dialog')).toBeVisible()\n+  })\n+\n+  test('should not open - when clicking an string input with the inline changes, it should not open the dialog', async ({\n+    page,\n+  }) => {\n+    // as string inputs become pte\n+\n+    await expect(page.getByTestId('pane-context-menu-button')).toBeVisible()\n+    await page.getByTestId('pane-context-menu-button').click()\n+    await expect(page.getByTestId('action-inlinechanges')).toBeVisible()\n+    await page.getByTestId('action-inlinechanges').click()\n \n+    await page.getByTestId('field-title').getByTestId('string-input-portable-text').click()\n+    await page.getByTestId('field-title').getByTestId('string-input-portable-text').fill('Test')\n     await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n   })\n })"
            },
            {
                "filename": "e2e/tests/enhanced-object-dialog/smoke.spec.ts",
                "status": "modified",
                "additions": 45,
                "deletions": 1,
                "changes": 46,
                "patch": "@@ -27,8 +27,12 @@ test.describe('Enhanced Object Dialog - open and close', () => {\n     const modal = page.getByTestId('nested-object-dialog')\n \n     await expect(modal).toBeVisible()\n-    await page.getByRole('button', {name: 'Close dialog'}).click()\n+    await page\n+      .getByTestId(/^field-animals\\[_key==\"[^\"]+\"\\]\\.name$/)\n+      .getByTestId('string-input')\n+      .fill('Blue, the whale')\n \n+    await page.getByRole('button', {name: 'Close dialog'}).click()\n     await expect(modal).not.toBeVisible()\n   })\n })\n@@ -59,3 +63,43 @@ test.describe('Enhanced Object Dialog - when disabled', () => {\n     await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n   })\n })\n+\n+test.describe('Enhanced Object Dialog - when tab focusing on an array item', () => {\n+  test.beforeEach(async ({createDraftDocument, page}) => {\n+    // wait for form to be attached\n+    await createDraftDocument('/content/input-debug;objectsDebug')\n+\n+    await page.getByTestId('field-animals').getByRole('button', {name: 'Add item'}).click()\n+    const modal = page.getByTestId('nested-object-dialog')\n+\n+    await expect(modal).toBeVisible()\n+    await page\n+      .getByTestId(/^field-animals\\[_key==\"[^\"]+\"\\]\\.name$/)\n+      .getByTestId('string-input')\n+      .fill('Blue, the whale')\n+\n+    await page.getByRole('button', {name: 'Close dialog'}).click()\n+    await expect(modal).not.toBeVisible()\n+\n+    await page.getByTestId('field-animals').focus()\n+  })\n+\n+  test(`when tab focusing on an array item, the tree editing modal should not open`, async ({\n+    page,\n+  }) => {\n+    await page.keyboard.press('Tab')\n+    await page.keyboard.press('Tab')\n+\n+    await expect(page.getByTestId('nested-object-dialog')).not.toBeVisible()\n+  })\n+\n+  test(`When pressing enter on an array item, the tree editing modal should open`, async ({\n+    page,\n+  }) => {\n+    await page.keyboard.press('Tab')\n+    await page.keyboard.press('Tab')\n+    await page.keyboard.press('Enter')\n+\n+    await expect(page.getByTestId('nested-object-dialog')).toBeVisible()\n+  })\n+})"
            },
            {
                "filename": "packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayState.ts",
                "status": "modified",
                "additions": 2,
                "deletions": 9,
                "changes": 11,
                "patch": "@@ -18,7 +18,6 @@ import {getItemType} from '../../../../store/utils/getItemType'\n import {type DialogItem} from '../../types'\n import {findArrayTypePaths} from '../findArrayTypePaths'\n import {getSchemaField} from '../getSchemaField'\n-import {hasCustomInputComponent} from '../hasCustomInputComponent'\n import {isPathTextInPTEField} from '../isPathTextInPTEField'\n import {buildArrayStatePTE} from './buildArrayStatePTE'\n import {buildBreadcrumbsState} from './buildBreadcrumbsState'\n@@ -116,10 +115,7 @@ export function buildArrayState(props: BuildArrayState): TreeEditingState {\n     const childrenFields = itemSchemaField?.fields || []\n     const childrenMenuItems: DialogItem[] = []\n \n-    if (\n-      shouldBeInBreadcrumb(itemPath, openPath, documentValue) &&\n-      !hasCustomInputComponent(rootSchemaType.fields, itemPath)\n-    ) {\n+    if (shouldBeInBreadcrumb(itemPath, openPath, documentValue)) {\n       const breadcrumbsResult = buildBreadcrumbsState({\n         arraySchemaType,\n         arrayValue,\n@@ -249,10 +245,7 @@ export function buildArrayState(props: BuildArrayState): TreeEditingState {\n         }\n         childArray.forEach(updateChildArrayIndex)\n \n-        if (\n-          shouldBeInBreadcrumb(childPath, openPath, documentValue) &&\n-          !hasCustomInputComponent(rootSchemaType.fields, childPath)\n-        ) {\n+        if (shouldBeInBreadcrumb(childPath, openPath, documentValue)) {\n           const breadcrumbsResult = buildBreadcrumbsState({\n             arraySchemaType: childField.type as ArraySchemaType,\n             arrayValue: childValue as Record<string, unknown>[],"
            },
            {
                "filename": "packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildArrayStatePTE.ts",
                "status": "modified",
                "additions": 2,
                "deletions": 10,
                "changes": 12,
                "patch": "@@ -16,7 +16,6 @@ import {getValueAtPath, pathToString} from '../../../../../field/paths/helpers'\n import {EMPTY_ARRAY} from '../../../../../util/empty'\n import {getItemType} from '../../../../store/utils/getItemType'\n import {type DialogItem} from '../../types'\n-import {hasCustomInputComponent} from '../hasCustomInputComponent'\n import {isPathTextInPTEField} from '../isPathTextInPTEField'\n import {buildBreadcrumbsState} from './buildBreadcrumbsState'\n import {type RecursiveProps, type TreeEditingState} from './buildTreeEditingState'\n@@ -124,11 +123,7 @@ export function buildArrayStatePTE(props: BuildArrayStatePTEProps): {\n     // This handles both direct block selection and nested paths within the block\n     const openPathStartsWithBlock = startsWith(blockPath, openPath)\n \n-    if (\n-      openPathStartsWithBlock &&\n-      shouldBeInBreadcrumb(blockPath, openPath, documentValue) &&\n-      !hasCustomInputComponent(rootSchemaType.fields, blockPath)\n-    ) {\n+    if (openPathStartsWithBlock && shouldBeInBreadcrumb(blockPath, openPath, documentValue)) {\n       const blockBreadcrumb: DialogItem = {\n         children: EMPTY_ARRAY,\n         parentSchemaType: childField.type as ArraySchemaType,\n@@ -188,10 +183,7 @@ export function buildArrayStatePTE(props: BuildArrayStatePTEProps): {\n           // But ensure the value is at least an empty array for processing\n           const arrayFieldValue = Array.isArray(blockFieldValue) ? blockFieldValue : []\n \n-          if (\n-            shouldBeInBreadcrumb(blockFieldPath, openPath, documentValue) &&\n-            !hasCustomInputComponent(rootSchemaType.fields, blockFieldPath)\n-          ) {\n+          if (shouldBeInBreadcrumb(blockFieldPath, openPath, documentValue)) {\n             const breadcrumbsResult = buildBreadcrumbsState({\n               arraySchemaType: blockField.type as ArraySchemaType,\n               arrayValue: arrayFieldValue as Record<string, unknown>[],"
            },
            {
                "filename": "packages/sanity/src/core/form/studio/tree-editing/utils/build-tree-editing-state/buildTreeEditingState.ts",
                "status": "modified",
                "additions": 0,
                "deletions": 14,
                "changes": 14,
                "patch": "@@ -11,7 +11,6 @@ import {getSchemaTypeTitle} from '../../../../../schema/helpers'\n import {type DialogItem} from '../../types'\n import {getRootPath} from '../getRootPath'\n import {getSchemaField} from '../getSchemaField'\n-import {hasCustomInputComponent} from '../hasCustomInputComponent'\n import {buildArrayState} from './buildArrayState'\n \n const EMPTY_ARRAY: [] = []\n@@ -78,19 +77,6 @@ export function buildTreeEditingState(props: BuildTreeEditingStateProps): TreeEd\n     path: rootPath,\n   })\n \n-  // If the child array field has custom components.input, skip building dialog\n-  // but preserve breadcrumbs, menuItems, and siblings\n-  if (hasCustomInputComponent((props.schemaType as ObjectSchemaType).fields || [], openPath)) {\n-    const {menuItems, siblings} = result\n-    return {\n-      relativePath: EMPTY_ARRAY,\n-      breadcrumbs,\n-      menuItems: menuItems,\n-      rootTitle,\n-      siblings: siblings,\n-    }\n-  }\n-\n   function recursive(recursiveProps: RecursiveProps): TreeEditingState {\n     const {schemaType, path, documentValue} = recursiveProps\n "
            },
            {
                "filename": "packages/sanity/src/core/form/useDocumentForm.ts",
                "status": "modified",
                "additions": 16,
                "deletions": 1,
                "changes": 17,
                "patch": "@@ -16,6 +16,7 @@ import deepEquals from 'react-fast-compare'\n \n import {useCanvasCompanionDoc} from '../canvas/actions/useCanvasCompanionDoc'\n import {isSanityCreateLinkedDocument} from '../create/createUtils'\n+import {pathToString} from '../field/paths/helpers'\n import {useReconnectingToast} from '../hooks'\n import {type ConnectionState, useConnectionState} from '../hooks/useConnectionState'\n import {useDocumentIdStack} from '../hooks/useDocumentIdStack'\n@@ -528,12 +529,26 @@ export function useDocumentForm(options: DocumentFormOptions): DocumentFormValue\n         if (!isKeySegment(lastSegment)) {\n           // For fields inside array items, find the last key segment to preserve context\n           const lastKeyIndex = nextFocusPath.findLastIndex((seg) => isKeySegment(seg))\n+          // We must preserve the context of the array item when focusing on an object field\n+          // As if we don't, then the open path will open the dialog when the object is simply focused,\n+          // Which is not what we want.\n           const newOpenPath =\n             lastKeyIndex >= 0\n               ? nextFocusPath.slice(0, lastKeyIndex + 1)\n               : nextFocusPath.slice(0, -1)\n \n-          handleSetOpenPath(pathFor(newOpenPath))\n+          /*\n+           * This checks if an element exists in the dom with the updated path.\n+           * There are situations where the element doesn't exist in the dom yet, for example:\n+           * (think internationalizedArrayString where clicking a button creates an input with the path \"en.value\")\n+           * And, in those cases, the open path will open the dialog when the button is pressed.\n+           * So, if an element exists in the dom with the updated path then it means\n+           * then we shouldn't update the open path\n+           */\n+          const elementExists = document.getElementById(`${pathToString(nextFocusPath)}`)\n+          if (!elementExists) {\n+            handleSetOpenPath(pathFor(newOpenPath))\n+          }\n         }\n       } else {\n         handleSetOpenPath(pathFor(nextFocusPath.slice(0, -1)))"
            }
        ],
        "pr_mirror": "sanity-io__sanity.615e6c01"
    }
}