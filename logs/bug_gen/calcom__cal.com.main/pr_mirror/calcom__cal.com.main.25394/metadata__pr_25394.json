{
    "cost": 0.16751500000000002,
    "rewrites": {
        "calcom__cal.com.main/apps/web/test/lib/confirm.handler.test.ts": {
            "output": "import {\n  createBookingScenario,\n  getOrganizer,\n  getScenarioData,\n  TestData,\n  mockSuccessfulVideoMeetingCreation,\n} from \"@calcom/web/test/utils/bookingScenario/bookingScenario\";\n\nimport { describe, it, beforeEach, vi, expect } from \"vitest\";\n\nimport * as handleConfirmationModule from \"@calcom/features/bookings/lib/handleConfirmation\";\nimport { BookingStatus } from \"@calcom/prisma/enums\";\nimport { confirmHandler } from \"@calcom/trpc/server/routers/viewer/bookings/confirm.handler\";\nimport type { TrpcSessionUser } from \"@calcom/trpc/server/types\";\n\ndescribe(\"confirmHandler\", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it(\"should pass hideCalendarNotes property to CalendarEvent when enabled\", async () => {\n    vi.setSystemTime(\"2050-01-07T00:00:00Z\");\n\n    const handleConfirmationSpy = vi.spyOn(handleConfirmationModule, \"handleConfirmation\");\n\n    const attendeeUser = getOrganizer({\n      email: \"test@example.com\",\n      name: \"test name\",\n      id: 102,\n      schedules: [TestData.schedules.IstWorkHours],\n    });\n\n    const organizer = getOrganizer({\n      name: \"Organizer\",\n      email: \"organizer@example.com\",\n      id: 101,\n      schedules: [TestData.schedules.IstWorkHours],\n    });\n\n    const uidOfBooking = \"hideNotes123\";\n    const iCalUID = `${uidOfBooking}@Cal.com`;\n\n    const plus1DateString = \"2050-01-08\";\n\n    await createBookingScenario(\n      getScenarioData({\n        eventTypes: [\n          {\n            id: 1,\n            slotInterval: 15,\n            length: 15,\n            locations: [],\n            hideCalendarNotes: true,\n            hideCalendarEventDetails: true,\n            requiresConfirmation: true,\n            users: [\n              {\n                id: 101,\n              },\n            ],\n          },\n        ],\n        bookings: [\n          {\n            id: 101,\n            uid: uidOfBooking,\n            eventTypeId: 1,\n            status: BookingStatus.PENDING,\n            startTime: `${plus1DateString}T05:00:00.000Z`,\n            endTime: `${plus1DateString}T05:15:00.000Z`,\n            references: [],\n            iCalUID,\n            location: \"integrations:daily\",\n            attendees: [attendeeUser],\n            responses: { name: attendeeUser.name, email: attendeeUser.email, notes: \"Sensitive information\" },\n          },\n        ],\n        organizer,\n        apps: [TestData.apps[\"daily-video\"]],\n      })\n    );\n\n    mockSuccessfulVideoMeetingCreation({\n      metadataLookupKey: \"dailyvideo\",\n    });\n\n    const ctx = {\n      user: {\n        id: organizer.id,\n        name: organizer.name,\n        timeZone: organizer.timeZone,\n        username: organizer.username,\n      } as NonNullable<TrpcSessionUser>,\n    };\n\n    const res = await confirmHandler({\n      ctx,\n      input: { bookingId: 101, confirmed: true, reason: \"\", emailsEnabled: true },\n    });\n\n    expect(res?.status).toBe(BookingStatus.ACCEPTED);\n    expect(handleConfirmationSpy).toHaveBeenCalledTimes(1);\n\n    const handleConfirmationCall = handleConfirmationSpy.mock.calls[0][0];\n    const calendarEvent = handleConfirmationCall.evt;\n\n    expect(calendarEvent.hideCalendarNotes).toBe(true);\n    expect(calendarEvent.hideCalendarEventDetails).toBe(true);\n  });\n});",
            "output_extracted": "import {\n  createBookingScenario,\n  getOrganizer,\n  getScenarioData,\n  TestData,\n  mockSuccessfulVideoMeetingCreation,\n} from \"@calcom/web/test/utils/bookingScenario/bookingScenario\";\n\nimport { describe, it, beforeEach, vi, expect } from \"vitest\";\n\nimport * as handleConfirmationModule from \"@calcom/features/bookings/lib/handleConfirmation\";\nimport { BookingStatus } from \"@calcom/prisma/enums\";\nimport { confirmHandler } from \"@calcom/trpc/server/routers/viewer/bookings/confirm.handler\";\nimport type { TrpcSessionUser } from \"@calcom/trpc/server/types\";\n\ndescribe(\"confirmHandler\", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it(\"should pass hideCalendarNotes property to CalendarEvent when enabled\", async () => {\n    vi.setSystemTime(\"2050-01-07T00:00:00Z\");\n\n    const handleConfirmationSpy = vi.spyOn(handleConfirmationModule, \"handleConfirmation\");\n\n    const attendeeUser = getOrganizer({\n      email: \"test@example.com\",\n      name: \"test name\",\n      id: 102,\n      schedules: [TestData.schedules.IstWorkHours],\n    });\n\n    const organizer = getOrganizer({\n      name: \"Organizer\",\n      email: \"organizer@example.com\",\n      id: 101,\n      schedules: [TestData.schedules.IstWorkHours],\n    });\n\n    const uidOfBooking = \"hideNotes123\";\n    const iCalUID = `${uidOfBooking}@Cal.com`;\n\n    const plus1DateString = \"2050-01-08\";\n\n    await createBookingScenario(\n      getScenarioData({\n        eventTypes: [\n          {\n            id: 1,\n            slotInterval: 15,\n            length: 15,\n            locations: [],\n            hideCalendarNotes: true,\n            hideCalendarEventDetails: true,\n            requiresConfirmation: true,\n            users: [\n              {\n                id: 101,\n              },\n            ],\n          },\n        ],\n        bookings: [\n          {\n            id: 101,\n            uid: uidOfBooking,\n            eventTypeId: 1,\n            status: BookingStatus.PENDING,\n            startTime: `${plus1DateString}T05:00:00.000Z`,\n            endTime: `${plus1DateString}T05:15:00.000Z`,\n            references: [],\n            iCalUID,\n            location: \"integrations:daily\",\n            attendees: [attendeeUser],\n            responses: { name: attendeeUser.name, email: attendeeUser.email, notes: \"Sensitive information\" },\n          },\n        ],\n        organizer,\n        apps: [TestData.apps[\"daily-video\"]],\n      })\n    );\n\n    mockSuccessfulVideoMeetingCreation({\n      metadataLookupKey: \"dailyvideo\",\n    });\n\n    const ctx = {\n      user: {\n        id: organizer.id,\n        name: organizer.name,\n        timeZone: organizer.timeZone,\n        username: organizer.username,\n      } as NonNullable<TrpcSessionUser>,\n    };\n\n    const res = await confirmHandler({\n      ctx,\n      input: { bookingId: 101, confirmed: true, reason: \"\", emailsEnabled: true },\n    });\n\n    expect(res?.status).toBe(BookingStatus.ACCEPTED);\n    expect(handleConfirmationSpy).toHaveBeenCalledTimes(1);\n\n    const handleConfirmationCall = handleConfirmationSpy.mock.calls[0][0];\n    const calendarEvent = handleConfirmationCall.evt;\n\n    expect(calendarEvent.hideCalendarNotes).toBe(true);\n    expect(calendarEvent.hideCalendarEventDetails).toBe(true);\n  });\n});",
            "cost": 0.035100000000000006
        },
        "calcom__cal.com.main/packages/trpc/server/routers/viewer/bookings/confirm.handler.ts": {
            "output": "import { getUsersCredentialsIncludeServiceAccountKey } from \"@calcom/app-store/delegationCredential\";\nimport type { LocationObject } from \"@calcom/app-store/locations\";\nimport { getLocationValueForDB } from \"@calcom/app-store/locations\";\nimport { sendDeclinedEmailsAndSMS } from \"@calcom/emails/email-manager\";\nimport { getAllCredentialsIncludeServiceAccountKey } from \"@calcom/features/bookings/lib/getAllCredentialsForUsersOnEvent/getAllCredentials\";\nimport { getCalEventResponses } from \"@calcom/features/bookings/lib/getCalEventResponses\";\nimport { handleConfirmation } from \"@calcom/features/bookings/lib/handleConfirmation\";\nimport { handleWebhookTrigger } from \"@calcom/features/bookings/lib/handleWebhookTrigger\";\nimport { processPaymentRefund } from \"@calcom/features/bookings/lib/payment/processPaymentRefund\";\nimport { CreditService } from \"@calcom/features/ee/billing/credit-service\";\nimport { getBookerBaseUrl } from \"@calcom/features/ee/organizations/lib/getBookerUrlServer\";\nimport { workflowSelect } from \"@calcom/features/ee/workflows/lib/getAllWorkflows\";\nimport { WorkflowService } from \"@calcom/features/ee/workflows/lib/service/WorkflowService\";\nimport type { GetSubscriberOptions } from \"@calcom/features/webhooks/lib/getWebhooks\";\nimport type { EventPayloadType, EventTypeInfo } from \"@calcom/features/webhooks/lib/sendPayload\";\nimport getOrgIdFromMemberOrTeamId from \"@calcom/lib/getOrgIdFromMemberOrTeamId\";\nimport { getTeamIdFromEventType } from \"@calcom/lib/getTeamIdFromEventType\";\nimport { isPrismaObjOrUndefined } from \"@calcom/lib/isPrismaObj\";\nimport { parseRecurringEvent } from \"@calcom/lib/isRecurringEvent\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { PrismaOrgMembershipRepository } from \"@calcom/lib/server/repository/PrismaOrgMembershipRepository\";\nimport { getTimeFormatStringFromUserTimeFormat } from \"@calcom/lib/timeFormat\";\nimport { prisma } from \"@calcom/prisma\";\nimport { Prisma } from \"@calcom/prisma/client\";\nimport {\n  BookingStatus,\n  MembershipRole,\n  WebhookTriggerEvents,\n  WorkflowTriggerEvents,\n  UserPermissionRole,\n} from \"@calcom/prisma/enums\";\nimport type { EventTypeMetadata } from \"@calcom/prisma/zod-utils\";\nimport { getAllWorkflowsFromEventType } from \"@calcom/trpc/server/routers/viewer/workflows/util\";\nimport type { CalendarEvent } from \"@calcom/types/Calendar\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TrpcSessionUser } from \"../../../types\";\nimport type { TConfirmInputSchema } from \"./confirm.schema\";\n\ntype ConfirmOptions = {\n  ctx: {\n    user: Pick<NonNullable<TrpcSessionUser>, \"id\" | \"email\" | \"username\" | \"role\" | \"destinationCalendar\">;\n  };\n  input: TConfirmInputSchema;\n};\n\nexport const confirmHandler = async ({ ctx, input }: ConfirmOptions) => {\n  const { user } = ctx;\n  const {\n    bookingId,\n    recurringEventId,\n    reason: rejectionReason,\n    confirmed,\n    emailsEnabled,\n    platformClientParams,\n  } = input;\n\n  const booking = await prisma.booking.findUniqueOrThrow({\n    where: {\n      id: bookingId,\n    },\n    select: {\n      title: true,\n      description: true,\n      customInputs: true,\n      startTime: true,\n      endTime: true,\n      attendees: true,\n      eventTypeId: true,\n      responses: true,\n      metadata: true,\n      userPrimaryEmail: true,\n      eventType: {\n        select: {\n          id: true,\n          owner: true,\n          teamId: true,\n          recurringEvent: true,\n          title: true,\n          slug: true,\n          requiresConfirmation: true,\n          currency: true,\n          length: true,\n          description: true,\n          price: true,\n          bookingFields: true,\n          hideOrganizerEmail: true,\n          hideCalendarNotes: true,\n          hideCalendarEventDetails: true,\n          disableGuests: true,\n          customReplyToEmail: true,\n          metadata: true,\n          locations: true,\n          team: {\n            select: {\n              id: true,\n              name: true,\n              parentId: true,\n            },\n          },\n          workflows: {\n            select: {\n              workflow: {\n                select: workflowSelect,\n              },\n            },\n          },\n          customInputs: true,\n          parentId: true,\n          parent: {\n            select: {\n              teamId: true,\n            },\n          },\n        },\n      },\n      location: true,\n      userId: true,\n      user: {\n        select: {\n          id: true,\n          username: true,\n          email: true,\n          timeZone: true,\n          timeFormat: true,\n          name: true,\n          destinationCalendar: true,\n          locale: true,\n        },\n      },\n      id: true,\n      uid: true,\n      payment: true,\n      destinationCalendar: true,\n      paid: true,\n      recurringEventId: true,\n      status: true,\n      smsReminderNumber: true,\n    },\n  });\n\n  await checkIfUserIsAuthorizedToConfirmBooking({\n    eventTypeId: booking.eventTypeId,\n    loggedInUserId: user.id,\n    teamId: booking.eventType?.teamId || booking.eventType?.parent?.teamId,\n    bookingUserId: booking.userId,\n    userRole: user.role,\n  });\n\n  // Do not move this before authorization check.\n  // This is done to avoid exposing extra information to the requester.\n  if (booking.status === BookingStatus.ACCEPTED) {\n    throw new TRPCError({ code: \"BAD_REQUEST\", message: \"Booking already confirmed\" });\n  }\n\n  // If booking requires payment and is not paid, we don't allow confirmation\n  if (confirmed && booking.payment.length > 0 && !booking.paid) {\n    await prisma.booking.update({\n      where: {\n        id: bookingId,\n      },\n      data: {\n        status: BookingStatus.ACCEPTED,\n      },\n    });\n\n    return { message: \"Booking confirmed\", status: BookingStatus.ACCEPTED };\n  }\n\n  // Cache translations to avoid requesting multiple times.\n  const translations = new Map();\n  const attendeesListPromises = booking.attendees.map(async (attendee) => {\n    const locale = attendee.locale ?? \"en\";\n    let translate = translations.get(locale);\n    if (!translate) {\n      translate = await getTranslation(locale, \"common\");\n      translations.set(locale, translate);\n    }\n    return {\n      name: attendee.name,\n      email: attendee.email,\n      timeZone: attendee.timeZone,\n      phoneNumber: attendee.phoneNumber,\n      language: {\n        translate,\n        locale,\n      },\n    };\n  });\n\n  const organizerOrganizationProfile = await prisma.profile.findFirst({\n    where: {\n      userId: booking.user?.id,\n    },\n  });\n\n  const organizerOrganizationId = organizerOrganizationProfile?.organizationId;\n\n  const bookerUrl = await getBookerBaseUrl(\n    booking.eventType?.team?.parentId ?? organizerOrganizationId ?? null\n  );\n\n  const attendeesList = await Promise.all(attendeesListPromises);\n  const tOrganizer = await getTranslation(booking.user?.locale ?? \"en\", \"common\");\n\n  const evt: CalendarEvent = {\n    type: booking?.eventType?.slug as string,\n    title: booking.title,\n    description: booking.description,\n    bookerUrl,\n    // TODO: Remove the usage of `bookingFields` in computing responses. We can do that by storing `label` with the response. Also, this would allow us to correctly show the label for a field even after the Event Type has been deleted.\n    ...getCalEventResponses({\n      bookingFields: booking.eventType?.bookingFields ?? null,\n      booking,\n    }),\n    customInputs: isPrismaObjOrUndefined(booking.customInputs),\n    startTime: booking.startTime.toISOString(),\n    endTime: booking.endTime.toISOString(),\n    organizer: {\n      id: booking.user?.id,\n      email: booking?.userPrimaryEmail || booking.user?.email || \"Email-less\",\n      name: booking.user?.name || \"Nameless\",\n      username: booking.user?.username || undefined,\n      usernameInOrg: organizerOrganizationProfile?.username || undefined,\n      timeZone: booking.user?.timeZone || \"Europe/London\",\n      timeFormat: getTimeFormatStringFromUserTimeFormat(booking.user?.timeFormat),\n      language: { translate: tOrganizer, locale: booking.user?.locale ?? \"en\" },\n    },\n    attendees: attendeesList,\n    location: booking.location ?? \"\",\n    uid: booking.uid,\n    destinationCalendar: booking.destinationCalendar\n      ? [booking.destinationCalendar]\n      : booking.user?.destinationCalendar\n      ? [booking.user?.destinationCalendar]\n      : [],\n    requiresConfirmation: booking?.eventType?.requiresConfirmation ?? false,\n    hideOrganizerEmail: booking.eventType?.hideOrganizerEmail,\n    hideCalendarNotes: booking.eventType?.hideCalendarNotes,\n    hideCalendarEventDetails: booking.eventType?.hideCalendarEventDetails,\n    eventTypeId: booking.eventType?.id,\n    customReplyToEmail: booking.eventType?.customReplyToEmail,\n    team: booking.eventType?.team\n      ? {\n          name: booking.eventType.team.name,\n          id: booking.eventType.team.id,\n          members: [],\n        }\n      : undefined,\n    ...(platformClientParams ? platformClientParams : {}),\n    organizationId: organizerOrganizationId ?? booking.eventType?.team?.parentId ?? null,\n    additionalNotes: booking.description,\n  };\n\n  const recurringEvent = parseRecurringEvent(booking.eventType?.recurringEvent);\n  if (recurringEventId) {\n    if (\n      !(await prisma.booking.findFirst({\n        where: {\n          recurringEventId,\n          id: booking.id,\n        },\n        select: {\n          id: true,\n        },\n      }))\n    ) {\n      // FIXME: It might be best to retrieve recurringEventId from the booking itself.\n      throw new TRPCError({\n        code: \"UNAUTHORIZED\",\n        message: \"Recurring event id doesn't belong to the booking\",\n      });\n    }\n  }\n  if (recurringEventId && recurringEvent) {\n    const groupedRecurringBookings = await prisma.booking.groupBy({\n      where: {\n        recurringEventId: booking.recurringEventId,\n      },\n      by: [Prisma.BookingScalarFieldEnum.recurringEventId],\n      _count: true,\n    });\n    // Overriding the recurring event configuration count to be the actual number of events booked for\n    // the recurring event (equal or less than recurring event configuration count)\n    recurringEvent.count = groupedRecurringBookings[0]._count;\n    // count changed, parsing again to get the new value in\n    evt.recurringEvent = parseRecurringEvent(recurringEvent);\n  }\n\n  if (confirmed) {\n    const credentials = await getUsersCredentialsIncludeServiceAccountKey(booking.user);\n    const userWithCredentials = {\n      ...booking.user,\n      credentials,\n    };\n    const allCredentials = await getAllCredentialsIncludeServiceAccountKey(userWithCredentials, {\n      ...booking.eventType,\n      metadata: booking.eventType?.metadata as EventTypeMetadata,\n    });\n    const conferenceCredentialId = getLocationValueForDB(\n      booking.location ?? \"\",\n      (booking.eventType?.locations as LocationObject[]) || []\n    );\n    evt.conferenceCredentialId = conferenceCredentialId.conferenceCredentialId;\n    await handleConfirmation({\n      user: { ...booking.user, credentials: allCredentials },\n      evt,\n      recurringEventId,\n      prisma,\n      bookingId,\n      booking,\n      emailsEnabled,\n      platformClientParams,\n    });\n  } else {\n    evt.rejectionReason = rejectionReason;\n    if (recurringEventId) {\n      // The booking to reject is a recurring event and comes from /booking/upcoming, proceeding to mark all related\n      // bookings as rejected.\n      await prisma.booking.updateMany({\n        where: {\n          recurringEventId,\n          status: BookingStatus.PENDING,\n        },\n        data: {\n          status: BookingStatus.REJECTED,\n          rejectionReason,\n        },\n      });\n    } else {\n      // handle refunds\n      if (booking.payment.length) {\n        await processPaymentRefund({\n          booking: booking,\n          teamId: booking.eventType?.teamId,\n        });\n      }\n      // end handle refunds.\n\n      await prisma.booking.update({\n        where: {\n          id: bookingId,\n        },\n        data: {\n          status: BookingStatus.REJECTED,\n          rejectionReason,\n        },\n      });\n    }\n\n    if (emailsEnabled) {\n      await sendDeclinedEmailsAndSMS(evt, booking.eventType?.metadata as EventTypeMetadata);\n    }\n\n    const teamId = await getTeamIdFromEventType({\n      eventType: {\n        team: { id: booking.eventType?.teamId ?? null },\n        parentId: booking?.eventType?.parentId ?? null,\n      },\n    });\n\n    const orgId = await getOrgIdFromMemberOrTeamId({ memberId: booking.userId, teamId });\n\n    // send BOOKING_REJECTED webhooks\n    const subscriberOptions: GetSubscriberOptions = {\n      userId: booking.userId,\n      eventTypeId: booking.eventTypeId,\n      triggerEvent: WebhookTriggerEvents.BOOKING_REJECTED,\n      teamId,\n      orgId,\n      oAuthClientId: platformClientParams?.platformClientId,\n    };\n    const eventTrigger: WebhookTriggerEvents = WebhookTriggerEvents.BOOKING_REJECTED;\n    const eventTypeInfo: EventTypeInfo = {\n      eventTitle: booking.eventType?.title,\n      eventDescription: booking.eventType?.description,\n      requiresConfirmation: booking.eventType?.requiresConfirmation || null,\n      price: booking.eventType?.price,\n      currency: booking.eventType?.currency,\n      length: booking.eventType?.length,\n    };\n    const webhookData: EventPayloadType = {\n      ...evt,\n      ...eventTypeInfo,\n      bookingId,\n      eventTypeId: booking.eventType?.id,\n      status: BookingStatus.REJECTED,\n      smsReminderNumber: booking.smsReminderNumber || undefined,\n    };\n    await handleWebhookTrigger({ subscriberOptions, eventTrigger, webhookData });\n\n    const workflows = await getAllWorkflowsFromEventType(booking.eventType, booking.user?.id);\n    try {\n      const creditService = new CreditService();\n\n      await WorkflowService.scheduleWorkflowsFilteredByTriggerEvent({\n        workflows,\n        smsReminderNumber: booking.smsReminderNumber,\n        calendarEvent: {\n          ...evt,\n          bookerUrl: bookerUrl,\n          eventType: {\n            ...eventTypeInfo,\n            slug: booking.eventType?.slug as string,\n          },\n        },\n        hideB",
            "output_extracted": "import { getUsersCredentialsIncludeServiceAccountKey } from \"@calcom/app-store/delegationCredential\";\nimport type { LocationObject } from \"@calcom/app-store/locations\";\nimport { getLocationValueForDB } from \"@calcom/app-store/locations\";\nimport { sendDeclinedEmailsAndSMS } from \"@calcom/emails/email-manager\";\nimport { getAllCredentialsIncludeServiceAccountKey } from \"@calcom/features/bookings/lib/getAllCredentialsForUsersOnEvent/getAllCredentials\";\nimport { getCalEventResponses } from \"@calcom/features/bookings/lib/getCalEventResponses\";\nimport { handleConfirmation } from \"@calcom/features/bookings/lib/handleConfirmation\";\nimport { handleWebhookTrigger } from \"@calcom/features/bookings/lib/handleWebhookTrigger\";\nimport { processPaymentRefund } from \"@calcom/features/bookings/lib/payment/processPaymentRefund\";\nimport { CreditService } from \"@calcom/features/ee/billing/credit-service\";\nimport { getBookerBaseUrl } from \"@calcom/features/ee/organizations/lib/getBookerUrlServer\";\nimport { workflowSelect } from \"@calcom/features/ee/workflows/lib/getAllWorkflows\";\nimport { WorkflowService } from \"@calcom/features/ee/workflows/lib/service/WorkflowService\";\nimport type { GetSubscriberOptions } from \"@calcom/features/webhooks/lib/getWebhooks\";\nimport type { EventPayloadType, EventTypeInfo } from \"@calcom/features/webhooks/lib/sendPayload\";\nimport getOrgIdFromMemberOrTeamId from \"@calcom/lib/getOrgIdFromMemberOrTeamId\";\nimport { getTeamIdFromEventType } from \"@calcom/lib/getTeamIdFromEventType\";\nimport { isPrismaObjOrUndefined } from \"@calcom/lib/isPrismaObj\";\nimport { parseRecurringEvent } from \"@calcom/lib/isRecurringEvent\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { PrismaOrgMembershipRepository } from \"@calcom/lib/server/repository/PrismaOrgMembershipRepository\";\nimport { getTimeFormatStringFromUserTimeFormat } from \"@calcom/lib/timeFormat\";\nimport { prisma } from \"@calcom/prisma\";\nimport { Prisma } from \"@calcom/prisma/client\";\nimport {\n  BookingStatus,\n  MembershipRole,\n  WebhookTriggerEvents,\n  WorkflowTriggerEvents,\n  UserPermissionRole,\n} from \"@calcom/prisma/enums\";\nimport type { EventTypeMetadata } from \"@calcom/prisma/zod-utils\";\nimport { getAllWorkflowsFromEventType } from \"@calcom/trpc/server/routers/viewer/workflows/util\";\nimport type { CalendarEvent } from \"@calcom/types/Calendar\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TrpcSessionUser } from \"../../../types\";\nimport type { TConfirmInputSchema } from \"./confirm.schema\";\n\ntype ConfirmOptions = {\n  ctx: {\n    user: Pick<NonNullable<TrpcSessionUser>, \"id\" | \"email\" | \"username\" | \"role\" | \"destinationCalendar\">;\n  };\n  input: TConfirmInputSchema;\n};\n\nexport const confirmHandler = async ({ ctx, input }: ConfirmOptions) => {\n  const { user } = ctx;\n  const {\n    bookingId,\n    recurringEventId,\n    reason: rejectionReason,\n    confirmed,\n    emailsEnabled,\n    platformClientParams,\n  } = input;\n\n  const booking = await prisma.booking.findUniqueOrThrow({\n    where: {\n      id: bookingId,\n    },\n    select: {\n      title: true,\n      description: true,\n      customInputs: true,\n      startTime: true,\n      endTime: true,\n      attendees: true,\n      eventTypeId: true,\n      responses: true,\n      metadata: true,\n      userPrimaryEmail: true,\n      eventType: {\n        select: {\n          id: true,\n          owner: true,\n          teamId: true,\n          recurringEvent: true,\n          title: true,\n          slug: true,\n          requiresConfirmation: true,\n          currency: true,\n          length: true,\n          description: true,\n          price: true,\n          bookingFields: true,\n          hideOrganizerEmail: true,\n          hideCalendarNotes: true,\n          hideCalendarEventDetails: true,\n          disableGuests: true,\n          customReplyToEmail: true,\n          metadata: true,\n          locations: true,\n          team: {\n            select: {\n              id: true,\n              name: true,\n              parentId: true,\n            },\n          },\n          workflows: {\n            select: {\n              workflow: {\n                select: workflowSelect,\n              },\n            },\n          },\n          customInputs: true,\n          parentId: true,\n          parent: {\n            select: {\n              teamId: true,\n            },\n          },\n        },\n      },\n      location: true,\n      userId: true,\n      user: {\n        select: {\n          id: true,\n          username: true,\n          email: true,\n          timeZone: true,\n          timeFormat: true,\n          name: true,\n          destinationCalendar: true,\n          locale: true,\n        },\n      },\n      id: true,\n      uid: true,\n      payment: true,\n      destinationCalendar: true,\n      paid: true,\n      recurringEventId: true,\n      status: true,\n      smsReminderNumber: true,\n    },\n  });\n\n  await checkIfUserIsAuthorizedToConfirmBooking({\n    eventTypeId: booking.eventTypeId,\n    loggedInUserId: user.id,\n    teamId: booking.eventType?.teamId || booking.eventType?.parent?.teamId,\n    bookingUserId: booking.userId,\n    userRole: user.role,\n  });\n\n  // Do not move this before authorization check.\n  // This is done to avoid exposing extra information to the requester.\n  if (booking.status === BookingStatus.ACCEPTED) {\n    throw new TRPCError({ code: \"BAD_REQUEST\", message: \"Booking already confirmed\" });\n  }\n\n  // If booking requires payment and is not paid, we don't allow confirmation\n  if (confirmed && booking.payment.length > 0 && !booking.paid) {\n    await prisma.booking.update({\n      where: {\n        id: bookingId,\n      },\n      data: {\n        status: BookingStatus.ACCEPTED,\n      },\n    });\n\n    return { message: \"Booking confirmed\", status: BookingStatus.ACCEPTED };\n  }\n\n  // Cache translations to avoid requesting multiple times.\n  const translations = new Map();\n  const attendeesListPromises = booking.attendees.map(async (attendee) => {\n    const locale = attendee.locale ?? \"en\";\n    let translate = translations.get(locale);\n    if (!translate) {\n      translate = await getTranslation(locale, \"common\");\n      translations.set(locale, translate);\n    }\n    return {\n      name: attendee.name,\n      email: attendee.email,\n      timeZone: attendee.timeZone,\n      phoneNumber: attendee.phoneNumber,\n      language: {\n        translate,\n        locale,\n      },\n    };\n  });\n\n  const organizerOrganizationProfile = await prisma.profile.findFirst({\n    where: {\n      userId: booking.user?.id,\n    },\n  });\n\n  const organizerOrganizationId = organizerOrganizationProfile?.organizationId;\n\n  const bookerUrl = await getBookerBaseUrl(\n    booking.eventType?.team?.parentId ?? organizerOrganizationId ?? null\n  );\n\n  const attendeesList = await Promise.all(attendeesListPromises);\n  const tOrganizer = await getTranslation(booking.user?.locale ?? \"en\", \"common\");\n\n  const evt: CalendarEvent = {\n    type: booking?.eventType?.slug as string,\n    title: booking.title,\n    description: booking.description,\n    bookerUrl,\n    // TODO: Remove the usage of `bookingFields` in computing responses. We can do that by storing `label` with the response. Also, this would allow us to correctly show the label for a field even after the Event Type has been deleted.\n    ...getCalEventResponses({\n      bookingFields: booking.eventType?.bookingFields ?? null,\n      booking,\n    }),\n    customInputs: isPrismaObjOrUndefined(booking.customInputs),\n    startTime: booking.startTime.toISOString(),\n    endTime: booking.endTime.toISOString(),\n    organizer: {\n      id: booking.user?.id,\n      email: booking?.userPrimaryEmail || booking.user?.email || \"Email-less\",\n      name: booking.user?.name || \"Nameless\",\n      username: booking.user?.username || undefined,\n      usernameInOrg: organizerOrganizationProfile?.username || undefined,\n      timeZone: booking.user?.timeZone || \"Europe/London\",\n      timeFormat: getTimeFormatStringFromUserTimeFormat(booking.user?.timeFormat),\n      language: { translate: tOrganizer, locale: booking.user?.locale ?? \"en\" },\n    },\n    attendees: attendeesList,\n    location: booking.location ?? \"\",\n    uid: booking.uid,\n    destinationCalendar: booking.destinationCalendar\n      ? [booking.destinationCalendar]\n      : booking.user?.destinationCalendar\n      ? [booking.user?.destinationCalendar]\n      : [],\n    requiresConfirmation: booking?.eventType?.requiresConfirmation ?? false,\n    hideOrganizerEmail: booking.eventType?.hideOrganizerEmail,\n    hideCalendarNotes: booking.eventType?.hideCalendarNotes,\n    hideCalendarEventDetails: booking.eventType?.hideCalendarEventDetails,\n    eventTypeId: booking.eventType?.id,\n    customReplyToEmail: booking.eventType?.customReplyToEmail,\n    team: booking.eventType?.team\n      ? {\n          name: booking.eventType.team.name,\n          id: booking.eventType.team.id,\n          members: [],\n        }\n      : undefined,\n    ...(platformClientParams ? platformClientParams : {}),\n    organizationId: organizerOrganizationId ?? booking.eventType?.team?.parentId ?? null,\n    additionalNotes: booking.description,\n  };\n\n  const recurringEvent = parseRecurringEvent(booking.eventType?.recurringEvent);\n  if (recurringEventId) {\n    if (\n      !(await prisma.booking.findFirst({\n        where: {\n          recurringEventId,\n          id: booking.id,\n        },\n        select: {\n          id: true,\n        },\n      }))\n    ) {\n      // FIXME: It might be best to retrieve recurringEventId from the booking itself.\n      throw new TRPCError({\n        code: \"UNAUTHORIZED\",\n        message: \"Recurring event id doesn't belong to the booking\",\n      });\n    }\n  }\n  if (recurringEventId && recurringEvent) {\n    const groupedRecurringBookings = await prisma.booking.groupBy({\n      where: {\n        recurringEventId: booking.recurringEventId,\n      },\n      by: [Prisma.BookingScalarFieldEnum.recurringEventId],\n      _count: true,\n    });\n    // Overriding the recurring event configuration count to be the actual number of events booked for\n    // the recurring event (equal or less than recurring event configuration count)\n    recurringEvent.count = groupedRecurringBookings[0]._count;\n    // count changed, parsing again to get the new value in\n    evt.recurringEvent = parseRecurringEvent(recurringEvent);\n  }\n\n  if (confirmed) {\n    const credentials = await getUsersCredentialsIncludeServiceAccountKey(booking.user);\n    const userWithCredentials = {\n      ...booking.user,\n      credentials,\n    };\n    const allCredentials = await getAllCredentialsIncludeServiceAccountKey(userWithCredentials, {\n      ...booking.eventType,\n      metadata: booking.eventType?.metadata as EventTypeMetadata,\n    });\n    const conferenceCredentialId = getLocationValueForDB(\n      booking.location ?? \"\",\n      (booking.eventType?.locations as LocationObject[]) || []\n    );\n    evt.conferenceCredentialId = conferenceCredentialId.conferenceCredentialId;\n    await handleConfirmation({\n      user: { ...booking.user, credentials: allCredentials },\n      evt,\n      recurringEventId,\n      prisma,\n      bookingId,\n      booking,\n      emailsEnabled,\n      platformClientParams,\n    });\n  } else {\n    evt.rejectionReason = rejectionReason;\n    if (recurringEventId) {\n      // The booking to reject is a recurring event and comes from /booking/upcoming, proceeding to mark all related\n      // bookings as rejected.\n      await prisma.booking.updateMany({\n        where: {\n          recurringEventId,\n          status: BookingStatus.PENDING,\n        },\n        data: {\n          status: BookingStatus.REJECTED,\n          rejectionReason,\n        },\n      });\n    } else {\n      // handle refunds\n      if (booking.payment.length) {\n        await processPaymentRefund({\n          booking: booking,\n          teamId: booking.eventType?.teamId,\n        });\n      }\n      // end handle refunds.\n\n      await prisma.booking.update({\n        where: {\n          id: bookingId,\n        },\n        data: {\n          status: BookingStatus.REJECTED,\n          rejectionReason,\n        },\n      });\n    }\n\n    if (emailsEnabled) {\n      await sendDeclinedEmailsAndSMS(evt, booking.eventType?.metadata as EventTypeMetadata);\n    }\n\n    const teamId = await getTeamIdFromEventType({\n      eventType: {\n        team: { id: booking.eventType?.teamId ?? null },\n        parentId: booking?.eventType?.parentId ?? null,\n      },\n    });\n\n    const orgId = await getOrgIdFromMemberOrTeamId({ memberId: booking.userId, teamId });\n\n    // send BOOKING_REJECTED webhooks\n    const subscriberOptions: GetSubscriberOptions = {\n      userId: booking.userId,\n      eventTypeId: booking.eventTypeId,\n      triggerEvent: WebhookTriggerEvents.BOOKING_REJECTED,\n      teamId,\n      orgId,\n      oAuthClientId: platformClientParams?.platformClientId,\n    };\n    const eventTrigger: WebhookTriggerEvents = WebhookTriggerEvents.BOOKING_REJECTED;\n    const eventTypeInfo: EventTypeInfo = {\n      eventTitle: booking.eventType?.title,\n      eventDescription: booking.eventType?.description,\n      requiresConfirmation: booking.eventType?.requiresConfirmation || null,\n      price: booking.eventType?.price,\n      currency: booking.eventType?.currency,\n      length: booking.eventType?.length,\n    };\n    const webhookData: EventPayloadType = {\n      ...evt,\n      ...eventTypeInfo,\n      bookingId,\n      eventTypeId: booking.eventType?.id,\n      status: BookingStatus.REJECTED,\n      smsReminderNumber: booking.smsReminderNumber || undefined,\n    };\n    await handleWebhookTrigger({ subscriberOptions, eventTrigger, webhookData });\n\n    const workflows = await getAllWorkflowsFromEventType(booking.eventType, booking.user?.id);\n    try {\n      const creditService = new CreditService();\n\n      await WorkflowService.scheduleWorkflowsFilteredByTriggerEvent({\n        workflows,\n        smsReminderNumber: booking.smsReminderNumber,\n        calendarEvent: {\n          ...evt,\n          bookerUrl: bookerUrl,\n          eventType: {\n            ...eventTypeInfo,\n            slug: booking.eventType?.slug as string,\n          },\n        },\n        hideB",
            "cost": 0.132415
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25394",
        "repo": "calcom/cal.com",
        "base_commit": "81224f324ada684cd47a6be44388447b12dea1f2",
        "head_commit": "b83d9c9c63dc25d8ef8359581712fbd8636b8089",
        "title": "fix: Use the correct user when confirming or rejecting a booking",
        "merged_at": "2025-11-26T11:23:58Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25394",
        "test_files": [
            "apps/web/test/lib/confirm.handler.test.ts"
        ],
        "code_files": [
            "packages/trpc/server/routers/viewer/bookings/confirm.handler.ts"
        ],
        "total_changes": 11,
        "num_files": 2,
        "pull_number": 25394,
        "patch": "diff --git a/apps/web/test/lib/confirm.handler.test.ts b/apps/web/test/lib/confirm.handler.test.ts\nindex ca85519cfb04d5..0ef053d381fc2e 100644\n--- a/apps/web/test/lib/confirm.handler.test.ts\n+++ b/apps/web/test/lib/confirm.handler.test.ts\n@@ -73,6 +73,7 @@ describe(\"confirmHandler\", () => {\n             location: \"integrations:daily\",\n             attendees: [attendeeUser],\n             responses: { name: attendeeUser.name, email: attendeeUser.email, notes: \"Sensitive information\" },\n+            user: { id: organizer.id },\n           },\n         ],\n         organizer,\ndiff --git a/packages/trpc/server/routers/viewer/bookings/confirm.handler.ts b/packages/trpc/server/routers/viewer/bookings/confirm.handler.ts\nindex 558d98d9960e99..a170e1a7306e05 100644\n--- a/packages/trpc/server/routers/viewer/bookings/confirm.handler.ts\n+++ b/packages/trpc/server/routers/viewer/bookings/confirm.handler.ts\n@@ -45,7 +45,6 @@ type ConfirmOptions = {\n };\n \n export const confirmHandler = async ({ ctx, input }: ConfirmOptions) => {\n-  const { user } = ctx;\n   const {\n     bookingId,\n     recurringEventId,\n@@ -139,12 +138,17 @@ export const confirmHandler = async ({ ctx, input }: ConfirmOptions) => {\n     },\n   });\n \n+  const user = booking.user;\n+  if (!user) {\n+    throw new TRPCError({ code: \"BAD_REQUEST\", message: \"Booking must have an organizer\" });\n+  }\n+\n   await checkIfUserIsAuthorizedToConfirmBooking({\n     eventTypeId: booking.eventTypeId,\n-    loggedInUserId: user.id,\n+    loggedInUserId: ctx.user.id,\n     teamId: booking.eventType?.teamId || booking.eventType?.parent?.teamId,\n     bookingUserId: booking.userId,\n-    userRole: user.role,\n+    userRole: ctx.user.role,\n   });\n \n   // Do not move this before authorization check.\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}