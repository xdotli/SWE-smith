{
    "cost": 0.093075,
    "rewrites": {
        "calcom__cal.com.main/packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts": {
            "output": "import type { z } from \"zod\";\n\nimport { getUsersCredentialsIncludeServiceAccountKey } from \"@calcom/app-store/delegationCredential\";\nimport { getEventLocationType, OrganizerDefaultConferencingAppType } from \"@calcom/app-store/locations\";\nimport { getAppFromSlug } from \"@calcom/app-store/utils\";\nimport { sendLocationChangeEmailsAndSMS } from \"@calcom/emails/email-manager\";\nimport EventManager from \"@calcom/features/bookings/lib/EventManager\";\nimport { BookingRepository } from \"@calcom/features/bookings/repositories/BookingRepository\";\nimport { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport { getVideoCallUrlFromCalEvent } from \"@calcom/lib/CalEventParser\";\nimport { buildCalEventFromBooking } from \"@calcom/lib/buildCalEventFromBooking\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Booking, BookingReference } from \"@calcom/prisma/client\";\nimport type { userMetadata } from \"@calcom/prisma/zod-utils\";\nimport type { EventTypeMetadata } from \"@calcom/prisma/zod-utils\";\nimport type { AdditionalInformation, CalendarEvent } from \"@calcom/types/Calendar\";\nimport type { PartialReference } from \"@calcom/types/EventManager\";\nimport type { Ensure } from \"@calcom/types/utils\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TrpcSessionUser } from \"../../../types\";\nimport type { TEditLocationInputSchema } from \"./editLocation.schema\";\nimport type { BookingsProcedureContext } from \"./util\";\n\n// #region EditLocation Types and Helpers\ntype EditLocationOptions = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  } & BookingsProcedureContext;\n  input: TEditLocationInputSchema;\n};\n\ntype UserMetadata = z.infer<typeof userMetadata>;\n\nasync function updateLocationInConnectedAppForBooking({\n  evt,\n  eventManager,\n  booking,\n}: {\n  evt: CalendarEvent;\n  eventManager: EventManager;\n  booking: Booking & {\n    references: BookingReference[];\n  };\n}) {\n  const updatedResult = await eventManager.updateLocation(evt, booking);\n  const results = updatedResult.results;\n  if (results.length > 0 && results.every((res) => !res.success)) {\n    const error = {\n      errorCode: \"BookingUpdateLocationFailed\",\n      message: \"Updating location failed\",\n    };\n    logger.error(`Updating location failed`, safeStringify(error), safeStringify(results));\n    throw new SystemError(\"Updating location failed\");\n  }\n  logger.info(`Got results from updateLocationInConnectedApp`, safeStringify(updatedResult.results));\n  return updatedResult;\n}\n\nfunction extractAdditionalInformation(result: {\n  updatedEvent: AdditionalInformation;\n}): AdditionalInformation {\n  const additionalInformation: AdditionalInformation = {};\n  if (result) {\n    additionalInformation.hangoutLink = result.updatedEvent?.hangoutLink;\n    additionalInformation.conferenceData = result.updatedEvent?.conferenceData;\n    additionalInformation.entryPoints = result.updatedEvent?.entryPoints;\n  }\n  return additionalInformation;\n}\n\nasync function updateBookingLocationInDb({\n  booking,\n  evt,\n  references,\n}: {\n  booking: {\n    id: number;\n    metadata: Booking[\"metadata\"];\n    responses: Booking[\"responses\"];\n  };\n  evt: Ensure<CalendarEvent, \"location\">;\n  references: PartialReference[];\n}) {\n  const isSeatedEvent = !!evt.seatsPerTimeSlot;\n  const bookingMetadataUpdate = {\n    videoCallUrl: getVideoCallUrlFromCalEvent(evt),\n  };\n  const referencesToCreate = references.map((reference) => {\n    const { credentialId, ...restReference } = reference;\n    return {\n      ...restReference,\n      ...(credentialId && credentialId > 0 ? { credentialId } : {}),\n    };\n  });\n  const responses = {\n    ...(typeof booking.responses === \"object\" && booking.responses),\n    location: {\n      value: evt.location,\n      optionValue: \"\",\n    },\n  };\n\n  const bookingRepository = new BookingRepository(prisma);\n  await bookingRepository.updateLocationById({\n    where: { id: booking.id },\n    data: {\n      location: evt.location,\n      metadata: {\n        ...(typeof booking.metadata === \"object\" && booking.metadata),\n        ...bookingMetadataUpdate,\n      },\n      referencesToCreate,\n      ...(!isSeatedEvent ? { responses } : {}),\n      iCalSequence: (evt.iCalSequence || 0) + 1,\n    },\n  });\n}\n\nasync function getAllCredentialsIncludeServiceAccountKey({\n  user,\n  conferenceCredentialId,\n}: {\n  user: { id: number; email: string };\n  conferenceCredentialId: number | null;\n}) {\n  const credentials = await getUsersCredentialsIncludeServiceAccountKey(user);\n\n  let conferenceCredential;\n\n  if (conferenceCredentialId) {\n    conferenceCredential = await CredentialRepository.findFirstByIdWithKeyAndUser({\n      id: conferenceCredentialId,\n    });\n  }\n  return [...(credentials ? credentials : []), ...(conferenceCredential ? [conferenceCredential] : [])];\n}\n\nasync function getLocationInEvtFormatOrThrow({\n  location,\n  organizer,\n  loggedInUserTranslate,\n}: {\n  location: string;\n  organizer: {\n    name: string | null;\n    metadata: UserMetadata;\n  };\n  loggedInUserTranslate: Awaited<ReturnType<typeof getTranslation>>;\n}) {\n  if (location !== OrganizerDefaultConferencingAppType) {\n    return location;\n  }\n\n  try {\n    return getLocationForOrganizerDefaultConferencingAppInEvtFormat({\n      organizer: {\n        name: organizer.name ?? \"Organizer\",\n        metadata: organizer.metadata,\n      },\n      loggedInUserTranslate,\n    });\n  } catch (e) {\n    if (e instanceof UserError) {\n      throw new TRPCError({ code: \"BAD_REQUEST\", message: e.message });\n    }\n    logger.error(safeStringify(e));\n    throw e;\n  }\n}\n// #endregion\n\n/**\n * An error that should be shown to the user\n */\nexport class UserError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"LocationError\";\n  }\n}\n\n/**\n * An error that should not be shown to the user\n */\nexport class SystemError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SystemError\";\n  }\n}\n\nexport function getLocationForOrganizerDefaultConferencingAppInEvtFormat({\n  organizer,\n  loggedInUserTranslate: translate,\n}: {\n  organizer: {\n    name: string;\n    metadata: {\n      defaultConferencingApp?: NonNullable<UserMetadata>[\"defaultConferencingApp\"];\n    } | null;\n  };\n  /**\n   * translate is used to translate if any error is thrown\n   */\n  loggedInUserTranslate: Awaited<ReturnType<typeof getTranslation>>;\n}) {\n  const organizerMetadata = organizer.metadata;\n  const defaultConferencingApp = organizerMetadata?.defaultConferencingApp;\n  if (!defaultConferencingApp) {\n    throw new UserError(\n      translate(\"organizer_default_conferencing_app_not_found\", { organizer: organizer.name })\n    );\n  }\n  const defaultConferencingAppSlug = defaultConferencingApp.appSlug;\n  const app = getAppFromSlug(defaultConferencingAppSlug);\n  if (!app) {\n    throw new SystemError(`Default conferencing app ${defaultConferencingAppSlug} not found`);\n  }\n  const defaultConferencingAppLocationType = app.appData?.location?.type;\n  if (!defaultConferencingAppLocationType) {\n    throw new SystemError(\"Default conferencing app has no location type\");\n  }\n\n  const location = defaultConferencingAppLocationType;\n  const locationType = getEventLocationType(location);\n  if (!locationType) {\n    throw new SystemError(`Location type not found: ${location}`);\n  }\n\n  if (locationType.linkType === \"dynamic\") {\n    // Dynamic location type need to return the location as it is e.g. integrations:zoom_video\n    return location;\n  }\n\n  const appLink = defaultConferencingApp.appLink;\n  if (!appLink) {\n    throw new SystemError(`Default conferencing app ${defaultConferencingAppSlug} has no app link`);\n  }\n  return appLink;\n}\n\nexport async function editLocationHandler({ ctx, input }: EditLocationOptions) {\n  const { newLocation, credentialId: conferenceCredentialId } = input;\n  const { booking, user: loggedInUser } = ctx;\n\n  const organizer = await new UserRepository(prisma).findByIdOrThrow({ id: booking.userId || 0 });\n  const organizationId = booking.user?.profiles?.[0]?.organizationId ?? null;\n\n  const newLocationInEvtFormat = await getLocationInEvtFormatOrThrow({\n    location: newLocation,\n    organizer,\n    loggedInUserTranslate: await getTranslation(loggedInUser.locale ?? \"en\", \"common\"),\n  });\n\n  const evt = await buildCalEventFromBooking({\n    booking,\n    organizer,\n    location: newLocationInEvtFormat,\n    conferenceCredentialId,\n    organizationId,\n  });\n\n  const eventManager = new EventManager({\n    ...ctx.user,\n    credentials: await getAllCredentialsIncludeServiceAccountKey({ user: ctx.user, conferenceCredentialId }),\n  });\n\n  const updatedResult = await updateLocationInConnectedAppForBooking({\n    booking,\n    eventManager,\n    evt,\n  });\n\n  const additionalInformation = extractAdditionalInformation(updatedResult.results[0]);\n\n  await updateBookingLocationInDb({\n    booking,\n    evt: { ...evt, additionalInformation },\n    references: updatedResult.referencesToCreate,\n  });\n\n  try {\n    await sendLocationChangeEmailsAndSMS(\n      { ...evt, additionalInformation },\n      booking?.eventType?.metadata as EventTypeMetadata\n    );\n  } catch (error) {\n    console.log(\"Error sending LocationChangeEmails\", safeStringify(error));\n  }\n\n  return { message: \"Location updated\" };\n}",
            "output_extracted": "import type { z } from \"zod\";\n\nimport { getUsersCredentialsIncludeServiceAccountKey } from \"@calcom/app-store/delegationCredential\";\nimport { getEventLocationType, OrganizerDefaultConferencingAppType } from \"@calcom/app-store/locations\";\nimport { getAppFromSlug } from \"@calcom/app-store/utils\";\nimport { sendLocationChangeEmailsAndSMS } from \"@calcom/emails/email-manager\";\nimport EventManager from \"@calcom/features/bookings/lib/EventManager\";\nimport { BookingRepository } from \"@calcom/features/bookings/repositories/BookingRepository\";\nimport { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport { getVideoCallUrlFromCalEvent } from \"@calcom/lib/CalEventParser\";\nimport { buildCalEventFromBooking } from \"@calcom/lib/buildCalEventFromBooking\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Booking, BookingReference } from \"@calcom/prisma/client\";\nimport type { userMetadata } from \"@calcom/prisma/zod-utils\";\nimport type { EventTypeMetadata } from \"@calcom/prisma/zod-utils\";\nimport type { AdditionalInformation, CalendarEvent } from \"@calcom/types/Calendar\";\nimport type { PartialReference } from \"@calcom/types/EventManager\";\nimport type { Ensure } from \"@calcom/types/utils\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TrpcSessionUser } from \"../../../types\";\nimport type { TEditLocationInputSchema } from \"./editLocation.schema\";\nimport type { BookingsProcedureContext } from \"./util\";\n\n// #region EditLocation Types and Helpers\ntype EditLocationOptions = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  } & BookingsProcedureContext;\n  input: TEditLocationInputSchema;\n};\n\ntype UserMetadata = z.infer<typeof userMetadata>;\n\nasync function updateLocationInConnectedAppForBooking({\n  evt,\n  eventManager,\n  booking,\n}: {\n  evt: CalendarEvent;\n  eventManager: EventManager;\n  booking: Booking & {\n    references: BookingReference[];\n  };\n}) {\n  const updatedResult = await eventManager.updateLocation(evt, booking);\n  const results = updatedResult.results;\n  if (results.length > 0 && results.every((res) => !res.success)) {\n    const error = {\n      errorCode: \"BookingUpdateLocationFailed\",\n      message: \"Updating location failed\",\n    };\n    logger.error(`Updating location failed`, safeStringify(error), safeStringify(results));\n    throw new SystemError(\"Updating location failed\");\n  }\n  logger.info(`Got results from updateLocationInConnectedApp`, safeStringify(updatedResult.results));\n  return updatedResult;\n}\n\nfunction extractAdditionalInformation(result: {\n  updatedEvent: AdditionalInformation;\n}): AdditionalInformation {\n  const additionalInformation: AdditionalInformation = {};\n  if (result) {\n    additionalInformation.hangoutLink = result.updatedEvent?.hangoutLink;\n    additionalInformation.conferenceData = result.updatedEvent?.conferenceData;\n    additionalInformation.entryPoints = result.updatedEvent?.entryPoints;\n  }\n  return additionalInformation;\n}\n\nasync function updateBookingLocationInDb({\n  booking,\n  evt,\n  references,\n}: {\n  booking: {\n    id: number;\n    metadata: Booking[\"metadata\"];\n    responses: Booking[\"responses\"];\n  };\n  evt: Ensure<CalendarEvent, \"location\">;\n  references: PartialReference[];\n}) {\n  const isSeatedEvent = !!evt.seatsPerTimeSlot;\n  const bookingMetadataUpdate = {\n    videoCallUrl: getVideoCallUrlFromCalEvent(evt),\n  };\n  const referencesToCreate = references.map((reference) => {\n    const { credentialId, ...restReference } = reference;\n    return {\n      ...restReference,\n      ...(credentialId && credentialId > 0 ? { credentialId } : {}),\n    };\n  });\n  const responses = {\n    ...(typeof booking.responses === \"object\" && booking.responses),\n    location: {\n      value: evt.location,\n      optionValue: \"\",\n    },\n  };\n\n  const bookingRepository = new BookingRepository(prisma);\n  await bookingRepository.updateLocationById({\n    where: { id: booking.id },\n    data: {\n      location: evt.location,\n      metadata: {\n        ...(typeof booking.metadata === \"object\" && booking.metadata),\n        ...bookingMetadataUpdate,\n      },\n      referencesToCreate,\n      ...(!isSeatedEvent ? { responses } : {}),\n      iCalSequence: (evt.iCalSequence || 0) + 1,\n    },\n  });\n}\n\nasync function getAllCredentialsIncludeServiceAccountKey({\n  user,\n  conferenceCredentialId,\n}: {\n  user: { id: number; email: string };\n  conferenceCredentialId: number | null;\n}) {\n  const credentials = await getUsersCredentialsIncludeServiceAccountKey(user);\n\n  let conferenceCredential;\n\n  if (conferenceCredentialId) {\n    conferenceCredential = await CredentialRepository.findFirstByIdWithKeyAndUser({\n      id: conferenceCredentialId,\n    });\n  }\n  return [...(credentials ? credentials : []), ...(conferenceCredential ? [conferenceCredential] : [])];\n}\n\nasync function getLocationInEvtFormatOrThrow({\n  location,\n  organizer,\n  loggedInUserTranslate,\n}: {\n  location: string;\n  organizer: {\n    name: string | null;\n    metadata: UserMetadata;\n  };\n  loggedInUserTranslate: Awaited<ReturnType<typeof getTranslation>>;\n}) {\n  if (location !== OrganizerDefaultConferencingAppType) {\n    return location;\n  }\n\n  try {\n    return getLocationForOrganizerDefaultConferencingAppInEvtFormat({\n      organizer: {\n        name: organizer.name ?? \"Organizer\",\n        metadata: organizer.metadata,\n      },\n      loggedInUserTranslate,\n    });\n  } catch (e) {\n    if (e instanceof UserError) {\n      throw new TRPCError({ code: \"BAD_REQUEST\", message: e.message });\n    }\n    logger.error(safeStringify(e));\n    throw e;\n  }\n}\n// #endregion\n\n/**\n * An error that should be shown to the user\n */\nexport class UserError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"LocationError\";\n  }\n}\n\n/**\n * An error that should not be shown to the user\n */\nexport class SystemError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SystemError\";\n  }\n}\n\nexport function getLocationForOrganizerDefaultConferencingAppInEvtFormat({\n  organizer,\n  loggedInUserTranslate: translate,\n}: {\n  organizer: {\n    name: string;\n    metadata: {\n      defaultConferencingApp?: NonNullable<UserMetadata>[\"defaultConferencingApp\"];\n    } | null;\n  };\n  /**\n   * translate is used to translate if any error is thrown\n   */\n  loggedInUserTranslate: Awaited<ReturnType<typeof getTranslation>>;\n}) {\n  const organizerMetadata = organizer.metadata;\n  const defaultConferencingApp = organizerMetadata?.defaultConferencingApp;\n  if (!defaultConferencingApp) {\n    throw new UserError(\n      translate(\"organizer_default_conferencing_app_not_found\", { organizer: organizer.name })\n    );\n  }\n  const defaultConferencingAppSlug = defaultConferencingApp.appSlug;\n  const app = getAppFromSlug(defaultConferencingAppSlug);\n  if (!app) {\n    throw new SystemError(`Default conferencing app ${defaultConferencingAppSlug} not found`);\n  }\n  const defaultConferencingAppLocationType = app.appData?.location?.type;\n  if (!defaultConferencingAppLocationType) {\n    throw new SystemError(\"Default conferencing app has no location type\");\n  }\n\n  const location = defaultConferencingAppLocationType;\n  const locationType = getEventLocationType(location);\n  if (!locationType) {\n    throw new SystemError(`Location type not found: ${location}`);\n  }\n\n  if (locationType.linkType === \"dynamic\") {\n    // Dynamic location type need to return the location as it is e.g. integrations:zoom_video\n    return location;\n  }\n\n  const appLink = defaultConferencingApp.appLink;\n  if (!appLink) {\n    throw new SystemError(`Default conferencing app ${defaultConferencingAppSlug} has no app link`);\n  }\n  return appLink;\n}\n\nexport async function editLocationHandler({ ctx, input }: EditLocationOptions) {\n  const { newLocation, credentialId: conferenceCredentialId } = input;\n  const { booking, user: loggedInUser } = ctx;\n\n  const organizer = await new UserRepository(prisma).findByIdOrThrow({ id: booking.userId || 0 });\n  const organizationId = booking.user?.profiles?.[0]?.organizationId ?? null;\n\n  const newLocationInEvtFormat = await getLocationInEvtFormatOrThrow({\n    location: newLocation,\n    organizer,\n    loggedInUserTranslate: await getTranslation(loggedInUser.locale ?? \"en\", \"common\"),\n  });\n\n  const evt = await buildCalEventFromBooking({\n    booking,\n    organizer,\n    location: newLocationInEvtFormat,\n    conferenceCredentialId,\n    organizationId,\n  });\n\n  const eventManager = new EventManager({\n    ...ctx.user,\n    credentials: await getAllCredentialsIncludeServiceAccountKey({ user: ctx.user, conferenceCredentialId }),\n  });\n\n  const updatedResult = await updateLocationInConnectedAppForBooking({\n    booking,\n    eventManager,\n    evt,\n  });\n\n  const additionalInformation = extractAdditionalInformation(updatedResult.results[0]);\n\n  await updateBookingLocationInDb({\n    booking,\n    evt: { ...evt, additionalInformation },\n    references: updatedResult.referencesToCreate,\n  });\n\n  try {\n    await sendLocationChangeEmailsAndSMS(\n      { ...evt, additionalInformation },\n      booking?.eventType?.metadata as EventTypeMetadata\n    );\n  } catch (error) {\n    console.log(\"Error sending LocationChangeEmails\", safeStringify(error));\n  }\n\n  return { message: \"Location updated\" };\n}",
            "cost": 0.093075
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25315",
        "repo": "calcom/cal.com",
        "base_commit": "6499243a42c565c444b6b86f8c288413b5ac5a7c",
        "head_commit": "db5d90c3b1833000f3e7e80b4d1b1d76471603c5",
        "title": "fix: access service class for editLocationHandler",
        "merged_at": "2025-11-21T16:13:06Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25315",
        "test_files": [
            "packages/features/credentials/services/CredentialAccessService.test.ts"
        ],
        "code_files": [
            "packages/features/credentials/services/CredentialAccessService.ts",
            "packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts"
        ],
        "total_changes": 468,
        "num_files": 3,
        "pull_number": 25315,
        "patch": "diff --git a/packages/features/credentials/services/CredentialAccessService.test.ts b/packages/features/credentials/services/CredentialAccessService.test.ts\nnew file mode 100644\nindex 00000000000000..69852b0d4e31aa\n--- /dev/null\n+++ b/packages/features/credentials/services/CredentialAccessService.test.ts\n@@ -0,0 +1,320 @@\n+import { describe, expect, test, vi, beforeEach } from \"vitest\";\n+\n+import { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\n+import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n+import { HttpError } from \"@calcom/lib/http-error\";\n+import { prisma } from \"@calcom/prisma\";\n+\n+import { CredentialAccessService } from \"./CredentialAccessService\";\n+\n+vi.mock(\"@calcom/prisma\", () => {\n+  return {\n+    prisma: {\n+      user: {\n+        findUnique: vi.fn(),\n+      },\n+    },\n+  };\n+});\n+\n+vi.mock(\"@calcom/features/credentials/repositories/CredentialRepository\", () => {\n+  return {\n+    CredentialRepository: {\n+      findFirstByIdWithKeyAndUser: vi.fn(),\n+    },\n+  };\n+});\n+\n+vi.mock(\"@calcom/features/users/repositories/UserRepository\", () => {\n+  return {\n+    UserRepository: vi.fn().mockImplementation(() => ({\n+      getUserOrganizationAndTeams: vi.fn(),\n+    })),\n+  };\n+});\n+\n+describe(\"CredentialAccessService\", () => {\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+  });\n+\n+  test(\"should allow access when credential belongs to logged-in user\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: loggedInUserId,\n+      teamId: null,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: { email: \"user@example.com\" },\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+\n+  test(\"should allow access when credential belongs to booking owner\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: bookingOwnerId,\n+      teamId: null,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: { email: \"owner@example.com\" },\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+\n+  test(\"should allow access when credential belongs to team the logged-in user belongs to\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+    const teamId = 50;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: null,\n+      teamId: teamId,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: null,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const mockUserRepo = {\n+      getUserOrganizationAndTeams: vi.fn().mockResolvedValue({\n+        organizationId: null,\n+        teams: [{ teamId: teamId }],\n+      }),\n+    };\n+\n+    vi.mocked(UserRepository).mockImplementation(() => mockUserRepo as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+\n+  test(\"should allow access when credential belongs to team the booking owner belongs to\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+    const teamId = 50;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: null,\n+      teamId: teamId,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: null,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const mockUserRepo = {\n+      getUserOrganizationAndTeams: vi\n+        .fn()\n+        .mockResolvedValueOnce({\n+          organizationId: null,\n+          teams: [],\n+        })\n+        .mockResolvedValueOnce({\n+          organizationId: null,\n+          teams: [{ teamId: teamId }],\n+        }),\n+    };\n+\n+    vi.mocked(UserRepository).mockImplementation(() => mockUserRepo as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+\n+  test(\"should allow access when credential belongs to organization the logged-in user belongs to\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+    const orgId = 50;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: null,\n+      teamId: orgId,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: null,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const mockUserRepo = {\n+      getUserOrganizationAndTeams: vi.fn().mockResolvedValue({\n+        organizationId: orgId,\n+        teams: [],\n+      }),\n+    };\n+\n+    vi.mocked(UserRepository).mockImplementation(() => mockUserRepo as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+\n+  test(\"should throw NOT_FOUND when credential does not exist\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue(null);\n+\n+    const service = new CredentialAccessService();\n+    const error = await service\n+      .ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+      .catch((e) => e);\n+\n+    expect(error).toBeInstanceOf(HttpError);\n+    expect(error.statusCode).toBe(404);\n+    expect(error.message).toBe(\"Credential not found\");\n+  });\n+\n+  test(\"should throw FORBIDDEN when credential is not accessible\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+    const otherUserId = 300;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: otherUserId,\n+      teamId: null,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: { email: \"other@example.com\" },\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const mockUserRepo = {\n+      getUserOrganizationAndTeams: vi\n+        .fn()\n+        .mockResolvedValueOnce({\n+          organizationId: null,\n+          teams: [],\n+        })\n+        .mockResolvedValueOnce({\n+          organizationId: null,\n+          teams: [],\n+        }),\n+    };\n+\n+    vi.mocked(UserRepository).mockImplementation(() => mockUserRepo as any);\n+\n+    const service = new CredentialAccessService();\n+    const error = await service\n+      .ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+      .catch((e) => e);\n+\n+    expect(error).toBeInstanceOf(HttpError);\n+    expect(error.statusCode).toBe(403);\n+    expect(error.message).toBe(\"You do not have access to this credential\");\n+  });\n+\n+  test(\"should handle null bookingOwnerId\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = null;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: loggedInUserId,\n+      teamId: null,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: { email: \"user@example.com\" },\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+});\ndiff --git a/packages/features/credentials/services/CredentialAccessService.ts b/packages/features/credentials/services/CredentialAccessService.ts\nnew file mode 100644\nindex 00000000000000..8b4c21d83f2999\n--- /dev/null\n+++ b/packages/features/credentials/services/CredentialAccessService.ts\n@@ -0,0 +1,130 @@\n+import { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\n+import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n+import { HttpError } from \"@calcom/lib/http-error\";\n+import type { PrismaClient } from \"@calcom/prisma\";\n+import { prisma } from \"@calcom/prisma\";\n+\n+type CredentialAccessInput = {\n+  credentialId: number;\n+  loggedInUserId: number;\n+  bookingOwnerId: number | null;\n+};\n+\n+type UserTeamsData = {\n+  organizationId: number | null;\n+  teams: Array<{ teamId: number }>;\n+} | null;\n+\n+export class CredentialAccessService {\n+  private readonly userRepository: UserRepository;\n+\n+  constructor(private readonly prismaClient: PrismaClient = prisma) {\n+    this.userRepository = new UserRepository(this.prismaClient);\n+  }\n+\n+  /**\n+   * Ensures that a credential is accessible by the logged-in user or booking owner.\n+   */\n+  async ensureAccessible(input: CredentialAccessInput): Promise<void> {\n+    const credential = await this.checkCredentialExists(input.credentialId);\n+\n+    if (this.checkUserOwnership(credential, input.loggedInUserId)) {\n+      return;\n+    }\n+\n+    if (this.checkBookingOwnerOwnership(credential, input.bookingOwnerId)) {\n+      return;\n+    }\n+\n+    await this.checkTeamAccess(credential, input.loggedInUserId, input.bookingOwnerId);\n+  }\n+\n+  private async checkCredentialExists(credentialId: number) {\n+    const credential = await CredentialRepository.findFirstByIdWithKeyAndUser({\n+      id: credentialId,\n+    });\n+\n+    if (!credential) {\n+      throw new HttpError({\n+        statusCode: 404,\n+        message: \"Credential not found\",\n+      });\n+    }\n+\n+    return credential;\n+  }\n+\n+  private checkUserOwnership(\n+    credential: Awaited<ReturnType<typeof CredentialRepository.findFirstByIdWithKeyAndUser>>,\n+    loggedInUserId: number\n+  ): boolean {\n+    return credential?.userId === loggedInUserId;\n+  }\n+\n+  private checkBookingOwnerOwnership(\n+    credential: Awaited<ReturnType<typeof CredentialRepository.findFirstByIdWithKeyAndUser>>,\n+    bookingOwnerId: number | null\n+  ): boolean {\n+    return bookingOwnerId !== null && credential?.userId === bookingOwnerId;\n+  }\n+\n+  private async checkTeamAccess(\n+    credential: NonNullable<Awaited<ReturnType<typeof CredentialRepository.findFirstByIdWithKeyAndUser>>>,\n+    loggedInUserId: number,\n+    bookingOwnerId: number | null\n+  ): Promise<void> {\n+    if (!credential.teamId) {\n+      this.throwForbiddenError();\n+    }\n+\n+    const [loggedInUserTeams, bookingOwnerTeams] = await this.getUserTeamsData(\n+      loggedInUserId,\n+      bookingOwnerId\n+    );\n+\n+    if (this.hasTeamAccess(credential.teamId, loggedInUserTeams)) {\n+      return;\n+    }\n+\n+    if (this.hasTeamAccess(credential.teamId, bookingOwnerTeams)) {\n+      return;\n+    }\n+\n+    this.throwForbiddenError();\n+  }\n+\n+  private async getUserTeamsData(\n+    loggedInUserId: number,\n+    bookingOwnerId: number | null\n+  ): Promise<[UserTeamsData, UserTeamsData]> {\n+    return Promise.all([\n+      this.userRepository.getUserOrganizationAndTeams({ userId: loggedInUserId }),\n+      bookingOwnerId\n+        ? this.userRepository.getUserOrganizationAndTeams({ userId: bookingOwnerId })\n+        : Promise.resolve(null),\n+    ]);\n+  }\n+\n+  private hasTeamAccess(teamId: number, userTeams: UserTeamsData): boolean {\n+    if (!userTeams) {\n+      return false;\n+    }\n+\n+    const teamIds = this.getTeamIdsForUser(userTeams);\n+    return teamIds.includes(teamId);\n+  }\n+\n+  private getTeamIdsForUser(userTeams: NonNullable<UserTeamsData>): number[] {\n+    return [\n+      ...(userTeams.organizationId ? [userTeams.organizationId] : []),\n+      ...(userTeams.teams || []).map((t) => t.teamId),\n+    ];\n+  }\n+\n+  private throwForbiddenError(): never {\n+    throw new HttpError({\n+      statusCode: 403,\n+      message: \"You do not have access to this credential\",\n+    });\n+  }\n+}\ndiff --git a/packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts b/packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts\nindex 52f840d0953e60..203947232ac773 100644\n--- a/packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts\n+++ b/packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts\n@@ -7,6 +7,7 @@ import { sendLocationChangeEmailsAndSMS } from \"@calcom/emails/email-manager\";\n import EventManager from \"@calcom/features/bookings/lib/EventManager\";\n import { BookingRepository } from \"@calcom/features/bookings/repositories/BookingRepository\";\n import { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\n+import { CredentialAccessService } from \"@calcom/features/credentials/services/CredentialAccessService\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n import { getVideoCallUrlFromCalEvent } from \"@calcom/lib/CalEventParser\";\n import { buildCalEventFromBooking } from \"@calcom/lib/buildCalEventFromBooking\";\n@@ -125,15 +126,26 @@ async function updateBookingLocationInDb({\n async function getAllCredentialsIncludeServiceAccountKey({\n   user,\n   conferenceCredentialId,\n+  bookingOwnerId,\n }: {\n   user: { id: number; email: string };\n   conferenceCredentialId: number | null;\n+  bookingOwnerId: number | null;\n }) {\n   const credentials = await getUsersCredentialsIncludeServiceAccountKey(user);\n \n   let conferenceCredential;\n \n   if (conferenceCredentialId) {\n+    // Validate that the credential is accessible before fetching it\n+    const credentialAccessService = new CredentialAccessService();\n+    await credentialAccessService.ensureAccessible({\n+      credentialId: conferenceCredentialId,\n+      loggedInUserId: user.id,\n+      bookingOwnerId,\n+    });\n+\n+    // Now fetch the credential with the key\n     conferenceCredential = await CredentialRepository.findFirstByIdWithKeyAndUser({\n       id: conferenceCredentialId,\n     });\n@@ -266,7 +278,11 @@ export async function editLocationHandler({ ctx, input }: EditLocationOptions) {\n \n   const eventManager = new EventManager({\n     ...ctx.user,\n-    credentials: await getAllCredentialsIncludeServiceAccountKey({ user: ctx.user, conferenceCredentialId }),\n+    credentials: await getAllCredentialsIncludeServiceAccountKey({\n+      user: ctx.user,\n+      conferenceCredentialId,\n+      bookingOwnerId: booking.userId,\n+    }),\n   });\n \n   const updatedResult = await updateLocationInConnectedAppForBooking({\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}