{
    "cost": 0.07141,
    "rewrites": {
        "calcom__cal.com.main/packages/app-store/utils.ts": {
            "output": "// If you import this file on any app it should produce circular dependency\n// import appStore from \"./index\";\nimport { appStoreMetadata } from \"@calcom/app-store/appStoreMetaData\";\nimport type { EventLocationType } from \"@calcom/app-store/locations\";\nimport logger from \"@calcom/lib/logger\";\nimport { getPiiFreeCredential } from \"@calcom/lib/piiFreeData\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport type { AppCategories } from \"@calcom/prisma/client\";\nimport type { App, AppMeta } from \"@calcom/types/App\";\nimport type { CredentialForCalendarService } from \"@calcom/types/Credential\";\n\nexport * from \"./_utils/getEventTypeAppData\";\n\nexport type LocationOption = {\n  label: string;\n  value: EventLocationType[\"type\"];\n  icon?: string;\n  disabled?: boolean;\n};\n\nconst ALL_APPS_MAP = Object.keys(appStoreMetadata).reduce((store, key) => {\n  const metadata = appStoreMetadata[key as keyof typeof appStoreMetadata] as AppMeta;\n\n  store[key] = metadata;\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  //@ts-ignore\n  delete store[key][\"/*\"];\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  //@ts-ignore\n  delete store[key][\"__createdUsingCli\"];\n  return store;\n}, {} as Record<string, AppMeta>);\n\nexport type CredentialDataWithTeamName = CredentialForCalendarService & {\n  team?: {\n    name: string;\n  } | null;\n};\n\nexport const ALL_APPS = Object.values(ALL_APPS_MAP);\n\n/**\n * This should get all available apps to the user based on his saved\n * credentials, this should also get globally available apps.\n */\nfunction getApps(credentials: CredentialDataWithTeamName[], filterOnCredentials?: boolean) {\n  const apps = ALL_APPS.reduce((reducedArray, appMeta) => {\n    const appCredentials = credentials.filter((credential) => credential.appId === appMeta.slug);\n\n    if (filterOnCredentials && !appCredentials.length && !appMeta.isGlobal) return reducedArray;\n\n    let locationOption: LocationOption | null = null;\n\n    /** If the app is a globally installed one, let's inject it's key */\n    if (appMeta.isGlobal) {\n      const credential = {\n        id: 0,\n        type: appMeta.type,\n         \n        key: appMeta.key!,\n        userId: 0,\n        user: { email: \"\" },\n        teamId: null,\n        appId: appMeta.slug,\n        invalid: false,\n        delegatedTo: null,\n        delegatedToId: null,\n        delegationCredentialId: null,\n        team: {\n          name: \"Default\",\n        },\n      };\n      logger.debug(\n        `${appMeta.type} is a global app, injecting credential`,\n        safeStringify(getPiiFreeCredential(credential))\n      );\n      appCredentials.push(credential);\n    }\n\n    /** Check if app has location option AND add it if user has credentials for it */\n    if (appCredentials.length > 0 && appMeta?.appData?.location) {\n      locationOption = {\n        value: appMeta.appData.location.type,\n        label: appMeta.appData.location.label || \"No label set\",\n        disabled: false,\n      };\n    }\n\n    const credential: (typeof appCredentials)[number] | null = appCredentials[0] || null;\n\n    reducedArray.push({\n      ...appMeta,\n      /**\n       * @deprecated use `credentials`\n       */\n      credential,\n      credentials: appCredentials,\n      /** Option to display in `location` field while editing event types */\n      locationOption,\n    });\n\n    return reducedArray;\n  }, [] as (App & { credential: CredentialDataWithTeamName; credentials: CredentialDataWithTeamName[]; locationOption: LocationOption | null })[]);\n\n  return apps;\n}\n\nexport function getLocalAppMetadata() {\n  return ALL_APPS;\n}\n\nexport function hasIntegrationInstalled(type: App[\"type\"]): boolean {\n  return ALL_APPS.some((app) => app.type === type && !!app.installed);\n}\n\nexport function getAppName(name: string): string | null {\n  return ALL_APPS_MAP[name as keyof typeof ALL_APPS_MAP]?.name ?? null;\n}\n\nexport function getAppType(name: string): string {\n  const type = ALL_APPS_MAP[name as keyof typeof ALL_APPS_MAP].type;\n\n  if (type.endsWith(\"_calendar\")) {\n    return \"Calendar\";\n  }\n  if (type.endsWith(\"_payment\")) {\n    return \"Payment\";\n  }\n  return \"Unknown\";\n}\n\nexport function getAppFromSlug(slug: string | undefined): AppMeta | undefined {\n  return ALL_APPS.find((app) => app.slug === slug);\n}\n\nexport function getAppFromLocationValue(type: string): AppMeta | undefined {\n  return ALL_APPS.find((app) => app?.appData?.location?.type === type);\n}\n\n/**\n *\n * @param appCategories - from app metadata\n * @param concurrentMeetings - from app metadata\n * @returns - true if app supports team install\n */\nexport function doesAppSupportTeamInstall({\n  appCategories,\n  concurrentMeetings = undefined,\n  isPaid,\n}: {\n  appCategories: string[];\n  concurrentMeetings: boolean | undefined;\n  isPaid: boolean;\n}) {\n  // Paid apps can't be installed on team level - That isn't supported\n  if (isPaid) {\n    return false;\n  }\n  return !appCategories.some(\n    (category) =>\n      category === \"calendar\" ||\n      (defaultVideoAppCategories.includes(category as AppCategories) && !concurrentMeetings)\n  );\n}\n\nexport function isConferencing(appCategories: string[]) {\n  return appCategories.some((category) => category === \"conferencing\" || category === \"video\");\n}\nexport const defaultVideoAppCategories: AppCategories[] = [\n  \"messaging\",\n  \"conferencing\",\n  // Legacy name for conferencing\n  \"video\",\n];\n\nexport default getApps;",
            "output_extracted": "// If you import this file on any app it should produce circular dependency\n// import appStore from \"./index\";\nimport { appStoreMetadata } from \"@calcom/app-store/appStoreMetaData\";\nimport type { EventLocationType } from \"@calcom/app-store/locations\";\nimport logger from \"@calcom/lib/logger\";\nimport { getPiiFreeCredential } from \"@calcom/lib/piiFreeData\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport type { AppCategories } from \"@calcom/prisma/client\";\nimport type { App, AppMeta } from \"@calcom/types/App\";\nimport type { CredentialForCalendarService } from \"@calcom/types/Credential\";\n\nexport * from \"./_utils/getEventTypeAppData\";\n\nexport type LocationOption = {\n  label: string;\n  value: EventLocationType[\"type\"];\n  icon?: string;\n  disabled?: boolean;\n};\n\nconst ALL_APPS_MAP = Object.keys(appStoreMetadata).reduce((store, key) => {\n  const metadata = appStoreMetadata[key as keyof typeof appStoreMetadata] as AppMeta;\n\n  store[key] = metadata;\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  //@ts-ignore\n  delete store[key][\"/*\"];\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  //@ts-ignore\n  delete store[key][\"__createdUsingCli\"];\n  return store;\n}, {} as Record<string, AppMeta>);\n\nexport type CredentialDataWithTeamName = CredentialForCalendarService & {\n  team?: {\n    name: string;\n  } | null;\n};\n\nexport const ALL_APPS = Object.values(ALL_APPS_MAP);\n\n/**\n * This should get all available apps to the user based on his saved\n * credentials, this should also get globally available apps.\n */\nfunction getApps(credentials: CredentialDataWithTeamName[], filterOnCredentials?: boolean) {\n  const apps = ALL_APPS.reduce((reducedArray, appMeta) => {\n    const appCredentials = credentials.filter((credential) => credential.appId === appMeta.slug);\n\n    if (filterOnCredentials && !appCredentials.length && !appMeta.isGlobal) return reducedArray;\n\n    let locationOption: LocationOption | null = null;\n\n    /** If the app is a globally installed one, let's inject it's key */\n    if (appMeta.isGlobal) {\n      const credential = {\n        id: 0,\n        type: appMeta.type,\n         \n        key: appMeta.key!,\n        userId: 0,\n        user: { email: \"\" },\n        teamId: null,\n        appId: appMeta.slug,\n        invalid: false,\n        delegatedTo: null,\n        delegatedToId: null,\n        delegationCredentialId: null,\n        team: {\n          name: \"Default\",\n        },\n      };\n      logger.debug(\n        `${appMeta.type} is a global app, injecting credential`,\n        safeStringify(getPiiFreeCredential(credential))\n      );\n      appCredentials.push(credential);\n    }\n\n    /** Check if app has location option AND add it if user has credentials for it */\n    if (appCredentials.length > 0 && appMeta?.appData?.location) {\n      locationOption = {\n        value: appMeta.appData.location.type,\n        label: appMeta.appData.location.label || \"No label set\",\n        disabled: false,\n      };\n    }\n\n    const credential: (typeof appCredentials)[number] | null = appCredentials[0] || null;\n\n    reducedArray.push({\n      ...appMeta,\n      /**\n       * @deprecated use `credentials`\n       */\n      credential,\n      credentials: appCredentials,\n      /** Option to display in `location` field while editing event types */\n      locationOption,\n    });\n\n    return reducedArray;\n  }, [] as (App & { credential: CredentialDataWithTeamName; credentials: CredentialDataWithTeamName[]; locationOption: LocationOption | null })[]);\n\n  return apps;\n}\n\nexport function getLocalAppMetadata() {\n  return ALL_APPS;\n}\n\nexport function hasIntegrationInstalled(type: App[\"type\"]): boolean {\n  return ALL_APPS.some((app) => app.type === type && !!app.installed);\n}\n\nexport function getAppName(name: string): string | null {\n  return ALL_APPS_MAP[name as keyof typeof ALL_APPS_MAP]?.name ?? null;\n}\n\nexport function getAppType(name: string): string {\n  const type = ALL_APPS_MAP[name as keyof typeof ALL_APPS_MAP].type;\n\n  if (type.endsWith(\"_calendar\")) {\n    return \"Calendar\";\n  }\n  if (type.endsWith(\"_payment\")) {\n    return \"Payment\";\n  }\n  return \"Unknown\";\n}\n\nexport function getAppFromSlug(slug: string | undefined): AppMeta | undefined {\n  return ALL_APPS.find((app) => app.slug === slug);\n}\n\nexport function getAppFromLocationValue(type: string): AppMeta | undefined {\n  return ALL_APPS.find((app) => app?.appData?.location?.type === type);\n}\n\n/**\n *\n * @param appCategories - from app metadata\n * @param concurrentMeetings - from app metadata\n * @returns - true if app supports team install\n */\nexport function doesAppSupportTeamInstall({\n  appCategories,\n  concurrentMeetings = undefined,\n  isPaid,\n}: {\n  appCategories: string[];\n  concurrentMeetings: boolean | undefined;\n  isPaid: boolean;\n}) {\n  // Paid apps can't be installed on team level - That isn't supported\n  if (isPaid) {\n    return false;\n  }\n  return !appCategories.some(\n    (category) =>\n      category === \"calendar\" ||\n      (defaultVideoAppCategories.includes(category as AppCategories) && !concurrentMeetings)\n  );\n}\n\nexport function isConferencing(appCategories: string[]) {\n  return appCategories.some((category) => category === \"conferencing\" || category === \"video\");\n}\nexport const defaultVideoAppCategories: AppCategories[] = [\n  \"messaging\",\n  \"conferencing\",\n  // Legacy name for conferencing\n  \"video\",\n];\n\nexport default getApps;",
            "cost": 0.055015
        },
        "calcom__cal.com.main/packages/trpc/server/routers/viewer/apps/appById.handler.ts": {
            "output": "import { getUsersCredentialsIncludeServiceAccountKey } from \"@calcom/app-store/delegationCredential\";\nimport getApps from \"@calcom/app-store/utils\";\nimport type { TrpcSessionUser } from \"@calcom/trpc/server/types\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TAppByIdInputSchema } from \"./appById.schema\";\n\ntype AppByIdOptions = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  };\n  input: TAppByIdInputSchema;\n};\n\nexport const appByIdHandler = async ({ ctx, input }: AppByIdOptions) => {\n  const { user } = ctx;\n  const appId = input.appId;\n  // getApps need credentials with service account key, but we are filtering credentials out already before returning from this fn\n  const credentials = await getUsersCredentialsIncludeServiceAccountKey(user);\n  const apps = getApps(credentials);\n  const appFromDb = apps.find((app) => app.slug === appId);\n  if (!appFromDb) {\n    throw new TRPCError({ code: \"BAD_REQUEST\", message: `Could not find app ${appId}` });\n  }\n\n   \n  const { credential: _, credentials: _1, ...app } = appFromDb;\n  return {\n    isInstalled: appFromDb.credentials.length,\n    ...app,\n  };\n};",
            "output_extracted": "import { getUsersCredentialsIncludeServiceAccountKey } from \"@calcom/app-store/delegationCredential\";\nimport getApps from \"@calcom/app-store/utils\";\nimport type { TrpcSessionUser } from \"@calcom/trpc/server/types\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TAppByIdInputSchema } from \"./appById.schema\";\n\ntype AppByIdOptions = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  };\n  input: TAppByIdInputSchema;\n};\n\nexport const appByIdHandler = async ({ ctx, input }: AppByIdOptions) => {\n  const { user } = ctx;\n  const appId = input.appId;\n  // getApps need credentials with service account key, but we are filtering credentials out already before returning from this fn\n  const credentials = await getUsersCredentialsIncludeServiceAccountKey(user);\n  const apps = getApps(credentials);\n  const appFromDb = apps.find((app) => app.slug === appId);\n  if (!appFromDb) {\n    throw new TRPCError({ code: \"BAD_REQUEST\", message: `Could not find app ${appId}` });\n  }\n\n   \n  const { credential: _, credentials: _1, ...app } = appFromDb;\n  return {\n    isInstalled: appFromDb.credentials.length,\n    ...app,\n  };\n};",
            "cost": 0.016395
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25323",
        "repo": "calcom/cal.com",
        "base_commit": "6499243a42c565c444b6b86f8c288413b5ac5a7c",
        "head_commit": "55c9bc490b83eb699c0761e16f451eaf5b6cea7e",
        "title": "fix: refactor handler for global apps",
        "merged_at": "2025-11-21T15:51:23Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25323",
        "test_files": [
            "packages/app-store/utils.test.ts",
            "packages/trpc/server/routers/viewer/apps/appById.handler.test.ts"
        ],
        "code_files": [
            "packages/app-store/utils.ts",
            "packages/trpc/server/routers/viewer/apps/appById.handler.ts"
        ],
        "total_changes": 395,
        "num_files": 4,
        "pull_number": 25323,
        "patch": "diff --git a/packages/app-store/utils.test.ts b/packages/app-store/utils.test.ts\nnew file mode 100644\nindex 00000000000000..e2dd98931d15a0\n--- /dev/null\n+++ b/packages/app-store/utils.test.ts\n@@ -0,0 +1,140 @@\n+import { describe, it, expect } from \"vitest\";\n+\n+import type { App } from \"@calcom/types/App\";\n+import type { CredentialForCalendarService } from \"@calcom/types/Credential\";\n+\n+import { sanitizeAppForViewer } from \"./utils\";\n+import type { CredentialDataWithTeamName, LocationOption } from \"./utils\";\n+\n+describe(\"sanitizeAppForViewer\", () => {\n+  it(\"should remove key, credential, and credentials properties\", () => {\n+    const mockCredential: CredentialDataWithTeamName = {\n+      id: 1,\n+      type: \"daily_video\",\n+      key: { api_key: \"secret-api-key\" },\n+      userId: 1,\n+      user: { email: \"test@example.com\" },\n+      teamId: null,\n+      appId: \"daily-video\",\n+      invalid: false,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+      team: null,\n+    };\n+\n+    const mockApp: App & {\n+      credential: CredentialDataWithTeamName | null;\n+      credentials: CredentialDataWithTeamName[];\n+      locationOption: LocationOption | null;\n+    } = {\n+      type: \"daily_video\",\n+      name: \"Daily Video\",\n+      description: \"Video conferencing\",\n+      variant: \"conferencing\",\n+      slug: \"daily-video\",\n+      categories: [\"conferencing\"],\n+      logo: \"/logo.png\",\n+      publisher: \"Daily\",\n+      url: \"https://daily.co\",\n+      email: \"support@daily.co\",\n+      key: { api_key: \"secret-global-api-key\" },\n+      credential: mockCredential,\n+      credentials: [mockCredential],\n+      locationOption: {\n+        value: \"integrations:daily_video\",\n+        label: \"Daily Video\",\n+      },\n+    };\n+\n+    const sanitized = sanitizeAppForViewer(mockApp);\n+\n+    // Should not have key, credential, or credentials\n+    expect(sanitized).not.toHaveProperty(\"key\");\n+    expect(sanitized).not.toHaveProperty(\"credential\");\n+    expect(sanitized).not.toHaveProperty(\"credentials\");\n+\n+    // Should have all other properties\n+    expect(sanitized).toHaveProperty(\"type\", \"daily_video\");\n+    expect(sanitized).toHaveProperty(\"name\", \"Daily Video\");\n+    expect(sanitized).toHaveProperty(\"slug\", \"daily-video\");\n+    expect(sanitized).toHaveProperty(\"locationOption\");\n+    expect(sanitized.locationOption).toEqual({\n+      value: \"integrations:daily_video\",\n+      label: \"Daily Video\",\n+    });\n+  });\n+\n+  it(\"should handle apps without credential or credentials\", () => {\n+    const mockApp: App & {\n+      credential?: CredentialDataWithTeamName | null;\n+      credentials?: CredentialDataWithTeamName[];\n+      locationOption?: LocationOption | null;\n+    } = {\n+      type: \"zoom_video\",\n+      name: \"Zoom\",\n+      description: \"Video conferencing\",\n+      variant: \"conferencing\",\n+      slug: \"zoom\",\n+      categories: [\"conferencing\"],\n+      logo: \"/logo.png\",\n+      publisher: \"Zoom\",\n+      url: \"https://zoom.us\",\n+      email: \"support@zoom.us\",\n+      key: { api_key: \"secret-key\" },\n+    };\n+\n+    const sanitized = sanitizeAppForViewer(mockApp);\n+\n+    expect(sanitized).not.toHaveProperty(\"key\");\n+    expect(sanitized).not.toHaveProperty(\"credential\");\n+    expect(sanitized).not.toHaveProperty(\"credentials\");\n+    expect(sanitized).toHaveProperty(\"slug\", \"zoom\");\n+  });\n+\n+  it(\"should preserve all non-sensitive properties\", () => {\n+    const mockApp: App & {\n+      credential: CredentialDataWithTeamName | null;\n+      credentials: CredentialDataWithTeamName[];\n+      locationOption: LocationOption | null;\n+    } = {\n+      type: \"stripe_payment\",\n+      name: \"Stripe\",\n+      description: \"Payment processing\",\n+      variant: \"payment\",\n+      slug: \"stripe\",\n+      categories: [\"payment\"],\n+      logo: \"/logo.png\",\n+      publisher: \"Stripe\",\n+      url: \"https://stripe.com\",\n+      email: \"support@stripe.com\",\n+      verified: true,\n+      trending: true,\n+      rating: 4.5,\n+      reviews: 1000,\n+      isGlobal: false,\n+      key: { api_key: \"sk_live_secret\" },\n+      credential: null,\n+      credentials: [],\n+      locationOption: null,\n+      appData: {\n+        location: {\n+          type: \"integrations:stripe\",\n+          label: \"Stripe\",\n+          linkType: \"dynamic\",\n+        },\n+      },\n+    };\n+\n+    const sanitized = sanitizeAppForViewer(mockApp);\n+\n+    expect(sanitized).not.toHaveProperty(\"key\");\n+    expect(sanitized).not.toHaveProperty(\"credential\");\n+    expect(sanitized).not.toHaveProperty(\"credentials\");\n+    expect(sanitized.verified).toBe(true);\n+    expect(sanitized.trending).toBe(true);\n+    expect(sanitized.rating).toBe(4.5);\n+    expect(sanitized.reviews).toBe(1000);\n+    expect(sanitized.appData).toBeDefined();\n+  });\n+});\ndiff --git a/packages/app-store/utils.ts b/packages/app-store/utils.ts\nindex f0675f49958fbe..78a9b0a4f5906c 100644\n--- a/packages/app-store/utils.ts\n+++ b/packages/app-store/utils.ts\n@@ -57,7 +57,7 @@ function getApps(credentials: CredentialDataWithTeamName[], filterOnCredentials?\n       const credential = {\n         id: 0,\n         type: appMeta.type,\n-         \n+\n         key: appMeta.key!,\n         userId: 0,\n         user: { email: \"\" },\n@@ -174,4 +174,15 @@ export const defaultVideoAppCategories: AppCategories[] = [\n   \"video\",\n ];\n \n+export function sanitizeAppForViewer<\n+  T extends App & {\n+    credential?: CredentialDataWithTeamName | null;\n+    credentials?: CredentialDataWithTeamName[];\n+    locationOption?: LocationOption | null;\n+  }\n+>(app: T): Omit<T, \"key\" | \"credential\" | \"credentials\"> {\n+  const { key: _, credential: _1, credentials: _2, ...sanitizedApp } = app;\n+  return sanitizedApp;\n+}\n+\n export default getApps;\ndiff --git a/packages/trpc/server/routers/viewer/apps/appById.handler.test.ts b/packages/trpc/server/routers/viewer/apps/appById.handler.test.ts\nnew file mode 100644\nindex 00000000000000..29704af7fcd0d4\n--- /dev/null\n+++ b/packages/trpc/server/routers/viewer/apps/appById.handler.test.ts\n@@ -0,0 +1,235 @@\n+import { describe, it, expect, vi, beforeEach } from \"vitest\";\n+\n+import { TRPCError } from \"@trpc/server\";\n+\n+import type { CredentialForCalendarService } from \"@calcom/types/Credential\";\n+\n+import { appByIdHandler } from \"./appById.handler\";\n+import type { TAppByIdInputSchema } from \"./appById.schema\";\n+\n+// Mock the dependencies\n+vi.mock(\"@calcom/app-store/delegationCredential\", () => ({\n+  getUsersCredentialsIncludeServiceAccountKey: vi.fn(),\n+}));\n+\n+vi.mock(\"@calcom/app-store/utils\", () => ({\n+  default: vi.fn(),\n+  sanitizeAppForViewer: vi.fn((app) => {\n+    const { key: _, credential: _1, credentials: _2, ...sanitized } = app;\n+    return sanitized;\n+  }),\n+}));\n+\n+import { getUsersCredentialsIncludeServiceAccountKey } from \"@calcom/app-store/delegationCredential\";\n+import getApps, { sanitizeAppForViewer } from \"@calcom/app-store/utils\";\n+\n+import type { CredentialDataWithTeamName, LocationOption } from \"@calcom/app-store/utils\";\n+import type { App } from \"@calcom/types/App\";\n+\n+describe(\"appByIdHandler\", () => {\n+  const mockUser = {\n+    id: 1,\n+    email: \"test@example.com\",\n+    username: \"testuser\",\n+    name: \"Test User\",\n+  };\n+\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+  });\n+\n+  it(\"should not expose key field for globally installed apps\", async () => {\n+    const secretApiKey = \"secret-daily-api-key-12345\";\n+    const mockCredential: CredentialDataWithTeamName = {\n+      id: 0,\n+      type: \"daily_video\",\n+      key: { apikey: secretApiKey },\n+      userId: 0,\n+      user: { email: \"\" },\n+      teamId: null,\n+      appId: \"daily-video\",\n+      invalid: false,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+      team: {\n+        name: \"Default\",\n+      },\n+    };\n+\n+    const mockApp: App & {\n+      credential: CredentialDataWithTeamName | null;\n+      credentials: CredentialDataWithTeamName[];\n+      locationOption: LocationOption | null;\n+    } = {\n+      type: \"daily_video\",\n+      name: \"Cal Video\",\n+      description: \"Video conferencing\",\n+      variant: \"conferencing\",\n+      slug: \"daily-video\",\n+      categories: [\"conferencing\"],\n+      logo: \"icon.svg\",\n+      publisher: \"Cal.com\",\n+      url: \"https://daily.co\",\n+      email: \"help@cal.com\",\n+      isGlobal: true,\n+      // This is the sensitive key that should NOT be exposed\n+      key: { apikey: secretApiKey },\n+      credential: mockCredential,\n+      credentials: [mockCredential],\n+      locationOption: {\n+        value: \"integrations:daily\",\n+        label: \"Cal Video\",\n+      },\n+      appData: {\n+        location: {\n+          linkType: \"dynamic\",\n+          type: \"integrations:daily\",\n+          label: \"Cal Video\",\n+        },\n+      },\n+    };\n+\n+    vi.mocked(getUsersCredentialsIncludeServiceAccountKey).mockResolvedValue([]);\n+    vi.mocked(getApps).mockReturnValue([mockApp]);\n+\n+    const result = await appByIdHandler({\n+      ctx: { user: mockUser },\n+      input: { appId: \"daily-video\" } as TAppByIdInputSchema,\n+    });\n+\n+    // Verify that key is NOT in the response\n+    expect(result).not.toHaveProperty(\"key\");\n+    expect(result).not.toHaveProperty(\"credential\");\n+    expect(result).not.toHaveProperty(\"credentials\");\n+\n+    // Verify that other properties are preserved\n+    expect(result).toHaveProperty(\"slug\", \"daily-video\");\n+    expect(result).toHaveProperty(\"name\", \"Cal Video\");\n+    expect(result).toHaveProperty(\"isGlobal\", true);\n+    expect(result).toHaveProperty(\"locationOption\");\n+    expect(result).toHaveProperty(\"isInstalled\", 1);\n+\n+    // Verify sanitizeAppForViewer was called\n+    expect(sanitizeAppForViewer).toHaveBeenCalledWith(mockApp);\n+  });\n+\n+  it(\"should throw BAD_REQUEST when app is not found\", async () => {\n+    vi.mocked(getUsersCredentialsIncludeServiceAccountKey).mockResolvedValue([]);\n+    vi.mocked(getApps).mockReturnValue([]);\n+\n+    await expect(\n+      appByIdHandler({\n+        ctx: { user: mockUser },\n+        input: { appId: \"non-existent-app\" } as TAppByIdInputSchema,\n+      })\n+    ).rejects.toThrow(TRPCError);\n+\n+    await expect(\n+      appByIdHandler({\n+        ctx: { user: mockUser },\n+        input: { appId: \"non-existent-app\" } as TAppByIdInputSchema,\n+      })\n+    ).rejects.toThrow(\"Could not find app non-existent-app\");\n+  });\n+\n+  it(\"should preserve all non-sensitive properties\", async () => {\n+    const mockApp: App & {\n+      credential: CredentialDataWithTeamName | null;\n+      credentials: CredentialDataWithTeamName[];\n+      locationOption: LocationOption | null;\n+    } = {\n+      type: \"zoom_video\",\n+      name: \"Zoom\",\n+      description: \"Video conferencing\",\n+      variant: \"conferencing\",\n+      slug: \"zoom\",\n+      categories: [\"conferencing\"],\n+      logo: \"icon.svg\",\n+      publisher: \"Zoom\",\n+      url: \"https://zoom.us\",\n+      email: \"support@zoom.us\",\n+      isGlobal: false,\n+      verified: true,\n+      trending: true,\n+      rating: 4.5,\n+      reviews: 1000,\n+      key: { api_key: \"secret-zoom-key\" },\n+      credential: null,\n+      credentials: [],\n+      locationOption: null,\n+    };\n+\n+    vi.mocked(getUsersCredentialsIncludeServiceAccountKey).mockResolvedValue([]);\n+    vi.mocked(getApps).mockReturnValue([mockApp]);\n+\n+    const result = await appByIdHandler({\n+      ctx: { user: mockUser },\n+      input: { appId: \"zoom\" } as TAppByIdInputSchema,\n+    });\n+\n+    // Verify sensitive fields are removed\n+    expect(result).not.toHaveProperty(\"key\");\n+    expect(result).not.toHaveProperty(\"credential\");\n+    expect(result).not.toHaveProperty(\"credentials\");\n+\n+    // Verify non-sensitive fields are preserved\n+    expect(result).toHaveProperty(\"slug\", \"zoom\");\n+    expect(result).toHaveProperty(\"name\", \"Zoom\");\n+    expect(result).toHaveProperty(\"verified\", true);\n+    expect(result).toHaveProperty(\"trending\", true);\n+    expect(result).toHaveProperty(\"rating\", 4.5);\n+    expect(result).toHaveProperty(\"reviews\", 1000);\n+    expect(result).toHaveProperty(\"isInstalled\", 0);\n+  });\n+\n+  it(\"should correctly set isInstalled based on credentials length\", async () => {\n+    const mockCredential: CredentialDataWithTeamName = {\n+      id: 1,\n+      type: \"google_calendar\",\n+      key: { access_token: \"token\" },\n+      userId: 1,\n+      user: { email: \"test@example.com\" },\n+      teamId: null,\n+      appId: \"google-calendar\",\n+      invalid: false,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+      team: null,\n+    };\n+\n+    const mockApp: App & {\n+      credential: CredentialDataWithTeamName | null;\n+      credentials: CredentialDataWithTeamName[];\n+      locationOption: LocationOption | null;\n+    } = {\n+      type: \"google_calendar\",\n+      name: \"Google Calendar\",\n+      description: \"Calendar integration\",\n+      variant: \"calendar\",\n+      slug: \"google-calendar\",\n+      categories: [\"calendar\"],\n+      logo: \"icon.svg\",\n+      publisher: \"Google\",\n+      url: \"https://google.com\",\n+      email: \"support@google.com\",\n+      key: { api_key: \"secret-key\" },\n+      credential: mockCredential,\n+      credentials: [mockCredential],\n+      locationOption: null,\n+    };\n+\n+    vi.mocked(getUsersCredentialsIncludeServiceAccountKey).mockResolvedValue([]);\n+    vi.mocked(getApps).mockReturnValue([mockApp]);\n+\n+    const result = await appByIdHandler({\n+      ctx: { user: mockUser },\n+      input: { appId: \"google-calendar\" } as TAppByIdInputSchema,\n+    });\n+\n+    expect(result.isInstalled).toBe(1);\n+    expect(result).not.toHaveProperty(\"key\");\n+  });\n+});\n+\ndiff --git a/packages/trpc/server/routers/viewer/apps/appById.handler.ts b/packages/trpc/server/routers/viewer/apps/appById.handler.ts\nindex 3737db59cffd8f..bf14841871271d 100644\n--- a/packages/trpc/server/routers/viewer/apps/appById.handler.ts\n+++ b/packages/trpc/server/routers/viewer/apps/appById.handler.ts\n@@ -1,5 +1,5 @@\n import { getUsersCredentialsIncludeServiceAccountKey } from \"@calcom/app-store/delegationCredential\";\n-import getApps from \"@calcom/app-store/utils\";\n+import getApps, { sanitizeAppForViewer } from \"@calcom/app-store/utils\";\n import type { TrpcSessionUser } from \"@calcom/trpc/server/types\";\n \n import { TRPCError } from \"@trpc/server\";\n@@ -24,10 +24,9 @@ export const appByIdHandler = async ({ ctx, input }: AppByIdOptions) => {\n     throw new TRPCError({ code: \"BAD_REQUEST\", message: `Could not find app ${appId}` });\n   }\n \n-   \n-  const { credential: _, credentials: _1, ...app } = appFromDb;\n+  const safeApp = sanitizeAppForViewer(appFromDb);\n   return {\n     isInstalled: appFromDb.credentials.length,\n-    ...app,\n+    ...safeApp,\n   };\n };\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}