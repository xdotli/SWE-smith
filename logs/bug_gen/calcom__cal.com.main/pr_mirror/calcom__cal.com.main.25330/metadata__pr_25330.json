{
    "cost": 0.32171500000000003,
    "rewrites": {
        "calcom__cal.com.main/packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts": {
            "output": "import { describe, it, vi, expect } from \"vitest\";\n\nimport { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TeamWithParent } from \"./types\";\nimport type { UserWithMembership } from \"./utils\";\nimport { INVITE_STATUS } from \"./utils\";\nimport {\n  ensureAtleastAdminPermissions,\n  getUniqueInvitationsOrThrowIfEmpty,\n  getOrgState,\n  getOrgConnectionInfo,\n  canBeInvited,\n  getAutoJoinStatus,\n  checkInputEmailIsValid,\n} from \"./utils\";\n\nvi.mock(\"@calcom/prisma\", () => {\n  return {\n    prisma: vi.fn(),\n  };\n});\n\nvi.mock(\"@calcom/lib/server/queries/organisations\", () => {\n  return {\n    isOrganisationAdmin: vi.fn(),\n    isOrganisationOwner: vi.fn(),\n  };\n});\n\nvi.mock(\"@calcom/features/pbac/services/permission-check.service\", () => {\n  return {\n    PermissionCheckService: vi.fn(),\n  };\n});\n\nconst mockedRegularTeam: TeamWithParent = {\n  id: 1,\n  name: \"Team A\",\n  slug: null,\n  appLogo: null,\n  appIconLogo: null,\n  bio: null,\n  hideBranding: false,\n  pendingPayment: false,\n  hideBookATeamMember: false,\n  createdAt: new Date(),\n  brandColor: \"#292929\",\n  darkBrandColor: \"#fafafa\",\n  timeZone: \"Europe/London\",\n  weekStart: \"Sunday\",\n  theme: null,\n  timeFormat: null,\n  metadata: null,\n  parentId: null,\n  parent: null,\n  isPrivate: false,\n  logoUrl: \"\",\n  isOrganization: false,\n  calVideoLogo: \"\",\n  bannerUrl: \"\",\n  isPlatform: false,\n  smsLockState: \"LOCKED\",\n  createdByOAuthClientId: null,\n  smsLockReviewedByAdmin: false,\n  hideTeamProfileLink: false,\n  rrResetInterval: null,\n  rrTimestampBasis: \"CREATED_AT\",\n  bookingLimits: null,\n  includeManagedEventsInLimits: false,\n};\n\nconst mockedSubTeam = {\n  ...mockedRegularTeam,\n  parentId: 1000,\n};\n\nconst mockUser: UserWithMembership = {\n  id: 4,\n  username: \"pro\",\n  email: \"pro@example.com\",\n  password: {\n    hash: \"\",\n    userId: 0,\n  },\n  completedOnboarding: true,\n  identityProvider: \"CAL\",\n  profiles: [],\n};\n\nconst userInTeamAccepted: UserWithMembership = {\n  ...mockUser,\n  teams: [{ teamId: mockedRegularTeam.id, accepted: true, userId: mockUser.id, role: \"MEMBER\" }],\n};\n\nconst userInTeamNotAccepted: UserWithMembership = {\n  ...mockUser,\n  teams: [{ teamId: mockedRegularTeam.id, accepted: false, userId: mockUser.id, role: \"MEMBER\" }],\n};\n\ndescribe(\"Invite Member Utils\", () => {\n  describe(\"ensureAtleastAdminPermissions\", () => {\n    it(\"It should throw an error if the user is not an admin of the ORG\", async () => {\n      const mockCheckPermission = vi.fn().mockResolvedValue(false);\n      vi.mocked(PermissionCheckService).mockImplementation(\n        () =>\n          ({\n            checkPermission: mockCheckPermission,\n          } as any)\n      );\n\n      await expect(ensureAtleastAdminPermissions({ userId: 1, teamId: 1, isOrg: true })).rejects.toThrow(\n        \"UNAUTHORIZED\"\n      );\n\n      expect(mockCheckPermission).toHaveBeenCalledWith({\n        userId: 1,\n        teamId: 1,\n        permission: \"organization.invite\",\n        fallbackRoles: [\"OWNER\", \"ADMIN\"],\n      });\n    });\n\n    it(\"It should NOT throw an error if the user is an admin of the ORG\", async () => {\n      const mockCheckPermission = vi.fn().mockResolvedValue(true);\n      vi.mocked(PermissionCheckService).mockImplementation(\n        () =>\n          ({\n            checkPermission: mockCheckPermission,\n          } as any)\n      );\n\n      await expect(\n        ensureAtleastAdminPermissions({ userId: 1, teamId: 1, isOrg: true })\n      ).resolves.not.toThrow();\n\n      expect(mockCheckPermission).toHaveBeenCalledWith({\n        userId: 1,\n        teamId: 1,\n        permission: \"organization.invite\",\n        fallbackRoles: [\"OWNER\", \"ADMIN\"],\n      });\n    });\n  });\n\n  describe(\"getUniqueInvitationsOrThrowIfEmpty\", () => {\n    it(\"should throw a TRPCError with code BAD_REQUEST if no emails are provided\", async () => {\n      await expect(getUniqueInvitationsOrThrowIfEmpty([])).rejects.toThrow(TRPCError);\n    });\n\n    it(\"should return an array with multiple emails if an array is provided\", async () => {\n      const result = await getUniqueInvitationsOrThrowIfEmpty([\n        { usernameOrEmail: \"test1@example.com\", role: MembershipRole.MEMBER },\n        { usernameOrEmail: \"test2@example.com\", role: MembershipRole.MEMBER },\n      ]);\n      expect(result).toEqual([\n        { usernameOrEmail: \"test1@example.com\", role: MembershipRole.MEMBER },\n        { usernameOrEmail: \"test2@example.com\", role: MembershipRole.MEMBER },\n      ]);\n    });\n  });\n  describe(\"checkInputEmailIsValid\", () => {\n    it(\"should throw a TRPCError with code BAD_REQUEST if the email is invalid\", () => {\n      const invalidEmail = \"invalid-email\";\n      expect(() => checkInputEmailIsValid(invalidEmail)).toThrow(TRPCError);\n      expect(() => checkInputEmailIsValid(invalidEmail)).toThrowError(\n        \"Invite failed because invalid-email is not a valid email address\"\n      );\n    });\n\n    it(\"should not throw an error if the email is valid\", () => {\n      const validEmail = \"valid-email@example.com\";\n      const validEmailWithApostrophe = \"valid'email@example.com\";\n      expect(() => checkInputEmailIsValid(validEmail)).not.toThrow();\n      expect(() => checkInputEmailIsValid(validEmailWithApostrophe)).not.toThrow();\n    });\n  });\n  describe(\"getOrgConnectionInfo\", () => {\n    const orgAutoAcceptDomain = \"example.com\";\n    const email = \"user@example.com\";\n\n    it(\"should return autoAccept:false when orgVerified is false even if email domain matches orgAutoAcceptDomain\", () => {\n      const result = getOrgConnectionInfo({\n        orgAutoAcceptDomain,\n        orgVerified: false,\n        email,\n        team: {\n          ...mockedRegularTeam,\n          parentId: 2,\n        },\n        isOrg: false,\n      });\n      expect(result).toEqual({ orgId: 2, autoAccept: false });\n    });\n\n    it(\"should return orgId and autoAccept as false if team has parent and email domain does not match orgAutoAcceptDomain\", () => {\n      const result = getOrgConnectionInfo({\n        orgAutoAcceptDomain,\n        orgVerified: true,\n        email: \"user@other.com\",\n        team: {\n          ...mockedRegularTeam,\n          parentId: 2,\n        },\n        isOrg: false,\n      });\n      expect(result).toEqual({ orgId: undefined, autoAccept: false });\n    });\n\n    it(\"should return orgId and autoAccept as true if team has no parent and isOrg is true and email domain matches orgAutoAcceptDomain\", () => {\n      const result = getOrgConnectionInfo({\n        orgAutoAcceptDomain,\n        orgVerified: true,\n        email,\n        team: { ...mockedRegularTeam, parentId: null },\n        isOrg: true,\n      });\n      expect(result).toEqual({ orgId: 1, autoAccept: true });\n    });\n\n    it(\"should return orgId and autoAccept as false if team has no parent and isOrg is true and email domain does not match orgAutoAcceptDomain\", () => {\n      const result = getOrgConnectionInfo({\n        orgAutoAcceptDomain,\n        orgVerified: false,\n        email: \"user@other.com\",\n        team: { ...mockedRegularTeam, parentId: null },\n        isOrg: true,\n      });\n      expect(result).toEqual({ orgId: undefined, autoAccept: false });\n    });\n\n    it(\"should return orgId and autoAccept as false if team has no parent and isOrg is true and email domain matches orgAutoAcceptDomain but orgVerified is false\", () => {\n      const result = getOrgConnectionInfo({\n        orgAutoAcceptDomain,\n        orgVerified: false,\n        email,\n        team: { ...mockedRegularTeam, parentId: null },\n        isOrg: true,\n      });\n      expect(result).toEqual({ orgId: mockedRegularTeam.id, autoAccept: false });\n    });\n  });\n  describe(\"getOrgState\", () => {\n    it(\"should return the correct values when isOrg is true and teamMetadata.orgAutoAcceptEmail is true\", () => {\n      const team = {\n        organizationSettings: {\n          id: 1,\n          teamId: 1,\n          isOrganizationConfigured: false,\n          isOrganizationVerified: true,\n          orgAutoAcceptEmail: \"example.com\",\n          organizationId: 1,\n          lockEventTypeCreationForUsers: false,\n          adminGetsNoSlotsNotification: false,\n          isAdminReviewed: false,\n          isAdminAPIEnabled: false,\n          allowSEOIndexing: false,\n          orgProfileRedirectsToVerifiedDomain: false,\n          disablePhoneOnlySMSNotifications: false,\n        },\n        slug: \"abc\",\n        parent: null,\n        isOrganization: true,\n      };\n      const result = getOrgState(true, { ...mockedRegularTeam, ...team });\n      expect(result).toEqual({\n        isInOrgScope: true,\n        orgVerified: true,\n        orgConfigured: false,\n        orgPublished: true,\n        autoAcceptEmailDomain: \"example.com\",\n      });\n    });\n\n    it(\"should return the correct values when orgMetadataIfExists.orgAutoAcceptEmail is true\", () => {\n      const team = {\n        metadata: {},\n        parent: {\n          ...mockedRegularTeam,\n          organizationSettings: {\n            id: 1,\n            teamId: 1,\n            isOrganizationConfigured: false,\n            isOrganizationVerified: false,\n            orgAutoAcceptEmail: \"example.com\",\n            organizationId: 1,\n            lockEventTypeCreationForUsers: false,\n            adminGetsNoSlotsNotification: false,\n            isAdminReviewed: false,\n            isAdminAPIEnabled: false,\n            allowSEOIndexing: false,\n            orgProfileRedirectsToVerifiedDomain: false,\n            disablePhoneOnlySMSNotifications: false,\n          },\n        },\n      };\n      const result = getOrgState(false, { ...mockedRegularTeam, ...team });\n      expect(result).toEqual({\n        isInOrgScope: true,\n        orgVerified: false,\n        orgConfigured: false,\n        orgPublished: false,\n        autoAcceptEmailDomain: \"example.com\",\n      });\n    });\n\n    it(\"should return the correct values when neither isOrg nor orgMetadataIfExists.orgAutoAcceptEmail is true\", () => {\n      const team = {\n        metadata: {},\n        parent: null,\n      };\n      const result = getOrgState(false, { ...mockedRegularTeam, ...team });\n      expect(result).toEqual({\n        isInOrgScope: false,\n        orgVerified: null,\n        orgConfigured: null,\n        orgPublished: null,\n        autoAcceptEmailDomain: null,\n      });\n    });\n  });\n\n  describe(\"canBeInvited: Check if user can be invited to the team/org\", () => {\n    const invitee: UserWithMembership = {\n      ...mockUser,\n      id: 1,\n      username: \"testuser\",\n      email: \"testuser@example.com\",\n      profiles: [],\n    };\n\n    it(\"should return CAN_BE_INVITED when inviting to an sub-team if the invitee is a member of the organization\", () => {\n      const inviteeOrganizationId = 2;\n      const inviteeWithOrg: UserWithMembership = {\n        ...invitee,\n        profiles: [getSampleProfile({ organizationId: inviteeOrganizationId })],\n      };\n\n      const subTeam = {\n        ...mockedRegularTeam,\n        parentId: inviteeOrganizationId,\n      };\n\n      expect(canBeInvited(inviteeWithOrg, subTeam)).toBe(INVITE_STATUS.CAN_BE_INVITED);\n    });\n\n    it(\"should return CAN_BE_INVITED if the user is invited to a sub-team of the organization the user belongs to\", () => {\n      const inviteeOrgId = 2;\n      const subTeamOrgId = inviteeOrgId;\n      const inviteeWithOrg: UserWithMembership = {\n        ...invitee,\n        profiles: [getSampleProfile({ organizationId: 2 })],\n        teams: [{ teamId: 2, accepted: true, userId: invitee.id, role: \"ADMIN\" }],\n      };\n\n      const subTeam = {\n        ...mockedRegularTeam,\n        parentId: subTeamOrgId,\n        id: 1,\n      };\n      expect(canBeInvited(inviteeWithOrg, subTeam)).toBe(INVITE_STATUS.CAN_BE_INVITED);\n    });\n\n    it(\"should return CAN_BE_INVITED if the invitee does not already belong to another organization and is being invited to a regular team\", () => {\n      expect(canBeInvited(invitee, mockedRegularTeam)).toBe(INVITE_STATUS.CAN_BE_INVITED);\n    });\n\n    it(\"should return USER_ALREADY_INVITED_OR_MEMBER when inviting a user who is already a member of the team\", () => {\n      const teamId = 1;\n      const inviteeWithOrg: UserWithMembership = {\n        ...invitee,\n        teams: [{ teamId: teamId, accepted: true, userId: invitee.id, role: \"ADMIN\" }],\n      };\n      const regularTeam = {\n        ...mockedRegularTeam,\n        id: teamId,\n      };\n      expect(canBeInvited(inviteeWithOrg, regularTeam)).toBe(INVITE_STATUS.USER_ALREADY_INVITED_OR_MEMBER);\n    });\n\n    it(\"should return USER_ALREADY_INVITED_OR_MEMBER when inviting a user to sub-team who is already a member of the sub-team\", () => {\n      const teamId = 1;\n      const inviteeOrgId = 2;\n      const inviteeWithOrg: UserWithMembership = {\n        ...invitee,\n        profiles: [getSampleProfile({ organizationId: inviteeOrgId })],\n        teams",
            "output_extracted": "import { describe, it, vi, expect } from \"vitest\";\n\nimport { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TeamWithParent } from \"./types\";\nimport type { UserWithMembership } from \"./utils\";\nimport { INVITE_STATUS } from \"./utils\";\nimport {\n  ensureAtleastAdminPermissions,\n  getUniqueInvitationsOrThrowIfEmpty,\n  getOrgState,\n  getOrgConnectionInfo,\n  canBeInvited,\n  getAutoJoinStatus,\n  checkInputEmailIsValid,\n} from \"./utils\";\n\nvi.mock(\"@calcom/prisma\", () => {\n  return {\n    prisma: vi.fn(),\n  };\n});\n\nvi.mock(\"@calcom/lib/server/queries/organisations\", () => {\n  return {\n    isOrganisationAdmin: vi.fn(),\n    isOrganisationOwner: vi.fn(),\n  };\n});\n\nvi.mock(\"@calcom/features/pbac/services/permission-check.service\", () => {\n  return {\n    PermissionCheckService: vi.fn(),\n  };\n});\n\nconst mockedRegularTeam: TeamWithParent = {\n  id: 1,\n  name: \"Team A\",\n  slug: null,\n  appLogo: null,\n  appIconLogo: null,\n  bio: null,\n  hideBranding: false,\n  pendingPayment: false,\n  hideBookATeamMember: false,\n  createdAt: new Date(),\n  brandColor: \"#292929\",\n  darkBrandColor: \"#fafafa\",\n  timeZone: \"Europe/London\",\n  weekStart: \"Sunday\",\n  theme: null,\n  timeFormat: null,\n  metadata: null,\n  parentId: null,\n  parent: null,\n  isPrivate: false,\n  logoUrl: \"\",\n  isOrganization: false,\n  calVideoLogo: \"\",\n  bannerUrl: \"\",\n  isPlatform: false,\n  smsLockState: \"LOCKED\",\n  createdByOAuthClientId: null,\n  smsLockReviewedByAdmin: false,\n  hideTeamProfileLink: false,\n  rrResetInterval: null,\n  rrTimestampBasis: \"CREATED_AT\",\n  bookingLimits: null,\n  includeManagedEventsInLimits: false,\n};\n\nconst mockedSubTeam = {\n  ...mockedRegularTeam,\n  parentId: 1000,\n};\n\nconst mockUser: UserWithMembership = {\n  id: 4,\n  username: \"pro\",\n  email: \"pro@example.com\",\n  password: {\n    hash: \"\",\n    userId: 0,\n  },\n  completedOnboarding: true,\n  identityProvider: \"CAL\",\n  profiles: [],\n};\n\nconst userInTeamAccepted: UserWithMembership = {\n  ...mockUser,\n  teams: [{ teamId: mockedRegularTeam.id, accepted: true, userId: mockUser.id, role: \"MEMBER\" }],\n};\n\nconst userInTeamNotAccepted: UserWithMembership = {\n  ...mockUser,\n  teams: [{ teamId: mockedRegularTeam.id, accepted: false, userId: mockUser.id, role: \"MEMBER\" }],\n};\n\ndescribe(\"Invite Member Utils\", () => {\n  describe(\"ensureAtleastAdminPermissions\", () => {\n    it(\"It should throw an error if the user is not an admin of the ORG\", async () => {\n      const mockCheckPermission = vi.fn().mockResolvedValue(false);\n      vi.mocked(PermissionCheckService).mockImplementation(\n        () =>\n          ({\n            checkPermission: mockCheckPermission,\n          } as any)\n      );\n\n      await expect(ensureAtleastAdminPermissions({ userId: 1, teamId: 1, isOrg: true })).rejects.toThrow(\n        \"UNAUTHORIZED\"\n      );\n\n      expect(mockCheckPermission).toHaveBeenCalledWith({\n        userId: 1,\n        teamId: 1,\n        permission: \"organization.invite\",\n        fallbackRoles: [\"OWNER\", \"ADMIN\"],\n      });\n    });\n\n    it(\"It should NOT throw an error if the user is an admin of the ORG\", async () => {\n      const mockCheckPermission = vi.fn().mockResolvedValue(true);\n      vi.mocked(PermissionCheckService).mockImplementation(\n        () =>\n          ({\n            checkPermission: mockCheckPermission,\n          } as any)\n      );\n\n      await expect(\n        ensureAtleastAdminPermissions({ userId: 1, teamId: 1, isOrg: true })\n      ).resolves.not.toThrow();\n\n      expect(mockCheckPermission).toHaveBeenCalledWith({\n        userId: 1,\n        teamId: 1,\n        permission: \"organization.invite\",\n        fallbackRoles: [\"OWNER\", \"ADMIN\"],\n      });\n    });\n  });\n\n  describe(\"getUniqueInvitationsOrThrowIfEmpty\", () => {\n    it(\"should throw a TRPCError with code BAD_REQUEST if no emails are provided\", async () => {\n      await expect(getUniqueInvitationsOrThrowIfEmpty([])).rejects.toThrow(TRPCError);\n    });\n\n    it(\"should return an array with multiple emails if an array is provided\", async () => {\n      const result = await getUniqueInvitationsOrThrowIfEmpty([\n        { usernameOrEmail: \"test1@example.com\", role: MembershipRole.MEMBER },\n        { usernameOrEmail: \"test2@example.com\", role: MembershipRole.MEMBER },\n      ]);\n      expect(result).toEqual([\n        { usernameOrEmail: \"test1@example.com\", role: MembershipRole.MEMBER },\n        { usernameOrEmail: \"test2@example.com\", role: MembershipRole.MEMBER },\n      ]);\n    });\n  });\n  describe(\"checkInputEmailIsValid\", () => {\n    it(\"should throw a TRPCError with code BAD_REQUEST if the email is invalid\", () => {\n      const invalidEmail = \"invalid-email\";\n      expect(() => checkInputEmailIsValid(invalidEmail)).toThrow(TRPCError);\n      expect(() => checkInputEmailIsValid(invalidEmail)).toThrowError(\n        \"Invite failed because invalid-email is not a valid email address\"\n      );\n    });\n\n    it(\"should not throw an error if the email is valid\", () => {\n      const validEmail = \"valid-email@example.com\";\n      const validEmailWithApostrophe = \"valid'email@example.com\";\n      expect(() => checkInputEmailIsValid(validEmail)).not.toThrow();\n      expect(() => checkInputEmailIsValid(validEmailWithApostrophe)).not.toThrow();\n    });\n  });\n  describe(\"getOrgConnectionInfo\", () => {\n    const orgAutoAcceptDomain = \"example.com\";\n    const email = \"user@example.com\";\n\n    it(\"should return autoAccept:false when orgVerified is false even if email domain matches orgAutoAcceptDomain\", () => {\n      const result = getOrgConnectionInfo({\n        orgAutoAcceptDomain,\n        orgVerified: false,\n        email,\n        team: {\n          ...mockedRegularTeam,\n          parentId: 2,\n        },\n        isOrg: false,\n      });\n      expect(result).toEqual({ orgId: 2, autoAccept: false });\n    });\n\n    it(\"should return orgId and autoAccept as false if team has parent and email domain does not match orgAutoAcceptDomain\", () => {\n      const result = getOrgConnectionInfo({\n        orgAutoAcceptDomain,\n        orgVerified: true,\n        email: \"user@other.com\",\n        team: {\n          ...mockedRegularTeam,\n          parentId: 2,\n        },\n        isOrg: false,\n      });\n      expect(result).toEqual({ orgId: undefined, autoAccept: false });\n    });\n\n    it(\"should return orgId and autoAccept as true if team has no parent and isOrg is true and email domain matches orgAutoAcceptDomain\", () => {\n      const result = getOrgConnectionInfo({\n        orgAutoAcceptDomain,\n        orgVerified: true,\n        email,\n        team: { ...mockedRegularTeam, parentId: null },\n        isOrg: true,\n      });\n      expect(result).toEqual({ orgId: 1, autoAccept: true });\n    });\n\n    it(\"should return orgId and autoAccept as false if team has no parent and isOrg is true and email domain does not match orgAutoAcceptDomain\", () => {\n      const result = getOrgConnectionInfo({\n        orgAutoAcceptDomain,\n        orgVerified: false,\n        email: \"user@other.com\",\n        team: { ...mockedRegularTeam, parentId: null },\n        isOrg: true,\n      });\n      expect(result).toEqual({ orgId: undefined, autoAccept: false });\n    });\n\n    it(\"should return orgId and autoAccept as false if team has no parent and isOrg is true and email domain matches orgAutoAcceptDomain but orgVerified is false\", () => {\n      const result = getOrgConnectionInfo({\n        orgAutoAcceptDomain,\n        orgVerified: false,\n        email,\n        team: { ...mockedRegularTeam, parentId: null },\n        isOrg: true,\n      });\n      expect(result).toEqual({ orgId: mockedRegularTeam.id, autoAccept: false });\n    });\n  });\n  describe(\"getOrgState\", () => {\n    it(\"should return the correct values when isOrg is true and teamMetadata.orgAutoAcceptEmail is true\", () => {\n      const team = {\n        organizationSettings: {\n          id: 1,\n          teamId: 1,\n          isOrganizationConfigured: false,\n          isOrganizationVerified: true,\n          orgAutoAcceptEmail: \"example.com\",\n          organizationId: 1,\n          lockEventTypeCreationForUsers: false,\n          adminGetsNoSlotsNotification: false,\n          isAdminReviewed: false,\n          isAdminAPIEnabled: false,\n          allowSEOIndexing: false,\n          orgProfileRedirectsToVerifiedDomain: false,\n          disablePhoneOnlySMSNotifications: false,\n        },\n        slug: \"abc\",\n        parent: null,\n        isOrganization: true,\n      };\n      const result = getOrgState(true, { ...mockedRegularTeam, ...team });\n      expect(result).toEqual({\n        isInOrgScope: true,\n        orgVerified: true,\n        orgConfigured: false,\n        orgPublished: true,\n        autoAcceptEmailDomain: \"example.com\",\n      });\n    });\n\n    it(\"should return the correct values when orgMetadataIfExists.orgAutoAcceptEmail is true\", () => {\n      const team = {\n        metadata: {},\n        parent: {\n          ...mockedRegularTeam,\n          organizationSettings: {\n            id: 1,\n            teamId: 1,\n            isOrganizationConfigured: false,\n            isOrganizationVerified: false,\n            orgAutoAcceptEmail: \"example.com\",\n            organizationId: 1,\n            lockEventTypeCreationForUsers: false,\n            adminGetsNoSlotsNotification: false,\n            isAdminReviewed: false,\n            isAdminAPIEnabled: false,\n            allowSEOIndexing: false,\n            orgProfileRedirectsToVerifiedDomain: false,\n            disablePhoneOnlySMSNotifications: false,\n          },\n        },\n      };\n      const result = getOrgState(false, { ...mockedRegularTeam, ...team });\n      expect(result).toEqual({\n        isInOrgScope: true,\n        orgVerified: false,\n        orgConfigured: false,\n        orgPublished: false,\n        autoAcceptEmailDomain: \"example.com\",\n      });\n    });\n\n    it(\"should return the correct values when neither isOrg nor orgMetadataIfExists.orgAutoAcceptEmail is true\", () => {\n      const team = {\n        metadata: {},\n        parent: null,\n      };\n      const result = getOrgState(false, { ...mockedRegularTeam, ...team });\n      expect(result).toEqual({\n        isInOrgScope: false,\n        orgVerified: null,\n        orgConfigured: null,\n        orgPublished: null,\n        autoAcceptEmailDomain: null,\n      });\n    });\n  });\n\n  describe(\"canBeInvited: Check if user can be invited to the team/org\", () => {\n    const invitee: UserWithMembership = {\n      ...mockUser,\n      id: 1,\n      username: \"testuser\",\n      email: \"testuser@example.com\",\n      profiles: [],\n    };\n\n    it(\"should return CAN_BE_INVITED when inviting to an sub-team if the invitee is a member of the organization\", () => {\n      const inviteeOrganizationId = 2;\n      const inviteeWithOrg: UserWithMembership = {\n        ...invitee,\n        profiles: [getSampleProfile({ organizationId: inviteeOrganizationId })],\n      };\n\n      const subTeam = {\n        ...mockedRegularTeam,\n        parentId: inviteeOrganizationId,\n      };\n\n      expect(canBeInvited(inviteeWithOrg, subTeam)).toBe(INVITE_STATUS.CAN_BE_INVITED);\n    });\n\n    it(\"should return CAN_BE_INVITED if the user is invited to a sub-team of the organization the user belongs to\", () => {\n      const inviteeOrgId = 2;\n      const subTeamOrgId = inviteeOrgId;\n      const inviteeWithOrg: UserWithMembership = {\n        ...invitee,\n        profiles: [getSampleProfile({ organizationId: 2 })],\n        teams: [{ teamId: 2, accepted: true, userId: invitee.id, role: \"ADMIN\" }],\n      };\n\n      const subTeam = {\n        ...mockedRegularTeam,\n        parentId: subTeamOrgId,\n        id: 1,\n      };\n      expect(canBeInvited(inviteeWithOrg, subTeam)).toBe(INVITE_STATUS.CAN_BE_INVITED);\n    });\n\n    it(\"should return CAN_BE_INVITED if the invitee does not already belong to another organization and is being invited to a regular team\", () => {\n      expect(canBeInvited(invitee, mockedRegularTeam)).toBe(INVITE_STATUS.CAN_BE_INVITED);\n    });\n\n    it(\"should return USER_ALREADY_INVITED_OR_MEMBER when inviting a user who is already a member of the team\", () => {\n      const teamId = 1;\n      const inviteeWithOrg: UserWithMembership = {\n        ...invitee,\n        teams: [{ teamId: teamId, accepted: true, userId: invitee.id, role: \"ADMIN\" }],\n      };\n      const regularTeam = {\n        ...mockedRegularTeam,\n        id: teamId,\n      };\n      expect(canBeInvited(inviteeWithOrg, regularTeam)).toBe(INVITE_STATUS.USER_ALREADY_INVITED_OR_MEMBER);\n    });\n\n    it(\"should return USER_ALREADY_INVITED_OR_MEMBER when inviting a user to sub-team who is already a member of the sub-team\", () => {\n      const teamId = 1;\n      const inviteeOrgId = 2;\n      const inviteeWithOrg: UserWithMembership = {\n        ...invitee,\n        profiles: [getSampleProfile({ organizationId: inviteeOrgId })],\n        teams",
            "cost": 0.16345500000000002
        },
        "calcom__cal.com.main/packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts": {
            "output": "import { randomBytes } from \"crypto\";\nimport type { TFunction } from \"i18next\";\n\nimport { getOrgFullOrigin } from \"@calcom/ee/organizations/lib/orgDomains\";\nimport { sendTeamInviteEmail } from \"@calcom/emails/organization-email-service\";\nimport { checkAdminOrOwner } from \"@calcom/features/auth/lib/checkAdminOrOwner\";\nimport { updateNewTeamMemberEventTypes } from \"@calcom/features/ee/teams/lib/queries\";\nimport { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\nimport { createAProfileForAnExistingUser } from \"@calcom/features/profile/lib/createAProfileForAnExistingUser\";\nimport { ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport { OnboardingPathService } from \"@calcom/features/onboarding/lib/onboarding-path.service\";\nimport { DEFAULT_SCHEDULE, getAvailabilityFromSchedule } from \"@calcom/lib/availability\";\nimport { ENABLE_PROFILE_SWITCHER, WEBAPP_URL } from \"@calcom/lib/constants\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { getParsedTeam } from \"@calcom/lib/server/repository/teamUtils\";\nimport slugify from \"@calcom/lib/slugify\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Membership, OrganizationSettings, Team } from \"@calcom/prisma/client\";\nimport { type User as UserType, type UserPassword, Prisma } from \"@calcom/prisma/client\";\nimport type { Profile as ProfileType } from \"@calcom/prisma/client\";\nimport type { CreationSource } from \"@calcom/prisma/enums\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\nimport { teamMetadataSchema } from \"@calcom/prisma/zod-utils\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport { isEmail } from \"../util\";\nimport type { TeamWithParent } from \"./types\";\n\nconst log = logger.getSubLogger({ prefix: [\"inviteMember.utils\"] });\nexport type Invitee = Pick<\n  UserType,\n  \"id\" | \"email\" | \"username\" | \"identityProvider\" | \"completedOnboarding\"\n>;\n\nexport type UserWithMembership = Invitee & {\n  teams?: Pick<Membership, \"userId\" | \"teamId\" | \"accepted\" | \"role\">[];\n  profiles: ProfileType[];\n  password: UserPassword | null;\n};\n\nexport type Invitation = {\n  usernameOrEmail: string;\n  role: MembershipRole;\n};\n\ntype InvitableExistingUser = UserWithMembership & {\n  newRole: MembershipRole;\n};\n\ntype InvitableExistingUserWithProfile = InvitableExistingUser & {\n  profile: {\n    username: string;\n  } | null;\n};\n\nexport async function ensureAtleastAdminPermissions({\n  userId,\n  teamId,\n  isOrg,\n}: {\n  userId: number;\n  teamId: number;\n  isOrg?: boolean;\n}) {\n  const permissionCheckService = new PermissionCheckService();\n\n  // Checks if the team they are inviting to IS the org. Not a child team\n  // TODO: do some logic here to check if the user is inviting a NEW user to a team that ISNT in the same org\n  const permission = isOrg ? \"organization.invite\" : \"team.invite\";\n  const hasInvitePermission = await permissionCheckService.checkPermission({\n    userId,\n    teamId,\n    permission,\n    fallbackRoles: [MembershipRole.OWNER, MembershipRole.ADMIN],\n  });\n\n  if (!hasInvitePermission) {\n    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n  }\n}\n\nexport function checkInputEmailIsValid(email: string) {\n  if (!isEmail(email))\n    throw new TRPCError({\n      code: \"BAD_REQUEST\",\n      message: `Invite failed because ${email} is not a valid email address`,\n    });\n}\n\nexport async function getTeamOrThrow(teamId: number) {\n  const team = await prisma.team.findUnique({\n    where: {\n      id: teamId,\n    },\n    include: {\n      organizationSettings: true,\n      parent: {\n        include: {\n          organizationSettings: true,\n        },\n      },\n    },\n  });\n\n  if (!team)\n    throw new TRPCError({\n      code: \"NOT_FOUND\",\n      message: `Team not found`,\n    });\n\n  return { ...team, metadata: teamMetadataSchema.parse(team.metadata) };\n}\n\nexport async function getUniqueInvitationsOrThrowIfEmpty(invitations: Invitation[]) {\n  const usernamesOrEmailsSet = new Set<string>();\n  const uniqueInvitations: Invitation[] = [];\n\n  invitations.forEach((usernameOrEmail) => {\n    if (usernamesOrEmailsSet.has(usernameOrEmail.usernameOrEmail)) {\n      return;\n    }\n    uniqueInvitations.push(usernameOrEmail);\n    usernamesOrEmailsSet.add(usernameOrEmail.usernameOrEmail);\n  });\n\n  if (uniqueInvitations.length === 0) {\n    throw new TRPCError({\n      code: \"BAD_REQUEST\",\n      message: \"You must provide at least one email address to invite.\",\n    });\n  }\n\n  return uniqueInvitations;\n}\n\nexport const enum INVITE_STATUS {\n  USER_PENDING_MEMBER_OF_THE_ORG = \"USER_PENDING_MEMBER_OF_THE_ORG\",\n  USER_ALREADY_INVITED_OR_MEMBER = \"USER_ALREADY_INVITED_OR_MEMBER\",\n  USER_MEMBER_OF_OTHER_ORGANIZATION = \"USER_MEMBER_OF_OTHER_ORGANIZATION\",\n  CAN_BE_INVITED = \"CAN_BE_INVITED\",\n}\n\nexport function canBeInvited(invitee: UserWithMembership, team: TeamWithParent) {\n  const myLog = log.getSubLogger({ prefix: [\"canBeInvited\"] });\n  myLog.debug(\"Checking if user can be invited\", safeStringify({ invitee, team }));\n  const alreadyInvited = invitee.teams?.find(({ teamId: membershipTeamId }) => team.id === membershipTeamId);\n  if (alreadyInvited) {\n    return INVITE_STATUS.USER_ALREADY_INVITED_OR_MEMBER;\n  }\n\n  const orgMembership = invitee.teams?.find((membership) => membership.teamId === team.parentId);\n\n  // An invitee here won't be a member of the team\n  // If he is invited to a sub-team and is already part of the organization.\n  if (\n    team.parentId &&\n    new UserRepository(prisma).isAMemberOfOrganization({ user: invitee, organizationId: team.parentId })\n  ) {\n    return INVITE_STATUS.CAN_BE_INVITED;\n  }\n\n  // user invited to join a team inside an org, but has not accepted invite to org yet\n  if (team.parentId && orgMembership && !orgMembership.accepted) {\n    return INVITE_STATUS.USER_PENDING_MEMBER_OF_THE_ORG;\n  }\n\n  const hasDifferentOrganizationProfile = invitee.profiles.some((profile) => {\n    const isRegularTeam = !team.isOrganization && !team.parentId;\n    if (isRegularTeam) {\n      // \u26a0\ufe0f Inviting to a regular team but the user has a profile with some organization\n      return true;\n    }\n\n    const isOrganization = team.isOrganization && !team.parentId;\n    if (isOrganization) {\n      // \u26a0\ufe0f User has profile with different organization than the organization being invited to\n      return profile.organizationId !== team.id;\n    }\n\n    // \u26a0\ufe0f User having profile with an organization is invited to join a sub-team that is not part of the organization\n    return profile.organizationId != team.parentId;\n  });\n\n  if (\n    !ENABLE_PROFILE_SWITCHER &&\n    // User having profile with an organization is invited to join a sub-team that is not part of the organization\n    hasDifferentOrganizationProfile\n  ) {\n    return INVITE_STATUS.USER_MEMBER_OF_OTHER_ORGANIZATION;\n  }\n  return INVITE_STATUS.CAN_BE_INVITED;\n}\n\nexport async function findUsersWithInviteStatus({\n  invitations,\n  team,\n}: {\n  invitations: Invitation[];\n  team: TeamWithParent;\n}) {\n  const usernamesOrEmails = invitations.map((invitation) => invitation.usernameOrEmail);\n  const inviteesFromDb: UserWithMembership[] = await prisma.user.findMany({\n    where: {\n      OR: [\n        // Either it's a username in that organization\n        {\n          profiles: {\n            some: {\n              organizationId: team.id,\n              username: { in: usernamesOrEmails },\n            },\n          },\n        },\n        // Or it's an email\n        { email: { in: usernamesOrEmails } },\n      ],\n    },\n    select: {\n      id: true,\n      email: true,\n      username: true,\n      password: true,\n      completedOnboarding: true,\n      identityProvider: true,\n      profiles: true,\n      teams: true,\n    },\n  });\n\n  const userToRoleMap = buildUserToRoleMap();\n  const defaultMemberRole = MembershipRole.MEMBER;\n  // Check if the users found in the database can be invited to join the team/org\n  return inviteesFromDb.map((inviteeFromDb) => {\n    const newRole = getRoleForUser({ email: inviteeFromDb.email, username: inviteeFromDb.username });\n\n    return {\n      ...inviteeFromDb,\n      newRole: newRole ?? defaultMemberRole,\n      canBeInvited: canBeInvited(inviteeFromDb, team),\n    };\n  });\n\n  function buildUserToRoleMap() {\n    const userToRoleMap = new Map<string, MembershipRole>();\n    invitations.forEach((invitation) => {\n      userToRoleMap.set(invitation.usernameOrEmail, invitation.role);\n    });\n    return userToRoleMap;\n  }\n\n  function getRoleForUser({ email, username }: { email: string; username: string | null }) {\n    return userToRoleMap.get(email) || (username ? userToRoleMap.get(username) : defaultMemberRole);\n  }\n}\n\nexport function getOrgConnectionInfo({\n  orgAutoAcceptDomain,\n  orgVerified,\n  isOrg,\n  email,\n  team,\n}: {\n  orgAutoAcceptDomain?: string | null;\n  orgVerified: boolean | null;\n  email: string;\n  team: Pick<TeamWithParent, \"parentId\" | \"id\">;\n  isOrg: boolean;\n}) {\n  let orgId: number | undefined = undefined;\n  let autoAccept = false;\n\n  if (team.parentId || isOrg) {\n    orgId = team.parentId || team.id;\n    if (email.split(\"@\")[1] == orgAutoAcceptDomain) {\n      // We discourage self-served organizations from being able to use auto-accept feature by having a barrier of a fixed number of paying teams in the account for creating the organization\n      // We can't put restriction of a published organization here because when we move teams during the onboarding of the organization, it isn't published at the moment and we really need those members to be auto-added\n      // Further, sensitive operations like member editing and impersonating are disabled by default, unless reviewed by the ADMIN team\n      autoAccept = !!orgVerified;\n    } else {\n      orgId = undefined;\n      autoAccept = false;\n    }\n  }\n\n  return { orgId, autoAccept };\n}\n\nexport async function createNewUsersConnectToOrgIfExists({\n  invitations,\n  isOrg,\n  teamId,\n  parentId,\n  autoAcceptEmailDomain,\n  orgConnectInfoByUsernameOrEmail,\n  isPlatformManaged,\n  timeFormat,\n  weekStart,\n  timeZone,\n  language,\n  creationSource,\n}: {\n  invitations: Invitation[];\n  isOrg: boolean;\n  teamId: number;\n  parentId?: number | null;\n  autoAcceptEmailDomain: string | null;\n  orgConnectInfoByUsernameOrEmail: Record<string, ReturnType<typeof getOrgConnectionInfo>>;\n  isPlatformManaged?: boolean;\n  timeFormat?: number;\n  weekStart?: string;\n  timeZone?: string;\n  language: string;\n  creationSource: CreationSource;\n}) {\n  // fail if we have invalid emails\n  invitations.forEach((invitation) => checkInputEmailIsValid(invitation.usernameOrEmail));\n  // from this point we know usernamesOrEmails contains only emails\n  const createdUsers = await prisma.$transaction(\n    async (tx) => {\n      const createdUsers = [];\n      for (let index = 0; index < invitations.length; index++) {\n        const invitation = invitations[index];\n        // Weird but orgId is defined only if the invited user email matches orgAutoAcceptEmail\n        const { orgId, autoAccept } = orgConnectInfoByUsernameOrEmail[invitation.usernameOrEmail];\n        const [emailUser, emailDomain] = invitation.usernameOrEmail.split(\"@\");\n        const [domainName, TLD] = emailDomain.split(\".\");\n\n        // An org member can't change username during signup, so we set the username\n        const orgMemberUsername =\n          emailDomain === autoAcceptEmailDomain\n            ? slugify(emailUser)\n            : slugify(`${emailUser}-${domainName}${isPlatformManaged ? `-${TLD}` : \"\"}`);\n\n        // As a regular team member is allowed to change username during signup, we don't set any username for him\n        const regularTeamMemberUsername = null;\n\n        const isBecomingAnOrgMember = parentId || isOrg;\n\n        const defaultAvailability = getAvailabilityFromSchedule(DEFAULT_SCHEDULE);\n        const t = await getTranslation(language ?? \"en\", \"common\");\n        const createdUser = await tx.user.create({\n          data: {\n            username: isBecomingAnOrgMember ? orgMemberUsername : regularTeamMemberUsername,\n            email: invitation.usernameOrEmail,\n            verified: true,\n            invitedTo: teamId,\n            isPlatformManaged: !!isPlatformManaged,\n            timeFormat,\n            weekStart,\n            timeZone,\n            creationSource,\n            organizationId: orgId || null, // If the user is invited to a child team, they are automatically added to the parent org\n            ...(orgId\n              ? {\n                  profiles: {\n                    createMany: {\n                      data: [\n                        {\n                          uid: ProfileRepository.generateProfileUid(),\n                          username: orgMemberUsername,\n                          organizationId: orgId,\n                        },\n                      ],\n                    },\n                  },\n                }\n              : null),\n            teams: {\n              create: {\n                teamId: teamId,\n                role: invitation.role,\n                accepted: autoAccept, // If the user is invited to a child team, they are automatically accepted\n              },\n            },\n            ...(!isPlatformManaged\n              ? {\n                  schedules: {\n                    create: {\n                      name: t(\"default_schedule_name\"),\n                      availability: {\n                        createMany: {\n                          data: defaultAvailability.",
            "output_extracted": "import { randomBytes } from \"crypto\";\nimport type { TFunction } from \"i18next\";\n\nimport { getOrgFullOrigin } from \"@calcom/ee/organizations/lib/orgDomains\";\nimport { sendTeamInviteEmail } from \"@calcom/emails/organization-email-service\";\nimport { checkAdminOrOwner } from \"@calcom/features/auth/lib/checkAdminOrOwner\";\nimport { updateNewTeamMemberEventTypes } from \"@calcom/features/ee/teams/lib/queries\";\nimport { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\nimport { createAProfileForAnExistingUser } from \"@calcom/features/profile/lib/createAProfileForAnExistingUser\";\nimport { ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport { OnboardingPathService } from \"@calcom/features/onboarding/lib/onboarding-path.service\";\nimport { DEFAULT_SCHEDULE, getAvailabilityFromSchedule } from \"@calcom/lib/availability\";\nimport { ENABLE_PROFILE_SWITCHER, WEBAPP_URL } from \"@calcom/lib/constants\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { getParsedTeam } from \"@calcom/lib/server/repository/teamUtils\";\nimport slugify from \"@calcom/lib/slugify\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Membership, OrganizationSettings, Team } from \"@calcom/prisma/client\";\nimport { type User as UserType, type UserPassword, Prisma } from \"@calcom/prisma/client\";\nimport type { Profile as ProfileType } from \"@calcom/prisma/client\";\nimport type { CreationSource } from \"@calcom/prisma/enums\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\nimport { teamMetadataSchema } from \"@calcom/prisma/zod-utils\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport { isEmail } from \"../util\";\nimport type { TeamWithParent } from \"./types\";\n\nconst log = logger.getSubLogger({ prefix: [\"inviteMember.utils\"] });\nexport type Invitee = Pick<\n  UserType,\n  \"id\" | \"email\" | \"username\" | \"identityProvider\" | \"completedOnboarding\"\n>;\n\nexport type UserWithMembership = Invitee & {\n  teams?: Pick<Membership, \"userId\" | \"teamId\" | \"accepted\" | \"role\">[];\n  profiles: ProfileType[];\n  password: UserPassword | null;\n};\n\nexport type Invitation = {\n  usernameOrEmail: string;\n  role: MembershipRole;\n};\n\ntype InvitableExistingUser = UserWithMembership & {\n  newRole: MembershipRole;\n};\n\ntype InvitableExistingUserWithProfile = InvitableExistingUser & {\n  profile: {\n    username: string;\n  } | null;\n};\n\nexport async function ensureAtleastAdminPermissions({\n  userId,\n  teamId,\n  isOrg,\n}: {\n  userId: number;\n  teamId: number;\n  isOrg?: boolean;\n}) {\n  const permissionCheckService = new PermissionCheckService();\n\n  // Checks if the team they are inviting to IS the org. Not a child team\n  // TODO: do some logic here to check if the user is inviting a NEW user to a team that ISNT in the same org\n  const permission = isOrg ? \"organization.invite\" : \"team.invite\";\n  const hasInvitePermission = await permissionCheckService.checkPermission({\n    userId,\n    teamId,\n    permission,\n    fallbackRoles: [MembershipRole.OWNER, MembershipRole.ADMIN],\n  });\n\n  if (!hasInvitePermission) {\n    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n  }\n}\n\nexport function checkInputEmailIsValid(email: string) {\n  if (!isEmail(email))\n    throw new TRPCError({\n      code: \"BAD_REQUEST\",\n      message: `Invite failed because ${email} is not a valid email address`,\n    });\n}\n\nexport async function getTeamOrThrow(teamId: number) {\n  const team = await prisma.team.findUnique({\n    where: {\n      id: teamId,\n    },\n    include: {\n      organizationSettings: true,\n      parent: {\n        include: {\n          organizationSettings: true,\n        },\n      },\n    },\n  });\n\n  if (!team)\n    throw new TRPCError({\n      code: \"NOT_FOUND\",\n      message: `Team not found`,\n    });\n\n  return { ...team, metadata: teamMetadataSchema.parse(team.metadata) };\n}\n\nexport async function getUniqueInvitationsOrThrowIfEmpty(invitations: Invitation[]) {\n  const usernamesOrEmailsSet = new Set<string>();\n  const uniqueInvitations: Invitation[] = [];\n\n  invitations.forEach((usernameOrEmail) => {\n    if (usernamesOrEmailsSet.has(usernameOrEmail.usernameOrEmail)) {\n      return;\n    }\n    uniqueInvitations.push(usernameOrEmail);\n    usernamesOrEmailsSet.add(usernameOrEmail.usernameOrEmail);\n  });\n\n  if (uniqueInvitations.length === 0) {\n    throw new TRPCError({\n      code: \"BAD_REQUEST\",\n      message: \"You must provide at least one email address to invite.\",\n    });\n  }\n\n  return uniqueInvitations;\n}\n\nexport const enum INVITE_STATUS {\n  USER_PENDING_MEMBER_OF_THE_ORG = \"USER_PENDING_MEMBER_OF_THE_ORG\",\n  USER_ALREADY_INVITED_OR_MEMBER = \"USER_ALREADY_INVITED_OR_MEMBER\",\n  USER_MEMBER_OF_OTHER_ORGANIZATION = \"USER_MEMBER_OF_OTHER_ORGANIZATION\",\n  CAN_BE_INVITED = \"CAN_BE_INVITED\",\n}\n\nexport function canBeInvited(invitee: UserWithMembership, team: TeamWithParent) {\n  const myLog = log.getSubLogger({ prefix: [\"canBeInvited\"] });\n  myLog.debug(\"Checking if user can be invited\", safeStringify({ invitee, team }));\n  const alreadyInvited = invitee.teams?.find(({ teamId: membershipTeamId }) => team.id === membershipTeamId);\n  if (alreadyInvited) {\n    return INVITE_STATUS.USER_ALREADY_INVITED_OR_MEMBER;\n  }\n\n  const orgMembership = invitee.teams?.find((membership) => membership.teamId === team.parentId);\n\n  // An invitee here won't be a member of the team\n  // If he is invited to a sub-team and is already part of the organization.\n  if (\n    team.parentId &&\n    new UserRepository(prisma).isAMemberOfOrganization({ user: invitee, organizationId: team.parentId })\n  ) {\n    return INVITE_STATUS.CAN_BE_INVITED;\n  }\n\n  // user invited to join a team inside an org, but has not accepted invite to org yet\n  if (team.parentId && orgMembership && !orgMembership.accepted) {\n    return INVITE_STATUS.USER_PENDING_MEMBER_OF_THE_ORG;\n  }\n\n  const hasDifferentOrganizationProfile = invitee.profiles.some((profile) => {\n    const isRegularTeam = !team.isOrganization && !team.parentId;\n    if (isRegularTeam) {\n      // \u26a0\ufe0f Inviting to a regular team but the user has a profile with some organization\n      return true;\n    }\n\n    const isOrganization = team.isOrganization && !team.parentId;\n    if (isOrganization) {\n      // \u26a0\ufe0f User has profile with different organization than the organization being invited to\n      return profile.organizationId !== team.id;\n    }\n\n    // \u26a0\ufe0f User having profile with an organization is invited to join a sub-team that is not part of the organization\n    return profile.organizationId != team.parentId;\n  });\n\n  if (\n    !ENABLE_PROFILE_SWITCHER &&\n    // User having profile with an organization is invited to join a sub-team that is not part of the organization\n    hasDifferentOrganizationProfile\n  ) {\n    return INVITE_STATUS.USER_MEMBER_OF_OTHER_ORGANIZATION;\n  }\n  return INVITE_STATUS.CAN_BE_INVITED;\n}\n\nexport async function findUsersWithInviteStatus({\n  invitations,\n  team,\n}: {\n  invitations: Invitation[];\n  team: TeamWithParent;\n}) {\n  const usernamesOrEmails = invitations.map((invitation) => invitation.usernameOrEmail);\n  const inviteesFromDb: UserWithMembership[] = await prisma.user.findMany({\n    where: {\n      OR: [\n        // Either it's a username in that organization\n        {\n          profiles: {\n            some: {\n              organizationId: team.id,\n              username: { in: usernamesOrEmails },\n            },\n          },\n        },\n        // Or it's an email\n        { email: { in: usernamesOrEmails } },\n      ],\n    },\n    select: {\n      id: true,\n      email: true,\n      username: true,\n      password: true,\n      completedOnboarding: true,\n      identityProvider: true,\n      profiles: true,\n      teams: true,\n    },\n  });\n\n  const userToRoleMap = buildUserToRoleMap();\n  const defaultMemberRole = MembershipRole.MEMBER;\n  // Check if the users found in the database can be invited to join the team/org\n  return inviteesFromDb.map((inviteeFromDb) => {\n    const newRole = getRoleForUser({ email: inviteeFromDb.email, username: inviteeFromDb.username });\n\n    return {\n      ...inviteeFromDb,\n      newRole: newRole ?? defaultMemberRole,\n      canBeInvited: canBeInvited(inviteeFromDb, team),\n    };\n  });\n\n  function buildUserToRoleMap() {\n    const userToRoleMap = new Map<string, MembershipRole>();\n    invitations.forEach((invitation) => {\n      userToRoleMap.set(invitation.usernameOrEmail, invitation.role);\n    });\n    return userToRoleMap;\n  }\n\n  function getRoleForUser({ email, username }: { email: string; username: string | null }) {\n    return userToRoleMap.get(email) || (username ? userToRoleMap.get(username) : defaultMemberRole);\n  }\n}\n\nexport function getOrgConnectionInfo({\n  orgAutoAcceptDomain,\n  orgVerified,\n  isOrg,\n  email,\n  team,\n}: {\n  orgAutoAcceptDomain?: string | null;\n  orgVerified: boolean | null;\n  email: string;\n  team: Pick<TeamWithParent, \"parentId\" | \"id\">;\n  isOrg: boolean;\n}) {\n  let orgId: number | undefined = undefined;\n  let autoAccept = false;\n\n  if (team.parentId || isOrg) {\n    orgId = team.parentId || team.id;\n    if (email.split(\"@\")[1] == orgAutoAcceptDomain) {\n      // We discourage self-served organizations from being able to use auto-accept feature by having a barrier of a fixed number of paying teams in the account for creating the organization\n      // We can't put restriction of a published organization here because when we move teams during the onboarding of the organization, it isn't published at the moment and we really need those members to be auto-added\n      // Further, sensitive operations like member editing and impersonating are disabled by default, unless reviewed by the ADMIN team\n      autoAccept = !!orgVerified;\n    } else {\n      orgId = undefined;\n      autoAccept = false;\n    }\n  }\n\n  return { orgId, autoAccept };\n}\n\nexport async function createNewUsersConnectToOrgIfExists({\n  invitations,\n  isOrg,\n  teamId,\n  parentId,\n  autoAcceptEmailDomain,\n  orgConnectInfoByUsernameOrEmail,\n  isPlatformManaged,\n  timeFormat,\n  weekStart,\n  timeZone,\n  language,\n  creationSource,\n}: {\n  invitations: Invitation[];\n  isOrg: boolean;\n  teamId: number;\n  parentId?: number | null;\n  autoAcceptEmailDomain: string | null;\n  orgConnectInfoByUsernameOrEmail: Record<string, ReturnType<typeof getOrgConnectionInfo>>;\n  isPlatformManaged?: boolean;\n  timeFormat?: number;\n  weekStart?: string;\n  timeZone?: string;\n  language: string;\n  creationSource: CreationSource;\n}) {\n  // fail if we have invalid emails\n  invitations.forEach((invitation) => checkInputEmailIsValid(invitation.usernameOrEmail));\n  // from this point we know usernamesOrEmails contains only emails\n  const createdUsers = await prisma.$transaction(\n    async (tx) => {\n      const createdUsers = [];\n      for (let index = 0; index < invitations.length; index++) {\n        const invitation = invitations[index];\n        // Weird but orgId is defined only if the invited user email matches orgAutoAcceptEmail\n        const { orgId, autoAccept } = orgConnectInfoByUsernameOrEmail[invitation.usernameOrEmail];\n        const [emailUser, emailDomain] = invitation.usernameOrEmail.split(\"@\");\n        const [domainName, TLD] = emailDomain.split(\".\");\n\n        // An org member can't change username during signup, so we set the username\n        const orgMemberUsername =\n          emailDomain === autoAcceptEmailDomain\n            ? slugify(emailUser)\n            : slugify(`${emailUser}-${domainName}${isPlatformManaged ? `-${TLD}` : \"\"}`);\n\n        // As a regular team member is allowed to change username during signup, we don't set any username for him\n        const regularTeamMemberUsername = null;\n\n        const isBecomingAnOrgMember = parentId || isOrg;\n\n        const defaultAvailability = getAvailabilityFromSchedule(DEFAULT_SCHEDULE);\n        const t = await getTranslation(language ?? \"en\", \"common\");\n        const createdUser = await tx.user.create({\n          data: {\n            username: isBecomingAnOrgMember ? orgMemberUsername : regularTeamMemberUsername,\n            email: invitation.usernameOrEmail,\n            verified: true,\n            invitedTo: teamId,\n            isPlatformManaged: !!isPlatformManaged,\n            timeFormat,\n            weekStart,\n            timeZone,\n            creationSource,\n            organizationId: orgId || null, // If the user is invited to a child team, they are automatically added to the parent org\n            ...(orgId\n              ? {\n                  profiles: {\n                    createMany: {\n                      data: [\n                        {\n                          uid: ProfileRepository.generateProfileUid(),\n                          username: orgMemberUsername,\n                          organizationId: orgId,\n                        },\n                      ],\n                    },\n                  },\n                }\n              : null),\n            teams: {\n              create: {\n                teamId: teamId,\n                role: invitation.role,\n                accepted: autoAccept, // If the user is invited to a child team, they are automatically accepted\n              },\n            },\n            ...(!isPlatformManaged\n              ? {\n                  schedules: {\n                    create: {\n                      name: t(\"default_schedule_name\"),\n                      availability: {\n                        createMany: {\n                          data: defaultAvailability.",
            "cost": 0.15826
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25330",
        "repo": "calcom/cal.com",
        "base_commit": "0af77be1272bc5b64961e639fe0ee20b040d2abd",
        "head_commit": "d1092c3b5badde359c4786f21b7eb33bea4a8c19",
        "title": "fix: filter on invites",
        "merged_at": "2025-11-21T18:34:05Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25330",
        "test_files": [
            "packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts"
        ],
        "code_files": [
            "packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts"
        ],
        "total_changes": 213,
        "num_files": 2,
        "pull_number": 25330,
        "patch": "diff --git a/packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts b/packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts\nindex 04a71d338012b2..d1952ee36e3263 100644\n--- a/packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts\n+++ b/packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts\n@@ -1,4 +1,4 @@\n-import { describe, it, vi, expect } from \"vitest\";\n+import { describe, it, vi, expect, beforeEach } from \"vitest\";\n \n import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n@@ -16,11 +16,21 @@ import {\n   canBeInvited,\n   getAutoJoinStatus,\n   checkInputEmailIsValid,\n+  createMemberships,\n } from \"./utils\";\n \n+const { mockCreateMany } = vi.hoisted(() => {\n+  const mockCreateManyFn = vi.fn();\n+  return { mockCreateMany: mockCreateManyFn };\n+});\n+\n vi.mock(\"@calcom/prisma\", () => {\n   return {\n-    prisma: vi.fn(),\n+    prisma: {\n+      membership: {\n+        createMany: mockCreateMany,\n+      },\n+    },\n   };\n });\n \n@@ -37,6 +47,27 @@ vi.mock(\"@calcom/features/pbac/services/permission-check.service\", () => {\n   };\n });\n \n+vi.mock(\"@calcom/lib/logger\", () => {\n+  const mockSubLogger = {\n+    debug: vi.fn(),\n+    error: vi.fn(),\n+    log: vi.fn(),\n+    warn: vi.fn(),\n+    info: vi.fn(),\n+    getSubLogger: vi.fn(() => mockSubLogger),\n+  };\n+  return {\n+    default: {\n+      getSubLogger: vi.fn(() => mockSubLogger),\n+      error: vi.fn(),\n+      debug: vi.fn(),\n+      log: vi.fn(),\n+      warn: vi.fn(),\n+      info: vi.fn(),\n+    },\n+  };\n+});\n+\n const mockedRegularTeam: TeamWithParent = {\n   id: 1,\n   name: \"Team A\",\n@@ -609,6 +640,178 @@ describe(\"Invite Member Utils\", () => {\n       });\n     });\n   });\n+\n+  describe(\"createMemberships - Privilege Escalation Prevention\", () => {\n+    beforeEach(() => {\n+      mockCreateMany.mockClear();\n+      mockCreateMany.mockResolvedValue({ count: 0 });\n+    });\n+\n+    it(\"should NOT escalate privilege when attacker has OWNER role in unrelated team\", async () => {\n+      const attackerTeamId = 999; // Attacker's personal team\n+      const victimTeamId = 100; // Victim team being invited to\n+      const victimOrgId = 200; // Parent organization of victim team\n+\n+      const attacker: UserWithMembership & {\n+        newRole: MembershipRole;\n+        needToCreateOrgMembership: boolean | null;\n+      } = {\n+        ...mockUser,\n+        id: 1,\n+        email: \"attacker@example.com\",\n+        username: \"attacker\",\n+        teams: [\n+          // Attacker controls this - OWNER role in their personal team (first in array)\n+          { teamId: attackerTeamId, userId: 1, accepted: true, role: MembershipRole.OWNER },\n+          // Some other unrelated membership\n+          { teamId: 50, userId: 1, accepted: true, role: MembershipRole.MEMBER },\n+        ],\n+        newRole: MembershipRole.MEMBER, // Inviter wants to invite as MEMBER\n+        needToCreateOrgMembership: true,\n+      };\n+\n+      await createMemberships({\n+        teamId: victimTeamId,\n+        language: \"en\",\n+        invitees: [attacker],\n+        parentId: victimOrgId,\n+        accepted: false,\n+      });\n+\n+      // Verify createMany was called\n+      expect(mockCreateMany).toHaveBeenCalledTimes(1);\n+\n+      // Get the data that was passed to createMany\n+      const callArgs = mockCreateMany.mock.calls[0][0];\n+      const createdMemberships = callArgs.data;\n+\n+      // Should create 2 memberships: one for team, one for org\n+      expect(createdMemberships).toHaveLength(2);\n+\n+      // Check team membership - should be MEMBER (inviter's choice), NOT OWNER\n+      const teamMembership = createdMemberships.find((m: any) => m.teamId === victimTeamId);\n+      expect(teamMembership).toBeDefined();\n+      expect(teamMembership.role).toBe(MembershipRole.MEMBER);\n+      expect(teamMembership.userId).toBe(attacker.id);\n+      expect(teamMembership.accepted).toBe(false);\n+\n+      // Check org membership\n+      const orgMembership = createdMemberships.find((m: any) => m.teamId === victimOrgId);\n+      expect(orgMembership).toBeDefined();\n+      expect(orgMembership.role).toBe(MembershipRole.MEMBER);\n+    });\n+\n+    it(\"should preserve ADMIN role when user is already ADMIN in parent organization\", async () => {\n+      const teamId = 100;\n+      const parentOrgId = 200;\n+\n+      const existingAdmin: UserWithMembership & {\n+        newRole: MembershipRole;\n+        needToCreateOrgMembership: boolean | null;\n+      } = {\n+        ...mockUser,\n+        id: 2,\n+        email: \"admin@example.com\",\n+        username: \"admin\",\n+        teams: [\n+          // User is already ADMIN in the parent org\n+          { teamId: parentOrgId, userId: 2, accepted: true, role: MembershipRole.ADMIN },\n+        ],\n+        newRole: MembershipRole.MEMBER, // Inviter wants MEMBER, but should preserve ADMIN\n+        needToCreateOrgMembership: false, // Already has org membership\n+      };\n+\n+      await createMemberships({\n+        teamId,\n+        language: \"en\",\n+        invitees: [existingAdmin],\n+        parentId: parentOrgId,\n+        accepted: true,\n+      });\n+\n+      const callArgs = mockCreateMany.mock.calls[0][0];\n+      const createdMemberships = callArgs.data;\n+\n+      // Should only create team membership (org membership already exists)\n+      expect(createdMemberships).toHaveLength(1);\n+\n+      // Should preserve ADMIN role since user is ADMIN in parent org\n+      const teamMembership = createdMemberships.find((m: any) => m.teamId === teamId);\n+      expect(teamMembership.role).toBe(MembershipRole.ADMIN);\n+    });\n+\n+    it(\"should use inviter's role when user has no membership in parent organization\", async () => {\n+      const teamId = 100;\n+      const parentOrgId = 200;\n+      const unrelatedTeamId = 999;\n+\n+      const user: UserWithMembership & {\n+        newRole: MembershipRole;\n+        needToCreateOrgMembership: boolean | null;\n+      } = {\n+        ...mockUser,\n+        id: 3,\n+        email: \"user@example.com\",\n+        username: \"user\",\n+        teams: [\n+          // User has OWNER in unrelated team, but NOT in parent org\n+          { teamId: unrelatedTeamId, userId: 3, accepted: true, role: MembershipRole.OWNER },\n+        ],\n+        newRole: MembershipRole.MEMBER,\n+        needToCreateOrgMembership: true,\n+      };\n+\n+      await createMemberships({\n+        teamId,\n+        language: \"en\",\n+        invitees: [user],\n+        parentId: parentOrgId,\n+        accepted: false,\n+      });\n+\n+      const callArgs = mockCreateMany.mock.calls[0][0];\n+      const createdMemberships = callArgs.data;\n+\n+      const teamMembership = createdMemberships.find((m: any) => m.teamId === teamId);\n+      // Should use inviter's chosen role (MEMBER), not OWNER from unrelated team\n+      expect(teamMembership.role).toBe(MembershipRole.MEMBER);\n+    });\n+\n+    it(\"should use inviter's role when inviting to team without parent organization\", async () => {\n+      const teamId = 100;\n+\n+      const user: UserWithMembership & {\n+        newRole: MembershipRole;\n+        needToCreateOrgMembership: boolean | null;\n+      } = {\n+        ...mockUser,\n+        id: 4,\n+        email: \"user2@example.com\",\n+        username: \"user2\",\n+        teams: [\n+          // User has OWNER in unrelated team\n+          { teamId: 999, userId: 4, accepted: true, role: MembershipRole.OWNER },\n+        ],\n+        newRole: MembershipRole.MEMBER,\n+        needToCreateOrgMembership: null,\n+      };\n+\n+      await createMemberships({\n+        teamId,\n+        language: \"en\",\n+        invitees: [user],\n+        parentId: null, // No parent org\n+        accepted: false,\n+      });\n+\n+      const callArgs = mockCreateMany.mock.calls[0][0];\n+      const createdMemberships = callArgs.data;\n+\n+      expect(createdMemberships).toHaveLength(1);\n+      // Should use inviter's chosen role when no parentId\n+      expect(createdMemberships[0].role).toBe(MembershipRole.MEMBER);\n+    });\n+  });\n });\n function getSampleProfile({ organizationId }: { organizationId?: number } = {}): {\n   id: number;\ndiff --git a/packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts b/packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts\nindex d00bf42f9c0333..0bf2ae50705264 100644\n--- a/packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts\n+++ b/packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts\n@@ -5,11 +5,11 @@ import { getOrgFullOrigin } from \"@calcom/ee/organizations/lib/orgDomains\";\n import { sendTeamInviteEmail } from \"@calcom/emails/organization-email-service\";\n import { checkAdminOrOwner } from \"@calcom/features/auth/lib/checkAdminOrOwner\";\n import { updateNewTeamMemberEventTypes } from \"@calcom/features/ee/teams/lib/queries\";\n+import { OnboardingPathService } from \"@calcom/features/onboarding/lib/onboarding-path.service\";\n import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\n import { createAProfileForAnExistingUser } from \"@calcom/features/profile/lib/createAProfileForAnExistingUser\";\n import { ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n-import { OnboardingPathService } from \"@calcom/features/onboarding/lib/onboarding-path.service\";\n import { DEFAULT_SCHEDULE, getAvailabilityFromSchedule } from \"@calcom/lib/availability\";\n import { ENABLE_PROFILE_SWITCHER, WEBAPP_URL } from \"@calcom/lib/constants\";\n import logger from \"@calcom/lib/logger\";\n@@ -437,7 +437,9 @@ export async function createMemberships({\n   try {\n     await prisma.membership.createMany({\n       data: invitees.flatMap((invitee) => {\n-        const organizationRole = invitee?.teams?.[0]?.role;\n+        const organizationRole = parentId\n+          ? invitee?.teams?.find((membership) => membership.teamId === parentId)?.role\n+          : undefined;\n         const data = [];\n         const createdAt = new Date();\n         // membership for the team\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}