{
    "cost": 0.48192000000000007,
    "rewrites": {
        "calcom__cal.com.main/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts": {
            "output": "import { getCredentialForSelectedCalendar } from \"@calcom/app-store/delegationCredential\";\nimport type {\n  AdapterFactory,\n  CalendarSubscriptionProvider,\n} from \"@calcom/features/calendar-subscription/adapters/AdaptersFactory\";\nimport type {\n  CalendarCredential,\n  CalendarSubscriptionEvent,\n} from \"@calcom/features/calendar-subscription/lib/CalendarSubscriptionPort.interface\";\nimport type { CalendarCacheEventService } from \"@calcom/features/calendar-subscription/lib/cache/CalendarCacheEventService\";\nimport type { CalendarSyncService } from \"@calcom/features/calendar-subscription/lib/sync/CalendarSyncService\";\nimport type { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\nimport logger from \"@calcom/lib/logger\";\nimport type { ISelectedCalendarRepository } from \"@calcom/lib/server/repository/SelectedCalendarRepository.interface\";\nimport { SelectedCalendar } from \"@calcom/prisma/client\";\n\nconst log = logger.getSubLogger({ prefix: [\"CalendarSubscriptionService\"] });\n\nexport class CalendarSubscriptionService {\n  static CALENDAR_SUBSCRIPTION_CACHE_FEATURE = \"calendar-subscription-cache\" as const;\n  static CALENDAR_SUBSCRIPTION_SYNC_FEATURE = \"calendar-subscription-sync\" as const;\n\n  constructor(\n    private deps: {\n      adapterFactory: AdapterFactory;\n      selectedCalendarRepository: ISelectedCalendarRepository;\n      featuresRepository: FeaturesRepository;\n      calendarCacheEventService: CalendarCacheEventService;\n      calendarSyncService: CalendarSyncService;\n    }\n  ) {}\n\n  /**\n   * Subscribe to a calendar\n   */\n  async subscribe(selectedCalendarId: string): Promise<void> {\n    log.debug(\"subscribe\", { selectedCalendarId });\n    const selectedCalendar = await this.deps.selectedCalendarRepository.findById(selectedCalendarId);\n    if (!selectedCalendar) {\n      log.debug(\"Selected calendar not found\", { selectedCalendarId });\n      return;\n    }\n\n    if (!selectedCalendar.credentialId && !selectedCalendar.delegationCredentialId) {\n      log.debug(\"Selected calendar doesn't have credentials\", { selectedCalendarId });\n      return;\n    }\n\n    const credential = await this.getCredential(selectedCalendar);\n    if (!credential) {\n      log.debug(\"Calendar credential not found\", { selectedCalendarId });\n      return;\n    }\n\n    const calendarSubscriptionAdapter = this.deps.adapterFactory.get(\n      selectedCalendar.integration as CalendarSubscriptionProvider\n    );\n    const res = await calendarSubscriptionAdapter.subscribe(selectedCalendar, credential);\n\n    await this.deps.selectedCalendarRepository.updateSubscription(selectedCalendarId, {\n      channelId: res?.id,\n      channelResourceId: res?.resourceId,\n      channelResourceUri: res?.resourceUri,\n      channelKind: res?.provider,\n      channelExpiration: res?.expiration,\n      syncSubscribedAt: new Date(),\n    });\n\n    // initial event loading\n    await this.processEvents(selectedCalendar);\n  }\n\n  /**\n   * Unsubscribe from a calendar\n   */\n  async unsubscribe(selectedCalendarId: string): Promise<void> {\n    log.debug(\"unsubscribe\", { selectedCalendarId });\n    const selectedCalendar = await this.deps.selectedCalendarRepository.findById(selectedCalendarId);\n    if (!selectedCalendar) {\n      log.debug(\"Selected calendar not found\", { selectedCalendarId });\n      return;\n    }\n\n    if (!selectedCalendar.credentialId && !selectedCalendar.delegationCredentialId) {\n      log.debug(\"Selected calendar doesn't have credentials\", { selectedCalendarId });\n      return;\n    }\n\n    const credential = await this.getCredential(selectedCalendar);\n    if (!credential) return;\n\n    const calendarSubscriptionAdapter = this.deps.adapterFactory.get(\n      selectedCalendar.integration as CalendarSubscriptionProvider\n    );\n\n    await Promise.all([\n      calendarSubscriptionAdapter.unsubscribe(selectedCalendar, credential),\n      this.deps.selectedCalendarRepository.updateSubscription(selectedCalendarId, {\n        syncSubscribedAt: null,\n      }),\n    ]);\n\n    // cleanup cache after unsubscribe\n    if (await this.isCacheEnabled()) {\n      log.debug(\"cleanupCache\", { selectedCalendarId });\n      await this.deps.calendarCacheEventService.cleanupCache(selectedCalendar);\n    }\n  }\n\n  /**\n   * Process webhook\n   */\n  async processWebhook(provider: CalendarSubscriptionProvider, request: Request) {\n    log.debug(\"processWebhook\", { provider });\n    const calendarSubscriptionAdapter = this.deps.adapterFactory.get(provider);\n\n    const isValid = await calendarSubscriptionAdapter.validate(request);\n    if (!isValid) throw new Error(\"Invalid webhook request\");\n\n    const channelId = await calendarSubscriptionAdapter.extractChannelId(request);\n    if (!channelId) throw new Error(\"Missing channel ID in webhook\");\n\n    log.debug(\"Processing webhook\", { channelId });\n    const selectedCalendar = await this.deps.selectedCalendarRepository.findByChannelId(channelId);\n    // it maybe caused by an old subscription being triggered\n    if (!selectedCalendar) return null;\n\n    // incremental event loading\n    await this.processEvents(selectedCalendar);\n  }\n\n  /**\n   * Process events\n   * - fetch events from calendar\n   * - process events\n   * - update selected calendar\n   * - update cache\n   * - update sync\n   */\n  async processEvents(selectedCalendar: SelectedCalendar): Promise<void> {\n    const calendarSubscriptionAdapter = this.deps.adapterFactory.get(\n      selectedCalendar.integration as CalendarSubscriptionProvider\n    );\n\n    if (!selectedCalendar.credentialId && !selectedCalendar.delegationCredentialId) {\n      log.debug(\"Selected Calendar doesn't have credentials\", { selectedCalendarId: selectedCalendar.id });\n      return;\n    }\n\n    // for cache the feature should be enabled globally and by user/team features\n    const [cacheEnabled, syncEnabled, cacheEnabledForUser] = await Promise.all([\n      this.isCacheEnabled(),\n      this.isSyncEnabled(),\n      this.isCacheEnabledForUser(selectedCalendar.userId),\n    ]);\n\n    if (!cacheEnabled && !syncEnabled) {\n      log.info(\"Cache and sync are globally disabled\", { channelId: selectedCalendar.channelId });\n      return;\n    }\n\n    log.debug(\"Processing events\", { channelId: selectedCalendar.channelId });\n    const credential = await this.getCredential(selectedCalendar);\n    if (!credential) return;\n\n    let events: CalendarSubscriptionEvent | null = null;\n    try {\n      events = await calendarSubscriptionAdapter.fetchEvents(selectedCalendar, credential);\n    } catch (err) {\n      log.debug(\"Error fetching events\", { channelId: selectedCalendar.channelId, err });\n      await this.deps.selectedCalendarRepository.updateSyncStatus(selectedCalendar.id, {\n        syncErrorAt: new Date(),\n        syncErrorCount: { increment: 1 },\n      });\n      throw err;\n    }\n\n    if (!events?.items?.length) {\n      log.debug(\"No events fetched\", { channelId: selectedCalendar.channelId });\n      return;\n    }\n\n    log.debug(\"Processing events\", { channelId: selectedCalendar.channelId, count: events.items.length });\n    await this.deps.selectedCalendarRepository.updateSyncStatus(selectedCalendar.id, {\n      syncToken: events.syncToken || selectedCalendar.syncToken,\n      syncedAt: new Date(),\n      syncErrorAt: null,\n      syncErrorCount: 0,\n    });\n\n    // it requires both global and team/user feature cache enabled\n    if (cacheEnabled && cacheEnabledForUser) {\n      log.debug(\"Caching events\", { count: events.items.length });\n      await this.deps.calendarCacheEventService.handleEvents(selectedCalendar, events.items);\n    }\n\n    if (syncEnabled) {\n      log.debug(\"Syncing events\", { count: events.items.length });\n      await this.deps.calendarSyncService.handleEvents(selectedCalendar, events.items);\n    }\n  }\n\n  /**\n   * Subscribe periodically to new calendars\n   */\n  async checkForNewSubscriptions() {\n    const rows = await this.deps.selectedCalendarRepository.findNextSubscriptionBatch({\n      take: 100,\n      integrations: this.deps.adapterFactory.getProviders(),\n    });\n    log.debug(\"checkForNewSubscriptions\", { count: rows.length });\n    await Promise.allSettled(rows.map(({ id }) => this.subscribe(id)));\n  }\n\n  /**\n   * Check if cache is enabled\n   * @returns true if cache is enabled\n   */\n  async isCacheEnabled(): Promise<boolean> {\n    return this.deps.featuresRepository.checkIfFeatureIsEnabledGlobally(\n      CalendarSubscriptionService.CALENDAR_SUBSCRIPTION_CACHE_FEATURE\n    );\n  }\n\n  /**\n   * Check if cache is enabled for user\n   * @returns true if cache is enabled\n   */\n  async isCacheEnabledForUser(userId: number): Promise<boolean> {\n    return this.deps.featuresRepository.checkIfUserHasFeature(\n      userId,\n      CalendarSubscriptionService.CALENDAR_SUBSCRIPTION_CACHE_FEATURE\n    );\n  }\n\n  /**\n   * Check if sync is enabled\n   * @returns true if sync is enabled\n   */\n  async isSyncEnabled(): Promise<boolean> {\n    return this.deps.featuresRepository.checkIfFeatureIsEnabledGlobally(\n      CalendarSubscriptionService.CALENDAR_SUBSCRIPTION_SYNC_FEATURE\n    );\n  }\n\n  /**\n   * Get credential with delegation if available\n   */\n  private async getCredential(selectedCalendar: SelectedCalendar): Promise<CalendarCredential | null> {\n    if (!selectedCalendar.credentialId && !selectedCalendar.delegationCredentialId) {\n      log.debug(\"Selected calendar doesn't have any credential\");\n      return null;\n    }\n    const credential = await getCredentialForSelectedCalendar(selectedCalendar);\n    if (!credential) return null;\n    return {\n      ...credential,\n      delegatedTo: credential.delegatedTo?.serviceAccountKey?.client_email\n        ? {\n            serviceAccountKey: {\n              client_email: credential.delegatedTo.serviceAccountKey.client_email,\n              client_id: credential.delegatedTo.serviceAccountKey.client_id,\n              private_key: credential.delegatedTo.serviceAccountKey.private_key,\n            },\n          }\n        : null,\n    };\n  }\n}",
            "output_extracted": "import { getCredentialForSelectedCalendar } from \"@calcom/app-store/delegationCredential\";\nimport type {\n  AdapterFactory,\n  CalendarSubscriptionProvider,\n} from \"@calcom/features/calendar-subscription/adapters/AdaptersFactory\";\nimport type {\n  CalendarCredential,\n  CalendarSubscriptionEvent,\n} from \"@calcom/features/calendar-subscription/lib/CalendarSubscriptionPort.interface\";\nimport type { CalendarCacheEventService } from \"@calcom/features/calendar-subscription/lib/cache/CalendarCacheEventService\";\nimport type { CalendarSyncService } from \"@calcom/features/calendar-subscription/lib/sync/CalendarSyncService\";\nimport type { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\nimport logger from \"@calcom/lib/logger\";\nimport type { ISelectedCalendarRepository } from \"@calcom/lib/server/repository/SelectedCalendarRepository.interface\";\nimport { SelectedCalendar } from \"@calcom/prisma/client\";\n\nconst log = logger.getSubLogger({ prefix: [\"CalendarSubscriptionService\"] });\n\nexport class CalendarSubscriptionService {\n  static CALENDAR_SUBSCRIPTION_CACHE_FEATURE = \"calendar-subscription-cache\" as const;\n  static CALENDAR_SUBSCRIPTION_SYNC_FEATURE = \"calendar-subscription-sync\" as const;\n\n  constructor(\n    private deps: {\n      adapterFactory: AdapterFactory;\n      selectedCalendarRepository: ISelectedCalendarRepository;\n      featuresRepository: FeaturesRepository;\n      calendarCacheEventService: CalendarCacheEventService;\n      calendarSyncService: CalendarSyncService;\n    }\n  ) {}\n\n  /**\n   * Subscribe to a calendar\n   */\n  async subscribe(selectedCalendarId: string): Promise<void> {\n    log.debug(\"subscribe\", { selectedCalendarId });\n    const selectedCalendar = await this.deps.selectedCalendarRepository.findById(selectedCalendarId);\n    if (!selectedCalendar) {\n      log.debug(\"Selected calendar not found\", { selectedCalendarId });\n      return;\n    }\n\n    if (!selectedCalendar.credentialId && !selectedCalendar.delegationCredentialId) {\n      log.debug(\"Selected calendar doesn't have credentials\", { selectedCalendarId });\n      return;\n    }\n\n    const credential = await this.getCredential(selectedCalendar);\n    if (!credential) {\n      log.debug(\"Calendar credential not found\", { selectedCalendarId });\n      return;\n    }\n\n    const calendarSubscriptionAdapter = this.deps.adapterFactory.get(\n      selectedCalendar.integration as CalendarSubscriptionProvider\n    );\n    const res = await calendarSubscriptionAdapter.subscribe(selectedCalendar, credential);\n\n    await this.deps.selectedCalendarRepository.updateSubscription(selectedCalendarId, {\n      channelId: res?.id,\n      channelResourceId: res?.resourceId,\n      channelResourceUri: res?.resourceUri,\n      channelKind: res?.provider,\n      channelExpiration: res?.expiration,\n      syncSubscribedAt: new Date(),\n    });\n\n    // initial event loading\n    await this.processEvents(selectedCalendar);\n  }\n\n  /**\n   * Unsubscribe from a calendar\n   */\n  async unsubscribe(selectedCalendarId: string): Promise<void> {\n    log.debug(\"unsubscribe\", { selectedCalendarId });\n    const selectedCalendar = await this.deps.selectedCalendarRepository.findById(selectedCalendarId);\n    if (!selectedCalendar) {\n      log.debug(\"Selected calendar not found\", { selectedCalendarId });\n      return;\n    }\n\n    if (!selectedCalendar.credentialId && !selectedCalendar.delegationCredentialId) {\n      log.debug(\"Selected calendar doesn't have credentials\", { selectedCalendarId });\n      return;\n    }\n\n    const credential = await this.getCredential(selectedCalendar);\n    if (!credential) return;\n\n    const calendarSubscriptionAdapter = this.deps.adapterFactory.get(\n      selectedCalendar.integration as CalendarSubscriptionProvider\n    );\n\n    await Promise.all([\n      calendarSubscriptionAdapter.unsubscribe(selectedCalendar, credential),\n      this.deps.selectedCalendarRepository.updateSubscription(selectedCalendarId, {\n        syncSubscribedAt: null,\n      }),\n    ]);\n\n    // cleanup cache after unsubscribe\n    if (await this.isCacheEnabled()) {\n      log.debug(\"cleanupCache\", { selectedCalendarId });\n      await this.deps.calendarCacheEventService.cleanupCache(selectedCalendar);\n    }\n  }\n\n  /**\n   * Process webhook\n   */\n  async processWebhook(provider: CalendarSubscriptionProvider, request: Request) {\n    log.debug(\"processWebhook\", { provider });\n    const calendarSubscriptionAdapter = this.deps.adapterFactory.get(provider);\n\n    const isValid = await calendarSubscriptionAdapter.validate(request);\n    if (!isValid) throw new Error(\"Invalid webhook request\");\n\n    const channelId = await calendarSubscriptionAdapter.extractChannelId(request);\n    if (!channelId) throw new Error(\"Missing channel ID in webhook\");\n\n    log.debug(\"Processing webhook\", { channelId });\n    const selectedCalendar = await this.deps.selectedCalendarRepository.findByChannelId(channelId);\n    // it maybe caused by an old subscription being triggered\n    if (!selectedCalendar) return null;\n\n    // incremental event loading\n    await this.processEvents(selectedCalendar);\n  }\n\n  /**\n   * Process events\n   * - fetch events from calendar\n   * - process events\n   * - update selected calendar\n   * - update cache\n   * - update sync\n   */\n  async processEvents(selectedCalendar: SelectedCalendar): Promise<void> {\n    const calendarSubscriptionAdapter = this.deps.adapterFactory.get(\n      selectedCalendar.integration as CalendarSubscriptionProvider\n    );\n\n    if (!selectedCalendar.credentialId && !selectedCalendar.delegationCredentialId) {\n      log.debug(\"Selected Calendar doesn't have credentials\", { selectedCalendarId: selectedCalendar.id });\n      return;\n    }\n\n    // for cache the feature should be enabled globally and by user/team features\n    const [cacheEnabled, syncEnabled, cacheEnabledForUser] = await Promise.all([\n      this.isCacheEnabled(),\n      this.isSyncEnabled(),\n      this.isCacheEnabledForUser(selectedCalendar.userId),\n    ]);\n\n    if (!cacheEnabled && !syncEnabled) {\n      log.info(\"Cache and sync are globally disabled\", { channelId: selectedCalendar.channelId });\n      return;\n    }\n\n    log.debug(\"Processing events\", { channelId: selectedCalendar.channelId });\n    const credential = await this.getCredential(selectedCalendar);\n    if (!credential) return;\n\n    let events: CalendarSubscriptionEvent | null = null;\n    try {\n      events = await calendarSubscriptionAdapter.fetchEvents(selectedCalendar, credential);\n    } catch (err) {\n      log.debug(\"Error fetching events\", { channelId: selectedCalendar.channelId, err });\n      await this.deps.selectedCalendarRepository.updateSyncStatus(selectedCalendar.id, {\n        syncErrorAt: new Date(),\n        syncErrorCount: { increment: 1 },\n      });\n      throw err;\n    }\n\n    if (!events?.items?.length) {\n      log.debug(\"No events fetched\", { channelId: selectedCalendar.channelId });\n      return;\n    }\n\n    log.debug(\"Processing events\", { channelId: selectedCalendar.channelId, count: events.items.length });\n    await this.deps.selectedCalendarRepository.updateSyncStatus(selectedCalendar.id, {\n      syncToken: events.syncToken || selectedCalendar.syncToken,\n      syncedAt: new Date(),\n      syncErrorAt: null,\n      syncErrorCount: 0,\n    });\n\n    // it requires both global and team/user feature cache enabled\n    if (cacheEnabled && cacheEnabledForUser) {\n      log.debug(\"Caching events\", { count: events.items.length });\n      await this.deps.calendarCacheEventService.handleEvents(selectedCalendar, events.items);\n    }\n\n    if (syncEnabled) {\n      log.debug(\"Syncing events\", { count: events.items.length });\n      await this.deps.calendarSyncService.handleEvents(selectedCalendar, events.items);\n    }\n  }\n\n  /**\n   * Subscribe periodically to new calendars\n   */\n  async checkForNewSubscriptions() {\n    const rows = await this.deps.selectedCalendarRepository.findNextSubscriptionBatch({\n      take: 100,\n      integrations: this.deps.adapterFactory.getProviders(),\n    });\n    log.debug(\"checkForNewSubscriptions\", { count: rows.length });\n    await Promise.allSettled(rows.map(({ id }) => this.subscribe(id)));\n  }\n\n  /**\n   * Check if cache is enabled\n   * @returns true if cache is enabled\n   */\n  async isCacheEnabled(): Promise<boolean> {\n    return this.deps.featuresRepository.checkIfFeatureIsEnabledGlobally(\n      CalendarSubscriptionService.CALENDAR_SUBSCRIPTION_CACHE_FEATURE\n    );\n  }\n\n  /**\n   * Check if cache is enabled for user\n   * @returns true if cache is enabled\n   */\n  async isCacheEnabledForUser(userId: number): Promise<boolean> {\n    return this.deps.featuresRepository.checkIfUserHasFeature(\n      userId,\n      CalendarSubscriptionService.CALENDAR_SUBSCRIPTION_CACHE_FEATURE\n    );\n  }\n\n  /**\n   * Check if sync is enabled\n   * @returns true if sync is enabled\n   */\n  async isSyncEnabled(): Promise<boolean> {\n    return this.deps.featuresRepository.checkIfFeatureIsEnabledGlobally(\n      CalendarSubscriptionService.CALENDAR_SUBSCRIPTION_SYNC_FEATURE\n    );\n  }\n\n  /**\n   * Get credential with delegation if available\n   */\n  private async getCredential(selectedCalendar: SelectedCalendar): Promise<CalendarCredential | null> {\n    if (!selectedCalendar.credentialId && !selectedCalendar.delegationCredentialId) {\n      log.debug(\"Selected calendar doesn't have any credential\");\n      return null;\n    }\n    const credential = await getCredentialForSelectedCalendar(selectedCalendar);\n    if (!credential) return null;\n    return {\n      ...credential,\n      delegatedTo: credential.delegatedTo?.serviceAccountKey?.client_email\n        ? {\n            serviceAccountKey: {\n              client_email: credential.delegatedTo.serviceAccountKey.client_email,\n              client_id: credential.delegatedTo.serviceAccountKey.client_id,\n              private_key: credential.delegatedTo.serviceAccountKey.private_key,\n            },\n          }\n        : null,\n    };\n  }\n}",
            "cost": 0.08898
        },
        "calcom__cal.com.main/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts": {
            "output": "import \"../__mocks__/delegationCredential\";\n\nimport { describe, test, expect, vi, beforeEach } from \"vitest\";\n\nimport type { AdapterFactory } from \"@calcom/features/calendar-subscription/adapters/AdaptersFactory\";\nimport type { CalendarCacheEventService } from \"@calcom/features/calendar-subscription/lib/cache/CalendarCacheEventService\";\nimport type { CalendarSyncService } from \"@calcom/features/calendar-subscription/lib/sync/CalendarSyncService\";\nimport type { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\nimport type { ISelectedCalendarRepository } from \"@calcom/lib/server/repository/SelectedCalendarRepository.interface\";\nimport type { SelectedCalendar } from \"@calcom/prisma/client\";\n\nimport { CalendarSubscriptionService } from \"../CalendarSubscriptionService\";\n\nconst mockSelectedCalendar: SelectedCalendar = {\n  id: \"test-calendar-id\",\n  userId: 1,\n  credentialId: 1,\n  integration: \"google_calendar\",\n  externalId: \"test@example.com\",\n  eventTypeId: null,\n  delegationCredentialId: null,\n  domainWideDelegationCredentialId: null,\n  googleChannelId: null,\n  googleChannelKind: null,\n  googleChannelResourceId: null,\n  googleChannelResourceUri: null,\n  googleChannelExpiration: null,\n  error: null,\n  lastErrorAt: null,\n  watchAttempts: 0,\n  maxAttempts: 3,\n  unwatchAttempts: 0,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n  channelId: \"test-channel-id\",\n  channelKind: \"web_hook\",\n  channelResourceId: \"test-resource-id\",\n  channelResourceUri: \"test-resource-uri\",\n  channelExpiration: new Date(Date.now() + 86400000),\n  syncSubscribedAt: new Date(),\n  syncToken: \"test-sync-token\",\n  syncedAt: new Date(),\n  syncErrorAt: null,\n  syncErrorCount: 0,\n};\n\nconst mockCredential = {\n  id: 1,\n  key: { access_token: \"test-token\" },\n  user: { email: \"test@example.com\" },\n  delegatedTo: null,\n};\n\nconst mockSubscriptionResult = {\n  provider: \"google_calendar\" as const,\n  id: \"test-channel-id\",\n  resourceId: \"test-resource-id\",\n  resourceUri: \"test-resource-uri\",\n  expiration: new Date(Date.now() + 86400000),\n};\n\nconst mockEvents = {\n  provider: \"google_calendar\" as const,\n  syncToken: \"new-sync-token\",\n  items: [\n    {\n      id: \"event-1\",\n      iCalUID: \"event-1@cal.com\",\n      start: new Date(),\n      end: new Date(Date.now() + 3600000),\n      busy: true,\n      summary: \"Test Event\",\n      description: \"Test Description\",\n      location: \"Test Location\",\n      status: \"confirmed\",\n      isAllDay: false,\n      timeZone: \"UTC\",\n      recurringEventId: null,\n      originalStartDate: null,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      etag: \"test-etag\",\n      kind: \"calendar#event\",\n    },\n  ],\n};\n\ndescribe(\"CalendarSubscriptionService\", () => {\n  let service: CalendarSubscriptionService;\n  let mockAdapterFactory: AdapterFactory;\n  let mockSelectedCalendarRepository: ISelectedCalendarRepository;\n  let mockFeaturesRepository: FeaturesRepository;\n  let mockCalendarCacheEventService: CalendarCacheEventService;\n  let mockCalendarSyncService: CalendarSyncService;\n  let mockAdapter: {\n    subscribe: ReturnType<typeof vi.fn>;\n    unsubscribe: ReturnType<typeof vi.fn>;\n    validate: ReturnType<typeof vi.fn>;\n    extractChannelId: ReturnType<typeof vi.fn>;\n    fetchEvents: ReturnType<typeof vi.fn>;\n  };\n\n  beforeEach(async () => {\n    mockAdapter = {\n      subscribe: vi.fn().mockResolvedValue(mockSubscriptionResult),\n      unsubscribe: vi.fn().mockResolvedValue(undefined),\n      validate: vi.fn().mockResolvedValue(true),\n      extractChannelId: vi.fn().mockResolvedValue(\"test-channel-id\"),\n      fetchEvents: vi.fn().mockResolvedValue(mockEvents),\n    };\n\n    mockAdapterFactory = {\n      get: vi.fn().mockReturnValue(mockAdapter),\n      getProviders: vi.fn().mockReturnValue([\"google_calendar\", \"office365_calendar\"]),\n    };\n\n    mockSelectedCalendarRepository = {\n      findById: vi.fn().mockResolvedValue(mockSelectedCalendar),\n      findByChannelId: vi.fn().mockResolvedValue(mockSelectedCalendar),\n      findNextSubscriptionBatch: vi.fn().mockResolvedValue([mockSelectedCalendar]),\n      updateSyncStatus: vi.fn().mockResolvedValue(mockSelectedCalendar),\n      updateSubscription: vi.fn().mockResolvedValue(mockSelectedCalendar),\n    };\n\n    mockFeaturesRepository = {\n      checkIfFeatureIsEnabledGlobally: vi.fn().mockResolvedValue(true),\n      checkIfUserHasFeature: vi.fn().mockResolvedValue(true),\n    };\n\n    mockCalendarCacheEventService = {\n      handleEvents: vi.fn().mockResolvedValue(undefined),\n      cleanupCache: vi.fn().mockResolvedValue(undefined),\n      cleanupStaleCache: vi.fn().mockResolvedValue(undefined),\n    };\n\n    mockCalendarSyncService = {\n      handleEvents: vi.fn().mockResolvedValue(undefined),\n    };\n\n    service = new CalendarSubscriptionService({\n      adapterFactory: mockAdapterFactory,\n      selectedCalendarRepository: mockSelectedCalendarRepository,\n      featuresRepository: mockFeaturesRepository,\n      calendarCacheEventService: mockCalendarCacheEventService,\n      calendarSyncService: mockCalendarSyncService,\n    });\n\n    const { getCredentialForSelectedCalendar } = await import(\"../__mocks__/delegationCredential\");\n    getCredentialForSelectedCalendar.mockResolvedValue(mockCredential);\n  });\n\n  describe(\"subscribe\", () => {\n    test(\"should successfully subscribe to a calendar\", async () => {\n      await service.subscribe(\"test-calendar-id\");\n\n      expect(mockSelectedCalendarRepository.findById).toHaveBeenCalledWith(\"test-calendar-id\");\n      expect(mockAdapterFactory.get).toHaveBeenCalledWith(\"google_calendar\");\n      expect(mockAdapter.subscribe).toHaveBeenCalledWith(mockSelectedCalendar, mockCredential);\n      expect(mockSelectedCalendarRepository.updateSubscription).toHaveBeenCalledWith(\"test-calendar-id\", {\n        channelId: \"test-channel-id\",\n        channelResourceId: \"test-resource-id\",\n        channelResourceUri: \"test-resource-uri\",\n        channelKind: \"google_calendar\",\n        channelExpiration: mockSubscriptionResult.expiration,\n        syncSubscribedAt: expect.any(Date),\n      });\n    });\n\n    test(\"should return early if selected calendar not found\", async () => {\n      mockSelectedCalendarRepository.findById.mockResolvedValue(null);\n\n      await service.subscribe(\"non-existent-id\");\n\n      expect(mockAdapter.subscribe).not.toHaveBeenCalled();\n      expect(mockSelectedCalendarRepository.updateSubscription).not.toHaveBeenCalled();\n    });\n\n    test(\"should return early if selected calendar has no credentialId or delegationCredentialId\", async () => {\n      mockSelectedCalendarRepository.findById.mockResolvedValue({\n        ...mockSelectedCalendar,\n        credentialId: null,\n        delegationCredentialId: null,\n      });\n\n      await service.subscribe(\"test-calendar-id\");\n\n      expect(mockAdapter.subscribe).not.toHaveBeenCalled();\n      expect(mockSelectedCalendarRepository.updateSubscription).not.toHaveBeenCalled();\n    });\n  });\n\n  describe(\"unsubscribe\", () => {\n    test(\"should successfully unsubscribe from a calendar\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally.mockResolvedValue(true);\n\n      await service.unsubscribe(\"test-calendar-id\");\n\n      expect(mockSelectedCalendarRepository.findById).toHaveBeenCalledWith(\"test-calendar-id\");\n      expect(mockAdapter.unsubscribe).toHaveBeenCalledWith(mockSelectedCalendar, mockCredential);\n      expect(mockSelectedCalendarRepository.updateSubscription).toHaveBeenCalledWith(\"test-calendar-id\", {\n        syncSubscribedAt: null,\n      });\n      expect(mockCalendarCacheEventService.cleanupCache).toHaveBeenCalledWith(mockSelectedCalendar);\n    });\n\n    test(\"should not cleanup cache if cache is disabled\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally.mockResolvedValue(false);\n\n      await service.unsubscribe(\"test-calendar-id\");\n\n      expect(mockCalendarCacheEventService.cleanupCache).not.toHaveBeenCalled();\n    });\n\n    test(\"should return early if selected calendar not found\", async () => {\n      mockSelectedCalendarRepository.findById.mockResolvedValue(null);\n\n      await service.unsubscribe(\"non-existent-id\");\n\n      expect(mockAdapter.unsubscribe).not.toHaveBeenCalled();\n    });\n  });\n\n  describe(\"processWebhook\", () => {\n    test(\"should successfully process a valid webhook\", async () => {\n      const mockRequest = new Request(\"http://example.com\");\n\n      await service.processWebhook(\"google_calendar\", mockRequest);\n\n      expect(mockAdapter.validate).toHaveBeenCalledWith(mockRequest);\n      expect(mockAdapter.extractChannelId).toHaveBeenCalledWith(mockRequest);\n      expect(mockSelectedCalendarRepository.findByChannelId).toHaveBeenCalledWith(\"test-channel-id\");\n    });\n\n    test(\"should throw error for invalid webhook\", async () => {\n      const mockRequest = new Request(\"http://example.com\");\n      mockAdapter.validate.mockResolvedValue(false);\n\n      await expect(service.processWebhook(\"google_calendar\", mockRequest)).rejects.toThrow(\n        \"Invalid webhook request\"\n      );\n    });\n\n    test(\"should throw error for missing channel ID\", async () => {\n      const mockRequest = new Request(\"http://example.com\");\n      mockAdapter.extractChannelId.mockResolvedValue(null);\n\n      await expect(service.processWebhook(\"google_calendar\", mockRequest)).rejects.toThrow(\n        \"Missing channel ID in webhook\"\n      );\n    });\n\n    test(\"should return null for old subscription\", async () => {\n      const mockRequest = new Request(\"http://example.com\");\n      mockSelectedCalendarRepository.findByChannelId.mockResolvedValue(null);\n\n      const _result = await service.processWebhook(\"google_calendar\", mockRequest);\n\n      expect(_result).toBeNull();\n    });\n  });\n\n  describe(\"processEvents\", () => {\n    test(\"should process events when both cache and sync are enabled\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(true)\n        .mockResolvedValueOnce(true);\n      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(true);\n\n      await service.processEvents(mockSelectedCalendar);\n\n      expect(mockAdapter.fetchEvents).toHaveBeenCalledWith(mockSelectedCalendar, mockCredential);\n      expect(mockSelectedCalendarRepository.updateSyncStatus).toHaveBeenCalledWith(mockSelectedCalendar.id, {\n        syncToken: \"new-sync-token\",\n        syncedAt: expect.any(Date),\n        syncErrorAt: null,\n        syncErrorCount: 0,\n      });\n      expect(mockCalendarCacheEventService.handleEvents).toHaveBeenCalledWith(\n        mockSelectedCalendar,\n        mockEvents.items\n      );\n      expect(mockCalendarSyncService.handleEvents).toHaveBeenCalledWith(\n        mockSelectedCalendar,\n        mockEvents.items\n      );\n    });\n\n    test(\"should not process cache when cache is disabled globally\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(false)\n        .mockResolvedValueOnce(true);\n      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(true);\n\n      await service.processEvents(mockSelectedCalendar);\n\n      expect(mockCalendarCacheEventService.handleEvents).not.toHaveBeenCalled();\n      expect(mockCalendarSyncService.handleEvents).toHaveBeenCalled();\n    });\n\n    test(\"should not process cache when cache is disabled for user\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(true)\n        .mockResolvedValueOnce(true);\n      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(false);\n\n      await service.processEvents(mockSelectedCalendar);\n\n      expect(mockCalendarCacheEventService.handleEvents).not.toHaveBeenCalled();\n      expect(mockCalendarSyncService.handleEvents).toHaveBeenCalled();\n    });\n\n    test(\"should return early when both cache and sync are disabled\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(false)\n        .mockResolvedValueOnce(false);\n\n      await service.processEvents(mockSelectedCalendar);\n\n      expect(mockAdapter.fetchEvents).not.toHaveBeenCalled();\n      expect(mockCalendarCacheEventService.handleEvents).not.toHaveBeenCalled();\n      expect(mockCalendarSyncService.handleEvents).not.toHaveBeenCalled();\n    });\n\n    test(\"should handle API errors and update sync status\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(true)\n        .mockResolvedValueOnce(true);\n      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(true);\n\n      const apiError = new Error(\"API Error\");\n      mockAdapter.fetchEvents.mockRejectedValue(apiError);\n\n      await expect(service.processEvents(mockSelectedCalendar)).rejects.toThrow(\"API Error\");\n\n      expect(mockSelectedCalendarRepository.updateSyncStatus).toHaveBeenCalledWith(mockSelectedCalendar.id, {\n        syncErrorAt: expect.any(Date),\n        syncErrorCount: {\n          increment: 1,\n        },\n      });\n    });\n\n    test(\"should return early when no events are fetched\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(true)\n        .mockResolvedValueOnce(true);\n      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(true);\n\n      mockAdapter.fetchEvents.mockResolvedValue({\n        ...mockEvents,\n        items: [],\n      });\n\n      await service.processEvents(mockSelectedCalendar);\n\n      expect(mockCalendarCacheEventService.handleEvents).not.toHaveBeenCalled();\n      expect(mockCalendarSyncService.handleEvents).not.toHaveBeenCalled();\n    });\n\n    test(\"should return early when selected calendar has no credentialId or delegationCredentialId\", async () => {\n      const calendarWithoutCredential = {\n        ...mockSelectedCalendar,\n        credentialId: null,\n        delegationCredential",
            "output_extracted": "import \"../__mocks__/delegationCredential\";\n\nimport { describe, test, expect, vi, beforeEach } from \"vitest\";\n\nimport type { AdapterFactory } from \"@calcom/features/calendar-subscription/adapters/AdaptersFactory\";\nimport type { CalendarCacheEventService } from \"@calcom/features/calendar-subscription/lib/cache/CalendarCacheEventService\";\nimport type { CalendarSyncService } from \"@calcom/features/calendar-subscription/lib/sync/CalendarSyncService\";\nimport type { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\nimport type { ISelectedCalendarRepository } from \"@calcom/lib/server/repository/SelectedCalendarRepository.interface\";\nimport type { SelectedCalendar } from \"@calcom/prisma/client\";\n\nimport { CalendarSubscriptionService } from \"../CalendarSubscriptionService\";\n\nconst mockSelectedCalendar: SelectedCalendar = {\n  id: \"test-calendar-id\",\n  userId: 1,\n  credentialId: 1,\n  integration: \"google_calendar\",\n  externalId: \"test@example.com\",\n  eventTypeId: null,\n  delegationCredentialId: null,\n  domainWideDelegationCredentialId: null,\n  googleChannelId: null,\n  googleChannelKind: null,\n  googleChannelResourceId: null,\n  googleChannelResourceUri: null,\n  googleChannelExpiration: null,\n  error: null,\n  lastErrorAt: null,\n  watchAttempts: 0,\n  maxAttempts: 3,\n  unwatchAttempts: 0,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n  channelId: \"test-channel-id\",\n  channelKind: \"web_hook\",\n  channelResourceId: \"test-resource-id\",\n  channelResourceUri: \"test-resource-uri\",\n  channelExpiration: new Date(Date.now() + 86400000),\n  syncSubscribedAt: new Date(),\n  syncToken: \"test-sync-token\",\n  syncedAt: new Date(),\n  syncErrorAt: null,\n  syncErrorCount: 0,\n};\n\nconst mockCredential = {\n  id: 1,\n  key: { access_token: \"test-token\" },\n  user: { email: \"test@example.com\" },\n  delegatedTo: null,\n};\n\nconst mockSubscriptionResult = {\n  provider: \"google_calendar\" as const,\n  id: \"test-channel-id\",\n  resourceId: \"test-resource-id\",\n  resourceUri: \"test-resource-uri\",\n  expiration: new Date(Date.now() + 86400000),\n};\n\nconst mockEvents = {\n  provider: \"google_calendar\" as const,\n  syncToken: \"new-sync-token\",\n  items: [\n    {\n      id: \"event-1\",\n      iCalUID: \"event-1@cal.com\",\n      start: new Date(),\n      end: new Date(Date.now() + 3600000),\n      busy: true,\n      summary: \"Test Event\",\n      description: \"Test Description\",\n      location: \"Test Location\",\n      status: \"confirmed\",\n      isAllDay: false,\n      timeZone: \"UTC\",\n      recurringEventId: null,\n      originalStartDate: null,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      etag: \"test-etag\",\n      kind: \"calendar#event\",\n    },\n  ],\n};\n\ndescribe(\"CalendarSubscriptionService\", () => {\n  let service: CalendarSubscriptionService;\n  let mockAdapterFactory: AdapterFactory;\n  let mockSelectedCalendarRepository: ISelectedCalendarRepository;\n  let mockFeaturesRepository: FeaturesRepository;\n  let mockCalendarCacheEventService: CalendarCacheEventService;\n  let mockCalendarSyncService: CalendarSyncService;\n  let mockAdapter: {\n    subscribe: ReturnType<typeof vi.fn>;\n    unsubscribe: ReturnType<typeof vi.fn>;\n    validate: ReturnType<typeof vi.fn>;\n    extractChannelId: ReturnType<typeof vi.fn>;\n    fetchEvents: ReturnType<typeof vi.fn>;\n  };\n\n  beforeEach(async () => {\n    mockAdapter = {\n      subscribe: vi.fn().mockResolvedValue(mockSubscriptionResult),\n      unsubscribe: vi.fn().mockResolvedValue(undefined),\n      validate: vi.fn().mockResolvedValue(true),\n      extractChannelId: vi.fn().mockResolvedValue(\"test-channel-id\"),\n      fetchEvents: vi.fn().mockResolvedValue(mockEvents),\n    };\n\n    mockAdapterFactory = {\n      get: vi.fn().mockReturnValue(mockAdapter),\n      getProviders: vi.fn().mockReturnValue([\"google_calendar\", \"office365_calendar\"]),\n    };\n\n    mockSelectedCalendarRepository = {\n      findById: vi.fn().mockResolvedValue(mockSelectedCalendar),\n      findByChannelId: vi.fn().mockResolvedValue(mockSelectedCalendar),\n      findNextSubscriptionBatch: vi.fn().mockResolvedValue([mockSelectedCalendar]),\n      updateSyncStatus: vi.fn().mockResolvedValue(mockSelectedCalendar),\n      updateSubscription: vi.fn().mockResolvedValue(mockSelectedCalendar),\n    };\n\n    mockFeaturesRepository = {\n      checkIfFeatureIsEnabledGlobally: vi.fn().mockResolvedValue(true),\n      checkIfUserHasFeature: vi.fn().mockResolvedValue(true),\n    };\n\n    mockCalendarCacheEventService = {\n      handleEvents: vi.fn().mockResolvedValue(undefined),\n      cleanupCache: vi.fn().mockResolvedValue(undefined),\n      cleanupStaleCache: vi.fn().mockResolvedValue(undefined),\n    };\n\n    mockCalendarSyncService = {\n      handleEvents: vi.fn().mockResolvedValue(undefined),\n    };\n\n    service = new CalendarSubscriptionService({\n      adapterFactory: mockAdapterFactory,\n      selectedCalendarRepository: mockSelectedCalendarRepository,\n      featuresRepository: mockFeaturesRepository,\n      calendarCacheEventService: mockCalendarCacheEventService,\n      calendarSyncService: mockCalendarSyncService,\n    });\n\n    const { getCredentialForSelectedCalendar } = await import(\"../__mocks__/delegationCredential\");\n    getCredentialForSelectedCalendar.mockResolvedValue(mockCredential);\n  });\n\n  describe(\"subscribe\", () => {\n    test(\"should successfully subscribe to a calendar\", async () => {\n      await service.subscribe(\"test-calendar-id\");\n\n      expect(mockSelectedCalendarRepository.findById).toHaveBeenCalledWith(\"test-calendar-id\");\n      expect(mockAdapterFactory.get).toHaveBeenCalledWith(\"google_calendar\");\n      expect(mockAdapter.subscribe).toHaveBeenCalledWith(mockSelectedCalendar, mockCredential);\n      expect(mockSelectedCalendarRepository.updateSubscription).toHaveBeenCalledWith(\"test-calendar-id\", {\n        channelId: \"test-channel-id\",\n        channelResourceId: \"test-resource-id\",\n        channelResourceUri: \"test-resource-uri\",\n        channelKind: \"google_calendar\",\n        channelExpiration: mockSubscriptionResult.expiration,\n        syncSubscribedAt: expect.any(Date),\n      });\n    });\n\n    test(\"should return early if selected calendar not found\", async () => {\n      mockSelectedCalendarRepository.findById.mockResolvedValue(null);\n\n      await service.subscribe(\"non-existent-id\");\n\n      expect(mockAdapter.subscribe).not.toHaveBeenCalled();\n      expect(mockSelectedCalendarRepository.updateSubscription).not.toHaveBeenCalled();\n    });\n\n    test(\"should return early if selected calendar has no credentialId or delegationCredentialId\", async () => {\n      mockSelectedCalendarRepository.findById.mockResolvedValue({\n        ...mockSelectedCalendar,\n        credentialId: null,\n        delegationCredentialId: null,\n      });\n\n      await service.subscribe(\"test-calendar-id\");\n\n      expect(mockAdapter.subscribe).not.toHaveBeenCalled();\n      expect(mockSelectedCalendarRepository.updateSubscription).not.toHaveBeenCalled();\n    });\n  });\n\n  describe(\"unsubscribe\", () => {\n    test(\"should successfully unsubscribe from a calendar\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally.mockResolvedValue(true);\n\n      await service.unsubscribe(\"test-calendar-id\");\n\n      expect(mockSelectedCalendarRepository.findById).toHaveBeenCalledWith(\"test-calendar-id\");\n      expect(mockAdapter.unsubscribe).toHaveBeenCalledWith(mockSelectedCalendar, mockCredential);\n      expect(mockSelectedCalendarRepository.updateSubscription).toHaveBeenCalledWith(\"test-calendar-id\", {\n        syncSubscribedAt: null,\n      });\n      expect(mockCalendarCacheEventService.cleanupCache).toHaveBeenCalledWith(mockSelectedCalendar);\n    });\n\n    test(\"should not cleanup cache if cache is disabled\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally.mockResolvedValue(false);\n\n      await service.unsubscribe(\"test-calendar-id\");\n\n      expect(mockCalendarCacheEventService.cleanupCache).not.toHaveBeenCalled();\n    });\n\n    test(\"should return early if selected calendar not found\", async () => {\n      mockSelectedCalendarRepository.findById.mockResolvedValue(null);\n\n      await service.unsubscribe(\"non-existent-id\");\n\n      expect(mockAdapter.unsubscribe).not.toHaveBeenCalled();\n    });\n  });\n\n  describe(\"processWebhook\", () => {\n    test(\"should successfully process a valid webhook\", async () => {\n      const mockRequest = new Request(\"http://example.com\");\n\n      await service.processWebhook(\"google_calendar\", mockRequest);\n\n      expect(mockAdapter.validate).toHaveBeenCalledWith(mockRequest);\n      expect(mockAdapter.extractChannelId).toHaveBeenCalledWith(mockRequest);\n      expect(mockSelectedCalendarRepository.findByChannelId).toHaveBeenCalledWith(\"test-channel-id\");\n    });\n\n    test(\"should throw error for invalid webhook\", async () => {\n      const mockRequest = new Request(\"http://example.com\");\n      mockAdapter.validate.mockResolvedValue(false);\n\n      await expect(service.processWebhook(\"google_calendar\", mockRequest)).rejects.toThrow(\n        \"Invalid webhook request\"\n      );\n    });\n\n    test(\"should throw error for missing channel ID\", async () => {\n      const mockRequest = new Request(\"http://example.com\");\n      mockAdapter.extractChannelId.mockResolvedValue(null);\n\n      await expect(service.processWebhook(\"google_calendar\", mockRequest)).rejects.toThrow(\n        \"Missing channel ID in webhook\"\n      );\n    });\n\n    test(\"should return null for old subscription\", async () => {\n      const mockRequest = new Request(\"http://example.com\");\n      mockSelectedCalendarRepository.findByChannelId.mockResolvedValue(null);\n\n      const _result = await service.processWebhook(\"google_calendar\", mockRequest);\n\n      expect(_result).toBeNull();\n    });\n  });\n\n  describe(\"processEvents\", () => {\n    test(\"should process events when both cache and sync are enabled\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(true)\n        .mockResolvedValueOnce(true);\n      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(true);\n\n      await service.processEvents(mockSelectedCalendar);\n\n      expect(mockAdapter.fetchEvents).toHaveBeenCalledWith(mockSelectedCalendar, mockCredential);\n      expect(mockSelectedCalendarRepository.updateSyncStatus).toHaveBeenCalledWith(mockSelectedCalendar.id, {\n        syncToken: \"new-sync-token\",\n        syncedAt: expect.any(Date),\n        syncErrorAt: null,\n        syncErrorCount: 0,\n      });\n      expect(mockCalendarCacheEventService.handleEvents).toHaveBeenCalledWith(\n        mockSelectedCalendar,\n        mockEvents.items\n      );\n      expect(mockCalendarSyncService.handleEvents).toHaveBeenCalledWith(\n        mockSelectedCalendar,\n        mockEvents.items\n      );\n    });\n\n    test(\"should not process cache when cache is disabled globally\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(false)\n        .mockResolvedValueOnce(true);\n      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(true);\n\n      await service.processEvents(mockSelectedCalendar);\n\n      expect(mockCalendarCacheEventService.handleEvents).not.toHaveBeenCalled();\n      expect(mockCalendarSyncService.handleEvents).toHaveBeenCalled();\n    });\n\n    test(\"should not process cache when cache is disabled for user\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(true)\n        .mockResolvedValueOnce(true);\n      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(false);\n\n      await service.processEvents(mockSelectedCalendar);\n\n      expect(mockCalendarCacheEventService.handleEvents).not.toHaveBeenCalled();\n      expect(mockCalendarSyncService.handleEvents).toHaveBeenCalled();\n    });\n\n    test(\"should return early when both cache and sync are disabled\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(false)\n        .mockResolvedValueOnce(false);\n\n      await service.processEvents(mockSelectedCalendar);\n\n      expect(mockAdapter.fetchEvents).not.toHaveBeenCalled();\n      expect(mockCalendarCacheEventService.handleEvents).not.toHaveBeenCalled();\n      expect(mockCalendarSyncService.handleEvents).not.toHaveBeenCalled();\n    });\n\n    test(\"should handle API errors and update sync status\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(true)\n        .mockResolvedValueOnce(true);\n      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(true);\n\n      const apiError = new Error(\"API Error\");\n      mockAdapter.fetchEvents.mockRejectedValue(apiError);\n\n      await expect(service.processEvents(mockSelectedCalendar)).rejects.toThrow(\"API Error\");\n\n      expect(mockSelectedCalendarRepository.updateSyncStatus).toHaveBeenCalledWith(mockSelectedCalendar.id, {\n        syncErrorAt: expect.any(Date),\n        syncErrorCount: {\n          increment: 1,\n        },\n      });\n    });\n\n    test(\"should return early when no events are fetched\", async () => {\n      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally\n        .mockResolvedValueOnce(true)\n        .mockResolvedValueOnce(true);\n      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(true);\n\n      mockAdapter.fetchEvents.mockResolvedValue({\n        ...mockEvents,\n        items: [],\n      });\n\n      await service.processEvents(mockSelectedCalendar);\n\n      expect(mockCalendarCacheEventService.handleEvents).not.toHaveBeenCalled();\n      expect(mockCalendarSyncService.handleEvents).not.toHaveBeenCalled();\n    });\n\n    test(\"should return early when selected calendar has no credentialId or delegationCredentialId\", async () => {\n      const calendarWithoutCredential = {\n        ...mockSelectedCalendar,\n        credentialId: null,\n        delegationCredential",
            "cost": 0.142295
        },
        "calcom__cal.com.main/packages/features/flags/features.repository.interface.ts": {
            "output": "import type { AppFlags } from \"./config\";\n\nexport interface IFeaturesRepository {\n  checkIfFeatureIsEnabledGlobally(slug: keyof AppFlags): Promise<boolean>;\n  checkIfUserHasFeature(userId: number, slug: string): Promise<boolean>;\n  checkIfTeamHasFeature(teamId: number, slug: keyof AppFlags): Promise<boolean>;\n}",
            "output_extracted": "import type { AppFlags } from \"./config\";\n\nexport interface IFeaturesRepository {\n  checkIfFeatureIsEnabledGlobally(slug: keyof AppFlags): Promise<boolean>;\n  checkIfUserHasFeature(userId: number, slug: string): Promise<boolean>;\n  checkIfTeamHasFeature(teamId: number, slug: keyof AppFlags): Promise<boolean>;\n}",
            "cost": 0.007725
        },
        "calcom__cal.com.main/packages/features/flags/features.repository.ts": {
            "output": "import { captureException } from \"@sentry/nextjs\";\n\nimport type { PrismaClient } from \"@calcom/prisma\";\nimport { Prisma } from \"@calcom/prisma/client\";\n\nimport type { AppFlags, TeamFeatures } from \"./config\";\nimport type { IFeaturesRepository } from \"./features.repository.interface\";\n\ninterface CacheOptions {\n  ttl: number; // time in ms\n}\n\n/**\n * Repository class for managing feature flags and feature access control.\n * Implements the IFeaturesRepository interface to provide feature flag functionality\n * for users, teams, and global application features.\n */\nexport class FeaturesRepository implements IFeaturesRepository {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private static featuresCache: { data: any[]; expiry: number } | null = null;\n\n  constructor(private prismaClient: PrismaClient) {}\n\n  private clearCache() {\n    FeaturesRepository.featuresCache = null;\n  }\n\n  /**\n   * Gets all features with their enabled status.\n   * Uses caching to avoid hitting the database on every request.\n   * @returns Promise<Feature[]> - Array of all features\n   */\n  public async getAllFeatures() {\n    if (FeaturesRepository.featuresCache && Date.now() < FeaturesRepository.featuresCache.expiry) {\n      return FeaturesRepository.featuresCache.data;\n    }\n\n    const features = await this.prismaClient.feature.findMany({\n      orderBy: { slug: \"asc\" },\n    });\n\n    FeaturesRepository.featuresCache = {\n      data: features,\n      expiry: Date.now() + 5 * 60 * 1000, // 5 minutes cache\n    };\n\n    return features;\n  }\n\n  /**\n   * Gets a map of all feature flags and their enabled status.\n   * Uses caching to avoid hitting the database on every request.\n   * @returns Promise<AppFlags> - A map of feature flags to their enabled status\n   */\n  public async getFeatureFlagMap() {\n    const flags = await this.getAllFeatures();\n    return flags.reduce((acc, flag) => {\n      acc[flag.slug as keyof AppFlags] = flag.enabled;\n      return acc;\n    }, {} as AppFlags);\n  }\n\n  /**\n   * Gets all features enabled for a specific team in a map format.\n   * @param teamId - The ID of the team to get features for\n   * @returns Promise<{ [slug: string]: boolean } | null>\n   */\n  public async getTeamFeatures(teamId: number) {\n    const result = await this.prismaClient.teamFeatures.findMany({\n      where: {\n        teamId,\n      },\n      include: {\n        feature: {\n          select: {\n            slug: true,\n            enabled: true,\n          },\n        },\n      },\n    });\n\n    if (!result.length) return null;\n\n    const features: TeamFeatures = Object.fromEntries(\n      result.map((teamFeature) => [teamFeature.feature.slug, true])\n    ) as TeamFeatures;\n\n    return features;\n  }\n\n  /**\n   * Checks if a feature is enabled globally in the application.\n   * @param slug - The feature flag identifier to check\n   * @returns Promise<boolean> - True if the feature is enabled globally, false otherwise\n   * @throws Error if the feature flag check fails\n   */\n  async checkIfFeatureIsEnabledGlobally(\n    slug: keyof AppFlags,\n    _options: CacheOptions = { ttl: 5 * 60 * 1000 }\n  ): Promise<boolean> {\n    try {\n      const features = await this.getAllFeatures();\n      const flag = features.find((f) => f.slug === slug);\n      return Boolean(flag && flag.enabled);\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Checks if a specific user has access to a feature.\n   * Checks both direct user feature assignments and team-based feature access.\n   * @param userId - The ID of the user to check\n   * @param slug - The feature identifier to check\n   * @returns Promise<boolean> - True if the user has access to the feature, false otherwise\n   * @throws Error if the feature access check fails\n   */\n  async checkIfUserHasFeature(userId: number, slug: string) {\n    try {\n      /**\n       * findUnique was failing in prismock tests, so I'm using findFirst instead\n       * FIXME refactor when upgrading prismock\n       * https://github.com/morintd/prismock/issues/592\n       */\n      const userHasFeature = await this.prismaClient.userFeatures.findFirst({\n        where: {\n          userId,\n          featureId: slug,\n        },\n      });\n      if (userHasFeature) return true;\n      // If the user doesn't have the feature, check if they belong to a team with the feature.\n      // This also covers organizations, which are teams.\n      const userBelongsToTeamWithFeature = await this.checkIfUserBelongsToTeamWithFeature(userId, slug);\n      if (userBelongsToTeamWithFeature) return true;\n      return false;\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Checks if a specific user has access to a feature, ignoring hierarchical (parent) teams.\n   * Only checks direct user assignments and direct team memberships \u2014 does not traverse parents.\n   * @param userId - The ID of the user to check\n   * @param slug - The feature identifier to check\n   * @returns Promise<boolean> - True if the user has direct or same-level team access to the feature\n   * @throws Error if the feature access check fails\n   */\n  async checkIfUserHasFeatureNonHierarchical(userId: number, slug: string) {\n    try {\n      // Prismock limitation: findUnique may fail, use findFirst instead\n      const userHasFeature = await this.prismaClient.userFeatures.findFirst({\n        select: {\n          userId: true,\n        },\n        where: {\n          userId,\n          featureId: slug,\n        },\n      });\n      if (userHasFeature) return true;\n\n      const userBelongsToTeamWithFeature = await this.checkIfUserBelongsToTeamWithFeatureNonHierarchical(\n        userId,\n        slug\n      );\n\n      return userBelongsToTeamWithFeature;\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Private helper method to check if a user belongs to any team that has access to a feature.\n   * @param userId - The ID of the user to check\n   * @param slug - The feature identifier to check\n   * @returns Promise<boolean> - True if the user belongs to a team with the feature, false otherwise\n   * @throws Error if the team feature check fails\n   * @private\n   */\n  private async checkIfUserBelongsToTeamWithFeature(userId: number, slug: string) {\n    try {\n      const query = Prisma.sql`\n        WITH RECURSIVE TeamHierarchy AS (\n          -- Start with teams the user belongs to\n          SELECT DISTINCT t.id, t.\"parentId\",\n            CASE WHEN EXISTS (\n              SELECT 1 FROM \"TeamFeatures\" tf\n              WHERE tf.\"teamId\" = t.id AND tf.\"featureId\" = ${slug}\n            ) THEN true ELSE false END as has_feature\n          FROM \"Team\" t\n          INNER JOIN \"Membership\" m ON m.\"teamId\" = t.id\n          WHERE m.\"userId\" = ${userId} AND m.accepted = true\n\n          UNION ALL\n\n          -- Recursively get parent teams\n          SELECT DISTINCT p.id, p.\"parentId\",\n            CASE WHEN EXISTS (\n              SELECT 1 FROM \"TeamFeatures\" tf\n              WHERE tf.\"teamId\" = p.id AND tf.\"featureId\" = ${slug}\n            ) THEN true ELSE false END as has_feature\n          FROM \"Team\" p\n          INNER JOIN TeamHierarchy c ON p.id = c.\"parentId\"\n          WHERE NOT c.has_feature -- Stop recursion if we found a team with the feature\n        )\n        SELECT 1\n        FROM TeamHierarchy\n        WHERE has_feature = true\n        LIMIT 1;\n      `;\n\n      const result = await this.prismaClient.$queryRaw<unknown[]>(query);\n      return result.length > 0;\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Checks if a user belongs to any direct team that has access to a feature.\n   * This version ignores parent/child team relationships \u2014 no recursion or hierarchy traversal.\n   * @param userId - The ID of the user to check\n   * @param slug - The feature identifier to check\n   * @returns Promise<boolean> - True if the user belongs to a team with the feature (direct only)\n   * @throws Error if the query fails\n   * @private\n   */\n  private async checkIfUserBelongsToTeamWithFeatureNonHierarchical(userId: number, slug: string) {\n    try {\n      const query = Prisma.sql`\n        SELECT 1\n        FROM \"Team\" t\n        INNER JOIN \"Membership\" m ON m.\"teamId\" = t.id\n        WHERE m.\"userId\" = ${userId}\n          AND m.accepted = true\n          AND EXISTS (\n            SELECT 1\n            FROM \"TeamFeatures\" tf\n            WHERE tf.\"teamId\" = t.id\n              AND tf.\"featureId\" = ${slug}\n          )\n        LIMIT 1;\n      `;\n\n      const result = await this.prismaClient.$queryRaw<unknown[]>(query);\n      return result.length > 0;\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Enables a feature for a specific team.\n   * @param teamId - The ID of the team to enable the feature for\n   * @param featureId - The feature identifier to enable\n   * @param assignedBy - The user or what assigned the feature\n   * @returns Promise<void>\n   * @throws Error if the feature enabling fails\n   */\n  async enableFeatureForTeam(teamId: number, featureId: keyof AppFlags, assignedBy: string): Promise<void> {\n    try {\n      await this.prismaClient.teamFeatures.upsert({\n        where: {\n          teamId_featureId: {\n            teamId,\n            featureId,\n          },\n        },\n        create: {\n          teamId,\n          featureId,\n          assignedBy,\n        },\n        update: {},\n      });\n      // Clear cache when features are modified\n      this.clearCache();\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Checks if a team or any of its ancestors has access to a specific feature.\n   * Uses a recursive CTE raw SQL query for performance.\n   * @param teamId - The ID of the team to start the check from\n   * @param featureId - The feature identifier to check\n   * @returns Promise<boolean> - True if the team or any ancestor has the feature, false otherwise\n   * @throws Error if the database query fails\n   */\n  async checkIfTeamHasFeature(teamId: number, featureId: keyof AppFlags): Promise<boolean> {\n    try {\n      // Early return if team has feature directly assigned\n      const teamHasFeature = await this.prismaClient.teamFeatures.findUnique({\n        where: {\n          teamId_featureId: {\n            teamId,\n            featureId,\n          },\n        },\n      });\n      if (teamHasFeature) return true;\n\n      const query = Prisma.sql`\n        WITH RECURSIVE TeamHierarchy AS (\n          -- Start with the initial team\n          SELECT id, \"parentId\",\n            CASE WHEN EXISTS (\n              SELECT 1 FROM \"TeamFeatures\" tf\n              WHERE tf.\"teamId\" = id AND tf.\"featureId\" = ${featureId}\n            ) THEN true ELSE false END as has_feature\n          FROM \"Team\"\n          WHERE id = ${teamId}\n\n          UNION ALL\n\n          -- Recursively get parent teams\n          SELECT p.id, p.\"parentId\",\n            CASE WHEN EXISTS (\n              SELECT 1 FROM \"TeamFeatures\" tf\n              WHERE tf.\"teamId\" = p.id AND tf.\"featureId\" = ${featureId}\n            ) THEN true ELSE false END as has_feature\n          FROM \"Team\" p\n          INNER JOIN TeamHierarchy c ON p.id = c.\"parentId\"\n          WHERE NOT c.has_feature -- Stop recursion if we found a team with the feature\n        )\n        SELECT 1\n        FROM TeamHierarchy\n        WHERE has_feature = true\n        LIMIT 1;\n      `;\n\n      const result = await this.prismaClient.$queryRaw<unknown[]>(query);\n      return result.length > 0;\n    } catch (err) {\n      captureException(err);\n      console.error(\n        `Recursive feature check failed for team ${teamId}, feature ${featureId}:`,\n        err instanceof Error ? err.message : err\n      );\n      throw err;\n    }\n  }\n}",
            "output_extracted": "import { captureException } from \"@sentry/nextjs\";\n\nimport type { PrismaClient } from \"@calcom/prisma\";\nimport { Prisma } from \"@calcom/prisma/client\";\n\nimport type { AppFlags, TeamFeatures } from \"./config\";\nimport type { IFeaturesRepository } from \"./features.repository.interface\";\n\ninterface CacheOptions {\n  ttl: number; // time in ms\n}\n\n/**\n * Repository class for managing feature flags and feature access control.\n * Implements the IFeaturesRepository interface to provide feature flag functionality\n * for users, teams, and global application features.\n */\nexport class FeaturesRepository implements IFeaturesRepository {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private static featuresCache: { data: any[]; expiry: number } | null = null;\n\n  constructor(private prismaClient: PrismaClient) {}\n\n  private clearCache() {\n    FeaturesRepository.featuresCache = null;\n  }\n\n  /**\n   * Gets all features with their enabled status.\n   * Uses caching to avoid hitting the database on every request.\n   * @returns Promise<Feature[]> - Array of all features\n   */\n  public async getAllFeatures() {\n    if (FeaturesRepository.featuresCache && Date.now() < FeaturesRepository.featuresCache.expiry) {\n      return FeaturesRepository.featuresCache.data;\n    }\n\n    const features = await this.prismaClient.feature.findMany({\n      orderBy: { slug: \"asc\" },\n    });\n\n    FeaturesRepository.featuresCache = {\n      data: features,\n      expiry: Date.now() + 5 * 60 * 1000, // 5 minutes cache\n    };\n\n    return features;\n  }\n\n  /**\n   * Gets a map of all feature flags and their enabled status.\n   * Uses caching to avoid hitting the database on every request.\n   * @returns Promise<AppFlags> - A map of feature flags to their enabled status\n   */\n  public async getFeatureFlagMap() {\n    const flags = await this.getAllFeatures();\n    return flags.reduce((acc, flag) => {\n      acc[flag.slug as keyof AppFlags] = flag.enabled;\n      return acc;\n    }, {} as AppFlags);\n  }\n\n  /**\n   * Gets all features enabled for a specific team in a map format.\n   * @param teamId - The ID of the team to get features for\n   * @returns Promise<{ [slug: string]: boolean } | null>\n   */\n  public async getTeamFeatures(teamId: number) {\n    const result = await this.prismaClient.teamFeatures.findMany({\n      where: {\n        teamId,\n      },\n      include: {\n        feature: {\n          select: {\n            slug: true,\n            enabled: true,\n          },\n        },\n      },\n    });\n\n    if (!result.length) return null;\n\n    const features: TeamFeatures = Object.fromEntries(\n      result.map((teamFeature) => [teamFeature.feature.slug, true])\n    ) as TeamFeatures;\n\n    return features;\n  }\n\n  /**\n   * Checks if a feature is enabled globally in the application.\n   * @param slug - The feature flag identifier to check\n   * @returns Promise<boolean> - True if the feature is enabled globally, false otherwise\n   * @throws Error if the feature flag check fails\n   */\n  async checkIfFeatureIsEnabledGlobally(\n    slug: keyof AppFlags,\n    _options: CacheOptions = { ttl: 5 * 60 * 1000 }\n  ): Promise<boolean> {\n    try {\n      const features = await this.getAllFeatures();\n      const flag = features.find((f) => f.slug === slug);\n      return Boolean(flag && flag.enabled);\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Checks if a specific user has access to a feature.\n   * Checks both direct user feature assignments and team-based feature access.\n   * @param userId - The ID of the user to check\n   * @param slug - The feature identifier to check\n   * @returns Promise<boolean> - True if the user has access to the feature, false otherwise\n   * @throws Error if the feature access check fails\n   */\n  async checkIfUserHasFeature(userId: number, slug: string) {\n    try {\n      /**\n       * findUnique was failing in prismock tests, so I'm using findFirst instead\n       * FIXME refactor when upgrading prismock\n       * https://github.com/morintd/prismock/issues/592\n       */\n      const userHasFeature = await this.prismaClient.userFeatures.findFirst({\n        where: {\n          userId,\n          featureId: slug,\n        },\n      });\n      if (userHasFeature) return true;\n      // If the user doesn't have the feature, check if they belong to a team with the feature.\n      // This also covers organizations, which are teams.\n      const userBelongsToTeamWithFeature = await this.checkIfUserBelongsToTeamWithFeature(userId, slug);\n      if (userBelongsToTeamWithFeature) return true;\n      return false;\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Checks if a specific user has access to a feature, ignoring hierarchical (parent) teams.\n   * Only checks direct user assignments and direct team memberships \u2014 does not traverse parents.\n   * @param userId - The ID of the user to check\n   * @param slug - The feature identifier to check\n   * @returns Promise<boolean> - True if the user has direct or same-level team access to the feature\n   * @throws Error if the feature access check fails\n   */\n  async checkIfUserHasFeatureNonHierarchical(userId: number, slug: string) {\n    try {\n      // Prismock limitation: findUnique may fail, use findFirst instead\n      const userHasFeature = await this.prismaClient.userFeatures.findFirst({\n        select: {\n          userId: true,\n        },\n        where: {\n          userId,\n          featureId: slug,\n        },\n      });\n      if (userHasFeature) return true;\n\n      const userBelongsToTeamWithFeature = await this.checkIfUserBelongsToTeamWithFeatureNonHierarchical(\n        userId,\n        slug\n      );\n\n      return userBelongsToTeamWithFeature;\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Private helper method to check if a user belongs to any team that has access to a feature.\n   * @param userId - The ID of the user to check\n   * @param slug - The feature identifier to check\n   * @returns Promise<boolean> - True if the user belongs to a team with the feature, false otherwise\n   * @throws Error if the team feature check fails\n   * @private\n   */\n  private async checkIfUserBelongsToTeamWithFeature(userId: number, slug: string) {\n    try {\n      const query = Prisma.sql`\n        WITH RECURSIVE TeamHierarchy AS (\n          -- Start with teams the user belongs to\n          SELECT DISTINCT t.id, t.\"parentId\",\n            CASE WHEN EXISTS (\n              SELECT 1 FROM \"TeamFeatures\" tf\n              WHERE tf.\"teamId\" = t.id AND tf.\"featureId\" = ${slug}\n            ) THEN true ELSE false END as has_feature\n          FROM \"Team\" t\n          INNER JOIN \"Membership\" m ON m.\"teamId\" = t.id\n          WHERE m.\"userId\" = ${userId} AND m.accepted = true\n\n          UNION ALL\n\n          -- Recursively get parent teams\n          SELECT DISTINCT p.id, p.\"parentId\",\n            CASE WHEN EXISTS (\n              SELECT 1 FROM \"TeamFeatures\" tf\n              WHERE tf.\"teamId\" = p.id AND tf.\"featureId\" = ${slug}\n            ) THEN true ELSE false END as has_feature\n          FROM \"Team\" p\n          INNER JOIN TeamHierarchy c ON p.id = c.\"parentId\"\n          WHERE NOT c.has_feature -- Stop recursion if we found a team with the feature\n        )\n        SELECT 1\n        FROM TeamHierarchy\n        WHERE has_feature = true\n        LIMIT 1;\n      `;\n\n      const result = await this.prismaClient.$queryRaw<unknown[]>(query);\n      return result.length > 0;\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Checks if a user belongs to any direct team that has access to a feature.\n   * This version ignores parent/child team relationships \u2014 no recursion or hierarchy traversal.\n   * @param userId - The ID of the user to check\n   * @param slug - The feature identifier to check\n   * @returns Promise<boolean> - True if the user belongs to a team with the feature (direct only)\n   * @throws Error if the query fails\n   * @private\n   */\n  private async checkIfUserBelongsToTeamWithFeatureNonHierarchical(userId: number, slug: string) {\n    try {\n      const query = Prisma.sql`\n        SELECT 1\n        FROM \"Team\" t\n        INNER JOIN \"Membership\" m ON m.\"teamId\" = t.id\n        WHERE m.\"userId\" = ${userId}\n          AND m.accepted = true\n          AND EXISTS (\n            SELECT 1\n            FROM \"TeamFeatures\" tf\n            WHERE tf.\"teamId\" = t.id\n              AND tf.\"featureId\" = ${slug}\n          )\n        LIMIT 1;\n      `;\n\n      const result = await this.prismaClient.$queryRaw<unknown[]>(query);\n      return result.length > 0;\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Enables a feature for a specific team.\n   * @param teamId - The ID of the team to enable the feature for\n   * @param featureId - The feature identifier to enable\n   * @param assignedBy - The user or what assigned the feature\n   * @returns Promise<void>\n   * @throws Error if the feature enabling fails\n   */\n  async enableFeatureForTeam(teamId: number, featureId: keyof AppFlags, assignedBy: string): Promise<void> {\n    try {\n      await this.prismaClient.teamFeatures.upsert({\n        where: {\n          teamId_featureId: {\n            teamId,\n            featureId,\n          },\n        },\n        create: {\n          teamId,\n          featureId,\n          assignedBy,\n        },\n        update: {},\n      });\n      // Clear cache when features are modified\n      this.clearCache();\n    } catch (err) {\n      captureException(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Checks if a team or any of its ancestors has access to a specific feature.\n   * Uses a recursive CTE raw SQL query for performance.\n   * @param teamId - The ID of the team to start the check from\n   * @param featureId - The feature identifier to check\n   * @returns Promise<boolean> - True if the team or any ancestor has the feature, false otherwise\n   * @throws Error if the database query fails\n   */\n  async checkIfTeamHasFeature(teamId: number, featureId: keyof AppFlags): Promise<boolean> {\n    try {\n      // Early return if team has feature directly assigned\n      const teamHasFeature = await this.prismaClient.teamFeatures.findUnique({\n        where: {\n          teamId_featureId: {\n            teamId,\n            featureId,\n          },\n        },\n      });\n      if (teamHasFeature) return true;\n\n      const query = Prisma.sql`\n        WITH RECURSIVE TeamHierarchy AS (\n          -- Start with the initial team\n          SELECT id, \"parentId\",\n            CASE WHEN EXISTS (\n              SELECT 1 FROM \"TeamFeatures\" tf\n              WHERE tf.\"teamId\" = id AND tf.\"featureId\" = ${featureId}\n            ) THEN true ELSE false END as has_feature\n          FROM \"Team\"\n          WHERE id = ${teamId}\n\n          UNION ALL\n\n          -- Recursively get parent teams\n          SELECT p.id, p.\"parentId\",\n            CASE WHEN EXISTS (\n              SELECT 1 FROM \"TeamFeatures\" tf\n              WHERE tf.\"teamId\" = p.id AND tf.\"featureId\" = ${featureId}\n            ) THEN true ELSE false END as has_feature\n          FROM \"Team\" p\n          INNER JOIN TeamHierarchy c ON p.id = c.\"parentId\"\n          WHERE NOT c.has_feature -- Stop recursion if we found a team with the feature\n        )\n        SELECT 1\n        FROM TeamHierarchy\n        WHERE has_feature = true\n        LIMIT 1;\n      `;\n\n      const result = await this.prismaClient.$queryRaw<unknown[]>(query);\n      return result.length > 0;\n    } catch (err) {\n      captureException(err);\n      console.error(\n        `Recursive feature check failed for team ${teamId}, feature ${featureId}:`,\n        err instanceof Error ? err.message : err\n      );\n      throw err;\n    }\n  }\n}",
            "cost": 0.10653500000000002
        },
        "calcom__cal.com.main/packages/lib/server/repository/SelectedCalendarRepository.interface.ts": {
            "output": "import type { Prisma, SelectedCalendar } from \"@calcom/prisma/client\";\n\nexport interface ISelectedCalendarRepository {\n  /**\n   * Find selected calendar by id\n   *\n   * @param id\n   */\n  findById(id: string): Promise<SelectedCalendar | null>;\n\n  /**\n   * Find selected calendar by channel id\n   *\n   * @param channelId\n   */\n  findByChannelId(channelId: string): Promise<SelectedCalendar | null>;\n\n  /**\n   *  Find next batch of selected calendars\n   *  Will check if syncSubscribedAt is null or channelExpiration is greater than current date\n   *\n   * @param take the number of calendars to take\n   * @param integrations the list of integrations\n   */\n  findNextSubscriptionBatch({\n    take,\n    integrations,\n  }: {\n    take: number;\n    integrations?: string[];\n  }): Promise<SelectedCalendar[]>;\n\n  /**\n   * Update status of sync for selected calendar\n   *\n   * @param id\n   * @param data\n   */\n  updateSyncStatus(\n    id: string,\n    data: Pick<\n      Prisma.SelectedCalendarUpdateInput,\n      \"syncToken\" | \"syncedAt\" | \"syncErrorAt\" | \"syncErrorCount\"\n    >\n  ): Promise<SelectedCalendar>;\n\n  /**\n   * Update subscription status for selected calendar\n   */\n  updateSubscription(\n    id: string,\n    data: Pick<\n      Prisma.SelectedCalendarUpdateInput,\n      | \"channelId\"\n      | \"channelResourceId\"\n      | \"channelResourceUri\"\n      | \"channelKind\"\n      | \"channelExpiration\"\n      | \"syncSubscribedAt\"\n    >\n  ): Promise<SelectedCalendar>;\n}",
            "output_extracted": "import type { Prisma, SelectedCalendar } from \"@calcom/prisma/client\";\n\nexport interface ISelectedCalendarRepository {\n  /**\n   * Find selected calendar by id\n   *\n   * @param id\n   */\n  findById(id: string): Promise<SelectedCalendar | null>;\n\n  /**\n   * Find selected calendar by channel id\n   *\n   * @param channelId\n   */\n  findByChannelId(channelId: string): Promise<SelectedCalendar | null>;\n\n  /**\n   *  Find next batch of selected calendars\n   *  Will check if syncSubscribedAt is null or channelExpiration is greater than current date\n   *\n   * @param take the number of calendars to take\n   * @param integrations the list of integrations\n   */\n  findNextSubscriptionBatch({\n    take,\n    integrations,\n  }: {\n    take: number;\n    integrations?: string[];\n  }): Promise<SelectedCalendar[]>;\n\n  /**\n   * Update status of sync for selected calendar\n   *\n   * @param id\n   * @param data\n   */\n  updateSyncStatus(\n    id: string,\n    data: Pick<\n      Prisma.SelectedCalendarUpdateInput,\n      \"syncToken\" | \"syncedAt\" | \"syncErrorAt\" | \"syncErrorCount\"\n    >\n  ): Promise<SelectedCalendar>;\n\n  /**\n   * Update subscription status for selected calendar\n   */\n  updateSubscription(\n    id: string,\n    data: Pick<\n      Prisma.SelectedCalendarUpdateInput,\n      | \"channelId\"\n      | \"channelResourceId\"\n      | \"channelResourceUri\"\n      | \"channelKind\"\n      | \"channelExpiration\"\n      | \"syncSubscribedAt\"\n    >\n  ): Promise<SelectedCalendar>;\n}",
            "cost": 0.01856
        },
        "calcom__cal.com.main/packages/lib/server/repository/SelectedCalendarRepository.ts": {
            "output": "import type { ISelectedCalendarRepository } from \"@calcom/lib/server/repository/SelectedCalendarRepository.interface\";\nimport type { PrismaClient } from \"@calcom/prisma\";\nimport type { Prisma } from \"@calcom/prisma/client\";\n\nexport class SelectedCalendarRepository implements ISelectedCalendarRepository {\n  constructor(private prismaClient: PrismaClient) {}\n\n  async findById(id: string) {\n    return this.prismaClient.selectedCalendar.findUnique({\n      where: { id },\n    });\n  }\n\n  async findByChannelId(channelId: string) {\n    return this.prismaClient.selectedCalendar.findFirst({ where: { channelId } });\n  }\n\n  async findNextSubscriptionBatch({ take, integrations }: { take: number; integrations: string[] }) {\n    return this.prismaClient.selectedCalendar.findMany({\n      where: {\n        integration: { in: integrations },\n        OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: new Date() } }],\n        // initially we will run subscription only for teams that have\n        // the feature flags enabled and it should be removed later\n        user: {\n          teams: {\n            some: {\n              team: {\n                features: {\n                  some: {\n                    OR: [\n                      { featureId: \"calendar-subscription-cache\" },\n                      { featureId: \"calendar-subscription-sync\" },\n                    ],\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      take,\n    });\n  }\n\n  async updateSyncStatus(\n    id: string,\n    data: Pick<\n      Prisma.SelectedCalendarUpdateInput,\n      \"syncToken\" | \"syncedAt\" | \"syncErrorAt\" | \"syncErrorCount\"\n    >\n  ) {\n    return this.prismaClient.selectedCalendar.update({\n      where: { id },\n      data,\n    });\n  }\n\n  async updateSubscription(\n    id: string,\n    data: Pick<\n      Prisma.SelectedCalendarUpdateInput,\n      | \"channelId\"\n      | \"channelResourceId\"\n      | \"channelResourceUri\"\n      | \"channelKind\"\n      | \"channelExpiration\"\n      | \"syncSubscribedAt\"\n    >\n  ) {\n    return this.prismaClient.selectedCalendar.update({\n      where: { id },\n      data,\n    });\n  }\n}",
            "output_extracted": "import type { ISelectedCalendarRepository } from \"@calcom/lib/server/repository/SelectedCalendarRepository.interface\";\nimport type { PrismaClient } from \"@calcom/prisma\";\nimport type { Prisma } from \"@calcom/prisma/client\";\n\nexport class SelectedCalendarRepository implements ISelectedCalendarRepository {\n  constructor(private prismaClient: PrismaClient) {}\n\n  async findById(id: string) {\n    return this.prismaClient.selectedCalendar.findUnique({\n      where: { id },\n    });\n  }\n\n  async findByChannelId(channelId: string) {\n    return this.prismaClient.selectedCalendar.findFirst({ where: { channelId } });\n  }\n\n  async findNextSubscriptionBatch({ take, integrations }: { take: number; integrations: string[] }) {\n    return this.prismaClient.selectedCalendar.findMany({\n      where: {\n        integration: { in: integrations },\n        OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: new Date() } }],\n        // initially we will run subscription only for teams that have\n        // the feature flags enabled and it should be removed later\n        user: {\n          teams: {\n            some: {\n              team: {\n                features: {\n                  some: {\n                    OR: [\n                      { featureId: \"calendar-subscription-cache\" },\n                      { featureId: \"calendar-subscription-sync\" },\n                    ],\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      take,\n    });\n  }\n\n  async updateSyncStatus(\n    id: string,\n    data: Pick<\n      Prisma.SelectedCalendarUpdateInput,\n      \"syncToken\" | \"syncedAt\" | \"syncErrorAt\" | \"syncErrorCount\"\n    >\n  ) {\n    return this.prismaClient.selectedCalendar.update({\n      where: { id },\n      data,\n    });\n  }\n\n  async updateSubscription(\n    id: string,\n    data: Pick<\n      Prisma.SelectedCalendarUpdateInput,\n      | \"channelId\"\n      | \"channelResourceId\"\n      | \"channelResourceUri\"\n      | \"channelKind\"\n      | \"channelExpiration\"\n      | \"syncSubscribedAt\"\n    >\n  ) {\n    return this.prismaClient.selectedCalendar.update({\n      where: { id },\n      data,\n    });\n  }\n}",
            "cost": 0.024470000000000002
        },
        "calcom__cal.com.main/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts": {
            "output": "import { describe, test, expect, vi, beforeEach } from \"vitest\";\n\nimport type { PrismaClient } from \"@calcom/prisma\";\nimport type { Prisma, SelectedCalendar } from \"@calcom/prisma/client\";\n\nimport { SelectedCalendarRepository } from \"../SelectedCalendarRepository\";\n\nconst mockPrismaClient = {\n  selectedCalendar: {\n    findUnique: vi.fn(),\n    findFirst: vi.fn(),\n    findMany: vi.fn(),\n    update: vi.fn(),\n  },\n} as unknown as PrismaClient;\n\nconst mockSelectedCalendar: SelectedCalendar = {\n  id: \"test-calendar-id\",\n  userId: 1,\n  credentialId: 1,\n  integration: \"google_calendar\",\n  externalId: \"test@example.com\",\n  eventTypeId: null,\n  delegationCredentialId: null,\n  domainWideDelegationCredentialId: null,\n  googleChannelId: null,\n  googleChannelKind: null,\n  googleChannelResourceId: null,\n  googleChannelResourceUri: null,\n  googleChannelExpiration: null,\n  error: null,\n  lastErrorAt: null,\n  watchAttempts: 0,\n  maxAttempts: 3,\n  unwatchAttempts: 0,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n  channelId: \"test-channel-id\",\n  channelKind: \"web_hook\",\n  channelResourceId: \"test-resource-id\",\n  channelResourceUri: \"test-resource-uri\",\n  channelExpiration: new Date(Date.now() + 86400000),\n  syncSubscribedAt: new Date(),\n  syncToken: \"test-sync-token\",\n  syncedAt: new Date(),\n  syncErrorAt: null,\n  syncErrorCount: 0,\n};\n\ndescribe(\"SelectedCalendarRepository\", () => {\n  let repository: SelectedCalendarRepository;\n\n  beforeEach(() => {\n    repository = new SelectedCalendarRepository(mockPrismaClient);\n    vi.clearAllMocks();\n  });\n\n  describe(\"findById\", () => {\n    test(\"should find selected calendar by id with credential delegation\", async () => {\n      const mockCalendarWithCredential = {\n        ...mockSelectedCalendar,\n        credential: {\n          delegationCredential: {\n            id: \"delegation-id\",\n            key: { client_email: \"test@service.com\" },\n          },\n        },\n      };\n\n      vi.mocked(mockPrismaClient.selectedCalendar.findUnique).mockResolvedValue(mockCalendarWithCredential);\n\n      const result = await repository.findById(\"test-calendar-id\");\n\n      expect(mockPrismaClient.selectedCalendar.findUnique).toHaveBeenCalledWith({\n        where: { id: \"test-calendar-id\" },\n      });\n\n      expect(result).toEqual(mockCalendarWithCredential);\n    });\n\n    test(\"should return null when calendar not found\", async () => {\n      vi.mocked(mockPrismaClient.selectedCalendar.findUnique).mockResolvedValue(null);\n\n      const result = await repository.findById(\"non-existent-id\");\n\n      expect(result).toBeNull();\n    });\n  });\n\n  describe(\"findByChannelId\", () => {\n    test(\"should find selected calendar by channel id\", async () => {\n      vi.mocked(mockPrismaClient.selectedCalendar.findFirst).mockResolvedValue(mockSelectedCalendar);\n\n      const result = await repository.findByChannelId(\"test-channel-id\");\n\n      expect(mockPrismaClient.selectedCalendar.findFirst).toHaveBeenCalledWith({\n        where: { channelId: \"test-channel-id\" },\n      });\n\n      expect(result).toEqual(mockSelectedCalendar);\n    });\n\n    test(\"should return null when calendar not found\", async () => {\n      vi.mocked(mockPrismaClient.selectedCalendar.findFirst).mockResolvedValue(null);\n\n      const result = await repository.findByChannelId(\"non-existent-channel-id\");\n\n      expect(result).toBeNull();\n    });\n  });\n\n  describe(\"findNextSubscriptionBatch\", () => {\n    test(\"should find next batch of calendars for subscription\", async () => {\n      const mockCalendars = [mockSelectedCalendar];\n      vi.mocked(mockPrismaClient.selectedCalendar.findMany).mockResolvedValue(mockCalendars);\n\n      const result = await repository.findNextSubscriptionBatch({\n        take: 10,\n        integrations: [\"google_calendar\", \"office365_calendar\"],\n      });\n\n      expect(mockPrismaClient.selectedCalendar.findMany).toHaveBeenCalledWith({\n        where: {\n          integration: { in: [\"google_calendar\", \"office365_calendar\"] },\n          OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: expect.any(Date) } }],\n          user: {\n            teams: {\n              some: {\n                team: {\n                  features: {\n                    some: {\n                      OR: [\n                        { featureId: \"calendar-subscription-cache\" },\n                        { featureId: \"calendar-subscription-sync\" },\n                      ],\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n        take: 10,\n      });\n\n      expect(result).toEqual(mockCalendars);\n    });\n\n    test(\"should handle empty integrations array\", async () => {\n      const mockCalendars = [mockSelectedCalendar];\n      vi.mocked(mockPrismaClient.selectedCalendar.findMany).mockResolvedValue(mockCalendars);\n\n      const result = await repository.findNextSubscriptionBatch({\n        take: 5,\n        integrations: [],\n      });\n\n      expect(mockPrismaClient.selectedCalendar.findMany).toHaveBeenCalledWith({\n        where: {\n          integration: { in: [] },\n          OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: expect.any(Date) } }],\n          user: {\n            teams: {\n              some: {\n                team: {\n                  features: {\n                    some: {\n                      OR: [\n                        { featureId: \"calendar-subscription-cache\" },\n                        { featureId: \"calendar-subscription-sync\" },\n                      ],\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n        take: 5,\n      });\n\n      expect(result).toEqual(mockCalendars);\n    });\n  });\n\n  describe(\"updateSyncStatus\", () => {\n    test(\"should update sync status\", async () => {\n      const updateData: Pick<\n        Prisma.SelectedCalendarUpdateInput,\n        \"syncToken\" | \"syncedAt\" | \"syncErrorAt\" | \"syncErrorCount\"\n      > = {\n        syncToken: \"new-sync-token\",\n        syncedAt: new Date(),\n        syncErrorAt: null,\n        syncErrorCount: 0,\n      };\n\n      const updatedCalendar = {\n        ...mockSelectedCalendar,\n        ...updateData,\n      };\n\n      vi.mocked(mockPrismaClient.selectedCalendar.update).mockResolvedValue(updatedCalendar);\n\n      const result = await repository.updateSyncStatus(\"test-calendar-id\", updateData);\n\n      expect(mockPrismaClient.selectedCalendar.update).toHaveBeenCalledWith({\n        where: { id: \"test-calendar-id\" },\n        data: updateData,\n      });\n\n      expect(result).toEqual(updatedCalendar);\n    });\n\n    test(\"should update sync error status\", async () => {\n      const updateData: Pick<\n        Prisma.SelectedCalendarUpdateInput,\n        \"syncToken\" | \"syncedAt\" | \"syncErrorAt\" | \"syncErrorCount\"\n      > = {\n        syncErrorAt: new Date(),\n        syncErrorCount: 1,\n      };\n\n      const updatedCalendar = {\n        ...mockSelectedCalendar,\n        ...updateData,\n      };\n\n      vi.mocked(mockPrismaClient.selectedCalendar.update).mockResolvedValue(updatedCalendar);\n\n      const result = await repository.updateSyncStatus(\"test-calendar-id\", updateData);\n\n      expect(mockPrismaClient.selectedCalendar.update).toHaveBeenCalledWith({\n        where: { id: \"test-calendar-id\" },\n        data: updateData,\n      });\n\n      expect(result).toEqual(updatedCalendar);\n    });\n  });\n\n  describe(\"updateSubscription\", () => {\n    test(\"should update subscription status\", async () => {\n      const updateData: Pick<\n        Prisma.SelectedCalendarUpdateInput,\n        | \"channelId\"\n        | \"channelResourceId\"\n        | \"channelResourceUri\"\n        | \"channelKind\"\n        | \"channelExpiration\"\n        | \"syncSubscribedAt\"\n      > = {\n        channelId: \"new-channel-id\",\n        channelResourceId: \"new-resource-id\",\n        channelResourceUri: \"new-resource-uri\",\n        channelKind: \"web_hook\",\n        channelExpiration: new Date(Date.now() + 86400000),\n        syncSubscribedAt: new Date(),\n      };\n\n      const updatedCalendar = {\n        ...mockSelectedCalendar,\n        ...updateData,\n      };\n\n      vi.mocked(mockPrismaClient.selectedCalendar.update).mockResolvedValue(updatedCalendar);\n\n      const result = await repository.updateSubscription(\"test-calendar-id\", updateData);\n\n      expect(mockPrismaClient.selectedCalendar.update).toHaveBeenCalledWith({\n        where: { id: \"test-calendar-id\" },\n        data: updateData,\n      });\n\n      expect(result).toEqual(updatedCalendar);\n    });\n\n    test(\"should unsubscribe by setting syncSubscribedAt to null\", async () => {\n      const updateData: Pick<\n        Prisma.SelectedCalendarUpdateInput,\n        | \"channelId\"\n        | \"channelResourceId\"\n        | \"channelResourceUri\"\n        | \"channelKind\"\n        | \"channelExpiration\"\n        | \"syncSubscribedAt\"\n      > = {\n        syncSubscribedAt: null,\n      };\n\n      const updatedCalendar = {\n        ...mockSelectedCalendar,\n        syncSubscribedAt: null,\n      };\n\n      vi.mocked(mockPrismaClient.selectedCalendar.update).mockResolvedValue(updatedCalendar);\n\n      const result = await repository.updateSubscription(\"test-calendar-id\", updateData);\n\n      expect(mockPrismaClient.selectedCalendar.update).toHaveBeenCalledWith({\n        where: { id: \"test-calendar-id\" },\n        data: updateData,\n      });\n\n      expect(result).toEqual(updatedCalendar);\n    });\n  });\n});",
            "output_extracted": "import { describe, test, expect, vi, beforeEach } from \"vitest\";\n\nimport type { PrismaClient } from \"@calcom/prisma\";\nimport type { Prisma, SelectedCalendar } from \"@calcom/prisma/client\";\n\nimport { SelectedCalendarRepository } from \"../SelectedCalendarRepository\";\n\nconst mockPrismaClient = {\n  selectedCalendar: {\n    findUnique: vi.fn(),\n    findFirst: vi.fn(),\n    findMany: vi.fn(),\n    update: vi.fn(),\n  },\n} as unknown as PrismaClient;\n\nconst mockSelectedCalendar: SelectedCalendar = {\n  id: \"test-calendar-id\",\n  userId: 1,\n  credentialId: 1,\n  integration: \"google_calendar\",\n  externalId: \"test@example.com\",\n  eventTypeId: null,\n  delegationCredentialId: null,\n  domainWideDelegationCredentialId: null,\n  googleChannelId: null,\n  googleChannelKind: null,\n  googleChannelResourceId: null,\n  googleChannelResourceUri: null,\n  googleChannelExpiration: null,\n  error: null,\n  lastErrorAt: null,\n  watchAttempts: 0,\n  maxAttempts: 3,\n  unwatchAttempts: 0,\n  createdAt: new Date(),\n  updatedAt: new Date(),\n  channelId: \"test-channel-id\",\n  channelKind: \"web_hook\",\n  channelResourceId: \"test-resource-id\",\n  channelResourceUri: \"test-resource-uri\",\n  channelExpiration: new Date(Date.now() + 86400000),\n  syncSubscribedAt: new Date(),\n  syncToken: \"test-sync-token\",\n  syncedAt: new Date(),\n  syncErrorAt: null,\n  syncErrorCount: 0,\n};\n\ndescribe(\"SelectedCalendarRepository\", () => {\n  let repository: SelectedCalendarRepository;\n\n  beforeEach(() => {\n    repository = new SelectedCalendarRepository(mockPrismaClient);\n    vi.clearAllMocks();\n  });\n\n  describe(\"findById\", () => {\n    test(\"should find selected calendar by id with credential delegation\", async () => {\n      const mockCalendarWithCredential = {\n        ...mockSelectedCalendar,\n        credential: {\n          delegationCredential: {\n            id: \"delegation-id\",\n            key: { client_email: \"test@service.com\" },\n          },\n        },\n      };\n\n      vi.mocked(mockPrismaClient.selectedCalendar.findUnique).mockResolvedValue(mockCalendarWithCredential);\n\n      const result = await repository.findById(\"test-calendar-id\");\n\n      expect(mockPrismaClient.selectedCalendar.findUnique).toHaveBeenCalledWith({\n        where: { id: \"test-calendar-id\" },\n      });\n\n      expect(result).toEqual(mockCalendarWithCredential);\n    });\n\n    test(\"should return null when calendar not found\", async () => {\n      vi.mocked(mockPrismaClient.selectedCalendar.findUnique).mockResolvedValue(null);\n\n      const result = await repository.findById(\"non-existent-id\");\n\n      expect(result).toBeNull();\n    });\n  });\n\n  describe(\"findByChannelId\", () => {\n    test(\"should find selected calendar by channel id\", async () => {\n      vi.mocked(mockPrismaClient.selectedCalendar.findFirst).mockResolvedValue(mockSelectedCalendar);\n\n      const result = await repository.findByChannelId(\"test-channel-id\");\n\n      expect(mockPrismaClient.selectedCalendar.findFirst).toHaveBeenCalledWith({\n        where: { channelId: \"test-channel-id\" },\n      });\n\n      expect(result).toEqual(mockSelectedCalendar);\n    });\n\n    test(\"should return null when calendar not found\", async () => {\n      vi.mocked(mockPrismaClient.selectedCalendar.findFirst).mockResolvedValue(null);\n\n      const result = await repository.findByChannelId(\"non-existent-channel-id\");\n\n      expect(result).toBeNull();\n    });\n  });\n\n  describe(\"findNextSubscriptionBatch\", () => {\n    test(\"should find next batch of calendars for subscription\", async () => {\n      const mockCalendars = [mockSelectedCalendar];\n      vi.mocked(mockPrismaClient.selectedCalendar.findMany).mockResolvedValue(mockCalendars);\n\n      const result = await repository.findNextSubscriptionBatch({\n        take: 10,\n        integrations: [\"google_calendar\", \"office365_calendar\"],\n      });\n\n      expect(mockPrismaClient.selectedCalendar.findMany).toHaveBeenCalledWith({\n        where: {\n          integration: { in: [\"google_calendar\", \"office365_calendar\"] },\n          OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: expect.any(Date) } }],\n          user: {\n            teams: {\n              some: {\n                team: {\n                  features: {\n                    some: {\n                      OR: [\n                        { featureId: \"calendar-subscription-cache\" },\n                        { featureId: \"calendar-subscription-sync\" },\n                      ],\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n        take: 10,\n      });\n\n      expect(result).toEqual(mockCalendars);\n    });\n\n    test(\"should handle empty integrations array\", async () => {\n      const mockCalendars = [mockSelectedCalendar];\n      vi.mocked(mockPrismaClient.selectedCalendar.findMany).mockResolvedValue(mockCalendars);\n\n      const result = await repository.findNextSubscriptionBatch({\n        take: 5,\n        integrations: [],\n      });\n\n      expect(mockPrismaClient.selectedCalendar.findMany).toHaveBeenCalledWith({\n        where: {\n          integration: { in: [] },\n          OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: expect.any(Date) } }],\n          user: {\n            teams: {\n              some: {\n                team: {\n                  features: {\n                    some: {\n                      OR: [\n                        { featureId: \"calendar-subscription-cache\" },\n                        { featureId: \"calendar-subscription-sync\" },\n                      ],\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n        take: 5,\n      });\n\n      expect(result).toEqual(mockCalendars);\n    });\n  });\n\n  describe(\"updateSyncStatus\", () => {\n    test(\"should update sync status\", async () => {\n      const updateData: Pick<\n        Prisma.SelectedCalendarUpdateInput,\n        \"syncToken\" | \"syncedAt\" | \"syncErrorAt\" | \"syncErrorCount\"\n      > = {\n        syncToken: \"new-sync-token\",\n        syncedAt: new Date(),\n        syncErrorAt: null,\n        syncErrorCount: 0,\n      };\n\n      const updatedCalendar = {\n        ...mockSelectedCalendar,\n        ...updateData,\n      };\n\n      vi.mocked(mockPrismaClient.selectedCalendar.update).mockResolvedValue(updatedCalendar);\n\n      const result = await repository.updateSyncStatus(\"test-calendar-id\", updateData);\n\n      expect(mockPrismaClient.selectedCalendar.update).toHaveBeenCalledWith({\n        where: { id: \"test-calendar-id\" },\n        data: updateData,\n      });\n\n      expect(result).toEqual(updatedCalendar);\n    });\n\n    test(\"should update sync error status\", async () => {\n      const updateData: Pick<\n        Prisma.SelectedCalendarUpdateInput,\n        \"syncToken\" | \"syncedAt\" | \"syncErrorAt\" | \"syncErrorCount\"\n      > = {\n        syncErrorAt: new Date(),\n        syncErrorCount: 1,\n      };\n\n      const updatedCalendar = {\n        ...mockSelectedCalendar,\n        ...updateData,\n      };\n\n      vi.mocked(mockPrismaClient.selectedCalendar.update).mockResolvedValue(updatedCalendar);\n\n      const result = await repository.updateSyncStatus(\"test-calendar-id\", updateData);\n\n      expect(mockPrismaClient.selectedCalendar.update).toHaveBeenCalledWith({\n        where: { id: \"test-calendar-id\" },\n        data: updateData,\n      });\n\n      expect(result).toEqual(updatedCalendar);\n    });\n  });\n\n  describe(\"updateSubscription\", () => {\n    test(\"should update subscription status\", async () => {\n      const updateData: Pick<\n        Prisma.SelectedCalendarUpdateInput,\n        | \"channelId\"\n        | \"channelResourceId\"\n        | \"channelResourceUri\"\n        | \"channelKind\"\n        | \"channelExpiration\"\n        | \"syncSubscribedAt\"\n      > = {\n        channelId: \"new-channel-id\",\n        channelResourceId: \"new-resource-id\",\n        channelResourceUri: \"new-resource-uri\",\n        channelKind: \"web_hook\",\n        channelExpiration: new Date(Date.now() + 86400000),\n        syncSubscribedAt: new Date(),\n      };\n\n      const updatedCalendar = {\n        ...mockSelectedCalendar,\n        ...updateData,\n      };\n\n      vi.mocked(mockPrismaClient.selectedCalendar.update).mockResolvedValue(updatedCalendar);\n\n      const result = await repository.updateSubscription(\"test-calendar-id\", updateData);\n\n      expect(mockPrismaClient.selectedCalendar.update).toHaveBeenCalledWith({\n        where: { id: \"test-calendar-id\" },\n        data: updateData,\n      });\n\n      expect(result).toEqual(updatedCalendar);\n    });\n\n    test(\"should unsubscribe by setting syncSubscribedAt to null\", async () => {\n      const updateData: Pick<\n        Prisma.SelectedCalendarUpdateInput,\n        | \"channelId\"\n        | \"channelResourceId\"\n        | \"channelResourceUri\"\n        | \"channelKind\"\n        | \"channelExpiration\"\n        | \"syncSubscribedAt\"\n      > = {\n        syncSubscribedAt: null,\n      };\n\n      const updatedCalendar = {\n        ...mockSelectedCalendar,\n        syncSubscribedAt: null,\n      };\n\n      vi.mocked(mockPrismaClient.selectedCalendar.update).mockResolvedValue(updatedCalendar);\n\n      const result = await repository.updateSubscription(\"test-calendar-id\", updateData);\n\n      expect(mockPrismaClient.selectedCalendar.update).toHaveBeenCalledWith({\n        where: { id: \"test-calendar-id\" },\n        data: updateData,\n      });\n\n      expect(result).toEqual(updatedCalendar);\n    });\n  });\n});",
            "cost": 0.09335500000000001
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25502",
        "repo": "calcom/cal.com",
        "base_commit": "41ad0f718dcda69d502b28302571741470672e05",
        "head_commit": "070a3394c1a4f735733164948fdea265d9445b57",
        "title": "perf: Calendar Cache Improvements",
        "merged_at": "2025-12-02T11:11:52Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25502",
        "test_files": [
            "packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts",
            "packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts"
        ],
        "code_files": [
            "packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts",
            "packages/features/flags/features.repository.interface.ts",
            "packages/features/flags/features.repository.ts",
            "packages/lib/server/repository/SelectedCalendarRepository.interface.ts",
            "packages/lib/server/repository/SelectedCalendarRepository.ts"
        ],
        "total_changes": 192,
        "num_files": 7,
        "pull_number": 25502,
        "patch": "diff --git a/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts b/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts\nindex 236a718392a33d..6dfc3ae7031e8d 100644\n--- a/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts\n+++ b/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts\n@@ -12,7 +12,7 @@ import type { CalendarSyncService } from \"@calcom/features/calendar-subscription\n import type { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\n import logger from \"@calcom/lib/logger\";\n import type { ISelectedCalendarRepository } from \"@calcom/lib/server/repository/SelectedCalendarRepository.interface\";\n-import { SelectedCalendar } from \"@calcom/prisma/client\";\n+import type { SelectedCalendar } from \"@calcom/prisma/client\";\n \n const log = logger.getSubLogger({ prefix: [\"CalendarSubscriptionService\"] });\n \n@@ -204,9 +204,14 @@ export class CalendarSubscriptionService {\n    * Subscribe periodically to new calendars\n    */\n   async checkForNewSubscriptions() {\n+    const teamIds = await this.deps.featuresRepository.getTeamsWithFeatureEnabled(\n+      CalendarSubscriptionService.CALENDAR_SUBSCRIPTION_CACHE_FEATURE\n+    );\n+\n     const rows = await this.deps.selectedCalendarRepository.findNextSubscriptionBatch({\n       take: 100,\n       integrations: this.deps.adapterFactory.getProviders(),\n+      teamIds,\n     });\n     log.debug(\"checkForNewSubscriptions\", { count: rows.length });\n     await Promise.allSettled(rows.map(({ id }) => this.subscribe(id)));\ndiff --git a/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts b/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts\nindex a1081a2b1aaa3c..459b870a568b71 100644\n--- a/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts\n+++ b/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts\n@@ -125,6 +125,8 @@ describe(\"CalendarSubscriptionService\", () => {\n     mockFeaturesRepository = {\n       checkIfFeatureIsEnabledGlobally: vi.fn().mockResolvedValue(true),\n       checkIfUserHasFeature: vi.fn().mockResolvedValue(true),\n+      checkIfTeamHasFeature: vi.fn().mockResolvedValue(true),\n+      getTeamsWithFeatureEnabled: vi.fn().mockResolvedValue([1, 2, 3]),\n     };\n \n     mockCalendarCacheEventService = {\n@@ -376,12 +378,94 @@ describe(\"CalendarSubscriptionService\", () => {\n \n       await service.checkForNewSubscriptions();\n \n+      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n+        \"calendar-subscription-cache\"\n+      );\n       expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n         take: 100,\n         integrations: [\"google_calendar\", \"office365_calendar\"],\n+        teamIds: [1, 2, 3],\n       });\n       expect(subscribeSpy).toHaveBeenCalledWith(mockSelectedCalendar.id);\n     });\n+\n+    test(\"should handle mixed cache scenario where some teams have cache enabled and some do not\", async () => {\n+      const calendarWithCache = { ...mockSelectedCalendar, id: \"calendar-with-cache\", userId: 1 };\n+      const calendarWithCache2 = { ...mockSelectedCalendar, id: \"calendar-with-cache-2\", userId: 2 };\n+\n+      mockFeaturesRepository.getTeamsWithFeatureEnabled.mockResolvedValue([10, 20]);\n+\n+      mockSelectedCalendarRepository.findNextSubscriptionBatch.mockResolvedValue([\n+        calendarWithCache,\n+        calendarWithCache2,\n+      ]);\n+\n+      const subscribeSpy = vi.spyOn(service, \"subscribe\").mockResolvedValue(undefined);\n+\n+      await service.checkForNewSubscriptions();\n+\n+      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n+        \"calendar-subscription-cache\"\n+      );\n+      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n+        take: 100,\n+        integrations: [\"google_calendar\", \"office365_calendar\"],\n+        teamIds: [10, 20],\n+      });\n+      expect(subscribeSpy).toHaveBeenCalledTimes(2);\n+      expect(subscribeSpy).toHaveBeenCalledWith(\"calendar-with-cache\");\n+      expect(subscribeSpy).toHaveBeenCalledWith(\"calendar-with-cache-2\");\n+    });\n+\n+    test(\"should only fetch calendars for teams with feature enabled, not entire organization hierarchy\", async () => {\n+      const teamId = 100;\n+      const parentOrgId = 1;\n+\n+      mockFeaturesRepository.getTeamsWithFeatureEnabled.mockResolvedValue([teamId]);\n+\n+      const calendarForTeamMember = { ...mockSelectedCalendar, id: \"team-member-calendar\", userId: 5 };\n+      mockSelectedCalendarRepository.findNextSubscriptionBatch.mockResolvedValue([calendarForTeamMember]);\n+\n+      const subscribeSpy = vi.spyOn(service, \"subscribe\").mockResolvedValue(undefined);\n+\n+      await service.checkForNewSubscriptions();\n+\n+      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n+        \"calendar-subscription-cache\"\n+      );\n+      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n+        take: 100,\n+        integrations: [\"google_calendar\", \"office365_calendar\"],\n+        teamIds: [teamId],\n+      });\n+      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).not.toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teamIds: expect.arrayContaining([parentOrgId]),\n+        })\n+      );\n+      expect(subscribeSpy).toHaveBeenCalledTimes(1);\n+      expect(subscribeSpy).toHaveBeenCalledWith(\"team-member-calendar\");\n+    });\n+\n+    test(\"should not process any calendars when no teams have the feature enabled\", async () => {\n+      mockFeaturesRepository.getTeamsWithFeatureEnabled.mockResolvedValue([]);\n+\n+      mockSelectedCalendarRepository.findNextSubscriptionBatch.mockResolvedValue([]);\n+\n+      const subscribeSpy = vi.spyOn(service, \"subscribe\").mockResolvedValue(undefined);\n+\n+      await service.checkForNewSubscriptions();\n+\n+      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n+        \"calendar-subscription-cache\"\n+      );\n+      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n+        take: 100,\n+        integrations: [\"google_calendar\", \"office365_calendar\"],\n+        teamIds: [],\n+      });\n+      expect(subscribeSpy).not.toHaveBeenCalled();\n+    });\n   });\n \n   describe(\"feature flag methods\", () => {\ndiff --git a/packages/features/flags/features.repository.interface.ts b/packages/features/flags/features.repository.interface.ts\nindex 60fa9a7f9d1e16..782714d4d9284d 100644\n--- a/packages/features/flags/features.repository.interface.ts\n+++ b/packages/features/flags/features.repository.interface.ts\n@@ -4,4 +4,5 @@ export interface IFeaturesRepository {\n   checkIfFeatureIsEnabledGlobally(slug: keyof AppFlags): Promise<boolean>;\n   checkIfUserHasFeature(userId: number, slug: string): Promise<boolean>;\n   checkIfTeamHasFeature(teamId: number, slug: keyof AppFlags): Promise<boolean>;\n+  getTeamsWithFeatureEnabled(slug: keyof AppFlags): Promise<number[]>;\n }\ndiff --git a/packages/features/flags/features.repository.ts b/packages/features/flags/features.repository.ts\nindex b6df40504e82c0..48e3bd010470b6 100644\n--- a/packages/features/flags/features.repository.ts\n+++ b/packages/features/flags/features.repository.ts\n@@ -351,4 +351,23 @@ export class FeaturesRepository implements IFeaturesRepository {\n       throw err;\n     }\n   }\n+\n+  async getTeamsWithFeatureEnabled(slug: keyof AppFlags): Promise<number[]> {\n+    try {\n+      // If globally disabled, treat as effectively disabled everywhere\n+      const isGloballyEnabled = await this.checkIfFeatureIsEnabledGlobally(slug);\n+      if (!isGloballyEnabled) return [];\n+\n+      const rows = await this.prismaClient.teamFeatures.findMany({\n+        where: { featureId: slug },\n+        select: { teamId: true },\n+        orderBy: { teamId: \"asc\" },\n+      });\n+\n+      return rows.map((r) => r.teamId);\n+    } catch (err) {\n+      captureException(err);\n+      throw err;\n+    }\n+  }\n }\ndiff --git a/packages/lib/server/repository/SelectedCalendarRepository.interface.ts b/packages/lib/server/repository/SelectedCalendarRepository.interface.ts\nindex 55b49b7b5ecebd..2d119385175042 100644\n--- a/packages/lib/server/repository/SelectedCalendarRepository.interface.ts\n+++ b/packages/lib/server/repository/SelectedCalendarRepository.interface.ts\n@@ -24,9 +24,11 @@ export interface ISelectedCalendarRepository {\n    */\n   findNextSubscriptionBatch({\n     take,\n+    teamIds,\n     integrations,\n   }: {\n     take: number;\n+    teamIds: number[];\n     integrations?: string[];\n   }): Promise<SelectedCalendar[]>;\n \ndiff --git a/packages/lib/server/repository/SelectedCalendarRepository.ts b/packages/lib/server/repository/SelectedCalendarRepository.ts\nindex b40cfc70a37b57..716a35e646c42b 100644\n--- a/packages/lib/server/repository/SelectedCalendarRepository.ts\n+++ b/packages/lib/server/repository/SelectedCalendarRepository.ts\n@@ -15,26 +15,24 @@ export class SelectedCalendarRepository implements ISelectedCalendarRepository {\n     return this.prismaClient.selectedCalendar.findFirst({ where: { channelId } });\n   }\n \n-  async findNextSubscriptionBatch({ take, integrations }: { take: number; integrations: string[] }) {\n+  async findNextSubscriptionBatch({\n+    take,\n+    teamIds,\n+    integrations,\n+  }: {\n+    take: number;\n+    teamIds: number[];\n+    integrations: string[];\n+  }) {\n     return this.prismaClient.selectedCalendar.findMany({\n       where: {\n         integration: { in: integrations },\n         OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: new Date() } }],\n-        // initially we will run subscription only for teams that have\n-        // the feature flags enabled and it should be removed later\n         user: {\n           teams: {\n             some: {\n-              team: {\n-                features: {\n-                  some: {\n-                    OR: [\n-                      { featureId: \"calendar-subscription-cache\" },\n-                      { featureId: \"calendar-subscription-sync\" },\n-                    ],\n-                  },\n-                },\n-              },\n+              teamId: { in: teamIds },\n+              accepted: true,\n             },\n           },\n         },\ndiff --git a/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts b/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts\nindex d649c6da1754d6..ac1b8153a7335d 100644\n--- a/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts\n+++ b/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts\n@@ -116,6 +116,7 @@ describe(\"SelectedCalendarRepository\", () => {\n \n       const result = await repository.findNextSubscriptionBatch({\n         take: 10,\n+        teamIds: [1, 2, 3],\n         integrations: [\"google_calendar\", \"office365_calendar\"],\n       });\n \n@@ -126,16 +127,8 @@ describe(\"SelectedCalendarRepository\", () => {\n           user: {\n             teams: {\n               some: {\n-                team: {\n-                  features: {\n-                    some: {\n-                      OR: [\n-                        { featureId: \"calendar-subscription-cache\" },\n-                        { featureId: \"calendar-subscription-sync\" },\n-                      ],\n-                    },\n-                  },\n-                },\n+                teamId: { in: [1, 2, 3] },\n+                accepted: true,\n               },\n             },\n           },\n@@ -152,6 +145,7 @@ describe(\"SelectedCalendarRepository\", () => {\n \n       const result = await repository.findNextSubscriptionBatch({\n         take: 5,\n+        teamIds: [10, 20],\n         integrations: [],\n       });\n \n@@ -162,16 +156,8 @@ describe(\"SelectedCalendarRepository\", () => {\n           user: {\n             teams: {\n               some: {\n-                team: {\n-                  features: {\n-                    some: {\n-                      OR: [\n-                        { featureId: \"calendar-subscription-cache\" },\n-                        { featureId: \"calendar-subscription-sync\" },\n-                      ],\n-                    },\n-                  },\n-                },\n+                teamId: { in: [10, 20] },\n+                accepted: true,\n               },\n             },\n           },\n@@ -181,6 +167,35 @@ describe(\"SelectedCalendarRepository\", () => {\n \n       expect(result).toEqual(mockCalendars);\n     });\n+\n+    test(\"should handle empty teamIds array\", async () => {\n+      const mockCalendars: SelectedCalendar[] = [];\n+      vi.mocked(mockPrismaClient.selectedCalendar.findMany).mockResolvedValue(mockCalendars);\n+\n+      const result = await repository.findNextSubscriptionBatch({\n+        take: 10,\n+        teamIds: [],\n+        integrations: [\"google_calendar\"],\n+      });\n+\n+      expect(mockPrismaClient.selectedCalendar.findMany).toHaveBeenCalledWith({\n+        where: {\n+          integration: { in: [\"google_calendar\"] },\n+          OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: expect.any(Date) } }],\n+          user: {\n+            teams: {\n+              some: {\n+                teamId: { in: [] },\n+                accepted: true,\n+              },\n+            },\n+          },\n+        },\n+        take: 10,\n+      });\n+\n+      expect(result).toEqual(mockCalendars);\n+    });\n   });\n \n   describe(\"updateSyncStatus\", () => {\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}