{
    "cost": 0.06761,
    "rewrites": {
        "calcom__cal.com.main/packages/trpc/server/routers/viewer/teams/update.handler.ts": {
            "output": "import { getOrgFullOrigin } from \"@calcom/ee/organizations/lib/orgDomains\";\nimport { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\nimport { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\nimport { IS_TEAM_BILLING_ENABLED } from \"@calcom/lib/constants\";\nimport type { IntervalLimit } from \"@calcom/lib/intervalLimits/intervalLimitSchema\";\nimport { validateIntervalLimitOrder } from \"@calcom/lib/intervalLimits/validateIntervalLimitOrder\";\nimport { uploadLogo } from \"@calcom/lib/server/avatar\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Prisma } from \"@calcom/prisma/client\";\nimport { MembershipRole, RedirectType, RRTimestampBasis } from \"@calcom/prisma/enums\";\nimport { teamMetadataStrictSchema } from \"@calcom/prisma/zod-utils\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TrpcSessionUser } from \"../../../types\";\nimport type { TUpdateInputSchema } from \"./update.schema\";\n\ntype UpdateOptions = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  };\n  input: TUpdateInputSchema;\n};\n\nexport const updateHandler = async ({ ctx, input }: UpdateOptions) => {\n  const isOrgAdmin = ctx.user?.organization?.isOrgAdmin;\n\n  if (!isOrgAdmin) {\n    const permissionCheckService = new PermissionCheckService();\n    const hasTeamUpdatePermission = await permissionCheckService.checkPermission({\n      userId: ctx.user?.id || 0,\n      teamId: input.id,\n      permission: \"team.update\",\n      fallbackRoles: [MembershipRole.OWNER, MembershipRole.ADMIN],\n    });\n\n    if (!hasTeamUpdatePermission) {\n      throw new TRPCError({ code: \"UNAUTHORIZED\" });\n    }\n  }\n\n  if (input.slug) {\n    const orgId = ctx.user.organizationId;\n    const teamRepository = new TeamRepository(prisma);\n    const isSlugAvailable = await teamRepository.isSlugAvailableForUpdate({\n      slug: input.slug,\n      teamId: input.id,\n      parentId: orgId,\n    });\n    if (!isSlugAvailable) {\n      throw new TRPCError({ code: \"CONFLICT\", message: \"Slug already in use.\" });\n    }\n  }\n\n  const prevTeam = await prisma.team.findUnique({\n    where: {\n      id: input.id,\n    },\n  });\n\n  if (!prevTeam) throw new TRPCError({ code: \"NOT_FOUND\", message: \"Team not found.\" });\n\n  if (input.bookingLimits) {\n    const isValid = validateIntervalLimitOrder(input.bookingLimits);\n    if (!isValid)\n      throw new TRPCError({ code: \"BAD_REQUEST\", message: \"Booking limits must be in ascending order.\" });\n  }\n\n  const data: Prisma.TeamUpdateArgs[\"data\"] = {\n    name: input.name,\n    bio: input.bio,\n    hideBranding: input.hideBranding,\n    isPrivate: input.isPrivate,\n    hideBookATeamMember: input.hideBookATeamMember,\n    hideTeamProfileLink: input.hideTeamProfileLink,\n    brandColor: input.brandColor,\n    darkBrandColor: input.darkBrandColor,\n    theme: input.theme,\n    bookingLimits: input.bookingLimits ?? undefined,\n    includeManagedEventsInLimits: input.includeManagedEventsInLimits ?? undefined,\n    rrResetInterval: input.rrResetInterval,\n    rrTimestampBasis: input.rrTimestampBasis,\n  };\n\n  if (\n    input.logo &&\n    (input.logo.startsWith(\"data:image/png;base64,\") ||\n      input.logo.startsWith(\"data:image/jpeg;base64,\") ||\n      input.logo.startsWith(\"data:image/jpg;base64,\"))\n  ) {\n    data.logoUrl = await uploadLogo({ teamId: input.id, logo: input.logo });\n  } else if (typeof input.logo !== \"undefined\" && !input.logo) {\n    data.logoUrl = null;\n  }\n\n  if (\n    input.slug &&\n    IS_TEAM_BILLING_ENABLED &&\n    /** If the team doesn't have a slug we can assume that it hasn't been published yet. */\n    !prevTeam.slug\n  ) {\n    // Save it on the metadata so we can use it later\n    data.metadata = {\n      requestedSlug: input.slug,\n    };\n  } else {\n    data.slug = input.slug;\n\n    // If we save slug, we don't need the requestedSlug anymore\n    const metadataParse = teamMetadataStrictSchema.safeParse(prevTeam.metadata);\n    if (metadataParse.success) {\n      const { requestedSlug: _, ...cleanMetadata } = metadataParse.data || {};\n      data.metadata = {\n        ...cleanMetadata,\n      };\n    }\n  }\n\n  const updatedTeam = await prisma.team.update({\n    where: { id: input.id },\n    data,\n  });\n\n  if (\n    data.rrTimestampBasis &&\n    data.rrTimestampBasis !== RRTimestampBasis.CREATED_AT &&\n    prevTeam.rrTimestampBasis === RRTimestampBasis.CREATED_AT\n  ) {\n    // disable load balancing for all event types\n    await prisma.eventType.updateMany({\n      where: {\n        teamId: input.id,\n      },\n      data: {\n        maxLeadThreshold: null,\n      },\n    });\n  }\n\n  if (updatedTeam.parentId && prevTeam.slug) {\n    // No changes made lets skip this logic\n    if (updatedTeam.slug === prevTeam.slug) return;\n\n    // Fetch parent team slug to construct toUrl\n    const parentTeam = await prisma.team.findUnique({\n      where: {\n        id: updatedTeam.parentId,\n      },\n      select: {\n        slug: true,\n      },\n    });\n\n    if (!parentTeam?.slug) {\n      throw new Error(`Parent team with slug: ${parentTeam?.slug} not found`);\n    }\n\n    const orgUrlPrefix = getOrgFullOrigin(parentTeam.slug);\n\n    const toUrlOld = `${orgUrlPrefix}/${prevTeam.slug}`;\n    const toUrlNew = `${orgUrlPrefix}/${updatedTeam.slug}`;\n\n    await prisma.tempOrgRedirect.updateMany({\n      where: {\n        type: RedirectType.Team,\n        toUrl: toUrlOld,\n      },\n      data: {\n        toUrl: toUrlNew,\n      },\n    });\n  }\n\n  return {\n    logoUrl: updatedTeam.logoUrl,\n    name: updatedTeam.name,\n    bio: updatedTeam.bio,\n    slug: updatedTeam.slug,\n    theme: updatedTeam.theme,\n    brandColor: updatedTeam.brandColor,\n    darkBrandColor: updatedTeam.darkBrandColor,\n    bookingLimits: updatedTeam.bookingLimits as IntervalLimit,\n    includeManagedEventsInLimits: updatedTeam.includeManagedEventsInLimits,\n    rrResetInterval: updatedTeam.rrResetInterval,\n    rrTimestampBasis: updatedTeam.rrTimestampBasis,\n  };\n};\n\nexport default updateHandler;",
            "output_extracted": "import { getOrgFullOrigin } from \"@calcom/ee/organizations/lib/orgDomains\";\nimport { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\nimport { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\nimport { IS_TEAM_BILLING_ENABLED } from \"@calcom/lib/constants\";\nimport type { IntervalLimit } from \"@calcom/lib/intervalLimits/intervalLimitSchema\";\nimport { validateIntervalLimitOrder } from \"@calcom/lib/intervalLimits/validateIntervalLimitOrder\";\nimport { uploadLogo } from \"@calcom/lib/server/avatar\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Prisma } from \"@calcom/prisma/client\";\nimport { MembershipRole, RedirectType, RRTimestampBasis } from \"@calcom/prisma/enums\";\nimport { teamMetadataStrictSchema } from \"@calcom/prisma/zod-utils\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TrpcSessionUser } from \"../../../types\";\nimport type { TUpdateInputSchema } from \"./update.schema\";\n\ntype UpdateOptions = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  };\n  input: TUpdateInputSchema;\n};\n\nexport const updateHandler = async ({ ctx, input }: UpdateOptions) => {\n  const isOrgAdmin = ctx.user?.organization?.isOrgAdmin;\n\n  if (!isOrgAdmin) {\n    const permissionCheckService = new PermissionCheckService();\n    const hasTeamUpdatePermission = await permissionCheckService.checkPermission({\n      userId: ctx.user?.id || 0,\n      teamId: input.id,\n      permission: \"team.update\",\n      fallbackRoles: [MembershipRole.OWNER, MembershipRole.ADMIN],\n    });\n\n    if (!hasTeamUpdatePermission) {\n      throw new TRPCError({ code: \"UNAUTHORIZED\" });\n    }\n  }\n\n  if (input.slug) {\n    const orgId = ctx.user.organizationId;\n    const teamRepository = new TeamRepository(prisma);\n    const isSlugAvailable = await teamRepository.isSlugAvailableForUpdate({\n      slug: input.slug,\n      teamId: input.id,\n      parentId: orgId,\n    });\n    if (!isSlugAvailable) {\n      throw new TRPCError({ code: \"CONFLICT\", message: \"Slug already in use.\" });\n    }\n  }\n\n  const prevTeam = await prisma.team.findUnique({\n    where: {\n      id: input.id,\n    },\n  });\n\n  if (!prevTeam) throw new TRPCError({ code: \"NOT_FOUND\", message: \"Team not found.\" });\n\n  if (input.bookingLimits) {\n    const isValid = validateIntervalLimitOrder(input.bookingLimits);\n    if (!isValid)\n      throw new TRPCError({ code: \"BAD_REQUEST\", message: \"Booking limits must be in ascending order.\" });\n  }\n\n  const data: Prisma.TeamUpdateArgs[\"data\"] = {\n    name: input.name,\n    bio: input.bio,\n    hideBranding: input.hideBranding,\n    isPrivate: input.isPrivate,\n    hideBookATeamMember: input.hideBookATeamMember,\n    hideTeamProfileLink: input.hideTeamProfileLink,\n    brandColor: input.brandColor,\n    darkBrandColor: input.darkBrandColor,\n    theme: input.theme,\n    bookingLimits: input.bookingLimits ?? undefined,\n    includeManagedEventsInLimits: input.includeManagedEventsInLimits ?? undefined,\n    rrResetInterval: input.rrResetInterval,\n    rrTimestampBasis: input.rrTimestampBasis,\n  };\n\n  if (\n    input.logo &&\n    (input.logo.startsWith(\"data:image/png;base64,\") ||\n      input.logo.startsWith(\"data:image/jpeg;base64,\") ||\n      input.logo.startsWith(\"data:image/jpg;base64,\"))\n  ) {\n    data.logoUrl = await uploadLogo({ teamId: input.id, logo: input.logo });\n  } else if (typeof input.logo !== \"undefined\" && !input.logo) {\n    data.logoUrl = null;\n  }\n\n  if (\n    input.slug &&\n    IS_TEAM_BILLING_ENABLED &&\n    /** If the team doesn't have a slug we can assume that it hasn't been published yet. */\n    !prevTeam.slug\n  ) {\n    // Save it on the metadata so we can use it later\n    data.metadata = {\n      requestedSlug: input.slug,\n    };\n  } else {\n    data.slug = input.slug;\n\n    // If we save slug, we don't need the requestedSlug anymore\n    const metadataParse = teamMetadataStrictSchema.safeParse(prevTeam.metadata);\n    if (metadataParse.success) {\n      const { requestedSlug: _, ...cleanMetadata } = metadataParse.data || {};\n      data.metadata = {\n        ...cleanMetadata,\n      };\n    }\n  }\n\n  const updatedTeam = await prisma.team.update({\n    where: { id: input.id },\n    data,\n  });\n\n  if (\n    data.rrTimestampBasis &&\n    data.rrTimestampBasis !== RRTimestampBasis.CREATED_AT &&\n    prevTeam.rrTimestampBasis === RRTimestampBasis.CREATED_AT\n  ) {\n    // disable load balancing for all event types\n    await prisma.eventType.updateMany({\n      where: {\n        teamId: input.id,\n      },\n      data: {\n        maxLeadThreshold: null,\n      },\n    });\n  }\n\n  if (updatedTeam.parentId && prevTeam.slug) {\n    // No changes made lets skip this logic\n    if (updatedTeam.slug === prevTeam.slug) return;\n\n    // Fetch parent team slug to construct toUrl\n    const parentTeam = await prisma.team.findUnique({\n      where: {\n        id: updatedTeam.parentId,\n      },\n      select: {\n        slug: true,\n      },\n    });\n\n    if (!parentTeam?.slug) {\n      throw new Error(`Parent team with slug: ${parentTeam?.slug} not found`);\n    }\n\n    const orgUrlPrefix = getOrgFullOrigin(parentTeam.slug);\n\n    const toUrlOld = `${orgUrlPrefix}/${prevTeam.slug}`;\n    const toUrlNew = `${orgUrlPrefix}/${updatedTeam.slug}`;\n\n    await prisma.tempOrgRedirect.updateMany({\n      where: {\n        type: RedirectType.Team,\n        toUrl: toUrlOld,\n      },\n      data: {\n        toUrl: toUrlNew,\n      },\n    });\n  }\n\n  return {\n    logoUrl: updatedTeam.logoUrl,\n    name: updatedTeam.name,\n    bio: updatedTeam.bio,\n    slug: updatedTeam.slug,\n    theme: updatedTeam.theme,\n    brandColor: updatedTeam.brandColor,\n    darkBrandColor: updatedTeam.darkBrandColor,\n    bookingLimits: updatedTeam.bookingLimits as IntervalLimit,\n    includeManagedEventsInLimits: updatedTeam.includeManagedEventsInLimits,\n    rrResetInterval: updatedTeam.rrResetInterval,\n    rrTimestampBasis: updatedTeam.rrTimestampBasis,\n  };\n};\n\nexport default updateHandler;",
            "cost": 0.06761
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25332",
        "repo": "calcom/cal.com",
        "base_commit": "9c2d7f99c2ba3b845fe13456722557555bf2d963",
        "head_commit": "9817dcf2da9af66e69c368c5ea00f9c5767bb8be",
        "title": "chore: team update handler refactor",
        "merged_at": "2025-11-25T11:27:26Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25332",
        "test_files": [
            "packages/trpc/server/routers/viewer/teams/update.handler.test.ts"
        ],
        "code_files": [
            "packages/trpc/server/routers/viewer/teams/update.handler.ts"
        ],
        "total_changes": 262,
        "num_files": 2,
        "pull_number": 25332,
        "patch": "diff --git a/packages/trpc/server/routers/viewer/teams/update.handler.test.ts b/packages/trpc/server/routers/viewer/teams/update.handler.test.ts\nnew file mode 100644\nindex 00000000000000..59cabfd4dc81c5\n--- /dev/null\n+++ b/packages/trpc/server/routers/viewer/teams/update.handler.test.ts\n@@ -0,0 +1,215 @@\n+import { describe, it, expect, vi, beforeEach } from \"vitest\";\n+\n+import { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\n+import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\n+import { prisma } from \"@calcom/prisma\";\n+import { RRTimestampBasis } from \"@calcom/prisma/enums\";\n+\n+import type { TrpcSessionUser } from \"../../../types\";\n+import { updateHandler } from \"./update.handler\";\n+import type { TUpdateInputSchema } from \"./update.schema\";\n+\n+vi.mock(\"@calcom/prisma\", () => ({\n+  prisma: {\n+    team: {\n+      findUnique: vi.fn(),\n+      update: vi.fn(),\n+      updateMany: vi.fn(),\n+    },\n+    eventType: {\n+      updateMany: vi.fn(),\n+    },\n+    tempOrgRedirect: {\n+      updateMany: vi.fn(),\n+    },\n+  },\n+}));\n+\n+vi.mock(\"@calcom/features/pbac/services/permission-check.service\", () => ({\n+  PermissionCheckService: vi.fn().mockImplementation(() => ({\n+    checkPermission: vi.fn(),\n+  })),\n+}));\n+\n+vi.mock(\"@calcom/features/ee/teams/repositories/TeamRepository\", () => ({\n+  TeamRepository: vi.fn().mockImplementation(() => ({\n+    isSlugAvailableForUpdate: vi.fn().mockResolvedValue(true),\n+  })),\n+}));\n+\n+vi.mock(\"@calcom/lib/server/avatar\", () => ({\n+  uploadLogo: vi.fn().mockResolvedValue(\"https://example.com/logo.png\"),\n+}));\n+\n+vi.mock(\"@calcom/lib/intervalLimits/validateIntervalLimitOrder\", () => ({\n+  validateIntervalLimitOrder: vi.fn().mockReturnValue(true),\n+}));\n+\n+vi.mock(\"@calcom/lib/constants\", () => ({\n+  IS_TEAM_BILLING_ENABLED: false,\n+}));\n+\n+vi.mock(\"@calcom/ee/organizations/lib/orgDomains\", () => ({\n+  getOrgFullOrigin: vi.fn((slug: string) => `https://${slug}.cal.com`),\n+}));\n+\n+describe(\"updateHandler - Permission Check Tests\", () => {\n+  const mockPermissionCheckService = {\n+    checkPermission: vi.fn(),\n+  };\n+\n+  const mockTeamRepository = {\n+    isSlugAvailableForUpdate: vi.fn().mockResolvedValue(true),\n+  };\n+\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+    vi.mocked(PermissionCheckService).mockImplementation(\n+      () => mockPermissionCheckService as unknown as InstanceType<typeof PermissionCheckService>\n+    );\n+    vi.mocked(TeamRepository).mockImplementation(\n+      () => mockTeamRepository as unknown as InstanceType<typeof TeamRepository>\n+    );\n+  });\n+\n+  describe(\"Permission Check Service\", () => {\n+    const user: NonNullable<TrpcSessionUser> = {\n+      id: 1,\n+      organizationId: 100,\n+    } as NonNullable<TrpcSessionUser>;\n+\n+    it(\"should use permission check service for all users\", async () => {\n+      const input: TUpdateInputSchema = {\n+        id: 50,\n+        name: \"Updated Team\",\n+      };\n+\n+      mockPermissionCheckService.checkPermission.mockResolvedValue(true);\n+\n+      vi.mocked(prisma.team.findUnique).mockResolvedValue({\n+        id: 50,\n+        parentId: 100,\n+        slug: \"test-team\",\n+        metadata: {},\n+        rrTimestampBasis: RRTimestampBasis.CREATED_AT,\n+      } as any);\n+\n+      vi.mocked(prisma.team.update).mockResolvedValue({\n+        id: 50,\n+        name: \"Updated Team\",\n+        bio: null,\n+        slug: \"test-team\",\n+        theme: null,\n+        brandColor: null,\n+        darkBrandColor: null,\n+        logoUrl: null,\n+        bookingLimits: null,\n+        includeManagedEventsInLimits: null,\n+        rrResetInterval: null,\n+        rrTimestampBasis: RRTimestampBasis.CREATED_AT,\n+      } as any);\n+\n+      await updateHandler({\n+        ctx: { user },\n+        input,\n+      });\n+\n+      expect(mockPermissionCheckService.checkPermission).toHaveBeenCalledWith({\n+        userId: user.id,\n+        teamId: input.id,\n+        permission: \"team.update\",\n+        fallbackRoles: expect.any(Array),\n+      });\n+      expect(prisma.team.update).toHaveBeenCalled();\n+    });\n+\n+    it(\"should throw UNAUTHORIZED when permission check fails\", async () => {\n+      const input: TUpdateInputSchema = {\n+        id: 50,\n+        name: \"Unauthorized Update\",\n+      };\n+\n+      mockPermissionCheckService.checkPermission.mockResolvedValue(false);\n+\n+      vi.mocked(prisma.team.findUnique).mockResolvedValue({\n+        id: 50,\n+        parentId: 100,\n+        slug: \"test-team\",\n+        metadata: {},\n+        rrTimestampBasis: RRTimestampBasis.CREATED_AT,\n+      } as any);\n+\n+      await expect(\n+        updateHandler({\n+          ctx: { user },\n+          input,\n+        })\n+      ).rejects.toMatchObject({\n+        code: \"UNAUTHORIZED\",\n+      });\n+\n+      expect(prisma.team.update).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"should throw UNAUTHORIZED when user has no id\", async () => {\n+      const userWithoutId = {\n+        id: undefined,\n+        organizationId: 100,\n+      } as unknown as NonNullable<TrpcSessionUser>;\n+\n+      const input: TUpdateInputSchema = {\n+        id: 50,\n+        name: \"Updated Team\",\n+      };\n+\n+      vi.mocked(prisma.team.findUnique).mockResolvedValue({\n+        id: 50,\n+        parentId: 100,\n+        slug: \"test-team\",\n+        metadata: {},\n+        rrTimestampBasis: RRTimestampBasis.CREATED_AT,\n+      } as any);\n+\n+      await expect(\n+        updateHandler({\n+          ctx: { user: userWithoutId },\n+          input,\n+        })\n+      ).rejects.toMatchObject({\n+        code: \"UNAUTHORIZED\",\n+      });\n+\n+      expect(mockPermissionCheckService.checkPermission).not.toHaveBeenCalled();\n+      expect(prisma.team.update).not.toHaveBeenCalled();\n+    });\n+  });\n+\n+  describe(\"Team Not Found\", () => {\n+    const user: NonNullable<TrpcSessionUser> = {\n+      id: 1,\n+      organizationId: 100,\n+    } as NonNullable<TrpcSessionUser>;\n+\n+    it(\"should throw NOT_FOUND when team does not exist\", async () => {\n+      const input: TUpdateInputSchema = {\n+        id: 999,\n+        name: \"Non-existent Team\",\n+      };\n+\n+      vi.mocked(prisma.team.findUnique).mockResolvedValue(null);\n+\n+      await expect(\n+        updateHandler({\n+          ctx: { user },\n+          input,\n+        })\n+      ).rejects.toMatchObject({\n+        code: \"NOT_FOUND\",\n+        message: \"Team not found.\",\n+      });\n+\n+      // Should not check permissions if team doesn't exist\n+      expect(mockPermissionCheckService.checkPermission).not.toHaveBeenCalled();\n+    });\n+  });\n+});\ndiff --git a/packages/trpc/server/routers/viewer/teams/update.handler.ts b/packages/trpc/server/routers/viewer/teams/update.handler.ts\nindex 55022aad5aeb59..43fa3859940f52 100644\n--- a/packages/trpc/server/routers/viewer/teams/update.handler.ts\n+++ b/packages/trpc/server/routers/viewer/teams/update.handler.ts\n@@ -23,20 +23,35 @@ type UpdateOptions = {\n };\n \n export const updateHandler = async ({ ctx, input }: UpdateOptions) => {\n-  const isOrgAdmin = ctx.user?.organization?.isOrgAdmin;\n+  const prevTeam = await prisma.team.findUnique({\n+    where: {\n+      id: input.id,\n+    },\n+    select: {\n+      id: true,\n+      parentId: true,\n+      slug: true,\n+      metadata: true,\n+      rrTimestampBasis: true,\n+    },\n+  });\n \n-  if (!isOrgAdmin) {\n-    const permissionCheckService = new PermissionCheckService();\n-    const hasTeamUpdatePermission = await permissionCheckService.checkPermission({\n-      userId: ctx.user?.id || 0,\n-      teamId: input.id,\n-      permission: \"team.update\",\n-      fallbackRoles: [MembershipRole.OWNER, MembershipRole.ADMIN],\n-    });\n+  if (!prevTeam) throw new TRPCError({ code: \"NOT_FOUND\", message: \"Team not found.\" });\n \n-    if (!hasTeamUpdatePermission) {\n-      throw new TRPCError({ code: \"UNAUTHORIZED\" });\n-    }\n+  if (!ctx.user?.id) {\n+    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n+  }\n+\n+  const permissionCheckService = new PermissionCheckService();\n+  const hasTeamUpdatePermission = await permissionCheckService.checkPermission({\n+    userId: ctx.user.id,\n+    teamId: input.id,\n+    permission: \"team.update\",\n+    fallbackRoles: [MembershipRole.OWNER, MembershipRole.ADMIN],\n+  });\n+\n+  if (!hasTeamUpdatePermission) {\n+    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n   }\n \n   if (input.slug) {\n@@ -52,14 +67,6 @@ export const updateHandler = async ({ ctx, input }: UpdateOptions) => {\n     }\n   }\n \n-  const prevTeam = await prisma.team.findUnique({\n-    where: {\n-      id: input.id,\n-    },\n-  });\n-\n-  if (!prevTeam) throw new TRPCError({ code: \"NOT_FOUND\", message: \"Team not found.\" });\n-\n   if (input.bookingLimits) {\n     const isValid = validateIntervalLimitOrder(input.bookingLimits);\n     if (!isValid)\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}