{
    "cost": 0.305875,
    "rewrites": {
        "calcom__cal.com.main/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx": {
            "output": "import { createRouterCaller } from \"app/_trpc/context\";\nimport { _generateMetadata, getTranslate } from \"app/_utils\";\nimport { unstable_cache } from \"next/cache\";\nimport { headers, cookies } from \"next/headers\";\nimport { redirect } from \"next/navigation\";\n\nimport { getServerSession } from \"@calcom/features/auth/lib/getServerSession\";\nimport { Resource, CustomAction } from \"@calcom/features/pbac/domain/types/permission-registry\";\nimport { getSpecificPermissions } from \"@calcom/features/pbac/lib/resource-permissions\";\nimport { RoleManagementFactory } from \"@calcom/features/pbac/services/role-management.factory\";\nimport SettingsHeader from \"@calcom/features/settings/appDir/SettingsHeader\";\nimport { PrismaAttributeRepository } from \"@calcom/lib/server/repository/PrismaAttributeRepository\";\nimport { prisma } from \"@calcom/prisma\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\nimport { viewerTeamsRouter } from \"@calcom/trpc/server/routers/viewer/teams/_router\";\n\nimport { buildLegacyRequest } from \"@lib/buildLegacyCtx\";\n\nimport { TeamMembersView } from \"~/teams/team-members-view\";\n\nexport const generateMetadata = async ({ params }: { params: Promise<{ id: string }> }) =>\n  await _generateMetadata(\n    (t) => t(\"team_members\"),\n    (t) => t(\"members_team_description\"),\n    undefined,\n    undefined,\n    `/settings/teams/${(await params).id}/members`\n  );\n\nconst getCachedTeamRoles = unstable_cache(\n  async (teamId: number, organizationId?: number) => {\n    if (!organizationId) return []; // Fallback to traditional roles\n    try {\n      const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n      return await roleManager.getTeamRoles(teamId);\n    } catch (error) {\n      // PBAC not enabled or error occurred, return empty array\n      return [];\n    }\n  },\n  undefined,\n  { revalidate: 3600, tags: [\"pbac.team.roles.list\"] } // Cache for 1 hour\n);\n\nconst getCachedTeamAttributes = unstable_cache(\n  async (organizationId?: number) => {\n    if (!organizationId) return [];\n    const attributeRepo = new PrismaAttributeRepository(prisma);\n\n    try {\n      return await attributeRepo.findAllByOrgIdWithOptions({ orgId: organizationId });\n    } catch (error) {\n      return [];\n    }\n  },\n  undefined,\n  { revalidate: 3600, tags: [\"viewer.attributes.list\"] } // Cache for 1 hour\n);\n\nconst Page = async ({ params }: { params: Promise<{ id: string }> }) => {\n  const t = await getTranslate();\n  const { id } = await params;\n  const teamId = parseInt(id);\n\n  const session = await getServerSession({ req: buildLegacyRequest(await headers(), await cookies()) });\n\n  if (!session?.user.id) {\n    return redirect(\"/auth/login\");\n  }\n\n  const teamCaller = await createRouterCaller(viewerTeamsRouter);\n  const team = await teamCaller.get({ teamId });\n\n  if (!team) {\n    throw new Error(\"Team not found\");\n  }\n\n  // Get organization ID (either the team's parent or the team itself if it's an org)\n  const organizationId = team.parentId || teamId;\n\n  // Load PBAC roles and attributes if available\n  const [roles, attributes] = await Promise.all([\n    getCachedTeamRoles(teamId, organizationId),\n    getCachedTeamAttributes(organizationId),\n  ]);\n\n  const fallbackRolesCanListMembers: MembershipRole[] = [MembershipRole.ADMIN, MembershipRole.OWNER];\n\n  // If the team is not private we allow members to list other members\n  if (!team.isPrivate) {\n    fallbackRolesCanListMembers.push(MembershipRole.MEMBER);\n  }\n\n  // Get specific PBAC permissions for team member actions\n  const permissions = await getSpecificPermissions({\n    userId: session.user.id,\n    teamId: teamId,\n    resource: Resource.Team,\n    userRole: team.membership.role,\n    actions: [\n      CustomAction.Invite,\n      CustomAction.ChangeMemberRole,\n      CustomAction.Remove,\n      CustomAction.ListMembers,\n      CustomAction.ListMembersPrivate,\n      CustomAction.Impersonate,\n    ],\n    fallbackRoles: {\n      [CustomAction.Invite]: {\n        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n      },\n      [CustomAction.ChangeMemberRole]: {\n        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n      },\n      [CustomAction.Remove]: {\n        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n      },\n      [CustomAction.ListMembers]: {\n        roles: fallbackRolesCanListMembers,\n      },\n      [CustomAction.Impersonate]: {\n        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n      },\n      [CustomAction.ListMembersPrivate]: {\n        roles: fallbackRolesCanListMembers,\n      },\n    },\n  });\n\n  // Map specific permissions to member actions\n  const memberPermissions = {\n    canListMembers: team.isPrivate\n      ? permissions[CustomAction.ListMembersPrivate]\n      : permissions[CustomAction.ListMembers],\n    canInvite: permissions[CustomAction.Invite],\n    canChangeMemberRole: permissions[CustomAction.ChangeMemberRole],\n    canRemove: permissions[CustomAction.Remove],\n    canImpersonate: permissions[CustomAction.Impersonate],\n  };\n\n  const facetedTeamValues = {\n    roles,\n    teams: [team],\n    attributes: attributes.map((attribute) => ({\n      id: attribute.id,\n      name: attribute.name,\n      options: Array.from(new Set(attribute.options.map((option) => option.value))).map((value) => ({\n        value,\n      })),\n    })),\n  };\n\n  return (\n    <SettingsHeader title={t(\"team_members\")} description={t(\"members_team_description\")}>\n      <TeamMembersView\n        team={team}\n        facetedTeamValues={facetedTeamValues}\n        attributes={attributes}\n        permissions={memberPermissions}\n      />\n    </SettingsHeader>\n  );\n};\n\nexport default Page;",
            "output_extracted": "import { createRouterCaller } from \"app/_trpc/context\";\nimport { _generateMetadata, getTranslate } from \"app/_utils\";\nimport { unstable_cache } from \"next/cache\";\nimport { headers, cookies } from \"next/headers\";\nimport { redirect } from \"next/navigation\";\n\nimport { getServerSession } from \"@calcom/features/auth/lib/getServerSession\";\nimport { Resource, CustomAction } from \"@calcom/features/pbac/domain/types/permission-registry\";\nimport { getSpecificPermissions } from \"@calcom/features/pbac/lib/resource-permissions\";\nimport { RoleManagementFactory } from \"@calcom/features/pbac/services/role-management.factory\";\nimport SettingsHeader from \"@calcom/features/settings/appDir/SettingsHeader\";\nimport { PrismaAttributeRepository } from \"@calcom/lib/server/repository/PrismaAttributeRepository\";\nimport { prisma } from \"@calcom/prisma\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\nimport { viewerTeamsRouter } from \"@calcom/trpc/server/routers/viewer/teams/_router\";\n\nimport { buildLegacyRequest } from \"@lib/buildLegacyCtx\";\n\nimport { TeamMembersView } from \"~/teams/team-members-view\";\n\nexport const generateMetadata = async ({ params }: { params: Promise<{ id: string }> }) =>\n  await _generateMetadata(\n    (t) => t(\"team_members\"),\n    (t) => t(\"members_team_description\"),\n    undefined,\n    undefined,\n    `/settings/teams/${(await params).id}/members`\n  );\n\nconst getCachedTeamRoles = unstable_cache(\n  async (teamId: number, organizationId?: number) => {\n    if (!organizationId) return []; // Fallback to traditional roles\n    try {\n      const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n      return await roleManager.getTeamRoles(teamId);\n    } catch (error) {\n      // PBAC not enabled or error occurred, return empty array\n      return [];\n    }\n  },\n  undefined,\n  { revalidate: 3600, tags: [\"pbac.team.roles.list\"] } // Cache for 1 hour\n);\n\nconst getCachedTeamAttributes = unstable_cache(\n  async (organizationId?: number) => {\n    if (!organizationId) return [];\n    const attributeRepo = new PrismaAttributeRepository(prisma);\n\n    try {\n      return await attributeRepo.findAllByOrgIdWithOptions({ orgId: organizationId });\n    } catch (error) {\n      return [];\n    }\n  },\n  undefined,\n  { revalidate: 3600, tags: [\"viewer.attributes.list\"] } // Cache for 1 hour\n);\n\nconst Page = async ({ params }: { params: Promise<{ id: string }> }) => {\n  const t = await getTranslate();\n  const { id } = await params;\n  const teamId = parseInt(id);\n\n  const session = await getServerSession({ req: buildLegacyRequest(await headers(), await cookies()) });\n\n  if (!session?.user.id) {\n    return redirect(\"/auth/login\");\n  }\n\n  const teamCaller = await createRouterCaller(viewerTeamsRouter);\n  const team = await teamCaller.get({ teamId });\n\n  if (!team) {\n    throw new Error(\"Team not found\");\n  }\n\n  // Get organization ID (either the team's parent or the team itself if it's an org)\n  const organizationId = team.parentId || teamId;\n\n  // Load PBAC roles and attributes if available\n  const [roles, attributes] = await Promise.all([\n    getCachedTeamRoles(teamId, organizationId),\n    getCachedTeamAttributes(organizationId),\n  ]);\n\n  const fallbackRolesCanListMembers: MembershipRole[] = [MembershipRole.ADMIN, MembershipRole.OWNER];\n\n  // If the team is not private we allow members to list other members\n  if (!team.isPrivate) {\n    fallbackRolesCanListMembers.push(MembershipRole.MEMBER);\n  }\n\n  // Get specific PBAC permissions for team member actions\n  const permissions = await getSpecificPermissions({\n    userId: session.user.id,\n    teamId: teamId,\n    resource: Resource.Team,\n    userRole: team.membership.role,\n    actions: [\n      CustomAction.Invite,\n      CustomAction.ChangeMemberRole,\n      CustomAction.Remove,\n      CustomAction.ListMembers,\n      CustomAction.ListMembersPrivate,\n      CustomAction.Impersonate,\n    ],\n    fallbackRoles: {\n      [CustomAction.Invite]: {\n        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n      },\n      [CustomAction.ChangeMemberRole]: {\n        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n      },\n      [CustomAction.Remove]: {\n        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n      },\n      [CustomAction.ListMembers]: {\n        roles: fallbackRolesCanListMembers,\n      },\n      [CustomAction.Impersonate]: {\n        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n      },\n      [CustomAction.ListMembersPrivate]: {\n        roles: fallbackRolesCanListMembers,\n      },\n    },\n  });\n\n  // Map specific permissions to member actions\n  const memberPermissions = {\n    canListMembers: team.isPrivate\n      ? permissions[CustomAction.ListMembersPrivate]\n      : permissions[CustomAction.ListMembers],\n    canInvite: permissions[CustomAction.Invite],\n    canChangeMemberRole: permissions[CustomAction.ChangeMemberRole],\n    canRemove: permissions[CustomAction.Remove],\n    canImpersonate: permissions[CustomAction.Impersonate],\n  };\n\n  const facetedTeamValues = {\n    roles,\n    teams: [team],\n    attributes: attributes.map((attribute) => ({\n      id: attribute.id,\n      name: attribute.name,\n      options: Array.from(new Set(attribute.options.map((option) => option.value))).map((value) => ({\n        value,\n      })),\n    })),\n  };\n\n  return (\n    <SettingsHeader title={t(\"team_members\")} description={t(\"members_team_description\")}>\n      <TeamMembersView\n        team={team}\n        facetedTeamValues={facetedTeamValues}\n        attributes={attributes}\n        permissions={memberPermissions}\n      />\n    </SettingsHeader>\n  );\n};\n\nexport default Page;",
            "cost": 0.05942000000000001
        },
        "calcom__cal.com.main/packages/features/ee/teams/components/EditMemberSheet.tsx": {
            "output": "import { zodResolver } from \"@hookform/resolvers/zod\";\nimport type { Dispatch } from \"react\";\nimport { useMemo, useState } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { z } from \"zod\";\nimport { shallow } from \"zustand/shallow\";\n\nimport { DisplayInfo } from \"@calcom/features/users/components/UserTable/EditSheet/DisplayInfo\";\nimport { SheetFooterControls } from \"@calcom/features/users/components/UserTable/EditSheet/SheetFooterControls\";\nimport { useEditMode } from \"@calcom/features/users/components/UserTable/EditSheet/store\";\nimport { useLocale } from \"@calcom/lib/hooks/useLocale\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\nimport { trpc } from \"@calcom/trpc/react\";\nimport { Avatar } from \"@calcom/ui/components/avatar\";\nimport { Form } from \"@calcom/ui/components/form\";\nimport { ToggleGroup, Select } from \"@calcom/ui/components/form\";\nimport { Icon } from \"@calcom/ui/components/icon\";\nimport { Sheet, SheetContent, SheetFooter, SheetHeader, SheetBody } from \"@calcom/ui/components/sheet\";\nimport { Skeleton, Loader } from \"@calcom/ui/components/skeleton\";\nimport { showToast } from \"@calcom/ui/components/toast\";\nimport { Tooltip } from \"@calcom/ui/components/tooltip\";\n\nimport { updateRoleInCache, getUpdatedUser } from \"./MemberChangeRoleModal\";\nimport type { Action, State, User } from \"./MemberList\";\n\nconst formSchema = z.object({\n  role: z.union([z.nativeEnum(MembershipRole), z.string()]), // Support both traditional roles and custom role IDs\n});\n\ntype FormSchema = z.infer<typeof formSchema>;\n\nexport function EditMemberSheet({\n  state,\n  dispatch,\n  currentMember,\n  teamId,\n}: {\n  state: State;\n  dispatch: Dispatch<Action>;\n  currentMember: MembershipRole;\n  teamId: number;\n}) {\n  const { t } = useLocale();\n  const { user } = state.editSheet;\n  const selectedUser = user as User;\n  const [editMode, setEditMode, setMutationLoading] = useEditMode(\n    (state) => [state.editMode, state.setEditMode, state.setMutationLoading],\n    shallow\n  );\n  const [role, setRole] = useState<string>(selectedUser.customRoleId || selectedUser.role);\n  const name =\n    selectedUser.name ||\n    (() => {\n      const emailName = selectedUser.email.split(\"@\")[0] as string;\n      return emailName.charAt(0).toUpperCase() + emailName.slice(1);\n    })();\n\n  const bookerUrl = selectedUser.bookerUrl;\n  const utils = trpc.useUtils();\n  const bookerUrlWithoutProtocol = bookerUrl.replace(/^https?:\\/\\//, \"\");\n  const bookingLink = !!selectedUser.username ? `${bookerUrlWithoutProtocol}/${selectedUser.username}` : \"\";\n\n  // Load custom roles for the team\n  const { data: customRoles, isPending: isLoadingRoles } = trpc.viewer.pbac.getTeamRoles.useQuery(\n    { teamId },\n    {\n      enabled: !!teamId,\n      retry: false, // Don't retry if PBAC is not enabled\n    }\n  );\n\n  const options = useMemo(() => {\n    // If we have custom roles, only show custom roles\n    if (customRoles && customRoles.length > 0) {\n      return customRoles.map((customRole) => ({\n        label: customRole.name,\n        value: customRole.id,\n      }));\n    }\n\n    // Otherwise, show traditional roles\n    return [\n      {\n        label: t(\"member\"),\n        value: MembershipRole.MEMBER,\n      },\n      {\n        label: t(\"admin\"),\n        value: MembershipRole.ADMIN,\n      },\n      {\n        label: t(\"owner\"),\n        value: MembershipRole.OWNER,\n      },\n    ].filter(({ value }) => value !== MembershipRole.OWNER || currentMember === MembershipRole.OWNER);\n  }, [t, currentMember, customRoles]);\n\n  // Determine if we should use Select (when custom roles exist) or ToggleGroup (traditional only)\n  const hasCustomRoles = customRoles && customRoles.length > 0;\n  const shouldUseSelect = hasCustomRoles; // Use Select for custom roles, ToggleGroup for traditional roles\n\n  const form = useForm({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      role: selectedUser.customRoleId || selectedUser.role, // Use custom role ID if available, otherwise traditional role\n    },\n  });\n\n  const { data: getUserConnectedApps, isPending } = trpc.viewer.teams.getUserConnectedApps.useQuery({\n    userIds: [selectedUser.id],\n    teamId,\n  });\n\n  const connectedApps = getUserConnectedApps?.[selectedUser.id];\n\n  const changeRoleMutation = trpc.viewer.teams.changeMemberRole.useMutation({\n    onMutate: async ({ teamId, memberId, role }) => {\n      await utils.viewer.teams.listMembers.cancel();\n      const previousValue = utils.viewer.teams.listMembers.getInfiniteData({\n        limit: 10,\n        teamId,\n        searchTerm: undefined,\n      });\n\n      if (previousValue) {\n        updateRoleInCache({\n          utils,\n          teamId,\n          memberId,\n          role: role as MembershipRole | string,\n          searchTerm: undefined,\n          customRoles,\n        });\n      }\n\n      return { previousValue };\n    },\n    onSuccess: async (_data, { role }) => {\n      setRole(role as string);\n      setMutationLoading(false);\n      await utils.viewer.teams.get.invalidate();\n      await utils.viewer.teams.listMembers.invalidate();\n      showToast(t(\"profile_updated_successfully\"), \"success\");\n      setEditMode(false);\n\n      dispatch({\n        type: \"EDIT_USER_SHEET\",\n        payload: {\n          showModal: true,\n          user: getUpdatedUser(selectedUser, role, customRoles),\n        },\n      });\n    },\n    async onError(err) {\n      showToast(err.message, \"error\");\n      setMutationLoading(false);\n    },\n  });\n\n  function changeRole(values: FormSchema) {\n    setMutationLoading(true);\n    changeRoleMutation.mutate({\n      teamId: teamId,\n      memberId: user?.id as number,\n      role: values.role,\n    });\n  }\n\n  const appList = (connectedApps || []).map(({ logo, name, externalId }) => {\n    return logo ? (\n      externalId ? (\n        <div className=\"ltr:mr-2 rtl:ml-2 \">\n          <Tooltip content={externalId}>\n            <img className=\"h-5 w-5\" src={logo} alt={`${name} logo`} />\n          </Tooltip>\n        </div>\n      ) : (\n        <div className=\"ltr:mr-2 rtl:ml-2\">\n          <img className=\"h-5 w-5\" src={logo} alt={`${name} logo`} />\n        </div>\n      )\n    ) : null;\n  });\n\n  return (\n    <Sheet\n      open={true}\n      onOpenChange={() => {\n        setEditMode(false);\n        dispatch({ type: \"CLOSE_MODAL\" });\n      }}>\n      <SheetContent className=\"bg-cal-muted\">\n        {!isPending && !isLoadingRoles ? (\n          <Form form={form} handleSubmit={changeRole} className=\"flex h-full flex-col\">\n            <SheetHeader showCloseButton={false} className=\"w-full\">\n              <div className=\"border-sublte bg-default w-full rounded-xl border p-4\">\n                <div\n                  className=\"block w-full rounded-lg ring-1 ring-[#0000000F]\"\n                  style={{\n                    background: \"linear-gradient(to top right, var(--cal-bg-emphasis), var(--cal-bg))\",\n                    height: \"110px\",\n                  }}\n                />\n                <div className=\"bg-default ml-3 w-fit translate-y-[-50%] rounded-full p-1 ring-1 ring-[#0000000F]\">\n                  <Avatar asChild size=\"lg\" alt={`${name} avatar`} imageSrc={selectedUser.avatarUrl} />\n                </div>\n                <Skeleton as=\"p\" waitForTranslation={false}>\n                  <h2 className=\"text-emphasis font-sans text-2xl font-semibold\">\n                    {name || \"Nameless User\"}\n                  </h2>\n                </Skeleton>\n                <Skeleton as=\"p\" waitForTranslation={false}>\n                  <p className=\"text-subtle max-h-[3em] overflow-hidden text-ellipsis text-sm font-normal\">\n                    {selectedUser.bio ? selectedUser?.bio : t(\"user_has_no_bio\")}\n                  </p>\n                </Skeleton>\n              </div>\n            </SheetHeader>\n            <SheetBody className=\"flex flex-col stack-y-4 p-4\">\n              <div className=\"mb-4 flex flex-col stack-y-4\">\n                <h3 className=\"text-emphasis mb-1 text-base font-semibold\">{t(\"profile\")}</h3>\n                <DisplayInfo label=\"Cal\" value={bookingLink} icon=\"external-link\" />\n                <DisplayInfo label={t(\"email\")} value={selectedUser.email} icon=\"at-sign\" />\n                {!editMode ? (\n                  <DisplayInfo\n                    label={t(\"role\")}\n                    value={[selectedUser.customRole?.name || selectedUser.role]}\n                    icon=\"fingerprint\"\n                  />\n                ) : (\n                  <div className=\"flex items-center gap-6\">\n                    <div className=\"flex w-[110px] items-center gap-2\">\n                      <Icon className=\"h-4 w-4\" name=\"fingerprint\" />\n                      <label className=\"text-sm font-medium\">{t(\"role\")}</label>\n                    </div>\n                    <div className=\"flex flex-1\">\n                      {shouldUseSelect ? (\n                        <Select\n                          value={options.find((option) => option.value === form.watch(\"role\"))}\n                          onChange={(selectedOption: any) => {\n                            if (selectedOption) {\n                              form.setValue(\"role\", selectedOption.value);\n                            }\n                          }}\n                          options={options}\n                          isDisabled={isLoadingRoles}\n                          placeholder={isLoadingRoles ? t(\"loading\") : t(\"select_role\")}\n                          className=\"flex-1\"\n                        />\n                      ) : (\n                        <ToggleGroup\n                          isFullWidth\n                          defaultValue={role}\n                          value={form.watch(\"role\")}\n                          options={options}\n                          onValueChange={(value: FormSchema[\"role\"]) => {\n                            form.setValue(\"role\", value);\n                          }}\n                        />\n                      )}\n                    </div>\n                  </div>\n                )}\n                <div className=\"flex items-center gap-6\">\n                  <div className=\"flex w-[110px] items-center gap-2\">\n                    <Icon className=\"text-subtle h-4 w-4\" name=\"grid-3x3\" />\n                    <label className=\"text-subtle text-sm font-medium\">{t(\"apps\")}</label>\n                  </div>\n                  <div className=\"flex flex-1\">\n                    {!connectedApps ? (\n                      <div>{t(\"user_has_no_app_installed\")}</div>\n                    ) : (\n                      <div className=\"flex\">{appList}</div>\n                    )}\n                  </div>\n                </div>\n              </div>\n            </SheetBody>\n            <SheetFooter className=\"mt-auto\">\n              <SheetFooterControls />\n            </SheetFooter>\n          </Form>\n        ) : (\n          <Loader />\n        )}\n      </SheetContent>\n    </Sheet>\n  );\n}",
            "output_extracted": "import { zodResolver } from \"@hookform/resolvers/zod\";\nimport type { Dispatch } from \"react\";\nimport { useMemo, useState } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { z } from \"zod\";\nimport { shallow } from \"zustand/shallow\";\n\nimport { DisplayInfo } from \"@calcom/features/users/components/UserTable/EditSheet/DisplayInfo\";\nimport { SheetFooterControls } from \"@calcom/features/users/components/UserTable/EditSheet/SheetFooterControls\";\nimport { useEditMode } from \"@calcom/features/users/components/UserTable/EditSheet/store\";\nimport { useLocale } from \"@calcom/lib/hooks/useLocale\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\nimport { trpc } from \"@calcom/trpc/react\";\nimport { Avatar } from \"@calcom/ui/components/avatar\";\nimport { Form } from \"@calcom/ui/components/form\";\nimport { ToggleGroup, Select } from \"@calcom/ui/components/form\";\nimport { Icon } from \"@calcom/ui/components/icon\";\nimport { Sheet, SheetContent, SheetFooter, SheetHeader, SheetBody } from \"@calcom/ui/components/sheet\";\nimport { Skeleton, Loader } from \"@calcom/ui/components/skeleton\";\nimport { showToast } from \"@calcom/ui/components/toast\";\nimport { Tooltip } from \"@calcom/ui/components/tooltip\";\n\nimport { updateRoleInCache, getUpdatedUser } from \"./MemberChangeRoleModal\";\nimport type { Action, State, User } from \"./MemberList\";\n\nconst formSchema = z.object({\n  role: z.union([z.nativeEnum(MembershipRole), z.string()]), // Support both traditional roles and custom role IDs\n});\n\ntype FormSchema = z.infer<typeof formSchema>;\n\nexport function EditMemberSheet({\n  state,\n  dispatch,\n  currentMember,\n  teamId,\n}: {\n  state: State;\n  dispatch: Dispatch<Action>;\n  currentMember: MembershipRole;\n  teamId: number;\n}) {\n  const { t } = useLocale();\n  const { user } = state.editSheet;\n  const selectedUser = user as User;\n  const [editMode, setEditMode, setMutationLoading] = useEditMode(\n    (state) => [state.editMode, state.setEditMode, state.setMutationLoading],\n    shallow\n  );\n  const [role, setRole] = useState<string>(selectedUser.customRoleId || selectedUser.role);\n  const name =\n    selectedUser.name ||\n    (() => {\n      const emailName = selectedUser.email.split(\"@\")[0] as string;\n      return emailName.charAt(0).toUpperCase() + emailName.slice(1);\n    })();\n\n  const bookerUrl = selectedUser.bookerUrl;\n  const utils = trpc.useUtils();\n  const bookerUrlWithoutProtocol = bookerUrl.replace(/^https?:\\/\\//, \"\");\n  const bookingLink = !!selectedUser.username ? `${bookerUrlWithoutProtocol}/${selectedUser.username}` : \"\";\n\n  // Load custom roles for the team\n  const { data: customRoles, isPending: isLoadingRoles } = trpc.viewer.pbac.getTeamRoles.useQuery(\n    { teamId },\n    {\n      enabled: !!teamId,\n      retry: false, // Don't retry if PBAC is not enabled\n    }\n  );\n\n  const options = useMemo(() => {\n    // If we have custom roles, only show custom roles\n    if (customRoles && customRoles.length > 0) {\n      return customRoles.map((customRole) => ({\n        label: customRole.name,\n        value: customRole.id,\n      }));\n    }\n\n    // Otherwise, show traditional roles\n    return [\n      {\n        label: t(\"member\"),\n        value: MembershipRole.MEMBER,\n      },\n      {\n        label: t(\"admin\"),\n        value: MembershipRole.ADMIN,\n      },\n      {\n        label: t(\"owner\"),\n        value: MembershipRole.OWNER,\n      },\n    ].filter(({ value }) => value !== MembershipRole.OWNER || currentMember === MembershipRole.OWNER);\n  }, [t, currentMember, customRoles]);\n\n  // Determine if we should use Select (when custom roles exist) or ToggleGroup (traditional only)\n  const hasCustomRoles = customRoles && customRoles.length > 0;\n  const shouldUseSelect = hasCustomRoles; // Use Select for custom roles, ToggleGroup for traditional roles\n\n  const form = useForm({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      role: selectedUser.customRoleId || selectedUser.role, // Use custom role ID if available, otherwise traditional role\n    },\n  });\n\n  const { data: getUserConnectedApps, isPending } = trpc.viewer.teams.getUserConnectedApps.useQuery({\n    userIds: [selectedUser.id],\n    teamId,\n  });\n\n  const connectedApps = getUserConnectedApps?.[selectedUser.id];\n\n  const changeRoleMutation = trpc.viewer.teams.changeMemberRole.useMutation({\n    onMutate: async ({ teamId, memberId, role }) => {\n      await utils.viewer.teams.listMembers.cancel();\n      const previousValue = utils.viewer.teams.listMembers.getInfiniteData({\n        limit: 10,\n        teamId,\n        searchTerm: undefined,\n      });\n\n      if (previousValue) {\n        updateRoleInCache({\n          utils,\n          teamId,\n          memberId,\n          role: role as MembershipRole | string,\n          searchTerm: undefined,\n          customRoles,\n        });\n      }\n\n      return { previousValue };\n    },\n    onSuccess: async (_data, { role }) => {\n      setRole(role as string);\n      setMutationLoading(false);\n      await utils.viewer.teams.get.invalidate();\n      await utils.viewer.teams.listMembers.invalidate();\n      showToast(t(\"profile_updated_successfully\"), \"success\");\n      setEditMode(false);\n\n      dispatch({\n        type: \"EDIT_USER_SHEET\",\n        payload: {\n          showModal: true,\n          user: getUpdatedUser(selectedUser, role, customRoles),\n        },\n      });\n    },\n    async onError(err) {\n      showToast(err.message, \"error\");\n      setMutationLoading(false);\n    },\n  });\n\n  function changeRole(values: FormSchema) {\n    setMutationLoading(true);\n    changeRoleMutation.mutate({\n      teamId: teamId,\n      memberId: user?.id as number,\n      role: values.role,\n    });\n  }\n\n  const appList = (connectedApps || []).map(({ logo, name, externalId }) => {\n    return logo ? (\n      externalId ? (\n        <div className=\"ltr:mr-2 rtl:ml-2 \">\n          <Tooltip content={externalId}>\n            <img className=\"h-5 w-5\" src={logo} alt={`${name} logo`} />\n          </Tooltip>\n        </div>\n      ) : (\n        <div className=\"ltr:mr-2 rtl:ml-2\">\n          <img className=\"h-5 w-5\" src={logo} alt={`${name} logo`} />\n        </div>\n      )\n    ) : null;\n  });\n\n  return (\n    <Sheet\n      open={true}\n      onOpenChange={() => {\n        setEditMode(false);\n        dispatch({ type: \"CLOSE_MODAL\" });\n      }}>\n      <SheetContent className=\"bg-cal-muted\">\n        {!isPending && !isLoadingRoles ? (\n          <Form form={form} handleSubmit={changeRole} className=\"flex h-full flex-col\">\n            <SheetHeader showCloseButton={false} className=\"w-full\">\n              <div className=\"border-sublte bg-default w-full rounded-xl border p-4\">\n                <div\n                  className=\"block w-full rounded-lg ring-1 ring-[#0000000F]\"\n                  style={{\n                    background: \"linear-gradient(to top right, var(--cal-bg-emphasis), var(--cal-bg))\",\n                    height: \"110px\",\n                  }}\n                />\n                <div className=\"bg-default ml-3 w-fit translate-y-[-50%] rounded-full p-1 ring-1 ring-[#0000000F]\">\n                  <Avatar asChild size=\"lg\" alt={`${name} avatar`} imageSrc={selectedUser.avatarUrl} />\n                </div>\n                <Skeleton as=\"p\" waitForTranslation={false}>\n                  <h2 className=\"text-emphasis font-sans text-2xl font-semibold\">\n                    {name || \"Nameless User\"}\n                  </h2>\n                </Skeleton>\n                <Skeleton as=\"p\" waitForTranslation={false}>\n                  <p className=\"text-subtle max-h-[3em] overflow-hidden text-ellipsis text-sm font-normal\">\n                    {selectedUser.bio ? selectedUser?.bio : t(\"user_has_no_bio\")}\n                  </p>\n                </Skeleton>\n              </div>\n            </SheetHeader>\n            <SheetBody className=\"flex flex-col stack-y-4 p-4\">\n              <div className=\"mb-4 flex flex-col stack-y-4\">\n                <h3 className=\"text-emphasis mb-1 text-base font-semibold\">{t(\"profile\")}</h3>\n                <DisplayInfo label=\"Cal\" value={bookingLink} icon=\"external-link\" />\n                <DisplayInfo label={t(\"email\")} value={selectedUser.email} icon=\"at-sign\" />\n                {!editMode ? (\n                  <DisplayInfo\n                    label={t(\"role\")}\n                    value={[selectedUser.customRole?.name || selectedUser.role]}\n                    icon=\"fingerprint\"\n                  />\n                ) : (\n                  <div className=\"flex items-center gap-6\">\n                    <div className=\"flex w-[110px] items-center gap-2\">\n                      <Icon className=\"h-4 w-4\" name=\"fingerprint\" />\n                      <label className=\"text-sm font-medium\">{t(\"role\")}</label>\n                    </div>\n                    <div className=\"flex flex-1\">\n                      {shouldUseSelect ? (\n                        <Select\n                          value={options.find((option) => option.value === form.watch(\"role\"))}\n                          onChange={(selectedOption: any) => {\n                            if (selectedOption) {\n                              form.setValue(\"role\", selectedOption.value);\n                            }\n                          }}\n                          options={options}\n                          isDisabled={isLoadingRoles}\n                          placeholder={isLoadingRoles ? t(\"loading\") : t(\"select_role\")}\n                          className=\"flex-1\"\n                        />\n                      ) : (\n                        <ToggleGroup\n                          isFullWidth\n                          defaultValue={role}\n                          value={form.watch(\"role\")}\n                          options={options}\n                          onValueChange={(value: FormSchema[\"role\"]) => {\n                            form.setValue(\"role\", value);\n                          }}\n                        />\n                      )}\n                    </div>\n                  </div>\n                )}\n                <div className=\"flex items-center gap-6\">\n                  <div className=\"flex w-[110px] items-center gap-2\">\n                    <Icon className=\"text-subtle h-4 w-4\" name=\"grid-3x3\" />\n                    <label className=\"text-subtle text-sm font-medium\">{t(\"apps\")}</label>\n                  </div>\n                  <div className=\"flex flex-1\">\n                    {!connectedApps ? (\n                      <div>{t(\"user_has_no_app_installed\")}</div>\n                    ) : (\n                      <div className=\"flex\">{appList}</div>\n                    )}\n                  </div>\n                </div>\n              </div>\n            </SheetBody>\n            <SheetFooter className=\"mt-auto\">\n              <SheetFooterControls />\n            </SheetFooter>\n          </Form>\n        ) : (\n          <Loader />\n        )}\n      </SheetContent>\n    </Sheet>\n  );\n}",
            "cost": 0.101795
        },
        "calcom__cal.com.main/packages/features/ee/teams/components/MemberList.tsx": {
            "output": "\"use client\";\n\nimport { keepPreviousData } from \"@tanstack/react-query\";\nimport {\n  getCoreRowModel,\n  getFilteredRowModel,\n  getSortedRowModel,\n  useReactTable,\n  type ColumnDef,\n} from \"@tanstack/react-table\";\nimport classNames from \"classnames\";\nimport { useSession } from \"next-auth/react\";\nimport posthog from \"posthog-js\";\nimport { signIn } from \"next-auth/react\";\nimport { usePathname } from \"next/navigation\";\nimport { useQueryState, parseAsBoolean } from \"nuqs\";\nimport { useMemo, useReducer, useRef, useState } from \"react\";\nimport type { Dispatch, SetStateAction } from \"react\";\n\nimport { Dialog } from \"@calcom/features/components/controlled-dialog\";\nimport {\n  DataTableProvider,\n  DataTableToolbar,\n  DataTableFilters,\n  DataTableWrapper,\n  DataTableSelectionBar,\n  useDataTable,\n  useFetchMoreOnBottomReached,\n  useColumnFilters,\n  convertFacetedValuesToMap,\n} from \"@calcom/features/data-table\";\nimport { useOrgBranding } from \"@calcom/features/ee/organizations/context/provider\";\nimport { DynamicLink } from \"@calcom/features/users/components/UserTable/BulkActions/DynamicLink\";\nimport type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\nimport { WEBAPP_URL } from \"@calcom/lib/constants\";\nimport { getUserAvatarUrl } from \"@calcom/lib/getAvatarUrl\";\nimport { useLocale } from \"@calcom/lib/hooks/useLocale\";\nimport { trpc } from \"@calcom/trpc\";\nimport type { RouterOutputs } from \"@calcom/trpc/react\";\nimport { Avatar } from \"@calcom/ui/components/avatar\";\nimport { Badge } from \"@calcom/ui/components/badge\";\nimport { Button } from \"@calcom/ui/components/button\";\nimport { ButtonGroup } from \"@calcom/ui/components/buttonGroup\";\nimport {\n  DialogContent,\n  DialogFooter,\n  DialogClose,\n  ConfirmationDialogContent,\n} from \"@calcom/ui/components/dialog\";\nimport {\n  Dropdown,\n  DropdownItem,\n  DropdownMenuPortal,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@calcom/ui/components/dropdown\";\nimport { Checkbox } from \"@calcom/ui/components/form\";\nimport { showToast } from \"@calcom/ui/components/toast\";\nimport { Tooltip } from \"@calcom/ui/components/tooltip\";\n\nimport DeleteBulkTeamMembers from \"./DeleteBulkTeamMembers\";\nimport { EditMemberSheet } from \"./EditMemberSheet\";\nimport { EventTypesList } from \"./EventTypesList\";\nimport TeamAvailabilityModal from \"./TeamAvailabilityModal\";\n\ninterface Props {\n  team: NonNullable<RouterOutputs[\"viewer\"][\"teams\"][\"get\"]>;\n  isOrgAdminOrOwner: boolean | undefined;\n  setShowMemberInvitationModal: Dispatch<SetStateAction<boolean>>;\n}\n\nexport type User = RouterOutputs[\"viewer\"][\"teams\"][\"listMembers\"][\"members\"][number];\n\nconst checkIsOrg = (team: Props[\"team\"]) => {\n  return team.isOrganization;\n};\n\ntype Payload = {\n  showModal: boolean;\n  user?: User;\n};\n\nexport type State = {\n  deleteMember: Payload;\n  impersonateMember: Payload;\n  editSheet: Payload;\n  teamAvailability: Payload;\n};\n\nexport type Action =\n  | {\n      type:\n        | \"SET_DELETE_ID\"\n        | \"SET_IMPERSONATE_ID\"\n        | \"EDIT_USER_SHEET\"\n        | \"TEAM_AVAILABILITY\"\n        | \"INVITE_MEMBER\";\n      payload: Payload;\n    }\n  | {\n      type: \"CLOSE_MODAL\";\n    };\n\nconst initialState: State = {\n  deleteMember: {\n    showModal: false,\n  },\n  impersonateMember: {\n    showModal: false,\n  },\n  editSheet: {\n    showModal: false,\n  },\n  teamAvailability: {\n    showModal: false,\n  },\n};\n\nconst initalColumnVisibility = {\n  select: true,\n  member: true,\n  role: true,\n  teams: true,\n  actions: true,\n};\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case \"SET_DELETE_ID\":\n      return { ...state, deleteMember: action.payload };\n    case \"SET_IMPERSONATE_ID\":\n      return { ...state, impersonateMember: action.payload };\n    case \"EDIT_USER_SHEET\":\n      return { ...state, editSheet: action.payload };\n    case \"TEAM_AVAILABILITY\":\n      return { ...state, teamAvailability: action.payload };\n    case \"CLOSE_MODAL\":\n      return {\n        ...state,\n        deleteMember: { showModal: false },\n        impersonateMember: { showModal: false },\n        editSheet: { showModal: false },\n        teamAvailability: { showModal: false },\n      };\n    default:\n      return state;\n  }\n}\n\ninterface Props {\n  team: NonNullable<RouterOutputs[\"viewer\"][\"teams\"][\"get\"]>;\n  isOrgAdminOrOwner: boolean | undefined;\n  setShowMemberInvitationModal: Dispatch<SetStateAction<boolean>>;\n  facetedTeamValues?: {\n    roles: { id: string; name: string }[];\n    teams: RouterOutputs[\"viewer\"][\"teams\"][\"get\"][];\n    attributes: {\n      id: string;\n      name: string;\n      options: {\n        value: string;\n      }[];\n    }[];\n  };\n  permissions: MemberPermissions;\n}\n\nexport default function MemberList(props: Props) {\n  const pathname = usePathname();\n  if (!pathname) return null;\n  return (\n    <DataTableProvider tableIdentifier={pathname}>\n      <MemberListContent {...props} />\n    </DataTableProvider>\n  );\n}\n\nfunction MemberListContent(props: Props) {\n  const { facetedTeamValues } = props;\n  const [dynamicLinkVisible, setDynamicLinkVisible] = useQueryState(\"dynamicLink\", parseAsBoolean);\n  const { t, i18n } = useLocale();\n  const { data: session } = useSession();\n\n  const utils = trpc.useUtils();\n  const orgBranding = useOrgBranding();\n  const domain = orgBranding?.fullDomain ?? WEBAPP_URL;\n\n  const tableContainerRef = useRef<HTMLDivElement>(null);\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const { searchTerm } = useDataTable();\n\n  const { data, isPending, hasNextPage, fetchNextPage, isFetching } =\n    trpc.viewer.teams.listMembers.useInfiniteQuery(\n      {\n        limit: 10,\n        searchTerm,\n        teamId: props.team.id,\n        // TODO: send `columnFilters` to server for server side filtering\n        // filters: columnFilters,\n      },\n      {\n        enabled: !!props.team.id,\n        getNextPageParam: (lastPage) => lastPage.nextCursor,\n        placeholderData: keepPreviousData,\n        refetchOnWindowFocus: true,\n        refetchOnMount: true,\n        staleTime: 0,\n      }\n    );\n\n  const columnFilters = useColumnFilters();\n  const [rowSelection, setRowSelection] = useState({});\n\n  const removeMemberFromCache = ({\n    utils,\n    memberId,\n    teamId,\n    searchTerm,\n  }: {\n    utils: ReturnType<typeof trpc.useUtils>;\n    memberId: number;\n    teamId: number;\n    searchTerm: string;\n  }) => {\n    utils.viewer.teams.listMembers.setInfiniteData(\n      {\n        limit: 10,\n        teamId,\n        searchTerm,\n      },\n      (data) => {\n        if (!data) {\n          return {\n            pages: [],\n            pageParams: [],\n          };\n        }\n\n        return {\n          ...data,\n          pages: data.pages.map((page) => ({\n            ...page,\n            members: page.members.filter((member) => member.id !== memberId),\n          })),\n        };\n      }\n    );\n  };\n\n  const removeMemberMutation = trpc.viewer.teams.removeMember.useMutation({\n    onMutate: async ({ teamIds }) => {\n      await utils.viewer.teams.listMembers.cancel();\n      const previousValue = utils.viewer.teams.listMembers.getInfiniteData({\n        limit: 10,\n        teamId: teamIds[0],\n        searchTerm,\n      });\n\n      if (previousValue) {\n        removeMemberFromCache({\n          utils,\n          memberId: state.deleteMember.user?.id as number,\n          teamId: teamIds[0],\n          searchTerm,\n        });\n      }\n      return { previousValue };\n    },\n    async onSuccess() {\n      await utils.viewer.teams.get.invalidate();\n      await utils.viewer.eventTypes.invalidate();\n      await utils.viewer.organizations.listMembers.invalidate();\n      await utils.viewer.organizations.getMembers.invalidate();\n      showToast(t(\"success\"), \"success\");\n    },\n    async onError(err) {\n      showToast(err.message, \"error\");\n    },\n  });\n\n  const resendInvitationMutation = trpc.viewer.teams.resendInvitation.useMutation({\n    onSuccess: () => {\n      showToast(t(\"invitation_resent\"), \"success\");\n    },\n    onError: (error) => {\n      showToast(error.message, \"error\");\n    },\n  });\n\n  // const ownersInTeam = () => {\n  //   const { members } = props.team;\n  //   const owners = members.filter((member) => member[\"role\"] === MembershipRole.OWNER && member[\"accepted\"]);\n  //   return owners.length;\n  // };\n\n  const removeMember = () =>\n    removeMemberMutation.mutate({\n      teamIds: [props.team?.id],\n      memberIds: [state.deleteMember.user?.id as number],\n      isOrg: checkIsOrg(props.team),\n    });\n\n  const totalRowCount = data?.pages?.[0]?.meta?.totalRowCount ?? 0;\n\n  const memorisedColumns = useMemo(() => {\n    const cols: ColumnDef<User>[] = [\n      // Disabling select for this PR: Will work on actions etc in a follow up\n      {\n        id: \"select\",\n        enableHiding: false,\n        enableSorting: false,\n        enableResizing: false,\n        size: 30,\n        header: ({ table }) => (\n          <Checkbox\n            checked={table.getIsAllPageRowsSelected()}\n            onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}\n            aria-label=\"Select all\"\n          />\n        ),\n        cell: ({ row }) => (\n          <Checkbox\n            checked={row.getIsSelected()}\n            onCheckedChange={(value) => row.toggleSelected(!!value)}\n            aria-label=\"Select row\"\n            className=\"translate-y-[2px]\"\n          />\n        ),\n      },\n      {\n        id: \"member\",\n        accessorFn: (data) => data.email,\n        enableHiding: false,\n        header: \"Member\",\n        size: 250,\n        cell: ({ row }) => {\n          const { username, email, avatarUrl, accepted, name } = row.original;\n          const memberName =\n            name ||\n            (() => {\n              const emailName = email.split(\"@\")[0];\n              return emailName.charAt(0).toUpperCase() + emailName.slice(1);\n            })();\n          return (\n            <div className=\"flex items-center gap-2\">\n              <Avatar\n                size=\"sm\"\n                alt={username || email}\n                imageSrc={getUserAvatarUrl({\n                  avatarUrl,\n                })}\n              />\n              <div data-testid={`member-${username}`}>\n                <div data-testid=\"member-name\" className=\"text-emphasis text-sm font-medium leading-none\">\n                  {memberName}\n                </div>\n                <div\n                  data-testid={accepted ? \"member-email\" : `email-${email.replace(\"@\", \"\")}-pending`}\n                  className=\"text-subtle mt-1 text-sm leading-none\">\n                  {email}\n                </div>\n              </div>\n            </div>\n          );\n        },\n        filterFn: (rows, id, filterValue) => {\n          const { data } = filterValue;\n          const userEmail = rows.original.email;\n          return data.includes(userEmail);\n        },\n      },\n      {\n        id: \"role\",\n        accessorFn: (data) => data.role,\n        header: \"Role\",\n        size: 100,\n        cell: ({ row, table }) => {\n          const { role, accepted, customRole } = row.original;\n          const roleName = customRole?.name || role;\n          const roleIdentifier = customRole?.id || role;\n          return (\n            <div className=\"flex h-full flex-wrap items-center gap-2\">\n              {!accepted && (\n                <Badge\n                  data-testid=\"member-pending\"\n                  variant=\"orange\"\n                  className=\"text-xs\"\n                  onClick={() => {\n                    table.getColumn(\"role\")?.setFilterValue([\"PENDING\"]);\n                  }}>\n                  Pending\n                </Badge>\n              )}\n              <Badge\n                data-testid=\"member-role\"\n                variant={role === \"MEMBER\" ? \"gray\" : \"blue\"}\n                onClick={() => {\n                  table.getColumn(\"role\")?.setFilterValue([roleIdentifier]);\n                }}>\n                {roleName}\n              </Badge>\n            </div>\n          );\n        },\n        filterFn: (rows, id, filterValue) => {\n          const { data } = filterValue;\n          const { role, accepted, customRole } = rows.original;\n          const roleIdentifier = customRole?.id || role;\n\n          if (data.includes(\"PENDING\")) {\n            if (data.length === 1) return !accepted;\n            else return !accepted || data.includes(roleIdentifier);\n          }\n\n          // Show only the selected roles (check both traditional role and custom role ID)\n          return data.includes(roleIdentifier);\n        },\n      },\n      {\n        id: \"lastActiveAt\",\n        header: \"Last Active\",\n        cell: ({ row }) => <div>{row.original.lastActiveAt}</div>,\n      },\n      {\n        id: \"actions\",\n        size: 90,\n        enableResizing: false,\n        cell: ({ row }) => {\n          const user = row.original;\n          const isSelf = user.id === session?.user.id;\n          // TODO(SEAN) In a follow up can we rename canChangeMemberRole to canEditMembers - role is a bit specific.\n          const canChangeRole = props.permissions?.canChangeMemberRole ?? false;\n          const canRemove = props.permissions?.canRemove ?? false;\n          const canImpersonate = props.permissions?.canImpersonate ?? false;\n          const canResendInvitation = props.permissions?.canInvite ?? false;\n          const editMode =\n            [canChangeRole, canRemove, canImpersonate, canResendInvitation].some(Boolean) && !isSelf;\n\n          const impersonationMode =\n            canImpersonate &&\n            !user.disableImpersonation &&\n            user.accepted &&\n            process.env.NEXT_PUBLIC_TEAM_IMPERSONATION === \"true\";\n          return (\n            <>\n              {props.team.membership?.accepted &&",
            "output_extracted": "\"use client\";\n\nimport { keepPreviousData } from \"@tanstack/react-query\";\nimport {\n  getCoreRowModel,\n  getFilteredRowModel,\n  getSortedRowModel,\n  useReactTable,\n  type ColumnDef,\n} from \"@tanstack/react-table\";\nimport classNames from \"classnames\";\nimport { useSession } from \"next-auth/react\";\nimport posthog from \"posthog-js\";\nimport { signIn } from \"next-auth/react\";\nimport { usePathname } from \"next/navigation\";\nimport { useQueryState, parseAsBoolean } from \"nuqs\";\nimport { useMemo, useReducer, useRef, useState } from \"react\";\nimport type { Dispatch, SetStateAction } from \"react\";\n\nimport { Dialog } from \"@calcom/features/components/controlled-dialog\";\nimport {\n  DataTableProvider,\n  DataTableToolbar,\n  DataTableFilters,\n  DataTableWrapper,\n  DataTableSelectionBar,\n  useDataTable,\n  useFetchMoreOnBottomReached,\n  useColumnFilters,\n  convertFacetedValuesToMap,\n} from \"@calcom/features/data-table\";\nimport { useOrgBranding } from \"@calcom/features/ee/organizations/context/provider\";\nimport { DynamicLink } from \"@calcom/features/users/components/UserTable/BulkActions/DynamicLink\";\nimport type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\nimport { WEBAPP_URL } from \"@calcom/lib/constants\";\nimport { getUserAvatarUrl } from \"@calcom/lib/getAvatarUrl\";\nimport { useLocale } from \"@calcom/lib/hooks/useLocale\";\nimport { trpc } from \"@calcom/trpc\";\nimport type { RouterOutputs } from \"@calcom/trpc/react\";\nimport { Avatar } from \"@calcom/ui/components/avatar\";\nimport { Badge } from \"@calcom/ui/components/badge\";\nimport { Button } from \"@calcom/ui/components/button\";\nimport { ButtonGroup } from \"@calcom/ui/components/buttonGroup\";\nimport {\n  DialogContent,\n  DialogFooter,\n  DialogClose,\n  ConfirmationDialogContent,\n} from \"@calcom/ui/components/dialog\";\nimport {\n  Dropdown,\n  DropdownItem,\n  DropdownMenuPortal,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@calcom/ui/components/dropdown\";\nimport { Checkbox } from \"@calcom/ui/components/form\";\nimport { showToast } from \"@calcom/ui/components/toast\";\nimport { Tooltip } from \"@calcom/ui/components/tooltip\";\n\nimport DeleteBulkTeamMembers from \"./DeleteBulkTeamMembers\";\nimport { EditMemberSheet } from \"./EditMemberSheet\";\nimport { EventTypesList } from \"./EventTypesList\";\nimport TeamAvailabilityModal from \"./TeamAvailabilityModal\";\n\ninterface Props {\n  team: NonNullable<RouterOutputs[\"viewer\"][\"teams\"][\"get\"]>;\n  isOrgAdminOrOwner: boolean | undefined;\n  setShowMemberInvitationModal: Dispatch<SetStateAction<boolean>>;\n}\n\nexport type User = RouterOutputs[\"viewer\"][\"teams\"][\"listMembers\"][\"members\"][number];\n\nconst checkIsOrg = (team: Props[\"team\"]) => {\n  return team.isOrganization;\n};\n\ntype Payload = {\n  showModal: boolean;\n  user?: User;\n};\n\nexport type State = {\n  deleteMember: Payload;\n  impersonateMember: Payload;\n  editSheet: Payload;\n  teamAvailability: Payload;\n};\n\nexport type Action =\n  | {\n      type:\n        | \"SET_DELETE_ID\"\n        | \"SET_IMPERSONATE_ID\"\n        | \"EDIT_USER_SHEET\"\n        | \"TEAM_AVAILABILITY\"\n        | \"INVITE_MEMBER\";\n      payload: Payload;\n    }\n  | {\n      type: \"CLOSE_MODAL\";\n    };\n\nconst initialState: State = {\n  deleteMember: {\n    showModal: false,\n  },\n  impersonateMember: {\n    showModal: false,\n  },\n  editSheet: {\n    showModal: false,\n  },\n  teamAvailability: {\n    showModal: false,\n  },\n};\n\nconst initalColumnVisibility = {\n  select: true,\n  member: true,\n  role: true,\n  teams: true,\n  actions: true,\n};\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case \"SET_DELETE_ID\":\n      return { ...state, deleteMember: action.payload };\n    case \"SET_IMPERSONATE_ID\":\n      return { ...state, impersonateMember: action.payload };\n    case \"EDIT_USER_SHEET\":\n      return { ...state, editSheet: action.payload };\n    case \"TEAM_AVAILABILITY\":\n      return { ...state, teamAvailability: action.payload };\n    case \"CLOSE_MODAL\":\n      return {\n        ...state,\n        deleteMember: { showModal: false },\n        impersonateMember: { showModal: false },\n        editSheet: { showModal: false },\n        teamAvailability: { showModal: false },\n      };\n    default:\n      return state;\n  }\n}\n\ninterface Props {\n  team: NonNullable<RouterOutputs[\"viewer\"][\"teams\"][\"get\"]>;\n  isOrgAdminOrOwner: boolean | undefined;\n  setShowMemberInvitationModal: Dispatch<SetStateAction<boolean>>;\n  facetedTeamValues?: {\n    roles: { id: string; name: string }[];\n    teams: RouterOutputs[\"viewer\"][\"teams\"][\"get\"][];\n    attributes: {\n      id: string;\n      name: string;\n      options: {\n        value: string;\n      }[];\n    }[];\n  };\n  permissions: MemberPermissions;\n}\n\nexport default function MemberList(props: Props) {\n  const pathname = usePathname();\n  if (!pathname) return null;\n  return (\n    <DataTableProvider tableIdentifier={pathname}>\n      <MemberListContent {...props} />\n    </DataTableProvider>\n  );\n}\n\nfunction MemberListContent(props: Props) {\n  const { facetedTeamValues } = props;\n  const [dynamicLinkVisible, setDynamicLinkVisible] = useQueryState(\"dynamicLink\", parseAsBoolean);\n  const { t, i18n } = useLocale();\n  const { data: session } = useSession();\n\n  const utils = trpc.useUtils();\n  const orgBranding = useOrgBranding();\n  const domain = orgBranding?.fullDomain ?? WEBAPP_URL;\n\n  const tableContainerRef = useRef<HTMLDivElement>(null);\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const { searchTerm } = useDataTable();\n\n  const { data, isPending, hasNextPage, fetchNextPage, isFetching } =\n    trpc.viewer.teams.listMembers.useInfiniteQuery(\n      {\n        limit: 10,\n        searchTerm,\n        teamId: props.team.id,\n        // TODO: send `columnFilters` to server for server side filtering\n        // filters: columnFilters,\n      },\n      {\n        enabled: !!props.team.id,\n        getNextPageParam: (lastPage) => lastPage.nextCursor,\n        placeholderData: keepPreviousData,\n        refetchOnWindowFocus: true,\n        refetchOnMount: true,\n        staleTime: 0,\n      }\n    );\n\n  const columnFilters = useColumnFilters();\n  const [rowSelection, setRowSelection] = useState({});\n\n  const removeMemberFromCache = ({\n    utils,\n    memberId,\n    teamId,\n    searchTerm,\n  }: {\n    utils: ReturnType<typeof trpc.useUtils>;\n    memberId: number;\n    teamId: number;\n    searchTerm: string;\n  }) => {\n    utils.viewer.teams.listMembers.setInfiniteData(\n      {\n        limit: 10,\n        teamId,\n        searchTerm,\n      },\n      (data) => {\n        if (!data) {\n          return {\n            pages: [],\n            pageParams: [],\n          };\n        }\n\n        return {\n          ...data,\n          pages: data.pages.map((page) => ({\n            ...page,\n            members: page.members.filter((member) => member.id !== memberId),\n          })),\n        };\n      }\n    );\n  };\n\n  const removeMemberMutation = trpc.viewer.teams.removeMember.useMutation({\n    onMutate: async ({ teamIds }) => {\n      await utils.viewer.teams.listMembers.cancel();\n      const previousValue = utils.viewer.teams.listMembers.getInfiniteData({\n        limit: 10,\n        teamId: teamIds[0],\n        searchTerm,\n      });\n\n      if (previousValue) {\n        removeMemberFromCache({\n          utils,\n          memberId: state.deleteMember.user?.id as number,\n          teamId: teamIds[0],\n          searchTerm,\n        });\n      }\n      return { previousValue };\n    },\n    async onSuccess() {\n      await utils.viewer.teams.get.invalidate();\n      await utils.viewer.eventTypes.invalidate();\n      await utils.viewer.organizations.listMembers.invalidate();\n      await utils.viewer.organizations.getMembers.invalidate();\n      showToast(t(\"success\"), \"success\");\n    },\n    async onError(err) {\n      showToast(err.message, \"error\");\n    },\n  });\n\n  const resendInvitationMutation = trpc.viewer.teams.resendInvitation.useMutation({\n    onSuccess: () => {\n      showToast(t(\"invitation_resent\"), \"success\");\n    },\n    onError: (error) => {\n      showToast(error.message, \"error\");\n    },\n  });\n\n  // const ownersInTeam = () => {\n  //   const { members } = props.team;\n  //   const owners = members.filter((member) => member[\"role\"] === MembershipRole.OWNER && member[\"accepted\"]);\n  //   return owners.length;\n  // };\n\n  const removeMember = () =>\n    removeMemberMutation.mutate({\n      teamIds: [props.team?.id],\n      memberIds: [state.deleteMember.user?.id as number],\n      isOrg: checkIsOrg(props.team),\n    });\n\n  const totalRowCount = data?.pages?.[0]?.meta?.totalRowCount ?? 0;\n\n  const memorisedColumns = useMemo(() => {\n    const cols: ColumnDef<User>[] = [\n      // Disabling select for this PR: Will work on actions etc in a follow up\n      {\n        id: \"select\",\n        enableHiding: false,\n        enableSorting: false,\n        enableResizing: false,\n        size: 30,\n        header: ({ table }) => (\n          <Checkbox\n            checked={table.getIsAllPageRowsSelected()}\n            onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}\n            aria-label=\"Select all\"\n          />\n        ),\n        cell: ({ row }) => (\n          <Checkbox\n            checked={row.getIsSelected()}\n            onCheckedChange={(value) => row.toggleSelected(!!value)}\n            aria-label=\"Select row\"\n            className=\"translate-y-[2px]\"\n          />\n        ),\n      },\n      {\n        id: \"member\",\n        accessorFn: (data) => data.email,\n        enableHiding: false,\n        header: \"Member\",\n        size: 250,\n        cell: ({ row }) => {\n          const { username, email, avatarUrl, accepted, name } = row.original;\n          const memberName =\n            name ||\n            (() => {\n              const emailName = email.split(\"@\")[0];\n              return emailName.charAt(0).toUpperCase() + emailName.slice(1);\n            })();\n          return (\n            <div className=\"flex items-center gap-2\">\n              <Avatar\n                size=\"sm\"\n                alt={username || email}\n                imageSrc={getUserAvatarUrl({\n                  avatarUrl,\n                })}\n              />\n              <div data-testid={`member-${username}`}>\n                <div data-testid=\"member-name\" className=\"text-emphasis text-sm font-medium leading-none\">\n                  {memberName}\n                </div>\n                <div\n                  data-testid={accepted ? \"member-email\" : `email-${email.replace(\"@\", \"\")}-pending`}\n                  className=\"text-subtle mt-1 text-sm leading-none\">\n                  {email}\n                </div>\n              </div>\n            </div>\n          );\n        },\n        filterFn: (rows, id, filterValue) => {\n          const { data } = filterValue;\n          const userEmail = rows.original.email;\n          return data.includes(userEmail);\n        },\n      },\n      {\n        id: \"role\",\n        accessorFn: (data) => data.role,\n        header: \"Role\",\n        size: 100,\n        cell: ({ row, table }) => {\n          const { role, accepted, customRole } = row.original;\n          const roleName = customRole?.name || role;\n          const roleIdentifier = customRole?.id || role;\n          return (\n            <div className=\"flex h-full flex-wrap items-center gap-2\">\n              {!accepted && (\n                <Badge\n                  data-testid=\"member-pending\"\n                  variant=\"orange\"\n                  className=\"text-xs\"\n                  onClick={() => {\n                    table.getColumn(\"role\")?.setFilterValue([\"PENDING\"]);\n                  }}>\n                  Pending\n                </Badge>\n              )}\n              <Badge\n                data-testid=\"member-role\"\n                variant={role === \"MEMBER\" ? \"gray\" : \"blue\"}\n                onClick={() => {\n                  table.getColumn(\"role\")?.setFilterValue([roleIdentifier]);\n                }}>\n                {roleName}\n              </Badge>\n            </div>\n          );\n        },\n        filterFn: (rows, id, filterValue) => {\n          const { data } = filterValue;\n          const { role, accepted, customRole } = rows.original;\n          const roleIdentifier = customRole?.id || role;\n\n          if (data.includes(\"PENDING\")) {\n            if (data.length === 1) return !accepted;\n            else return !accepted || data.includes(roleIdentifier);\n          }\n\n          // Show only the selected roles (check both traditional role and custom role ID)\n          return data.includes(roleIdentifier);\n        },\n      },\n      {\n        id: \"lastActiveAt\",\n        header: \"Last Active\",\n        cell: ({ row }) => <div>{row.original.lastActiveAt}</div>,\n      },\n      {\n        id: \"actions\",\n        size: 90,\n        enableResizing: false,\n        cell: ({ row }) => {\n          const user = row.original;\n          const isSelf = user.id === session?.user.id;\n          // TODO(SEAN) In a follow up can we rename canChangeMemberRole to canEditMembers - role is a bit specific.\n          const canChangeRole = props.permissions?.canChangeMemberRole ?? false;\n          const canRemove = props.permissions?.canRemove ?? false;\n          const canImpersonate = props.permissions?.canImpersonate ?? false;\n          const canResendInvitation = props.permissions?.canInvite ?? false;\n          const editMode =\n            [canChangeRole, canRemove, canImpersonate, canResendInvitation].some(Boolean) && !isSelf;\n\n          const impersonationMode =\n            canImpersonate &&\n            !user.disableImpersonation &&\n            user.accepted &&\n            process.env.NEXT_PUBLIC_TEAM_IMPERSONATION === \"true\";\n          return (\n            <>\n              {props.team.membership?.accepted &&",
            "cost": 0.14466
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25587",
        "repo": "calcom/cal.com",
        "base_commit": "1c3ced5b7040115e0ac1301e8482d49a80881d6c",
        "head_commit": "8aee08ccacf7fd36f648401cb49307442636d95d",
        "title": "fix: unable to edit member as a team owner/admin",
        "merged_at": "2025-12-03T18:14:35Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25587",
        "test_files": [
            "packages/features/ee/teams/components/EditMemberSheet.test.tsx"
        ],
        "code_files": [
            "apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx",
            "packages/features/ee/teams/components/EditMemberSheet.tsx",
            "packages/features/ee/teams/components/MemberList.tsx",
            "packages/features/pbac/lib/team-member-permissions.ts"
        ],
        "total_changes": 484,
        "num_files": 5,
        "pull_number": 25587,
        "patch": "diff --git a/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx b/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx\nindex 97adac481de73b..3cf44ce444e2a9 100644\n--- a/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx\n+++ b/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx\n@@ -5,13 +5,11 @@ import { headers, cookies } from \"next/headers\";\n import { redirect } from \"next/navigation\";\n \n import { getServerSession } from \"@calcom/features/auth/lib/getServerSession\";\n-import { Resource, CustomAction } from \"@calcom/features/pbac/domain/types/permission-registry\";\n-import { getSpecificPermissions } from \"@calcom/features/pbac/lib/resource-permissions\";\n+import { getTeamMemberPermissions } from \"@calcom/features/pbac/lib/team-member-permissions\";\n import { RoleManagementFactory } from \"@calcom/features/pbac/services/role-management.factory\";\n import SettingsHeader from \"@calcom/features/settings/appDir/SettingsHeader\";\n import { PrismaAttributeRepository } from \"@calcom/lib/server/repository/PrismaAttributeRepository\";\n import { prisma } from \"@calcom/prisma\";\n-import { MembershipRole } from \"@calcom/prisma/enums\";\n import { viewerTeamsRouter } from \"@calcom/trpc/server/routers/viewer/teams/_router\";\n \n import { buildLegacyRequest } from \"@lib/buildLegacyCtx\";\n@@ -33,7 +31,7 @@ const getCachedTeamRoles = unstable_cache(\n     try {\n       const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n       return await roleManager.getTeamRoles(teamId);\n-    } catch (error) {\n+    } catch {\n       // PBAC not enabled or error occurred, return empty array\n       return [];\n     }\n@@ -49,7 +47,7 @@ const getCachedTeamAttributes = unstable_cache(\n \n     try {\n       return await attributeRepo.findAllByOrgIdWithOptions({ orgId: organizationId });\n-    } catch (error) {\n+    } catch {\n       return [];\n     }\n   },\n@@ -79,65 +77,15 @@ const Page = async ({ params }: { params: Promise<{ id: string }> }) => {\n   const organizationId = team.parentId || teamId;\n \n   // Load PBAC roles and attributes if available\n-  const [roles, attributes] = await Promise.all([\n+  const [roles, attributes, memberPermissions] = await Promise.all([\n     getCachedTeamRoles(teamId, organizationId),\n     getCachedTeamAttributes(organizationId),\n+    getTeamMemberPermissions({\n+      userId: session.user.id,\n+      team,\n+    }),\n   ]);\n \n-  const fallbackRolesCanListMembers: MembershipRole[] = [MembershipRole.ADMIN, MembershipRole.OWNER];\n-\n-  // If the team is not private we allow members to list other members\n-  if (!team.isPrivate) {\n-    fallbackRolesCanListMembers.push(MembershipRole.MEMBER);\n-  }\n-\n-  // Get specific PBAC permissions for team member actions\n-  const permissions = await getSpecificPermissions({\n-    userId: session.user.id,\n-    teamId: teamId,\n-    resource: Resource.Team,\n-    userRole: team.membership.role,\n-    actions: [\n-      CustomAction.Invite,\n-      CustomAction.ChangeMemberRole,\n-      CustomAction.Remove,\n-      CustomAction.ListMembers,\n-      CustomAction.ListMembersPrivate,\n-      CustomAction.Impersonate,\n-    ],\n-    fallbackRoles: {\n-      [CustomAction.Invite]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.ChangeMemberRole]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.Remove]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.ListMembers]: {\n-        roles: fallbackRolesCanListMembers,\n-      },\n-      [CustomAction.Impersonate]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.ListMembersPrivate]: {\n-        roles: fallbackRolesCanListMembers,\n-      },\n-    },\n-  });\n-\n-  // Map specific permissions to member actions\n-  const memberPermissions = {\n-    canListMembers: team.isPrivate\n-      ? permissions[CustomAction.ListMembersPrivate]\n-      : permissions[CustomAction.ListMembers],\n-    canInvite: permissions[CustomAction.Invite],\n-    canChangeMemberRole: permissions[CustomAction.ChangeMemberRole],\n-    canRemove: permissions[CustomAction.Remove],\n-    canImpersonate: permissions[CustomAction.Impersonate],\n-  };\n-\n   const facetedTeamValues = {\n     roles,\n     teams: [team],\ndiff --git a/packages/features/ee/teams/components/EditMemberSheet.test.tsx b/packages/features/ee/teams/components/EditMemberSheet.test.tsx\nnew file mode 100644\nindex 00000000000000..77f8e480db0fa9\n--- /dev/null\n+++ b/packages/features/ee/teams/components/EditMemberSheet.test.tsx\n@@ -0,0 +1,327 @@\n+import { render } from \"@testing-library/react\";\n+import React, { type ReactNode } from \"react\";\n+import { vi } from \"vitest\";\n+\n+import type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\n+import { MembershipRole } from \"@calcom/prisma/enums\";\n+\n+import { EditMemberSheet } from \"./EditMemberSheet\";\n+import type { State, User } from \"./MemberList\";\n+\n+// Mock dependencies\n+vi.mock(\"@calcom/lib/hooks/useLocale\", () => ({\n+  useLocale: () => ({\n+    t: (key: string) => key,\n+  }),\n+}));\n+\n+vi.mock(\"@calcom/trpc/react\", () => ({\n+  trpc: {\n+    viewer: {\n+      pbac: {\n+        getTeamRoles: {\n+          useQuery: () => ({\n+            data: undefined,\n+            isPending: false,\n+          }),\n+        },\n+      },\n+      teams: {\n+        getUserConnectedApps: {\n+          useQuery: () => ({\n+            data: {},\n+            isPending: false,\n+          }),\n+        },\n+        changeMemberRole: {\n+          useMutation: () => ({\n+            mutate: vi.fn(),\n+            mutateAsync: vi.fn(),\n+          }),\n+        },\n+        listMembers: {\n+          cancel: vi.fn(),\n+          getInfiniteData: vi.fn(),\n+          invalidate: vi.fn(),\n+        },\n+        get: {\n+          setData: vi.fn(),\n+          invalidate: vi.fn(),\n+        },\n+      },\n+    },\n+    useUtils: () => ({\n+      viewer: {\n+        teams: {\n+          listMembers: {\n+            cancel: vi.fn(),\n+            getInfiniteData: vi.fn(),\n+            invalidate: vi.fn(),\n+          },\n+          get: {\n+            setData: vi.fn(),\n+            invalidate: vi.fn(),\n+          },\n+        },\n+      },\n+    }),\n+  },\n+}));\n+\n+const mockSetEditMode = vi.fn();\n+const mockSetMutationLoading = vi.fn();\n+\n+vi.mock(\"@calcom/features/users/components/UserTable/EditSheet/store\", () => ({\n+  useEditMode: vi.fn((selector) => {\n+    const state = {\n+      editMode: false,\n+      setEditMode: mockSetEditMode,\n+      mutationLoading: false,\n+      setMutationLoading: mockSetMutationLoading,\n+    };\n+    if (typeof selector === \"function\") {\n+      return selector(state);\n+    }\n+    return state;\n+  }),\n+}));\n+\n+// Mock SheetFooterControls to verify props\n+let capturedProps: { canChangeMemberRole?: boolean; canEditAttributesForUser?: boolean }[] = [];\n+vi.mock(\"@calcom/features/users/components/UserTable/EditSheet/SheetFooterControls\", () => ({\n+  SheetFooterControls: (props: { canChangeMemberRole?: boolean; canEditAttributesForUser?: boolean }) => {\n+    capturedProps.push(props);\n+    return React.createElement(\"div\", { \"data-testid\": \"sheet-footer-controls\" }, \"SheetFooterControls\");\n+  },\n+}));\n+\n+// Mock other UI components\n+vi.mock(\"@calcom/ui/components/sheet\", () => ({\n+  Sheet: ({ children }: { children: ReactNode }) =>\n+    React.createElement(\"div\", { \"data-testid\": \"sheet\" }, children),\n+  SheetContent: ({ children }: { children: ReactNode }) =>\n+    React.createElement(\"div\", { \"data-testid\": \"sheet-content\" }, children),\n+  SheetHeader: ({ children }: { children: ReactNode }) =>\n+    React.createElement(\"div\", { \"data-testid\": \"sheet-header\" }, children),\n+  SheetBody: ({ children }: { children: ReactNode }) =>\n+    React.createElement(\"div\", { \"data-testid\": \"sheet-body\" }, children),\n+  SheetFooter: ({ children }: { children: ReactNode }) =>\n+    React.createElement(\"div\", { \"data-testid\": \"sheet-footer\" }, children),\n+}));\n+\n+vi.mock(\"@calcom/ui/components/form\", () => ({\n+  Form: ({ children }: { children: ReactNode }) => React.createElement(\"form\", null, children),\n+  ToggleGroup: () => React.createElement(\"div\", { \"data-testid\": \"toggle-group\" }, \"ToggleGroup\"),\n+  Select: () => React.createElement(\"div\", { \"data-testid\": \"select\" }, \"Select\"),\n+}));\n+\n+vi.mock(\"@calcom/ui/components/avatar\", () => ({\n+  Avatar: () => React.createElement(\"div\", { \"data-testid\": \"avatar\" }, \"Avatar\"),\n+}));\n+\n+vi.mock(\"@calcom/ui/components/skeleton\", () => ({\n+  Skeleton: ({ children }: { children: ReactNode }) => React.createElement(\"div\", null, children),\n+  Loader: () => React.createElement(\"div\", { \"data-testid\": \"loader\" }, \"Loading...\"),\n+}));\n+\n+vi.mock(\"@calcom/features/users/components/UserTable/EditSheet/DisplayInfo\", () => ({\n+  DisplayInfo: () => <div data-testid=\"display-info\">DisplayInfo</div>,\n+}));\n+\n+describe(\"EditMemberSheet\", () => {\n+  const mockDispatch = vi.fn();\n+\n+  // Create a minimal mock user that satisfies the User type\n+  const mockUser = {\n+    id: 1,\n+    name: \"Test User\",\n+    email: \"test@example.com\",\n+    username: \"testuser\",\n+    role: MembershipRole.MEMBER,\n+    accepted: true,\n+    avatarUrl: \"\",\n+    bookerUrl: \"https://cal.com\",\n+    lastActiveAt: \"2024-01-01\",\n+    customRoleId: null,\n+  } as User;\n+\n+  const mockState: State = {\n+    editSheet: {\n+      user: mockUser,\n+      showModal: true,\n+    },\n+    deleteMember: {\n+      showModal: false,\n+    },\n+    impersonateMember: {\n+      showModal: false,\n+    },\n+    teamAvailability: {\n+      showModal: false,\n+    },\n+  };\n+\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+    mockSetEditMode.mockClear();\n+    mockSetMutationLoading.mockClear();\n+    capturedProps = [];\n+  });\n+\n+  describe(\"Fix verification: canChangeMemberRole prop passing\", () => {\n+    it(\"should pass canChangeMemberRole=true to SheetFooterControls when permissions.canChangeMemberRole is true\", () => {\n+      const permissions: MemberPermissions = {\n+        canListMembers: false,\n+        canInvite: false,\n+        canChangeMemberRole: true,\n+        canRemove: false,\n+        canImpersonate: false,\n+      };\n+\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={permissions}\n+        />\n+      );\n+\n+      // Verify SheetFooterControls was called with canChangeMemberRole=true\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: true,\n+        })\n+      );\n+    });\n+\n+    it(\"should pass canChangeMemberRole=false to SheetFooterControls when permissions.canChangeMemberRole is false\", () => {\n+      const permissions: MemberPermissions = {\n+        canListMembers: false,\n+        canInvite: false,\n+        canChangeMemberRole: false,\n+        canRemove: false,\n+        canImpersonate: false,\n+      };\n+\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={permissions}\n+        />\n+      );\n+\n+      // Verify SheetFooterControls was called with canChangeMemberRole=false\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: false,\n+        })\n+      );\n+    });\n+\n+    it(\"should pass canChangeMemberRole=undefined to SheetFooterControls when permissions is undefined\", () => {\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={undefined}\n+        />\n+      );\n+\n+      // Verify SheetFooterControls was called with canChangeMemberRole=undefined\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: undefined,\n+        })\n+      );\n+    });\n+\n+    it(\"should pass canChangeMemberRole=undefined to SheetFooterControls when permissions object exists but canChangeMemberRole is undefined\", () => {\n+      const permissions: Partial<MemberPermissions> = {\n+        canListMembers: true,\n+        canInvite: false,\n+        // canChangeMemberRole is intentionally omitted\n+      };\n+\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={permissions as MemberPermissions}\n+        />\n+      );\n+\n+      // Verify SheetFooterControls was called with canChangeMemberRole=undefined\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: undefined,\n+        })\n+      );\n+    });\n+\n+    it(\"should pass canEditAttributesForUser from permissions to SheetFooterControls\", () => {\n+      const permissions: MemberPermissions = {\n+        canListMembers: false,\n+        canInvite: false,\n+        canChangeMemberRole: true,\n+        canRemove: false,\n+        canImpersonate: false,\n+        canEditAttributesForUser: true,\n+      };\n+\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={permissions}\n+        />\n+      );\n+\n+      // Verify SheetFooterControls was called with both props\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: true,\n+          canEditAttributesForUser: true,\n+        })\n+      );\n+    });\n+\n+    it(\"should correctly extract canChangeMemberRole from permissions object (verifies fix)\", () => {\n+      // This test specifically verifies the fix where permissions?.canChangeMemberRole\n+      // is now correctly passed to SheetFooterControls\n+      const permissions: MemberPermissions = {\n+        canListMembers: false,\n+        canInvite: false,\n+        canChangeMemberRole: true, // This should be passed to SheetFooterControls\n+        canRemove: false,\n+        canImpersonate: false,\n+      };\n+\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={permissions}\n+        />\n+      );\n+\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: true,\n+        })\n+      );\n+    });\n+  });\n+});\ndiff --git a/packages/features/ee/teams/components/EditMemberSheet.tsx b/packages/features/ee/teams/components/EditMemberSheet.tsx\nindex 61bbb6693c8ded..8611d8d9f35582 100644\n--- a/packages/features/ee/teams/components/EditMemberSheet.tsx\n+++ b/packages/features/ee/teams/components/EditMemberSheet.tsx\n@@ -8,6 +8,7 @@ import { shallow } from \"zustand/shallow\";\n import { DisplayInfo } from \"@calcom/features/users/components/UserTable/EditSheet/DisplayInfo\";\n import { SheetFooterControls } from \"@calcom/features/users/components/UserTable/EditSheet/SheetFooterControls\";\n import { useEditMode } from \"@calcom/features/users/components/UserTable/EditSheet/store\";\n+import type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\n import { useLocale } from \"@calcom/lib/hooks/useLocale\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n import { trpc } from \"@calcom/trpc/react\";\n@@ -34,11 +35,13 @@ export function EditMemberSheet({\n   dispatch,\n   currentMember,\n   teamId,\n+  permissions,\n }: {\n   state: State;\n   dispatch: Dispatch<Action>;\n   currentMember: MembershipRole;\n   teamId: number;\n+  permissions?: MemberPermissions;\n }) {\n   const { t } = useLocale();\n   const { user } = state.editSheet;\n@@ -277,7 +280,10 @@ export function EditMemberSheet({\n               </div>\n             </SheetBody>\n             <SheetFooter className=\"mt-auto\">\n-              <SheetFooterControls />\n+              <SheetFooterControls\n+                canChangeMemberRole={permissions?.canChangeMemberRole}\n+                canEditAttributesForUser={permissions?.canEditAttributesForUser}\n+              />\n             </SheetFooter>\n           </Form>\n         ) : (\ndiff --git a/packages/features/ee/teams/components/MemberList.tsx b/packages/features/ee/teams/components/MemberList.tsx\nindex b2be14f2ee159c..ff1ee1627c3b9a 100644\n--- a/packages/features/ee/teams/components/MemberList.tsx\n+++ b/packages/features/ee/teams/components/MemberList.tsx\n@@ -830,6 +830,7 @@ function MemberListContent(props: Props) {\n           state={state}\n           currentMember={props.team.membership.role}\n           teamId={props.team.id}\n+          permissions={props.permissions}\n         />\n       )}\n     </>\ndiff --git a/packages/features/pbac/lib/team-member-permissions.ts b/packages/features/pbac/lib/team-member-permissions.ts\nnew file mode 100644\nindex 00000000000000..ad27cdf27669b7\n--- /dev/null\n+++ b/packages/features/pbac/lib/team-member-permissions.ts\n@@ -0,0 +1,80 @@\n+import type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\n+import { MembershipRole } from \"@calcom/prisma/enums\";\n+\n+import { Resource, CustomAction } from \"../domain/types/permission-registry\";\n+import { getSpecificPermissions } from \"./resource-permissions\";\n+\n+interface TeamWithMembership {\n+  id: number;\n+  isPrivate: boolean;\n+  membership: {\n+    role: MembershipRole;\n+    accepted: boolean;\n+  };\n+}\n+\n+interface GetTeamMemberPermissionsOptions {\n+  userId: number;\n+  team: TeamWithMembership;\n+}\n+\n+/**\n+ * Gets team member permissions using PBAC or fallback to role-based permissions.\n+ */\n+export async function getTeamMemberPermissions({\n+  userId,\n+  team,\n+}: GetTeamMemberPermissionsOptions): Promise<MemberPermissions> {\n+  // Determine fallback roles for ListMembers based on team privacy\n+  const fallbackRolesCanListMembers: MembershipRole[] = [MembershipRole.ADMIN, MembershipRole.OWNER];\n+  if (!team.isPrivate) {\n+    fallbackRolesCanListMembers.push(MembershipRole.MEMBER);\n+  }\n+\n+  // Get specific PBAC permissions for team member actions\n+  const permissions = await getSpecificPermissions({\n+    userId,\n+    teamId: team.id,\n+    resource: Resource.Team,\n+    userRole: team.membership.role,\n+    actions: [\n+      CustomAction.Invite,\n+      CustomAction.ChangeMemberRole,\n+      CustomAction.Remove,\n+      CustomAction.ListMembers,\n+      CustomAction.ListMembersPrivate,\n+      CustomAction.Impersonate,\n+    ],\n+    fallbackRoles: {\n+      [CustomAction.Invite]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.ChangeMemberRole]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.Remove]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.ListMembers]: {\n+        roles: fallbackRolesCanListMembers,\n+      },\n+      [CustomAction.Impersonate]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.ListMembersPrivate]: {\n+        roles: fallbackRolesCanListMembers,\n+      },\n+    },\n+  });\n+\n+  // Map specific permissions to member actions\n+  return {\n+    canListMembers: team.isPrivate\n+      ? permissions[CustomAction.ListMembersPrivate]\n+      : permissions[CustomAction.ListMembers],\n+    canInvite: permissions[CustomAction.Invite],\n+    canChangeMemberRole: permissions[CustomAction.ChangeMemberRole],\n+    canRemove: permissions[CustomAction.Remove],\n+    canImpersonate: permissions[CustomAction.Impersonate],\n+  };\n+}\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}