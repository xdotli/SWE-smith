{
    "cost": 0.41146000000000005,
    "rewrites": {
        "calcom__cal.com.main/packages/features/CalendarEventBuilder.test.ts": {
            "output": "import type { TFunction } from \"i18next\";\nimport { describe, expect, it, vi } from \"vitest\";\n\nimport dayjs from \"@calcom/dayjs\";\nimport { BookingForCalEventBuilder, CalendarEventBuilder } from \"@calcom/features/CalendarEventBuilder\";\nimport { TimeFormat } from \"@calcom/lib/timeFormat\";\nimport type { Person } from \"@calcom/types/Calendar\";\n\nvi.mock(\"@calcom/features/ee/organizations/lib/getBookerUrlServer\", () => ({\n  getBookerBaseUrl: vi.fn(async () => \"https://cal.com\"),\n}));\n\nvi.mock(\"@calcom/lib/server/i18n\", () => ({\n  getTranslation: vi.fn(async () => vi.fn(() => \"translated\")),\n}));\n\nvi.mock(\"@calcom/features/bookings/lib/getCalEventResponses\", () => ({\n  getCalEventResponses: vi.fn(() => ({\n    responses: {\n      name: { label: \"your_name\", value: \"Test User\", isHidden: false },\n      email: { label: \"email_address\", value: \"test@example.com\", isHidden: false },\n    },\n    userFieldsResponses: {},\n  })),\n}));\n\ndescribe(\"CalendarEventBuilder\", () => {\n  const mockTranslate = vi.fn(() => \"foo\") as TFunction;\n  const mockStartTime = dayjs().add(1, \"day\").format();\n  const mockEndTime = dayjs().add(1, \"day\").add(30, \"minutes\").format();\n\n  it(\"should create a basic calendar event\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n        additionalNotes: \"Some notes\",\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        description: \"Test description\",\n        id: 123,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.bookerUrl).toBe(\"https://cal.com/user/test-slug\");\n      expect(event.title).toBe(\"Test Event\");\n      expect(event.startTime).toBe(mockStartTime);\n      expect(event.endTime).toBe(mockEndTime);\n      expect(event.additionalNotes).toBe(\"Some notes\");\n    }\n  });\n\n  it(\"should create an event with event type details\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        description: \"Test description\",\n        id: 123,\n        hideCalendarNotes: true,\n        hideCalendarEventDetails: false,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.type).toBe(\"test-slug\");\n      expect(event.description).toBe(\"Test description\");\n      expect(event.eventTypeId).toBe(123);\n      expect(event.hideCalendarNotes).toBe(true);\n      expect(event.hideCalendarEventDetails).toBe(false);\n    }\n  });\n\n  it(\"should create an event with organizer details\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withOrganizer({\n        id: 456,\n        name: \"John Doe\",\n        email: \"john@example.com\",\n        username: \"johndoe\",\n        timeZone: \"America/New_York\",\n        language: {\n          translate: mockTranslate,\n          locale: \"en\",\n        },\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.organizer).toEqual({\n        id: 456,\n        name: \"John Doe\",\n        email: \"john@example.com\",\n        username: \"johndoe\",\n        timeZone: \"America/New_York\",\n        language: {\n          translate: mockTranslate,\n          locale: \"en\",\n        },\n      });\n    }\n  });\n\n  it(\"should handle nameless organizer\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withOrganizer({\n        id: 456,\n        name: null,\n        email: \"john@example.com\",\n        timeZone: \"America/New_York\",\n        language: {\n          translate: mockTranslate,\n          locale: \"en\",\n        },\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.organizer.name).toBe(\"Nameless\");\n    }\n  });\n\n  it(\"should create an event with attendees\", () => {\n    const attendees: Person[] = [\n      {\n        email: \"attendee1@example.com\",\n        name: \"Attendee One\",\n        timeZone: \"Europe/London\",\n        language: {\n          translate: mockTranslate,\n          locale: \"en\",\n        },\n      },\n      {\n        email: \"attendee2@example.com\",\n        name: \"Attendee Two\",\n        timeZone: \"Europe/Paris\",\n        language: {\n          translate: mockTranslate,\n          locale: \"fr\",\n        },\n      },\n    ];\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withAttendees(attendees)\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.attendees).toEqual(attendees);\n    }\n  });\n\n  it(\"should create an event with metadata and responses\", () => {\n    const customInputs = { question1: \"answer1\" };\n    const responses = {\n      name: { label: \"your_name\", value: \"Owner 1\", isHidden: false },\n      email: {\n        label: \"email_address\",\n        value: \"owner1-dunder@example.com\",\n        isHidden: false,\n      },\n    };\n    const userFieldsResponses = {};\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withMetadataAndResponses({\n        additionalNotes: \"Some notes\",\n        customInputs,\n        responses,\n        userFieldsResponses,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.additionalNotes).toBe(\"Some notes\");\n      expect(event.customInputs).toEqual(customInputs);\n      expect(event.responses).toEqual(responses);\n      expect(event.userFieldsResponses).toEqual(userFieldsResponses);\n    }\n  });\n\n  it(\"should create an event with location\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withLocation({\n        location: \"Conference Room A\",\n        conferenceCredentialId: 789,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.location).toBe(\"Conference Room A\");\n      expect(event.conferenceCredentialId).toBe(789);\n    }\n  });\n\n  it(\"should create an event with destination calendar\", () => {\n    const destinationCalendar = {\n      id: 1,\n      integration: \"google_calendar\",\n      externalId: \"external123\",\n      primaryEmail: \"primary@example.com\",\n      userId: null,\n      eventTypeId: null,\n      credentialId: null,\n      createdAt: null,\n      updatedAt: null,\n      delegationCredentialId: null,\n      domainWideDelegationCredentialId: null,\n    };\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withDestinationCalendar([destinationCalendar])\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.destinationCalendar).toEqual([destinationCalendar]);\n    }\n  });\n\n  it(\"should create an event with identifiers\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withIdentifiers({\n        iCalUID: \"ical-123\",\n        iCalSequence: 2,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.iCalUID).toBe(\"ical-123\");\n      expect(event.iCalSequence).toBe(2);\n    }\n  });\n\n  it(\"should create an event with confirmation settings\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withConfirmation({\n        requiresConfirmation: true,\n        isConfirmedByDefault: false,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.requiresConfirmation).toBe(true);\n      expect(event.oneTimePassword).toBeUndefined();\n    }\n  });\n\n  it(\"should set oneTimePassword to null when isConfirmedByDefault is true\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withConfirmation({\n        requiresConfirmation: true,\n        isConfirmedByDefault: true,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.requiresConfirmation).toBe(true);\n      expect(event.oneTimePassword).toBeNull();\n    }\n  });\n\n  it(\"should create an event with platform variables\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withPlatformVariables({\n        platformClientId: \"client-123\",\n        platformRescheduleUrl: \"https://platform.com/reschedule\",\n        platformCancelUrl: \"https://platform.com/cancel\",\n        platformBookingUrl: \"https://platform.com/booking\",\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.platformClientId).toBe(\"client-123\");\n      expect(event.platformRescheduleUrl).toBe(\"https://platform.com/reschedule\");\n      expect(event.platformCancelUrl).toBe(\"https://platform.com/cancel\");\n      expect(event.platformBookingUrl).toBe(\"https://platform.com/booking\");\n    }\n  });\n\n  it(\"should create an event with apps status\", () => {\n    const appsStatus = [\n      {\n        appName: \"google-calendar\",\n        type: \"google_calendar\",\n        success: 1,\n        failures: 0,\n        errors: [],\n        warnings: [],\n      },\n      {\n        appName: \"Google Meet\",\n        type: \"conferencing\",\n        success: 1,\n        failures: 0,\n        errors: [],\n        warnings: undefined,\n      },\n    ];\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withAppsStatus(appsStatus)\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.appsStatus).toEqual(appsStatus);\n    }\n  });\n\n  it(\"should create an event with video call data\", () => {\n    const videoCallData = {\n      type: \"google_meet\",\n      id: \"123\",\n      url: \"https://meet.example.com/123\",\n      password: \"password123\",\n    };\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withVideoCallData(videoCallData)\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.videoCallData).toEqual(videoCallData);\n    }\n  });\n\n  it(\"should create an event with team information\", () => {\n    const team = {\n      name: \"Engineering Team\",\n      members: [\n        {\n          email: \"member1@example.com\",\n          name: \"Member One\",\n          timeZone: \"America/Chicago\",\n          language: {\n            translate: mockTranslate,\n            locale: \"en\",\n          },\n        },\n      ],\n      id: 101,\n    };\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https",
            "output_extracted": "import type { TFunction } from \"i18next\";\nimport { describe, expect, it, vi } from \"vitest\";\n\nimport dayjs from \"@calcom/dayjs\";\nimport { BookingForCalEventBuilder, CalendarEventBuilder } from \"@calcom/features/CalendarEventBuilder\";\nimport { TimeFormat } from \"@calcom/lib/timeFormat\";\nimport type { Person } from \"@calcom/types/Calendar\";\n\nvi.mock(\"@calcom/features/ee/organizations/lib/getBookerUrlServer\", () => ({\n  getBookerBaseUrl: vi.fn(async () => \"https://cal.com\"),\n}));\n\nvi.mock(\"@calcom/lib/server/i18n\", () => ({\n  getTranslation: vi.fn(async () => vi.fn(() => \"translated\")),\n}));\n\nvi.mock(\"@calcom/features/bookings/lib/getCalEventResponses\", () => ({\n  getCalEventResponses: vi.fn(() => ({\n    responses: {\n      name: { label: \"your_name\", value: \"Test User\", isHidden: false },\n      email: { label: \"email_address\", value: \"test@example.com\", isHidden: false },\n    },\n    userFieldsResponses: {},\n  })),\n}));\n\ndescribe(\"CalendarEventBuilder\", () => {\n  const mockTranslate = vi.fn(() => \"foo\") as TFunction;\n  const mockStartTime = dayjs().add(1, \"day\").format();\n  const mockEndTime = dayjs().add(1, \"day\").add(30, \"minutes\").format();\n\n  it(\"should create a basic calendar event\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n        additionalNotes: \"Some notes\",\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        description: \"Test description\",\n        id: 123,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.bookerUrl).toBe(\"https://cal.com/user/test-slug\");\n      expect(event.title).toBe(\"Test Event\");\n      expect(event.startTime).toBe(mockStartTime);\n      expect(event.endTime).toBe(mockEndTime);\n      expect(event.additionalNotes).toBe(\"Some notes\");\n    }\n  });\n\n  it(\"should create an event with event type details\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        description: \"Test description\",\n        id: 123,\n        hideCalendarNotes: true,\n        hideCalendarEventDetails: false,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.type).toBe(\"test-slug\");\n      expect(event.description).toBe(\"Test description\");\n      expect(event.eventTypeId).toBe(123);\n      expect(event.hideCalendarNotes).toBe(true);\n      expect(event.hideCalendarEventDetails).toBe(false);\n    }\n  });\n\n  it(\"should create an event with organizer details\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withOrganizer({\n        id: 456,\n        name: \"John Doe\",\n        email: \"john@example.com\",\n        username: \"johndoe\",\n        timeZone: \"America/New_York\",\n        language: {\n          translate: mockTranslate,\n          locale: \"en\",\n        },\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.organizer).toEqual({\n        id: 456,\n        name: \"John Doe\",\n        email: \"john@example.com\",\n        username: \"johndoe\",\n        timeZone: \"America/New_York\",\n        language: {\n          translate: mockTranslate,\n          locale: \"en\",\n        },\n      });\n    }\n  });\n\n  it(\"should handle nameless organizer\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withOrganizer({\n        id: 456,\n        name: null,\n        email: \"john@example.com\",\n        timeZone: \"America/New_York\",\n        language: {\n          translate: mockTranslate,\n          locale: \"en\",\n        },\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.organizer.name).toBe(\"Nameless\");\n    }\n  });\n\n  it(\"should create an event with attendees\", () => {\n    const attendees: Person[] = [\n      {\n        email: \"attendee1@example.com\",\n        name: \"Attendee One\",\n        timeZone: \"Europe/London\",\n        language: {\n          translate: mockTranslate,\n          locale: \"en\",\n        },\n      },\n      {\n        email: \"attendee2@example.com\",\n        name: \"Attendee Two\",\n        timeZone: \"Europe/Paris\",\n        language: {\n          translate: mockTranslate,\n          locale: \"fr\",\n        },\n      },\n    ];\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withAttendees(attendees)\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.attendees).toEqual(attendees);\n    }\n  });\n\n  it(\"should create an event with metadata and responses\", () => {\n    const customInputs = { question1: \"answer1\" };\n    const responses = {\n      name: { label: \"your_name\", value: \"Owner 1\", isHidden: false },\n      email: {\n        label: \"email_address\",\n        value: \"owner1-dunder@example.com\",\n        isHidden: false,\n      },\n    };\n    const userFieldsResponses = {};\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withMetadataAndResponses({\n        additionalNotes: \"Some notes\",\n        customInputs,\n        responses,\n        userFieldsResponses,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.additionalNotes).toBe(\"Some notes\");\n      expect(event.customInputs).toEqual(customInputs);\n      expect(event.responses).toEqual(responses);\n      expect(event.userFieldsResponses).toEqual(userFieldsResponses);\n    }\n  });\n\n  it(\"should create an event with location\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withLocation({\n        location: \"Conference Room A\",\n        conferenceCredentialId: 789,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.location).toBe(\"Conference Room A\");\n      expect(event.conferenceCredentialId).toBe(789);\n    }\n  });\n\n  it(\"should create an event with destination calendar\", () => {\n    const destinationCalendar = {\n      id: 1,\n      integration: \"google_calendar\",\n      externalId: \"external123\",\n      primaryEmail: \"primary@example.com\",\n      userId: null,\n      eventTypeId: null,\n      credentialId: null,\n      createdAt: null,\n      updatedAt: null,\n      delegationCredentialId: null,\n      domainWideDelegationCredentialId: null,\n    };\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withDestinationCalendar([destinationCalendar])\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.destinationCalendar).toEqual([destinationCalendar]);\n    }\n  });\n\n  it(\"should create an event with identifiers\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withIdentifiers({\n        iCalUID: \"ical-123\",\n        iCalSequence: 2,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.iCalUID).toBe(\"ical-123\");\n      expect(event.iCalSequence).toBe(2);\n    }\n  });\n\n  it(\"should create an event with confirmation settings\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withConfirmation({\n        requiresConfirmation: true,\n        isConfirmedByDefault: false,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.requiresConfirmation).toBe(true);\n      expect(event.oneTimePassword).toBeUndefined();\n    }\n  });\n\n  it(\"should set oneTimePassword to null when isConfirmedByDefault is true\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withConfirmation({\n        requiresConfirmation: true,\n        isConfirmedByDefault: true,\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.requiresConfirmation).toBe(true);\n      expect(event.oneTimePassword).toBeNull();\n    }\n  });\n\n  it(\"should create an event with platform variables\", () => {\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withPlatformVariables({\n        platformClientId: \"client-123\",\n        platformRescheduleUrl: \"https://platform.com/reschedule\",\n        platformCancelUrl: \"https://platform.com/cancel\",\n        platformBookingUrl: \"https://platform.com/booking\",\n      })\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.platformClientId).toBe(\"client-123\");\n      expect(event.platformRescheduleUrl).toBe(\"https://platform.com/reschedule\");\n      expect(event.platformCancelUrl).toBe(\"https://platform.com/cancel\");\n      expect(event.platformBookingUrl).toBe(\"https://platform.com/booking\");\n    }\n  });\n\n  it(\"should create an event with apps status\", () => {\n    const appsStatus = [\n      {\n        appName: \"google-calendar\",\n        type: \"google_calendar\",\n        success: 1,\n        failures: 0,\n        errors: [],\n        warnings: [],\n      },\n      {\n        appName: \"Google Meet\",\n        type: \"conferencing\",\n        success: 1,\n        failures: 0,\n        errors: [],\n        warnings: undefined,\n      },\n    ];\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withAppsStatus(appsStatus)\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.appsStatus).toEqual(appsStatus);\n    }\n  });\n\n  it(\"should create an event with video call data\", () => {\n    const videoCallData = {\n      type: \"google_meet\",\n      id: \"123\",\n      url: \"https://meet.example.com/123\",\n      password: \"password123\",\n    };\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https://cal.com/user/test-slug\",\n        title: \"Test Event\",\n        startTime: mockStartTime,\n        endTime: mockEndTime,\n      })\n      .withEventType({\n        slug: \"test-slug\",\n        id: 123,\n      })\n      .withVideoCallData(videoCallData)\n      .build();\n\n    expect(event).not.toBeNull();\n    if (event) {\n      expect(event.videoCallData).toEqual(videoCallData);\n    }\n  });\n\n  it(\"should create an event with team information\", () => {\n    const team = {\n      name: \"Engineering Team\",\n      members: [\n        {\n          email: \"member1@example.com\",\n          name: \"Member One\",\n          timeZone: \"America/Chicago\",\n          language: {\n            translate: mockTranslate,\n            locale: \"en\",\n          },\n        },\n      ],\n      id: 101,\n    };\n\n    const event = new CalendarEventBuilder()\n      .withBasicDetails({\n        bookerUrl: \"https",
            "cost": 0.19864
        },
        "calcom__cal.com.main/packages/features/CalendarEventBuilder.ts": {
            "output": "import type { TFunction } from \"i18next\";\n\nimport { getCalEventResponses } from \"@calcom/features/bookings/lib/getCalEventResponses\";\nimport type { BookingRepository } from \"@calcom/features/bookings/repositories/BookingRepository\";\nimport { getBookerBaseUrl } from \"@calcom/features/ee/organizations/lib/getBookerUrlServer\";\nimport { parseRecurringEvent } from \"@calcom/lib/isRecurringEvent\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { getTimeFormatStringFromUserTimeFormat, type TimeFormat } from \"@calcom/lib/timeFormat\";\nimport type { Attendee, BookingSeat, DestinationCalendar, Prisma, User } from \"@calcom/prisma/client\";\nimport type { SchedulingType } from \"@calcom/prisma/enums\";\nimport { bookingResponses as bookingResponsesSchema } from \"@calcom/prisma/zod-utils\";\nimport type { CalendarEvent, Person, CalEventResponses, AppsStatus } from \"@calcom/types/Calendar\";\nimport type { VideoCallData } from \"@calcom/types/VideoApiAdapter\";\n\nexport type BookingForCalEventBuilder = NonNullable<\n  Awaited<ReturnType<BookingRepository[\"getBookingForCalEventBuilder\"]>>\n>;\nexport type BookingMetaOptions = {\n  conferenceCredentialId?: number;\n  platformClientId?: string;\n  platformRescheduleUrl?: string;\n  platformCancelUrl?: string;\n  platformBookingUrl?: string;\n};\n\nasync function _buildPersonFromUser(\n  user: Pick<User, \"id\" | \"name\" | \"locale\" | \"username\" | \"email\" | \"timeFormat\" | \"timeZone\">\n) {\n  const translate = await getTranslation(user.locale ?? \"en\", \"common\");\n  return {\n    id: user.id,\n    name: user.name || \"Nameless\",\n    email: user.email,\n    username: user.username || undefined,\n    timeZone: user.timeZone,\n    language: { translate, locale: user.locale ?? \"en\" },\n    timeFormat: getTimeFormatStringFromUserTimeFormat(user.timeFormat),\n  } satisfies Person;\n}\n\nasync function _buildPersonFromAttendee(\n  attendee: Pick<Attendee, \"locale\" | \"name\" | \"timeZone\" | \"email\" | \"phoneNumber\"> & {\n    bookingSeat: Pick<\n      BookingSeat,\n      \"id\" | \"referenceUid\" | \"bookingId\" | \"metadata\" | \"data\" | \"attendeeId\"\n    > | null;\n  }\n) {\n  const translate = await getTranslation(attendee.locale ?? \"en\", \"common\");\n\n  return {\n    name: attendee.name ?? \"\",\n    email: attendee.email,\n    timeZone: attendee.timeZone,\n    language: { translate, locale: attendee.locale ?? \"en\" },\n    phoneNumber: attendee.phoneNumber,\n    bookingSeat: attendee.bookingSeat,\n  } satisfies Person;\n}\n\nexport class CalendarEventBuilder {\n  private event: Partial<CalendarEvent>;\n\n  constructor(existingEvent?: Partial<CalendarEvent>) {\n    this.event = existingEvent || {};\n  }\n\n  static fromEvent(event: Partial<CalendarEvent>) {\n    return new CalendarEventBuilder(event);\n  }\n\n  /**\n   * Builds a CalendarEventBuilder instance from a booking.\n   */\n  static async fromBooking(\n    booking: BookingForCalEventBuilder,\n    meta: BookingMetaOptions = {}\n  ): Promise<CalendarEventBuilder> {\n    const { uid, user, eventType } = booking;\n\n    if (!user) throw new Error(`Booking ${uid} is missing an organizer \u2014 user may have been deleted.`);\n    if (!eventType) throw new Error(`Booking ${uid} is missing eventType \u2014 it may have been deleted.`);\n\n    const builder = new CalendarEventBuilder();\n    const {\n      description,\n      attendees,\n      references,\n      title,\n      startTime,\n      endTime,\n      location,\n      responses,\n      customInputs,\n      iCalUID,\n      iCalSequence,\n      oneTimePassword,\n      seatsReferences,\n    } = booking;\n\n    const {\n      conferenceCredentialId,\n      platformRescheduleUrl = \"\",\n      platformClientId = \"\",\n      platformCancelUrl = \"\",\n      platformBookingUrl = \"\",\n    } = meta;\n\n    const organizerPerson = await _buildPersonFromUser(user);\n    const attendeesList = await Promise.all(attendees.map(_buildPersonFromAttendee));\n    const additionalNotes = description || undefined;\n\n    const videoRef = references.find((r) => r.type.endsWith(\"_video\"));\n    const videoCallData = videoRef\n      ? {\n          type: videoRef.type,\n          id: videoRef.meetingId,\n          password: videoRef.meetingPassword,\n          url: videoRef.meetingUrl,\n        }\n      : undefined;\n    const appsStatus: AppsStatus[] = [];\n\n    const organizationId = user.profiles?.[0]?.organizationId ?? null;\n    const bookerUrl = await getBookerBaseUrl(eventType.team?.parentId ?? organizationId);\n\n    const parsedBookingResponses = bookingResponsesSchema.safeParse(responses);\n    const bookingResponses = parsedBookingResponses.success ? parsedBookingResponses.data : null;\n\n    const calEventResponses = getCalEventResponses({\n      booking,\n      bookingFields: eventType.bookingFields,\n    });\n\n    // custom inputs are the old system to record booking responses\n    const parsedCustomInputs =\n      typeof customInputs === \"object\" ? (customInputs as Record<string, string>) : null;\n\n    const recurring = parseRecurringEvent(eventType.recurringEvent) ?? undefined;\n\n    // Base builder setup\n    builder\n      .withBasicDetails({\n        bookerUrl,\n        title,\n        startTime: startTime.toISOString(),\n        endTime: endTime.toISOString(),\n        additionalNotes,\n      })\n      .withEventType({\n        id: eventType.id,\n        slug: eventType.slug,\n        description: eventType.description,\n        hideCalendarNotes: eventType.hideCalendarNotes,\n        hideCalendarEventDetails: eventType.hideCalendarEventDetails,\n        hideOrganizerEmail: eventType.hideOrganizerEmail,\n        schedulingType: eventType.schedulingType,\n        seatsPerTimeSlot: eventType.seatsPerTimeSlot,\n        seatsShowAttendees: !!eventType.seatsShowAttendees,\n        seatsShowAvailabilityCount: !!eventType.seatsShowAvailabilityCount,\n        customReplyToEmail: eventType.customReplyToEmail,\n        disableRescheduling: eventType.disableRescheduling ?? false,\n        disableCancelling: eventType.disableCancelling ?? false,\n      })\n      .withOrganizer(organizerPerson)\n      .withAttendees(attendeesList)\n      .withMetadataAndResponses({\n        additionalNotes,\n        customInputs: parsedCustomInputs,\n        responses: calEventResponses.responses,\n        userFieldsResponses: calEventResponses.userFieldsResponses,\n      })\n      .withLocation({ location, conferenceCredentialId })\n      .withIdentifiers({ iCalUID: iCalUID || undefined, iCalSequence })\n      .withConfirmation({\n        requiresConfirmation: !!eventType.requiresConfirmation,\n        isConfirmedByDefault: !eventType.requiresConfirmation,\n      })\n      .withPlatformVariables({\n        platformClientId,\n        platformRescheduleUrl,\n        platformCancelUrl,\n        platformBookingUrl,\n      })\n      .withRecurring(recurring)\n      .withUid(uid)\n      .withOneTimePassword(oneTimePassword)\n      .withOrganization(organizationId);\n\n    // Seats\n    if (seatsReferences?.length && bookingResponses) {\n      const currentSeat = seatsReferences.find(\n        (s) =>\n          s.attendee.email === bookingResponses.email ||\n          (bookingResponses.attendeePhoneNumber &&\n            s.attendee.phoneNumber === bookingResponses.attendeePhoneNumber)\n      );\n      if (currentSeat) builder.withAttendeeSeatId(currentSeat.referenceUid);\n    }\n\n    // Video\n    if (videoCallData && videoCallData.url) {\n      builder.withVideoCallData({\n        ...videoCallData,\n        id: videoCallData.id ?? \"\",\n        password: videoCallData.password ?? \"\",\n        url: videoCallData.url,\n      });\n    }\n\n    references\n      .filter((r) => r && r.type)\n      .forEach((ref) => {\n        appsStatus.push({\n          appName: ref.type.replace(\"_\", \"-\"),\n          type: ref.type,\n          success: ref.uid ? 1 : 0,\n          failures: ref.uid ? 0 : 1,\n          errors: [],\n        });\n      });\n\n    if (appsStatus.length) {\n      builder.withAppsStatus(appsStatus);\n    }\n\n    // Team & calendars\n    if (eventType.team) {\n      const hostsWithoutOrganizer = await Promise.all(\n        eventType.hosts.filter((h) => h.user.email !== user.email).map((h) => _buildPersonFromUser(h.user))\n      );\n\n      const hostCalendars = [\n        ...eventType.hosts.map((h) => h.user.destinationCalendar).filter(Boolean),\n        user.destinationCalendar,\n      ].filter(Boolean) as NonNullable<DestinationCalendar>[];\n\n      builder\n        .withTeam({\n          id: eventType.team.id,\n          name: eventType.team.name || \"\",\n          members: hostsWithoutOrganizer,\n        })\n        .withDestinationCalendar(hostCalendars);\n    } else if (user.destinationCalendar) {\n      builder.withDestinationCalendar([user.destinationCalendar]);\n    }\n\n    return builder;\n  }\n\n  withBasicDetails({\n    bookerUrl,\n    title,\n    startTime,\n    endTime,\n    additionalNotes,\n  }: {\n    bookerUrl: string;\n    title: string;\n    startTime: string;\n    endTime: string;\n    additionalNotes?: string;\n  }) {\n    this.event = {\n      ...this.event,\n      bookerUrl,\n      title,\n      startTime,\n      endTime,\n      additionalNotes,\n    };\n    return this;\n  }\n\n  withEventType(eventType: {\n    slug: string;\n    description?: string | null;\n    id: number;\n    hideCalendarNotes?: boolean;\n    hideCalendarEventDetails?: boolean;\n    hideOrganizerEmail?: boolean;\n    schedulingType?: SchedulingType | null;\n    seatsPerTimeSlot?: number | null;\n    seatsShowAttendees?: boolean | null;\n    seatsShowAvailabilityCount?: boolean | null;\n    customReplyToEmail?: string | null;\n    disableRescheduling?: boolean;\n    disableCancelling?: boolean;\n  }) {\n    this.event = {\n      ...this.event,\n      type: eventType.slug,\n      description: eventType.description,\n      eventTypeId: eventType.id,\n      hideCalendarNotes: eventType.hideCalendarNotes,\n      hideCalendarEventDetails: eventType.hideCalendarEventDetails,\n      hideOrganizerEmail: eventType.hideOrganizerEmail,\n      schedulingType: eventType.schedulingType,\n      seatsPerTimeSlot: eventType.seatsPerTimeSlot,\n      // if seats are not enabled we should default true\n      seatsShowAttendees: eventType.seatsPerTimeSlot ? eventType.seatsShowAttendees : true,\n      seatsShowAvailabilityCount: eventType.seatsPerTimeSlot ? eventType.seatsShowAvailabilityCount : true,\n      customReplyToEmail: eventType.customReplyToEmail,\n      disableRescheduling: eventType.disableRescheduling ?? false,\n      disableCancelling: eventType.disableCancelling ?? false,\n    };\n    return this;\n  }\n\n  withOrganizer(organizer: {\n    id: number;\n    name: string | null;\n    email: string;\n    username?: string;\n    usernameInOrg?: string;\n    timeZone: string;\n    timeFormat?: TimeFormat;\n    language: {\n      translate: TFunction;\n      locale: string;\n    };\n  }) {\n    this.event = {\n      ...this.event,\n      organizer: {\n        id: organizer.id,\n        name: organizer.name || \"Nameless\",\n        email: organizer.email,\n        username: organizer.username,\n        usernameInOrg: organizer.usernameInOrg,\n        timeZone: organizer.timeZone,\n        language: organizer.language,\n        timeFormat: organizer.timeFormat,\n      },\n    };\n    return this;\n  }\n\n  withAttendees(attendees: Person[]) {\n    this.event = {\n      ...this.event,\n      attendees,\n    };\n    return this;\n  }\n\n  withMetadataAndResponses({\n    additionalNotes,\n    customInputs,\n    responses,\n    userFieldsResponses,\n  }: {\n    additionalNotes?: string | null;\n    customInputs?: Prisma.JsonObject | null;\n    responses?: CalEventResponses | null;\n    userFieldsResponses?: CalEventResponses | null;\n  }) {\n    this.event = {\n      ...this.event,\n      additionalNotes,\n      customInputs,\n      responses,\n      userFieldsResponses,\n    };\n    return this;\n  }\n\n  withLocation({\n    location,\n    conferenceCredentialId,\n  }: {\n    location: string | null;\n    conferenceCredentialId?: number;\n  }) {\n    this.event = {\n      ...this.event,\n      location,\n      conferenceCredentialId,\n    };\n    return this;\n  }\n\n  withDestinationCalendar(destinationCalendar: CalendarEvent[\"destinationCalendar\"]) {\n    this.event = {\n      ...this.event,\n      destinationCalendar,\n    };\n    return this;\n  }\n\n  withIdentifiers({ iCalUID, iCalSequence }: { iCalUID?: string; iCalSequence?: number }) {\n    this.event = {\n      ...this.event,\n      iCalUID: iCalUID ?? this.event.iCalUID,\n      iCalSequence: iCalSequence ?? this.event.iCalSequence,\n    };\n    return this;\n  }\n\n  withConfirmation({\n    requiresConfirmation,\n    isConfirmedByDefault,\n  }: {\n    requiresConfirmation: boolean;\n    isConfirmedByDefault: boolean;\n  }) {\n    this.event = {\n      ...this.event,\n      requiresConfirmation,\n      oneTimePassword: isConfirmedByDefault ? null : undefined,\n    };\n    return this;\n  }\n\n  withPlatformVariables({\n    platformClientId,\n    platformRescheduleUrl,\n    platformCancelUrl,\n    platformBookingUrl,\n  }: {\n    platformClientId?: string | null;\n    platformRescheduleUrl?: string | null;\n    platformCancelUrl?: string | null;\n    platformBookingUrl?: string | null;\n  }) {\n    this.event = {\n      ...this.event,\n      platformClientId,\n      platformRescheduleUrl,\n      platformCancelUrl,\n      platformBookingUrl,\n    };\n    return this;\n  }\n\n  withAppsStatus(appsStatus?: AppsStatus[]) {\n    this.event = {\n      ...this.event,\n      appsStatus,\n    };\n    return",
            "output_extracted": "import type { TFunction } from \"i18next\";\n\nimport { getCalEventResponses } from \"@calcom/features/bookings/lib/getCalEventResponses\";\nimport type { BookingRepository } from \"@calcom/features/bookings/repositories/BookingRepository\";\nimport { getBookerBaseUrl } from \"@calcom/features/ee/organizations/lib/getBookerUrlServer\";\nimport { parseRecurringEvent } from \"@calcom/lib/isRecurringEvent\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { getTimeFormatStringFromUserTimeFormat, type TimeFormat } from \"@calcom/lib/timeFormat\";\nimport type { Attendee, BookingSeat, DestinationCalendar, Prisma, User } from \"@calcom/prisma/client\";\nimport type { SchedulingType } from \"@calcom/prisma/enums\";\nimport { bookingResponses as bookingResponsesSchema } from \"@calcom/prisma/zod-utils\";\nimport type { CalendarEvent, Person, CalEventResponses, AppsStatus } from \"@calcom/types/Calendar\";\nimport type { VideoCallData } from \"@calcom/types/VideoApiAdapter\";\n\nexport type BookingForCalEventBuilder = NonNullable<\n  Awaited<ReturnType<BookingRepository[\"getBookingForCalEventBuilder\"]>>\n>;\nexport type BookingMetaOptions = {\n  conferenceCredentialId?: number;\n  platformClientId?: string;\n  platformRescheduleUrl?: string;\n  platformCancelUrl?: string;\n  platformBookingUrl?: string;\n};\n\nasync function _buildPersonFromUser(\n  user: Pick<User, \"id\" | \"name\" | \"locale\" | \"username\" | \"email\" | \"timeFormat\" | \"timeZone\">\n) {\n  const translate = await getTranslation(user.locale ?? \"en\", \"common\");\n  return {\n    id: user.id,\n    name: user.name || \"Nameless\",\n    email: user.email,\n    username: user.username || undefined,\n    timeZone: user.timeZone,\n    language: { translate, locale: user.locale ?? \"en\" },\n    timeFormat: getTimeFormatStringFromUserTimeFormat(user.timeFormat),\n  } satisfies Person;\n}\n\nasync function _buildPersonFromAttendee(\n  attendee: Pick<Attendee, \"locale\" | \"name\" | \"timeZone\" | \"email\" | \"phoneNumber\"> & {\n    bookingSeat: Pick<\n      BookingSeat,\n      \"id\" | \"referenceUid\" | \"bookingId\" | \"metadata\" | \"data\" | \"attendeeId\"\n    > | null;\n  }\n) {\n  const translate = await getTranslation(attendee.locale ?? \"en\", \"common\");\n\n  return {\n    name: attendee.name ?? \"\",\n    email: attendee.email,\n    timeZone: attendee.timeZone,\n    language: { translate, locale: attendee.locale ?? \"en\" },\n    phoneNumber: attendee.phoneNumber,\n    bookingSeat: attendee.bookingSeat,\n  } satisfies Person;\n}\n\nexport class CalendarEventBuilder {\n  private event: Partial<CalendarEvent>;\n\n  constructor(existingEvent?: Partial<CalendarEvent>) {\n    this.event = existingEvent || {};\n  }\n\n  static fromEvent(event: Partial<CalendarEvent>) {\n    return new CalendarEventBuilder(event);\n  }\n\n  /**\n   * Builds a CalendarEventBuilder instance from a booking.\n   */\n  static async fromBooking(\n    booking: BookingForCalEventBuilder,\n    meta: BookingMetaOptions = {}\n  ): Promise<CalendarEventBuilder> {\n    const { uid, user, eventType } = booking;\n\n    if (!user) throw new Error(`Booking ${uid} is missing an organizer \u2014 user may have been deleted.`);\n    if (!eventType) throw new Error(`Booking ${uid} is missing eventType \u2014 it may have been deleted.`);\n\n    const builder = new CalendarEventBuilder();\n    const {\n      description,\n      attendees,\n      references,\n      title,\n      startTime,\n      endTime,\n      location,\n      responses,\n      customInputs,\n      iCalUID,\n      iCalSequence,\n      oneTimePassword,\n      seatsReferences,\n    } = booking;\n\n    const {\n      conferenceCredentialId,\n      platformRescheduleUrl = \"\",\n      platformClientId = \"\",\n      platformCancelUrl = \"\",\n      platformBookingUrl = \"\",\n    } = meta;\n\n    const organizerPerson = await _buildPersonFromUser(user);\n    const attendeesList = await Promise.all(attendees.map(_buildPersonFromAttendee));\n    const additionalNotes = description || undefined;\n\n    const videoRef = references.find((r) => r.type.endsWith(\"_video\"));\n    const videoCallData = videoRef\n      ? {\n          type: videoRef.type,\n          id: videoRef.meetingId,\n          password: videoRef.meetingPassword,\n          url: videoRef.meetingUrl,\n        }\n      : undefined;\n    const appsStatus: AppsStatus[] = [];\n\n    const organizationId = user.profiles?.[0]?.organizationId ?? null;\n    const bookerUrl = await getBookerBaseUrl(eventType.team?.parentId ?? organizationId);\n\n    const parsedBookingResponses = bookingResponsesSchema.safeParse(responses);\n    const bookingResponses = parsedBookingResponses.success ? parsedBookingResponses.data : null;\n\n    const calEventResponses = getCalEventResponses({\n      booking,\n      bookingFields: eventType.bookingFields,\n    });\n\n    // custom inputs are the old system to record booking responses\n    const parsedCustomInputs =\n      typeof customInputs === \"object\" ? (customInputs as Record<string, string>) : null;\n\n    const recurring = parseRecurringEvent(eventType.recurringEvent) ?? undefined;\n\n    // Base builder setup\n    builder\n      .withBasicDetails({\n        bookerUrl,\n        title,\n        startTime: startTime.toISOString(),\n        endTime: endTime.toISOString(),\n        additionalNotes,\n      })\n      .withEventType({\n        id: eventType.id,\n        slug: eventType.slug,\n        description: eventType.description,\n        hideCalendarNotes: eventType.hideCalendarNotes,\n        hideCalendarEventDetails: eventType.hideCalendarEventDetails,\n        hideOrganizerEmail: eventType.hideOrganizerEmail,\n        schedulingType: eventType.schedulingType,\n        seatsPerTimeSlot: eventType.seatsPerTimeSlot,\n        seatsShowAttendees: !!eventType.seatsShowAttendees,\n        seatsShowAvailabilityCount: !!eventType.seatsShowAvailabilityCount,\n        customReplyToEmail: eventType.customReplyToEmail,\n        disableRescheduling: eventType.disableRescheduling ?? false,\n        disableCancelling: eventType.disableCancelling ?? false,\n      })\n      .withOrganizer(organizerPerson)\n      .withAttendees(attendeesList)\n      .withMetadataAndResponses({\n        additionalNotes,\n        customInputs: parsedCustomInputs,\n        responses: calEventResponses.responses,\n        userFieldsResponses: calEventResponses.userFieldsResponses,\n      })\n      .withLocation({ location, conferenceCredentialId })\n      .withIdentifiers({ iCalUID: iCalUID || undefined, iCalSequence })\n      .withConfirmation({\n        requiresConfirmation: !!eventType.requiresConfirmation,\n        isConfirmedByDefault: !eventType.requiresConfirmation,\n      })\n      .withPlatformVariables({\n        platformClientId,\n        platformRescheduleUrl,\n        platformCancelUrl,\n        platformBookingUrl,\n      })\n      .withRecurring(recurring)\n      .withUid(uid)\n      .withOneTimePassword(oneTimePassword)\n      .withOrganization(organizationId);\n\n    // Seats\n    if (seatsReferences?.length && bookingResponses) {\n      const currentSeat = seatsReferences.find(\n        (s) =>\n          s.attendee.email === bookingResponses.email ||\n          (bookingResponses.attendeePhoneNumber &&\n            s.attendee.phoneNumber === bookingResponses.attendeePhoneNumber)\n      );\n      if (currentSeat) builder.withAttendeeSeatId(currentSeat.referenceUid);\n    }\n\n    // Video\n    if (videoCallData && videoCallData.url) {\n      builder.withVideoCallData({\n        ...videoCallData,\n        id: videoCallData.id ?? \"\",\n        password: videoCallData.password ?? \"\",\n        url: videoCallData.url,\n      });\n    }\n\n    references\n      .filter((r) => r && r.type)\n      .forEach((ref) => {\n        appsStatus.push({\n          appName: ref.type.replace(\"_\", \"-\"),\n          type: ref.type,\n          success: ref.uid ? 1 : 0,\n          failures: ref.uid ? 0 : 1,\n          errors: [],\n        });\n      });\n\n    if (appsStatus.length) {\n      builder.withAppsStatus(appsStatus);\n    }\n\n    // Team & calendars\n    if (eventType.team) {\n      const hostsWithoutOrganizer = await Promise.all(\n        eventType.hosts.filter((h) => h.user.email !== user.email).map((h) => _buildPersonFromUser(h.user))\n      );\n\n      const hostCalendars = [\n        ...eventType.hosts.map((h) => h.user.destinationCalendar).filter(Boolean),\n        user.destinationCalendar,\n      ].filter(Boolean) as NonNullable<DestinationCalendar>[];\n\n      builder\n        .withTeam({\n          id: eventType.team.id,\n          name: eventType.team.name || \"\",\n          members: hostsWithoutOrganizer,\n        })\n        .withDestinationCalendar(hostCalendars);\n    } else if (user.destinationCalendar) {\n      builder.withDestinationCalendar([user.destinationCalendar]);\n    }\n\n    return builder;\n  }\n\n  withBasicDetails({\n    bookerUrl,\n    title,\n    startTime,\n    endTime,\n    additionalNotes,\n  }: {\n    bookerUrl: string;\n    title: string;\n    startTime: string;\n    endTime: string;\n    additionalNotes?: string;\n  }) {\n    this.event = {\n      ...this.event,\n      bookerUrl,\n      title,\n      startTime,\n      endTime,\n      additionalNotes,\n    };\n    return this;\n  }\n\n  withEventType(eventType: {\n    slug: string;\n    description?: string | null;\n    id: number;\n    hideCalendarNotes?: boolean;\n    hideCalendarEventDetails?: boolean;\n    hideOrganizerEmail?: boolean;\n    schedulingType?: SchedulingType | null;\n    seatsPerTimeSlot?: number | null;\n    seatsShowAttendees?: boolean | null;\n    seatsShowAvailabilityCount?: boolean | null;\n    customReplyToEmail?: string | null;\n    disableRescheduling?: boolean;\n    disableCancelling?: boolean;\n  }) {\n    this.event = {\n      ...this.event,\n      type: eventType.slug,\n      description: eventType.description,\n      eventTypeId: eventType.id,\n      hideCalendarNotes: eventType.hideCalendarNotes,\n      hideCalendarEventDetails: eventType.hideCalendarEventDetails,\n      hideOrganizerEmail: eventType.hideOrganizerEmail,\n      schedulingType: eventType.schedulingType,\n      seatsPerTimeSlot: eventType.seatsPerTimeSlot,\n      // if seats are not enabled we should default true\n      seatsShowAttendees: eventType.seatsPerTimeSlot ? eventType.seatsShowAttendees : true,\n      seatsShowAvailabilityCount: eventType.seatsPerTimeSlot ? eventType.seatsShowAvailabilityCount : true,\n      customReplyToEmail: eventType.customReplyToEmail,\n      disableRescheduling: eventType.disableRescheduling ?? false,\n      disableCancelling: eventType.disableCancelling ?? false,\n    };\n    return this;\n  }\n\n  withOrganizer(organizer: {\n    id: number;\n    name: string | null;\n    email: string;\n    username?: string;\n    usernameInOrg?: string;\n    timeZone: string;\n    timeFormat?: TimeFormat;\n    language: {\n      translate: TFunction;\n      locale: string;\n    };\n  }) {\n    this.event = {\n      ...this.event,\n      organizer: {\n        id: organizer.id,\n        name: organizer.name || \"Nameless\",\n        email: organizer.email,\n        username: organizer.username,\n        usernameInOrg: organizer.usernameInOrg,\n        timeZone: organizer.timeZone,\n        language: organizer.language,\n        timeFormat: organizer.timeFormat,\n      },\n    };\n    return this;\n  }\n\n  withAttendees(attendees: Person[]) {\n    this.event = {\n      ...this.event,\n      attendees,\n    };\n    return this;\n  }\n\n  withMetadataAndResponses({\n    additionalNotes,\n    customInputs,\n    responses,\n    userFieldsResponses,\n  }: {\n    additionalNotes?: string | null;\n    customInputs?: Prisma.JsonObject | null;\n    responses?: CalEventResponses | null;\n    userFieldsResponses?: CalEventResponses | null;\n  }) {\n    this.event = {\n      ...this.event,\n      additionalNotes,\n      customInputs,\n      responses,\n      userFieldsResponses,\n    };\n    return this;\n  }\n\n  withLocation({\n    location,\n    conferenceCredentialId,\n  }: {\n    location: string | null;\n    conferenceCredentialId?: number;\n  }) {\n    this.event = {\n      ...this.event,\n      location,\n      conferenceCredentialId,\n    };\n    return this;\n  }\n\n  withDestinationCalendar(destinationCalendar: CalendarEvent[\"destinationCalendar\"]) {\n    this.event = {\n      ...this.event,\n      destinationCalendar,\n    };\n    return this;\n  }\n\n  withIdentifiers({ iCalUID, iCalSequence }: { iCalUID?: string; iCalSequence?: number }) {\n    this.event = {\n      ...this.event,\n      iCalUID: iCalUID ?? this.event.iCalUID,\n      iCalSequence: iCalSequence ?? this.event.iCalSequence,\n    };\n    return this;\n  }\n\n  withConfirmation({\n    requiresConfirmation,\n    isConfirmedByDefault,\n  }: {\n    requiresConfirmation: boolean;\n    isConfirmedByDefault: boolean;\n  }) {\n    this.event = {\n      ...this.event,\n      requiresConfirmation,\n      oneTimePassword: isConfirmedByDefault ? null : undefined,\n    };\n    return this;\n  }\n\n  withPlatformVariables({\n    platformClientId,\n    platformRescheduleUrl,\n    platformCancelUrl,\n    platformBookingUrl,\n  }: {\n    platformClientId?: string | null;\n    platformRescheduleUrl?: string | null;\n    platformCancelUrl?: string | null;\n    platformBookingUrl?: string | null;\n  }) {\n    this.event = {\n      ...this.event,\n      platformClientId,\n      platformRescheduleUrl,\n      platformCancelUrl,\n      platformBookingUrl,\n    };\n    return this;\n  }\n\n  withAppsStatus(appsStatus?: AppsStatus[]) {\n    this.event = {\n      ...this.event,\n      appsStatus,\n    };\n    return",
            "cost": 0.13348000000000002
        },
        "calcom__cal.com.main/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts": {
            "output": "import { describe, expect, vi, beforeEach, test } from \"vitest\";\n\nimport type { BookingSeatRepository } from \"@calcom/features/bookings/repositories/BookingSeatRepository\";\nimport type { WorkflowReminderRepository } from \"@calcom/features/ee/workflows/repositories/WorkflowReminderRepository\";\nimport { WorkflowActions, WorkflowTemplates, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\nimport type { CalendarEvent } from \"@calcom/types/Calendar\";\n\nvi.mock(\"@calcom/emails/workflow-email-service\", () => ({\n  sendCustomWorkflowEmail: vi.fn(),\n}));\n\nvi.mock(\"@calcom/features/profile/lib/hideBranding\", () => ({\n  getHideBranding: vi.fn().mockResolvedValue(false),\n}));\n\nvi.mock(\"@calcom/lib/server/i18n\", () => ({\n  getTranslation: vi.fn().mockResolvedValue((key: string) => key),\n}));\n\nvi.mock(\"@calcom/prisma\", () => ({\n  default: {},\n  prisma: {},\n}));\n\nimport { EmailWorkflowService } from \"./EmailWorkflowService\";\n\nconst mockWorkflowReminderRepository: Pick<WorkflowReminderRepository, \"findByIdIncludeStepAndWorkflow\"> = {\n  findByIdIncludeStepAndWorkflow: vi.fn(),\n};\n\nconst mockBookingSeatRepository: Pick<BookingSeatRepository, \"getByUidIncludeAttendee\"> = {\n  getByUidIncludeAttendee: vi.fn(),\n};\n\ndescribe(\"EmailWorkflowService\", () => {\n  let emailWorkflowService: EmailWorkflowService;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    emailWorkflowService = new EmailWorkflowService(\n      mockWorkflowReminderRepository as WorkflowReminderRepository,\n      mockBookingSeatRepository as BookingSeatRepository\n    );\n  });\n\n  describe(\"handleSendEmailWorkflowTask\", () => {\n    const mockEvt: Partial<CalendarEvent> = {\n      uid: \"booking-123\",\n      bookerUrl: \"https://cal.com\",\n      title: \"Test Meeting\",\n      startTime: \"2024-12-01T10:00:00Z\",\n      endTime: \"2024-12-01T11:00:00Z\",\n      organizer: {\n        name: \"Organizer Name\",\n        email: \"organizer@example.com\",\n        timeZone: \"UTC\",\n        language: { locale: \"en\", translate: (key: string) => key },\n        timeFormat: 12,\n      },\n      attendees: [\n        {\n          name: \"Attendee Name\",\n          email: \"attendee@example.com\",\n          timeZone: \"UTC\",\n          language: { locale: \"en\", translate: (key: string) => key },\n        },\n      ],\n    };\n\n    test(\"should throw error if workflow reminder not found\", async () => {\n      vi.mocked(mockWorkflowReminderRepository.findByIdIncludeStepAndWorkflow).mockResolvedValue(null);\n\n      await expect(\n        emailWorkflowService.handleSendEmailWorkflowTask({\n          evt: mockEvt as CalendarEvent,\n          workflowReminderId: 1,\n        })\n      ).rejects.toThrow(\"Workflow reminder not found with id 1\");\n    });\n\n    test(\"should throw error if workflow step not verified\", async () => {\n      vi.mocked(mockWorkflowReminderRepository.findByIdIncludeStepAndWorkflow).mockResolvedValue({\n        id: 1,\n        workflowStep: {\n          id: 1,\n          verifiedAt: null,\n          action: WorkflowActions.EMAIL_ATTENDEE,\n          workflow: { userId: 1, teamId: null },\n        },\n      });\n\n      await expect(\n        emailWorkflowService.handleSendEmailWorkflowTask({\n          evt: mockEvt as CalendarEvent,\n          workflowReminderId: 1,\n        })\n      ).rejects.toThrow(\"Workflow step id 1 is not verified\");\n    });\n\n    test(\"should throw error if workflow step not found on reminder\", async () => {\n      vi.mocked(mockWorkflowReminderRepository.findByIdIncludeStepAndWorkflow).mockResolvedValue({\n        id: 1,\n        workflowStep: null,\n      });\n\n      await expect(\n        emailWorkflowService.handleSendEmailWorkflowTask({\n          evt: mockEvt as CalendarEvent,\n          workflowReminderId: 1,\n        })\n      ).rejects.toThrow(\"Workflow step not found on reminder with id 1\");\n    });\n\n    test(\"should fetch seat attendee email for seated events\", async () => {\n      const mockWorkflowReminder = {\n        id: 1,\n        seatReferenceId: \"seat-123\",\n        workflowStep: {\n          id: 1,\n          action: WorkflowActions.EMAIL_ATTENDEE,\n          sendTo: null,\n          template: WorkflowTemplates.REMINDER,\n          reminderBody: null,\n          emailSubject: null,\n          sender: null,\n          includeCalendarEvent: false,\n          verifiedAt: new Date(),\n          workflow: {\n            userId: 1,\n            teamId: null,\n            trigger: WorkflowTriggerEvents.BEFORE_EVENT,\n            time: 24,\n            timeUnit: \"HOUR\",\n          },\n        },\n      };\n\n      vi.mocked(mockWorkflowReminderRepository.findByIdIncludeStepAndWorkflow).mockResolvedValue(\n        mockWorkflowReminder\n      );\n      vi.mocked(mockBookingSeatRepository.getByUidIncludeAttendee).mockResolvedValue({\n        attendee: {\n          email: \"seat-attendee@example.com\",\n        },\n      });\n\n      try {\n        await emailWorkflowService.handleSendEmailWorkflowTask({\n          evt: mockEvt as CalendarEvent,\n          workflowReminderId: 1,\n        });\n      } catch {\n        // Expected to throw due to incomplete mock setup - we only care about the seat lookup\n      }\n\n      expect(mockBookingSeatRepository.getByUidIncludeAttendee).toHaveBeenCalledWith(\"seat-123\");\n    });\n  });\n});",
            "output_extracted": "import { describe, expect, vi, beforeEach, test } from \"vitest\";\n\nimport type { BookingSeatRepository } from \"@calcom/features/bookings/repositories/BookingSeatRepository\";\nimport type { WorkflowReminderRepository } from \"@calcom/features/ee/workflows/repositories/WorkflowReminderRepository\";\nimport { WorkflowActions, WorkflowTemplates, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\nimport type { CalendarEvent } from \"@calcom/types/Calendar\";\n\nvi.mock(\"@calcom/emails/workflow-email-service\", () => ({\n  sendCustomWorkflowEmail: vi.fn(),\n}));\n\nvi.mock(\"@calcom/features/profile/lib/hideBranding\", () => ({\n  getHideBranding: vi.fn().mockResolvedValue(false),\n}));\n\nvi.mock(\"@calcom/lib/server/i18n\", () => ({\n  getTranslation: vi.fn().mockResolvedValue((key: string) => key),\n}));\n\nvi.mock(\"@calcom/prisma\", () => ({\n  default: {},\n  prisma: {},\n}));\n\nimport { EmailWorkflowService } from \"./EmailWorkflowService\";\n\nconst mockWorkflowReminderRepository: Pick<WorkflowReminderRepository, \"findByIdIncludeStepAndWorkflow\"> = {\n  findByIdIncludeStepAndWorkflow: vi.fn(),\n};\n\nconst mockBookingSeatRepository: Pick<BookingSeatRepository, \"getByUidIncludeAttendee\"> = {\n  getByUidIncludeAttendee: vi.fn(),\n};\n\ndescribe(\"EmailWorkflowService\", () => {\n  let emailWorkflowService: EmailWorkflowService;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    emailWorkflowService = new EmailWorkflowService(\n      mockWorkflowReminderRepository as WorkflowReminderRepository,\n      mockBookingSeatRepository as BookingSeatRepository\n    );\n  });\n\n  describe(\"handleSendEmailWorkflowTask\", () => {\n    const mockEvt: Partial<CalendarEvent> = {\n      uid: \"booking-123\",\n      bookerUrl: \"https://cal.com\",\n      title: \"Test Meeting\",\n      startTime: \"2024-12-01T10:00:00Z\",\n      endTime: \"2024-12-01T11:00:00Z\",\n      organizer: {\n        name: \"Organizer Name\",\n        email: \"organizer@example.com\",\n        timeZone: \"UTC\",\n        language: { locale: \"en\", translate: (key: string) => key },\n        timeFormat: 12,\n      },\n      attendees: [\n        {\n          name: \"Attendee Name\",\n          email: \"attendee@example.com\",\n          timeZone: \"UTC\",\n          language: { locale: \"en\", translate: (key: string) => key },\n        },\n      ],\n    };\n\n    test(\"should throw error if workflow reminder not found\", async () => {\n      vi.mocked(mockWorkflowReminderRepository.findByIdIncludeStepAndWorkflow).mockResolvedValue(null);\n\n      await expect(\n        emailWorkflowService.handleSendEmailWorkflowTask({\n          evt: mockEvt as CalendarEvent,\n          workflowReminderId: 1,\n        })\n      ).rejects.toThrow(\"Workflow reminder not found with id 1\");\n    });\n\n    test(\"should throw error if workflow step not verified\", async () => {\n      vi.mocked(mockWorkflowReminderRepository.findByIdIncludeStepAndWorkflow).mockResolvedValue({\n        id: 1,\n        workflowStep: {\n          id: 1,\n          verifiedAt: null,\n          action: WorkflowActions.EMAIL_ATTENDEE,\n          workflow: { userId: 1, teamId: null },\n        },\n      });\n\n      await expect(\n        emailWorkflowService.handleSendEmailWorkflowTask({\n          evt: mockEvt as CalendarEvent,\n          workflowReminderId: 1,\n        })\n      ).rejects.toThrow(\"Workflow step id 1 is not verified\");\n    });\n\n    test(\"should throw error if workflow step not found on reminder\", async () => {\n      vi.mocked(mockWorkflowReminderRepository.findByIdIncludeStepAndWorkflow).mockResolvedValue({\n        id: 1,\n        workflowStep: null,\n      });\n\n      await expect(\n        emailWorkflowService.handleSendEmailWorkflowTask({\n          evt: mockEvt as CalendarEvent,\n          workflowReminderId: 1,\n        })\n      ).rejects.toThrow(\"Workflow step not found on reminder with id 1\");\n    });\n\n    test(\"should fetch seat attendee email for seated events\", async () => {\n      const mockWorkflowReminder = {\n        id: 1,\n        seatReferenceId: \"seat-123\",\n        workflowStep: {\n          id: 1,\n          action: WorkflowActions.EMAIL_ATTENDEE,\n          sendTo: null,\n          template: WorkflowTemplates.REMINDER,\n          reminderBody: null,\n          emailSubject: null,\n          sender: null,\n          includeCalendarEvent: false,\n          verifiedAt: new Date(),\n          workflow: {\n            userId: 1,\n            teamId: null,\n            trigger: WorkflowTriggerEvents.BEFORE_EVENT,\n            time: 24,\n            timeUnit: \"HOUR\",\n          },\n        },\n      };\n\n      vi.mocked(mockWorkflowReminderRepository.findByIdIncludeStepAndWorkflow).mockResolvedValue(\n        mockWorkflowReminder\n      );\n      vi.mocked(mockBookingSeatRepository.getByUidIncludeAttendee).mockResolvedValue({\n        attendee: {\n          email: \"seat-attendee@example.com\",\n        },\n      });\n\n      try {\n        await emailWorkflowService.handleSendEmailWorkflowTask({\n          evt: mockEvt as CalendarEvent,\n          workflowReminderId: 1,\n        });\n      } catch {\n        // Expected to throw due to incomplete mock setup - we only care about the seat lookup\n      }\n\n      expect(mockBookingSeatRepository.getByUidIncludeAttendee).toHaveBeenCalledWith(\"seat-123\");\n    });\n  });\n});",
            "cost": 0.07934
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25597",
        "repo": "calcom/cal.com",
        "base_commit": "06055729692e4e6df0f1684d94158b75ac7c02bb",
        "head_commit": "80f829e1ba2470cc1849cd5dbfc54cd842346b7c",
        "title": "fix: workflow reminder send to all RR hosts.",
        "merged_at": "2025-12-04T07:21:48Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25597",
        "test_files": [
            "packages/features/CalendarEventBuilder.test.ts",
            "packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts"
        ],
        "code_files": [
            "packages/features/CalendarEventBuilder.ts"
        ],
        "total_changes": 273,
        "num_files": 3,
        "pull_number": 25597,
        "patch": "diff --git a/packages/features/CalendarEventBuilder.test.ts b/packages/features/CalendarEventBuilder.test.ts\nindex cd12f0f26e85dc..4bede68260953e 100644\n--- a/packages/features/CalendarEventBuilder.test.ts\n+++ b/packages/features/CalendarEventBuilder.test.ts\n@@ -980,6 +980,9 @@ describe(\"CalendarEventBuilder\", () => {\n     });\n \n     it(\"should create a calendar event from booking with team\", async () => {\n+      // Note: The CalendarEventBuilder filters team members to only include hosts\n+      // whose emails appear in booking.attendees. This simulates a COLLECTIVE event\n+      // where all hosts are assigned to the booking.\n       const mockBooking = {\n         uid: \"booking-789\",\n         metadata: null,\n@@ -1001,6 +1004,14 @@ describe(\"CalendarEventBuilder\", () => {\n             locale: \"en\",\n             phoneNumber: null,\n           },\n+          {\n+            // Team member host - included in attendees for COLLECTIVE events\n+            name: \"Team Member\",\n+            email: \"member@example.com\",\n+            timeZone: \"America/Los_Angeles\",\n+            locale: \"en\",\n+            phoneNumber: null,\n+          },\n         ],\n         user: {\n           id: 3,\n@@ -1647,6 +1658,14 @@ describe(\"CalendarEventBuilder\", () => {\n             locale: \"en\",\n             phoneNumber: null,\n           },\n+          {\n+            // Team member host - included in attendees for COLLECTIVE events\n+            name: \"Team Member\",\n+            email: \"member@example.com\",\n+            timeZone: \"America/Los_Angeles\",\n+            locale: \"en\",\n+            phoneNumber: null,\n+          },\n         ],\n         user: {\n           id: 100,\n@@ -1836,12 +1855,14 @@ describe(\"CalendarEventBuilder\", () => {\n       expect(builtFromBooking.organizer.username).toBe(\"teamlead\");\n       expect(builtFromBooking.organizer.timeZone).toBe(\"America/New_York\");\n \n-      expect(builtFromBooking.attendees).toHaveLength(2);\n+      expect(builtFromBooking.attendees).toHaveLength(3);\n       expect(builtFromBooking.attendees[0].name).toBe(\"Complete User\");\n       expect(builtFromBooking.attendees[0].email).toBe(\"complete@example.com\");\n       expect(builtFromBooking.attendees[0].timeZone).toBe(\"America/New_York\");\n       expect(builtFromBooking.attendees[1].name).toBe(\"Guest User\");\n       expect(builtFromBooking.attendees[1].email).toBe(\"guest@example.com\");\n+      expect(builtFromBooking.attendees[2].name).toBe(\"Team Member\");\n+      expect(builtFromBooking.attendees[2].email).toBe(\"member@example.com\");\n \n       expect(builtFromBooking.team).toBeDefined();\n       expect(builtFromBooking.team?.id).toBe(50);\ndiff --git a/packages/features/CalendarEventBuilder.ts b/packages/features/CalendarEventBuilder.ts\nindex 9ec0e6346a25ba..492b1aed7d455a 100644\n--- a/packages/features/CalendarEventBuilder.ts\n+++ b/packages/features/CalendarEventBuilder.ts\n@@ -7,7 +7,7 @@ import { parseRecurringEvent } from \"@calcom/lib/isRecurringEvent\";\n import { getTranslation } from \"@calcom/lib/server/i18n\";\n import { getTimeFormatStringFromUserTimeFormat, type TimeFormat } from \"@calcom/lib/timeFormat\";\n import type { Attendee, BookingSeat, DestinationCalendar, Prisma, User } from \"@calcom/prisma/client\";\n-import type { SchedulingType } from \"@calcom/prisma/enums\";\n+import { SchedulingType } from \"@calcom/prisma/enums\";\n import { bookingResponses as bookingResponsesSchema } from \"@calcom/prisma/zod-utils\";\n import type { CalendarEvent, Person, CalEventResponses, AppsStatus } from \"@calcom/types/Calendar\";\n import type { VideoCallData } from \"@calcom/types/VideoApiAdapter\";\n@@ -226,12 +226,25 @@ export class CalendarEventBuilder {\n \n     // Team & calendars\n     if (eventType.team) {\n+      // We need to get the team members assigned to the booking\n+      // In the DB team members are stored in the Attendee table\n+      const bookingAttendees = booking.attendees;\n+\n+      const hostsToInclude = eventType.hosts.filter((host) =>\n+        bookingAttendees.some((attendee) => attendee.email === host.user.email)\n+      );\n+\n+      const hostsWithoutOrganizerData = hostsToInclude.filter(\n+        (host) => host.user.email !== user.email\n+      );\n+\n       const hostsWithoutOrganizer = await Promise.all(\n-        eventType.hosts.filter((h) => h.user.email !== user.email).map((h) => _buildPersonFromUser(h.user))\n+        hostsWithoutOrganizerData.map((host) => _buildPersonFromUser(host.user))\n       );\n \n       const hostCalendars = [\n-        ...eventType.hosts.map((h) => h.user.destinationCalendar).filter(Boolean),\n+        user.destinationCalendar,\n+        ...hostsWithoutOrganizerData.map((h) => h.user.destinationCalendar).filter(Boolean),\n         user.destinationCalendar,\n       ].filter(Boolean) as NonNullable<DestinationCalendar>[];\n \ndiff --git a/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts b/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts\nindex 64fd338591ab7c..b11f5d7cc1cc27 100644\n--- a/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts\n+++ b/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts\n@@ -2,9 +2,17 @@ import { describe, expect, vi, beforeEach, test } from \"vitest\";\n \n import type { BookingSeatRepository } from \"@calcom/features/bookings/repositories/BookingSeatRepository\";\n import type { WorkflowReminderRepository } from \"@calcom/features/ee/workflows/repositories/WorkflowReminderRepository\";\n-import { WorkflowActions, WorkflowTemplates, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\n+import {\n+  SchedulingType,\n+  TimeUnit,\n+  WorkflowActions,\n+  WorkflowTemplates,\n+  WorkflowTriggerEvents,\n+} from \"@calcom/prisma/enums\";\n import type { CalendarEvent } from \"@calcom/types/Calendar\";\n \n+import { EmailWorkflowService } from \"./EmailWorkflowService\";\n+\n vi.mock(\"@calcom/emails/workflow-email-service\", () => ({\n   sendCustomWorkflowEmail: vi.fn(),\n }));\n@@ -22,8 +30,6 @@ vi.mock(\"@calcom/prisma\", () => ({\n   prisma: {},\n }));\n \n-import { EmailWorkflowService } from \"./EmailWorkflowService\";\n-\n const mockWorkflowReminderRepository: Pick<WorkflowReminderRepository, \"findByIdIncludeStepAndWorkflow\"> = {\n   findByIdIncludeStepAndWorkflow: vi.fn(),\n };\n@@ -156,4 +162,223 @@ describe(\"EmailWorkflowService\", () => {\n       expect(mockBookingSeatRepository.getByUidIncludeAttendee).toHaveBeenCalledWith(\"seat-123\");\n     });\n   });\n+\n+  describe(\"generateParametersToBuildEmailWorkflowContent - EMAIL_HOST\", () => {\n+    const mockCommonScheduleFunctionParams = {\n+      triggerEvent: WorkflowTriggerEvents.BEFORE_EVENT,\n+      timeSpan: {\n+        time: 24,\n+        timeUnit: TimeUnit.HOUR,\n+      },\n+      workflowStepId: 1,\n+      template: WorkflowTemplates.REMINDER,\n+      userId: 1,\n+      teamId: null,\n+      seatReferenceUid: undefined,\n+      verifiedAt: new Date(),\n+      creditCheckFn: vi.fn().mockResolvedValue(true),\n+    };\n+\n+    const baseMockEvt: Partial<CalendarEvent> = {\n+      uid: \"booking-123\",\n+      bookerUrl: \"https://cal.com\",\n+      title: \"Test Meeting\",\n+      startTime: \"2024-12-01T10:00:00Z\",\n+      endTime: \"2024-12-01T11:00:00Z\",\n+      organizer: {\n+        name: \"Organizer Name\",\n+        email: \"organizer@example.com\",\n+        timeZone: \"UTC\",\n+        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+        language: { locale: \"en\", translate: (() => \"\") as any },\n+        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+        timeFormat: \"h:mma\" as any,\n+      },\n+      attendees: [\n+        {\n+          name: \"Attendee Name\",\n+          email: \"attendee@example.com\",\n+          timeZone: \"UTC\",\n+          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+          language: { locale: \"en\", translate: (() => \"\") as any },\n+        },\n+      ],\n+    };\n+\n+    const mockWorkflowStep = {\n+      id: 1,\n+      action: WorkflowActions.EMAIL_HOST,\n+      verifiedAt: new Date(),\n+      sendTo: null,\n+      template: WorkflowTemplates.REMINDER,\n+      reminderBody: null,\n+      emailSubject: null,\n+      sender: null,\n+      includeCalendarEvent: false,\n+      numberVerificationPending: false,\n+      numberRequired: false,\n+    };\n+\n+    test(\"should send to organizer and team members for ROUND_ROBIN scheduling type\", async () => {\n+      // Note: For ROUND_ROBIN, the CalendarEventBuilder filters team members to only include\n+      // those assigned to the booking. EmailWorkflowService sends to all team members in evt.team.members.\n+      const mockEvt: Partial<CalendarEvent> = {\n+        ...baseMockEvt,\n+        schedulingType: SchedulingType.ROUND_ROBIN,\n+        team: {\n+          id: 1,\n+          name: \"Test Team\",\n+          members: [\n+            {\n+              id: 1,\n+              name: \"Team Member 1\",\n+              email: \"team1@example.com\",\n+              timeZone: \"UTC\",\n+              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+              language: { locale: \"en\", translate: (() => \"\") as any },\n+            },\n+            {\n+              id: 2,\n+              name: \"Team Member 2\",\n+              email: \"team2@example.com\",\n+              timeZone: \"UTC\",\n+              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+              language: { locale: \"en\", translate: (() => \"\") as any },\n+            },\n+          ],\n+        },\n+      };\n+\n+      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n+        evt: mockEvt as CalendarEvent,\n+        workflowStep: mockWorkflowStep,\n+        workflow: { userId: 1 },\n+        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n+        hideBranding: false,\n+      });\n+\n+      // EmailWorkflowService sends to organizer + all team members in evt.team.members\n+      // The filtering of team members happens in CalendarEventBuilder, not here\n+      expect(result.sendTo).toContain(\"organizer@example.com\");\n+      expect(result.sendTo).toContain(\"team1@example.com\");\n+      expect(result.sendTo).toContain(\"team2@example.com\");\n+      expect(result.sendTo.length).toBe(3);\n+    });\n+\n+    test(\"should send to organizer and team members for COLLECTIVE scheduling type\", async () => {\n+      const mockEvt: Partial<CalendarEvent> = {\n+        ...baseMockEvt,\n+        schedulingType: SchedulingType.COLLECTIVE,\n+        team: {\n+          id: 1,\n+          name: \"Test Team\",\n+          members: [\n+            {\n+              id: 1,\n+              name: \"Team Member 1\",\n+              email: \"team1@example.com\",\n+              timeZone: \"UTC\",\n+              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+              language: { locale: \"en\", translate: (() => \"\") as any },\n+            },\n+            {\n+              id: 2,\n+              name: \"Team Member 2\",\n+              email: \"team2@example.com\",\n+              timeZone: \"UTC\",\n+              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+              language: { locale: \"en\", translate: (() => \"\") as any },\n+            },\n+          ],\n+        },\n+      };\n+\n+      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n+        evt: mockEvt as CalendarEvent,\n+        workflowStep: mockWorkflowStep,\n+        workflow: { userId: 1 },\n+        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n+        hideBranding: false,\n+      });\n+\n+      expect(result.sendTo).toContain(\"organizer@example.com\");\n+      expect(result.sendTo).toContain(\"team1@example.com\");\n+      expect(result.sendTo).toContain(\"team2@example.com\");\n+      expect(result.sendTo.length).toBe(3);\n+    });\n+\n+    test(\"should send to organizer only when team is undefined for COLLECTIVE\", async () => {\n+      const mockEvt: Partial<CalendarEvent> = {\n+        ...baseMockEvt,\n+        schedulingType: SchedulingType.COLLECTIVE,\n+        team: undefined,\n+      } as Partial<CalendarEvent>;\n+\n+      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n+        evt: mockEvt as CalendarEvent,\n+        workflowStep: mockWorkflowStep,\n+        workflow: { userId: 1 },\n+        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n+        hideBranding: false,\n+      });\n+\n+      expect(result.sendTo).toEqual([\"organizer@example.com\"]);\n+      expect(result.sendTo.length).toBe(1);\n+    });\n+\n+    test(\"should send to organizer only when team members array is empty for COLLECTIVE\", async () => {\n+      const mockEvt: Partial<CalendarEvent> = {\n+        ...baseMockEvt,\n+        schedulingType: SchedulingType.COLLECTIVE,\n+        team: {\n+          id: 1,\n+          name: \"Test Team\",\n+          members: [],\n+        },\n+      };\n+\n+      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n+        evt: mockEvt as CalendarEvent,\n+        workflowStep: mockWorkflowStep,\n+        workflow: { userId: 1 },\n+        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n+        hideBranding: false,\n+      });\n+\n+      expect(result.sendTo).toEqual([\"organizer@example.com\"]);\n+      expect(result.sendTo.length).toBe(1);\n+    });\n+\n+    test(\"should send to organizer only for other scheduling types (e.g., null)\", async () => {\n+      const mockEvt: Partial<CalendarEvent> = {\n+        ...baseMockEvt,\n+        schedulingType: null,\n+        team: {\n+          id: 1,\n+          name: \"Test Team\",\n+          members: [\n+            {\n+              id: 1,\n+              name: \"Team Member 1\",\n+              email: \"team1@example.com\",\n+              timeZone: \"UTC\",\n+              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+              language: { locale: \"en\", translate: (() => \"\") as any },\n+            },\n+          ],\n+        },\n+      } as Partial<CalendarEvent>;\n+\n+      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n+        evt: mockEvt as CalendarEvent,\n+        workflowStep: mockWorkflowStep,\n+        workflow: { userId: 1 },\n+        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n+        hideBranding: false,\n+      });\n+\n+      expect(result.sendTo).toEqual([\"organizer@example.com\"]);\n+      expect(result.sendTo.length).toBe(1);\n+    });\n+  });\n });\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}