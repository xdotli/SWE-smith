{
    "cost": 0.24180000000000001,
    "rewrites": {
        "calcom__cal.com.main/packages/features/pbac/services/__tests__/role-management.factory.test.ts": {
            "output": "import { vi, describe, it, expect, beforeEach } from \"vitest\";\n\nimport { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\nimport { isOrganisationAdmin } from \"@calcom/lib/server/queries/organisations\";\nimport { prisma } from \"@calcom/prisma\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\n\nimport { RoleManagementError, RoleManagementErrorCode } from \"../../domain/errors/role-management.error\";\nimport { DEFAULT_ROLE_IDS } from \"../../lib/constants\";\nimport { PermissionCheckService } from \"../permission-check.service\";\nimport { RoleManagementFactory } from \"../role-management.factory\";\nimport { RoleService } from \"../role.service\";\n\n// Mock dependencies\nvi.mock(\"@calcom/features/flags/features.repository\");\nvi.mock(\"../role.service\");\nvi.mock(\"../permission-check.service\");\nvi.mock(\"@calcom/prisma\", () => ({\n  prisma: {\n    membership: {\n      update: vi.fn(),\n      findUnique: vi.fn(),\n      count: vi.fn(),\n    },\n  },\n}));\nvi.mock(\"@calcom/lib/server/queries/organisations\", () => ({\n  isOrganisationAdmin: vi.fn(),\n}));\n\ndescribe(\"RoleManagementFactory\", () => {\n  const organizationId = 123;\n  const userId = 456;\n  const membershipId = 789;\n  const role = MembershipRole.ADMIN;\n\n  let factory: RoleManagementFactory;\n  let mockFeaturesRepository: { checkIfTeamHasFeature: ReturnType<typeof vi.fn> };\n  let mockRoleService: {\n    assignRoleToMember: ReturnType<typeof vi.fn>;\n    roleBelongsToTeam: ReturnType<typeof vi.fn>;\n  };\n  let mockPermissionCheckService: { checkPermission: ReturnType<typeof vi.fn> };\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n\n    // Setup mocks\n    mockFeaturesRepository = {\n      checkIfTeamHasFeature: vi.fn(),\n    };\n\n    mockRoleService = {\n      assignRoleToMember: vi.fn(),\n      roleBelongsToTeam: vi.fn(),\n    };\n\n    mockPermissionCheckService = {\n      checkPermission: vi.fn(),\n    };\n\n    // Reset singleton instance and set up mocks\n    Object.defineProperty(RoleManagementFactory, \"instance\", {\n      value: undefined,\n      writable: true,\n    });\n\n    vi.spyOn(FeaturesRepository.prototype, \"checkIfTeamHasFeature\").mockImplementation(\n      mockFeaturesRepository.checkIfTeamHasFeature\n    );\n    vi.spyOn(RoleService.prototype, \"assignRoleToMember\").mockImplementation(\n      mockRoleService.assignRoleToMember\n    );\n    vi.spyOn(RoleService.prototype, \"roleBelongsToTeam\").mockImplementation(\n      mockRoleService.roleBelongsToTeam\n    );\n    vi.spyOn(PermissionCheckService.prototype, \"checkPermission\").mockImplementation(\n      mockPermissionCheckService.checkPermission\n    );\n\n    factory = RoleManagementFactory.getInstance();\n  });\n\n  describe(\"getInstance\", () => {\n    it(\"should create a singleton instance\", () => {\n      const instance1 = RoleManagementFactory.getInstance();\n      const instance2 = RoleManagementFactory.getInstance();\n      expect(instance1).toBe(instance2);\n    });\n  });\n\n  describe(\"createRoleManager\", () => {\n    it(\"should create PBACRoleManager when PBAC is enabled\", async () => {\n      mockFeaturesRepository.checkIfTeamHasFeature.mockResolvedValue(true);\n      const manager = await factory.createRoleManager(organizationId);\n      expect(manager.constructor.name).toBe(\"PBACRoleManager\");\n    });\n\n    it(\"should create LegacyRoleManager when PBAC is disabled\", async () => {\n      mockFeaturesRepository.checkIfTeamHasFeature.mockResolvedValue(false);\n      const manager = await factory.createRoleManager(organizationId);\n      expect(manager.constructor.name).toBe(\"LegacyRoleManager\");\n    });\n  });\n\n  describe(\"PBACRoleManager\", () => {\n    beforeEach(() => {\n      mockFeaturesRepository.checkIfTeamHasFeature.mockResolvedValue(true);\n    });\n\n    describe(\"checkPermissionToChangeRole\", () => {\n      it(\"should allow role change when user has permission\", async () => {\n        mockPermissionCheckService.checkPermission.mockResolvedValue(true);\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.checkPermissionToChangeRole(userId, organizationId, \"org\")\n        ).resolves.not.toThrow();\n      });\n\n      it(\"should throw UNAUTHORIZED when user lacks permission\", async () => {\n        mockPermissionCheckService.checkPermission.mockResolvedValue(false);\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(manager.checkPermissionToChangeRole(userId, organizationId, \"org\")).rejects.toThrow(\n          new RoleManagementError(\n            \"You do not have permission to change roles\",\n            RoleManagementErrorCode.UNAUTHORIZED\n          )\n        );\n      });\n    });\n\n    describe(\"assignRole\", () => {\n      it(\"should assign default role correctly\", async () => {\n        // Mock non-owner membership to bypass owner validation\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: null,\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        mockRoleService.assignRoleToMember.mockResolvedValue(undefined);\n        const manager = await factory.createRoleManager(organizationId);\n        await manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId);\n        expect(mockRoleService.assignRoleToMember).toHaveBeenCalledWith(\n          DEFAULT_ROLE_IDS[MembershipRole.ADMIN],\n          membershipId\n        );\n      });\n\n      it(\"should assign custom role after validation\", async () => {\n        const customRoleId = \"custom-role-123\";\n\n        // Mock non-owner membership to bypass owner validation\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: null,\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        mockRoleService.roleBelongsToTeam.mockResolvedValue(true);\n        mockRoleService.assignRoleToMember.mockResolvedValue(undefined);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await manager.assignRole(userId, organizationId, customRoleId as MembershipRole, membershipId);\n\n        expect(mockRoleService.roleBelongsToTeam).toHaveBeenCalledWith(customRoleId, organizationId);\n        expect(mockRoleService.assignRoleToMember).toHaveBeenCalledWith(customRoleId, membershipId);\n      });\n\n      it(\"should throw INVALID_ROLE for invalid custom role\", async () => {\n        const customRoleId = \"invalid-role\";\n        mockRoleService.roleBelongsToTeam.mockResolvedValue(false);\n\n        // Mock non-owner membership to bypass owner validation\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: null,\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, customRoleId as MembershipRole, membershipId)\n        ).rejects.toThrow(\n          new RoleManagementError(\"You do not have access to this role\", RoleManagementErrorCode.INVALID_ROLE)\n        );\n      });\n\n      it(\"should prevent changing the last owner to non-owner role\", async () => {\n        // Mock current membership as owner with customRoleId\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: DEFAULT_ROLE_IDS[MembershipRole.OWNER],\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        // Mock count showing only 1 owner\n        vi.mocked(prisma.membership.count).mockResolvedValue(1);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId)\n        ).rejects.toThrow(\n          new RoleManagementError(\n            \"Cannot change the role of the last owner in the organization\",\n            RoleManagementErrorCode.UNAUTHORIZED\n          )\n        );\n      });\n\n      it(\"should prevent changing the last legacy owner to non-owner role\", async () => {\n        // Mock current membership as legacy owner (role field)\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.OWNER,\n          customRoleId: null,\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        // Mock count showing only 1 owner\n        vi.mocked(prisma.membership.count).mockResolvedValue(1);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId)\n        ).rejects.toThrow(\n          new RoleManagementError(\n            \"Cannot change the role of the last owner in the organization\",\n            RoleManagementErrorCode.UNAUTHORIZED\n          )\n        );\n      });\n\n      it(\"should allow changing owner role when multiple owners exist\", async () => {\n        // Mock current membership as owner\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: DEFAULT_ROLE_IDS[MembershipRole.OWNER],\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        // Mock count showing multiple owners\n        vi.mocked(prisma.membership.count).mockResolvedValue(2);\n        mockRoleService.assignRoleToMember.mockResolvedValue(undefined);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId)\n        ).resolves.not.toThrow();\n\n        expect(mockRoleService.assignRoleToMember).toHaveBeenCalledWith(\n          DEFAULT_ROLE_IDS[MembershipRole.ADMIN],\n          membershipId\n        );\n      });\n\n      it(\"should allow changing owner to owner (same role)\", async () => {\n        // Mock current membership as owner\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: DEFAULT_ROLE_IDS[MembershipRole.OWNER],\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        // Mock count showing only 1 owner (should be bypassed)\n        vi.mocked(prisma.membership.count).mockResolvedValue(1);\n        mockRoleService.assignRoleToMember.mockResolvedValue(undefined);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.OWNER, membershipId)\n        ).resolves.not.toThrow();\n\n        expect(mockRoleService.assignRoleToMember).toHaveBeenCalledWith(\n          DEFAULT_ROLE_IDS[MembershipRole.OWNER],\n          membershipId\n        );\n      });\n\n      it(\"should allow changing non-owner role without validation\", async () => {\n        // Mock current membership as non-owner\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: null,\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        mockRoleService.assignRoleToMember.mockResolvedValue(undefined);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId)\n        ).resolves.not.toThrow();\n\n        expect(mockRoleService.assignRoleToMember).toHaveBeenCalledWith(\n          DEFAULT_ROLE_IDS[MembershipRole.ADMIN],\n          membershipId\n        );\n        // Should not call count since it's not an owner\n        expect(prisma.membership.count).not.toHaveBeenCalled();\n      });\n\n      it(\"should throw error when membership is not found\", async () => {\n        // Mock membership not found\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue(null);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId)\n        ).rejects.toThrow(\n          new RoleManagementError(\"Membership not found\", RoleManagementErrorCode.UNAUTHORIZED)\n        );\n      });\n    });\n  });\n\n  describe(\"LegacyRoleManager\", () => {\n    beforeEach(() => {\n      mockFeaturesRepository.checkIfTeamHasFeature.mockResolvedValue(false);\n      vi.mocked(prisma.membership.update).mockResolvedValue({\n        id: 1,\n        teamId: organizationId,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        role: MembershipRole.MEMBER,\n        userId: userId,\n        disableImpersonation: false,\n        accepted: true,\n        customRoleId: null,\n      });\n      vi.mocked(isOrganisationAdmin).mockResolvedValue(false);\n    });\n\n    describe(\"checkPermissionToChangeRole\", () => {\n      it(\"should allow role change when user is owner\", async () => {\n        vi.mocked(isOrganisationAdmin).mockResolvedValue({\n          id: 1,\n          teamId:",
            "output_extracted": "import { vi, describe, it, expect, beforeEach } from \"vitest\";\n\nimport { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\nimport { isOrganisationAdmin } from \"@calcom/lib/server/queries/organisations\";\nimport { prisma } from \"@calcom/prisma\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\n\nimport { RoleManagementError, RoleManagementErrorCode } from \"../../domain/errors/role-management.error\";\nimport { DEFAULT_ROLE_IDS } from \"../../lib/constants\";\nimport { PermissionCheckService } from \"../permission-check.service\";\nimport { RoleManagementFactory } from \"../role-management.factory\";\nimport { RoleService } from \"../role.service\";\n\n// Mock dependencies\nvi.mock(\"@calcom/features/flags/features.repository\");\nvi.mock(\"../role.service\");\nvi.mock(\"../permission-check.service\");\nvi.mock(\"@calcom/prisma\", () => ({\n  prisma: {\n    membership: {\n      update: vi.fn(),\n      findUnique: vi.fn(),\n      count: vi.fn(),\n    },\n  },\n}));\nvi.mock(\"@calcom/lib/server/queries/organisations\", () => ({\n  isOrganisationAdmin: vi.fn(),\n}));\n\ndescribe(\"RoleManagementFactory\", () => {\n  const organizationId = 123;\n  const userId = 456;\n  const membershipId = 789;\n  const role = MembershipRole.ADMIN;\n\n  let factory: RoleManagementFactory;\n  let mockFeaturesRepository: { checkIfTeamHasFeature: ReturnType<typeof vi.fn> };\n  let mockRoleService: {\n    assignRoleToMember: ReturnType<typeof vi.fn>;\n    roleBelongsToTeam: ReturnType<typeof vi.fn>;\n  };\n  let mockPermissionCheckService: { checkPermission: ReturnType<typeof vi.fn> };\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n\n    // Setup mocks\n    mockFeaturesRepository = {\n      checkIfTeamHasFeature: vi.fn(),\n    };\n\n    mockRoleService = {\n      assignRoleToMember: vi.fn(),\n      roleBelongsToTeam: vi.fn(),\n    };\n\n    mockPermissionCheckService = {\n      checkPermission: vi.fn(),\n    };\n\n    // Reset singleton instance and set up mocks\n    Object.defineProperty(RoleManagementFactory, \"instance\", {\n      value: undefined,\n      writable: true,\n    });\n\n    vi.spyOn(FeaturesRepository.prototype, \"checkIfTeamHasFeature\").mockImplementation(\n      mockFeaturesRepository.checkIfTeamHasFeature\n    );\n    vi.spyOn(RoleService.prototype, \"assignRoleToMember\").mockImplementation(\n      mockRoleService.assignRoleToMember\n    );\n    vi.spyOn(RoleService.prototype, \"roleBelongsToTeam\").mockImplementation(\n      mockRoleService.roleBelongsToTeam\n    );\n    vi.spyOn(PermissionCheckService.prototype, \"checkPermission\").mockImplementation(\n      mockPermissionCheckService.checkPermission\n    );\n\n    factory = RoleManagementFactory.getInstance();\n  });\n\n  describe(\"getInstance\", () => {\n    it(\"should create a singleton instance\", () => {\n      const instance1 = RoleManagementFactory.getInstance();\n      const instance2 = RoleManagementFactory.getInstance();\n      expect(instance1).toBe(instance2);\n    });\n  });\n\n  describe(\"createRoleManager\", () => {\n    it(\"should create PBACRoleManager when PBAC is enabled\", async () => {\n      mockFeaturesRepository.checkIfTeamHasFeature.mockResolvedValue(true);\n      const manager = await factory.createRoleManager(organizationId);\n      expect(manager.constructor.name).toBe(\"PBACRoleManager\");\n    });\n\n    it(\"should create LegacyRoleManager when PBAC is disabled\", async () => {\n      mockFeaturesRepository.checkIfTeamHasFeature.mockResolvedValue(false);\n      const manager = await factory.createRoleManager(organizationId);\n      expect(manager.constructor.name).toBe(\"LegacyRoleManager\");\n    });\n  });\n\n  describe(\"PBACRoleManager\", () => {\n    beforeEach(() => {\n      mockFeaturesRepository.checkIfTeamHasFeature.mockResolvedValue(true);\n    });\n\n    describe(\"checkPermissionToChangeRole\", () => {\n      it(\"should allow role change when user has permission\", async () => {\n        mockPermissionCheckService.checkPermission.mockResolvedValue(true);\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.checkPermissionToChangeRole(userId, organizationId, \"org\")\n        ).resolves.not.toThrow();\n      });\n\n      it(\"should throw UNAUTHORIZED when user lacks permission\", async () => {\n        mockPermissionCheckService.checkPermission.mockResolvedValue(false);\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(manager.checkPermissionToChangeRole(userId, organizationId, \"org\")).rejects.toThrow(\n          new RoleManagementError(\n            \"You do not have permission to change roles\",\n            RoleManagementErrorCode.UNAUTHORIZED\n          )\n        );\n      });\n    });\n\n    describe(\"assignRole\", () => {\n      it(\"should assign default role correctly\", async () => {\n        // Mock non-owner membership to bypass owner validation\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: null,\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        mockRoleService.assignRoleToMember.mockResolvedValue(undefined);\n        const manager = await factory.createRoleManager(organizationId);\n        await manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId);\n        expect(mockRoleService.assignRoleToMember).toHaveBeenCalledWith(\n          DEFAULT_ROLE_IDS[MembershipRole.ADMIN],\n          membershipId\n        );\n      });\n\n      it(\"should assign custom role after validation\", async () => {\n        const customRoleId = \"custom-role-123\";\n\n        // Mock non-owner membership to bypass owner validation\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: null,\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        mockRoleService.roleBelongsToTeam.mockResolvedValue(true);\n        mockRoleService.assignRoleToMember.mockResolvedValue(undefined);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await manager.assignRole(userId, organizationId, customRoleId as MembershipRole, membershipId);\n\n        expect(mockRoleService.roleBelongsToTeam).toHaveBeenCalledWith(customRoleId, organizationId);\n        expect(mockRoleService.assignRoleToMember).toHaveBeenCalledWith(customRoleId, membershipId);\n      });\n\n      it(\"should throw INVALID_ROLE for invalid custom role\", async () => {\n        const customRoleId = \"invalid-role\";\n        mockRoleService.roleBelongsToTeam.mockResolvedValue(false);\n\n        // Mock non-owner membership to bypass owner validation\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: null,\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, customRoleId as MembershipRole, membershipId)\n        ).rejects.toThrow(\n          new RoleManagementError(\"You do not have access to this role\", RoleManagementErrorCode.INVALID_ROLE)\n        );\n      });\n\n      it(\"should prevent changing the last owner to non-owner role\", async () => {\n        // Mock current membership as owner with customRoleId\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: DEFAULT_ROLE_IDS[MembershipRole.OWNER],\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        // Mock count showing only 1 owner\n        vi.mocked(prisma.membership.count).mockResolvedValue(1);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId)\n        ).rejects.toThrow(\n          new RoleManagementError(\n            \"Cannot change the role of the last owner in the organization\",\n            RoleManagementErrorCode.UNAUTHORIZED\n          )\n        );\n      });\n\n      it(\"should prevent changing the last legacy owner to non-owner role\", async () => {\n        // Mock current membership as legacy owner (role field)\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.OWNER,\n          customRoleId: null,\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        // Mock count showing only 1 owner\n        vi.mocked(prisma.membership.count).mockResolvedValue(1);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId)\n        ).rejects.toThrow(\n          new RoleManagementError(\n            \"Cannot change the role of the last owner in the organization\",\n            RoleManagementErrorCode.UNAUTHORIZED\n          )\n        );\n      });\n\n      it(\"should allow changing owner role when multiple owners exist\", async () => {\n        // Mock current membership as owner\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: DEFAULT_ROLE_IDS[MembershipRole.OWNER],\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        // Mock count showing multiple owners\n        vi.mocked(prisma.membership.count).mockResolvedValue(2);\n        mockRoleService.assignRoleToMember.mockResolvedValue(undefined);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId)\n        ).resolves.not.toThrow();\n\n        expect(mockRoleService.assignRoleToMember).toHaveBeenCalledWith(\n          DEFAULT_ROLE_IDS[MembershipRole.ADMIN],\n          membershipId\n        );\n      });\n\n      it(\"should allow changing owner to owner (same role)\", async () => {\n        // Mock current membership as owner\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: DEFAULT_ROLE_IDS[MembershipRole.OWNER],\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        // Mock count showing only 1 owner (should be bypassed)\n        vi.mocked(prisma.membership.count).mockResolvedValue(1);\n        mockRoleService.assignRoleToMember.mockResolvedValue(undefined);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.OWNER, membershipId)\n        ).resolves.not.toThrow();\n\n        expect(mockRoleService.assignRoleToMember).toHaveBeenCalledWith(\n          DEFAULT_ROLE_IDS[MembershipRole.OWNER],\n          membershipId\n        );\n      });\n\n      it(\"should allow changing non-owner role without validation\", async () => {\n        // Mock current membership as non-owner\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue({\n          id: membershipId,\n          userId,\n          teamId: organizationId,\n          role: MembershipRole.MEMBER,\n          customRoleId: null,\n          accepted: true,\n          disableImpersonation: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n\n        mockRoleService.assignRoleToMember.mockResolvedValue(undefined);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId)\n        ).resolves.not.toThrow();\n\n        expect(mockRoleService.assignRoleToMember).toHaveBeenCalledWith(\n          DEFAULT_ROLE_IDS[MembershipRole.ADMIN],\n          membershipId\n        );\n        // Should not call count since it's not an owner\n        expect(prisma.membership.count).not.toHaveBeenCalled();\n      });\n\n      it(\"should throw error when membership is not found\", async () => {\n        // Mock membership not found\n        vi.mocked(prisma.membership.findUnique).mockResolvedValue(null);\n\n        const manager = await factory.createRoleManager(organizationId);\n        await expect(\n          manager.assignRole(userId, organizationId, MembershipRole.ADMIN, membershipId)\n        ).rejects.toThrow(\n          new RoleManagementError(\"Membership not found\", RoleManagementErrorCode.UNAUTHORIZED)\n        );\n      });\n    });\n  });\n\n  describe(\"LegacyRoleManager\", () => {\n    beforeEach(() => {\n      mockFeaturesRepository.checkIfTeamHasFeature.mockResolvedValue(false);\n      vi.mocked(prisma.membership.update).mockResolvedValue({\n        id: 1,\n        teamId: organizationId,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        role: MembershipRole.MEMBER,\n        userId: userId,\n        disableImpersonation: false,\n        accepted: true,\n        customRoleId: null,\n      });\n      vi.mocked(isOrganisationAdmin).mockResolvedValue(false);\n    });\n\n    describe(\"checkPermissionToChangeRole\", () => {\n      it(\"should allow role change when user is owner\", async () => {\n        vi.mocked(isOrganisationAdmin).mockResolvedValue({\n          id: 1,\n          teamId:",
            "cost": 0.13335
        },
        "calcom__cal.com.main/packages/features/pbac/services/legacy-role-manager.service.ts": {
            "output": "import { isTeamOwner } from \"@calcom/features/ee/teams/lib/queries\";\nimport { isOrganisationAdmin } from \"@calcom/lib/server/queries/organisations\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Membership } from \"@calcom/prisma/client\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\n\nimport { RoleManagementError, RoleManagementErrorCode } from \"../domain/errors/role-management.error\";\nimport type { IRoleManager } from \"./role-manager.interface\";\n\nexport class LegacyRoleManager implements IRoleManager {\n  public isPBACEnabled = false;\n\n  protected async validateRoleChange(\n    userId: number,\n    teamId: number,\n    memberId: number,\n    newRole: MembershipRole | string,\n    memberships: Membership[]\n  ): Promise<void> {\n    // Only validate for traditional MembershipRole values\n    if (typeof newRole !== \"string\" || !Object.values(MembershipRole).includes(newRole as MembershipRole)) {\n      return;\n    }\n\n    const targetMembership = memberships.find((m) => m.userId === memberId);\n    const myMembership = memberships.find((m) => m.userId === userId);\n    const teamOwners = memberships.filter((m) => m.role === MembershipRole.OWNER);\n    const teamHasMoreThanOneOwner = teamOwners.length > 1;\n\n    if (!targetMembership) {\n      throw new RoleManagementError(\"Target membership not found\", RoleManagementErrorCode.UNAUTHORIZED);\n    }\n\n    // Only owners can award owner role\n    if (newRole === MembershipRole.OWNER && !(await isTeamOwner(userId, teamId))) {\n      throw new RoleManagementError(\"Only owners can award owner role\", RoleManagementErrorCode.UNAUTHORIZED);\n    }\n\n    // Admins cannot change the role of an owner\n    if (myMembership?.role === MembershipRole.ADMIN && targetMembership?.role === MembershipRole.OWNER) {\n      throw new RoleManagementError(\n        \"You can not change the role of an owner if you are an admin.\",\n        RoleManagementErrorCode.UNAUTHORIZED\n      );\n    }\n\n    // Cannot change the role of the only owner\n    if (targetMembership?.role === MembershipRole.OWNER && !teamHasMoreThanOneOwner) {\n      throw new RoleManagementError(\n        \"You can not change the role of the only owner of a team.\",\n        RoleManagementErrorCode.UNAUTHORIZED\n      );\n    }\n\n    // Admins cannot promote themselves to a higher role (except to MEMBER which is a demotion)\n    if (\n      myMembership?.role === MembershipRole.ADMIN &&\n      memberId === userId &&\n      newRole !== MembershipRole.MEMBER\n    ) {\n      throw new RoleManagementError(\n        \"You can not change yourself to a higher role.\",\n        RoleManagementErrorCode.UNAUTHORIZED\n      );\n    }\n  }\n\n  async checkPermissionToChangeRole(\n    userId: number,\n    targetId: number,\n    scope: \"org\" | \"team\",\n    memberId?: number,\n    newRole?: MembershipRole | string\n  ): Promise<void> {\n    let hasPermission = false;\n    if (scope === \"team\") {\n      const team = await prisma.membership.findFirst({\n        where: {\n          userId,\n          teamId: targetId,\n          accepted: true,\n          OR: [{ role: \"ADMIN\" }, { role: \"OWNER\" }],\n        },\n      });\n      hasPermission = !!team;\n    } else {\n      hasPermission = !!(await isOrganisationAdmin(userId, targetId));\n    }\n\n    // Only OWNER/ADMIN can update role\n    if (!hasPermission) {\n      throw new RoleManagementError(\n        \"Only owners or admin can update roles\",\n        RoleManagementErrorCode.UNAUTHORIZED\n      );\n    }\n\n    // Additional validation for team role changes in legacy mode\n    if (scope === \"team\" && memberId && newRole) {\n      const memberships = await prisma.membership.findMany({\n        where: {\n          teamId: targetId,\n          accepted: true,\n        },\n      });\n      await this.validateRoleChange(userId, targetId, memberId, newRole, memberships);\n    }\n  }\n\n  async assignRole(\n    userId: number,\n    organizationId: number,\n    role: MembershipRole | string,\n    // Used in other implementation\n     \n    _membershipId: number\n  ): Promise<void> {\n    await prisma.membership.update({\n      where: {\n        userId_teamId: {\n          userId,\n          teamId: organizationId,\n        },\n      },\n      data: {\n        role: role as MembershipRole,\n      },\n    });\n  }\n\n  // Used in other implementation\n   \n  async getAllRoles(_organizationId: number): Promise<{ id: string; name: string }[]> {\n    return [\n      { id: MembershipRole.OWNER, name: \"Owner\" },\n      { id: MembershipRole.ADMIN, name: \"Admin\" },\n      { id: MembershipRole.MEMBER, name: \"Member\" },\n    ];\n  }\n\n  // Used in other implementation\n   \n  async getTeamRoles(_teamId: number): Promise<{ id: string; name: string }[]> {\n    return [\n      { id: MembershipRole.OWNER, name: \"Owner\" },\n      { id: MembershipRole.ADMIN, name: \"Admin\" },\n      { id: MembershipRole.MEMBER, name: \"Member\" },\n    ];\n  }\n}",
            "output_extracted": "import { isTeamOwner } from \"@calcom/features/ee/teams/lib/queries\";\nimport { isOrganisationAdmin } from \"@calcom/lib/server/queries/organisations\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Membership } from \"@calcom/prisma/client\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\n\nimport { RoleManagementError, RoleManagementErrorCode } from \"../domain/errors/role-management.error\";\nimport type { IRoleManager } from \"./role-manager.interface\";\n\nexport class LegacyRoleManager implements IRoleManager {\n  public isPBACEnabled = false;\n\n  protected async validateRoleChange(\n    userId: number,\n    teamId: number,\n    memberId: number,\n    newRole: MembershipRole | string,\n    memberships: Membership[]\n  ): Promise<void> {\n    // Only validate for traditional MembershipRole values\n    if (typeof newRole !== \"string\" || !Object.values(MembershipRole).includes(newRole as MembershipRole)) {\n      return;\n    }\n\n    const targetMembership = memberships.find((m) => m.userId === memberId);\n    const myMembership = memberships.find((m) => m.userId === userId);\n    const teamOwners = memberships.filter((m) => m.role === MembershipRole.OWNER);\n    const teamHasMoreThanOneOwner = teamOwners.length > 1;\n\n    if (!targetMembership) {\n      throw new RoleManagementError(\"Target membership not found\", RoleManagementErrorCode.UNAUTHORIZED);\n    }\n\n    // Only owners can award owner role\n    if (newRole === MembershipRole.OWNER && !(await isTeamOwner(userId, teamId))) {\n      throw new RoleManagementError(\"Only owners can award owner role\", RoleManagementErrorCode.UNAUTHORIZED);\n    }\n\n    // Admins cannot change the role of an owner\n    if (myMembership?.role === MembershipRole.ADMIN && targetMembership?.role === MembershipRole.OWNER) {\n      throw new RoleManagementError(\n        \"You can not change the role of an owner if you are an admin.\",\n        RoleManagementErrorCode.UNAUTHORIZED\n      );\n    }\n\n    // Cannot change the role of the only owner\n    if (targetMembership?.role === MembershipRole.OWNER && !teamHasMoreThanOneOwner) {\n      throw new RoleManagementError(\n        \"You can not change the role of the only owner of a team.\",\n        RoleManagementErrorCode.UNAUTHORIZED\n      );\n    }\n\n    // Admins cannot promote themselves to a higher role (except to MEMBER which is a demotion)\n    if (\n      myMembership?.role === MembershipRole.ADMIN &&\n      memberId === userId &&\n      newRole !== MembershipRole.MEMBER\n    ) {\n      throw new RoleManagementError(\n        \"You can not change yourself to a higher role.\",\n        RoleManagementErrorCode.UNAUTHORIZED\n      );\n    }\n  }\n\n  async checkPermissionToChangeRole(\n    userId: number,\n    targetId: number,\n    scope: \"org\" | \"team\",\n    memberId?: number,\n    newRole?: MembershipRole | string\n  ): Promise<void> {\n    let hasPermission = false;\n    if (scope === \"team\") {\n      const team = await prisma.membership.findFirst({\n        where: {\n          userId,\n          teamId: targetId,\n          accepted: true,\n          OR: [{ role: \"ADMIN\" }, { role: \"OWNER\" }],\n        },\n      });\n      hasPermission = !!team;\n    } else {\n      hasPermission = !!(await isOrganisationAdmin(userId, targetId));\n    }\n\n    // Only OWNER/ADMIN can update role\n    if (!hasPermission) {\n      throw new RoleManagementError(\n        \"Only owners or admin can update roles\",\n        RoleManagementErrorCode.UNAUTHORIZED\n      );\n    }\n\n    // Additional validation for team role changes in legacy mode\n    if (scope === \"team\" && memberId && newRole) {\n      const memberships = await prisma.membership.findMany({\n        where: {\n          teamId: targetId,\n          accepted: true,\n        },\n      });\n      await this.validateRoleChange(userId, targetId, memberId, newRole, memberships);\n    }\n  }\n\n  async assignRole(\n    userId: number,\n    organizationId: number,\n    role: MembershipRole | string,\n    // Used in other implementation\n     \n    _membershipId: number\n  ): Promise<void> {\n    await prisma.membership.update({\n      where: {\n        userId_teamId: {\n          userId,\n          teamId: organizationId,\n        },\n      },\n      data: {\n        role: role as MembershipRole,\n      },\n    });\n  }\n\n  // Used in other implementation\n   \n  async getAllRoles(_organizationId: number): Promise<{ id: string; name: string }[]> {\n    return [\n      { id: MembershipRole.OWNER, name: \"Owner\" },\n      { id: MembershipRole.ADMIN, name: \"Admin\" },\n      { id: MembershipRole.MEMBER, name: \"Member\" },\n    ];\n  }\n\n  // Used in other implementation\n   \n  async getTeamRoles(_teamId: number): Promise<{ id: string; name: string }[]> {\n    return [\n      { id: MembershipRole.OWNER, name: \"Owner\" },\n      { id: MembershipRole.ADMIN, name: \"Admin\" },\n      { id: MembershipRole.MEMBER, name: \"Member\" },\n    ];\n  }\n}",
            "cost": 0.052065
        },
        "calcom__cal.com.main/packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts": {
            "output": "import { ensureOrganizationIsReviewed } from \"@calcom/ee/organizations/lib/ensureOrganizationIsReviewed\";\nimport { checkAdminOrOwner } from \"@calcom/features/auth/lib/checkAdminOrOwner\";\nimport { RoleManagementError } from \"@calcom/features/pbac/domain/errors/role-management.error\";\nimport { RoleManagementFactory } from \"@calcom/features/pbac/services/role-management.factory\";\nimport { checkRegularUsername } from \"@calcom/features/profile/lib/checkRegularUsername\";\nimport { uploadAvatar } from \"@calcom/lib/server/avatar\";\nimport { resizeBase64Image } from \"@calcom/lib/server/resizeBase64Image\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Prisma } from \"@calcom/prisma/client\";\nimport type { MembershipRole } from \"@calcom/prisma/enums\";\nimport type { TrpcSessionUser } from \"@calcom/trpc/server/types\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport assignUserToAttributeHandler from \"../attributes/assignUserToAttribute.handler\";\nimport type { TUpdateUserInputSchema } from \"./updateUser.schema\";\n\ntype UpdateUserOptions = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  };\n  input: TUpdateUserInputSchema;\n};\n\nconst applyRoleToAllTeams = async (userId: number, teamIds: number[], role: MembershipRole) => {\n  await prisma.membership.updateMany({\n    where: {\n      userId,\n      teamId: {\n        in: teamIds,\n      },\n    },\n    data: {\n      role,\n    },\n  });\n};\n\nexport const updateUserHandler = async ({ ctx, input }: UpdateUserOptions) => {\n  const { user } = ctx;\n  const { id: userId, organizationId } = user;\n\n  if (!organizationId)\n    throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"You must be a member of an organizaiton\" });\n\n  const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n\n  try {\n    await roleManager.checkPermissionToChangeRole(userId, organizationId, \"org\");\n  } catch (error) {\n    if (error instanceof RoleManagementError) {\n      throw new TRPCError({ code: \"UNAUTHORIZED\", message: error.message });\n    }\n    throw error;\n  }\n\n  await ensureOrganizationIsReviewed(organizationId);\n\n  // Is requested user a member of the organization?\n  const requestedMember = await prisma.membership.findFirst({\n    where: {\n      userId: input.userId,\n      teamId: organizationId,\n      accepted: true,\n    },\n    include: {\n      team: {\n        include: {\n          children: {\n            where: {\n              members: {\n                some: {\n                  userId: input.userId,\n                },\n              },\n            },\n            include: {\n              members: true,\n            },\n          },\n        },\n      },\n      user: {\n        select: {\n          username: true,\n          profiles: {\n            select: {\n              username: true,\n            },\n          },\n        },\n      },\n    },\n  });\n\n  if (!requestedMember)\n    throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"User does not belong to your organization\" });\n\n  const hasUsernameUpdated = input.username !== requestedMember.user.profiles[0]?.username;\n\n  if (input.username && hasUsernameUpdated && user.profile.organization?.slug) {\n    const checkRegularUsernameRes = await checkRegularUsername(\n      input.username,\n      user.profile.organization.slug\n    );\n    if (!checkRegularUsernameRes.available) {\n      throw new TRPCError({ code: \"BAD_REQUEST\", message: checkRegularUsernameRes.message });\n    }\n  }\n\n  const data: Prisma.UserUpdateInput = {\n    bio: input.bio,\n    email: input.email,\n    name: input.name,\n    timeZone: input.timeZone,\n  };\n\n  if (\n    input.avatar &&\n    (input.avatar.startsWith(\"data:image/png;base64,\") ||\n      input.avatar.startsWith(\"data:image/jpeg;base64,\") ||\n      input.avatar.startsWith(\"data:image/jpg;base64,\"))\n  ) {\n    const avatar = await resizeBase64Image(input.avatar);\n    data.avatarUrl = await uploadAvatar({\n      avatar,\n      userId: user.id,\n    });\n  }\n  if (input.avatar === \"\") {\n    data.avatarUrl = null;\n  }\n\n  // Update user\n  type TransactionPromise = ReturnType<typeof prisma.user.update> | ReturnType<typeof prisma.profile.update>;\n\n  const transactions: TransactionPromise[] = [\n    prisma.user.update({\n      where: {\n        id: input.userId,\n      },\n      data,\n    }),\n  ];\n\n  if (hasUsernameUpdated) {\n    transactions.push(\n      prisma.profile.update({\n        where: {\n          userId_organizationId: {\n            userId: input.userId,\n            organizationId,\n          },\n        },\n        data: {\n          username: input.username,\n        },\n      })\n    );\n  }\n\n  await prisma.$transaction(transactions);\n\n  await roleManager.assignRole(input.userId, organizationId, input.role, requestedMember.id);\n\n  if (input.attributeOptions) {\n    await assignUserToAttributeHandler({\n      ctx: {\n        user: ctx.user,\n      },\n      input: input.attributeOptions,\n    });\n  }\n\n  // We cast to membership role as we know pbac insnt enabled on this instance.\n  if (checkAdminOrOwner(input.role as MembershipRole) && roleManager.isPBACEnabled) {\n    const teamIds = requestedMember.team.children\n      .map((sub_team) => sub_team.members.find((item) => item.userId === input.userId)?.teamId)\n      .filter(Boolean) as number[]; //filter out undefined\n\n    await applyRoleToAllTeams(input.userId, teamIds, input.role as MembershipRole);\n  }\n  // TODO: audit log this\n\n  return {\n    success: true,\n  };\n};\n\nexport default updateUserHandler;",
            "output_extracted": "import { ensureOrganizationIsReviewed } from \"@calcom/ee/organizations/lib/ensureOrganizationIsReviewed\";\nimport { checkAdminOrOwner } from \"@calcom/features/auth/lib/checkAdminOrOwner\";\nimport { RoleManagementError } from \"@calcom/features/pbac/domain/errors/role-management.error\";\nimport { RoleManagementFactory } from \"@calcom/features/pbac/services/role-management.factory\";\nimport { checkRegularUsername } from \"@calcom/features/profile/lib/checkRegularUsername\";\nimport { uploadAvatar } from \"@calcom/lib/server/avatar\";\nimport { resizeBase64Image } from \"@calcom/lib/server/resizeBase64Image\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Prisma } from \"@calcom/prisma/client\";\nimport type { MembershipRole } from \"@calcom/prisma/enums\";\nimport type { TrpcSessionUser } from \"@calcom/trpc/server/types\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport assignUserToAttributeHandler from \"../attributes/assignUserToAttribute.handler\";\nimport type { TUpdateUserInputSchema } from \"./updateUser.schema\";\n\ntype UpdateUserOptions = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  };\n  input: TUpdateUserInputSchema;\n};\n\nconst applyRoleToAllTeams = async (userId: number, teamIds: number[], role: MembershipRole) => {\n  await prisma.membership.updateMany({\n    where: {\n      userId,\n      teamId: {\n        in: teamIds,\n      },\n    },\n    data: {\n      role,\n    },\n  });\n};\n\nexport const updateUserHandler = async ({ ctx, input }: UpdateUserOptions) => {\n  const { user } = ctx;\n  const { id: userId, organizationId } = user;\n\n  if (!organizationId)\n    throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"You must be a member of an organizaiton\" });\n\n  const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n\n  try {\n    await roleManager.checkPermissionToChangeRole(userId, organizationId, \"org\");\n  } catch (error) {\n    if (error instanceof RoleManagementError) {\n      throw new TRPCError({ code: \"UNAUTHORIZED\", message: error.message });\n    }\n    throw error;\n  }\n\n  await ensureOrganizationIsReviewed(organizationId);\n\n  // Is requested user a member of the organization?\n  const requestedMember = await prisma.membership.findFirst({\n    where: {\n      userId: input.userId,\n      teamId: organizationId,\n      accepted: true,\n    },\n    include: {\n      team: {\n        include: {\n          children: {\n            where: {\n              members: {\n                some: {\n                  userId: input.userId,\n                },\n              },\n            },\n            include: {\n              members: true,\n            },\n          },\n        },\n      },\n      user: {\n        select: {\n          username: true,\n          profiles: {\n            select: {\n              username: true,\n            },\n          },\n        },\n      },\n    },\n  });\n\n  if (!requestedMember)\n    throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"User does not belong to your organization\" });\n\n  const hasUsernameUpdated = input.username !== requestedMember.user.profiles[0]?.username;\n\n  if (input.username && hasUsernameUpdated && user.profile.organization?.slug) {\n    const checkRegularUsernameRes = await checkRegularUsername(\n      input.username,\n      user.profile.organization.slug\n    );\n    if (!checkRegularUsernameRes.available) {\n      throw new TRPCError({ code: \"BAD_REQUEST\", message: checkRegularUsernameRes.message });\n    }\n  }\n\n  const data: Prisma.UserUpdateInput = {\n    bio: input.bio,\n    email: input.email,\n    name: input.name,\n    timeZone: input.timeZone,\n  };\n\n  if (\n    input.avatar &&\n    (input.avatar.startsWith(\"data:image/png;base64,\") ||\n      input.avatar.startsWith(\"data:image/jpeg;base64,\") ||\n      input.avatar.startsWith(\"data:image/jpg;base64,\"))\n  ) {\n    const avatar = await resizeBase64Image(input.avatar);\n    data.avatarUrl = await uploadAvatar({\n      avatar,\n      userId: user.id,\n    });\n  }\n  if (input.avatar === \"\") {\n    data.avatarUrl = null;\n  }\n\n  // Update user\n  type TransactionPromise = ReturnType<typeof prisma.user.update> | ReturnType<typeof prisma.profile.update>;\n\n  const transactions: TransactionPromise[] = [\n    prisma.user.update({\n      where: {\n        id: input.userId,\n      },\n      data,\n    }),\n  ];\n\n  if (hasUsernameUpdated) {\n    transactions.push(\n      prisma.profile.update({\n        where: {\n          userId_organizationId: {\n            userId: input.userId,\n            organizationId,\n          },\n        },\n        data: {\n          username: input.username,\n        },\n      })\n    );\n  }\n\n  await prisma.$transaction(transactions);\n\n  await roleManager.assignRole(input.userId, organizationId, input.role, requestedMember.id);\n\n  if (input.attributeOptions) {\n    await assignUserToAttributeHandler({\n      ctx: {\n        user: ctx.user,\n      },\n      input: input.attributeOptions,\n    });\n  }\n\n  // We cast to membership role as we know pbac insnt enabled on this instance.\n  if (checkAdminOrOwner(input.role as MembershipRole) && roleManager.isPBACEnabled) {\n    const teamIds = requestedMember.team.children\n      .map((sub_team) => sub_team.members.find((item) => item.userId === input.userId)?.teamId)\n      .filter(Boolean) as number[]; //filter out undefined\n\n    await applyRoleToAllTeams(input.userId, teamIds, input.role as MembershipRole);\n  }\n  // TODO: audit log this\n\n  return {\n    success: true,\n  };\n};\n\nexport default updateUserHandler;",
            "cost": 0.056385000000000005
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25326",
        "repo": "calcom/cal.com",
        "base_commit": "44311f51badd99513e0774500444da72d2230658",
        "head_commit": "e34a4d2cefad9a3997ef4a59bc743464649d020b",
        "title": "chore: improve membership check",
        "merged_at": "2025-11-21T17:34:15Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25326",
        "test_files": [
            "packages/features/pbac/services/__tests__/role-management.factory.test.ts"
        ],
        "code_files": [
            "packages/features/pbac/services/legacy-role-manager.service.ts",
            "packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts"
        ],
        "total_changes": 78,
        "num_files": 3,
        "pull_number": 25326,
        "patch": "diff --git a/packages/features/pbac/services/__tests__/role-management.factory.test.ts b/packages/features/pbac/services/__tests__/role-management.factory.test.ts\nindex 669ad39345b884..0cdf1109c44a0e 100644\n--- a/packages/features/pbac/services/__tests__/role-management.factory.test.ts\n+++ b/packages/features/pbac/services/__tests__/role-management.factory.test.ts\n@@ -1,7 +1,7 @@\n import { vi, describe, it, expect, beforeEach } from \"vitest\";\n \n import { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\n-import { isOrganisationAdmin } from \"@calcom/lib/server/queries/organisations\";\n+import { isOrganisationAdmin, isOrganisationOwner } from \"@calcom/lib/server/queries/organisations\";\n import { prisma } from \"@calcom/prisma\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n \n@@ -26,6 +26,7 @@ vi.mock(\"@calcom/prisma\", () => ({\n }));\n vi.mock(\"@calcom/lib/server/queries/organisations\", () => ({\n   isOrganisationAdmin: vi.fn(),\n+  isOrganisationOwner: vi.fn(),\n }));\n \n describe(\"RoleManagementFactory\", () => {\n@@ -407,6 +408,33 @@ describe(\"RoleManagementFactory\", () => {\n           )\n         );\n       });\n+\n+      it(\"should prevent changing admin to owner\", async () => {\n+        vi.mocked(isOrganisationAdmin).mockResolvedValue({\n+          id: membershipId,\n+          userId,\n+          teamId: organizationId,\n+          role: MembershipRole.ADMIN,\n+          accepted: true,\n+          disableImpersonation: false,\n+          createdAt: new Date(),\n+          updatedAt: new Date(),\n+          customRoleId: null,\n+        });\n+        vi.mocked(isOrganisationOwner).mockResolvedValue(false);\n+        const manager = await factory.createRoleManager(organizationId);\n+        await expect(\n+          manager.checkPermissionToChangeRole(\n+            userId,\n+            organizationId,\n+            \"org\",\n+            membershipId,\n+            MembershipRole.OWNER\n+          )\n+        ).rejects.toThrow(\n+          new RoleManagementError(\"Only owners can update this role\", RoleManagementErrorCode.UNAUTHORIZED)\n+        );\n+      });\n     });\n \n     describe(\"assignRole\", () => {\ndiff --git a/packages/features/pbac/services/legacy-role-manager.service.ts b/packages/features/pbac/services/legacy-role-manager.service.ts\nindex 14e0c807cedb3c..c4c8e3ef308b9b 100644\n--- a/packages/features/pbac/services/legacy-role-manager.service.ts\n+++ b/packages/features/pbac/services/legacy-role-manager.service.ts\n@@ -1,5 +1,5 @@\n import { isTeamOwner } from \"@calcom/features/ee/teams/lib/queries\";\n-import { isOrganisationAdmin } from \"@calcom/lib/server/queries/organisations\";\n+import { isOrganisationAdmin, isOrganisationOwner } from \"@calcom/lib/server/queries/organisations\";\n import { prisma } from \"@calcom/prisma\";\n import type { Membership } from \"@calcom/prisma/client\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n@@ -73,6 +73,7 @@ export class LegacyRoleManager implements IRoleManager {\n     newRole?: MembershipRole | string\n   ): Promise<void> {\n     let hasPermission = false;\n+    const isOwnerChange = newRole === MembershipRole.OWNER;\n     if (scope === \"team\") {\n       const team = await prisma.membership.findFirst({\n         where: {\n@@ -84,13 +85,16 @@ export class LegacyRoleManager implements IRoleManager {\n       });\n       hasPermission = !!team;\n     } else {\n-      hasPermission = !!(await isOrganisationAdmin(userId, targetId));\n+      hasPermission =\n+        newRole === MembershipRole.OWNER\n+          ? !!(await isOrganisationOwner(userId, targetId))\n+          : !!(await isOrganisationAdmin(userId, targetId));\n     }\n \n     // Only OWNER/ADMIN can update role\n     if (!hasPermission) {\n       throw new RoleManagementError(\n-        \"Only owners or admin can update roles\",\n+        isOwnerChange ? \"Only owners can update this role\" : \"Only owners or admin can update roles\",\n         RoleManagementErrorCode.UNAUTHORIZED\n       );\n     }\n@@ -112,7 +116,7 @@ export class LegacyRoleManager implements IRoleManager {\n     organizationId: number,\n     role: MembershipRole | string,\n     // Used in other implementation\n-     \n+\n     _membershipId: number\n   ): Promise<void> {\n     await prisma.membership.update({\n@@ -129,7 +133,7 @@ export class LegacyRoleManager implements IRoleManager {\n   }\n \n   // Used in other implementation\n-   \n+\n   async getAllRoles(_organizationId: number): Promise<{ id: string; name: string }[]> {\n     return [\n       { id: MembershipRole.OWNER, name: \"Owner\" },\n@@ -139,7 +143,7 @@ export class LegacyRoleManager implements IRoleManager {\n   }\n \n   // Used in other implementation\n-   \n+\n   async getTeamRoles(_teamId: number): Promise<{ id: string; name: string }[]> {\n     return [\n       { id: MembershipRole.OWNER, name: \"Owner\" },\ndiff --git a/packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts b/packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts\nindex 049781a3c6e381..d30ebbecb0d2ca 100644\n--- a/packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts\n+++ b/packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts\n@@ -43,19 +43,6 @@ export const updateUserHandler = async ({ ctx, input }: UpdateUserOptions) => {\n   if (!organizationId)\n     throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"You must be a member of an organizaiton\" });\n \n-  const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n-\n-  try {\n-    await roleManager.checkPermissionToChangeRole(userId, organizationId, \"org\");\n-  } catch (error) {\n-    if (error instanceof RoleManagementError) {\n-      throw new TRPCError({ code: \"UNAUTHORIZED\", message: error.message });\n-    }\n-    throw error;\n-  }\n-\n-  await ensureOrganizationIsReviewed(organizationId);\n-\n   // Is requested user a member of the organization?\n   const requestedMember = await prisma.membership.findFirst({\n     where: {\n@@ -96,6 +83,25 @@ export const updateUserHandler = async ({ ctx, input }: UpdateUserOptions) => {\n   if (!requestedMember)\n     throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"User does not belong to your organization\" });\n \n+  const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n+\n+  try {\n+    await roleManager.checkPermissionToChangeRole(\n+      userId,\n+      organizationId,\n+      \"org\",\n+      requestedMember.id,\n+      input.role\n+    );\n+  } catch (error) {\n+    if (error instanceof RoleManagementError) {\n+      throw new TRPCError({ code: \"UNAUTHORIZED\", message: error.message });\n+    }\n+    throw error;\n+  }\n+\n+  await ensureOrganizationIsReviewed(organizationId);\n+\n   const hasUsernameUpdated = input.username !== requestedMember.user.profiles[0]?.username;\n \n   if (input.username && hasUsernameUpdated && user.profile.organization?.slug) {\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}