{
    "cost": 0.143265,
    "rewrites": {
        "calcom__cal.com.main/packages/features/membership/repositories/MembershipRepository.ts": {
            "output": "import { LookupTarget, ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\nimport { withSelectedCalendars } from \"@calcom/features/users/repositories/UserRepository\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { eventTypeSelect } from \"@calcom/lib/server/eventTypeSelect\";\nimport { availabilityUserSelect, prisma, type PrismaTransaction } from \"@calcom/prisma\";\nimport type { Prisma, Membership, PrismaClient } from \"@calcom/prisma/client\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\nimport { credentialForCalendarServiceSelect } from \"@calcom/prisma/selects/credential\";\n\nconst log = logger.getSubLogger({ prefix: [\"features/membership/repositories/MembershipRepository\"] });\ntype IMembership = {\n  teamId: number;\n  userId: number;\n  accepted: boolean;\n  role: MembershipRole;\n  createdAt?: Date;\n};\n\nconst membershipSelect = {\n  id: true,\n  teamId: true,\n  userId: true,\n  accepted: true,\n  role: true,\n  disableImpersonation: true,\n} satisfies Prisma.MembershipSelect;\n\ntype MembershipSelectableKeys = keyof typeof membershipSelect;\n\ntype MembershipPartialSelect = Partial<Record<MembershipSelectableKeys, boolean>>;\n\ntype MembershipDTO = Pick<Membership, MembershipSelectableKeys>;\n\ntype MembershipDTOFromSelect<TSelect extends MembershipPartialSelect> = {\n  [K in keyof TSelect & keyof MembershipDTO as TSelect[K] extends true ? K : never]: MembershipDTO[K];\n};\n\nconst teamParentSelect = {\n  id: true,\n  name: true,\n  slug: true,\n  logoUrl: true,\n  parentId: true,\n  metadata: true,\n} satisfies Prisma.TeamSelect;\n\nconst userSelect = {\n  name: true,\n  avatarUrl: true,\n  username: true,\n  id: true,\n  timeZone: true,\n} satisfies Prisma.UserSelect;\n\nconst getWhereForfindAllByUpId = async (upId: string, where?: Prisma.MembershipWhereInput) => {\n  const lookupTarget = ProfileRepository.getLookupTarget(upId);\n  let prismaWhere;\n  if (lookupTarget.type === LookupTarget.Profile) {\n    /**\n     * TODO: When we add profileId to membership, we lookup by profileId\n     * If the profile is movedFromUser, we lookup all memberships without profileId as well.\n     */\n    let profile;\n    if (\"uid\" in lookupTarget && lookupTarget.uid) {\n      profile = await ProfileRepository.findByUid(lookupTarget.uid);\n    } else if (\"id\" in lookupTarget && lookupTarget.id !== undefined) {\n      profile = await ProfileRepository.findById(lookupTarget.id);\n    } else {\n      return [];\n    }\n    if (!profile) {\n      return [];\n    }\n    const userId = \"user\" in profile && profile.user ? profile.user.id : null;\n    if (!userId) {\n      return [];\n    }\n    prismaWhere = {\n      userId,\n      ...where,\n    };\n  } else {\n    prismaWhere = {\n      userId: lookupTarget.id,\n      ...where,\n    };\n  }\n\n  return prismaWhere;\n};\n\nexport class MembershipRepository {\n  constructor(private readonly prismaClient: PrismaClient = prisma) {}\n\n  async hasMembership({ userId, teamId }: { userId: number; teamId: number }): Promise<boolean> {\n    const membership = await this.prismaClient.membership.findFirst({\n      where: {\n        userId,\n        teamId,\n        accepted: true,\n      },\n      select: {\n        id: true,\n      },\n    });\n    return !!membership;\n  }\n\n  async listAcceptedTeamMemberIds({ teamId }: { teamId: number }): Promise<number[]> {\n    const memberships =\n      (await this.prismaClient.membership.findMany({\n        where: {\n          teamId,\n          accepted: true,\n        },\n        select: {\n          userId: true,\n        },\n      })) || [];\n    const teamMemberIds = memberships.map((membership) => membership.userId);\n    return teamMemberIds;\n  }\n\n  static async create(data: IMembership) {\n    return await prisma.membership.create({\n      data: {\n        createdAt: new Date(),\n        ...data,\n      },\n    });\n  }\n\n  static async findFirstAcceptedMembershipByUserId(userId: number) {\n    return await prisma.membership.findFirst({\n      where: {\n        accepted: true,\n        userId,\n        team: {\n          slug: {\n            not: null,\n          },\n        },\n      },\n    });\n  }\n\n  static async createMany(data: IMembership[]) {\n    return await prisma.membership.createMany({\n      data: data.map((item) => ({\n        createdAt: new Date(),\n        ...item,\n      })),\n    });\n  }\n\n  /**\n   * TODO: Using a specific function for specific tasks so that we don't have to focus on TS magic at the moment. May be try to make it a a generic findAllByProfileId with various options.\n   */\n  static async findAllByUpIdIncludeTeamWithMembersAndEventTypes(\n    { upId }: { upId: string },\n    { where }: { where?: Prisma.MembershipWhereInput } = {}\n  ) {\n    const prismaWhere = await getWhereForfindAllByUpId(upId, where);\n    if (Array.isArray(prismaWhere)) {\n      return prismaWhere;\n    }\n\n    log.debug(\n      \"findAllByUpIdIncludeTeamWithMembersAndEventTypes\",\n      safeStringify({\n        prismaWhere,\n      })\n    );\n\n    return await prisma.membership.findMany({\n      where: prismaWhere,\n      include: {\n        team: {\n          include: {\n            members: {\n              select: membershipSelect,\n            },\n            parent: {\n              select: teamParentSelect,\n            },\n            eventTypes: {\n              select: {\n                ...eventTypeSelect,\n                hashedLink: true,\n                users: { select: userSelect },\n                children: {\n                  include: {\n                    users: { select: userSelect },\n                  },\n                },\n                hosts: {\n                  include: {\n                    user: { select: userSelect },\n                  },\n                },\n                team: {\n                  select: {\n                    id: true,\n                    members: {\n                      select: {\n                        user: {\n                          select: {\n                            timeZone: true,\n                          },\n                        },\n                      },\n                      take: 1,\n                    },\n                  },\n                },\n              },\n              // As required by getByViewHandler - Make it configurable\n              orderBy: [\n                {\n                  position: \"desc\",\n                },\n                {\n                  id: \"asc\",\n                },\n              ],\n            },\n          },\n        },\n      },\n    });\n  }\n\n  static async findAllByUpIdIncludeMinimalEventTypes(\n    { upId }: { upId: string },\n    { where, skipEventTypes = false }: { where?: Prisma.MembershipWhereInput; skipEventTypes?: boolean } = {}\n  ) {\n    const prismaWhere = await getWhereForfindAllByUpId(upId, where);\n    if (Array.isArray(prismaWhere)) {\n      return prismaWhere;\n    }\n\n    log.debug(\n      \"findAllByUpIdIncludeMinimalEventTypes\",\n      safeStringify({\n        prismaWhere,\n      })\n    );\n\n    const select = {\n      id: true,\n      teamId: true,\n      userId: true,\n      accepted: true,\n      role: true,\n      disableImpersonation: true,\n      team: {\n        select: {\n          ...teamParentSelect,\n          isOrganization: true,\n          parent: {\n            select: teamParentSelect,\n          },\n          ...(!skipEventTypes\n            ? {\n                eventTypes: {\n                  select: {\n                    ...eventTypeSelect,\n                    hashedLink: true,\n                    children: { select: { id: true } },\n                  },\n                  orderBy: [\n                    {\n                      position: \"desc\",\n                    },\n                    {\n                      id: \"asc\",\n                    },\n                  ],\n                },\n              }\n            : {}),\n        },\n      },\n    } satisfies Prisma.MembershipSelect;\n\n    return await prisma.membership.findMany({\n      where: prismaWhere,\n      select,\n    });\n  }\n\n  static async findAllByUpIdIncludeTeam(\n    { upId }: { upId: string },\n    { where }: { where?: Prisma.MembershipWhereInput } = {}\n  ) {\n    const prismaWhere = await getWhereForfindAllByUpId(upId, where);\n    if (Array.isArray(prismaWhere)) {\n      return prismaWhere;\n    }\n\n    return await prisma.membership.findMany({\n      where: prismaWhere,\n      include: {\n        team: {\n          include: {\n            parent: {\n              select: teamParentSelect,\n            },\n          },\n        },\n      },\n    });\n  }\n\n  static async findUniqueByUserIdAndTeamId({ userId, teamId }: { userId: number; teamId: number }) {\n    return await prisma.membership.findUnique({\n      where: {\n        userId_teamId: {\n          userId,\n          teamId,\n        },\n      },\n    });\n  }\n\n  async findAllMembershipsByUserIdForBilling({ userId }: { userId: number }) {\n    return this.prismaClient.membership.findMany({\n      where: { userId },\n      select: {\n        accepted: true,\n        user: {\n          select: {\n            isPlatformManaged: true,\n          },\n        },\n        team: {\n          select: {\n            slug: true,\n            isOrganization: true,\n            isPlatform: true,\n            metadata: true,\n            platformBilling: {\n              select: {\n                plan: true,\n              },\n            },\n            parent: {\n              select: {\n                isOrganization: true,\n                slug: true,\n                metadata: true,\n                isPlatform: true,\n              },\n            },\n          },\n        },\n      },\n    });\n  }\n\n  static async findByTeamIdForAvailability({ teamId }: { teamId: number }) {\n    const memberships = await prisma.membership.findMany({\n      where: { teamId },\n      include: {\n        user: {\n          select: {\n            credentials: {\n              select: credentialForCalendarServiceSelect,\n            }, // needed for getUserAvailability\n            ...availabilityUserSelect,\n          },\n        },\n      },\n    });\n\n    const membershipsWithSelectedCalendars = memberships.map((m) => {\n      return {\n        ...m,\n        user: withSelectedCalendars(m.user),\n      };\n    });\n\n    return membershipsWithSelectedCalendars;\n  }\n\n  static async getAdminOrOwnerMembership(userId: number, teamId: number) {\n    return prisma.membership.findFirst({\n      where: {\n        userId,\n        teamId,\n        accepted: true,\n        role: {\n          in: [MembershipRole.ADMIN, MembershipRole.OWNER],\n        },\n      },\n      select: {\n        id: true,\n      },\n    });\n  }\n\n  static async findAllAcceptedPublishedTeamMemberships(userId: number, tx?: PrismaTransaction) {\n    return (tx ?? prisma).membership.findMany({\n      where: {\n        userId,\n        accepted: true,\n        team: {\n          slug: { not: null },\n        },\n      },\n      select: {\n        teamId: true,\n      },\n    });\n  }\n\n  /**\n   * Get all team IDs that a user is a member of\n   */\n  static async findUserTeamIds({ userId }: { userId: number }) {\n    const memberships = await prisma.membership.findMany({\n      where: {\n        userId,\n        accepted: true,\n      },\n      select: {\n        teamId: true,\n      },\n    });\n\n    return memberships.map((membership) => membership.teamId);\n  }\n\n  /**\n   * Returns members who joined after the given time\n   */\n  static async findMembershipsCreatedAfterTimeIncludeUser({\n    organizationId,\n    time,\n  }: {\n    organizationId: number;\n    time: Date;\n  }) {\n    return prisma.membership.findMany({\n      where: {\n        teamId: organizationId,\n        createdAt: { gt: time },\n        accepted: true,\n      },\n      include: {\n        user: {\n          select: {\n            email: true,\n            name: true,\n            id: true,\n          },\n        },\n      },\n    });\n  }\n\n  static async findAllByTeamIds<TSelect extends MembershipPartialSelect = { userId: true }>({\n    teamIds,\n    select,\n  }: {\n    teamIds: number[];\n    select?: TSelect;\n  }): Promise<MembershipDTOFromSelect<TSelect>[]> {\n    return (await prisma.membership.findMany({\n      where: {\n        teamId: { in: teamIds },\n        accepted: true,\n      },\n      // this is explicit, and typed in TSelect default typings\n      select: select ?? { userId: true },\n    })) as unknown as Promise<MembershipDTOFromSelect<TSelect>[]>;\n  }\n\n  static async findAllAcceptedTeamMemberships(userId: number, where?: Prisma.MembershipWhereInput) {\n    const teams = await prisma.team.findMany({\n      where: {\n        members: {\n          some: {\n            userId,\n            accepted: true,\n            ...(where ?? {}),\n          },\n        },\n      },\n    });\n    return teams;\n  }\n\n  static async findAllByUserId({\n    userId,\n    filters,\n  }: {\n    userId: number;\n    filters?: {\n      accepted?: boolean;\n      roles?: MembershipRole[];\n    };\n  }) {\n    return prisma.membership.findMany({\n      where: {\n        userId,\n        ...(filters?.accepted !== undefined && { accepted: filters.accepted }),\n        ...(filters?.roles && { role: { in: filters.roles } }),\n      },\n      select: {\n        teamId: true,\n        role: true,\n        team: {\n          select: {\n            id: true,\n            parentId: true,\n          },\n        },\n      },\n    });\n  }\n\n  async findTeamAdminsByTeamId({ teamId }: { teamId: number }) {\n    return await this.prismaClient.membership.findMany({\n      where: {\n        team: {\n          id: teamId,\n          parentId: {\n            not: null,\n          },\n        },\n        role: {\n          in: [\"ADMIN\", \"OWNER\"],\n        },\n      },\n      select: {\n        user: {\n          select: {\n            email: true,\n            locale: true,\n          },\n        },\n      },\n    });\n  }\n}",
            "output_extracted": "import { LookupTarget, ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\nimport { withSelectedCalendars } from \"@calcom/features/users/repositories/UserRepository\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { eventTypeSelect } from \"@calcom/lib/server/eventTypeSelect\";\nimport { availabilityUserSelect, prisma, type PrismaTransaction } from \"@calcom/prisma\";\nimport type { Prisma, Membership, PrismaClient } from \"@calcom/prisma/client\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\nimport { credentialForCalendarServiceSelect } from \"@calcom/prisma/selects/credential\";\n\nconst log = logger.getSubLogger({ prefix: [\"features/membership/repositories/MembershipRepository\"] });\ntype IMembership = {\n  teamId: number;\n  userId: number;\n  accepted: boolean;\n  role: MembershipRole;\n  createdAt?: Date;\n};\n\nconst membershipSelect = {\n  id: true,\n  teamId: true,\n  userId: true,\n  accepted: true,\n  role: true,\n  disableImpersonation: true,\n} satisfies Prisma.MembershipSelect;\n\ntype MembershipSelectableKeys = keyof typeof membershipSelect;\n\ntype MembershipPartialSelect = Partial<Record<MembershipSelectableKeys, boolean>>;\n\ntype MembershipDTO = Pick<Membership, MembershipSelectableKeys>;\n\ntype MembershipDTOFromSelect<TSelect extends MembershipPartialSelect> = {\n  [K in keyof TSelect & keyof MembershipDTO as TSelect[K] extends true ? K : never]: MembershipDTO[K];\n};\n\nconst teamParentSelect = {\n  id: true,\n  name: true,\n  slug: true,\n  logoUrl: true,\n  parentId: true,\n  metadata: true,\n} satisfies Prisma.TeamSelect;\n\nconst userSelect = {\n  name: true,\n  avatarUrl: true,\n  username: true,\n  id: true,\n  timeZone: true,\n} satisfies Prisma.UserSelect;\n\nconst getWhereForfindAllByUpId = async (upId: string, where?: Prisma.MembershipWhereInput) => {\n  const lookupTarget = ProfileRepository.getLookupTarget(upId);\n  let prismaWhere;\n  if (lookupTarget.type === LookupTarget.Profile) {\n    /**\n     * TODO: When we add profileId to membership, we lookup by profileId\n     * If the profile is movedFromUser, we lookup all memberships without profileId as well.\n     */\n    let profile;\n    if (\"uid\" in lookupTarget && lookupTarget.uid) {\n      profile = await ProfileRepository.findByUid(lookupTarget.uid);\n    } else if (\"id\" in lookupTarget && lookupTarget.id !== undefined) {\n      profile = await ProfileRepository.findById(lookupTarget.id);\n    } else {\n      return [];\n    }\n    if (!profile) {\n      return [];\n    }\n    const userId = \"user\" in profile && profile.user ? profile.user.id : null;\n    if (!userId) {\n      return [];\n    }\n    prismaWhere = {\n      userId,\n      ...where,\n    };\n  } else {\n    prismaWhere = {\n      userId: lookupTarget.id,\n      ...where,\n    };\n  }\n\n  return prismaWhere;\n};\n\nexport class MembershipRepository {\n  constructor(private readonly prismaClient: PrismaClient = prisma) {}\n\n  async hasMembership({ userId, teamId }: { userId: number; teamId: number }): Promise<boolean> {\n    const membership = await this.prismaClient.membership.findFirst({\n      where: {\n        userId,\n        teamId,\n        accepted: true,\n      },\n      select: {\n        id: true,\n      },\n    });\n    return !!membership;\n  }\n\n  async listAcceptedTeamMemberIds({ teamId }: { teamId: number }): Promise<number[]> {\n    const memberships =\n      (await this.prismaClient.membership.findMany({\n        where: {\n          teamId,\n          accepted: true,\n        },\n        select: {\n          userId: true,\n        },\n      })) || [];\n    const teamMemberIds = memberships.map((membership) => membership.userId);\n    return teamMemberIds;\n  }\n\n  static async create(data: IMembership) {\n    return await prisma.membership.create({\n      data: {\n        createdAt: new Date(),\n        ...data,\n      },\n    });\n  }\n\n  static async findFirstAcceptedMembershipByUserId(userId: number) {\n    return await prisma.membership.findFirst({\n      where: {\n        accepted: true,\n        userId,\n        team: {\n          slug: {\n            not: null,\n          },\n        },\n      },\n    });\n  }\n\n  static async createMany(data: IMembership[]) {\n    return await prisma.membership.createMany({\n      data: data.map((item) => ({\n        createdAt: new Date(),\n        ...item,\n      })),\n    });\n  }\n\n  /**\n   * TODO: Using a specific function for specific tasks so that we don't have to focus on TS magic at the moment. May be try to make it a a generic findAllByProfileId with various options.\n   */\n  static async findAllByUpIdIncludeTeamWithMembersAndEventTypes(\n    { upId }: { upId: string },\n    { where }: { where?: Prisma.MembershipWhereInput } = {}\n  ) {\n    const prismaWhere = await getWhereForfindAllByUpId(upId, where);\n    if (Array.isArray(prismaWhere)) {\n      return prismaWhere;\n    }\n\n    log.debug(\n      \"findAllByUpIdIncludeTeamWithMembersAndEventTypes\",\n      safeStringify({\n        prismaWhere,\n      })\n    );\n\n    return await prisma.membership.findMany({\n      where: prismaWhere,\n      include: {\n        team: {\n          include: {\n            members: {\n              select: membershipSelect,\n            },\n            parent: {\n              select: teamParentSelect,\n            },\n            eventTypes: {\n              select: {\n                ...eventTypeSelect,\n                hashedLink: true,\n                users: { select: userSelect },\n                children: {\n                  include: {\n                    users: { select: userSelect },\n                  },\n                },\n                hosts: {\n                  include: {\n                    user: { select: userSelect },\n                  },\n                },\n                team: {\n                  select: {\n                    id: true,\n                    members: {\n                      select: {\n                        user: {\n                          select: {\n                            timeZone: true,\n                          },\n                        },\n                      },\n                      take: 1,\n                    },\n                  },\n                },\n              },\n              // As required by getByViewHandler - Make it configurable\n              orderBy: [\n                {\n                  position: \"desc\",\n                },\n                {\n                  id: \"asc\",\n                },\n              ],\n            },\n          },\n        },\n      },\n    });\n  }\n\n  static async findAllByUpIdIncludeMinimalEventTypes(\n    { upId }: { upId: string },\n    { where, skipEventTypes = false }: { where?: Prisma.MembershipWhereInput; skipEventTypes?: boolean } = {}\n  ) {\n    const prismaWhere = await getWhereForfindAllByUpId(upId, where);\n    if (Array.isArray(prismaWhere)) {\n      return prismaWhere;\n    }\n\n    log.debug(\n      \"findAllByUpIdIncludeMinimalEventTypes\",\n      safeStringify({\n        prismaWhere,\n      })\n    );\n\n    const select = {\n      id: true,\n      teamId: true,\n      userId: true,\n      accepted: true,\n      role: true,\n      disableImpersonation: true,\n      team: {\n        select: {\n          ...teamParentSelect,\n          isOrganization: true,\n          parent: {\n            select: teamParentSelect,\n          },\n          ...(!skipEventTypes\n            ? {\n                eventTypes: {\n                  select: {\n                    ...eventTypeSelect,\n                    hashedLink: true,\n                    children: { select: { id: true } },\n                  },\n                  orderBy: [\n                    {\n                      position: \"desc\",\n                    },\n                    {\n                      id: \"asc\",\n                    },\n                  ],\n                },\n              }\n            : {}),\n        },\n      },\n    } satisfies Prisma.MembershipSelect;\n\n    return await prisma.membership.findMany({\n      where: prismaWhere,\n      select,\n    });\n  }\n\n  static async findAllByUpIdIncludeTeam(\n    { upId }: { upId: string },\n    { where }: { where?: Prisma.MembershipWhereInput } = {}\n  ) {\n    const prismaWhere = await getWhereForfindAllByUpId(upId, where);\n    if (Array.isArray(prismaWhere)) {\n      return prismaWhere;\n    }\n\n    return await prisma.membership.findMany({\n      where: prismaWhere,\n      include: {\n        team: {\n          include: {\n            parent: {\n              select: teamParentSelect,\n            },\n          },\n        },\n      },\n    });\n  }\n\n  static async findUniqueByUserIdAndTeamId({ userId, teamId }: { userId: number; teamId: number }) {\n    return await prisma.membership.findUnique({\n      where: {\n        userId_teamId: {\n          userId,\n          teamId,\n        },\n      },\n    });\n  }\n\n  async findAllMembershipsByUserIdForBilling({ userId }: { userId: number }) {\n    return this.prismaClient.membership.findMany({\n      where: { userId },\n      select: {\n        accepted: true,\n        user: {\n          select: {\n            isPlatformManaged: true,\n          },\n        },\n        team: {\n          select: {\n            slug: true,\n            isOrganization: true,\n            isPlatform: true,\n            metadata: true,\n            platformBilling: {\n              select: {\n                plan: true,\n              },\n            },\n            parent: {\n              select: {\n                isOrganization: true,\n                slug: true,\n                metadata: true,\n                isPlatform: true,\n              },\n            },\n          },\n        },\n      },\n    });\n  }\n\n  static async findByTeamIdForAvailability({ teamId }: { teamId: number }) {\n    const memberships = await prisma.membership.findMany({\n      where: { teamId },\n      include: {\n        user: {\n          select: {\n            credentials: {\n              select: credentialForCalendarServiceSelect,\n            }, // needed for getUserAvailability\n            ...availabilityUserSelect,\n          },\n        },\n      },\n    });\n\n    const membershipsWithSelectedCalendars = memberships.map((m) => {\n      return {\n        ...m,\n        user: withSelectedCalendars(m.user),\n      };\n    });\n\n    return membershipsWithSelectedCalendars;\n  }\n\n  static async getAdminOrOwnerMembership(userId: number, teamId: number) {\n    return prisma.membership.findFirst({\n      where: {\n        userId,\n        teamId,\n        accepted: true,\n        role: {\n          in: [MembershipRole.ADMIN, MembershipRole.OWNER],\n        },\n      },\n      select: {\n        id: true,\n      },\n    });\n  }\n\n  static async findAllAcceptedPublishedTeamMemberships(userId: number, tx?: PrismaTransaction) {\n    return (tx ?? prisma).membership.findMany({\n      where: {\n        userId,\n        accepted: true,\n        team: {\n          slug: { not: null },\n        },\n      },\n      select: {\n        teamId: true,\n      },\n    });\n  }\n\n  /**\n   * Get all team IDs that a user is a member of\n   */\n  static async findUserTeamIds({ userId }: { userId: number }) {\n    const memberships = await prisma.membership.findMany({\n      where: {\n        userId,\n        accepted: true,\n      },\n      select: {\n        teamId: true,\n      },\n    });\n\n    return memberships.map((membership) => membership.teamId);\n  }\n\n  /**\n   * Returns members who joined after the given time\n   */\n  static async findMembershipsCreatedAfterTimeIncludeUser({\n    organizationId,\n    time,\n  }: {\n    organizationId: number;\n    time: Date;\n  }) {\n    return prisma.membership.findMany({\n      where: {\n        teamId: organizationId,\n        createdAt: { gt: time },\n        accepted: true,\n      },\n      include: {\n        user: {\n          select: {\n            email: true,\n            name: true,\n            id: true,\n          },\n        },\n      },\n    });\n  }\n\n  static async findAllByTeamIds<TSelect extends MembershipPartialSelect = { userId: true }>({\n    teamIds,\n    select,\n  }: {\n    teamIds: number[];\n    select?: TSelect;\n  }): Promise<MembershipDTOFromSelect<TSelect>[]> {\n    return (await prisma.membership.findMany({\n      where: {\n        teamId: { in: teamIds },\n        accepted: true,\n      },\n      // this is explicit, and typed in TSelect default typings\n      select: select ?? { userId: true },\n    })) as unknown as Promise<MembershipDTOFromSelect<TSelect>[]>;\n  }\n\n  static async findAllAcceptedTeamMemberships(userId: number, where?: Prisma.MembershipWhereInput) {\n    const teams = await prisma.team.findMany({\n      where: {\n        members: {\n          some: {\n            userId,\n            accepted: true,\n            ...(where ?? {}),\n          },\n        },\n      },\n    });\n    return teams;\n  }\n\n  static async findAllByUserId({\n    userId,\n    filters,\n  }: {\n    userId: number;\n    filters?: {\n      accepted?: boolean;\n      roles?: MembershipRole[];\n    };\n  }) {\n    return prisma.membership.findMany({\n      where: {\n        userId,\n        ...(filters?.accepted !== undefined && { accepted: filters.accepted }),\n        ...(filters?.roles && { role: { in: filters.roles } }),\n      },\n      select: {\n        teamId: true,\n        role: true,\n        team: {\n          select: {\n            id: true,\n            parentId: true,\n          },\n        },\n      },\n    });\n  }\n\n  async findTeamAdminsByTeamId({ teamId }: { teamId: number }) {\n    return await this.prismaClient.membership.findMany({\n      where: {\n        team: {\n          id: teamId,\n          parentId: {\n            not: null,\n          },\n        },\n        role: {\n          in: [\"ADMIN\", \"OWNER\"],\n        },\n      },\n      select: {\n        user: {\n          select: {\n            email: true,\n            locale: true,\n          },\n        },\n      },\n    });\n  }\n}",
            "cost": 0.12453
        },
        "calcom__cal.com.main/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts": {
            "output": "import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\nimport prisma from \"@calcom/prisma\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TrpcSessionUser } from \"../../../types\";\nimport type { TRemoveHostsFromEventTypes } from \"./removeHostsFromEventTypes.schema\";\n\ntype RemoveHostsFromEventTypes = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  };\n  input: TRemoveHostsFromEventTypes;\n};\n\nexport async function removeHostsFromEventTypesHandler({ ctx, input }: RemoveHostsFromEventTypes) {\n  const { userIds, eventTypeIds, teamId } = input;\n\n  const permissionCheckService = new PermissionCheckService();\n  const hasEventTypeUpdatePermission = await permissionCheckService.checkPermission({\n    userId: ctx.user.id,\n    teamId,\n    permission: \"eventType.update\",\n    fallbackRoles: [MembershipRole.OWNER, MembershipRole.ADMIN],\n  });\n\n  // check if user has permission to update event types\n  if (!hasEventTypeUpdatePermission) throw new TRPCError({ code: \"UNAUTHORIZED\" });\n\n  return await prisma.host.deleteMany({\n    where: {\n      eventTypeId: {\n        in: eventTypeIds,\n      },\n      userId: {\n        in: userIds,\n      },\n    },\n  });\n}\n\nexport default removeHostsFromEventTypesHandler;",
            "output_extracted": "import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\nimport prisma from \"@calcom/prisma\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\n\nimport { TRPCError } from \"@trpc/server\";\n\nimport type { TrpcSessionUser } from \"../../../types\";\nimport type { TRemoveHostsFromEventTypes } from \"./removeHostsFromEventTypes.schema\";\n\ntype RemoveHostsFromEventTypes = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  };\n  input: TRemoveHostsFromEventTypes;\n};\n\nexport async function removeHostsFromEventTypesHandler({ ctx, input }: RemoveHostsFromEventTypes) {\n  const { userIds, eventTypeIds, teamId } = input;\n\n  const permissionCheckService = new PermissionCheckService();\n  const hasEventTypeUpdatePermission = await permissionCheckService.checkPermission({\n    userId: ctx.user.id,\n    teamId,\n    permission: \"eventType.update\",\n    fallbackRoles: [MembershipRole.OWNER, MembershipRole.ADMIN],\n  });\n\n  // check if user has permission to update event types\n  if (!hasEventTypeUpdatePermission) throw new TRPCError({ code: \"UNAUTHORIZED\" });\n\n  return await prisma.host.deleteMany({\n    where: {\n      eventTypeId: {\n        in: eventTypeIds,\n      },\n      userId: {\n        in: userIds,\n      },\n    },\n  });\n}\n\nexport default removeHostsFromEventTypesHandler;",
            "cost": 0.018735
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25321",
        "repo": "calcom/cal.com",
        "base_commit": "6499243a42c565c444b6b86f8c288413b5ac5a7c",
        "head_commit": "16f3ebdb0f536d2707b70e60c44df84bf4906f6a",
        "title": "fix: Remove hosts - verify event type belongs to event type",
        "merged_at": "2025-11-21T15:26:23Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25321",
        "test_files": [
            "packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.test.ts"
        ],
        "code_files": [
            "packages/features/membership/repositories/MembershipRepository.ts",
            "packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts"
        ],
        "total_changes": 376,
        "num_files": 3,
        "pull_number": 25321,
        "patch": "diff --git a/packages/features/membership/repositories/MembershipRepository.ts b/packages/features/membership/repositories/MembershipRepository.ts\nindex b016ea5bec2190..2975224066f362 100644\n--- a/packages/features/membership/repositories/MembershipRepository.ts\n+++ b/packages/features/membership/repositories/MembershipRepository.ts\n@@ -134,6 +134,22 @@ export class MembershipRepository {\n     });\n   }\n \n+  static async findAcceptedMembershipsByUserIdsInTeam({\n+    userIds,\n+    teamId,\n+  }: {\n+    userIds: number[];\n+    teamId: number;\n+  }) {\n+    return prisma.membership.findMany({\n+      where: {\n+        userId: { in: userIds },\n+        accepted: true,\n+        teamId,\n+      },\n+    });\n+  }\n+\n   static async createMany(data: IMembership[]) {\n     return await prisma.membership.createMany({\n       data: data.map((item) => ({\ndiff --git a/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.test.ts b/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.test.ts\nnew file mode 100644\nindex 00000000000000..b7c5c85e07394e\n--- /dev/null\n+++ b/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.test.ts\n@@ -0,0 +1,346 @@\n+/* eslint-disable @typescript-eslint/no-explicit-any */\n+import { describe, it, beforeEach, vi, expect } from \"vitest\";\n+\n+import { MembershipRepository } from \"@calcom/features/membership/repositories/MembershipRepository\";\n+import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\n+import prisma from \"@calcom/prisma\";\n+\n+import type { TrpcSessionUser } from \"../../../types\";\n+import removeHostsFromEventTypesHandler from \"./removeHostsFromEventTypes.handler\";\n+\n+vi.mock(\"@calcom/prisma\", () => ({\n+  default: {\n+    host: {\n+      deleteMany: vi.fn(),\n+    },\n+  },\n+}));\n+\n+vi.mock(\"@calcom/features/pbac/services/permission-check.service\", () => ({\n+  PermissionCheckService: vi.fn(),\n+}));\n+\n+vi.mock(\"@calcom/features/membership/repositories/MembershipRepository\", () => ({\n+  MembershipRepository: {\n+    findAcceptedMembershipsByUserIdsInTeam: vi.fn(),\n+  },\n+}));\n+\n+describe(\"removeHostsFromEventTypesHandler\", () => {\n+  const mockUser = {\n+    id: 1,\n+    name: \"Test User\",\n+  } as NonNullable<TrpcSessionUser>;\n+\n+  const mockInput = {\n+    userIds: [101, 102],\n+    eventTypeIds: [201, 202],\n+    teamId: 300,\n+  };\n+\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+  });\n+\n+  it(\"throws UNAUTHORIZED if user does not have eventType.update permission\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(false);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    await expect(\n+      removeHostsFromEventTypesHandler({\n+        ctx: { user: mockUser },\n+        input: mockInput,\n+      })\n+    ).rejects.toMatchObject({\n+      code: \"UNAUTHORIZED\",\n+    });\n+\n+    expect(mockCheckPermission).toHaveBeenCalledWith({\n+      userId: mockUser.id,\n+      teamId: mockInput.teamId,\n+      permission: \"eventType.update\",\n+      fallbackRoles: [\"OWNER\", \"ADMIN\"],\n+    });\n+\n+    expect(MembershipRepository.findAcceptedMembershipsByUserIdsInTeam).not.toHaveBeenCalled();\n+    expect(prisma.host.deleteMany).not.toHaveBeenCalled();\n+  });\n+\n+  it(\"deletes hosts when user has permission and all users are team members\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Mock that all userIds are valid team members\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 101 },\n+      { userId: 102 },\n+    ]);\n+\n+    const mockDeleteResult = { count: 3 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: mockInput,\n+    });\n+\n+    expect(result).toEqual(mockDeleteResult);\n+\n+    expect(mockCheckPermission).toHaveBeenCalledWith({\n+      userId: mockUser.id,\n+      teamId: mockInput.teamId,\n+      permission: \"eventType.update\",\n+      fallbackRoles: [\"OWNER\", \"ADMIN\"],\n+    });\n+\n+    expect(MembershipRepository.findAcceptedMembershipsByUserIdsInTeam).toHaveBeenCalledWith({\n+      userIds: mockInput.userIds,\n+      teamId: mockInput.teamId,\n+    });\n+\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: mockInput.eventTypeIds,\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: mockInput.userIds,\n+        },\n+      },\n+    });\n+  });\n+\n+  it(\"only removes hosts for userIds that are team members (filters out non-members)\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Mock that only userId 101 is a team member, 102 is not\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 101 },\n+    ]);\n+\n+    const mockDeleteResult = { count: 1 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: mockInput,\n+    });\n+\n+    expect(result).toEqual(mockDeleteResult);\n+\n+    expect(MembershipRepository.findAcceptedMembershipsByUserIdsInTeam).toHaveBeenCalledWith({\n+      userIds: mockInput.userIds,\n+      teamId: mockInput.teamId,\n+    });\n+\n+    // Should only delete for userId 101, not 102\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: mockInput.eventTypeIds,\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: [101], // Only 101, not 102\n+        },\n+      },\n+    });\n+  });\n+\n+  it(\"handles empty userIds array\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Empty array means no memberships to validate\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([]);\n+\n+    const mockDeleteResult = { count: 0 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const emptyUsersInput = {\n+      ...mockInput,\n+      userIds: [],\n+    };\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: emptyUsersInput,\n+    });\n+\n+    expect(result).toEqual(mockDeleteResult);\n+\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: mockInput.eventTypeIds,\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: [],\n+        },\n+      },\n+    });\n+  });\n+\n+  it(\"handles empty eventTypeIds array\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Mock that all userIds are valid team members\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 101 },\n+      { userId: 102 },\n+    ]);\n+\n+    const mockDeleteResult = { count: 0 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const emptyEventTypesInput = {\n+      ...mockInput,\n+      eventTypeIds: [],\n+    };\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: emptyEventTypesInput,\n+    });\n+\n+    expect(result).toEqual(mockDeleteResult);\n+\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: [],\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: mockInput.userIds,\n+        },\n+      },\n+    });\n+  });\n+\n+  it(\"returns count of 0 when no hosts match the criteria\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Mock that all userIds are valid team members\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 101 },\n+      { userId: 102 },\n+    ]);\n+\n+    const mockDeleteResult = { count: 0 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: mockInput,\n+    });\n+\n+    expect(result.count).toBe(0);\n+  });\n+\n+  it(\"returns count of 0 when userId is a team member but not a host on the specified event types\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // User 999 is a valid team member\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 999 },\n+    ]);\n+\n+    // But they're not a host on any of the event types\n+    const mockDeleteResult = { count: 0 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const nonHostInput = {\n+      ...mockInput,\n+      userIds: [999],\n+    };\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: nonHostInput,\n+    });\n+\n+    expect(result.count).toBe(0);\n+\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: mockInput.eventTypeIds,\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: [999],\n+        },\n+      },\n+    });\n+  });\n+\n+  it(\"returns count of 0 when event types do not belong to the specified team\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Mock that all userIds are valid team members\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 101 },\n+      { userId: 102 },\n+    ]);\n+\n+    // Event types belong to a different team, so no hosts should be deleted\n+    const mockDeleteResult = { count: 0 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: mockInput,\n+    });\n+\n+    expect(result.count).toBe(0);\n+\n+    // Verify the query includes the teamId check\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: mockInput.eventTypeIds,\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: mockInput.userIds,\n+        },\n+      },\n+    });\n+  });\n+});\ndiff --git a/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts b/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts\nindex e819766fee8d44..ba0a7add791387 100644\n--- a/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts\n+++ b/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts\n@@ -1,3 +1,4 @@\n+import { MembershipRepository } from \"@calcom/features/membership/repositories/MembershipRepository\";\n import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\n import prisma from \"@calcom/prisma\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n@@ -28,13 +29,24 @@ export async function removeHostsFromEventTypesHandler({ ctx, input }: RemoveHos\n   // check if user has permission to update event types\n   if (!hasEventTypeUpdatePermission) throw new TRPCError({ code: \"UNAUTHORIZED\" });\n \n+  // verify that all userIds are members of the team\n+  const teamMemberIds = await MembershipRepository.findAcceptedMembershipsByUserIdsInTeam({\n+    userIds,\n+    teamId,\n+  });\n+\n+  const filteredUserIds = teamMemberIds.map((teamMember) => teamMember.userId);\n+\n   return await prisma.host.deleteMany({\n     where: {\n       eventTypeId: {\n         in: eventTypeIds,\n       },\n+      eventType: {\n+        teamId: teamId,\n+      },\n       userId: {\n-        in: userIds,\n+        in: filteredUserIds,\n       },\n     },\n   });\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}