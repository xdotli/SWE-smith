diff --git a/packages/features/auth/lib/next-auth-options.ts b/packages/features/auth/lib/next-auth-options.ts
index e4ee24a..82e8fc7 100644
--- a/packages/features/auth/lib/next-auth-options.ts
+++ b/packages/features/auth/lib/next-auth-options.ts
@@ -15,8 +15,8 @@ import { LicenseKeySingleton } from "@calcom/ee/common/server/LicenseKeyService"
 import { CredentialRepository } from "@calcom/features/credentials/repositories/CredentialRepository";
 import createUsersAndConnectToOrg from "@calcom/features/ee/dsync/lib/users/createUsersAndConnectToOrg";
 import ImpersonationProvider from "@calcom/features/ee/impersonation/lib/ImpersonationProvider";
-import { getOrganizationRepository } from "@calcom/features/ee/organizations/di/OrganizationRepository.container";
 import { getOrgFullOrigin, subdomainSuffix } from "@calcom/features/ee/organizations/lib/orgDomains";
+import { getOrganizationRepository } from "@calcom/features/ee/organizations/di/OrganizationRepository.container";
 import { clientSecretVerifier, hostedCal, isSAMLLoginEnabled } from "@calcom/features/ee/sso/lib/saml";
 import { ProfileRepository } from "@calcom/features/profile/repositories/ProfileRepository";
 import { UserRepository } from "@calcom/features/users/repositories/UserRepository";
@@ -360,778 +360,4 @@ if (isSAMLLoginEnabled) {
         const { access_token } = await oauthController.token({
           code,
           grant_type: "authorization_code",
-          redirect_uri: `${process.env.NEXTAUTH_URL}`,
-          client_id: "dummy",
-          client_secret: clientSecretVerifier,
-        });
-
-        if (!access_token) {
-          return null;
-        }
-        // Fetch user info
-        const userInfo = await oauthController.userInfo(access_token);
-
-        if (!userInfo) {
-          return null;
-        }
-
-        const { id, firstName, lastName } = userInfo;
-        const email = userInfo.email.toLowerCase();
-        const userRepo = new UserRepository(prisma);
-        let user = !email ? undefined : await userRepo.findByEmailAndIncludeProfilesAndPassword({ email });
-        if (!user) {
-          const hostedCal = Boolean(HOSTED_CAL_FEATURES);
-          if (hostedCal && email) {
-            const domain = getDomainFromEmail(email);
-            const organizationRepository = getOrganizationRepository();
-            const org = await organizationRepository.getVerifiedOrganizationByAutoAcceptEmailDomain(domain);
-            if (org) {
-              const createUsersAndConnectToOrgProps = {
-                emailsToCreate: [email],
-                identityProvider: IdentityProvider.SAML,
-                identityProviderId: email,
-              };
-              await createUsersAndConnectToOrg({
-                createUsersAndConnectToOrgProps,
-                org,
-              });
-              user = await userRepo.findByEmailAndIncludeProfilesAndPassword({
-                email: email,
-              });
-            }
-          }
-          if (!user) throw new Error(ErrorCode.UserNotFound);
-        }
-        const [userProfile] = user?.allProfiles ?? [];
-        return {
-          id: id as unknown as number,
-          firstName,
-          lastName,
-          email,
-          name: `${firstName} ${lastName}`.trim(),
-          email_verified: true,
-          profile: userProfile,
-        };
-      },
-    })
-  );
-}
-
-providers.push(
-  EmailProvider({
-    type: "email",
-    maxAge: 10 * 60 * 60, // Magic links are valid for 10 min only
-    // Here we setup the sendVerificationRequest that calls the email template with the identifier (email) and token to verify.
-    sendVerificationRequest: async (props) => (await import("./sendVerificationRequest")).default(props),
-  })
-);
-
-function isNumber(n: string) {
-  return !isNaN(parseFloat(n)) && !isNaN(+n);
-}
-
-const calcomAdapter = CalComAdapter(prisma);
-
-const mapIdentityProvider = (providerName: string) => {
-  switch (providerName) {
-    case "saml-idp":
-    case "saml":
-      return IdentityProvider.SAML;
-    default:
-      return IdentityProvider.GOOGLE;
-  }
-};
-
-export const getOptions = ({
-  getDubId,
-}: {
-  /** so we can extract the Dub cookie in both pages and app routers */
-  getDubId: () => string | undefined;
-}): AuthOptions => ({
-  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
-  // @ts-ignore
-  adapter: calcomAdapter,
-  session: {
-    strategy: "jwt",
-  },
-  jwt: {
-    // decorate the native JWT encode function
-    // Impl. detail: We don't pass through as this function is called with encode/decode functions.
-    encode: async ({ token, maxAge, secret }) => {
-      log.debug("jwt:encode", safeStringify({ token, maxAge }));
-      if (token?.sub && isNumber(token.sub)) {
-        const user = await prisma.user.findFirst({
-          where: { id: Number(token.sub) },
-          select: { metadata: true },
-        });
-        // if no user is found, we still don't want to crash here.
-        if (user) {
-          const metadata = userMetadata.parse(user.metadata);
-          if (metadata?.sessionTimeout) {
-            maxAge = metadata.sessionTimeout * 60;
-          }
-        }
-      }
-      return encode({ secret, token, maxAge });
-    },
-  },
-  cookies: defaultCookies(WEBAPP_URL?.startsWith("https://")),
-  pages: {
-    signIn: "/auth/login",
-    signOut: "/auth/logout",
-    error: "/auth/error", // Error code passed in query string as ?error=
-    verifyRequest: "/auth/verify",
-    // newUser: "/auth/new", // New users will be directed here on first sign in (leave the property out if not of interest)
-  },
-  providers,
-  callbacks: {
-    async jwt({
-      // Always available but with a little difference in value
-      token,
-      // Available only in case of signIn, signUp or useSession().update call.
-      trigger,
-      // Available when useSession().update is called. The value will be the POST data
-      session,
-      // Available only in the first call once the user signs in. Not available in subsequent calls
-      user,
-      // Available only in the first call once the user signs in. Not available in subsequent calls
-      account,
-    }) {
-      log.debug("callbacks:jwt", safeStringify({ token, user, account, trigger, session }));
-      // The data available in 'session' depends on what data was supplied in update method call of session
-      if (trigger === "update") {
-        return {
-          ...token,
-          profileId: session?.profileId ?? token.profileId ?? null,
-          upId: session?.upId ?? token.upId ?? null,
-          locale: session?.locale ?? token.locale ?? "en",
-          name: session?.name ?? token.name,
-          username: session?.username ?? token.username,
-          email: session?.email ?? token.email,
-        } as JWT;
-      }
-      const autoMergeIdentities = async () => {
-        const existingUser = await prisma.user.findFirst({
-          where: { email: token.email! },
-          select: {
-            id: true,
-            username: true,
-            avatarUrl: true,
-            name: true,
-            email: true,
-            role: true,
-            locale: true,
-            movedToProfileId: true,
-            teams: {
-              include: {
-                team: {
-                  select: {
-                    id: true,
-                    metadata: true,
-                  },
-                },
-              },
-            },
-          },
-        });
-
-        if (!existingUser) {
-          return token;
-        }
-
-        // Check if the existingUser has any active teams
-        const belongsToActiveTeam = checkIfUserBelongsToActiveTeam(existingUser);
-        const { teams: _teams, ...existingUserWithoutTeamsField } = existingUser;
-        const allProfiles = await ProfileRepository.findAllProfilesForUserIncludingMovedUser(existingUser);
-        log.debug(
-          "callbacks:jwt:autoMergeIdentities",
-          safeStringify({
-            allProfiles,
-          })
-        );
-        const { upId } = determineProfile({ profiles: allProfiles, token });
-
-        const profile = await ProfileRepository.findByUpIdWithAuth(upId, existingUser.id);
-        if (!profile) {
-          throw new Error("Profile not found");
-        }
-
-        const profileOrg = profile?.organization;
-        let orgRole: MembershipRole | undefined;
-        // Get users role of org
-        if (profileOrg) {
-          const membership = await prisma.membership.findUnique({
-            where: {
-              userId_teamId: {
-                teamId: profileOrg.id,
-                userId: existingUser.id,
-              },
-            },
-          });
-          orgRole = membership?.role;
-        }
-
-        return {
-          ...existingUserWithoutTeamsField,
-          ...token,
-          profileId: profile.id,
-          upId,
-          belongsToActiveTeam,
-          orgAwareUsername: profileOrg ? profile.username : existingUser.username,
-          // All organizations in the token would be too big to store. It breaks the sessions request.
-          // So, we just set the currently switched organization only here.
-          // platform org user don't need profiles nor domains
-          org:
-            profileOrg && !profileOrg.isPlatform
-              ? {
-                  id: profileOrg.id,
-                  name: profileOrg.name,
-                  slug: profileOrg.slug ?? profileOrg.requestedSlug ?? "",
-                  logoUrl: profileOrg.logoUrl,
-                  fullDomain: getOrgFullOrigin(profileOrg.slug ?? profileOrg.requestedSlug ?? ""),
-                  domainSuffix: subdomainSuffix(),
-                  role: orgRole as MembershipRole, // It can't be undefined if we have a profileOrg
-                }
-              : null,
-        } as JWT;
-      };
-      if (!user) {
-        return await autoMergeIdentities();
-      }
-      if (!account) {
-        return token;
-      }
-      if (account.type === "credentials") {
-        log.debug("callbacks:jwt:accountType:credentials", safeStringify({ account }));
-        // return token if credentials,saml-idp
-        if (account.provider === "saml-idp") {
-          return { ...token, upId: user.profile?.upId ?? token.upId ?? null } as JWT;
-        }
-        // any other credentials, add user info
-        return {
-          ...token,
-          id: user.id,
-          name: user.name,
-          username: user.username,
-          orgAwareUsername: user?.org ? user.profile?.username : user.username,
-          email: user.email,
-          role: user.role,
-          impersonatedBy: user.impersonatedBy,
-          belongsToActiveTeam: user?.belongsToActiveTeam,
-          org: user?.org,
-          locale: user?.locale,
-          profileId: user.profile?.id ?? token.profileId ?? null,
-          upId: user.profile?.upId ?? token.upId ?? null,
-        } as JWT;
-      }
-
-      // The arguments above are from the provider so we need to look up the
-      // user based on those values in order to construct a JWT.
-      if (account.type === "oauth") {
-        log.debug("callbacks:jwt:accountType:oauth", safeStringify({ account }));
-        if (!account.provider || !account.providerAccountId) {
-          return { ...token, upId: user.profile?.upId ?? token.upId ?? null } as JWT;
-        }
-        const idP = account.provider === "saml" ? IdentityProvider.SAML : IdentityProvider.GOOGLE;
-
-        const existingUser = await prisma.user.findFirst({
-          where: {
-            AND: [
-              {
-                identityProvider: idP,
-              },
-              {
-                identityProviderId: account.providerAccountId,
-              },
-            ],
-          },
-        });
-
-        if (!existingUser) {
-          return await autoMergeIdentities();
-        }
-
-        const grantedScopes = account.scope?.split(" ") ?? [];
-        if (
-          account.provider === "google" &&
-          !(await CredentialRepository.findFirstByAppIdAndUserId({
-            userId: Number(user.id),
-            appId: "google-calendar",
-          })) &&
-          GOOGLE_CALENDAR_SCOPES.every((scope) => grantedScopes.includes(scope))
-        ) {
-          // Installing Google Calendar by default
-          const credentialkey = {
-            access_token: account.access_token,
-            refresh_token: account.refresh_token,
-            id_token: account.id_token,
-            token_type: account.token_type,
-            expires_at: account.expires_at,
-          };
-          const gcalCredential = await CredentialRepository.create({
-            userId: Number(user.id),
-            key: credentialkey,
-            appId: "google-calendar",
-            type: "google_calendar",
-          });
-          const gCalService = new GoogleCalendarService({
-            ...gcalCredential,
-            user: null,
-            delegatedTo: null,
-          });
-
-          if (
-            !(await CredentialRepository.findFirstByUserIdAndType({
-              userId: Number(user.id),
-              type: "google_video",
-            }))
-          ) {
-            await CredentialRepository.create({
-              type: "google_video",
-              key: {},
-              userId: Number(user.id),
-              appId: "google-meet",
-            });
-          }
-
-          const oAuth2Client = new OAuth2Client(GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET);
-          oAuth2Client.setCredentials(credentialkey);
-          const calendar = new calendar_v3.Calendar({
-            auth: oAuth2Client,
-          });
-          const primaryCal = await gCalService.getPrimaryCalendar(calendar);
-          if (primaryCal?.id) {
-            await gCalService.createSelectedCalendar({
-              externalId: primaryCal.id,
-              userId: Number(user.id),
-            });
-          }
-          await updateProfilePhotoGoogle(oAuth2Client, Number(user.id));
-        }
-        const allProfiles = await ProfileRepository.findAllProfilesForUserIncludingMovedUser(existingUser);
-        const { upId } = determineProfile({ profiles: allProfiles, token });
-        log.debug("callbacks:jwt:accountType:oauth:existingUser", safeStringify({ existingUser, upId }));
-        return {
-          ...token,
-          upId,
-          id: existingUser.id,
-          name: existingUser.name,
-          username: existingUser.username,
-          email: existingUser.email,
-          role: existingUser.role,
-          impersonatedBy: token.impersonatedBy,
-          belongsToActiveTeam: token?.belongsToActiveTeam as boolean,
-          org: token?.org,
-          orgAwareUsername: token.orgAwareUsername,
-          locale: existingUser.locale,
-        } as JWT;
-      }
-
-      if (account.type === "email") {
-        return await autoMergeIdentities();
-      }
-
-      log.info(
-        "callbacks:jwt:accountType:unknown",
-        safeStringify({ accountType: account.type, accountProvider: account.provider })
-      );
-      return token;
-    },
-    async session({ session, token, user }) {
-      log.debug("callbacks:session - Session callback called", safeStringify({ session, token, user }));
-      const deploymentRepo = new DeploymentRepository(prisma);
-      const licenseKeyService = await LicenseKeySingleton.getInstance(deploymentRepo);
-      const hasValidLicense = await licenseKeyService.checkLicense();
-      const profileId = token.profileId;
-      const calendsoSession: Session = {
-        ...session,
-        profileId,
-        upId: token.upId || session.upId,
-        hasValidLicense,
-        user: {
-          ...session.user,
-          id: token.id as number,
-          name: token.name,
-          username: token.username as string,
-          orgAwareUsername: token.orgAwareUsername,
-          role: token.role as UserPermissionRole,
-          impersonatedBy: token.impersonatedBy,
-          belongsToActiveTeam: token?.belongsToActiveTeam as boolean,
-          org: token?.org,
-          locale: token.locale,
-        },
-      };
-      return calendsoSession;
-    },
-    async signIn(params): Promise<boolean | string> {
-      const {
-        /**
-         * Available when Credentials provider is used - Has the value returned by authorize callback
-         */
-        user,
-        /**
-         * Available when Credentials provider is used - Has the value submitted as the body of the HTTP POST submission
-         */
-        profile,
-        account,
-      } = params;
-
-      log.debug("callbacks:signin", safeStringify(params));
-
-      if (account?.provider === "email") {
-        return true;
-      }
-      // In this case we've already verified the credentials in the authorize
-      // callback so we can sign the user in.
-      // Only if provider is not saml-idp
-      if (account?.provider !== "saml-idp") {
-        if (account?.type === "credentials") {
-          return true;
-        }
-
-        if (account?.type !== "oauth") {
-          return false;
-        }
-      }
-      if (!user.email) {
-        return false;
-      }
-
-      if (!user.name) {
-        return false;
-      }
-      if (account?.provider) {
-        const idP: IdentityProvider = mapIdentityProvider(account.provider);
-        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
-        // @ts-ignore-error TODO validate email_verified key on profile
-        user.email_verified = user.email_verified || !!user.emailVerified || profile.email_verified;
-
-        if (!user.email_verified) {
-          log.error("Attention: SAML/Google User email is not verified in the IdP", safeStringify({ user }));
-          return "/auth/error?error=unverified-email";
-        }
-
-        let existingUser = await prisma.user.findFirst({
-          include: {
-            password: {
-              select: {
-                hash: true,
-              },
-            },
-            accounts: {
-              where: {
-                provider: account.provider,
-              },
-            },
-          },
-          where: {
-            identityProvider: idP,
-            identityProviderId: account.providerAccountId,
-          },
-        });
-
-        /* --- START FIX LEGACY ISSUE WHERE 'identityProviderId' was accidentally set to userId --- */
-        if (!existingUser) {
-          existingUser = await prisma.user.findFirst({
-            include: {
-              password: {
-                select: {
-                  hash: true,
-                },
-              },
-              accounts: {
-                where: {
-                  provider: account.provider,
-                },
-              },
-            },
-            where: {
-              identityProvider: idP,
-              identityProviderId: String(user.id),
-            },
-          });
-          if (existingUser) {
-            await prisma.user.update({
-              where: {
-                id: existingUser?.id,
-              },
-              data: {
-                identityProviderId: account.providerAccountId,
-              },
-            });
-          }
-        }
-        /* --- END FIXES LEGACY ISSUE WHERE 'identityProviderId' was accidentally set to userId --- */
-        if (existingUser) {
-          // In this case there's an existing user and their email address
-          // hasn't changed since they last logged in.
-          if (existingUser.email === user.email) {
-            try {
-              // If old user without Account entry we link their google account
-              if (existingUser.accounts.length === 0) {
-                const linkAccountWithUserData = AdapterAccountPresenter.fromCalAccount(
-                  account,
-                  existingUser.id,
-                  user.email
-                );
-                await calcomAdapter.linkAccount(linkAccountWithUserData);
-              }
-            } catch (error) {
-              if (error instanceof Error) {
-                log.error("Error while linking account of already existing user", safeStringify(error));
-              }
-            }
-            if (existingUser.twoFactorEnabled && existingUser.identityProvider === idP) {
-              return loginWithTotp(existingUser.email);
-            } else {
-              return true;
-            }
-          }
-
-          // If the email address doesn't match, check if an account already exists
-          // with the new email address. If it does, for now we return an error. If
-          // not, update the email of their account and log them in.
-          const userWithNewEmail = await prisma.user.findFirst({
-            where: { email: user.email },
-          });
-
-          if (!userWithNewEmail) {
-            await prisma.user.update({ where: { id: existingUser.id }, data: { email: user.email } });
-            if (existingUser.twoFactorEnabled) {
-              return loginWithTotp(existingUser.email);
-            } else {
-              return true;
-            }
-          } else {
-            return "/auth/error?error=new-email-conflict";
-          }
-        }
-
-        // If there's no existing user for this identity provider and id, create
-        // a new account. If an account already exists with the incoming email
-        // address return an error for now.
-
-        const existingUserWithEmail = await prisma.user.findFirst({
-          where: {
-            email: {
-              equals: user.email,
-              mode: "insensitive",
-            },
-          },
-          include: {
-            password: {
-              select: {
-                hash: true,
-              },
-            },
-          },
-        });
-
-        if (existingUserWithEmail) {
-          // if self-hosted then we can allow auto-merge of identity providers if email is verified
-          if (
-            !hostedCal &&
-            existingUserWithEmail.emailVerified &&
-            existingUserWithEmail.identityProvider !== IdentityProvider.CAL
-          ) {
-            if (existingUserWithEmail.twoFactorEnabled) {
-              return loginWithTotp(existingUserWithEmail.email);
-            } else {
-              return true;
-            }
-          }
-
-          // check if user was invited
-          if (
-            !existingUserWithEmail.password?.hash &&
-            !existingUserWithEmail.emailVerified &&
-            !existingUserWithEmail.username
-          ) {
-            await prisma.user.update({
-              where: {
-                email: existingUserWithEmail.email,
-              },
-              data: {
-                // update the email to the IdP email
-                email: user.email,
-                // Slugify the incoming name and append a few random characters to
-                // prevent conflicts for users with the same name.
-                username: getOrgUsernameFromEmail(user.email, getDomainFromEmail(user.email)),
-                emailVerified: new Date(Date.now()),
-                name: user.name,
-                identityProvider: idP,
-                identityProviderId: account.providerAccountId,
-              },
-            });
-
-            if (existingUserWithEmail.twoFactorEnabled) {
-              return loginWithTotp(existingUserWithEmail.email);
-            } else {
-              return true;
-            }
-          }
-
-          // User signs up with email/password and then tries to login with Google/SAML using the same email
-          if (
-            existingUserWithEmail.identityProvider === IdentityProvider.CAL &&
-            (idP === IdentityProvider.GOOGLE || idP === IdentityProvider.SAML)
-          ) {
-            await prisma.user.update({
-              where: { email: existingUserWithEmail.email },
-              // also update email to the IdP email
-              data: {
-                email: user.email.toLowerCase(),
-                identityProvider: idP,
-                identityProviderId: account.providerAccountId,
-              },
-            });
-
-            if (existingUserWithEmail.twoFactorEnabled) {
-              return loginWithTotp(existingUserWithEmail.email);
-            } else {
-              return true;
-            }
-          } else if (existingUserWithEmail.identityProvider === IdentityProvider.CAL) {
-            return `/auth/error?error=wrong-provider&provider=${existingUserWithEmail.identityProvider}`;
-          } else if (
-            existingUserWithEmail.identityProvider === IdentityProvider.GOOGLE &&
-            idP === IdentityProvider.SAML
-          ) {
-            await prisma.user.update({
-              where: { email: existingUserWithEmail.email },
-              // also update email to the IdP email
-              data: {
-                email: user.email.toLowerCase(),
-                identityProvider: idP,
-                identityProviderId: account.providerAccountId,
-              },
-            });
-
-            if (existingUserWithEmail.twoFactorEnabled) {
-              return loginWithTotp(existingUserWithEmail.email);
-            } else {
-              return true;
-            }
-          }
-          return `/auth/error?error=wrong-provider&provider=${existingUserWithEmail.identityProvider}`;
-        }
-
-        // Associate with organization if enabled by flag and idP is Google (for now)
-        const { orgUsername, orgId } = await checkIfUserShouldBelongToOrg(idP, user.email);
-
-        try {
-          const newUser = await prisma.user.create({
-            data: {
-              // Slugify the incoming name and append a few random characters to
-              // prevent conflicts for users with the same name.
-              username: orgId ? slugify(orgUsername) : usernameSlug(user.name),
-              emailVerified: new Date(Date.now()),
-              name: user.name,
-              ...(user.image && { avatarUrl: user.image }),
-              email: user.email,
-              identityProvider: idP,
-              identityProviderId: account.providerAccountId,
-              ...(orgId && {
-                verified: true,
-                organization: { connect: { id: orgId } },
-                teams: {
-                  create: { role: MembershipRole.MEMBER, accepted: true, team: { connect: { id: orgId } } },
-                },
-              }),
-              creationSource: CreationSource.WEBAPP,
-            },
-          });
-          const linkAccountNewUserData = AdapterAccountPresenter.fromCalAccount(
-            account,
-            newUser.id,
-            user.email
-          );
-          await calcomAdapter.linkAccount(linkAccountNewUserData);
-
-          if (account.twoFactorEnabled) {
-            return loginWithTotp(newUser.email);
-          } else {
-            return true;
-          }
-        } catch (err) {
-          log.error("Error creating a new user", err);
-          return `/auth/error?error=user-creation-error`;
-        }
-      }
-
-      return false;
-    },
-    /**
-     * Used to handle the navigation right after successful login or logout
-     */
-    async redirect({ url, baseUrl }) {
-      // Allows relative callback URLs
-      if (url.startsWith("/")) return `${baseUrl}${url}`;
-      // Allows callback URLs on the same domain
-      else if (new URL(url).hostname === new URL(WEBAPP_URL).hostname) return url;
-      return baseUrl;
-    },
-  },
-  events: {
-    async signIn(message) {
-      /* only run this code if:
-         - it's a hosted cal account
-         - DUB_API_KEY is configured
-         - it's a new user
-      */
-      const user = message.user as User & {
-        username: string;
-        createdDate: string;
-      };
-      // check if the user was created in the last 10 minutes
-      // this is a workaround – in the future once we move to use the Account model in the DB
-      // we should use NextAuth's isNewUser flag instead: https://next-auth.js.org/configuration/events#signin
-      const isNewUser = new Date(user.createdDate) > new Date(Date.now() - 10 * 60 * 1000);
-      if ((isENVDev || IS_CALCOM) && isNewUser) {
-        if (process.env.DUB_API_KEY) {
-          const clickId = getDubId();
-          // check if there's a clickId (dub_id) cookie set by @dub/analytics
-          if (clickId) {
-            // here we use waitUntil – meaning this code will run async to not block the main thread
-            waitUntil(
-              // if so, send a lead event to Dub
-              // @see https://d.to/conversions/next-auth
-              dub.track.lead({
-                clickId,
-                eventName: "Sign Up",
-                externalId: user.id.toString(),
-                customerName: user.name,
-                customerEmail: user.email,
-                customerAvatar: user.image,
-              })
-            );
-          }
-        }
-      }
-    },
-  },
-});
-
-/**
- * Identifies the profile the user should be logged into.
- */
-const determineProfile = ({
-  token,
-  profiles,
-}: {
-  token: JWT;
-  profiles: { id: number | null; upId: string }[];
-}) => {
-  // If profile switcher is disabled, we can only show the first profile.
-  if (!ENABLE_PROFILE_SWITCHER) {
-    return profiles[0];
-  }
-
-  if (token.upId) {
-    // Otherwise use what's in the token
-    return { profileId: token.profileId, upId: token.upId as string };
-  }
-
-  // If there is just one profile it has to be the one we want to log into.
-  return profiles[0];
-};
+          redirect_uri: `${process.env.NEXTAUTH_URL}
\ No newline at end of file
diff --git a/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts b/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts
index d5d1cdb..90b90b6 100644
--- a/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts
+++ b/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts
@@ -16,30 +16,6 @@ describe("getOrgUsernameFromEmail", () => {
     const result = getOrgUsernameFromEmail(email, autoAcceptEmailDomain);
     expect(result).toBe("john.doe-example");
   });
-
-  it("should generate unique usernames for different emails even with same name", () => {
-    const email1 = "alice@acme.com";
-    const email2 = "alice+work@corp.com";
-
-    const username1 = getOrgUsernameFromEmail(email1, null);
-    const username2 = getOrgUsernameFromEmail(email2, null);
-
-    expect(username1).toBe("alice-acme");
-    expect(username2).toBe("alice-work-corp");
-    expect(username1).not.toBe(username2);
-  });
-
-  it("should handle email with plus sign correctly", () => {
-    const email = "bob+test@example.com";
-    const result = getOrgUsernameFromEmail(email, "example.com");
-    expect(result).toBe("bob-test");
-  });
-
-  it("should handle null autoAcceptEmailDomain", () => {
-    const email = "user@company.com";
-    const result = getOrgUsernameFromEmail(email, null);
-    expect(result).toBe("user-company");
-  });
 });
 
 describe("deriveNameFromOrgUsername", () => {
@@ -48,4 +24,4 @@ describe("deriveNameFromOrgUsername", () => {
     const result = deriveNameFromOrgUsername({ username });
     expect(result).toBe("John Doe Example");
   });
-});
+});
\ No newline at end of file
