{
    "cost": 0.182675,
    "rewrites": {
        "calcom__cal.com.main/packages/features/auth/lib/next-auth-options.ts": {
            "output": "import { calendar_v3 } from \"@googleapis/calendar\";\nimport { waitUntil } from \"@vercel/functions\";\nimport { OAuth2Client } from \"googleapis-common\";\nimport type { AuthOptions, Account, Session, User } from \"next-auth\";\nimport type { JWT } from \"next-auth/jwt\";\nimport { encode } from \"next-auth/jwt\";\nimport type { Provider } from \"next-auth/providers\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport EmailProvider from \"next-auth/providers/email\";\nimport GoogleProvider from \"next-auth/providers/google\";\n\nimport { updateProfilePhotoGoogle } from \"@calcom/app-store/_utils/oauth/updateProfilePhotoGoogle\";\nimport GoogleCalendarService from \"@calcom/app-store/googlecalendar/lib/CalendarService\";\nimport { LicenseKeySingleton } from \"@calcom/ee/common/server/LicenseKeyService\";\nimport { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\nimport createUsersAndConnectToOrg from \"@calcom/features/ee/dsync/lib/users/createUsersAndConnectToOrg\";\nimport ImpersonationProvider from \"@calcom/features/ee/impersonation/lib/ImpersonationProvider\";\nimport { getOrgFullOrigin, subdomainSuffix } from \"@calcom/features/ee/organizations/lib/orgDomains\";\nimport { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\nimport { clientSecretVerifier, hostedCal, isSAMLLoginEnabled } from \"@calcom/features/ee/sso/lib/saml\";\nimport { ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport { isPasswordValid } from \"@calcom/lib/auth/isPasswordValid\";\nimport { checkRateLimitAndThrowError } from \"@calcom/lib/checkRateLimitAndThrowError\";\nimport {\n  GOOGLE_CALENDAR_SCOPES,\n  GOOGLE_OAUTH_SCOPES,\n  HOSTED_CAL_FEATURES,\n  IS_CALCOM,\n} from \"@calcom/lib/constants\";\nimport { ENABLE_PROFILE_SWITCHER, IS_TEAM_BILLING_ENABLED, WEBAPP_URL } from \"@calcom/lib/constants\";\nimport { symmetricDecrypt, symmetricEncrypt } from \"@calcom/lib/crypto\";\nimport { defaultCookies } from \"@calcom/lib/default-cookies\";\nimport { isENVDev } from \"@calcom/lib/env\";\nimport logger from \"@calcom/lib/logger\";\nimport { randomString } from \"@calcom/lib/random\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { hashEmail } from \"@calcom/lib/server/PiiHasher\";\nimport { DeploymentRepository } from \"@calcom/lib/server/repository/deployment\";\nimport slugify from \"@calcom/lib/slugify\";\nimport prisma from \"@calcom/prisma\";\nimport type { Membership, Team } from \"@calcom/prisma/client\";\nimport { CreationSource } from \"@calcom/prisma/enums\";\nimport { IdentityProvider, MembershipRole, UserPermissionRole } from \"@calcom/prisma/enums\";\nimport { teamMetadataSchema, userMetadata } from \"@calcom/prisma/zod-utils\";\n\nimport { getOrgUsernameFromEmail } from \"../signup/utils/getOrgUsernameFromEmail\";\nimport { ErrorCode } from \"./ErrorCode\";\nimport { dub } from \"./dub\";\nimport CalComAdapter from \"./next-auth-custom-adapter\";\nimport { verifyPassword } from \"./verifyPassword\";\n\ntype UserWithProfiles = NonNullable<\n  Awaited<ReturnType<UserRepository[\"findByEmailAndIncludeProfilesAndPassword\"]>>\n>;\n\n// This adapts our internal user model to what NextAuth expects\n// NextAuth core requires id to be a string, so we handle that here\nconst AdapterUserPresenter = {\n  fromCalUser: (\n    user: UserWithProfiles,\n    role: UserPermissionRole | \"INACTIVE_ADMIN\",\n    hasActiveTeams: boolean\n  ) => ({\n    ...user,\n    role: role as UserPermissionRole,\n    belongsToActiveTeam: hasActiveTeams,\n    profile: user.allProfiles[0],\n  }),\n};\n\n// Account presenter to handle linkAccount calls\nconst AdapterAccountPresenter = {\n  fromCalAccount: (account: Account, userId: number, providerEmail: string) => {\n    return {\n      ...account,\n      userId: String(userId), // Convert userId to string for Next Auth\n      providerEmail,\n      // Ensure these required fields are present\n      provider: account.provider,\n      providerAccountId: account.providerAccountId,\n      type: account.type,\n    };\n  },\n};\n\nconst log = logger.getSubLogger({ prefix: [\"next-auth-options\"] });\nconst GOOGLE_API_CREDENTIALS = process.env.GOOGLE_API_CREDENTIALS || \"{}\";\nconst { client_id: GOOGLE_CLIENT_ID, client_secret: GOOGLE_CLIENT_SECRET } =\n  JSON.parse(GOOGLE_API_CREDENTIALS)?.web || {};\nconst GOOGLE_LOGIN_ENABLED = process.env.GOOGLE_LOGIN_ENABLED === \"true\";\nconst IS_GOOGLE_LOGIN_ENABLED = !!(GOOGLE_CLIENT_ID && GOOGLE_CLIENT_SECRET && GOOGLE_LOGIN_ENABLED);\nconst ORGANIZATIONS_AUTOLINK =\n  process.env.ORGANIZATIONS_AUTOLINK === \"1\" || process.env.ORGANIZATIONS_AUTOLINK === \"true\";\n\nconst usernameSlug = (username: string) => `${slugify(username)}-${randomString(6).toLowerCase()}`;\nconst getDomainFromEmail = (email: string): string => email.split(\"@\")[1];\n\nconst loginWithTotp = async (email: string) =>\n  `/auth/login?totp=${encodeURIComponent(await (await import(\"./signJwt\")).default({ email }))}`;\n\ntype UserTeams = {\n  teams: (Membership & {\n    team: Pick<Team, \"metadata\">;\n  })[];\n};\n\nexport const checkIfUserBelongsToActiveTeam = <T extends UserTeams>(user: T) =>\n  user.teams.some((m: { team: { metadata: unknown } }) => {\n    if (!IS_TEAM_BILLING_ENABLED) {\n      return true;\n    }\n\n    const metadata = teamMetadataSchema.safeParse(m.team.metadata);\n\n    return metadata.success && metadata.data?.subscriptionId;\n  });\n\nconst checkIfUserShouldBelongToOrg = async (idP: IdentityProvider, email: string) => {\n  const [orgUsername, apexDomain] = email.split(\"@\");\n  if (!ORGANIZATIONS_AUTOLINK || idP !== \"GOOGLE\") return { orgUsername, orgId: undefined };\n  const existingOrg = await prisma.team.findFirst({\n    where: {\n      organizationSettings: {\n        isOrganizationVerified: true,\n        orgAutoAcceptEmail: apexDomain,\n      },\n    },\n    select: {\n      id: true,\n    },\n  });\n  return { orgUsername, orgId: existingOrg?.id };\n};\n\nconst providers: Provider[] = [\n  CredentialsProvider({\n    id: \"credentials\",\n    name: \"Cal.com\",\n    type: \"credentials\",\n    credentials: {\n      email: { label: \"Email Address\", type: \"email\", placeholder: \"john.doe@example.com\" },\n      password: { label: \"Password\", type: \"password\", placeholder: \"Your super secure password\" },\n      totpCode: { label: \"Two-factor Code\", type: \"input\", placeholder: \"Code from authenticator app\" },\n      backupCode: { label: \"Backup Code\", type: \"input\", placeholder: \"Two-factor backup code\" },\n    },\n    async authorize(credentials): Promise<User | null> {\n      log.debug(\"CredentialsProvider:credentials:authorize\", safeStringify({ credentials }));\n      if (!credentials) {\n        console.error(`For some reason credentials are missing`);\n        throw new Error(ErrorCode.InternalServerError);\n      }\n\n      const userRepo = new UserRepository(prisma);\n      const user = await userRepo.findByEmailAndIncludeProfilesAndPassword({\n        email: credentials.email,\n      });\n      // Don't leak information about it being username or password that is invalid\n      if (!user) {\n        throw new Error(ErrorCode.IncorrectEmailPassword);\n      }\n\n      // Locked users cannot login\n      if (user.locked) {\n        throw new Error(ErrorCode.UserAccountLocked);\n      }\n\n      await checkRateLimitAndThrowError({\n        identifier: hashEmail(user.email),\n      });\n\n      // Users without a password must use their identity provider (Google/SAML) to login\n      if (!user.password?.hash) {\n        throw new Error(ErrorCode.IncorrectEmailPassword);\n      }\n\n      // Always verify password for users who have one\n      const isCorrectPassword = await verifyPassword(credentials.password, user.password.hash);\n      if (!isCorrectPassword) {\n        throw new Error(ErrorCode.IncorrectEmailPassword);\n      }\n\n      if (user.twoFactorEnabled && credentials.backupCode) {\n        if (!process.env.CALENDSO_ENCRYPTION_KEY) {\n          console.error(\"Missing encryption key; cannot proceed with backup code login.\");\n          throw new Error(ErrorCode.InternalServerError);\n        }\n\n        if (!user.backupCodes) throw new Error(ErrorCode.MissingBackupCodes);\n\n        const backupCodes = JSON.parse(\n          symmetricDecrypt(user.backupCodes, process.env.CALENDSO_ENCRYPTION_KEY)\n        );\n\n        // check if user-supplied code matches one\n        const index = backupCodes.indexOf(credentials.backupCode.replaceAll(\"-\", \"\"));\n        if (index === -1) throw new Error(ErrorCode.IncorrectBackupCode);\n\n        // delete verified backup code and re-encrypt remaining\n        backupCodes[index] = null;\n        await prisma.user.update({\n          where: {\n            id: user.id,\n          },\n          data: {\n            backupCodes: symmetricEncrypt(JSON.stringify(backupCodes), process.env.CALENDSO_ENCRYPTION_KEY),\n          },\n        });\n      } else if (user.twoFactorEnabled) {\n        if (!credentials.totpCode) {\n          throw new Error(ErrorCode.SecondFactorRequired);\n        }\n\n        if (!user.twoFactorSecret) {\n          console.error(`Two factor is enabled for user ${user.id} but they have no secret`);\n          throw new Error(ErrorCode.InternalServerError);\n        }\n\n        if (!process.env.CALENDSO_ENCRYPTION_KEY) {\n          console.error(`\"Missing encryption key; cannot proceed with two factor login.\"`);\n          throw new Error(ErrorCode.InternalServerError);\n        }\n\n        const secret = symmetricDecrypt(user.twoFactorSecret, process.env.CALENDSO_ENCRYPTION_KEY);\n        if (secret.length !== 32) {\n          console.error(\n            `Two factor secret decryption failed. Expected key with length 32 but got ${secret.length}`\n          );\n          throw new Error(ErrorCode.InternalServerError);\n        }\n\n        const isValidToken = (await import(\"@calcom/lib/totp\")).totpAuthenticatorCheck(\n          credentials.totpCode,\n          secret\n        );\n        if (!isValidToken) {\n          throw new Error(ErrorCode.IncorrectTwoFactorCode);\n        }\n      }\n      // Check if the user you are logging into has any active teams\n      const hasActiveTeams = checkIfUserBelongsToActiveTeam(user);\n\n      // authentication success- but does it meet the minimum password requirements?\n      const validateRole = (role: UserPermissionRole) => {\n        // User's role is not \"ADMIN\"\n        if (role !== UserPermissionRole.ADMIN) return role;\n        // User's identity provider is not \"CAL\"\n        if (user.identityProvider !== IdentityProvider.CAL) return role;\n\n        if (process.env.NEXT_PUBLIC_IS_E2E) {\n          console.warn(\"E2E testing is enabled, skipping password and 2FA requirements for Admin\");\n          return role;\n        }\n\n        // User's password is valid and two-factor authentication is enabled\n        if (isPasswordValid(credentials.password, false, true) && user.twoFactorEnabled) return role;\n        // Code is running in a development environment\n        if (isENVDev) return role;\n        // By this point it is an ADMIN without valid security conditions\n        return \"INACTIVE_ADMIN\";\n      };\n\n      // Create a NextAuth compatible user object using our presenter\n      return AdapterUserPresenter.fromCalUser(user, validateRole(user.role), hasActiveTeams);\n    },\n  }),\n  ImpersonationProvider,\n];\n\nif (IS_GOOGLE_LOGIN_ENABLED) {\n  providers.push(\n    GoogleProvider({\n      clientId: GOOGLE_CLIENT_ID,\n      clientSecret: GOOGLE_CLIENT_SECRET,\n      allowDangerousEmailAccountLinking: true,\n      authorization: {\n        params: {\n          scope: [...GOOGLE_OAUTH_SCOPES, ...GOOGLE_CALENDAR_SCOPES].join(\" \"),\n          access_type: \"offline\",\n          prompt: \"consent\",\n        },\n      },\n    })\n  );\n}\n\nif (isSAMLLoginEnabled) {\n  providers.push({\n    id: \"saml\",\n    name: \"BoxyHQ\",\n    type: \"oauth\",\n    version: \"2.0\",\n    checks: [\"pkce\", \"state\"],\n    authorization: {\n      url: `${WEBAPP_URL}/api/auth/saml/authorize`,\n      params: {\n        scope: \"\",\n        response_type: \"code\",\n        provider: \"saml\",\n      },\n    },\n    token: {\n      url: `${WEBAPP_URL}/api/auth/saml/token`,\n      params: { grant_type: \"authorization_code\" },\n    },\n    userinfo: `${WEBAPP_URL}/api/auth/saml/userinfo`,\n    profile: async (profile: {\n      id?: number;\n      firstName?: string;\n      lastName?: string;\n      email?: string;\n      locale?: string;\n    }) => {\n      log.debug(\"BoxyHQ:profile\", safeStringify({ profile }));\n      const userRepo = new UserRepository(prisma);\n      const user = await userRepo.findByEmailAndIncludeProfilesAndPassword({\n        email: profile.email || \"\",\n      });\n      return {\n        id: profile.id || 0,\n        firstName: profile.firstName || \"\",\n        lastName: profile.lastName || \"\",\n        email: profile.email || \"\",\n        name: `${profile.firstName || \"\"} ${profile.lastName || \"\"}`.trim(),\n        email_verified: true,\n        locale: profile.locale,\n        ...(user ? { profile: user.allProfiles[0] } : {}),\n      };\n    },\n    options: {\n      clientId: \"dummy\",\n      clientSecret: clientSecretVerifier,\n    },\n    allowDangerousEmailAccountLinking: true,\n  });\n\n  // Idp initiated login\n  providers.push(\n    CredentialsProvider({\n      id: \"saml-idp\",\n      name: \"IdP Login\",\n      credentials: {\n        code: {},\n      },\n      async authorize(credentials) {\n        log.debug(\"CredentialsProvider:saml-idp:authorize\", safeStringify({ credentials }));\n        if (!credentials) {\n          return null;\n        }\n\n        const { code } = credentials;\n\n        if (!code) {\n          return null;\n        }\n\n        const { oauthController } = await (await import(\"@calcom/features/ee/sso/lib/jackson\")).default();\n\n        // Fetch access token\n        const { access_token } = await oauthController.token({\n          code,\n          grant_type: \"authorization_code\",\n          redirect_uri: `${process.env.NEXTAUTH_URL}",
            "output_extracted": "import { calendar_v3 } from \"@googleapis/calendar\";\nimport { waitUntil } from \"@vercel/functions\";\nimport { OAuth2Client } from \"googleapis-common\";\nimport type { AuthOptions, Account, Session, User } from \"next-auth\";\nimport type { JWT } from \"next-auth/jwt\";\nimport { encode } from \"next-auth/jwt\";\nimport type { Provider } from \"next-auth/providers\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport EmailProvider from \"next-auth/providers/email\";\nimport GoogleProvider from \"next-auth/providers/google\";\n\nimport { updateProfilePhotoGoogle } from \"@calcom/app-store/_utils/oauth/updateProfilePhotoGoogle\";\nimport GoogleCalendarService from \"@calcom/app-store/googlecalendar/lib/CalendarService\";\nimport { LicenseKeySingleton } from \"@calcom/ee/common/server/LicenseKeyService\";\nimport { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\nimport createUsersAndConnectToOrg from \"@calcom/features/ee/dsync/lib/users/createUsersAndConnectToOrg\";\nimport ImpersonationProvider from \"@calcom/features/ee/impersonation/lib/ImpersonationProvider\";\nimport { getOrgFullOrigin, subdomainSuffix } from \"@calcom/features/ee/organizations/lib/orgDomains\";\nimport { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\nimport { clientSecretVerifier, hostedCal, isSAMLLoginEnabled } from \"@calcom/features/ee/sso/lib/saml\";\nimport { ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport { isPasswordValid } from \"@calcom/lib/auth/isPasswordValid\";\nimport { checkRateLimitAndThrowError } from \"@calcom/lib/checkRateLimitAndThrowError\";\nimport {\n  GOOGLE_CALENDAR_SCOPES,\n  GOOGLE_OAUTH_SCOPES,\n  HOSTED_CAL_FEATURES,\n  IS_CALCOM,\n} from \"@calcom/lib/constants\";\nimport { ENABLE_PROFILE_SWITCHER, IS_TEAM_BILLING_ENABLED, WEBAPP_URL } from \"@calcom/lib/constants\";\nimport { symmetricDecrypt, symmetricEncrypt } from \"@calcom/lib/crypto\";\nimport { defaultCookies } from \"@calcom/lib/default-cookies\";\nimport { isENVDev } from \"@calcom/lib/env\";\nimport logger from \"@calcom/lib/logger\";\nimport { randomString } from \"@calcom/lib/random\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { hashEmail } from \"@calcom/lib/server/PiiHasher\";\nimport { DeploymentRepository } from \"@calcom/lib/server/repository/deployment\";\nimport slugify from \"@calcom/lib/slugify\";\nimport prisma from \"@calcom/prisma\";\nimport type { Membership, Team } from \"@calcom/prisma/client\";\nimport { CreationSource } from \"@calcom/prisma/enums\";\nimport { IdentityProvider, MembershipRole, UserPermissionRole } from \"@calcom/prisma/enums\";\nimport { teamMetadataSchema, userMetadata } from \"@calcom/prisma/zod-utils\";\n\nimport { getOrgUsernameFromEmail } from \"../signup/utils/getOrgUsernameFromEmail\";\nimport { ErrorCode } from \"./ErrorCode\";\nimport { dub } from \"./dub\";\nimport CalComAdapter from \"./next-auth-custom-adapter\";\nimport { verifyPassword } from \"./verifyPassword\";\n\ntype UserWithProfiles = NonNullable<\n  Awaited<ReturnType<UserRepository[\"findByEmailAndIncludeProfilesAndPassword\"]>>\n>;\n\n// This adapts our internal user model to what NextAuth expects\n// NextAuth core requires id to be a string, so we handle that here\nconst AdapterUserPresenter = {\n  fromCalUser: (\n    user: UserWithProfiles,\n    role: UserPermissionRole | \"INACTIVE_ADMIN\",\n    hasActiveTeams: boolean\n  ) => ({\n    ...user,\n    role: role as UserPermissionRole,\n    belongsToActiveTeam: hasActiveTeams,\n    profile: user.allProfiles[0],\n  }),\n};\n\n// Account presenter to handle linkAccount calls\nconst AdapterAccountPresenter = {\n  fromCalAccount: (account: Account, userId: number, providerEmail: string) => {\n    return {\n      ...account,\n      userId: String(userId), // Convert userId to string for Next Auth\n      providerEmail,\n      // Ensure these required fields are present\n      provider: account.provider,\n      providerAccountId: account.providerAccountId,\n      type: account.type,\n    };\n  },\n};\n\nconst log = logger.getSubLogger({ prefix: [\"next-auth-options\"] });\nconst GOOGLE_API_CREDENTIALS = process.env.GOOGLE_API_CREDENTIALS || \"{}\";\nconst { client_id: GOOGLE_CLIENT_ID, client_secret: GOOGLE_CLIENT_SECRET } =\n  JSON.parse(GOOGLE_API_CREDENTIALS)?.web || {};\nconst GOOGLE_LOGIN_ENABLED = process.env.GOOGLE_LOGIN_ENABLED === \"true\";\nconst IS_GOOGLE_LOGIN_ENABLED = !!(GOOGLE_CLIENT_ID && GOOGLE_CLIENT_SECRET && GOOGLE_LOGIN_ENABLED);\nconst ORGANIZATIONS_AUTOLINK =\n  process.env.ORGANIZATIONS_AUTOLINK === \"1\" || process.env.ORGANIZATIONS_AUTOLINK === \"true\";\n\nconst usernameSlug = (username: string) => `${slugify(username)}-${randomString(6).toLowerCase()}`;\nconst getDomainFromEmail = (email: string): string => email.split(\"@\")[1];\n\nconst loginWithTotp = async (email: string) =>\n  `/auth/login?totp=${encodeURIComponent(await (await import(\"./signJwt\")).default({ email }))}`;\n\ntype UserTeams = {\n  teams: (Membership & {\n    team: Pick<Team, \"metadata\">;\n  })[];\n};\n\nexport const checkIfUserBelongsToActiveTeam = <T extends UserTeams>(user: T) =>\n  user.teams.some((m: { team: { metadata: unknown } }) => {\n    if (!IS_TEAM_BILLING_ENABLED) {\n      return true;\n    }\n\n    const metadata = teamMetadataSchema.safeParse(m.team.metadata);\n\n    return metadata.success && metadata.data?.subscriptionId;\n  });\n\nconst checkIfUserShouldBelongToOrg = async (idP: IdentityProvider, email: string) => {\n  const [orgUsername, apexDomain] = email.split(\"@\");\n  if (!ORGANIZATIONS_AUTOLINK || idP !== \"GOOGLE\") return { orgUsername, orgId: undefined };\n  const existingOrg = await prisma.team.findFirst({\n    where: {\n      organizationSettings: {\n        isOrganizationVerified: true,\n        orgAutoAcceptEmail: apexDomain,\n      },\n    },\n    select: {\n      id: true,\n    },\n  });\n  return { orgUsername, orgId: existingOrg?.id };\n};\n\nconst providers: Provider[] = [\n  CredentialsProvider({\n    id: \"credentials\",\n    name: \"Cal.com\",\n    type: \"credentials\",\n    credentials: {\n      email: { label: \"Email Address\", type: \"email\", placeholder: \"john.doe@example.com\" },\n      password: { label: \"Password\", type: \"password\", placeholder: \"Your super secure password\" },\n      totpCode: { label: \"Two-factor Code\", type: \"input\", placeholder: \"Code from authenticator app\" },\n      backupCode: { label: \"Backup Code\", type: \"input\", placeholder: \"Two-factor backup code\" },\n    },\n    async authorize(credentials): Promise<User | null> {\n      log.debug(\"CredentialsProvider:credentials:authorize\", safeStringify({ credentials }));\n      if (!credentials) {\n        console.error(`For some reason credentials are missing`);\n        throw new Error(ErrorCode.InternalServerError);\n      }\n\n      const userRepo = new UserRepository(prisma);\n      const user = await userRepo.findByEmailAndIncludeProfilesAndPassword({\n        email: credentials.email,\n      });\n      // Don't leak information about it being username or password that is invalid\n      if (!user) {\n        throw new Error(ErrorCode.IncorrectEmailPassword);\n      }\n\n      // Locked users cannot login\n      if (user.locked) {\n        throw new Error(ErrorCode.UserAccountLocked);\n      }\n\n      await checkRateLimitAndThrowError({\n        identifier: hashEmail(user.email),\n      });\n\n      // Users without a password must use their identity provider (Google/SAML) to login\n      if (!user.password?.hash) {\n        throw new Error(ErrorCode.IncorrectEmailPassword);\n      }\n\n      // Always verify password for users who have one\n      const isCorrectPassword = await verifyPassword(credentials.password, user.password.hash);\n      if (!isCorrectPassword) {\n        throw new Error(ErrorCode.IncorrectEmailPassword);\n      }\n\n      if (user.twoFactorEnabled && credentials.backupCode) {\n        if (!process.env.CALENDSO_ENCRYPTION_KEY) {\n          console.error(\"Missing encryption key; cannot proceed with backup code login.\");\n          throw new Error(ErrorCode.InternalServerError);\n        }\n\n        if (!user.backupCodes) throw new Error(ErrorCode.MissingBackupCodes);\n\n        const backupCodes = JSON.parse(\n          symmetricDecrypt(user.backupCodes, process.env.CALENDSO_ENCRYPTION_KEY)\n        );\n\n        // check if user-supplied code matches one\n        const index = backupCodes.indexOf(credentials.backupCode.replaceAll(\"-\", \"\"));\n        if (index === -1) throw new Error(ErrorCode.IncorrectBackupCode);\n\n        // delete verified backup code and re-encrypt remaining\n        backupCodes[index] = null;\n        await prisma.user.update({\n          where: {\n            id: user.id,\n          },\n          data: {\n            backupCodes: symmetricEncrypt(JSON.stringify(backupCodes), process.env.CALENDSO_ENCRYPTION_KEY),\n          },\n        });\n      } else if (user.twoFactorEnabled) {\n        if (!credentials.totpCode) {\n          throw new Error(ErrorCode.SecondFactorRequired);\n        }\n\n        if (!user.twoFactorSecret) {\n          console.error(`Two factor is enabled for user ${user.id} but they have no secret`);\n          throw new Error(ErrorCode.InternalServerError);\n        }\n\n        if (!process.env.CALENDSO_ENCRYPTION_KEY) {\n          console.error(`\"Missing encryption key; cannot proceed with two factor login.\"`);\n          throw new Error(ErrorCode.InternalServerError);\n        }\n\n        const secret = symmetricDecrypt(user.twoFactorSecret, process.env.CALENDSO_ENCRYPTION_KEY);\n        if (secret.length !== 32) {\n          console.error(\n            `Two factor secret decryption failed. Expected key with length 32 but got ${secret.length}`\n          );\n          throw new Error(ErrorCode.InternalServerError);\n        }\n\n        const isValidToken = (await import(\"@calcom/lib/totp\")).totpAuthenticatorCheck(\n          credentials.totpCode,\n          secret\n        );\n        if (!isValidToken) {\n          throw new Error(ErrorCode.IncorrectTwoFactorCode);\n        }\n      }\n      // Check if the user you are logging into has any active teams\n      const hasActiveTeams = checkIfUserBelongsToActiveTeam(user);\n\n      // authentication success- but does it meet the minimum password requirements?\n      const validateRole = (role: UserPermissionRole) => {\n        // User's role is not \"ADMIN\"\n        if (role !== UserPermissionRole.ADMIN) return role;\n        // User's identity provider is not \"CAL\"\n        if (user.identityProvider !== IdentityProvider.CAL) return role;\n\n        if (process.env.NEXT_PUBLIC_IS_E2E) {\n          console.warn(\"E2E testing is enabled, skipping password and 2FA requirements for Admin\");\n          return role;\n        }\n\n        // User's password is valid and two-factor authentication is enabled\n        if (isPasswordValid(credentials.password, false, true) && user.twoFactorEnabled) return role;\n        // Code is running in a development environment\n        if (isENVDev) return role;\n        // By this point it is an ADMIN without valid security conditions\n        return \"INACTIVE_ADMIN\";\n      };\n\n      // Create a NextAuth compatible user object using our presenter\n      return AdapterUserPresenter.fromCalUser(user, validateRole(user.role), hasActiveTeams);\n    },\n  }),\n  ImpersonationProvider,\n];\n\nif (IS_GOOGLE_LOGIN_ENABLED) {\n  providers.push(\n    GoogleProvider({\n      clientId: GOOGLE_CLIENT_ID,\n      clientSecret: GOOGLE_CLIENT_SECRET,\n      allowDangerousEmailAccountLinking: true,\n      authorization: {\n        params: {\n          scope: [...GOOGLE_OAUTH_SCOPES, ...GOOGLE_CALENDAR_SCOPES].join(\" \"),\n          access_type: \"offline\",\n          prompt: \"consent\",\n        },\n      },\n    })\n  );\n}\n\nif (isSAMLLoginEnabled) {\n  providers.push({\n    id: \"saml\",\n    name: \"BoxyHQ\",\n    type: \"oauth\",\n    version: \"2.0\",\n    checks: [\"pkce\", \"state\"],\n    authorization: {\n      url: `${WEBAPP_URL}/api/auth/saml/authorize`,\n      params: {\n        scope: \"\",\n        response_type: \"code\",\n        provider: \"saml\",\n      },\n    },\n    token: {\n      url: `${WEBAPP_URL}/api/auth/saml/token`,\n      params: { grant_type: \"authorization_code\" },\n    },\n    userinfo: `${WEBAPP_URL}/api/auth/saml/userinfo`,\n    profile: async (profile: {\n      id?: number;\n      firstName?: string;\n      lastName?: string;\n      email?: string;\n      locale?: string;\n    }) => {\n      log.debug(\"BoxyHQ:profile\", safeStringify({ profile }));\n      const userRepo = new UserRepository(prisma);\n      const user = await userRepo.findByEmailAndIncludeProfilesAndPassword({\n        email: profile.email || \"\",\n      });\n      return {\n        id: profile.id || 0,\n        firstName: profile.firstName || \"\",\n        lastName: profile.lastName || \"\",\n        email: profile.email || \"\",\n        name: `${profile.firstName || \"\"} ${profile.lastName || \"\"}`.trim(),\n        email_verified: true,\n        locale: profile.locale,\n        ...(user ? { profile: user.allProfiles[0] } : {}),\n      };\n    },\n    options: {\n      clientId: \"dummy\",\n      clientSecret: clientSecretVerifier,\n    },\n    allowDangerousEmailAccountLinking: true,\n  });\n\n  // Idp initiated login\n  providers.push(\n    CredentialsProvider({\n      id: \"saml-idp\",\n      name: \"IdP Login\",\n      credentials: {\n        code: {},\n      },\n      async authorize(credentials) {\n        log.debug(\"CredentialsProvider:saml-idp:authorize\", safeStringify({ credentials }));\n        if (!credentials) {\n          return null;\n        }\n\n        const { code } = credentials;\n\n        if (!code) {\n          return null;\n        }\n\n        const { oauthController } = await (await import(\"@calcom/features/ee/sso/lib/jackson\")).default();\n\n        // Fetch access token\n        const { access_token } = await oauthController.token({\n          code,\n          grant_type: \"authorization_code\",\n          redirect_uri: `${process.env.NEXTAUTH_URL}",
            "cost": 0.16517
        },
        "calcom__cal.com.main/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts": {
            "output": "import { describe, expect, it } from \"vitest\";\n\nimport { getOrgUsernameFromEmail, deriveNameFromOrgUsername } from \"./getOrgUsernameFromEmail\";\n\ndescribe(\"getOrgUsernameFromEmail\", () => {\n  it(\"should generate username with only email user part when domain matches autoAcceptEmailDomain\", () => {\n    const email = \"john.doe@example.com\";\n    const autoAcceptEmailDomain = \"example.com\";\n    const result = getOrgUsernameFromEmail(email, autoAcceptEmailDomain);\n    expect(result).toBe(\"john.doe\");\n  });\n\n  it(\"should generate username with email user and domain when domain doesn't match autoAcceptEmailDomain\", () => {\n    const email = \"john.doe@example.com\";\n    const autoAcceptEmailDomain = \"different.com\";\n    const result = getOrgUsernameFromEmail(email, autoAcceptEmailDomain);\n    expect(result).toBe(\"john.doe-example\");\n  });\n});\n\ndescribe(\"deriveNameFromOrgUsername\", () => {\n  it(\"should convert hyphenated username to capitalized words\", () => {\n    const username = \"john-doe-example\";\n    const result = deriveNameFromOrgUsername({ username });\n    expect(result).toBe(\"John Doe Example\");\n  });\n});",
            "output_extracted": "import { describe, expect, it } from \"vitest\";\n\nimport { getOrgUsernameFromEmail, deriveNameFromOrgUsername } from \"./getOrgUsernameFromEmail\";\n\ndescribe(\"getOrgUsernameFromEmail\", () => {\n  it(\"should generate username with only email user part when domain matches autoAcceptEmailDomain\", () => {\n    const email = \"john.doe@example.com\";\n    const autoAcceptEmailDomain = \"example.com\";\n    const result = getOrgUsernameFromEmail(email, autoAcceptEmailDomain);\n    expect(result).toBe(\"john.doe\");\n  });\n\n  it(\"should generate username with email user and domain when domain doesn't match autoAcceptEmailDomain\", () => {\n    const email = \"john.doe@example.com\";\n    const autoAcceptEmailDomain = \"different.com\";\n    const result = getOrgUsernameFromEmail(email, autoAcceptEmailDomain);\n    expect(result).toBe(\"john.doe-example\");\n  });\n});\n\ndescribe(\"deriveNameFromOrgUsername\", () => {\n  it(\"should convert hyphenated username to capitalized words\", () => {\n    const username = \"john-doe-example\";\n    const result = deriveNameFromOrgUsername({ username });\n    expect(result).toBe(\"John Doe Example\");\n  });\n});",
            "cost": 0.017505
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25435",
        "repo": "calcom/cal.com",
        "base_commit": "a23400777a4696afea85e2e07c090665248afbfa",
        "head_commit": "a0878dfeff04ddb9292a9fe0f4d706b3aaaa0593",
        "title": "fix: signup username collision",
        "merged_at": "2025-11-27T15:41:38Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25435",
        "test_files": [
            "packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts"
        ],
        "code_files": [
            "packages/features/auth/lib/next-auth-options.ts"
        ],
        "total_changes": 28,
        "num_files": 2,
        "pull_number": 25435,
        "patch": "diff --git a/packages/features/auth/lib/next-auth-options.ts b/packages/features/auth/lib/next-auth-options.ts\nindex bab3b102745350..fedc3e958a3b9a 100644\n--- a/packages/features/auth/lib/next-auth-options.ts\n+++ b/packages/features/auth/lib/next-auth-options.ts\n@@ -15,8 +15,8 @@ import { LicenseKeySingleton } from \"@calcom/ee/common/server/LicenseKeyService\"\n import { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\n import createUsersAndConnectToOrg from \"@calcom/features/ee/dsync/lib/users/createUsersAndConnectToOrg\";\n import ImpersonationProvider from \"@calcom/features/ee/impersonation/lib/ImpersonationProvider\";\n-import { getOrgFullOrigin, subdomainSuffix } from \"@calcom/features/ee/organizations/lib/orgDomains\";\n import { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\n+import { getOrgFullOrigin, subdomainSuffix } from \"@calcom/features/ee/organizations/lib/orgDomains\";\n import { clientSecretVerifier, hostedCal, isSAMLLoginEnabled } from \"@calcom/features/ee/sso/lib/saml\";\n import { ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n@@ -962,7 +962,7 @@ export const getOptions = ({\n                 email: user.email,\n                 // Slugify the incoming name and append a few random characters to\n                 // prevent conflicts for users with the same name.\n-                username: getOrgUsernameFromEmail(user.name, getDomainFromEmail(user.email)),\n+                username: getOrgUsernameFromEmail(user.email, getDomainFromEmail(user.email)),\n                 emailVerified: new Date(Date.now()),\n                 name: user.name,\n                 identityProvider: idP,\ndiff --git a/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts b/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts\nindex 62aa8aed79b13b..d5d1cdb1af5088 100644\n--- a/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts\n+++ b/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts\n@@ -16,6 +16,30 @@ describe(\"getOrgUsernameFromEmail\", () => {\n     const result = getOrgUsernameFromEmail(email, autoAcceptEmailDomain);\n     expect(result).toBe(\"john.doe-example\");\n   });\n+\n+  it(\"should generate unique usernames for different emails even with same name\", () => {\n+    const email1 = \"alice@acme.com\";\n+    const email2 = \"alice+work@corp.com\";\n+\n+    const username1 = getOrgUsernameFromEmail(email1, null);\n+    const username2 = getOrgUsernameFromEmail(email2, null);\n+\n+    expect(username1).toBe(\"alice-acme\");\n+    expect(username2).toBe(\"alice-work-corp\");\n+    expect(username1).not.toBe(username2);\n+  });\n+\n+  it(\"should handle email with plus sign correctly\", () => {\n+    const email = \"bob+test@example.com\";\n+    const result = getOrgUsernameFromEmail(email, \"example.com\");\n+    expect(result).toBe(\"bob-test\");\n+  });\n+\n+  it(\"should handle null autoAcceptEmailDomain\", () => {\n+    const email = \"user@company.com\";\n+    const result = getOrgUsernameFromEmail(email, null);\n+    expect(result).toBe(\"user-company\");\n+  });\n });\n \n describe(\"deriveNameFromOrgUsername\", () => {\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}