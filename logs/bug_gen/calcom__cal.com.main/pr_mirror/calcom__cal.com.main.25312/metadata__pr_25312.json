{
    "cost": 0.32068,
    "rewrites": {
        "calcom__cal.com.main/packages/features/ee/billing/credit-service.ts": {
            "output": "import type { TFunction } from \"i18next\";\n\nimport dayjs from \"@calcom/dayjs\";\nimport { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\nimport { MembershipRepository } from \"@calcom/features/membership/repositories/MembershipRepository\";\nimport { IS_SMS_CREDITS_ENABLED } from \"@calcom/lib/constants\";\nimport getOrgIdFromMemberOrTeamId from \"@calcom/lib/getOrgIdFromMemberOrTeamId\";\nimport logger from \"@calcom/lib/logger\";\nimport { CreditsRepository } from \"@calcom/lib/server/repository/credits\";\nimport { prisma, type PrismaTransaction } from \"@calcom/prisma\";\nimport { CreditUsageType, CreditType } from \"@calcom/prisma/enums\";\n\nimport { getBillingProviderService, getTeamBillingServiceFactory } from \"./di/containers/Billing\";\nimport { SubscriptionStatus } from \"./repository/billing/IBillingRepository\";\n\nconst log = logger.getSubLogger({ prefix: [\"[CreditService]\"] });\n\ntype LowCreditBalanceResultBase = {\n  team?: {\n    id: number;\n    name: string;\n    adminAndOwners: {\n      id: number;\n      name: string | null;\n      email: string;\n      t: TFunction;\n    }[];\n  };\n  user?: {\n    id: number;\n    name: string | null;\n    email: string;\n    t: TFunction;\n  };\n  creditFor?: CreditUsageType;\n};\n\ntype LowCreditBalanceLimitReachedResult = LowCreditBalanceResultBase & {\n  type: \"LIMIT_REACHED\";\n  teamId?: number | null;\n  userId?: number | null;\n};\n\ntype LowCreditBalanceWarningResult = LowCreditBalanceResultBase & {\n  type: \"WARNING\";\n  balance: number;\n};\n\ntype LowCreditBalanceResult = LowCreditBalanceLimitReachedResult | LowCreditBalanceWarningResult | null;\n\nexport type CreditCheckFn = CreditService[\"hasAvailableCredits\"];\n\nexport class CreditService {\n  async chargeCredits({\n    userId,\n    teamId,\n    credits,\n    bookingUid,\n    smsSid,\n    smsSegments,\n    phoneNumber,\n    email,\n    callDuration,\n    creditFor,\n    externalRef,\n  }: {\n    userId?: number;\n    teamId?: number;\n    credits: number | null;\n    bookingUid?: string;\n    smsSid?: string;\n    smsSegments?: number;\n    phoneNumber?: string;\n    email?: string;\n    callDuration?: number;\n    creditFor?: CreditUsageType;\n    externalRef?: string;\n  }) {\n    if (externalRef) {\n      const existingLog = await CreditsRepository.findCreditExpenseLogByExternalRef(externalRef);\n      if (existingLog) {\n        log.warn(\"Credit expense log already exists\", { externalRef, existingLog });\n        return {\n          bookingUid: existingLog.bookingUid,\n          duplicate: true,\n          userId,\n          teamId,\n        };\n      }\n    }\n    return await prisma\n      .$transaction(async (tx) => {\n        let teamIdToCharge = credits === 0 && teamId ? teamId : undefined;\n        let creditType: CreditType = CreditType.ADDITIONAL;\n        let remainingCredits;\n        let userIdToCharge;\n        if (!teamIdToCharge) {\n          const result = await this._getUserOrTeamToCharge({\n            credits: credits ?? 1, // if we don't have exact credits, we check for at east 1 credit available\n            userId,\n            teamId,\n            tx,\n          });\n          teamIdToCharge = result?.teamId;\n          userIdToCharge = result?.userId;\n          creditType = result?.creditType ?? creditType;\n          remainingCredits = result?.remainingCredits;\n        }\n\n        if (!teamIdToCharge && !userIdToCharge) {\n          log.error(\"No team or user found to charge. No credit expense log created\");\n          return null;\n        }\n\n        await this._createExpenseLog({\n          bookingUid,\n          smsSid,\n          teamId: teamIdToCharge,\n          userId: userIdToCharge,\n          credits,\n          creditType,\n          smsSegments,\n          phoneNumber,\n          email,\n          callDuration,\n          creditFor,\n          tx,\n          externalRef,\n        });\n\n        let lowCreditBalanceResult = null;\n        if (credits) {\n          lowCreditBalanceResult = await this._handleLowCreditBalance({\n            teamId: teamIdToCharge,\n            userId: userIdToCharge,\n            remainingCredits: remainingCredits ?? 0,\n            creditFor,\n            tx,\n          });\n        }\n\n        return {\n          teamId: teamIdToCharge,\n          userId: userIdToCharge,\n          lowCreditBalanceResult,\n        };\n      })\n      .then(async (result) => {\n        if (result?.lowCreditBalanceResult) {\n          // send emails after transaction is successfully committed\n          await this._handleLowCreditBalanceResult(result.lowCreditBalanceResult);\n        }\n        return {\n          teamId: result?.teamId,\n          userId: result?.userId,\n        };\n      });\n  }\n\n  /*\n    also returns true if team has no available credits but limitReachedAt is not yet set\n  */\n  async hasAvailableCredits({\n    userId,\n    teamId,\n  }: {\n    userId?: number | null;\n    teamId?: number | null;\n  }): Promise<boolean> {\n    return await prisma.$transaction(async (tx) => {\n      if (!IS_SMS_CREDITS_ENABLED) return true;\n\n      if (teamId) {\n        // Check if this team belongs to an organization or is itself an organization\n        const orgId = await getOrgIdFromMemberOrTeamId({ teamId }, tx);\n\n        // Use organization credits if team belongs to org, otherwise use team's own credits\n        const teamIdToCheck = orgId ?? teamId;\n\n        const creditBalance = await CreditsRepository.findCreditBalance({ teamId: teamIdToCheck }, tx);\n\n        const limitReached =\n          creditBalance?.limitReachedAt &&\n          dayjs(creditBalance.limitReachedAt).isAfter(dayjs().startOf(\"month\"));\n\n        if (!limitReached) return true;\n\n        // check if team is still out of credits\n        const teamCredits = await this._getAllCreditsForTeam({ teamId: teamIdToCheck, tx });\n        const availableCredits = teamCredits.totalRemainingMonthlyCredits + teamCredits.additionalCredits;\n\n        if (availableCredits > 0) {\n          await CreditsRepository.updateCreditBalance(\n            {\n              teamId: teamIdToCheck,\n              data: {\n                limitReachedAt: null,\n                warningSentAt: null,\n              },\n            },\n            tx\n          );\n          return true;\n        }\n        // limitReachedAt is set and still no available credits\n        return false;\n      }\n\n      if (userId) {\n        const teamWithAvailableCredits = await this._getTeamWithAvailableCredits({ userId, tx });\n\n        if (teamWithAvailableCredits && !teamWithAvailableCredits.limitReached) return true;\n\n        const userCredits = await this._getAllCredits({ userId, tx });\n\n        return userCredits.additionalCredits > 0;\n      }\n\n      return false;\n    });\n  }\n\n  async getTeamWithAvailableCredits(userId: number) {\n    return prisma.$transaction(async (tx) => {\n      return this._getTeamWithAvailableCredits({ userId, tx });\n    });\n  }\n\n  /**\n   * Separates memberships into organization and team memberships.\n   * Organizations take precedence - if user belongs to any organization,\n   * only organization memberships are returned.\n   *\n   * @param memberships - User's accepted team memberships\n   * @param teams - Team data including isOrganization and parentId\n   * @returns Memberships to check (org memberships if any exist, otherwise team memberships)\n   */\n  private static filterMembershipsForCreditCheck<T extends { teamId: number }>(\n    memberships: T[],\n    teams: Array<{ id: number; isOrganization: boolean; parentId: number | null }>\n  ): T[] {\n    const teamMap = new Map(teams.map((t) => [t.id, t]));\n\n    const orgMemberships: T[] = [];\n    const teamMemberships: T[] = [];\n\n    for (const membership of memberships) {\n      const team = teamMap.get(membership.teamId);\n      if (team?.isOrganization && !team.parentId) {\n        orgMemberships.push(membership);\n      } else {\n        teamMemberships.push(membership);\n      }\n    }\n\n    // If user belongs to any organization, ONLY check organization credits\n    return orgMemberships.length > 0 ? orgMemberships : teamMemberships;\n  }\n\n  /*\n    If user has memberships, it always returns a team, even if all have limit reached. In that case, limitReached: true is returned\n    If user belongs to any organization, ONLY organization credits are checked (team memberships are ignored)\n    If user does not belong to an organization, team credits are checked\n  */\n  protected async _getTeamWithAvailableCredits({ userId, tx }: { userId: number; tx: PrismaTransaction }) {\n    const memberships = await MembershipRepository.findAllAcceptedPublishedTeamMemberships(userId, tx);\n\n    if (!memberships || memberships.length === 0) {\n      return null;\n    }\n\n    const teamRepository = new TeamRepository(prisma);\n    const teams = await teamRepository.findTeamsForCreditCheck({\n      teamIds: memberships.map((m) => m.teamId),\n    });\n\n    const membershipsToCheck = CreditService.filterMembershipsForCreditCheck(memberships, teams);\n\n    for (const membership of membershipsToCheck) {\n      const creditBalance = await CreditsRepository.findCreditBalance({ teamId: membership.teamId }, tx);\n      const allCredits = await this._getAllCreditsForTeam({ teamId: membership.teamId, tx });\n\n      const limitReached =\n        creditBalance?.limitReachedAt &&\n        dayjs(creditBalance.limitReachedAt).isAfter(dayjs().startOf(\"month\"));\n\n      const availableCredits = allCredits.totalRemainingMonthlyCredits + allCredits.additionalCredits;\n\n      if (!limitReached || availableCredits > 0) {\n        if (limitReached) {\n          await CreditsRepository.updateCreditBalance(\n            {\n              teamId: membership.teamId,\n              data: {\n                limitReachedAt: null,\n                warningSentAt: null,\n              },\n            },\n            tx\n          );\n        }\n        return {\n          teamId: membership.teamId,\n          availableCredits,\n          creditType:\n            allCredits.totalRemainingMonthlyCredits > 0 ? CreditType.MONTHLY : CreditType.ADDITIONAL,\n        };\n      }\n    }\n\n    return {\n      teamId: membershipsToCheck[0].teamId,\n      availableCredits: 0,\n      creditType: CreditType.ADDITIONAL,\n      limitReached: true,\n    };\n  }\n\n  /*\n    always returns a team, even if all teams are out of credits\n  */\n  async getUserOrTeamToCharge({\n    credits,\n    userId,\n    teamId,\n  }: {\n    credits: number;\n    userId?: number | null;\n    teamId?: number | null;\n  }) {\n    return prisma.$transaction(async (tx) => {\n      return this._getUserOrTeamToCharge({ credits, userId, teamId, tx });\n    });\n  }\n\n  protected async _getUserOrTeamToCharge({\n    credits,\n    userId,\n    teamId,\n    tx,\n  }: {\n    credits: number;\n    userId?: number | null;\n    teamId?: number | null;\n    tx: PrismaTransaction;\n  }) {\n    if (teamId) {\n      const teamCredits = await this._getAllCreditsForTeam({ teamId, tx });\n      const remaningMonthlyCredits =\n        teamCredits.totalRemainingMonthlyCredits > 0 ? teamCredits.totalRemainingMonthlyCredits : 0;\n      return {\n        teamId,\n        remainingCredits: remaningMonthlyCredits + teamCredits.additionalCredits - credits,\n        creditType: remaningMonthlyCredits > 0 ? CreditType.MONTHLY : CreditType.ADDITIONAL,\n      };\n    }\n\n    if (userId) {\n      const team = await this._getTeamWithAvailableCredits({ userId, tx });\n      if (team) {\n        return { ...team, remainingCredits: team.availableCredits - credits };\n      }\n\n      const userCredits = await this._getAllCredits({ userId, tx });\n\n      return {\n        userId,\n        remainingCredits: userCredits.additionalCredits - credits,\n        creditType: CreditType.ADDITIONAL,\n      };\n    }\n    return null;\n  }\n\n  protected async _createExpenseLog(props: {\n    bookingUid?: string;\n    smsSid?: string;\n    teamId?: number;\n    userId?: number;\n    credits: number | null;\n    creditType: CreditType;\n    smsSegments?: number;\n    phoneNumber?: string;\n    email?: string;\n    callDuration?: number;\n    creditFor?: CreditUsageType;\n    tx: PrismaTransaction;\n    externalRef?: string;\n  }) {\n    const {\n      credits,\n      creditType,\n      bookingUid,\n      smsSid,\n      teamId,\n      userId,\n      smsSegments,\n      callDuration,\n      creditFor,\n      phoneNumber,\n      email,\n      tx,\n    } = props;\n    let creditBalance: { id: string; additionalCredits: number } | null | undefined =\n      await CreditsRepository.findCreditBalance({ teamId, userId }, tx);\n\n    if (!creditBalance) {\n      creditBalance = await CreditsRepository.createCreditBalance(\n        {\n          teamId,\n          userId,\n        },\n        tx\n      );\n    }\n\n    if (credits && creditType === CreditType.ADDITIONAL) {\n      const decrementValue =\n        credits <= creditBalance.additionalCredits ? credits : creditBalance.additionalCredits;\n      await CreditsRepository.updateCreditBalance(\n        {\n          id: creditBalance.id,\n          data: {\n            additionalCredits: {\n              decrement: decrementValue,\n            },\n          },\n        },\n        tx\n      );\n    }\n\n    if (creditBalance) {\n      // also track logs with undefined credits (will be set on the cron job)\n      await CreditsRepository.createCreditExpenseLog(\n        {\n          creditBalanceId: creditBalance.id,\n          credits,\n          creditType,\n          creditFor,\n          date: new Date(),\n          bookingUid,\n          smsSid,\n          smsSegments,\n          phoneNumber,\n          email,\n          callDuration,\n          externalRef: props.externalRef,\n        },\n        tx\n      );\n    }\n  }\n\n  /*\n  Called when we know the exact amount of credits to be charged:\n  - Sets `limitReachedAt` and `warningSentAt`\n  - Sends warning email if balance is low\n  - Sends limit reached email\n  - cancels all already scheduled SMS (from the next two hours)\n  */\n  protected async _handleLowCreditBalance({\n    teamId,\n    userId,\n    remainingCredits,\n    creditFor,\n    tx,\n  }: {\n    teamId?: number | null;\n    userId?: number | null;\n    remainingCredits: number;\n    creditFor?: CreditUsageType;\n    tx: PrismaTransaction",
            "output_extracted": "import type { TFunction } from \"i18next\";\n\nimport dayjs from \"@calcom/dayjs\";\nimport { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\nimport { MembershipRepository } from \"@calcom/features/membership/repositories/MembershipRepository\";\nimport { IS_SMS_CREDITS_ENABLED } from \"@calcom/lib/constants\";\nimport getOrgIdFromMemberOrTeamId from \"@calcom/lib/getOrgIdFromMemberOrTeamId\";\nimport logger from \"@calcom/lib/logger\";\nimport { CreditsRepository } from \"@calcom/lib/server/repository/credits\";\nimport { prisma, type PrismaTransaction } from \"@calcom/prisma\";\nimport { CreditUsageType, CreditType } from \"@calcom/prisma/enums\";\n\nimport { getBillingProviderService, getTeamBillingServiceFactory } from \"./di/containers/Billing\";\nimport { SubscriptionStatus } from \"./repository/billing/IBillingRepository\";\n\nconst log = logger.getSubLogger({ prefix: [\"[CreditService]\"] });\n\ntype LowCreditBalanceResultBase = {\n  team?: {\n    id: number;\n    name: string;\n    adminAndOwners: {\n      id: number;\n      name: string | null;\n      email: string;\n      t: TFunction;\n    }[];\n  };\n  user?: {\n    id: number;\n    name: string | null;\n    email: string;\n    t: TFunction;\n  };\n  creditFor?: CreditUsageType;\n};\n\ntype LowCreditBalanceLimitReachedResult = LowCreditBalanceResultBase & {\n  type: \"LIMIT_REACHED\";\n  teamId?: number | null;\n  userId?: number | null;\n};\n\ntype LowCreditBalanceWarningResult = LowCreditBalanceResultBase & {\n  type: \"WARNING\";\n  balance: number;\n};\n\ntype LowCreditBalanceResult = LowCreditBalanceLimitReachedResult | LowCreditBalanceWarningResult | null;\n\nexport type CreditCheckFn = CreditService[\"hasAvailableCredits\"];\n\nexport class CreditService {\n  async chargeCredits({\n    userId,\n    teamId,\n    credits,\n    bookingUid,\n    smsSid,\n    smsSegments,\n    phoneNumber,\n    email,\n    callDuration,\n    creditFor,\n    externalRef,\n  }: {\n    userId?: number;\n    teamId?: number;\n    credits: number | null;\n    bookingUid?: string;\n    smsSid?: string;\n    smsSegments?: number;\n    phoneNumber?: string;\n    email?: string;\n    callDuration?: number;\n    creditFor?: CreditUsageType;\n    externalRef?: string;\n  }) {\n    if (externalRef) {\n      const existingLog = await CreditsRepository.findCreditExpenseLogByExternalRef(externalRef);\n      if (existingLog) {\n        log.warn(\"Credit expense log already exists\", { externalRef, existingLog });\n        return {\n          bookingUid: existingLog.bookingUid,\n          duplicate: true,\n          userId,\n          teamId,\n        };\n      }\n    }\n    return await prisma\n      .$transaction(async (tx) => {\n        let teamIdToCharge = credits === 0 && teamId ? teamId : undefined;\n        let creditType: CreditType = CreditType.ADDITIONAL;\n        let remainingCredits;\n        let userIdToCharge;\n        if (!teamIdToCharge) {\n          const result = await this._getUserOrTeamToCharge({\n            credits: credits ?? 1, // if we don't have exact credits, we check for at east 1 credit available\n            userId,\n            teamId,\n            tx,\n          });\n          teamIdToCharge = result?.teamId;\n          userIdToCharge = result?.userId;\n          creditType = result?.creditType ?? creditType;\n          remainingCredits = result?.remainingCredits;\n        }\n\n        if (!teamIdToCharge && !userIdToCharge) {\n          log.error(\"No team or user found to charge. No credit expense log created\");\n          return null;\n        }\n\n        await this._createExpenseLog({\n          bookingUid,\n          smsSid,\n          teamId: teamIdToCharge,\n          userId: userIdToCharge,\n          credits,\n          creditType,\n          smsSegments,\n          phoneNumber,\n          email,\n          callDuration,\n          creditFor,\n          tx,\n          externalRef,\n        });\n\n        let lowCreditBalanceResult = null;\n        if (credits) {\n          lowCreditBalanceResult = await this._handleLowCreditBalance({\n            teamId: teamIdToCharge,\n            userId: userIdToCharge,\n            remainingCredits: remainingCredits ?? 0,\n            creditFor,\n            tx,\n          });\n        }\n\n        return {\n          teamId: teamIdToCharge,\n          userId: userIdToCharge,\n          lowCreditBalanceResult,\n        };\n      })\n      .then(async (result) => {\n        if (result?.lowCreditBalanceResult) {\n          // send emails after transaction is successfully committed\n          await this._handleLowCreditBalanceResult(result.lowCreditBalanceResult);\n        }\n        return {\n          teamId: result?.teamId,\n          userId: result?.userId,\n        };\n      });\n  }\n\n  /*\n    also returns true if team has no available credits but limitReachedAt is not yet set\n  */\n  async hasAvailableCredits({\n    userId,\n    teamId,\n  }: {\n    userId?: number | null;\n    teamId?: number | null;\n  }): Promise<boolean> {\n    return await prisma.$transaction(async (tx) => {\n      if (!IS_SMS_CREDITS_ENABLED) return true;\n\n      if (teamId) {\n        // Check if this team belongs to an organization or is itself an organization\n        const orgId = await getOrgIdFromMemberOrTeamId({ teamId }, tx);\n\n        // Use organization credits if team belongs to org, otherwise use team's own credits\n        const teamIdToCheck = orgId ?? teamId;\n\n        const creditBalance = await CreditsRepository.findCreditBalance({ teamId: teamIdToCheck }, tx);\n\n        const limitReached =\n          creditBalance?.limitReachedAt &&\n          dayjs(creditBalance.limitReachedAt).isAfter(dayjs().startOf(\"month\"));\n\n        if (!limitReached) return true;\n\n        // check if team is still out of credits\n        const teamCredits = await this._getAllCreditsForTeam({ teamId: teamIdToCheck, tx });\n        const availableCredits = teamCredits.totalRemainingMonthlyCredits + teamCredits.additionalCredits;\n\n        if (availableCredits > 0) {\n          await CreditsRepository.updateCreditBalance(\n            {\n              teamId: teamIdToCheck,\n              data: {\n                limitReachedAt: null,\n                warningSentAt: null,\n              },\n            },\n            tx\n          );\n          return true;\n        }\n        // limitReachedAt is set and still no available credits\n        return false;\n      }\n\n      if (userId) {\n        const teamWithAvailableCredits = await this._getTeamWithAvailableCredits({ userId, tx });\n\n        if (teamWithAvailableCredits && !teamWithAvailableCredits.limitReached) return true;\n\n        const userCredits = await this._getAllCredits({ userId, tx });\n\n        return userCredits.additionalCredits > 0;\n      }\n\n      return false;\n    });\n  }\n\n  async getTeamWithAvailableCredits(userId: number) {\n    return prisma.$transaction(async (tx) => {\n      return this._getTeamWithAvailableCredits({ userId, tx });\n    });\n  }\n\n  /**\n   * Separates memberships into organization and team memberships.\n   * Organizations take precedence - if user belongs to any organization,\n   * only organization memberships are returned.\n   *\n   * @param memberships - User's accepted team memberships\n   * @param teams - Team data including isOrganization and parentId\n   * @returns Memberships to check (org memberships if any exist, otherwise team memberships)\n   */\n  private static filterMembershipsForCreditCheck<T extends { teamId: number }>(\n    memberships: T[],\n    teams: Array<{ id: number; isOrganization: boolean; parentId: number | null }>\n  ): T[] {\n    const teamMap = new Map(teams.map((t) => [t.id, t]));\n\n    const orgMemberships: T[] = [];\n    const teamMemberships: T[] = [];\n\n    for (const membership of memberships) {\n      const team = teamMap.get(membership.teamId);\n      if (team?.isOrganization && !team.parentId) {\n        orgMemberships.push(membership);\n      } else {\n        teamMemberships.push(membership);\n      }\n    }\n\n    // If user belongs to any organization, ONLY check organization credits\n    return orgMemberships.length > 0 ? orgMemberships : teamMemberships;\n  }\n\n  /*\n    If user has memberships, it always returns a team, even if all have limit reached. In that case, limitReached: true is returned\n    If user belongs to any organization, ONLY organization credits are checked (team memberships are ignored)\n    If user does not belong to an organization, team credits are checked\n  */\n  protected async _getTeamWithAvailableCredits({ userId, tx }: { userId: number; tx: PrismaTransaction }) {\n    const memberships = await MembershipRepository.findAllAcceptedPublishedTeamMemberships(userId, tx);\n\n    if (!memberships || memberships.length === 0) {\n      return null;\n    }\n\n    const teamRepository = new TeamRepository(prisma);\n    const teams = await teamRepository.findTeamsForCreditCheck({\n      teamIds: memberships.map((m) => m.teamId),\n    });\n\n    const membershipsToCheck = CreditService.filterMembershipsForCreditCheck(memberships, teams);\n\n    for (const membership of membershipsToCheck) {\n      const creditBalance = await CreditsRepository.findCreditBalance({ teamId: membership.teamId }, tx);\n      const allCredits = await this._getAllCreditsForTeam({ teamId: membership.teamId, tx });\n\n      const limitReached =\n        creditBalance?.limitReachedAt &&\n        dayjs(creditBalance.limitReachedAt).isAfter(dayjs().startOf(\"month\"));\n\n      const availableCredits = allCredits.totalRemainingMonthlyCredits + allCredits.additionalCredits;\n\n      if (!limitReached || availableCredits > 0) {\n        if (limitReached) {\n          await CreditsRepository.updateCreditBalance(\n            {\n              teamId: membership.teamId,\n              data: {\n                limitReachedAt: null,\n                warningSentAt: null,\n              },\n            },\n            tx\n          );\n        }\n        return {\n          teamId: membership.teamId,\n          availableCredits,\n          creditType:\n            allCredits.totalRemainingMonthlyCredits > 0 ? CreditType.MONTHLY : CreditType.ADDITIONAL,\n        };\n      }\n    }\n\n    return {\n      teamId: membershipsToCheck[0].teamId,\n      availableCredits: 0,\n      creditType: CreditType.ADDITIONAL,\n      limitReached: true,\n    };\n  }\n\n  /*\n    always returns a team, even if all teams are out of credits\n  */\n  async getUserOrTeamToCharge({\n    credits,\n    userId,\n    teamId,\n  }: {\n    credits: number;\n    userId?: number | null;\n    teamId?: number | null;\n  }) {\n    return prisma.$transaction(async (tx) => {\n      return this._getUserOrTeamToCharge({ credits, userId, teamId, tx });\n    });\n  }\n\n  protected async _getUserOrTeamToCharge({\n    credits,\n    userId,\n    teamId,\n    tx,\n  }: {\n    credits: number;\n    userId?: number | null;\n    teamId?: number | null;\n    tx: PrismaTransaction;\n  }) {\n    if (teamId) {\n      const teamCredits = await this._getAllCreditsForTeam({ teamId, tx });\n      const remaningMonthlyCredits =\n        teamCredits.totalRemainingMonthlyCredits > 0 ? teamCredits.totalRemainingMonthlyCredits : 0;\n      return {\n        teamId,\n        remainingCredits: remaningMonthlyCredits + teamCredits.additionalCredits - credits,\n        creditType: remaningMonthlyCredits > 0 ? CreditType.MONTHLY : CreditType.ADDITIONAL,\n      };\n    }\n\n    if (userId) {\n      const team = await this._getTeamWithAvailableCredits({ userId, tx });\n      if (team) {\n        return { ...team, remainingCredits: team.availableCredits - credits };\n      }\n\n      const userCredits = await this._getAllCredits({ userId, tx });\n\n      return {\n        userId,\n        remainingCredits: userCredits.additionalCredits - credits,\n        creditType: CreditType.ADDITIONAL,\n      };\n    }\n    return null;\n  }\n\n  protected async _createExpenseLog(props: {\n    bookingUid?: string;\n    smsSid?: string;\n    teamId?: number;\n    userId?: number;\n    credits: number | null;\n    creditType: CreditType;\n    smsSegments?: number;\n    phoneNumber?: string;\n    email?: string;\n    callDuration?: number;\n    creditFor?: CreditUsageType;\n    tx: PrismaTransaction;\n    externalRef?: string;\n  }) {\n    const {\n      credits,\n      creditType,\n      bookingUid,\n      smsSid,\n      teamId,\n      userId,\n      smsSegments,\n      callDuration,\n      creditFor,\n      phoneNumber,\n      email,\n      tx,\n    } = props;\n    let creditBalance: { id: string; additionalCredits: number } | null | undefined =\n      await CreditsRepository.findCreditBalance({ teamId, userId }, tx);\n\n    if (!creditBalance) {\n      creditBalance = await CreditsRepository.createCreditBalance(\n        {\n          teamId,\n          userId,\n        },\n        tx\n      );\n    }\n\n    if (credits && creditType === CreditType.ADDITIONAL) {\n      const decrementValue =\n        credits <= creditBalance.additionalCredits ? credits : creditBalance.additionalCredits;\n      await CreditsRepository.updateCreditBalance(\n        {\n          id: creditBalance.id,\n          data: {\n            additionalCredits: {\n              decrement: decrementValue,\n            },\n          },\n        },\n        tx\n      );\n    }\n\n    if (creditBalance) {\n      // also track logs with undefined credits (will be set on the cron job)\n      await CreditsRepository.createCreditExpenseLog(\n        {\n          creditBalanceId: creditBalance.id,\n          credits,\n          creditType,\n          creditFor,\n          date: new Date(),\n          bookingUid,\n          smsSid,\n          smsSegments,\n          phoneNumber,\n          email,\n          callDuration,\n          externalRef: props.externalRef,\n        },\n        tx\n      );\n    }\n  }\n\n  /*\n  Called when we know the exact amount of credits to be charged:\n  - Sets `limitReachedAt` and `warningSentAt`\n  - Sends warning email if balance is low\n  - Sends limit reached email\n  - cancels all already scheduled SMS (from the next two hours)\n  */\n  protected async _handleLowCreditBalance({\n    teamId,\n    userId,\n    remainingCredits,\n    creditFor,\n    tx,\n  }: {\n    teamId?: number | null;\n    userId?: number | null;\n    remainingCredits: number;\n    creditFor?: CreditUsageType;\n    tx: PrismaTransaction",
            "cost": 0.14687
        },
        "calcom__cal.com.main/packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts": {
            "output": "import prismaMock from \"../../../../../../tests/libs/__mocks__/prismaMock\";\n\nimport { describe, it, expect, beforeEach, vi } from \"vitest\";\n\nimport { WorkflowMethods } from \"@calcom/prisma/enums\";\n\nimport { sendOrScheduleWorkflowEmails } from \"./providers/emailProvider\";\nimport * as twilioProvider from \"./providers/twilioProvider\";\nimport { cancelScheduledMessagesAndScheduleEmails } from \"./reminderScheduler\";\n\nvi.mock(\"@calcom/features/ee/workflows/lib/reminders/providers/twilioProvider\", () => ({\n  cancelSMS: vi.fn(),\n  getMessageBody: vi.fn().mockResolvedValue(\"Test message body\"),\n}));\n\nvi.mock(\"@calcom/features/ee/workflows/lib/reminders/providers/emailProvider\", () => ({\n  sendOrScheduleWorkflowEmails: vi.fn(),\n}));\n\nvi.mock(\"@calcom/lib/server/i18n\", () => {\n  return {\n    getTranslation: async (locale: string, namespace: string) => {\n      const t = (key: string) => key;\n      t.locale = locale;\n      t.namespace = namespace;\n      return t;\n    },\n  };\n});\ndescribe(\"reminderScheduler\", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe(\"cancelScheduledMessagesAndScheduleEmails\", () => {\n    it(\"should cancel SMS messages and schedule emails for team\", async () => {\n      prismaMock.membership.findMany.mockResolvedValue([]);\n\n      const mockScheduledMessages = [\n        {\n          id: 1,\n          referenceId: \"sms-123\",\n          workflowStep: {\n            action: \"SMS_ATTENDEE\",\n          },\n          scheduledDate: new Date(),\n          uuid: \"uuid-123\",\n          booking: {\n            attendees: [\n              {\n                email: \"attendee@example.com\",\n                locale: \"en\",\n              },\n            ],\n            user: {\n              email: \"organizer@example.com\",\n            },\n          },\n        },\n      ];\n\n      prismaMock.workflowReminder.findMany.mockResolvedValue(mockScheduledMessages);\n\n      prismaMock.workflowReminder.updateMany.mockResolvedValue({ count: 1 });\n\n      await cancelScheduledMessagesAndScheduleEmails({ teamId: 10 });\n\n      expect(twilioProvider.cancelSMS).toHaveBeenCalledWith(\"sms-123\");\n\n      expect(sendOrScheduleWorkflowEmails).toHaveBeenCalledWith(\n        expect.objectContaining({\n          to: [\"attendee@example.com\"],\n          replyTo: \"organizer@example.com\",\n          referenceUid: \"uuid-123\",\n        })\n      );\n\n      const callArgs = prismaMock.workflowReminder.findMany.mock.calls[0][0];\n      expect(callArgs.where.workflowStep.workflow.OR).toEqual([{ userId: { in: [] } }, { teamId: 10 }]);\n    });\n\n    it(\"should cancel SMS messages and schedule emails for user\", async () => {\n      prismaMock.membership.findMany.mockResolvedValue([]);\n\n      const mockScheduledMessages = [\n        {\n          id: 1,\n          referenceId: \"sms-456\",\n          workflowStep: {\n            action: \"SMS_ATTENDEE\",\n          },\n          scheduledDate: new Date(),\n          uuid: \"uuid-456\",\n          booking: {\n            attendees: [\n              {\n                email: \"user-attendee@example.com\",\n                locale: \"en\",\n              },\n            ],\n            user: {\n              email: \"user-organizer@example.com\",\n            },\n          },\n        },\n      ];\n\n      prismaMock.workflowReminder.findMany.mockResolvedValue(mockScheduledMessages);\n\n      prismaMock.workflowReminder.updateMany.mockResolvedValue({ count: 1 });\n\n      await cancelScheduledMessagesAndScheduleEmails({ userId: 11 });\n\n      const callArgs = prismaMock.workflowReminder.findMany.mock.calls[0][0];\n      expect(callArgs.where.workflowStep.workflow.OR).toEqual([{ userId: { in: [11] } }]);\n\n      expect(twilioProvider.cancelSMS).toHaveBeenCalledWith(\"sms-456\");\n\n      expect(sendOrScheduleWorkflowEmails).toHaveBeenCalledWith(\n        expect.objectContaining({\n          to: [\"user-attendee@example.com\"],\n          replyTo: \"user-organizer@example.com\",\n          referenceUid: \"uuid-456\",\n        })\n      );\n\n      expect(prismaMock.workflowReminder.updateMany).toHaveBeenCalledWith({\n        where: {\n          id: {\n            in: [1],\n          },\n        },\n        data: {\n          method: WorkflowMethods.EMAIL,\n          referenceId: null,\n        },\n      });\n    });\n  });\n});",
            "output_extracted": "import prismaMock from \"../../../../../../tests/libs/__mocks__/prismaMock\";\n\nimport { describe, it, expect, beforeEach, vi } from \"vitest\";\n\nimport { WorkflowMethods } from \"@calcom/prisma/enums\";\n\nimport { sendOrScheduleWorkflowEmails } from \"./providers/emailProvider\";\nimport * as twilioProvider from \"./providers/twilioProvider\";\nimport { cancelScheduledMessagesAndScheduleEmails } from \"./reminderScheduler\";\n\nvi.mock(\"@calcom/features/ee/workflows/lib/reminders/providers/twilioProvider\", () => ({\n  cancelSMS: vi.fn(),\n  getMessageBody: vi.fn().mockResolvedValue(\"Test message body\"),\n}));\n\nvi.mock(\"@calcom/features/ee/workflows/lib/reminders/providers/emailProvider\", () => ({\n  sendOrScheduleWorkflowEmails: vi.fn(),\n}));\n\nvi.mock(\"@calcom/lib/server/i18n\", () => {\n  return {\n    getTranslation: async (locale: string, namespace: string) => {\n      const t = (key: string) => key;\n      t.locale = locale;\n      t.namespace = namespace;\n      return t;\n    },\n  };\n});\ndescribe(\"reminderScheduler\", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe(\"cancelScheduledMessagesAndScheduleEmails\", () => {\n    it(\"should cancel SMS messages and schedule emails for team\", async () => {\n      prismaMock.membership.findMany.mockResolvedValue([]);\n\n      const mockScheduledMessages = [\n        {\n          id: 1,\n          referenceId: \"sms-123\",\n          workflowStep: {\n            action: \"SMS_ATTENDEE\",\n          },\n          scheduledDate: new Date(),\n          uuid: \"uuid-123\",\n          booking: {\n            attendees: [\n              {\n                email: \"attendee@example.com\",\n                locale: \"en\",\n              },\n            ],\n            user: {\n              email: \"organizer@example.com\",\n            },\n          },\n        },\n      ];\n\n      prismaMock.workflowReminder.findMany.mockResolvedValue(mockScheduledMessages);\n\n      prismaMock.workflowReminder.updateMany.mockResolvedValue({ count: 1 });\n\n      await cancelScheduledMessagesAndScheduleEmails({ teamId: 10 });\n\n      expect(twilioProvider.cancelSMS).toHaveBeenCalledWith(\"sms-123\");\n\n      expect(sendOrScheduleWorkflowEmails).toHaveBeenCalledWith(\n        expect.objectContaining({\n          to: [\"attendee@example.com\"],\n          replyTo: \"organizer@example.com\",\n          referenceUid: \"uuid-123\",\n        })\n      );\n\n      const callArgs = prismaMock.workflowReminder.findMany.mock.calls[0][0];\n      expect(callArgs.where.workflowStep.workflow.OR).toEqual([{ userId: { in: [] } }, { teamId: 10 }]);\n    });\n\n    it(\"should cancel SMS messages and schedule emails for user\", async () => {\n      prismaMock.membership.findMany.mockResolvedValue([]);\n\n      const mockScheduledMessages = [\n        {\n          id: 1,\n          referenceId: \"sms-456\",\n          workflowStep: {\n            action: \"SMS_ATTENDEE\",\n          },\n          scheduledDate: new Date(),\n          uuid: \"uuid-456\",\n          booking: {\n            attendees: [\n              {\n                email: \"user-attendee@example.com\",\n                locale: \"en\",\n              },\n            ],\n            user: {\n              email: \"user-organizer@example.com\",\n            },\n          },\n        },\n      ];\n\n      prismaMock.workflowReminder.findMany.mockResolvedValue(mockScheduledMessages);\n\n      prismaMock.workflowReminder.updateMany.mockResolvedValue({ count: 1 });\n\n      await cancelScheduledMessagesAndScheduleEmails({ userId: 11 });\n\n      const callArgs = prismaMock.workflowReminder.findMany.mock.calls[0][0];\n      expect(callArgs.where.workflowStep.workflow.OR).toEqual([{ userId: { in: [11] } }]);\n\n      expect(twilioProvider.cancelSMS).toHaveBeenCalledWith(\"sms-456\");\n\n      expect(sendOrScheduleWorkflowEmails).toHaveBeenCalledWith(\n        expect.objectContaining({\n          to: [\"user-attendee@example.com\"],\n          replyTo: \"user-organizer@example.com\",\n          referenceUid: \"uuid-456\",\n        })\n      );\n\n      expect(prismaMock.workflowReminder.updateMany).toHaveBeenCalledWith({\n        where: {\n          id: {\n            in: [1],\n          },\n        },\n        data: {\n          method: WorkflowMethods.EMAIL,\n          referenceId: null,\n        },\n      });\n    });\n  });\n});",
            "cost": 0.046325000000000005
        },
        "calcom__cal.com.main/packages/features/ee/workflows/lib/reminders/reminderScheduler.ts": {
            "output": "import { BookingSeatRepository } from \"@calcom/features/bookings/repositories/BookingSeatRepository\";\nimport type { CreditCheckFn } from \"@calcom/features/ee/billing/credit-service\";\nimport {\n  isAttendeeAction,\n  isSMSAction,\n  isSMSOrWhatsappAction,\n  isWhatsappAction,\n  isCalAIAction,\n} from \"@calcom/features/ee/workflows/lib/actionHelperFunctions\";\nimport { isEmailAction } from \"@calcom/features/ee/workflows/lib/actionHelperFunctions\";\nimport { EmailWorkflowService } from \"@calcom/features/ee/workflows/lib/service/EmailWorkflowService\";\nimport { WorkflowService } from \"@calcom/features/ee/workflows/lib/service/WorkflowService\";\nimport * as twilio from \"@calcom/features/ee/workflows/lib/reminders/providers/twilioProvider\";\nimport type { Workflow, WorkflowStep } from \"@calcom/features/ee/workflows/lib/types\";\nimport { getSubmitterEmail } from \"@calcom/features/tasker/tasks/triggerFormSubmittedNoEvent/formSubmissionValidation\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport { SENDER_NAME } from \"@calcom/lib/constants\";\nimport { formatCalEventExtended } from \"@calcom/lib/formatCalendarEvent\";\nimport { withReporting } from \"@calcom/lib/sentryWrapper\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { checkSMSRateLimit } from \"@calcom/lib/smsLockState\";\nimport prisma from \"@calcom/prisma\";\nimport { SchedulingType } from \"@calcom/prisma/enums\";\nimport { WorkflowActions, WorkflowMethods, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\nimport type { CalendarEvent } from \"@calcom/types/Calendar\";\n\nimport { scheduleAIPhoneCall } from \"./aiPhoneCallManager\";\nimport type { FormSubmissionData } from \"../types\";\nimport type { BookingInfo } from \"../types\";\nimport type { ScheduleTextReminderAction } from \"./smsReminderManager\";\n\nexport type WorkflowContextData =\n  | { evt: BookingInfo; formData?: never }\n  | {\n      evt?: never;\n      formData: FormSubmissionData;\n    };\n\nexport type ExtendedCalendarEvent = Omit<CalendarEvent, \"bookerUrl\"> & {\n  metadata?: { videoCallUrl: string | undefined };\n  eventType: {\n    slug: string;\n    schedulingType?: SchedulingType | null;\n    hosts?: { user: { email: string; destinationCalendar?: { primaryEmail: string | null } | null } }[];\n  };\n  rescheduleReason?: string | null;\n  cancellationReason?: string | null;\n  bookerUrl: string;\n};\n\ntype ProcessWorkflowStepParams = (\n  | { calendarEvent: ExtendedCalendarEvent; formData?: never }\n  | {\n      calendarEvent?: never;\n      formData: FormSubmissionData;\n    }\n) & {\n  smsReminderNumber: string | null;\n  emailAttendeeSendToOverride?: string;\n  hideBranding?: boolean;\n  seatReferenceUid?: string;\n};\n\nexport type ScheduleWorkflowRemindersArgs = ProcessWorkflowStepParams & {\n  workflows: Workflow[];\n  isDryRun?: boolean;\n  creditCheckFn: CreditCheckFn;\n};\n\nconst getReminderPhoneNumber = async (\n  action: WorkflowActions,\n  seatReferenceUid: string | undefined,\n  smsReminderNumber: string | null,\n  stepSendTo: string | null\n) => {\n  const isAttendeeAction =\n    action === WorkflowActions.SMS_ATTENDEE || action === WorkflowActions.WHATSAPP_ATTENDEE;\n\n  if (!isAttendeeAction) {\n    return stepSendTo;\n  }\n\n  if (seatReferenceUid) {\n    const bookingSeatRepository = new BookingSeatRepository(prisma);\n    const seatAttendeeData = await bookingSeatRepository.getByReferenceUidWithAttendeeDetails(\n      seatReferenceUid\n    );\n    return seatAttendeeData?.attendee?.phoneNumber || smsReminderNumber;\n  }\n\n  return smsReminderNumber;\n};\n\nconst processWorkflowStep = async (\n  workflow: Workflow,\n  step: WorkflowStep,\n  {\n    smsReminderNumber,\n    calendarEvent,\n    emailAttendeeSendToOverride,\n    hideBranding,\n    seatReferenceUid,\n    formData,\n  }: ProcessWorkflowStepParams,\n  creditCheckFn: CreditCheckFn\n) => {\n  if (!step?.verifiedAt) return;\n\n  const evt = calendarEvent ? formatCalEventExtended(calendarEvent) : undefined;\n\n  if (!evt && !formData) return;\n\n  const contextData: WorkflowContextData = evt ? { evt } : { formData: formData as FormSubmissionData };\n\n  if (isSMSOrWhatsappAction(step.action)) {\n    await checkSMSRateLimit({\n      identifier: `sms:${workflow.teamId ? \"team:\" : \"user:\"}${workflow.teamId || workflow.userId}`,\n      rateLimitingType: \"sms\",\n    });\n  }\n\n  // Common parameters for all scheduling functions\n  const scheduleFunctionParams = WorkflowService.generateCommonScheduleFunctionParams({\n    workflow,\n    workflowStep: step,\n    seatReferenceUid: seatReferenceUid,\n    creditCheckFn,\n  });\n\n  if (isSMSAction(step.action)) {\n    const { scheduleSMSReminder } = await import(\"./smsReminderManager\");\n    const sendTo = await getReminderPhoneNumber(\n      step.action,\n      seatReferenceUid,\n      smsReminderNumber,\n      step.sendTo\n    );\n\n    await scheduleSMSReminder({\n      ...scheduleFunctionParams,\n      reminderPhone: sendTo,\n      action: step.action as ScheduleTextReminderAction,\n      message: step.reminderBody || \"\",\n      sender: step.sender,\n      isVerificationPending: step.numberVerificationPending,\n      ...contextData,\n    });\n  } else if (isEmailAction(step.action)) {\n    const { scheduleEmailReminder } = await import(\"./emailReminderManager\");\n    if (!evt && step.action === WorkflowActions.EMAIL_HOST) {\n      // EMAIL_HOST is not supported for form triggers\n      return;\n    }\n\n    const workflowReminderRepository = new WorkflowReminderRepository(prisma);\n    const bookingSeatRepository = new BookingSeatRepository(prisma);\n    const emailWorkflowService = new EmailWorkflowService(workflowReminderRepository, bookingSeatRepository);\n    const emailParams = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n      evt,\n      workflowStep: step,\n      workflow,\n      emailAttendeeSendToOverride,\n      formData,\n      commonScheduleFunctionParams: scheduleFunctionParams,\n      hideBranding,\n    });\n    await scheduleEmailReminder(emailParams);\n  } else if (isWhatsappAction(step.action)) {\n    if (!evt) {\n      // Whatsapp action not not yet supported for form triggers\n      return;\n    }\n\n    const { scheduleWhatsappReminder } = await import(\"./whatsappReminderManager\");\n    const sendTo = await getReminderPhoneNumber(\n      step.action,\n      seatReferenceUid,\n      smsReminderNumber,\n      step.sendTo\n    );\n\n    await scheduleWhatsappReminder({\n      ...scheduleFunctionParams,\n      verifiedAt: step.verifiedAt,\n      reminderPhone: sendTo,\n      action: step.action as ScheduleTextReminderAction,\n      message: step.reminderBody || \"\",\n      isVerificationPending: step.numberVerificationPending,\n      evt,\n    });\n  } else if (isCalAIAction(step.action)) {\n    const { scheduleAIPhoneCall } = await import(\"./aiPhoneCallManager\");\n    await scheduleAIPhoneCall({\n      triggerEvent: workflow.trigger,\n      timeSpan: {\n        time: workflow.time,\n        timeUnit: workflow.timeUnit,\n      },\n      workflowStepId: step.id,\n      userId: workflow.userId,\n      teamId: workflow.teamId,\n      seatReferenceUid,\n      submittedPhoneNumber: smsReminderNumber,\n      verifiedAt: step.verifiedAt,\n      routedEventTypeId: formData ? formData.routedEventTypeId : null,\n      ...contextData,\n    });\n  }\n};\n\nconst _scheduleWorkflowReminders = async (args: ScheduleWorkflowRemindersArgs) => {\n  const {\n    workflows,\n    smsReminderNumber,\n    calendarEvent: evt,\n    emailAttendeeSendToOverride = \"\",\n    hideBranding,\n    seatReferenceUid,\n    isDryRun = false,\n    formData,\n    creditCheckFn,\n  } = args;\n  if (isDryRun || !workflows.length) return;\n\n  for (const workflow of workflows) {\n    if (workflow.steps.length === 0) continue;\n\n    for (const step of workflow.steps) {\n      if (\n        // These tasks currently write the entire payload in the task\n        (workflow.trigger === WorkflowTriggerEvents.BEFORE_EVENT ||\n          workflow.trigger === WorkflowTriggerEvents.AFTER_EVENT) &&\n        isEmailAction(step.action) &&\n        evt\n      ) {\n        await WorkflowService.scheduleLazyEmailWorkflow({\n          evt,\n          workflowStepId: step.id,\n          workflowTriggerEvent: workflow.trigger,\n          workflow,\n          seatReferenceId: args.seatReferenceUid,\n        });\n        continue;\n      }\n\n      await processWorkflowStep(\n        workflow,\n        step,\n        {\n          emailAttendeeSendToOverride,\n          smsReminderNumber,\n          hideBranding,\n          seatReferenceUid,\n          ...(evt ? { calendarEvent: evt } : { formData }),\n        },\n        creditCheckFn\n      );\n    }\n  }\n};\n\nexport interface SendCancelledRemindersArgs {\n  workflows: Workflow[];\n  smsReminderNumber: string | null;\n  evt: ExtendedCalendarEvent;\n  hideBranding?: boolean;\n  creditCheckFn: CreditCheckFn;\n}\n\nconst _sendCancelledReminders = async (args: SendCancelledRemindersArgs) => {\n  const { smsReminderNumber, evt, workflows, hideBranding, creditCheckFn } = args;\n\n  if (!workflows.length) return;\n\n  for (const workflow of workflows) {\n    if (workflow.trigger !== WorkflowTriggerEvents.EVENT_CANCELLED) continue;\n\n    for (const step of workflow.steps) {\n      await processWorkflowStep(\n        workflow,\n        step,\n        {\n          smsReminderNumber,\n          hideBranding,\n          calendarEvent: evt,\n        },\n        creditCheckFn\n      );\n    }\n  }\n};\n\nconst _cancelScheduledMessagesAndScheduleEmails = async ({\n  teamId,\n  userId,\n}: {\n  teamId?: number | null;\n  userId?: number | null;\n}) => {\n  const { CreditService } = await import(\"@calcom/features/ee/billing/credit-service\");\n\n  let userIdsWithNoCredits: number[] = userId ? [userId] : [];\n\n  if (teamId) {\n    const teamMembers = await prisma.membership.findMany({\n      where: {\n        teamId,\n        accepted: true,\n      },\n    });\n\n    const creditService = new CreditService();\n\n    userIdsWithNoCredits = (\n      await Promise.all(\n        teamMembers.map(async (member) => {\n          const hasCredits = await creditService.hasAvailableCredits({ userId: member.userId });\n          return { userId: member.userId, hasCredits };\n        })\n      )\n    )\n      .filter(({ hasCredits }) => !hasCredits)\n      .map(({ userId }) => userId);\n  }\n\n  const scheduledMessages = await prisma.workflowReminder.findMany({\n    where: {\n      workflowStep: {\n        workflow: {\n          OR: [\n            {\n              userId: {\n                in: userIdsWithNoCredits,\n              },\n            },\n            ...(teamId ? [{ teamId }] : []),\n          ],\n        },\n      },\n      scheduled: true,\n      OR: [{ cancelled: false }, { cancelled: null }],\n      referenceId: {\n        not: null,\n      },\n      method: {\n        in: [WorkflowMethods.SMS, WorkflowMethods.WHATSAPP],\n      },\n    },\n    select: {\n      referenceId: true,\n      workflowStep: {\n        select: {\n          action: true,\n        },\n      },\n      scheduledDate: true,\n      uuid: true,\n      id: true,\n      booking: {\n        select: {\n          attendees: {\n            select: {\n              email: true,\n              locale: true,\n            },\n          },\n          user: {\n            select: {\n              email: true,\n            },\n          },\n        },\n      },\n    },\n  });\n\n  await Promise.allSettled(scheduledMessages.map((msg) => twilio.cancelSMS(msg.referenceId ?? \"\")));\n\n  await Promise.allSettled(\n    scheduledMessages.map(async (msg) => {\n      if (msg.workflowStep?.action && isAttendeeAction(msg.workflowStep.action)) {\n        const messageBody = await twilio.getMessageBody(msg.referenceId ?? \"\");\n        const sendTo = msg.booking?.attendees?.[0];\n\n        if (sendTo) {\n          const t = await getTranslation(sendTo.locale ?? \"en\", \"common\");\n          await sendOrScheduleWorkflowEmails({\n            to: [sendTo.email],\n            subject: t(\"notification_about_your_booking\"),\n            html: messageBody,\n            replyTo: msg.booking?.user?.email ?? \"\",\n            sendAt: msg.scheduledDate,\n            referenceUid: msg.uuid || undefined,\n          });\n        }\n      }\n    })\n  );\n\n  await prisma.workflowReminder.updateMany({\n    where: {\n      id: {\n        in: scheduledMessages.map((msg) => msg.id),\n      },\n    },\n    data: {\n      method: WorkflowMethods.EMAIL,\n      referenceId: null,\n    },\n  });\n};\n// Export functions wrapped with withReporting\nexport const scheduleWorkflowReminders = withReporting(\n  _scheduleWorkflowReminders,\n  \"scheduleWorkflowReminders\"\n);\nexport const sendCancelledReminders = withReporting(_sendCancelledReminders, \"sendCancelledReminders\");\nexport const cancelScheduledMessagesAndScheduleEmails = withReporting(\n  _cancelScheduledMessagesAndScheduleEmails,\n  \"cancelScheduledMessagesAndScheduleEmails\"\n);",
            "output_extracted": "import { BookingSeatRepository } from \"@calcom/features/bookings/repositories/BookingSeatRepository\";\nimport type { CreditCheckFn } from \"@calcom/features/ee/billing/credit-service\";\nimport {\n  isAttendeeAction,\n  isSMSAction,\n  isSMSOrWhatsappAction,\n  isWhatsappAction,\n  isCalAIAction,\n} from \"@calcom/features/ee/workflows/lib/actionHelperFunctions\";\nimport { isEmailAction } from \"@calcom/features/ee/workflows/lib/actionHelperFunctions\";\nimport { EmailWorkflowService } from \"@calcom/features/ee/workflows/lib/service/EmailWorkflowService\";\nimport { WorkflowService } from \"@calcom/features/ee/workflows/lib/service/WorkflowService\";\nimport * as twilio from \"@calcom/features/ee/workflows/lib/reminders/providers/twilioProvider\";\nimport type { Workflow, WorkflowStep } from \"@calcom/features/ee/workflows/lib/types\";\nimport { getSubmitterEmail } from \"@calcom/features/tasker/tasks/triggerFormSubmittedNoEvent/formSubmissionValidation\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport { SENDER_NAME } from \"@calcom/lib/constants\";\nimport { formatCalEventExtended } from \"@calcom/lib/formatCalendarEvent\";\nimport { withReporting } from \"@calcom/lib/sentryWrapper\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { checkSMSRateLimit } from \"@calcom/lib/smsLockState\";\nimport prisma from \"@calcom/prisma\";\nimport { SchedulingType } from \"@calcom/prisma/enums\";\nimport { WorkflowActions, WorkflowMethods, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\nimport type { CalendarEvent } from \"@calcom/types/Calendar\";\n\nimport { scheduleAIPhoneCall } from \"./aiPhoneCallManager\";\nimport type { FormSubmissionData } from \"../types\";\nimport type { BookingInfo } from \"../types\";\nimport type { ScheduleTextReminderAction } from \"./smsReminderManager\";\n\nexport type WorkflowContextData =\n  | { evt: BookingInfo; formData?: never }\n  | {\n      evt?: never;\n      formData: FormSubmissionData;\n    };\n\nexport type ExtendedCalendarEvent = Omit<CalendarEvent, \"bookerUrl\"> & {\n  metadata?: { videoCallUrl: string | undefined };\n  eventType: {\n    slug: string;\n    schedulingType?: SchedulingType | null;\n    hosts?: { user: { email: string; destinationCalendar?: { primaryEmail: string | null } | null } }[];\n  };\n  rescheduleReason?: string | null;\n  cancellationReason?: string | null;\n  bookerUrl: string;\n};\n\ntype ProcessWorkflowStepParams = (\n  | { calendarEvent: ExtendedCalendarEvent; formData?: never }\n  | {\n      calendarEvent?: never;\n      formData: FormSubmissionData;\n    }\n) & {\n  smsReminderNumber: string | null;\n  emailAttendeeSendToOverride?: string;\n  hideBranding?: boolean;\n  seatReferenceUid?: string;\n};\n\nexport type ScheduleWorkflowRemindersArgs = ProcessWorkflowStepParams & {\n  workflows: Workflow[];\n  isDryRun?: boolean;\n  creditCheckFn: CreditCheckFn;\n};\n\nconst getReminderPhoneNumber = async (\n  action: WorkflowActions,\n  seatReferenceUid: string | undefined,\n  smsReminderNumber: string | null,\n  stepSendTo: string | null\n) => {\n  const isAttendeeAction =\n    action === WorkflowActions.SMS_ATTENDEE || action === WorkflowActions.WHATSAPP_ATTENDEE;\n\n  if (!isAttendeeAction) {\n    return stepSendTo;\n  }\n\n  if (seatReferenceUid) {\n    const bookingSeatRepository = new BookingSeatRepository(prisma);\n    const seatAttendeeData = await bookingSeatRepository.getByReferenceUidWithAttendeeDetails(\n      seatReferenceUid\n    );\n    return seatAttendeeData?.attendee?.phoneNumber || smsReminderNumber;\n  }\n\n  return smsReminderNumber;\n};\n\nconst processWorkflowStep = async (\n  workflow: Workflow,\n  step: WorkflowStep,\n  {\n    smsReminderNumber,\n    calendarEvent,\n    emailAttendeeSendToOverride,\n    hideBranding,\n    seatReferenceUid,\n    formData,\n  }: ProcessWorkflowStepParams,\n  creditCheckFn: CreditCheckFn\n) => {\n  if (!step?.verifiedAt) return;\n\n  const evt = calendarEvent ? formatCalEventExtended(calendarEvent) : undefined;\n\n  if (!evt && !formData) return;\n\n  const contextData: WorkflowContextData = evt ? { evt } : { formData: formData as FormSubmissionData };\n\n  if (isSMSOrWhatsappAction(step.action)) {\n    await checkSMSRateLimit({\n      identifier: `sms:${workflow.teamId ? \"team:\" : \"user:\"}${workflow.teamId || workflow.userId}`,\n      rateLimitingType: \"sms\",\n    });\n  }\n\n  // Common parameters for all scheduling functions\n  const scheduleFunctionParams = WorkflowService.generateCommonScheduleFunctionParams({\n    workflow,\n    workflowStep: step,\n    seatReferenceUid: seatReferenceUid,\n    creditCheckFn,\n  });\n\n  if (isSMSAction(step.action)) {\n    const { scheduleSMSReminder } = await import(\"./smsReminderManager\");\n    const sendTo = await getReminderPhoneNumber(\n      step.action,\n      seatReferenceUid,\n      smsReminderNumber,\n      step.sendTo\n    );\n\n    await scheduleSMSReminder({\n      ...scheduleFunctionParams,\n      reminderPhone: sendTo,\n      action: step.action as ScheduleTextReminderAction,\n      message: step.reminderBody || \"\",\n      sender: step.sender,\n      isVerificationPending: step.numberVerificationPending,\n      ...contextData,\n    });\n  } else if (isEmailAction(step.action)) {\n    const { scheduleEmailReminder } = await import(\"./emailReminderManager\");\n    if (!evt && step.action === WorkflowActions.EMAIL_HOST) {\n      // EMAIL_HOST is not supported for form triggers\n      return;\n    }\n\n    const workflowReminderRepository = new WorkflowReminderRepository(prisma);\n    const bookingSeatRepository = new BookingSeatRepository(prisma);\n    const emailWorkflowService = new EmailWorkflowService(workflowReminderRepository, bookingSeatRepository);\n    const emailParams = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n      evt,\n      workflowStep: step,\n      workflow,\n      emailAttendeeSendToOverride,\n      formData,\n      commonScheduleFunctionParams: scheduleFunctionParams,\n      hideBranding,\n    });\n    await scheduleEmailReminder(emailParams);\n  } else if (isWhatsappAction(step.action)) {\n    if (!evt) {\n      // Whatsapp action not not yet supported for form triggers\n      return;\n    }\n\n    const { scheduleWhatsappReminder } = await import(\"./whatsappReminderManager\");\n    const sendTo = await getReminderPhoneNumber(\n      step.action,\n      seatReferenceUid,\n      smsReminderNumber,\n      step.sendTo\n    );\n\n    await scheduleWhatsappReminder({\n      ...scheduleFunctionParams,\n      verifiedAt: step.verifiedAt,\n      reminderPhone: sendTo,\n      action: step.action as ScheduleTextReminderAction,\n      message: step.reminderBody || \"\",\n      isVerificationPending: step.numberVerificationPending,\n      evt,\n    });\n  } else if (isCalAIAction(step.action)) {\n    const { scheduleAIPhoneCall } = await import(\"./aiPhoneCallManager\");\n    await scheduleAIPhoneCall({\n      triggerEvent: workflow.trigger,\n      timeSpan: {\n        time: workflow.time,\n        timeUnit: workflow.timeUnit,\n      },\n      workflowStepId: step.id,\n      userId: workflow.userId,\n      teamId: workflow.teamId,\n      seatReferenceUid,\n      submittedPhoneNumber: smsReminderNumber,\n      verifiedAt: step.verifiedAt,\n      routedEventTypeId: formData ? formData.routedEventTypeId : null,\n      ...contextData,\n    });\n  }\n};\n\nconst _scheduleWorkflowReminders = async (args: ScheduleWorkflowRemindersArgs) => {\n  const {\n    workflows,\n    smsReminderNumber,\n    calendarEvent: evt,\n    emailAttendeeSendToOverride = \"\",\n    hideBranding,\n    seatReferenceUid,\n    isDryRun = false,\n    formData,\n    creditCheckFn,\n  } = args;\n  if (isDryRun || !workflows.length) return;\n\n  for (const workflow of workflows) {\n    if (workflow.steps.length === 0) continue;\n\n    for (const step of workflow.steps) {\n      if (\n        // These tasks currently write the entire payload in the task\n        (workflow.trigger === WorkflowTriggerEvents.BEFORE_EVENT ||\n          workflow.trigger === WorkflowTriggerEvents.AFTER_EVENT) &&\n        isEmailAction(step.action) &&\n        evt\n      ) {\n        await WorkflowService.scheduleLazyEmailWorkflow({\n          evt,\n          workflowStepId: step.id,\n          workflowTriggerEvent: workflow.trigger,\n          workflow,\n          seatReferenceId: args.seatReferenceUid,\n        });\n        continue;\n      }\n\n      await processWorkflowStep(\n        workflow,\n        step,\n        {\n          emailAttendeeSendToOverride,\n          smsReminderNumber,\n          hideBranding,\n          seatReferenceUid,\n          ...(evt ? { calendarEvent: evt } : { formData }),\n        },\n        creditCheckFn\n      );\n    }\n  }\n};\n\nexport interface SendCancelledRemindersArgs {\n  workflows: Workflow[];\n  smsReminderNumber: string | null;\n  evt: ExtendedCalendarEvent;\n  hideBranding?: boolean;\n  creditCheckFn: CreditCheckFn;\n}\n\nconst _sendCancelledReminders = async (args: SendCancelledRemindersArgs) => {\n  const { smsReminderNumber, evt, workflows, hideBranding, creditCheckFn } = args;\n\n  if (!workflows.length) return;\n\n  for (const workflow of workflows) {\n    if (workflow.trigger !== WorkflowTriggerEvents.EVENT_CANCELLED) continue;\n\n    for (const step of workflow.steps) {\n      await processWorkflowStep(\n        workflow,\n        step,\n        {\n          smsReminderNumber,\n          hideBranding,\n          calendarEvent: evt,\n        },\n        creditCheckFn\n      );\n    }\n  }\n};\n\nconst _cancelScheduledMessagesAndScheduleEmails = async ({\n  teamId,\n  userId,\n}: {\n  teamId?: number | null;\n  userId?: number | null;\n}) => {\n  const { CreditService } = await import(\"@calcom/features/ee/billing/credit-service\");\n\n  let userIdsWithNoCredits: number[] = userId ? [userId] : [];\n\n  if (teamId) {\n    const teamMembers = await prisma.membership.findMany({\n      where: {\n        teamId,\n        accepted: true,\n      },\n    });\n\n    const creditService = new CreditService();\n\n    userIdsWithNoCredits = (\n      await Promise.all(\n        teamMembers.map(async (member) => {\n          const hasCredits = await creditService.hasAvailableCredits({ userId: member.userId });\n          return { userId: member.userId, hasCredits };\n        })\n      )\n    )\n      .filter(({ hasCredits }) => !hasCredits)\n      .map(({ userId }) => userId);\n  }\n\n  const scheduledMessages = await prisma.workflowReminder.findMany({\n    where: {\n      workflowStep: {\n        workflow: {\n          OR: [\n            {\n              userId: {\n                in: userIdsWithNoCredits,\n              },\n            },\n            ...(teamId ? [{ teamId }] : []),\n          ],\n        },\n      },\n      scheduled: true,\n      OR: [{ cancelled: false }, { cancelled: null }],\n      referenceId: {\n        not: null,\n      },\n      method: {\n        in: [WorkflowMethods.SMS, WorkflowMethods.WHATSAPP],\n      },\n    },\n    select: {\n      referenceId: true,\n      workflowStep: {\n        select: {\n          action: true,\n        },\n      },\n      scheduledDate: true,\n      uuid: true,\n      id: true,\n      booking: {\n        select: {\n          attendees: {\n            select: {\n              email: true,\n              locale: true,\n            },\n          },\n          user: {\n            select: {\n              email: true,\n            },\n          },\n        },\n      },\n    },\n  });\n\n  await Promise.allSettled(scheduledMessages.map((msg) => twilio.cancelSMS(msg.referenceId ?? \"\")));\n\n  await Promise.allSettled(\n    scheduledMessages.map(async (msg) => {\n      if (msg.workflowStep?.action && isAttendeeAction(msg.workflowStep.action)) {\n        const messageBody = await twilio.getMessageBody(msg.referenceId ?? \"\");\n        const sendTo = msg.booking?.attendees?.[0];\n\n        if (sendTo) {\n          const t = await getTranslation(sendTo.locale ?? \"en\", \"common\");\n          await sendOrScheduleWorkflowEmails({\n            to: [sendTo.email],\n            subject: t(\"notification_about_your_booking\"),\n            html: messageBody,\n            replyTo: msg.booking?.user?.email ?? \"\",\n            sendAt: msg.scheduledDate,\n            referenceUid: msg.uuid || undefined,\n          });\n        }\n      }\n    })\n  );\n\n  await prisma.workflowReminder.updateMany({\n    where: {\n      id: {\n        in: scheduledMessages.map((msg) => msg.id),\n      },\n    },\n    data: {\n      method: WorkflowMethods.EMAIL,\n      referenceId: null,\n    },\n  });\n};\n// Export functions wrapped with withReporting\nexport const scheduleWorkflowReminders = withReporting(\n  _scheduleWorkflowReminders,\n  \"scheduleWorkflowReminders\"\n);\nexport const sendCancelledReminders = withReporting(_sendCancelledReminders, \"sendCancelledReminders\");\nexport const cancelScheduledMessagesAndScheduleEmails = withReporting(\n  _cancelScheduledMessagesAndScheduleEmails,\n  \"cancelScheduledMessagesAndScheduleEmails\"\n);",
            "cost": 0.12748500000000001
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25312",
        "repo": "calcom/cal.com",
        "base_commit": "1578dee6223806d7b70d6cbb721e8cae9a3406d7",
        "head_commit": "072374d5c337647547b6eb5804cf9b80814df85f",
        "title": "fix: break circular dependency between reminderScheduler and credit-service",
        "merged_at": "2025-11-24T08:00:58Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25312",
        "test_files": [
            "packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts"
        ],
        "code_files": [
            "packages/features/ee/billing/credit-service.ts",
            "packages/features/ee/workflows/lib/reminders/reminderScheduler.ts",
            "packages/features/ee/workflows/repositories/WorkflowReminderRepository.ts"
        ],
        "total_changes": 234,
        "num_files": 4,
        "pull_number": 25312,
        "patch": "diff --git a/packages/features/ee/billing/credit-service.ts b/packages/features/ee/billing/credit-service.ts\nindex 864114c4e355e5..8b8b78819f5a6e 100644\n--- a/packages/features/ee/billing/credit-service.ts\n+++ b/packages/features/ee/billing/credit-service.ts\n@@ -605,11 +605,15 @@ export class CreditService {\n             \"@calcom/features/ee/workflows/lib/reminders/reminderScheduler\"\n           );\n           promises.push(\n-            cancelScheduledMessagesAndScheduleEmails({ teamId: result.teamId, userId: result.userId }).catch(\n-              (error) => {\n-                log.error(\"Failed to cancel scheduled messages\", error, { result });\n-              }\n-            )\n+            cancelScheduledMessagesAndScheduleEmails({\n+              teamId: result.teamId,\n+              userIdsWithNoCredits: await this._getUserIdsWithoutCredits({\n+                teamId: result.teamId ?? null,\n+                userId: result.userId ?? null,\n+              }),\n+            }).catch((error) => {\n+              log.error(\"Failed to cancel scheduled messages\", error, { result });\n+            })\n           );\n         }\n \n@@ -826,4 +830,34 @@ export class CreditService {\n       };\n     });\n   }\n+\n+  private async _getUserIdsWithoutCredits({\n+    teamId,\n+    userId,\n+  }: {\n+    teamId: number | null;\n+    userId: number | null;\n+  }) {\n+    let userIdsWithNoCredits: number[] = userId ? [userId] : [];\n+    if (teamId) {\n+      const teamMembers = await prisma.membership.findMany({\n+        where: {\n+          teamId,\n+          accepted: true,\n+        },\n+      });\n+\n+      userIdsWithNoCredits = (\n+        await Promise.all(\n+          teamMembers.map(async (member) => {\n+            const hasCredits = await this.hasAvailableCredits({ userId: member.userId });\n+            return { userId: member.userId, hasCredits };\n+          })\n+        )\n+      )\n+        .filter(({ hasCredits }) => !hasCredits)\n+        .map(({ userId }) => userId);\n+    }\n+    return userIdsWithNoCredits;\n+  }\n }\ndiff --git a/packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts b/packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts\nindex aa8549db6aa9b7..fbd3c98b0241e9 100644\n--- a/packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts\n+++ b/packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts\n@@ -34,8 +34,6 @@ describe(\"reminderScheduler\", () => {\n \n   describe(\"cancelScheduledMessagesAndScheduleEmails\", () => {\n     it(\"should cancel SMS messages and schedule emails for team\", async () => {\n-      prismaMock.membership.findMany.mockResolvedValue([]);\n-\n       const mockScheduledMessages = [\n         {\n           id: 1,\n@@ -63,7 +61,7 @@ describe(\"reminderScheduler\", () => {\n \n       prismaMock.workflowReminder.updateMany.mockResolvedValue({ count: 1 });\n \n-      await cancelScheduledMessagesAndScheduleEmails({ teamId: 10 });\n+      await cancelScheduledMessagesAndScheduleEmails({ teamId: 10, userIdsWithNoCredits: [1, 2, 3] });\n \n       expect(twilioProvider.cancelSMS).toHaveBeenCalledWith(\"sms-123\");\n \n@@ -76,12 +74,13 @@ describe(\"reminderScheduler\", () => {\n       );\n \n       const callArgs = prismaMock.workflowReminder.findMany.mock.calls[0][0];\n-      expect(callArgs.where.workflowStep.workflow.OR).toEqual([{ userId: { in: [] } }, { teamId: 10 }]);\n+      expect(callArgs.where.workflowStep.workflow.OR).toEqual([\n+        { userId: { in: [1, 2, 3] } },\n+        { teamId: 10 },\n+      ]);\n     });\n \n     it(\"should cancel SMS messages and schedule emails for user\", async () => {\n-      prismaMock.membership.findMany.mockResolvedValue([]);\n-\n       const mockScheduledMessages = [\n         {\n           id: 1,\n@@ -109,7 +108,7 @@ describe(\"reminderScheduler\", () => {\n \n       prismaMock.workflowReminder.updateMany.mockResolvedValue({ count: 1 });\n \n-      await cancelScheduledMessagesAndScheduleEmails({ userId: 11 });\n+      await cancelScheduledMessagesAndScheduleEmails({ userIdsWithNoCredits: [11] });\n \n       const callArgs = prismaMock.workflowReminder.findMany.mock.calls[0][0];\n       expect(callArgs.where.workflowStep.workflow.OR).toEqual([{ userId: { in: [11] } }]);\ndiff --git a/packages/features/ee/workflows/lib/reminders/reminderScheduler.ts b/packages/features/ee/workflows/lib/reminders/reminderScheduler.ts\nindex 8ddd80a8343693..63c47a4971861b 100644\n--- a/packages/features/ee/workflows/lib/reminders/reminderScheduler.ts\n+++ b/packages/features/ee/workflows/lib/reminders/reminderScheduler.ts\n@@ -11,14 +11,14 @@ import * as twilio from \"@calcom/features/ee/workflows/lib/reminders/providers/t\n import type { Workflow, WorkflowStep } from \"@calcom/features/ee/workflows/lib/types\";\n import { getSubmitterEmail } from \"@calcom/features/tasker/tasks/triggerFormSubmittedNoEvent/formSubmissionValidation\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n-import { checkSMSRateLimit } from \"@calcom/lib/smsLockState\";\n import { SENDER_NAME } from \"@calcom/lib/constants\";\n import { formatCalEventExtended } from \"@calcom/lib/formatCalendarEvent\";\n import { withReporting } from \"@calcom/lib/sentryWrapper\";\n import { getTranslation } from \"@calcom/lib/server/i18n\";\n+import { checkSMSRateLimit } from \"@calcom/lib/smsLockState\";\n import prisma from \"@calcom/prisma\";\n import { SchedulingType } from \"@calcom/prisma/enums\";\n-import { WorkflowActions, WorkflowMethods, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\n+import { WorkflowActions, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\n import type { CalendarEvent } from \"@calcom/types/Calendar\";\n \n import { scheduleAIPhoneCall } from \"./aiPhoneCallManager\";\n@@ -288,86 +288,18 @@ const _sendCancelledReminders = async (args: SendCancelledRemindersArgs) => {\n \n const _cancelScheduledMessagesAndScheduleEmails = async ({\n   teamId,\n-  userId,\n+  userIdsWithNoCredits,\n }: {\n   teamId?: number | null;\n-  userId?: number | null;\n+  userIdsWithNoCredits: number[];\n }) => {\n-  const { CreditService } = await import(\"@calcom/features/ee/billing/credit-service\");\n-\n-  let userIdsWithNoCredits: number[] = userId ? [userId] : [];\n-\n-  if (teamId) {\n-    const teamMembers = await prisma.membership.findMany({\n-      where: {\n-        teamId,\n-        accepted: true,\n-      },\n-    });\n-\n-    const creditService = new CreditService();\n-\n-    userIdsWithNoCredits = (\n-      await Promise.all(\n-        teamMembers.map(async (member) => {\n-          const hasCredits = await creditService.hasAvailableCredits({ userId: member.userId });\n-          return { userId: member.userId, hasCredits };\n-        })\n-      )\n-    )\n-      .filter(({ hasCredits }) => !hasCredits)\n-      .map(({ userId }) => userId);\n-  }\n+  const { WorkflowReminderRepository } = await import(\n+    \"@calcom/features/ee/workflows/repositories/WorkflowReminderRepository\"\n+  );\n \n-  const scheduledMessages = await prisma.workflowReminder.findMany({\n-    where: {\n-      workflowStep: {\n-        workflow: {\n-          OR: [\n-            {\n-              userId: {\n-                in: userIdsWithNoCredits,\n-              },\n-            },\n-            ...(teamId ? [{ teamId }] : []),\n-          ],\n-        },\n-      },\n-      scheduled: true,\n-      OR: [{ cancelled: false }, { cancelled: null }],\n-      referenceId: {\n-        not: null,\n-      },\n-      method: {\n-        in: [WorkflowMethods.SMS, WorkflowMethods.WHATSAPP],\n-      },\n-    },\n-    select: {\n-      referenceId: true,\n-      workflowStep: {\n-        select: {\n-          action: true,\n-        },\n-      },\n-      scheduledDate: true,\n-      uuid: true,\n-      id: true,\n-      booking: {\n-        select: {\n-          attendees: {\n-            select: {\n-              email: true,\n-              locale: true,\n-            },\n-          },\n-          user: {\n-            select: {\n-              email: true,\n-            },\n-          },\n-        },\n-      },\n-    },\n+  const scheduledMessages = await WorkflowReminderRepository.findScheduledMessagesToCancel({\n+    teamId,\n+    userIdsWithNoCredits,\n   });\n \n   await Promise.allSettled(scheduledMessages.map((msg) => twilio.cancelSMS(msg.referenceId ?? \"\")));\n@@ -393,16 +325,8 @@ const _cancelScheduledMessagesAndScheduleEmails = async ({\n     })\n   );\n \n-  await prisma.workflowReminder.updateMany({\n-    where: {\n-      id: {\n-        in: scheduledMessages.map((msg) => msg.id),\n-      },\n-    },\n-    data: {\n-      method: WorkflowMethods.EMAIL,\n-      referenceId: null,\n-    },\n+  await WorkflowReminderRepository.updateRemindersToEmail({\n+    reminderIds: scheduledMessages.map((msg) => msg.id),\n   });\n };\n // Export functions wrapped with withReporting\ndiff --git a/packages/features/ee/workflows/repositories/WorkflowReminderRepository.ts b/packages/features/ee/workflows/repositories/WorkflowReminderRepository.ts\nnew file mode 100644\nindex 00000000000000..60d6727d2c1b2d\n--- /dev/null\n+++ b/packages/features/ee/workflows/repositories/WorkflowReminderRepository.ts\n@@ -0,0 +1,77 @@\n+import { prisma } from \"@calcom/prisma\";\n+import { WorkflowMethods } from \"@calcom/prisma/enums\";\n+\n+export class WorkflowReminderRepository {\n+  static async findScheduledMessagesToCancel({\n+    teamId,\n+    userIdsWithNoCredits,\n+  }: {\n+    teamId?: number | null;\n+    userIdsWithNoCredits: number[];\n+  }) {\n+    return await prisma.workflowReminder.findMany({\n+      where: {\n+        workflowStep: {\n+          workflow: {\n+            OR: [\n+              {\n+                userId: {\n+                  in: userIdsWithNoCredits,\n+                },\n+              },\n+              ...(teamId ? [{ teamId }] : []),\n+            ],\n+          },\n+        },\n+        scheduled: true,\n+        OR: [{ cancelled: false }, { cancelled: null }],\n+        referenceId: {\n+          not: null,\n+        },\n+        method: {\n+          in: [WorkflowMethods.SMS, WorkflowMethods.WHATSAPP],\n+        },\n+      },\n+      select: {\n+        referenceId: true,\n+        workflowStep: {\n+          select: {\n+            action: true,\n+          },\n+        },\n+        scheduledDate: true,\n+        uuid: true,\n+        id: true,\n+        booking: {\n+          select: {\n+            attendees: {\n+              select: {\n+                email: true,\n+                locale: true,\n+              },\n+            },\n+            user: {\n+              select: {\n+                email: true,\n+              },\n+            },\n+          },\n+        },\n+      },\n+    });\n+  }\n+\n+  static async updateRemindersToEmail({ reminderIds }: { reminderIds: number[] }): Promise<void> {\n+    await prisma.workflowReminder.updateMany({\n+      where: {\n+        id: {\n+          in: reminderIds,\n+        },\n+      },\n+      data: {\n+        method: WorkflowMethods.EMAIL,\n+        referenceId: null,\n+      },\n+    });\n+  }\n+}\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}