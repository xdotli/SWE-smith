{
    "cost": 0.046955000000000004,
    "rewrites": {
        "calcom__cal.com.main/packages/features/ee/dsync/lib/handleUserEvents.ts": {
            "output": "import type { DirectorySyncEvent, User } from \"@boxyhq/saml-jackson\";\n\nimport removeUserFromOrg from \"@calcom/features/ee/dsync/lib/removeUserFromOrg\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport prisma from \"@calcom/prisma\";\nimport { IdentityProvider } from \"@calcom/prisma/enums\";\nimport { getTeamOrThrow } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\";\nimport type { UserWithMembership } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\";\nimport { sendExistingUserTeamInviteEmails } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\";\nimport { sendSignupToOrganizationEmail } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\";\n\nimport { assignValueToUserInOrgBulk } from \"./assignValueToUser\";\nimport getAttributesFromScimPayload from \"./getAttributesFromScimPayload\";\nimport createUsersAndConnectToOrg from \"./users/createUsersAndConnectToOrg\";\nimport dSyncUserSelect from \"./users/dSyncUserSelect\";\nimport inviteExistingUserToOrg from \"./users/inviteExistingUserToOrg\";\n\nconst log = logger.getSubLogger({ prefix: [\"handleUserEvents\"] });\n\nasync function syncCustomAttributesToUser({\n  event,\n  userEmail,\n  org,\n  directoryId,\n}: {\n  event: DirectorySyncEvent;\n  userEmail: string;\n  org: {\n    id: number;\n  };\n  directoryId: string;\n}) {\n  const user = await prisma.user.findUnique({\n    where: {\n      email: userEmail,\n    },\n    select: dSyncUserSelect,\n  });\n\n  if (!user) {\n    log.error(`User not found in DB ${userEmail}. Skipping custom attributes sync.`);\n    return;\n  }\n\n  const customAttributes = getAttributesFromScimPayload({ event, directoryId });\n  await assignValueToUserInOrgBulk({\n    orgId: org.id,\n    userId: user.id,\n    attributeLabelToValueMap: customAttributes,\n    updater: {\n      dsyncId: directoryId,\n    },\n  });\n}\n\nconst handleUserEvents = async (event: DirectorySyncEvent, organizationId: number) => {\n  log.debug(\"called\", safeStringify(event));\n  const directoryId = event.directory_id;\n  const eventData = event.data as User;\n  const userEmail = eventData.email;\n  // Check if user exists in DB\n  const user = await prisma.user.findUnique({\n    where: {\n      email: userEmail,\n    },\n    select: dSyncUserSelect,\n  });\n\n  const translation = await getTranslation(user?.locale || \"en\", \"common\");\n\n  const org = await getTeamOrThrow(organizationId);\n\n  if (!org) {\n    throw new Error(\"Org not found\");\n  }\n\n  if (user) {\n    if (eventData.active) {\n      if (await new UserRepository(prisma).isAMemberOfOrganization({ user, organizationId })) {\n        await syncCustomAttributesToUser({\n          event,\n          userEmail,\n          org,\n          directoryId,\n        });\n      } else {\n        // If data.active is true then provision the user into the org\n        const addedUser = await inviteExistingUserToOrg({\n          user: user as UserWithMembership,\n          org,\n          translation,\n        });\n        await sendExistingUserTeamInviteEmails({\n          currentUserName: user.username,\n          currentUserTeamName: org.name,\n          existingUsersWithMemberships: [\n            {\n              ...addedUser,\n              profile: null,\n            },\n          ],\n          language: translation,\n          isOrg: true,\n          teamId: org.id,\n          isAutoJoin: true,\n          currentUserParentTeamName: org?.parent?.name,\n          orgSlug: org.slug,\n        });\n      }\n    } else {\n      // If data.active is false then remove the user from the org\n      await removeUserFromOrg({\n        userId: user.id,\n        orgId: organizationId,\n      });\n    }\n    // If user is not in DB, create user and add to the org\n  } else {\n    const createUsersAndConnectToOrgProps = {\n      emailsToCreate: [userEmail],\n      identityProvider: IdentityProvider.CAL,\n      identityProviderId: null,\n    };\n    await createUsersAndConnectToOrg({\n      createUsersAndConnectToOrgProps,\n      org,\n    });\n\n    await sendSignupToOrganizationEmail({\n      usernameOrEmail: userEmail,\n      team: org,\n      translation,\n      inviterName: org.name,\n      teamId: organizationId,\n      isOrg: true,\n    });\n\n    await syncCustomAttributesToUser({\n      event,\n      userEmail,\n      org,\n      directoryId,\n    });\n  }\n};\n\nexport default handleUserEvents;",
            "output_extracted": "import type { DirectorySyncEvent, User } from \"@boxyhq/saml-jackson\";\n\nimport removeUserFromOrg from \"@calcom/features/ee/dsync/lib/removeUserFromOrg\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport prisma from \"@calcom/prisma\";\nimport { IdentityProvider } from \"@calcom/prisma/enums\";\nimport { getTeamOrThrow } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\";\nimport type { UserWithMembership } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\";\nimport { sendExistingUserTeamInviteEmails } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\";\nimport { sendSignupToOrganizationEmail } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\";\n\nimport { assignValueToUserInOrgBulk } from \"./assignValueToUser\";\nimport getAttributesFromScimPayload from \"./getAttributesFromScimPayload\";\nimport createUsersAndConnectToOrg from \"./users/createUsersAndConnectToOrg\";\nimport dSyncUserSelect from \"./users/dSyncUserSelect\";\nimport inviteExistingUserToOrg from \"./users/inviteExistingUserToOrg\";\n\nconst log = logger.getSubLogger({ prefix: [\"handleUserEvents\"] });\n\nasync function syncCustomAttributesToUser({\n  event,\n  userEmail,\n  org,\n  directoryId,\n}: {\n  event: DirectorySyncEvent;\n  userEmail: string;\n  org: {\n    id: number;\n  };\n  directoryId: string;\n}) {\n  const user = await prisma.user.findUnique({\n    where: {\n      email: userEmail,\n    },\n    select: dSyncUserSelect,\n  });\n\n  if (!user) {\n    log.error(`User not found in DB ${userEmail}. Skipping custom attributes sync.`);\n    return;\n  }\n\n  const customAttributes = getAttributesFromScimPayload({ event, directoryId });\n  await assignValueToUserInOrgBulk({\n    orgId: org.id,\n    userId: user.id,\n    attributeLabelToValueMap: customAttributes,\n    updater: {\n      dsyncId: directoryId,\n    },\n  });\n}\n\nconst handleUserEvents = async (event: DirectorySyncEvent, organizationId: number) => {\n  log.debug(\"called\", safeStringify(event));\n  const directoryId = event.directory_id;\n  const eventData = event.data as User;\n  const userEmail = eventData.email;\n  // Check if user exists in DB\n  const user = await prisma.user.findUnique({\n    where: {\n      email: userEmail,\n    },\n    select: dSyncUserSelect,\n  });\n\n  const translation = await getTranslation(user?.locale || \"en\", \"common\");\n\n  const org = await getTeamOrThrow(organizationId);\n\n  if (!org) {\n    throw new Error(\"Org not found\");\n  }\n\n  if (user) {\n    if (eventData.active) {\n      if (await new UserRepository(prisma).isAMemberOfOrganization({ user, organizationId })) {\n        await syncCustomAttributesToUser({\n          event,\n          userEmail,\n          org,\n          directoryId,\n        });\n      } else {\n        // If data.active is true then provision the user into the org\n        const addedUser = await inviteExistingUserToOrg({\n          user: user as UserWithMembership,\n          org,\n          translation,\n        });\n        await sendExistingUserTeamInviteEmails({\n          currentUserName: user.username,\n          currentUserTeamName: org.name,\n          existingUsersWithMemberships: [\n            {\n              ...addedUser,\n              profile: null,\n            },\n          ],\n          language: translation,\n          isOrg: true,\n          teamId: org.id,\n          isAutoJoin: true,\n          currentUserParentTeamName: org?.parent?.name,\n          orgSlug: org.slug,\n        });\n      }\n    } else {\n      // If data.active is false then remove the user from the org\n      await removeUserFromOrg({\n        userId: user.id,\n        orgId: organizationId,\n      });\n    }\n    // If user is not in DB, create user and add to the org\n  } else {\n    const createUsersAndConnectToOrgProps = {\n      emailsToCreate: [userEmail],\n      identityProvider: IdentityProvider.CAL,\n      identityProviderId: null,\n    };\n    await createUsersAndConnectToOrg({\n      createUsersAndConnectToOrgProps,\n      org,\n    });\n\n    await sendSignupToOrganizationEmail({\n      usernameOrEmail: userEmail,\n      team: org,\n      translation,\n      inviterName: org.name,\n      teamId: organizationId,\n      isOrg: true,\n    });\n\n    await syncCustomAttributesToUser({\n      event,\n      userEmail,\n      org,\n      directoryId,\n    });\n  }\n};\n\nexport default handleUserEvents;",
            "cost": 0.046955000000000004
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25314",
        "repo": "calcom/cal.com",
        "base_commit": "3c8215add3f250b44d98700795dc40ade280ecbb",
        "head_commit": "c0ab1158758952723701d467a4036898fb99d1cd",
        "title": "fix: Improve add users to org",
        "merged_at": "2025-11-21T15:18:41Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25314",
        "test_files": [
            "packages/features/ee/dsync/lib/handleUserEvents.test.ts"
        ],
        "code_files": [
            "packages/features/ee/dsync/lib/handleUserEvents.ts"
        ],
        "total_changes": 436,
        "num_files": 2,
        "pull_number": 25314,
        "patch": "diff --git a/packages/features/ee/dsync/lib/handleUserEvents.test.ts b/packages/features/ee/dsync/lib/handleUserEvents.test.ts\nnew file mode 100644\nindex 00000000000000..fd4cf4eae5421b\n--- /dev/null\n+++ b/packages/features/ee/dsync/lib/handleUserEvents.test.ts\n@@ -0,0 +1,433 @@\n+import prismock from \"../../../../../tests/libs/__mocks__/prisma\";\n+\n+import type { DirectorySyncEvent } from \"@boxyhq/saml-jackson\";\n+import { describe, expect, it, vi, beforeEach } from \"vitest\";\n+\n+import { IdentityProvider, MembershipRole } from \"@calcom/prisma/enums\";\n+\n+import handleUserEvents from \"./handleUserEvents\";\n+\n+vi.mock(\"@calcom/lib/logger\", () => ({\n+  default: {\n+    getSubLogger: () => ({\n+      debug: vi.fn(),\n+      error: vi.fn(),\n+      warn: vi.fn(),\n+    }),\n+  },\n+}));\n+\n+vi.mock(\"@calcom/lib/server/i18n\", () => ({\n+  getTranslation: vi.fn().mockResolvedValue((key: string) => key),\n+}));\n+\n+vi.mock(\"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\", () => ({\n+  getTeamOrThrow: vi.fn(),\n+  sendExistingUserTeamInviteEmails: vi.fn(),\n+  sendSignupToOrganizationEmail: vi.fn(),\n+}));\n+\n+vi.mock(\"./assignValueToUser\", () => ({\n+  assignValueToUserInOrgBulk: vi.fn(),\n+}));\n+\n+vi.mock(\"./users/createUsersAndConnectToOrg\", () => ({\n+  default: vi.fn(),\n+}));\n+\n+vi.mock(\"./users/inviteExistingUserToOrg\", () => ({\n+  default: vi.fn().mockResolvedValue({\n+    id: 1,\n+    username: \"testuser\",\n+    email: \"test@example.com\",\n+  }),\n+}));\n+\n+vi.mock(\"./removeUserFromOrg\", () => ({\n+  default: vi.fn(),\n+}));\n+\n+vi.mock(\"@calcom/features/users/repositories/UserRepository\", () => ({\n+  UserRepository: vi.fn().mockImplementation(() => ({\n+    isAMemberOfOrganization: vi.fn().mockResolvedValue(false),\n+  })),\n+}));\n+\n+async function createMockOrganization({ id, name, slug }: { id: number; name: string; slug: string }) {\n+  return prismock.team.create({\n+    data: {\n+      id,\n+      name,\n+      slug,\n+      isOrganization: true,\n+    },\n+  });\n+}\n+\n+async function createMockUser({ email, organizationId }: { email: string; organizationId: number | null }) {\n+  return prismock.user.create({\n+    data: {\n+      email,\n+      username: email.split(\"@\")[0],\n+      organizationId,\n+      completedOnboarding: true,\n+      identityProvider: IdentityProvider.CAL,\n+      locale: \"en\",\n+    },\n+  });\n+}\n+\n+async function createMockMembership({\n+  userId,\n+  teamId,\n+  role = MembershipRole.MEMBER,\n+}: {\n+  userId: number;\n+  teamId: number;\n+  role?: MembershipRole;\n+}) {\n+  return prismock.membership.create({\n+    data: {\n+      userId,\n+      teamId,\n+      role,\n+      accepted: true,\n+      disableImpersonation: false,\n+    },\n+  });\n+}\n+\n+describe(\"handleUserEvents\", () => {\n+  const directoryId = \"test-directory-id\";\n+  const organizationId = 1001;\n+  const organizationName = \"Test Organization\";\n+  const organizationSlug = \"test-org\";\n+\n+  beforeEach(async () => {\n+    vi.clearAllMocks();\n+\n+    await createMockOrganization({\n+      id: organizationId,\n+      name: organizationName,\n+      slug: organizationSlug,\n+    });\n+\n+    const { getTeamOrThrow } = await import(\"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\");\n+    vi.mocked(getTeamOrThrow).mockResolvedValue({\n+      id: organizationId,\n+      name: organizationName,\n+      slug: organizationSlug,\n+      isOrganization: true,\n+      parent: null,\n+      parentId: null,\n+      metadata: null,\n+    } as Awaited<ReturnType<typeof getTeamOrThrow>>);\n+  });\n+\n+  describe(\"Cross-tenant hijack prevention\", () => {\n+    it(\"should throw an error when user belongs to a different organization\", async () => {\n+      const userEmail = \"user@example.com\";\n+      const differentOrgId = 2002;\n+\n+      await createMockOrganization({\n+        id: differentOrgId,\n+        name: \"Different Organization\",\n+        slug: \"different-org\",\n+      });\n+\n+      await createMockUser({\n+        email: userEmail,\n+        organizationId: 9999,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.created\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      await expect(handleUserEvents(event, organizationId)).rejects.toThrow(\n+        \"User belongs to another organization.\"\n+      );\n+    });\n+\n+    it(\"should succeed when user belongs to the correct organization\", async () => {\n+      const userEmail = \"user@example.com\";\n+\n+      const user = await createMockUser({\n+        email: userEmail,\n+        organizationId: organizationId,\n+      });\n+\n+      await createMockMembership({\n+        userId: user.id,\n+        teamId: organizationId,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.created\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      const { UserRepository } = await import(\"@calcom/features/users/repositories/UserRepository\");\n+      vi.mocked(UserRepository).mockImplementation(\n+        () =>\n+          ({\n+            isAMemberOfOrganization: vi.fn().mockResolvedValue(true),\n+          } as unknown as InstanceType<typeof UserRepository>)\n+      );\n+\n+      await expect(handleUserEvents(event, organizationId)).resolves.not.toThrow();\n+    });\n+\n+    it(\"should pass when user has no organizationId (allow existing user to be added to an org)\", async () => {\n+      const userEmail = \"legacy@example.com\";\n+\n+      await createMockUser({\n+        email: userEmail,\n+        organizationId: null,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.created\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Legacy\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      await expect(handleUserEvents(event, organizationId)).resolves.toBeUndefined();\n+    });\n+\n+    it(\"should succeed when user does not exist yet (new user creation)\", async () => {\n+      const userEmail = \"newuser@example.com\";\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.created\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"New\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      const createUsersAndConnectToOrg = (await import(\"./users/createUsersAndConnectToOrg\")).default;\n+      vi.mocked(createUsersAndConnectToOrg).mockResolvedValue(undefined);\n+\n+      await expect(handleUserEvents(event, organizationId)).resolves.not.toThrow();\n+\n+      expect(createUsersAndConnectToOrg).toHaveBeenCalledWith({\n+        createUsersAndConnectToOrgProps: {\n+          emailsToCreate: [userEmail],\n+          identityProvider: IdentityProvider.CAL,\n+          identityProviderId: null,\n+        },\n+        org: expect.objectContaining({\n+          id: organizationId,\n+          name: organizationName,\n+        }),\n+      });\n+    });\n+  });\n+\n+  describe(\"User activation and deactivation\", () => {\n+    it(\"should invite existing user when active is true and user is not a member\", async () => {\n+      const userEmail = \"user@example.com\";\n+\n+      await createMockUser({\n+        email: userEmail,\n+        organizationId: organizationId,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.updated\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      const { UserRepository } = await import(\"@calcom/features/users/repositories/UserRepository\");\n+      vi.mocked(UserRepository).mockImplementation(\n+        () =>\n+          ({\n+            isAMemberOfOrganization: vi.fn().mockResolvedValue(false),\n+          } as unknown as InstanceType<typeof UserRepository>)\n+      );\n+\n+      const inviteExistingUserToOrg = (await import(\"./users/inviteExistingUserToOrg\")).default;\n+      const sendExistingUserTeamInviteEmails = (\n+        await import(\"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\")\n+      ).sendExistingUserTeamInviteEmails;\n+\n+      await handleUserEvents(event, organizationId);\n+\n+      expect(inviteExistingUserToOrg).toHaveBeenCalled();\n+      expect(sendExistingUserTeamInviteEmails).toHaveBeenCalled();\n+    });\n+\n+    it(\"should remove user from organization when active is false\", async () => {\n+      const userEmail = \"user@example.com\";\n+\n+      const user = await createMockUser({\n+        email: userEmail,\n+        organizationId: organizationId,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.updated\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: false,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      const removeUserFromOrg = (await import(\"./removeUserFromOrg\")).default;\n+\n+      await handleUserEvents(event, organizationId);\n+\n+      expect(removeUserFromOrg).toHaveBeenCalledWith({\n+        userId: user.id,\n+        orgId: organizationId,\n+      });\n+    });\n+\n+    it(\"should sync custom attributes when user is already a member and active\", async () => {\n+      const userEmail = \"user@example.com\";\n+\n+      const user = await createMockUser({\n+        email: userEmail,\n+        organizationId: organizationId,\n+      });\n+\n+      await createMockMembership({\n+        userId: user.id,\n+        teamId: organizationId,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.updated\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [\"custom:enterprise\"],\n+            \"custom:enterprise\": {\n+              department: \"Engineering\",\n+            },\n+          },\n+        },\n+      };\n+\n+      const { UserRepository } = await import(\"@calcom/features/users/repositories/UserRepository\");\n+      vi.mocked(UserRepository).mockImplementation(\n+        () =>\n+          ({\n+            isAMemberOfOrganization: vi.fn().mockResolvedValue(true),\n+          } as unknown as InstanceType<typeof UserRepository>)\n+      );\n+\n+      const { assignValueToUserInOrgBulk } = await import(\"./assignValueToUser\");\n+\n+      await handleUserEvents(event, organizationId);\n+\n+      expect(assignValueToUserInOrgBulk).toHaveBeenCalledWith({\n+        orgId: organizationId,\n+        userId: user.id,\n+        attributeLabelToValueMap: {\n+          department: \"Engineering\",\n+        },\n+        updater: {\n+          dsyncId: directoryId,\n+        },\n+      });\n+    });\n+  });\n+\n+  describe(\"Error handling\", () => {\n+    it(\"should throw an error when organization is not found\", async () => {\n+      const userEmail = \"user@example.com\";\n+      const nonExistentOrgId = 9999;\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.created\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      const { getTeamOrThrow } = await import(\"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\");\n+      vi.mocked(getTeamOrThrow).mockResolvedValue(\n+        null as unknown as Awaited<ReturnType<typeof getTeamOrThrow>>\n+      );\n+\n+      await expect(handleUserEvents(event, nonExistentOrgId)).rejects.toThrow(\"Org not found\");\n+    });\n+  });\n+});\ndiff --git a/packages/features/ee/dsync/lib/handleUserEvents.ts b/packages/features/ee/dsync/lib/handleUserEvents.ts\nindex bee2c1fe67343a..d117a2fadd42af 100644\n--- a/packages/features/ee/dsync/lib/handleUserEvents.ts\n+++ b/packages/features/ee/dsync/lib/handleUserEvents.ts\n@@ -78,6 +78,9 @@ const handleUserEvents = async (event: DirectorySyncEvent, organizationId: numbe\n   }\n \n   if (user) {\n+    if (user.organizationId && user.organizationId !== org.id) {\n+      throw new Error(\"User belongs to another organization.\");\n+    }\n     if (eventData.active) {\n       if (await new UserRepository(prisma).isAMemberOfOrganization({ user, organizationId })) {\n         await syncCustomAttributesToUser({\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}