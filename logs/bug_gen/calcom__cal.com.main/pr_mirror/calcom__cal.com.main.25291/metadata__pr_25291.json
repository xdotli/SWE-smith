{
    "cost": 0.72996,
    "rewrites": {
        "calcom__cal.com.main/packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts": {
            "output": "import type { TFunction } from \"i18next\";\n\nimport { sendOrganizationCreationEmail } from \"@calcom/emails/organization-email-service\";\nimport { sendEmailVerification } from \"@calcom/features/auth/lib/verifyEmail\";\nimport { getOrgFullOrigin } from \"@calcom/features/ee/organizations/lib/orgDomains\";\nimport {\n  assertCanCreateOrg,\n  findUserToBeOrgOwner,\n  setupDomain,\n} from \"@calcom/features/ee/organizations/lib/server/orgCreationUtils\";\nimport { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport { DEFAULT_SCHEDULE, getAvailabilityFromSchedule } from \"@calcom/lib/availability\";\nimport { WEBAPP_URL } from \"@calcom/lib/constants\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { uploadLogo } from \"@calcom/lib/server/avatar\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { OrganizationOnboardingRepository } from \"@calcom/lib/server/repository/organizationOnboarding\";\nimport { isBase64Image, resizeBase64Image } from \"@calcom/lib/server/resizeBase64Image\";\nimport slugify from \"@calcom/lib/slugify\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Prisma, Team, User } from \"@calcom/prisma/client\";\nimport { CreationSource, MembershipRole, UserPermissionRole } from \"@calcom/prisma/enums\";\nimport { userMetadata, teamMetadataStrictSchema } from \"@calcom/prisma/zod-utils\";\nimport { createTeamsHandler } from \"@calcom/trpc/server/routers/viewer/organizations/createTeams.handler\";\nimport { inviteMembersWithNoInviterPermissionCheck } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/inviteMember.handler\";\n\nimport { OrganizationPaymentService } from \"../../OrganizationPaymentService\";\nimport { OrganizationPermissionService } from \"../../OrganizationPermissionService\";\nimport type { IOrganizationOnboardingService } from \"./IOrganizationOnboardingService\";\nimport type {\n  TeamInput,\n  InvitedMemberInput,\n  CreateOnboardingIntentInput,\n  OnboardingUser,\n  OrganizationData,\n  TeamData,\n  InvitedMember,\n  OrganizationOnboardingData,\n  OnboardingIntentResult,\n} from \"./types\";\n\nconst log = logger.getSubLogger({ prefix: [\"BaseOnboardingService\"] });\n\nexport abstract class BaseOnboardingService implements IOrganizationOnboardingService {\n  protected user: OnboardingUser;\n  protected paymentService: OrganizationPaymentService;\n  protected permissionService: OrganizationPermissionService;\n\n  constructor(\n    user: OnboardingUser,\n    paymentService?: OrganizationPaymentService,\n    permissionService?: OrganizationPermissionService\n  ) {\n    this.user = user;\n    this.paymentService = paymentService || new OrganizationPaymentService(user);\n    this.permissionService = permissionService || new OrganizationPermissionService(user);\n  }\n\n  abstract createOnboardingIntent(input: CreateOnboardingIntentInput): Promise<OnboardingIntentResult>;\n  abstract createOrganization(\n    organizationOnboarding: OrganizationOnboardingData,\n    paymentDetails?: { subscriptionId: string; subscriptionItemId: string }\n  ): Promise<{ organization: Team; owner: User }>;\n\n  protected async createOnboardingRecord(input: CreateOnboardingIntentInput & { onboardingId?: string }) {\n    const processedAssets = await this.processOnboardingBrandAssets({\n      logo: input.logo,\n      bannerUrl: input.bannerUrl,\n    });\n\n    if (input.onboardingId) {\n      log.debug(\n        \"Updating existing organization onboarding record (resume flow)\",\n        safeStringify({\n          onboardingId: input.onboardingId,\n          slug: input.slug,\n          name: input.name,\n        })\n      );\n\n      const updateData: {\n        logo?: string | null;\n        bio?: string | null;\n        brandColor?: string | null;\n        bannerUrl?: string | null;\n        teams?: TeamData[];\n        invitedMembers?: InvitedMember[];\n      } = {\n        bio: input.bio ?? null,\n        brandColor: input.brandColor ?? null,\n        teams: input.teams ?? [],\n        invitedMembers: input.invitedMembers ?? [],\n      };\n\n      if (processedAssets.logo !== undefined) {\n        updateData.logo = processedAssets.logo;\n      }\n      if (processedAssets.bannerUrl !== undefined) {\n        updateData.bannerUrl = processedAssets.bannerUrl;\n      }\n\n      await OrganizationOnboardingRepository.update(input.onboardingId, updateData);\n\n      const updatedOnboarding = await OrganizationOnboardingRepository.findById(input.onboardingId);\n      if (!updatedOnboarding) {\n        throw new Error(`Onboarding record ${input.onboardingId} not found after update`);\n      }\n\n      log.debug(\"Organization onboarding updated\", safeStringify({ onboardingId: updatedOnboarding.id }));\n      return updatedOnboarding;\n    }\n\n    log.debug(\n      \"Creating organization onboarding record\",\n      safeStringify({\n        slug: input.slug,\n        name: input.name,\n        orgOwnerEmail: input.orgOwnerEmail,\n        isPlatform: input.isPlatform,\n      })\n    );\n\n    const organizationOnboarding = await this.paymentService.createOrganizationOnboarding({\n      name: input.name,\n      slug: input.slug,\n      orgOwnerEmail: input.orgOwnerEmail,\n      seats: input.seats,\n      pricePerSeat: input.pricePerSeat,\n      billingPeriod: input.billingPeriod,\n      createdByUserId: this.user.id,\n      logo: processedAssets.logo ?? null,\n      bio: input.bio ?? null,\n      brandColor: input.brandColor ?? null,\n      bannerUrl: processedAssets.bannerUrl ?? null,\n      teams: input.teams ?? [],\n      invitedMembers: input.invitedMembers ?? [],\n    });\n\n    log.debug(\"Organization onboarding created\", safeStringify({ onboardingId: organizationOnboarding.id }));\n\n    return organizationOnboarding;\n  }\n\n  protected filterTeamsAndInvites(teams: TeamInput[] = [], invitedMembers: InvitedMemberInput[] = []) {\n    const teamsData = teams\n      .filter((team) => team.name.trim().length > 0)\n      .map((team) => ({\n        id: team.id === -1 ? -1 : team.id,\n        name: team.name,\n        isBeingMigrated: team.isBeingMigrated,\n        slug: team.slug,\n      }));\n\n    const invitedMembersData = invitedMembers\n      .filter((invite) => invite.email.trim().length > 0)\n      .map((invite) => ({\n        email: invite.email,\n        name: invite.name,\n        teamId: invite.teamId,\n        teamName: invite.teamName,\n        role: invite.role,\n      }));\n\n    return { teamsData, invitedMembersData };\n  }\n\n  protected handleAdminHandoverIfNeeded(\n    input: CreateOnboardingIntentInput,\n    onboardingId: string\n  ): OnboardingIntentResult | null {\n    const isAdminHandoverFlow =\n      this.user.role === UserPermissionRole.ADMIN &&\n      this.user.email !== input.orgOwnerEmail &&\n      (!input.teams || input.teams.length === 0) &&\n      (!input.invitedMembers || input.invitedMembers.length === 0);\n\n    log.debug(\n      \"Checking admin handover flow\",\n      safeStringify({\n        userRole: this.user.role,\n        isAdmin: this.user.role === UserPermissionRole.ADMIN,\n        userEmail: this.user.email,\n        orgOwnerEmail: input.orgOwnerEmail,\n        emailsDifferent: this.user.email !== input.orgOwnerEmail,\n        teamsEmpty: !input.teams || input.teams.length === 0,\n        membersEmpty: !input.invitedMembers || input.invitedMembers.length === 0,\n        isAdminHandoverFlow,\n      })\n    );\n\n    if (!isAdminHandoverFlow) {\n      return null;\n    }\n\n    log.debug(\n      \"Admin handover flow detected\",\n      safeStringify({ adminEmail: this.user.email, orgOwnerEmail: input.orgOwnerEmail })\n    );\n\n    return {\n      userId: this.user.id,\n      orgOwnerEmail: input.orgOwnerEmail,\n      name: input.name,\n      slug: input.slug,\n      seats: input.seats ?? null,\n      pricePerSeat: input.pricePerSeat ?? null,\n      billingPeriod: input.billingPeriod,\n      isPlatform: input.isPlatform,\n      organizationOnboardingId: onboardingId,\n      checkoutUrl: null,\n      organizationId: null,\n      handoverUrl: `${WEBAPP_URL}/settings/organizations/new/resume?onboardingId=${onboardingId}`,\n    };\n  }\n\n  protected isAdminCreatingForSelf(input: { orgOwnerEmail: string }): boolean {\n    return this.user.role === UserPermissionRole.ADMIN && this.user.email === input.orgOwnerEmail;\n  }\n\n  private async processOnboardingBrandAssets(input: {\n    logo?: string | null;\n    bannerUrl?: string | null;\n  }): Promise<{ logo?: string | null; bannerUrl?: string | null }> {\n    const [logo, bannerUrl] = await Promise.all([\n      input.logo ? resizeBase64Image(input.logo) : Promise.resolve(input.logo),\n      input.bannerUrl ? resizeBase64Image(input.bannerUrl, { maxSize: 1500 }) : Promise.resolve(input.bannerUrl),\n    ]);\n\n    return { logo, bannerUrl };\n  }\n\n  private async uploadImageAsset({\n    image,\n    teamId,\n    isBanner = false,\n  }: {\n    image: string;\n    teamId: number;\n    isBanner?: boolean;\n  }): Promise<string> {\n    if (!isBase64Image(image)) {\n      return image;\n    }\n\n    return await uploadLogo({\n      logo: image,\n      teamId,\n      isBanner,\n    });\n  }\n\n  protected async uploadOrganizationBrandAssets({\n    logoUrl,\n    bannerUrl,\n    organizationId,\n  }: {\n    logoUrl?: string | null;\n    bannerUrl?: string | null;\n    organizationId: number;\n  }): Promise<{\n    logoUrl?: string | null;\n    bannerUrl?: string | null;\n  }> {\n    const uploadedLogoUrl = logoUrl ? await this.uploadImageAsset({ image: logoUrl, teamId: organizationId }) : logoUrl;\n\n    const uploadedBannerUrl = bannerUrl\n      ? await this.uploadImageAsset({ image: bannerUrl, teamId: organizationId, isBanner: true })\n      : bannerUrl;\n\n    if (uploadedLogoUrl === undefined && uploadedBannerUrl === undefined) {\n      return {\n        logoUrl,\n        bannerUrl,\n      };\n    }\n\n    return await prisma.team.update({\n      where: { id: organizationId },\n      data: {\n        logoUrl: uploadedLogoUrl,\n        bannerUrl: uploadedBannerUrl,\n      },\n      select: {\n        logoUrl: true,\n        bannerUrl: true,\n      },\n    });\n  }\n\n  protected async createOrganizationWithExistingUserAsOwner({\n    owner,\n    orgData,\n  }: {\n    owner: NonNullable<Awaited<ReturnType<typeof findUserToBeOrgOwner>>>;\n    orgData: OrganizationData;\n  }) {\n    const organizationRepository = getOrganizationRepository();\n    const orgOwnerTranslation = await getTranslation(owner.locale || \"en\", \"common\");\n    let organization = orgData.id ? await organizationRepository.findById({ id: orgData.id }) : null;\n\n    if (organization) {\n      log.info(\n        `Reusing existing organization:`,\n        safeStringify({\n          slug: orgData.slug,\n          id: organization.id,\n        })\n      );\n      return { organization };\n    }\n\n    const { slugConflictType } = await assertCanCreateOrg({\n      slug: orgData.slug,\n      isPlatform: orgData.isPlatform,\n      orgOwner: owner,\n      errorOnUserAlreadyPartOfOrg: false,\n      restrictBasedOnMinimumPublishedTeams: false,\n    });\n\n    const canSetSlug = slugConflictType === \"teamUserIsMemberOfExists\" ? false : true;\n\n    log.info(\n      `Creating organization for owner ${owner.email} with slug ${orgData.slug} and canSetSlug=${canSetSlug}`\n    );\n\n    try {\n      const nonOrgUsername = owner.username || \"\";\n\n      // Create organization first to get the ID\n      const orgCreationResult = await organizationRepository.createWithExistingUserAsOwner({\n        orgData: {\n          ...orgData,\n          // Don't pass brand assets yet - will be uploaded after org is created\n          logoUrl: null,\n          bannerUrl: null,\n          ...(canSetSlug ? { slug: orgData.slug } : { slug: null, requestedSlug: orgData.slug }),\n        },\n        owner: {\n          id: owner.id,\n          email: owner.email,\n          nonOrgUsername,\n        },\n      });\n\n      organization = {\n        ...orgCreationResult.organization,\n        ...await this.uploadOrganizationBrandAssets({\n          logoUrl: orgData.logoUrl,\n          bannerUrl: orgData.bannerUrl,\n          organizationId: orgCreationResult.organization.id,\n        })\n      };\n\n      const ownerProfile = orgCreationResult.ownerProfile;\n      if (!orgData.isPlatform) {\n        await sendOrganizationCreationEmail({\n          language: orgOwnerTranslation,\n          from: `${organization.name}'s admin`,\n          to: owner.email,\n          ownerNewUsername: ownerProfile.username,\n          ownerOldUsername: nonOrgUsername,\n          orgDomain: getOrgFullOrigin(orgData.slug, { protocol: false }),\n          orgName: organization.name,\n          prevLink: `${getOrgFullOrigin(\"\", { protocol: true })}/${owner.username || \"\"}`,\n          newLink: `${getOrgFullOrigin(orgData.slug, { protocol: true })}/${ownerProfile.username}`,\n        });\n      }\n\n      const availability = getAvailabilityFromSchedule(DEFAULT_SCHEDULE);\n      await prisma.availability.createMany({\n        data: availability.map((schedule) => ({\n          days: schedule.days,\n          startTime: schedule.startTime,\n          endTime: schedule.endTime,\n          userId: owner.id,\n        })),\n      });\n    } catch (error) {\n      log.error(\n        `RecoverableError: Error creating organization for owner ${owner.email}.`,\n        safeStringify(error)\n      );\n      throw error;\n    }\n\n    return { organization };\n  }\n\n  protected async createOrganizationWithNonExistentUserAsOw",
            "output_extracted": "import type { TFunction } from \"i18next\";\n\nimport { sendOrganizationCreationEmail } from \"@calcom/emails/organization-email-service\";\nimport { sendEmailVerification } from \"@calcom/features/auth/lib/verifyEmail\";\nimport { getOrgFullOrigin } from \"@calcom/features/ee/organizations/lib/orgDomains\";\nimport {\n  assertCanCreateOrg,\n  findUserToBeOrgOwner,\n  setupDomain,\n} from \"@calcom/features/ee/organizations/lib/server/orgCreationUtils\";\nimport { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\nimport { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport { DEFAULT_SCHEDULE, getAvailabilityFromSchedule } from \"@calcom/lib/availability\";\nimport { WEBAPP_URL } from \"@calcom/lib/constants\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { uploadLogo } from \"@calcom/lib/server/avatar\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { OrganizationOnboardingRepository } from \"@calcom/lib/server/repository/organizationOnboarding\";\nimport { isBase64Image, resizeBase64Image } from \"@calcom/lib/server/resizeBase64Image\";\nimport slugify from \"@calcom/lib/slugify\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Prisma, Team, User } from \"@calcom/prisma/client\";\nimport { CreationSource, MembershipRole, UserPermissionRole } from \"@calcom/prisma/enums\";\nimport { userMetadata, teamMetadataStrictSchema } from \"@calcom/prisma/zod-utils\";\nimport { createTeamsHandler } from \"@calcom/trpc/server/routers/viewer/organizations/createTeams.handler\";\nimport { inviteMembersWithNoInviterPermissionCheck } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/inviteMember.handler\";\n\nimport { OrganizationPaymentService } from \"../../OrganizationPaymentService\";\nimport { OrganizationPermissionService } from \"../../OrganizationPermissionService\";\nimport type { IOrganizationOnboardingService } from \"./IOrganizationOnboardingService\";\nimport type {\n  TeamInput,\n  InvitedMemberInput,\n  CreateOnboardingIntentInput,\n  OnboardingUser,\n  OrganizationData,\n  TeamData,\n  InvitedMember,\n  OrganizationOnboardingData,\n  OnboardingIntentResult,\n} from \"./types\";\n\nconst log = logger.getSubLogger({ prefix: [\"BaseOnboardingService\"] });\n\nexport abstract class BaseOnboardingService implements IOrganizationOnboardingService {\n  protected user: OnboardingUser;\n  protected paymentService: OrganizationPaymentService;\n  protected permissionService: OrganizationPermissionService;\n\n  constructor(\n    user: OnboardingUser,\n    paymentService?: OrganizationPaymentService,\n    permissionService?: OrganizationPermissionService\n  ) {\n    this.user = user;\n    this.paymentService = paymentService || new OrganizationPaymentService(user);\n    this.permissionService = permissionService || new OrganizationPermissionService(user);\n  }\n\n  abstract createOnboardingIntent(input: CreateOnboardingIntentInput): Promise<OnboardingIntentResult>;\n  abstract createOrganization(\n    organizationOnboarding: OrganizationOnboardingData,\n    paymentDetails?: { subscriptionId: string; subscriptionItemId: string }\n  ): Promise<{ organization: Team; owner: User }>;\n\n  protected async createOnboardingRecord(input: CreateOnboardingIntentInput & { onboardingId?: string }) {\n    const processedAssets = await this.processOnboardingBrandAssets({\n      logo: input.logo,\n      bannerUrl: input.bannerUrl,\n    });\n\n    if (input.onboardingId) {\n      log.debug(\n        \"Updating existing organization onboarding record (resume flow)\",\n        safeStringify({\n          onboardingId: input.onboardingId,\n          slug: input.slug,\n          name: input.name,\n        })\n      );\n\n      const updateData: {\n        logo?: string | null;\n        bio?: string | null;\n        brandColor?: string | null;\n        bannerUrl?: string | null;\n        teams?: TeamData[];\n        invitedMembers?: InvitedMember[];\n      } = {\n        bio: input.bio ?? null,\n        brandColor: input.brandColor ?? null,\n        teams: input.teams ?? [],\n        invitedMembers: input.invitedMembers ?? [],\n      };\n\n      if (processedAssets.logo !== undefined) {\n        updateData.logo = processedAssets.logo;\n      }\n      if (processedAssets.bannerUrl !== undefined) {\n        updateData.bannerUrl = processedAssets.bannerUrl;\n      }\n\n      await OrganizationOnboardingRepository.update(input.onboardingId, updateData);\n\n      const updatedOnboarding = await OrganizationOnboardingRepository.findById(input.onboardingId);\n      if (!updatedOnboarding) {\n        throw new Error(`Onboarding record ${input.onboardingId} not found after update`);\n      }\n\n      log.debug(\"Organization onboarding updated\", safeStringify({ onboardingId: updatedOnboarding.id }));\n      return updatedOnboarding;\n    }\n\n    log.debug(\n      \"Creating organization onboarding record\",\n      safeStringify({\n        slug: input.slug,\n        name: input.name,\n        orgOwnerEmail: input.orgOwnerEmail,\n        isPlatform: input.isPlatform,\n      })\n    );\n\n    const organizationOnboarding = await this.paymentService.createOrganizationOnboarding({\n      name: input.name,\n      slug: input.slug,\n      orgOwnerEmail: input.orgOwnerEmail,\n      seats: input.seats,\n      pricePerSeat: input.pricePerSeat,\n      billingPeriod: input.billingPeriod,\n      createdByUserId: this.user.id,\n      logo: processedAssets.logo ?? null,\n      bio: input.bio ?? null,\n      brandColor: input.brandColor ?? null,\n      bannerUrl: processedAssets.bannerUrl ?? null,\n      teams: input.teams ?? [],\n      invitedMembers: input.invitedMembers ?? [],\n    });\n\n    log.debug(\"Organization onboarding created\", safeStringify({ onboardingId: organizationOnboarding.id }));\n\n    return organizationOnboarding;\n  }\n\n  protected filterTeamsAndInvites(teams: TeamInput[] = [], invitedMembers: InvitedMemberInput[] = []) {\n    const teamsData = teams\n      .filter((team) => team.name.trim().length > 0)\n      .map((team) => ({\n        id: team.id === -1 ? -1 : team.id,\n        name: team.name,\n        isBeingMigrated: team.isBeingMigrated,\n        slug: team.slug,\n      }));\n\n    const invitedMembersData = invitedMembers\n      .filter((invite) => invite.email.trim().length > 0)\n      .map((invite) => ({\n        email: invite.email,\n        name: invite.name,\n        teamId: invite.teamId,\n        teamName: invite.teamName,\n        role: invite.role,\n      }));\n\n    return { teamsData, invitedMembersData };\n  }\n\n  protected handleAdminHandoverIfNeeded(\n    input: CreateOnboardingIntentInput,\n    onboardingId: string\n  ): OnboardingIntentResult | null {\n    const isAdminHandoverFlow =\n      this.user.role === UserPermissionRole.ADMIN &&\n      this.user.email !== input.orgOwnerEmail &&\n      (!input.teams || input.teams.length === 0) &&\n      (!input.invitedMembers || input.invitedMembers.length === 0);\n\n    log.debug(\n      \"Checking admin handover flow\",\n      safeStringify({\n        userRole: this.user.role,\n        isAdmin: this.user.role === UserPermissionRole.ADMIN,\n        userEmail: this.user.email,\n        orgOwnerEmail: input.orgOwnerEmail,\n        emailsDifferent: this.user.email !== input.orgOwnerEmail,\n        teamsEmpty: !input.teams || input.teams.length === 0,\n        membersEmpty: !input.invitedMembers || input.invitedMembers.length === 0,\n        isAdminHandoverFlow,\n      })\n    );\n\n    if (!isAdminHandoverFlow) {\n      return null;\n    }\n\n    log.debug(\n      \"Admin handover flow detected\",\n      safeStringify({ adminEmail: this.user.email, orgOwnerEmail: input.orgOwnerEmail })\n    );\n\n    return {\n      userId: this.user.id,\n      orgOwnerEmail: input.orgOwnerEmail,\n      name: input.name,\n      slug: input.slug,\n      seats: input.seats ?? null,\n      pricePerSeat: input.pricePerSeat ?? null,\n      billingPeriod: input.billingPeriod,\n      isPlatform: input.isPlatform,\n      organizationOnboardingId: onboardingId,\n      checkoutUrl: null,\n      organizationId: null,\n      handoverUrl: `${WEBAPP_URL}/settings/organizations/new/resume?onboardingId=${onboardingId}`,\n    };\n  }\n\n  protected isAdminCreatingForSelf(input: { orgOwnerEmail: string }): boolean {\n    return this.user.role === UserPermissionRole.ADMIN && this.user.email === input.orgOwnerEmail;\n  }\n\n  private async processOnboardingBrandAssets(input: {\n    logo?: string | null;\n    bannerUrl?: string | null;\n  }): Promise<{ logo?: string | null; bannerUrl?: string | null }> {\n    const [logo, bannerUrl] = await Promise.all([\n      input.logo ? resizeBase64Image(input.logo) : Promise.resolve(input.logo),\n      input.bannerUrl ? resizeBase64Image(input.bannerUrl, { maxSize: 1500 }) : Promise.resolve(input.bannerUrl),\n    ]);\n\n    return { logo, bannerUrl };\n  }\n\n  private async uploadImageAsset({\n    image,\n    teamId,\n    isBanner = false,\n  }: {\n    image: string;\n    teamId: number;\n    isBanner?: boolean;\n  }): Promise<string> {\n    if (!isBase64Image(image)) {\n      return image;\n    }\n\n    return await uploadLogo({\n      logo: image,\n      teamId,\n      isBanner,\n    });\n  }\n\n  protected async uploadOrganizationBrandAssets({\n    logoUrl,\n    bannerUrl,\n    organizationId,\n  }: {\n    logoUrl?: string | null;\n    bannerUrl?: string | null;\n    organizationId: number;\n  }): Promise<{\n    logoUrl?: string | null;\n    bannerUrl?: string | null;\n  }> {\n    const uploadedLogoUrl = logoUrl ? await this.uploadImageAsset({ image: logoUrl, teamId: organizationId }) : logoUrl;\n\n    const uploadedBannerUrl = bannerUrl\n      ? await this.uploadImageAsset({ image: bannerUrl, teamId: organizationId, isBanner: true })\n      : bannerUrl;\n\n    if (uploadedLogoUrl === undefined && uploadedBannerUrl === undefined) {\n      return {\n        logoUrl,\n        bannerUrl,\n      };\n    }\n\n    return await prisma.team.update({\n      where: { id: organizationId },\n      data: {\n        logoUrl: uploadedLogoUrl,\n        bannerUrl: uploadedBannerUrl,\n      },\n      select: {\n        logoUrl: true,\n        bannerUrl: true,\n      },\n    });\n  }\n\n  protected async createOrganizationWithExistingUserAsOwner({\n    owner,\n    orgData,\n  }: {\n    owner: NonNullable<Awaited<ReturnType<typeof findUserToBeOrgOwner>>>;\n    orgData: OrganizationData;\n  }) {\n    const organizationRepository = getOrganizationRepository();\n    const orgOwnerTranslation = await getTranslation(owner.locale || \"en\", \"common\");\n    let organization = orgData.id ? await organizationRepository.findById({ id: orgData.id }) : null;\n\n    if (organization) {\n      log.info(\n        `Reusing existing organization:`,\n        safeStringify({\n          slug: orgData.slug,\n          id: organization.id,\n        })\n      );\n      return { organization };\n    }\n\n    const { slugConflictType } = await assertCanCreateOrg({\n      slug: orgData.slug,\n      isPlatform: orgData.isPlatform,\n      orgOwner: owner,\n      errorOnUserAlreadyPartOfOrg: false,\n      restrictBasedOnMinimumPublishedTeams: false,\n    });\n\n    const canSetSlug = slugConflictType === \"teamUserIsMemberOfExists\" ? false : true;\n\n    log.info(\n      `Creating organization for owner ${owner.email} with slug ${orgData.slug} and canSetSlug=${canSetSlug}`\n    );\n\n    try {\n      const nonOrgUsername = owner.username || \"\";\n\n      // Create organization first to get the ID\n      const orgCreationResult = await organizationRepository.createWithExistingUserAsOwner({\n        orgData: {\n          ...orgData,\n          // Don't pass brand assets yet - will be uploaded after org is created\n          logoUrl: null,\n          bannerUrl: null,\n          ...(canSetSlug ? { slug: orgData.slug } : { slug: null, requestedSlug: orgData.slug }),\n        },\n        owner: {\n          id: owner.id,\n          email: owner.email,\n          nonOrgUsername,\n        },\n      });\n\n      organization = {\n        ...orgCreationResult.organization,\n        ...await this.uploadOrganizationBrandAssets({\n          logoUrl: orgData.logoUrl,\n          bannerUrl: orgData.bannerUrl,\n          organizationId: orgCreationResult.organization.id,\n        })\n      };\n\n      const ownerProfile = orgCreationResult.ownerProfile;\n      if (!orgData.isPlatform) {\n        await sendOrganizationCreationEmail({\n          language: orgOwnerTranslation,\n          from: `${organization.name}'s admin`,\n          to: owner.email,\n          ownerNewUsername: ownerProfile.username,\n          ownerOldUsername: nonOrgUsername,\n          orgDomain: getOrgFullOrigin(orgData.slug, { protocol: false }),\n          orgName: organization.name,\n          prevLink: `${getOrgFullOrigin(\"\", { protocol: true })}/${owner.username || \"\"}`,\n          newLink: `${getOrgFullOrigin(orgData.slug, { protocol: true })}/${ownerProfile.username}`,\n        });\n      }\n\n      const availability = getAvailabilityFromSchedule(DEFAULT_SCHEDULE);\n      await prisma.availability.createMany({\n        data: availability.map((schedule) => ({\n          days: schedule.days,\n          startTime: schedule.startTime,\n          endTime: schedule.endTime,\n          userId: owner.id,\n        })),\n      });\n    } catch (error) {\n      log.error(\n        `RecoverableError: Error creating organization for owner ${owner.email}.`,\n        safeStringify(error)\n      );\n      throw error;\n    }\n\n    return { organization };\n  }\n\n  protected async createOrganizationWithNonExistentUserAsOw",
            "cost": 0.1486
        },
        "calcom__cal.com.main/packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts": {
            "output": "import { findUserToBeOrgOwner } from \"@calcom/features/ee/organizations/lib/server/orgCreationUtils\";\nimport { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\nimport { IS_SELF_HOSTED } from \"@calcom/lib/constants\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { OrganizationOnboardingRepository } from \"@calcom/lib/server/repository/organizationOnboarding\";\nimport type { Team, User } from \"@calcom/prisma/client\";\nimport { orgOnboardingInvitedMembersSchema, orgOnboardingTeamsSchema } from \"@calcom/prisma/zod-utils\";\n\nimport { BaseOnboardingService } from \"../onboarding/BaseOnboardingService\";\nimport type {\n  CreateOnboardingIntentInput,\n  OnboardingIntentResult,\n  OrganizationOnboardingData,\n  OrganizationData,\n} from \"../onboarding/types\";\n\nconst log = logger.getSubLogger({ prefix: [\"BillingEnabledOrgOnboardingService\"] });\n\nconst invitedMembersSchema = orgOnboardingInvitedMembersSchema;\nconst teamsSchema = orgOnboardingTeamsSchema;\n\n/**\n * Handles organization onboarding when billing is enabled (Stripe flow).\n *\n * Flow:\n * 1. Create onboarding record\n * 2. Store teams/invites in database\n * 3. Create Stripe checkout session\n * 4. Return checkout URL\n * 5. Organization created later via Stripe webhook\n *\n * Exception: Admin creating org for self - immediately creates organization (no payment required)\n */\nexport class BillingEnabledOrgOnboardingService extends BaseOnboardingService {\n  async createOnboardingIntent(input: CreateOnboardingIntentInput): Promise<OnboardingIntentResult> {\n    log.debug(\n      \"BillingEnabledOrgOnboardingService.createOnboardingIntent - INPUT\",\n      safeStringify({\n        invitedMembers: input.invitedMembers,\n        teams: input.teams,\n      })\n    );\n\n    const { teamsData, invitedMembersData } = this.filterTeamsAndInvites(input.teams, input.invitedMembers);\n\n    log.debug(\n      \"BillingEnabledOrgOnboardingService - After filterTeamsAndInvites\",\n      safeStringify({\n        teamsData,\n        invitedMembersData,\n      })\n    );\n\n    // Create onboarding record with ALL data at once\n    const organizationOnboarding = await this.createOnboardingRecord({\n      ...input,\n      teams: teamsData,\n      invitedMembers: invitedMembersData,\n    });\n    const onboardingId = organizationOnboarding.id;\n\n    // Check if this is an admin handover flow\n    const handoverResult = this.handleAdminHandoverIfNeeded(input, onboardingId);\n    if (handoverResult) {\n      return handoverResult;\n    }\n\n    // Check if admin is creating org for themselves - skip payment, create immediately\n    if (\n      this.isAdminCreatingForSelf({\n        orgOwnerEmail: organizationOnboarding.orgOwnerEmail,\n      })\n    ) {\n      log.debug(\n        \"Admin creating org for self - skipping payment and creating organization immediately\",\n        safeStringify({ adminEmail: this.user.email, onboardingId })\n      );\n\n      const { organization } = await this.createOrganization(organizationOnboarding);\n\n      await OrganizationOnboardingRepository.markAsComplete(onboardingId);\n\n      log.debug(\n        \"Organization created successfully for admin\",\n        safeStringify({ onboardingId, organizationId: organization.id })\n      );\n\n      return {\n        userId: this.user.id,\n        orgOwnerEmail: input.orgOwnerEmail,\n        name: input.name,\n        slug: input.slug,\n        seats: input.seats ?? null,\n        pricePerSeat: input.pricePerSeat ?? null,\n        billingPeriod: input.billingPeriod,\n        isPlatform: input.isPlatform,\n        organizationOnboardingId: onboardingId,\n        checkoutUrl: null,\n        organizationId: organization.id,\n      };\n    }\n\n    // Regular flow - create payment intent\n    const paymentIntent = await this.paymentService.createPaymentIntent(\n      {\n        logo: organizationOnboarding.logo,\n        bio: input.bio ?? null,\n        brandColor: input.brandColor ?? null,\n        bannerUrl: organizationOnboarding.bannerUrl,\n        teams: teamsData,\n        invitedMembers: invitedMembersData,\n      },\n      {\n        id: organizationOnboarding.id,\n        pricePerSeat: organizationOnboarding.pricePerSeat,\n        billingPeriod: organizationOnboarding.billingPeriod,\n        seats: organizationOnboarding.seats,\n        isComplete: organizationOnboarding.isComplete,\n        orgOwnerEmail: organizationOnboarding.orgOwnerEmail,\n        slug: organizationOnboarding.slug,\n        stripeCustomerId: organizationOnboarding.stripeCustomerId,\n      }\n    );\n\n    return {\n      userId: this.user.id,\n      orgOwnerEmail: input.orgOwnerEmail,\n      name: input.name,\n      slug: input.slug,\n      seats: input.seats ?? null,\n      pricePerSeat: input.pricePerSeat ?? null,\n      billingPeriod: input.billingPeriod,\n      isPlatform: input.isPlatform,\n      organizationOnboardingId: onboardingId,\n      checkoutUrl: paymentIntent.checkoutUrl,\n      organizationId: null, // Organization not created yet (pending payment)\n    };\n  }\n\n  async createOrganization(\n    organizationOnboarding: OrganizationOnboardingData,\n    paymentDetails?: { subscriptionId: string; subscriptionItemId: string }\n  ): Promise<{ organization: Team; owner: User }> {\n    const organizationRepository = getOrganizationRepository();\n    log.info(\n      \"createOrganization (billing-enabled)\",\n      safeStringify({\n        orgId: organizationOnboarding.organizationId,\n        orgSlug: organizationOnboarding.slug,\n      })\n    );\n\n    const isAdminForSelf = this.isAdminCreatingForSelf({\n      orgOwnerEmail: organizationOnboarding.orgOwnerEmail,\n    });\n\n    if (\n      !IS_SELF_HOSTED &&\n      !isAdminForSelf &&\n      (!paymentDetails?.subscriptionId || !paymentDetails?.subscriptionItemId)\n    ) {\n      throw new Error(\"payment_subscription_id_and_payment_subscription_item_id_are_required\");\n    }\n\n    if (\n      await this.hasConflictingOrganization({\n        slug: organizationOnboarding.slug,\n        onboardingId: organizationOnboarding.id,\n      })\n    ) {\n      throw new Error(\"organization_already_exists_with_this_slug\");\n    }\n\n    let owner = await findUserToBeOrgOwner(organizationOnboarding.orgOwnerEmail);\n    const orgOwnerTranslation = await getTranslation(owner?.locale || \"en\", \"common\");\n\n    if (!process.env.NEXT_PUBLIC_SINGLE_ORG_SLUG) {\n      await this.handleDomainSetup({\n        organizationOnboarding,\n        orgOwnerTranslation,\n      });\n    }\n\n    const orgData: OrganizationData = {\n      id: organizationOnboarding.organizationId,\n      name: organizationOnboarding.name,\n      slug: organizationOnboarding.slug,\n      isOrganizationConfigured: true,\n      isOrganizationAdminReviewed: true,\n      autoAcceptEmail: organizationOnboarding.orgOwnerEmail.split(\"@\")[1],\n      seats: organizationOnboarding.seats,\n      pricePerSeat: organizationOnboarding.pricePerSeat,\n      isPlatform: false,\n      billingPeriod: organizationOnboarding.billingPeriod,\n      logoUrl: organizationOnboarding.logo,\n      bio: organizationOnboarding.bio,\n      brandColor: organizationOnboarding.brandColor,\n      bannerUrl: organizationOnboarding.bannerUrl,\n    };\n\n    let organization: Team;\n    if (!owner) {\n      const result = await this.createOrganizationWithNonExistentUserAsOwner({\n        email: organizationOnboarding.orgOwnerEmail,\n        orgData,\n      });\n      organization = result.organization;\n      owner = result.owner;\n    } else {\n      const result = await this.createOrganizationWithExistingUserAsOwner({\n        orgData,\n        owner,\n      });\n      organization = result.organization;\n    }\n\n    if (organizationOnboarding.stripeCustomerId) {\n      await this.ensureStripeCustomerIdIsUpdated({\n        owner,\n        stripeCustomerId: organizationOnboarding.stripeCustomerId,\n      });\n    }\n\n    await OrganizationOnboardingRepository.update(organizationOnboarding.id, {\n      organizationId: organization.id,\n    });\n\n    const updatedOrganization = await this.backwardCompatibilityForSubscriptionDetails({\n      organization,\n      paymentSubscriptionId: paymentDetails?.subscriptionId,\n      paymentSubscriptionItemId: paymentDetails?.subscriptionItemId,\n    });\n\n    organization.metadata = updatedOrganization.metadata;\n\n    const teamsData = teamsSchema.parse(organizationOnboarding.teams);\n    await this.createOrMoveTeamsToOrganization(teamsData, owner, organization.id);\n\n    await this.inviteMembers(\n      invitedMembersSchema.parse(organizationOnboarding.invitedMembers),\n      organization,\n      teamsData\n    );\n\n    if (!organization.slug) {\n      try {\n        const { slug } = await organizationRepository.setSlug({\n          id: organization.id,\n          slug: organizationOnboarding.slug,\n        });\n        organization.slug = slug;\n      } catch (error) {\n        log.error(\n          \"RecoverableError: Error while setting slug for organization\",\n          safeStringify(error),\n          safeStringify({\n            attemptedSlug: organizationOnboarding.slug,\n            organizationId: organization.id,\n          })\n        );\n        throw new Error(\n          `Unable to set slug '${organizationOnboarding.slug}' for organization ${organization.id}`\n        );\n      }\n    }\n\n    return { organization, owner };\n  }\n}",
            "output_extracted": "import { findUserToBeOrgOwner } from \"@calcom/features/ee/organizations/lib/server/orgCreationUtils\";\nimport { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\nimport { IS_SELF_HOSTED } from \"@calcom/lib/constants\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { OrganizationOnboardingRepository } from \"@calcom/lib/server/repository/organizationOnboarding\";\nimport type { Team, User } from \"@calcom/prisma/client\";\nimport { orgOnboardingInvitedMembersSchema, orgOnboardingTeamsSchema } from \"@calcom/prisma/zod-utils\";\n\nimport { BaseOnboardingService } from \"../onboarding/BaseOnboardingService\";\nimport type {\n  CreateOnboardingIntentInput,\n  OnboardingIntentResult,\n  OrganizationOnboardingData,\n  OrganizationData,\n} from \"../onboarding/types\";\n\nconst log = logger.getSubLogger({ prefix: [\"BillingEnabledOrgOnboardingService\"] });\n\nconst invitedMembersSchema = orgOnboardingInvitedMembersSchema;\nconst teamsSchema = orgOnboardingTeamsSchema;\n\n/**\n * Handles organization onboarding when billing is enabled (Stripe flow).\n *\n * Flow:\n * 1. Create onboarding record\n * 2. Store teams/invites in database\n * 3. Create Stripe checkout session\n * 4. Return checkout URL\n * 5. Organization created later via Stripe webhook\n *\n * Exception: Admin creating org for self - immediately creates organization (no payment required)\n */\nexport class BillingEnabledOrgOnboardingService extends BaseOnboardingService {\n  async createOnboardingIntent(input: CreateOnboardingIntentInput): Promise<OnboardingIntentResult> {\n    log.debug(\n      \"BillingEnabledOrgOnboardingService.createOnboardingIntent - INPUT\",\n      safeStringify({\n        invitedMembers: input.invitedMembers,\n        teams: input.teams,\n      })\n    );\n\n    const { teamsData, invitedMembersData } = this.filterTeamsAndInvites(input.teams, input.invitedMembers);\n\n    log.debug(\n      \"BillingEnabledOrgOnboardingService - After filterTeamsAndInvites\",\n      safeStringify({\n        teamsData,\n        invitedMembersData,\n      })\n    );\n\n    // Create onboarding record with ALL data at once\n    const organizationOnboarding = await this.createOnboardingRecord({\n      ...input,\n      teams: teamsData,\n      invitedMembers: invitedMembersData,\n    });\n    const onboardingId = organizationOnboarding.id;\n\n    // Check if this is an admin handover flow\n    const handoverResult = this.handleAdminHandoverIfNeeded(input, onboardingId);\n    if (handoverResult) {\n      return handoverResult;\n    }\n\n    // Check if admin is creating org for themselves - skip payment, create immediately\n    if (\n      this.isAdminCreatingForSelf({\n        orgOwnerEmail: organizationOnboarding.orgOwnerEmail,\n      })\n    ) {\n      log.debug(\n        \"Admin creating org for self - skipping payment and creating organization immediately\",\n        safeStringify({ adminEmail: this.user.email, onboardingId })\n      );\n\n      const { organization } = await this.createOrganization(organizationOnboarding);\n\n      await OrganizationOnboardingRepository.markAsComplete(onboardingId);\n\n      log.debug(\n        \"Organization created successfully for admin\",\n        safeStringify({ onboardingId, organizationId: organization.id })\n      );\n\n      return {\n        userId: this.user.id,\n        orgOwnerEmail: input.orgOwnerEmail,\n        name: input.name,\n        slug: input.slug,\n        seats: input.seats ?? null,\n        pricePerSeat: input.pricePerSeat ?? null,\n        billingPeriod: input.billingPeriod,\n        isPlatform: input.isPlatform,\n        organizationOnboardingId: onboardingId,\n        checkoutUrl: null,\n        organizationId: organization.id,\n      };\n    }\n\n    // Regular flow - create payment intent\n    const paymentIntent = await this.paymentService.createPaymentIntent(\n      {\n        logo: organizationOnboarding.logo,\n        bio: input.bio ?? null,\n        brandColor: input.brandColor ?? null,\n        bannerUrl: organizationOnboarding.bannerUrl,\n        teams: teamsData,\n        invitedMembers: invitedMembersData,\n      },\n      {\n        id: organizationOnboarding.id,\n        pricePerSeat: organizationOnboarding.pricePerSeat,\n        billingPeriod: organizationOnboarding.billingPeriod,\n        seats: organizationOnboarding.seats,\n        isComplete: organizationOnboarding.isComplete,\n        orgOwnerEmail: organizationOnboarding.orgOwnerEmail,\n        slug: organizationOnboarding.slug,\n        stripeCustomerId: organizationOnboarding.stripeCustomerId,\n      }\n    );\n\n    return {\n      userId: this.user.id,\n      orgOwnerEmail: input.orgOwnerEmail,\n      name: input.name,\n      slug: input.slug,\n      seats: input.seats ?? null,\n      pricePerSeat: input.pricePerSeat ?? null,\n      billingPeriod: input.billingPeriod,\n      isPlatform: input.isPlatform,\n      organizationOnboardingId: onboardingId,\n      checkoutUrl: paymentIntent.checkoutUrl,\n      organizationId: null, // Organization not created yet (pending payment)\n    };\n  }\n\n  async createOrganization(\n    organizationOnboarding: OrganizationOnboardingData,\n    paymentDetails?: { subscriptionId: string; subscriptionItemId: string }\n  ): Promise<{ organization: Team; owner: User }> {\n    const organizationRepository = getOrganizationRepository();\n    log.info(\n      \"createOrganization (billing-enabled)\",\n      safeStringify({\n        orgId: organizationOnboarding.organizationId,\n        orgSlug: organizationOnboarding.slug,\n      })\n    );\n\n    const isAdminForSelf = this.isAdminCreatingForSelf({\n      orgOwnerEmail: organizationOnboarding.orgOwnerEmail,\n    });\n\n    if (\n      !IS_SELF_HOSTED &&\n      !isAdminForSelf &&\n      (!paymentDetails?.subscriptionId || !paymentDetails?.subscriptionItemId)\n    ) {\n      throw new Error(\"payment_subscription_id_and_payment_subscription_item_id_are_required\");\n    }\n\n    if (\n      await this.hasConflictingOrganization({\n        slug: organizationOnboarding.slug,\n        onboardingId: organizationOnboarding.id,\n      })\n    ) {\n      throw new Error(\"organization_already_exists_with_this_slug\");\n    }\n\n    let owner = await findUserToBeOrgOwner(organizationOnboarding.orgOwnerEmail);\n    const orgOwnerTranslation = await getTranslation(owner?.locale || \"en\", \"common\");\n\n    if (!process.env.NEXT_PUBLIC_SINGLE_ORG_SLUG) {\n      await this.handleDomainSetup({\n        organizationOnboarding,\n        orgOwnerTranslation,\n      });\n    }\n\n    const orgData: OrganizationData = {\n      id: organizationOnboarding.organizationId,\n      name: organizationOnboarding.name,\n      slug: organizationOnboarding.slug,\n      isOrganizationConfigured: true,\n      isOrganizationAdminReviewed: true,\n      autoAcceptEmail: organizationOnboarding.orgOwnerEmail.split(\"@\")[1],\n      seats: organizationOnboarding.seats,\n      pricePerSeat: organizationOnboarding.pricePerSeat,\n      isPlatform: false,\n      billingPeriod: organizationOnboarding.billingPeriod,\n      logoUrl: organizationOnboarding.logo,\n      bio: organizationOnboarding.bio,\n      brandColor: organizationOnboarding.brandColor,\n      bannerUrl: organizationOnboarding.bannerUrl,\n    };\n\n    let organization: Team;\n    if (!owner) {\n      const result = await this.createOrganizationWithNonExistentUserAsOwner({\n        email: organizationOnboarding.orgOwnerEmail,\n        orgData,\n      });\n      organization = result.organization;\n      owner = result.owner;\n    } else {\n      const result = await this.createOrganizationWithExistingUserAsOwner({\n        orgData,\n        owner,\n      });\n      organization = result.organization;\n    }\n\n    if (organizationOnboarding.stripeCustomerId) {\n      await this.ensureStripeCustomerIdIsUpdated({\n        owner,\n        stripeCustomerId: organizationOnboarding.stripeCustomerId,\n      });\n    }\n\n    await OrganizationOnboardingRepository.update(organizationOnboarding.id, {\n      organizationId: organization.id,\n    });\n\n    const updatedOrganization = await this.backwardCompatibilityForSubscriptionDetails({\n      organization,\n      paymentSubscriptionId: paymentDetails?.subscriptionId,\n      paymentSubscriptionItemId: paymentDetails?.subscriptionItemId,\n    });\n\n    organization.metadata = updatedOrganization.metadata;\n\n    const teamsData = teamsSchema.parse(organizationOnboarding.teams);\n    await this.createOrMoveTeamsToOrganization(teamsData, owner, organization.id);\n\n    await this.inviteMembers(\n      invitedMembersSchema.parse(organizationOnboarding.invitedMembers),\n      organization,\n      teamsData\n    );\n\n    if (!organization.slug) {\n      try {\n        const { slug } = await organizationRepository.setSlug({\n          id: organization.id,\n          slug: organizationOnboarding.slug,\n        });\n        organization.slug = slug;\n      } catch (error) {\n        log.error(\n          \"RecoverableError: Error while setting slug for organization\",\n          safeStringify(error),\n          safeStringify({\n            attemptedSlug: organizationOnboarding.slug,\n            organizationId: organization.id,\n          })\n        );\n        throw new Error(\n          `Unable to set slug '${organizationOnboarding.slug}' for organization ${organization.id}`\n        );\n      }\n    }\n\n    return { organization, owner };\n  }\n}",
            "cost": 0.088825
        },
        "calcom__cal.com.main/packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts": {
            "output": "import { LicenseKeySingleton } from \"@calcom/ee/common/server/LicenseKeyService\";\nimport { findUserToBeOrgOwner } from \"@calcom/features/ee/organizations/lib/server/orgCreationUtils\";\nimport { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\nimport { IS_SELF_HOSTED } from \"@calcom/lib/constants\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { DeploymentRepository } from \"@calcom/lib/server/repository/deployment\";\nimport { OrganizationOnboardingRepository } from \"@calcom/lib/server/repository/organizationOnboarding\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Team, User } from \"@calcom/prisma/client\";\nimport { BillingPeriod } from \"@calcom/prisma/enums\";\nimport { orgOnboardingInvitedMembersSchema, orgOnboardingTeamsSchema } from \"@calcom/prisma/zod-utils\";\n\nimport { BaseOnboardingService } from \"./BaseOnboardingService\";\nimport type {\n  CreateOnboardingIntentInput,\n  OnboardingIntentResult,\n  OrganizationOnboardingData,\n  OrganizationData,\n} from \"./types\";\n\nconst log = logger.getSubLogger({ prefix: [\"SelfHostedOrganizationOnboardingService\"] });\n\nconst invitedMembersSchema = orgOnboardingInvitedMembersSchema;\nconst teamsSchema = orgOnboardingTeamsSchema;\n\n/**\n * Handles organization onboarding when billing is disabled (self-hosted admin flow).\n *\n * Flow:\n * 1. Create onboarding record\n * 2. Store teams/invites in database\n * 3. Immediately create organization, teams, and invite members\n * 4. Mark onboarding as complete\n * 5. Return organization ID\n */\nexport class SelfHostedOrganizationOnboardingService extends BaseOnboardingService {\n  async createOnboardingIntent(input: CreateOnboardingIntentInput): Promise<OnboardingIntentResult> {\n    log.debug(\n      \"Starting self-hosted onboarding flow (immediate organization creation)\",\n      safeStringify({\n        slug: input.slug,\n        teamsCount: input.teams?.length ?? 0,\n        invitesCount: input.invitedMembers?.length ?? 0,\n      })\n    );\n\n    // Step 1: Filter and normalize teams/invites\n    const { teamsData, invitedMembersData } = this.filterTeamsAndInvites(input.teams, input.invitedMembers);\n\n    // Step 2: Create onboarding record with ALL data at once\n    const organizationOnboarding = await this.createOnboardingRecord({\n      ...input,\n      teams: teamsData,\n      invitedMembers: invitedMembersData,\n    });\n    const onboardingId = organizationOnboarding.id;\n\n    // Check if this is an admin handover flow\n    const handoverResult = this.handleAdminHandoverIfNeeded(input, onboardingId);\n    if (handoverResult) {\n      return handoverResult;\n    }\n\n    // Step 3: Create organization immediately (regular self-hosted flow)\n    log.debug(\"Creating organization immediately (no payment required)\", safeStringify({ onboardingId }));\n\n    const { organization } = await this.createOrganization({\n      id: onboardingId,\n      organizationId: null,\n      name: input.name,\n      slug: input.slug,\n      orgOwnerEmail: input.orgOwnerEmail,\n      seats: input.seats ?? null,\n      pricePerSeat: input.pricePerSeat ?? null,\n      billingPeriod: input.billingPeriod ?? BillingPeriod.MONTHLY,\n      invitedMembers: invitedMembersData,\n      teams: teamsData,\n      isPlatform: input.isPlatform,\n      logo: organizationOnboarding.logo,\n      bio: input.bio ?? null,\n      brandColor: input.brandColor ?? null,\n      bannerUrl: organizationOnboarding.bannerUrl,\n      stripeCustomerId: null,\n      isDomainConfigured: false,\n    });\n\n    // Step 4: Mark onboarding as complete\n    await OrganizationOnboardingRepository.markAsComplete(onboardingId);\n\n    log.debug(\n      \"Organization created successfully\",\n      safeStringify({ onboardingId, organizationId: organization.id })\n    );\n\n    // Step 5: Return result with organization ID\n    return {\n      userId: this.user.id,\n      orgOwnerEmail: input.orgOwnerEmail,\n      name: input.name,\n      slug: input.slug,\n      seats: input.seats ?? null,\n      pricePerSeat: input.pricePerSeat ?? null,\n      billingPeriod: input.billingPeriod,\n      isPlatform: input.isPlatform,\n      organizationOnboardingId: onboardingId,\n      checkoutUrl: null, // No checkout required\n      organizationId: organization.id, // Organization created immediately\n    };\n  }\n\n  async createOrganization(\n    organizationOnboarding: OrganizationOnboardingData\n  ): Promise<{ organization: Team; owner: User }> {\n    const organizationRepository = getOrganizationRepository();\n    log.info(\n      \"createOrganization (self-hosted)\",\n      safeStringify({\n        orgId: organizationOnboarding.organizationId,\n        orgSlug: organizationOnboarding.slug,\n      })\n    );\n\n    if (IS_SELF_HOSTED) {\n      const deploymentRepo = new DeploymentRepository(prisma);\n      const licenseKeyService = await LicenseKeySingleton.getInstance(deploymentRepo);\n      const hasValidLicense = await licenseKeyService.checkLicense();\n\n      if (!hasValidLicense) {\n        throw new Error(\"Self hosted license not valid\");\n      }\n    }\n\n    if (\n      await this.hasConflictingOrganization({\n        slug: organizationOnboarding.slug,\n        onboardingId: organizationOnboarding.id,\n      })\n    ) {\n      throw new Error(\"organization_already_exists_with_this_slug\");\n    }\n\n    let owner = await findUserToBeOrgOwner(organizationOnboarding.orgOwnerEmail);\n    const orgOwnerTranslation = await getTranslation(owner?.locale || \"en\", \"common\");\n\n    if (!process.env.NEXT_PUBLIC_SINGLE_ORG_SLUG) {\n      await this.handleDomainSetup({\n        organizationOnboarding,\n        orgOwnerTranslation,\n      });\n    }\n\n    const orgData: OrganizationData = {\n      id: organizationOnboarding.organizationId,\n      name: organizationOnboarding.name,\n      slug: organizationOnboarding.slug,\n      isOrganizationConfigured: true,\n      isOrganizationAdminReviewed: true,\n      autoAcceptEmail: organizationOnboarding.orgOwnerEmail.split(\"@\")[1],\n      seats: organizationOnboarding.seats,\n      pricePerSeat: organizationOnboarding.pricePerSeat,\n      isPlatform: false,\n      billingPeriod: organizationOnboarding.billingPeriod,\n      logoUrl: organizationOnboarding.logo,\n      bio: organizationOnboarding.bio,\n      brandColor: organizationOnboarding.brandColor,\n      bannerUrl: organizationOnboarding.bannerUrl,\n    };\n\n    let organization: Team;\n    if (!owner) {\n      const result = await this.createOrganizationWithNonExistentUserAsOwner({\n        email: organizationOnboarding.orgOwnerEmail,\n        orgData,\n      });\n      organization = result.organization;\n      owner = result.owner;\n    } else {\n      const result = await this.createOrganizationWithExistingUserAsOwner({\n        orgData,\n        owner,\n      });\n      organization = result.organization;\n    }\n\n    if (organizationOnboarding.stripeCustomerId) {\n      await this.ensureStripeCustomerIdIsUpdated({\n        owner,\n        stripeCustomerId: organizationOnboarding.stripeCustomerId,\n      });\n    }\n\n    await OrganizationOnboardingRepository.update(organizationOnboarding.id, {\n      organizationId: organization.id,\n    });\n\n    const teamsData = teamsSchema.parse(organizationOnboarding.teams);\n    await this.createOrMoveTeamsToOrganization(teamsData, owner, organization.id);\n\n    await this.inviteMembers(\n      invitedMembersSchema.parse(organizationOnboarding.invitedMembers),\n      organization,\n      teamsData\n    );\n\n    if (!organization.slug) {\n      try {\n        const { slug } = await organizationRepository.setSlug({\n          id: organization.id,\n          slug: organizationOnboarding.slug,\n        });\n        organization.slug = slug;\n      } catch (error) {\n        log.error(\n          \"RecoverableError: Error while setting slug for organization\",\n          safeStringify(error),\n          safeStringify({\n            attemptedSlug: organizationOnboarding.slug,\n            organizationId: organization.id,\n          })\n        );\n        throw new Error(\n          `Unable to set slug '${organizationOnboarding.slug}' for organization ${organization.id}`\n        );\n      }\n    }\n\n    return { organization, owner };\n  }\n}",
            "output_extracted": "import { LicenseKeySingleton } from \"@calcom/ee/common/server/LicenseKeyService\";\nimport { findUserToBeOrgOwner } from \"@calcom/features/ee/organizations/lib/server/orgCreationUtils\";\nimport { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\nimport { IS_SELF_HOSTED } from \"@calcom/lib/constants\";\nimport logger from \"@calcom/lib/logger\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport { getTranslation } from \"@calcom/lib/server/i18n\";\nimport { DeploymentRepository } from \"@calcom/lib/server/repository/deployment\";\nimport { OrganizationOnboardingRepository } from \"@calcom/lib/server/repository/organizationOnboarding\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Team, User } from \"@calcom/prisma/client\";\nimport { BillingPeriod } from \"@calcom/prisma/enums\";\nimport { orgOnboardingInvitedMembersSchema, orgOnboardingTeamsSchema } from \"@calcom/prisma/zod-utils\";\n\nimport { BaseOnboardingService } from \"./BaseOnboardingService\";\nimport type {\n  CreateOnboardingIntentInput,\n  OnboardingIntentResult,\n  OrganizationOnboardingData,\n  OrganizationData,\n} from \"./types\";\n\nconst log = logger.getSubLogger({ prefix: [\"SelfHostedOrganizationOnboardingService\"] });\n\nconst invitedMembersSchema = orgOnboardingInvitedMembersSchema;\nconst teamsSchema = orgOnboardingTeamsSchema;\n\n/**\n * Handles organization onboarding when billing is disabled (self-hosted admin flow).\n *\n * Flow:\n * 1. Create onboarding record\n * 2. Store teams/invites in database\n * 3. Immediately create organization, teams, and invite members\n * 4. Mark onboarding as complete\n * 5. Return organization ID\n */\nexport class SelfHostedOrganizationOnboardingService extends BaseOnboardingService {\n  async createOnboardingIntent(input: CreateOnboardingIntentInput): Promise<OnboardingIntentResult> {\n    log.debug(\n      \"Starting self-hosted onboarding flow (immediate organization creation)\",\n      safeStringify({\n        slug: input.slug,\n        teamsCount: input.teams?.length ?? 0,\n        invitesCount: input.invitedMembers?.length ?? 0,\n      })\n    );\n\n    // Step 1: Filter and normalize teams/invites\n    const { teamsData, invitedMembersData } = this.filterTeamsAndInvites(input.teams, input.invitedMembers);\n\n    // Step 2: Create onboarding record with ALL data at once\n    const organizationOnboarding = await this.createOnboardingRecord({\n      ...input,\n      teams: teamsData,\n      invitedMembers: invitedMembersData,\n    });\n    const onboardingId = organizationOnboarding.id;\n\n    // Check if this is an admin handover flow\n    const handoverResult = this.handleAdminHandoverIfNeeded(input, onboardingId);\n    if (handoverResult) {\n      return handoverResult;\n    }\n\n    // Step 3: Create organization immediately (regular self-hosted flow)\n    log.debug(\"Creating organization immediately (no payment required)\", safeStringify({ onboardingId }));\n\n    const { organization } = await this.createOrganization({\n      id: onboardingId,\n      organizationId: null,\n      name: input.name,\n      slug: input.slug,\n      orgOwnerEmail: input.orgOwnerEmail,\n      seats: input.seats ?? null,\n      pricePerSeat: input.pricePerSeat ?? null,\n      billingPeriod: input.billingPeriod ?? BillingPeriod.MONTHLY,\n      invitedMembers: invitedMembersData,\n      teams: teamsData,\n      isPlatform: input.isPlatform,\n      logo: organizationOnboarding.logo,\n      bio: input.bio ?? null,\n      brandColor: input.brandColor ?? null,\n      bannerUrl: organizationOnboarding.bannerUrl,\n      stripeCustomerId: null,\n      isDomainConfigured: false,\n    });\n\n    // Step 4: Mark onboarding as complete\n    await OrganizationOnboardingRepository.markAsComplete(onboardingId);\n\n    log.debug(\n      \"Organization created successfully\",\n      safeStringify({ onboardingId, organizationId: organization.id })\n    );\n\n    // Step 5: Return result with organization ID\n    return {\n      userId: this.user.id,\n      orgOwnerEmail: input.orgOwnerEmail,\n      name: input.name,\n      slug: input.slug,\n      seats: input.seats ?? null,\n      pricePerSeat: input.pricePerSeat ?? null,\n      billingPeriod: input.billingPeriod,\n      isPlatform: input.isPlatform,\n      organizationOnboardingId: onboardingId,\n      checkoutUrl: null, // No checkout required\n      organizationId: organization.id, // Organization created immediately\n    };\n  }\n\n  async createOrganization(\n    organizationOnboarding: OrganizationOnboardingData\n  ): Promise<{ organization: Team; owner: User }> {\n    const organizationRepository = getOrganizationRepository();\n    log.info(\n      \"createOrganization (self-hosted)\",\n      safeStringify({\n        orgId: organizationOnboarding.organizationId,\n        orgSlug: organizationOnboarding.slug,\n      })\n    );\n\n    if (IS_SELF_HOSTED) {\n      const deploymentRepo = new DeploymentRepository(prisma);\n      const licenseKeyService = await LicenseKeySingleton.getInstance(deploymentRepo);\n      const hasValidLicense = await licenseKeyService.checkLicense();\n\n      if (!hasValidLicense) {\n        throw new Error(\"Self hosted license not valid\");\n      }\n    }\n\n    if (\n      await this.hasConflictingOrganization({\n        slug: organizationOnboarding.slug,\n        onboardingId: organizationOnboarding.id,\n      })\n    ) {\n      throw new Error(\"organization_already_exists_with_this_slug\");\n    }\n\n    let owner = await findUserToBeOrgOwner(organizationOnboarding.orgOwnerEmail);\n    const orgOwnerTranslation = await getTranslation(owner?.locale || \"en\", \"common\");\n\n    if (!process.env.NEXT_PUBLIC_SINGLE_ORG_SLUG) {\n      await this.handleDomainSetup({\n        organizationOnboarding,\n        orgOwnerTranslation,\n      });\n    }\n\n    const orgData: OrganizationData = {\n      id: organizationOnboarding.organizationId,\n      name: organizationOnboarding.name,\n      slug: organizationOnboarding.slug,\n      isOrganizationConfigured: true,\n      isOrganizationAdminReviewed: true,\n      autoAcceptEmail: organizationOnboarding.orgOwnerEmail.split(\"@\")[1],\n      seats: organizationOnboarding.seats,\n      pricePerSeat: organizationOnboarding.pricePerSeat,\n      isPlatform: false,\n      billingPeriod: organizationOnboarding.billingPeriod,\n      logoUrl: organizationOnboarding.logo,\n      bio: organizationOnboarding.bio,\n      brandColor: organizationOnboarding.brandColor,\n      bannerUrl: organizationOnboarding.bannerUrl,\n    };\n\n    let organization: Team;\n    if (!owner) {\n      const result = await this.createOrganizationWithNonExistentUserAsOwner({\n        email: organizationOnboarding.orgOwnerEmail,\n        orgData,\n      });\n      organization = result.organization;\n      owner = result.owner;\n    } else {\n      const result = await this.createOrganizationWithExistingUserAsOwner({\n        orgData,\n        owner,\n      });\n      organization = result.organization;\n    }\n\n    if (organizationOnboarding.stripeCustomerId) {\n      await this.ensureStripeCustomerIdIsUpdated({\n        owner,\n        stripeCustomerId: organizationOnboarding.stripeCustomerId,\n      });\n    }\n\n    await OrganizationOnboardingRepository.update(organizationOnboarding.id, {\n      organizationId: organization.id,\n    });\n\n    const teamsData = teamsSchema.parse(organizationOnboarding.teams);\n    await this.createOrMoveTeamsToOrganization(teamsData, owner, organization.id);\n\n    await this.inviteMembers(\n      invitedMembersSchema.parse(organizationOnboarding.invitedMembers),\n      organization,\n      teamsData\n    );\n\n    if (!organization.slug) {\n      try {\n        const { slug } = await organizationRepository.setSlug({\n          id: organization.id,\n          slug: organizationOnboarding.slug,\n        });\n        organization.slug = slug;\n      } catch (error) {\n        log.error(\n          \"RecoverableError: Error while setting slug for organization\",\n          safeStringify(error),\n          safeStringify({\n            attemptedSlug: organizationOnboarding.slug,\n            organizationId: organization.id,\n          })\n        );\n        throw new Error(\n          `Unable to set slug '${organizationOnboarding.slug}' for organization ${organization.id}`\n        );\n      }\n    }\n\n    return { organization, owner };\n  }\n}",
            "cost": 0.080005
        },
        "calcom__cal.com.main/packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts": {
            "output": "import { describe, expect, it } from \"vitest\";\n\nimport { UserPermissionRole } from \"@calcom/prisma/enums\";\n\nimport { BaseOnboardingService } from \"../BaseOnboardingService\";\nimport type { CreateOnboardingIntentInput } from \"../types\";\n\nclass TestableBaseOnboardingService extends BaseOnboardingService {\n  async createOnboardingIntent(input: CreateOnboardingIntentInput): Promise<any> {\n    throw new Error(\"Not implemented\");\n  }\n\n  public testFilterTeamsAndInvites(\n    teams: CreateOnboardingIntentInput[\"teams\"],\n    invitedMembers: CreateOnboardingIntentInput[\"invitedMembers\"]\n  ) {\n    return this.filterTeamsAndInvites(teams, invitedMembers);\n  }\n}\n\nconst mockUser = {\n  id: 1,\n  email: \"user@example.com\",\n  role: UserPermissionRole.USER,\n  name: \"Test User\",\n};\n\ndescribe(\"BaseOnboardingService\", () => {\n  describe(\"filterTeamsAndInvites\", () => {\n    it(\"should filter out invites with empty emails\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const invites = [\n        { email: \"valid@example.com\", teamName: \"Marketing\", role: \"MEMBER\" },\n        { email: \"\", teamName: \"Sales\", role: \"ADMIN\" },\n        { email: \"   \", teamName: \"Engineering\", role: \"MEMBER\" },\n        { email: \"another@example.com\", teamName: \"Design\", role: \"MEMBER\" },\n      ];\n\n      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n\n      expect(invitedMembersData).toHaveLength(2);\n      expect(invitedMembersData).toEqual([\n        {\n          email: \"valid@example.com\",\n          name: undefined,\n          teamId: undefined,\n          teamName: \"Marketing\",\n          role: \"MEMBER\",\n        },\n        {\n          email: \"another@example.com\",\n          name: undefined,\n          teamId: undefined,\n          teamName: \"Design\",\n          role: \"MEMBER\",\n        },\n      ]);\n    });\n\n    it(\"should preserve all fields from invites including role\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const invites = [\n        {\n          email: \"member@example.com\",\n          name: \"John Doe\",\n          teamId: 5,\n          teamName: \"Marketing\",\n          role: \"MEMBER\",\n        },\n        {\n          email: \"admin@example.com\",\n          name: \"Jane Smith\",\n          teamId: 10,\n          teamName: \"Engineering\",\n          role: \"ADMIN\",\n        },\n      ];\n\n      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n\n      expect(invitedMembersData).toEqual([\n        {\n          email: \"member@example.com\",\n          name: \"John Doe\",\n          teamId: 5,\n          teamName: \"Marketing\",\n          role: \"MEMBER\",\n        },\n        {\n          email: \"admin@example.com\",\n          name: \"Jane Smith\",\n          teamId: 10,\n          teamName: \"Engineering\",\n          role: \"ADMIN\",\n        },\n      ]);\n    });\n\n    it(\"should handle invites without optional fields\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const invites = [\n        { email: \"minimal@example.com\" },\n        { email: \"withteam@example.com\", teamName: \"Sales\" },\n      ];\n\n      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n\n      expect(invitedMembersData).toEqual([\n        {\n          email: \"minimal@example.com\",\n          name: undefined,\n          teamId: undefined,\n          teamName: undefined,\n          role: undefined,\n        },\n        {\n          email: \"withteam@example.com\",\n          name: undefined,\n          teamId: undefined,\n          teamName: \"Sales\",\n          role: undefined,\n        },\n      ]);\n    });\n\n    it(\"should filter out teams with empty names\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const teams = [\n        { id: 1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n        { id: 2, name: \"\", isBeingMigrated: false, slug: null },\n        { id: 3, name: \"   \", isBeingMigrated: false, slug: null },\n        { id: 4, name: \"Engineering\", isBeingMigrated: true, slug: \"eng\" },\n      ];\n\n      const { teamsData } = service.testFilterTeamsAndInvites(teams, []);\n\n      expect(teamsData).toHaveLength(2);\n      expect(teamsData).toEqual([\n        { id: 1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n        { id: 4, name: \"Engineering\", isBeingMigrated: true, slug: \"eng\" },\n      ]);\n    });\n\n    it(\"should preserve team properties including migration status\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const teams = [\n        { id: -1, name: \"New Team\", isBeingMigrated: false, slug: null },\n        { id: 42, name: \"Existing Team\", isBeingMigrated: true, slug: \"existing-team\" },\n      ];\n\n      const { teamsData } = service.testFilterTeamsAndInvites(teams, []);\n\n      expect(teamsData).toEqual([\n        { id: -1, name: \"New Team\", isBeingMigrated: false, slug: null },\n        { id: 42, name: \"Existing Team\", isBeingMigrated: true, slug: \"existing-team\" },\n      ]);\n    });\n\n    it(\"should handle empty teams and invites arrays\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites([], []);\n\n      expect(teamsData).toEqual([]);\n      expect(invitedMembersData).toEqual([]);\n    });\n\n    it(\"should handle undefined teams and invites\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(undefined, undefined);\n\n      expect(teamsData).toEqual([]);\n      expect(invitedMembersData).toEqual([]);\n    });\n\n    it(\"should preserve invites with teamId=-1 for new teams\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const teams = [\n        { id: -1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n        { id: -1, name: \"Sales\", isBeingMigrated: false, slug: null },\n      ];\n\n      const invites = [\n        { email: \"user1@example.com\", teamId: -1, teamName: \"Marketing\", role: \"MEMBER\" },\n        { email: \"user2@example.com\", teamId: -1, teamName: \"Sales\", role: \"ADMIN\" },\n      ];\n\n      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(teams, invites);\n\n      expect(teamsData).toHaveLength(2);\n      expect(invitedMembersData).toHaveLength(2);\n      expect(invitedMembersData[0].teamId).toBe(-1);\n      expect(invitedMembersData[1].teamId).toBe(-1);\n      expect(invitedMembersData[0].role).toBe(\"MEMBER\");\n      expect(invitedMembersData[1].role).toBe(\"ADMIN\");\n    });\n\n    it(\"should handle mixed scenarios with both org-level and team-specific invites\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const teams = [\n        { id: -1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n        { id: 42, name: \"Engineering\", isBeingMigrated: true, slug: \"eng\" },\n      ];\n\n      const invites = [\n        { email: \"orguser@example.com\", role: \"MEMBER\" },\n        { email: \"marketing@example.com\", teamName: \"Marketing\", teamId: -1, role: \"MEMBER\" },\n        { email: \"eng@example.com\", teamName: \"Engineering\", teamId: 42, role: \"ADMIN\" },\n      ];\n\n      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(teams, invites);\n\n      expect(teamsData).toHaveLength(2);\n      expect(invitedMembersData).toHaveLength(3);\n\n      expect(invitedMembersData[0]).toEqual({\n        email: \"orguser@example.com\",\n        name: undefined,\n        teamId: undefined,\n        teamName: undefined,\n        role: \"MEMBER\",\n      });\n\n      expect(invitedMembersData[1]).toEqual({\n        email: \"marketing@example.com\",\n        name: undefined,\n        teamId: -1,\n        teamName: \"Marketing\",\n        role: \"MEMBER\",\n      });\n\n      expect(invitedMembersData[2]).toEqual({\n        email: \"eng@example.com\",\n        name: undefined,\n        teamId: 42,\n        teamName: \"Engineering\",\n        role: \"ADMIN\",\n      });\n    });\n  });\n});",
            "output_extracted": "import { describe, expect, it } from \"vitest\";\n\nimport { UserPermissionRole } from \"@calcom/prisma/enums\";\n\nimport { BaseOnboardingService } from \"../BaseOnboardingService\";\nimport type { CreateOnboardingIntentInput } from \"../types\";\n\nclass TestableBaseOnboardingService extends BaseOnboardingService {\n  async createOnboardingIntent(input: CreateOnboardingIntentInput): Promise<any> {\n    throw new Error(\"Not implemented\");\n  }\n\n  public testFilterTeamsAndInvites(\n    teams: CreateOnboardingIntentInput[\"teams\"],\n    invitedMembers: CreateOnboardingIntentInput[\"invitedMembers\"]\n  ) {\n    return this.filterTeamsAndInvites(teams, invitedMembers);\n  }\n}\n\nconst mockUser = {\n  id: 1,\n  email: \"user@example.com\",\n  role: UserPermissionRole.USER,\n  name: \"Test User\",\n};\n\ndescribe(\"BaseOnboardingService\", () => {\n  describe(\"filterTeamsAndInvites\", () => {\n    it(\"should filter out invites with empty emails\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const invites = [\n        { email: \"valid@example.com\", teamName: \"Marketing\", role: \"MEMBER\" },\n        { email: \"\", teamName: \"Sales\", role: \"ADMIN\" },\n        { email: \"   \", teamName: \"Engineering\", role: \"MEMBER\" },\n        { email: \"another@example.com\", teamName: \"Design\", role: \"MEMBER\" },\n      ];\n\n      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n\n      expect(invitedMembersData).toHaveLength(2);\n      expect(invitedMembersData).toEqual([\n        {\n          email: \"valid@example.com\",\n          name: undefined,\n          teamId: undefined,\n          teamName: \"Marketing\",\n          role: \"MEMBER\",\n        },\n        {\n          email: \"another@example.com\",\n          name: undefined,\n          teamId: undefined,\n          teamName: \"Design\",\n          role: \"MEMBER\",\n        },\n      ]);\n    });\n\n    it(\"should preserve all fields from invites including role\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const invites = [\n        {\n          email: \"member@example.com\",\n          name: \"John Doe\",\n          teamId: 5,\n          teamName: \"Marketing\",\n          role: \"MEMBER\",\n        },\n        {\n          email: \"admin@example.com\",\n          name: \"Jane Smith\",\n          teamId: 10,\n          teamName: \"Engineering\",\n          role: \"ADMIN\",\n        },\n      ];\n\n      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n\n      expect(invitedMembersData).toEqual([\n        {\n          email: \"member@example.com\",\n          name: \"John Doe\",\n          teamId: 5,\n          teamName: \"Marketing\",\n          role: \"MEMBER\",\n        },\n        {\n          email: \"admin@example.com\",\n          name: \"Jane Smith\",\n          teamId: 10,\n          teamName: \"Engineering\",\n          role: \"ADMIN\",\n        },\n      ]);\n    });\n\n    it(\"should handle invites without optional fields\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const invites = [\n        { email: \"minimal@example.com\" },\n        { email: \"withteam@example.com\", teamName: \"Sales\" },\n      ];\n\n      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n\n      expect(invitedMembersData).toEqual([\n        {\n          email: \"minimal@example.com\",\n          name: undefined,\n          teamId: undefined,\n          teamName: undefined,\n          role: undefined,\n        },\n        {\n          email: \"withteam@example.com\",\n          name: undefined,\n          teamId: undefined,\n          teamName: \"Sales\",\n          role: undefined,\n        },\n      ]);\n    });\n\n    it(\"should filter out teams with empty names\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const teams = [\n        { id: 1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n        { id: 2, name: \"\", isBeingMigrated: false, slug: null },\n        { id: 3, name: \"   \", isBeingMigrated: false, slug: null },\n        { id: 4, name: \"Engineering\", isBeingMigrated: true, slug: \"eng\" },\n      ];\n\n      const { teamsData } = service.testFilterTeamsAndInvites(teams, []);\n\n      expect(teamsData).toHaveLength(2);\n      expect(teamsData).toEqual([\n        { id: 1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n        { id: 4, name: \"Engineering\", isBeingMigrated: true, slug: \"eng\" },\n      ]);\n    });\n\n    it(\"should preserve team properties including migration status\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const teams = [\n        { id: -1, name: \"New Team\", isBeingMigrated: false, slug: null },\n        { id: 42, name: \"Existing Team\", isBeingMigrated: true, slug: \"existing-team\" },\n      ];\n\n      const { teamsData } = service.testFilterTeamsAndInvites(teams, []);\n\n      expect(teamsData).toEqual([\n        { id: -1, name: \"New Team\", isBeingMigrated: false, slug: null },\n        { id: 42, name: \"Existing Team\", isBeingMigrated: true, slug: \"existing-team\" },\n      ]);\n    });\n\n    it(\"should handle empty teams and invites arrays\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites([], []);\n\n      expect(teamsData).toEqual([]);\n      expect(invitedMembersData).toEqual([]);\n    });\n\n    it(\"should handle undefined teams and invites\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(undefined, undefined);\n\n      expect(teamsData).toEqual([]);\n      expect(invitedMembersData).toEqual([]);\n    });\n\n    it(\"should preserve invites with teamId=-1 for new teams\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const teams = [\n        { id: -1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n        { id: -1, name: \"Sales\", isBeingMigrated: false, slug: null },\n      ];\n\n      const invites = [\n        { email: \"user1@example.com\", teamId: -1, teamName: \"Marketing\", role: \"MEMBER\" },\n        { email: \"user2@example.com\", teamId: -1, teamName: \"Sales\", role: \"ADMIN\" },\n      ];\n\n      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(teams, invites);\n\n      expect(teamsData).toHaveLength(2);\n      expect(invitedMembersData).toHaveLength(2);\n      expect(invitedMembersData[0].teamId).toBe(-1);\n      expect(invitedMembersData[1].teamId).toBe(-1);\n      expect(invitedMembersData[0].role).toBe(\"MEMBER\");\n      expect(invitedMembersData[1].role).toBe(\"ADMIN\");\n    });\n\n    it(\"should handle mixed scenarios with both org-level and team-specific invites\", () => {\n      const service = new TestableBaseOnboardingService(mockUser as any);\n\n      const teams = [\n        { id: -1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n        { id: 42, name: \"Engineering\", isBeingMigrated: true, slug: \"eng\" },\n      ];\n\n      const invites = [\n        { email: \"orguser@example.com\", role: \"MEMBER\" },\n        { email: \"marketing@example.com\", teamName: \"Marketing\", teamId: -1, role: \"MEMBER\" },\n        { email: \"eng@example.com\", teamName: \"Engineering\", teamId: 42, role: \"ADMIN\" },\n      ];\n\n      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(teams, invites);\n\n      expect(teamsData).toHaveLength(2);\n      expect(invitedMembersData).toHaveLength(3);\n\n      expect(invitedMembersData[0]).toEqual({\n        email: \"orguser@example.com\",\n        name: undefined,\n        teamId: undefined,\n        teamName: undefined,\n        role: \"MEMBER\",\n      });\n\n      expect(invitedMembersData[1]).toEqual({\n        email: \"marketing@example.com\",\n        name: undefined,\n        teamId: -1,\n        teamName: \"Marketing\",\n        role: \"MEMBER\",\n      });\n\n      expect(invitedMembersData[2]).toEqual({\n        email: \"eng@example.com\",\n        name: undefined,\n        teamId: 42,\n        teamName: \"Engineering\",\n        role: \"ADMIN\",\n      });\n    });\n  });\n});",
            "cost": 0.09537000000000001
        },
        "calcom__cal.com.main/packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts": {
            "output": "import prismock from \"../../../../../../../../tests/libs/__mocks__/prisma\";\n\nimport { describe, expect, it, vi, beforeEach } from \"vitest\";\n\nimport * as constants from \"@calcom/lib/constants\";\nimport { createDomain } from \"@calcom/lib/domainManager/organization\";\nimport { UserPermissionRole, CreationSource, MembershipRole, BillingPeriod } from \"@calcom/prisma/enums\";\nimport { createTeamsHandler } from \"@calcom/trpc/server/routers/viewer/organizations/createTeams.handler\";\nimport { inviteMembersWithNoInviterPermissionCheck } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/inviteMember.handler\";\n\nimport type { CreateOnboardingIntentInput } from \"../../onboarding/types\";\nimport { BillingEnabledOrgOnboardingService } from \"../BillingEnabledOrgOnboardingService\";\n\nvi.mock(\"../../OrganizationPaymentService\");\n\nvi.mock(\"@calcom/features/auth/lib/verifyEmail\", () => ({\n  sendEmailVerification: vi.fn(),\n}));\n\nvi.mock(\"@calcom/emails/email-manager\", () => ({\n  sendOrganizationCreationEmail: vi.fn(),\n}));\n\nvi.mock(\"@calcom/trpc/server/routers/viewer/teams/inviteMember/inviteMember.handler\", () => ({\n  inviteMembersWithNoInviterPermissionCheck: vi.fn(),\n}));\n\nvi.mock(\"@calcom/trpc/server/routers/viewer/organizations/createTeams.handler\", () => ({\n  createTeamsHandler: vi.fn(),\n}));\n\nvi.mock(\"@calcom/lib/domainManager/organization\", () => ({\n  createDomain: vi.fn(),\n}));\n\nvi.mock(\"@calcom/lib/server/i18n\", () => {\n  return {\n    getTranslation: async (locale: string, namespace: string) => {\n      const t = (key: string) => key;\n      t.locale = locale;\n      t.namespace = namespace;\n      return t;\n    },\n  };\n});\n\nconst mockUser = {\n  id: 1,\n  email: \"user@example.com\",\n  role: UserPermissionRole.USER,\n  name: \"Test User\",\n};\n\nconst mockInput: CreateOnboardingIntentInput = {\n  name: \"Test Organization\",\n  slug: \"test-org\",\n  orgOwnerEmail: \"owner@example.com\",\n  seats: 10,\n  pricePerSeat: 20,\n  isPlatform: false,\n  creationSource: CreationSource.WEBAPP,\n  logo: \"https://example.com/logo.png\",\n  bio: \"Test bio\",\n  brandColor: \"#000000\",\n  bannerUrl: \"https://example.com/banner.png\",\n  teams: [\n    { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n    { id: -1, name: \"Sales\", isBeingMigrated: false, slug: null },\n  ],\n  invitedMembers: [\n    { email: \"member1@example.com\", name: \"Member 1\" },\n    { email: \"member2@example.com\", name: \"Member 2\" },\n  ],\n};\n\ndescribe(\"BillingEnabledOrgOnboardingService\", () => {\n  let service: BillingEnabledOrgOnboardingService;\n  let mockPaymentService: any;\n\n  beforeEach(async () => {\n    vi.resetAllMocks();\n    // @ts-expect-error reset is a method on Prismock\n    await prismock.reset();\n\n    mockPaymentService = {\n      createOrganizationOnboarding: vi.fn().mockImplementation(async (data: any) => {\n        // Actually create the record in prismock so it can be updated later\n        return await prismock.organizationOnboarding.create({\n          data: {\n            id: \"onboarding-123\",\n            name: data.name,\n            slug: data.slug,\n            orgOwnerEmail: data.orgOwnerEmail,\n            seats: data.seats ?? null,\n            pricePerSeat: data.pricePerSeat ?? null,\n            billingPeriod: data.billingPeriod ?? BillingPeriod.MONTHLY,\n            isComplete: false,\n            stripeCustomerId: null,\n            createdById: data.createdByUserId,\n            teams: [],\n            invitedMembers: [],\n            isPlatform: data.isPlatform ?? false,\n            logo: data.logo ?? null,\n            bio: data.bio ?? null,\n            brandColor: data.brandColor ?? null,\n            bannerUrl: data.bannerUrl ?? null,\n          },\n        });\n      }),\n      createPaymentIntent: vi.fn().mockResolvedValue({\n        checkoutUrl: \"https://stripe.com/checkout/session\",\n        organizationOnboarding: {},\n        subscription: {},\n        sessionId: \"session-123\",\n      }),\n    };\n\n    service = new BillingEnabledOrgOnboardingService(mockUser as any, mockPaymentService);\n  });\n\n  describe(\"createOnboardingIntent\", () => {\n    it(\"should create onboarding record\", async () => {\n      await service.createOnboardingIntent(mockInput);\n\n      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n        expect.objectContaining({\n          name: mockInput.name,\n          slug: mockInput.slug,\n          orgOwnerEmail: mockInput.orgOwnerEmail,\n          createdByUserId: mockUser.id,\n        })\n      );\n    });\n\n    it(\"should create Stripe payment intent with teams and invites\", async () => {\n      await service.createOnboardingIntent(mockInput);\n\n      expect(mockPaymentService.createPaymentIntent).toHaveBeenCalledWith(\n        expect.objectContaining({\n          teams: expect.arrayContaining([\n            { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n            { id: -1, name: \"Sales\", isBeingMigrated: false, slug: null },\n          ]),\n          invitedMembers: expect.arrayContaining([\n            { email: \"member1@example.com\", name: \"Member 1\" },\n            { email: \"member2@example.com\", name: \"Member 2\" },\n          ]),\n        }),\n        expect.anything()\n      );\n    });\n\n    it(\"should return checkout URL\", async () => {\n      const result = await service.createOnboardingIntent(mockInput);\n\n      expect(result.checkoutUrl).toBe(\"https://stripe.com/checkout/session\");\n      expect(result.organizationId).toBeNull();\n    });\n\n    it(\"should filter out empty team names\", async () => {\n      const inputWithEmptyTeams = {\n        ...mockInput,\n        teams: [\n          { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n          { id: -1, name: \"  \", isBeingMigrated: false, slug: null },\n          { id: -1, name: \"\", isBeingMigrated: false, slug: null },\n        ],\n      };\n\n      await service.createOnboardingIntent(inputWithEmptyTeams);\n\n      expect(mockPaymentService.createPaymentIntent).toHaveBeenCalledWith(\n        expect.objectContaining({\n          teams: [{ id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null }],\n        }),\n        expect.anything()\n      );\n    });\n\n    it(\"should filter out empty invite emails\", async () => {\n      const inputWithEmptyInvites = {\n        ...mockInput,\n        invitedMembers: [\n          { email: \"member1@example.com\", name: \"Member 1\" },\n          { email: \"  \", name: \"Empty\" },\n          { email: \"\", name: \"Empty 2\" },\n        ],\n      };\n\n      await service.createOnboardingIntent(inputWithEmptyInvites);\n\n      expect(mockPaymentService.createPaymentIntent).toHaveBeenCalledWith(\n        expect.objectContaining({\n          invitedMembers: [{ email: \"member1@example.com\", name: \"Member 1\" }],\n        }),\n        expect.anything()\n      );\n    });\n\n    it(\"should NOT create organization immediately\", async () => {\n      const result = await service.createOnboardingIntent(mockInput);\n\n      // Organization will be created later via Stripe webhook\n      expect(result.organizationId).toBeNull();\n      expect(result.checkoutUrl).not.toBeNull();\n    });\n\n    it(\"should return all required fields\", async () => {\n      const result = await service.createOnboardingIntent(mockInput);\n\n      expect(result).toEqual({\n        userId: mockUser.id,\n        orgOwnerEmail: mockInput.orgOwnerEmail,\n        name: mockInput.name,\n        slug: mockInput.slug,\n        seats: mockInput.seats,\n        pricePerSeat: mockInput.pricePerSeat,\n        billingPeriod: mockInput.billingPeriod,\n        isPlatform: mockInput.isPlatform,\n        organizationOnboardingId: \"onboarding-123\",\n        checkoutUrl: \"https://stripe.com/checkout/session\",\n        organizationId: null,\n      });\n    });\n\n    it(\"should immediately create organization when admin creates org for self\", async () => {\n      vi.spyOn(constants, \"IS_SELF_HOSTED\", \"get\").mockReturnValue(false);\n\n      const adminUser = {\n        id: 1,\n        email: \"admin@example.com\",\n        role: UserPermissionRole.ADMIN,\n        name: \"Admin User\",\n      };\n\n      const adminInput = {\n        ...mockInput,\n        orgOwnerEmail: adminUser.email,\n      };\n\n      await prismock.user.create({\n        data: {\n          id: adminUser.id,\n          email: adminUser.email,\n          name: adminUser.name,\n          username: \"admin\",\n          completedOnboarding: true,\n          emailVerified: new Date(),\n        },\n      });\n\n      const adminService = new BillingEnabledOrgOnboardingService(adminUser as any, mockPaymentService);\n\n      const result = await adminService.createOnboardingIntent(adminInput);\n\n      expect(result.organizationId).not.toBeNull();\n      expect(result.checkoutUrl).toBeNull();\n      expect(mockPaymentService.createPaymentIntent).not.toHaveBeenCalled();\n\n      const onboarding = await prismock.organizationOnboarding.findUnique({\n        where: { id: result.organizationOnboardingId },\n      });\n      expect(onboarding?.isComplete).toBe(true);\n    });\n\n    it(\"should use checkout flow when admin creates org for someone else with no teams/invites (handover)\", async () => {\n      const adminUser = {\n        id: 1,\n        email: \"admin@example.com\",\n        role: UserPermissionRole.ADMIN,\n        name: \"Admin User\",\n      };\n\n      const handoverInput = {\n        ...mockInput,\n        orgOwnerEmail: \"other@example.com\",\n        teams: [],\n        invitedMembers: [],\n      };\n\n      const adminService = new BillingEnabledOrgOnboardingService(adminUser as any, mockPaymentService);\n\n      const result = await adminService.createOnboardingIntent(handoverInput);\n\n      expect(result.organizationId).toBeNull();\n      expect(result.checkoutUrl).toBeNull();\n      expect(result.handoverUrl).toContain(\"/settings/organizations/new/resume\");\n      expect(mockPaymentService.createPaymentIntent).not.toHaveBeenCalled();\n    });\n  });\n\n  describe(\"createOrganization\", () => {\n    // Helper functions for creating test data\n    async function createTestUser(data: {\n      email: string;\n      name?: string;\n      username?: string;\n      metadata?: any;\n      onboardingCompleted?: boolean;\n      emailVerified?: Date | null;\n    }) {\n      return prismock.user.create({\n        data: {\n          email: data.email,\n          name: data.name || \"Test User\",\n          username: data.username || \"testuser\",\n          metadata: data.metadata || {},\n          completedOnboarding: data.onboardingCompleted,\n          emailVerified: data.emailVerified,\n        },\n      });\n    }\n\n    async function createTestOrganization(data: {\n      name: string;\n      slug: string;\n      isOrganization?: boolean;\n      metadata?: any;\n    }) {\n      return prismock.team.create({\n        data: {\n          name: data.name,\n          slug: data.slug,\n          isOrganization: data.isOrganization ?? true,\n          metadata: data.metadata || {},\n        },\n      });\n    }\n\n    async function createTestTeam(data: { name: string; slug: string }) {\n      return prismock.team.create({\n        data: {\n          name: data.name,\n          slug: data.slug,\n          isOrganization: false,\n        },\n      });\n    }\n\n    async function createTestMembership(data: { userId: number; teamId: number; role?: MembershipRole }) {\n      return prismock.membership.create({\n        data: {\n          createdAt: new Date(),\n          userId: data.userId,\n          teamId: data.teamId,\n          role: data.role || MembershipRole.MEMBER,\n          accepted: true,\n        },\n      });\n    }\n\n    async function createTestOnboarding(overrides?: Partial<typeof mockOrganizationOnboardingData>) {\n      return await prismock.organizationOnboarding.create({\n        data: {\n          ...mockOrganizationOnboardingData,\n          ...overrides,\n        },\n      });\n    }\n\n    const mockOrganizationOnboardingData = {\n      id: \"onboarding-123\",\n      organizationId: null,\n      name: \"Test Org\",\n      slug: \"test-org\",\n      orgOwnerEmail: \"owner@example.com\",\n      seats: 5,\n      pricePerSeat: 20,\n      billingPeriod: BillingPeriod.MONTHLY,\n      invitedMembers: [{ email: \"member1@example.com\" }, { email: \"member2@example.com\" }],\n      teams: [\n        { id: 1, name: \"Team To Move\", isBeingMigrated: true, slug: \"new-team-slug\" },\n        { id: -1, name: \"New Team\", isBeingMigrated: false, slug: null },\n      ],\n      isPlatform: false,\n      logo: null,\n      bio: null,\n      brandColor: null,\n      bannerUrl: null,\n      stripeCustomerId: \"cus_123\",\n      isDomainConfigured: false,\n      isComplete: false,\n      createdById: null,\n    };\n\n    it(\"should require payment details for billing-enabled flow\", async () => {\n      vi.spyOn(constants, \"IS_SELF_HOSTED\", \"get\").mockReturnValue(false);\n\n      const mockOrganizationOnboarding = await createTestOnboarding();\n\n      await expect(service.createOrganization(mockOrganizationOnboarding)).rejects.toThrow(\n        \"payment_subscription_id_and_payment_subscription_item_id_are_required\"\n      );\n    });\n\n    it(\"should create organization with existing user as owner\", async () => {\n      vi.spyOn(constants, \"IS_SELF_HOSTED\", \"get\").mockReturnValue(false);\n\n      const mockOrganizationOnboarding = await createTestOnboarding();\n\n      const existingUser = await createTestUser({\n        email: mockOrganizationOnboarding.orgOwnerEmail,\n        name: \"Existing User\",\n        username: \"existinguser\",\n        onboardingCompleted: true,\n        emailVerified: new Date(),\n      });\n\n      const { organization, owner } = await service.createOrganization(mockOrganizationOnboarding, {\n        subsc",
            "output_extracted": "import prismock from \"../../../../../../../../tests/libs/__mocks__/prisma\";\n\nimport { describe, expect, it, vi, beforeEach } from \"vitest\";\n\nimport * as constants from \"@calcom/lib/constants\";\nimport { createDomain } from \"@calcom/lib/domainManager/organization\";\nimport { UserPermissionRole, CreationSource, MembershipRole, BillingPeriod } from \"@calcom/prisma/enums\";\nimport { createTeamsHandler } from \"@calcom/trpc/server/routers/viewer/organizations/createTeams.handler\";\nimport { inviteMembersWithNoInviterPermissionCheck } from \"@calcom/trpc/server/routers/viewer/teams/inviteMember/inviteMember.handler\";\n\nimport type { CreateOnboardingIntentInput } from \"../../onboarding/types\";\nimport { BillingEnabledOrgOnboardingService } from \"../BillingEnabledOrgOnboardingService\";\n\nvi.mock(\"../../OrganizationPaymentService\");\n\nvi.mock(\"@calcom/features/auth/lib/verifyEmail\", () => ({\n  sendEmailVerification: vi.fn(),\n}));\n\nvi.mock(\"@calcom/emails/email-manager\", () => ({\n  sendOrganizationCreationEmail: vi.fn(),\n}));\n\nvi.mock(\"@calcom/trpc/server/routers/viewer/teams/inviteMember/inviteMember.handler\", () => ({\n  inviteMembersWithNoInviterPermissionCheck: vi.fn(),\n}));\n\nvi.mock(\"@calcom/trpc/server/routers/viewer/organizations/createTeams.handler\", () => ({\n  createTeamsHandler: vi.fn(),\n}));\n\nvi.mock(\"@calcom/lib/domainManager/organization\", () => ({\n  createDomain: vi.fn(),\n}));\n\nvi.mock(\"@calcom/lib/server/i18n\", () => {\n  return {\n    getTranslation: async (locale: string, namespace: string) => {\n      const t = (key: string) => key;\n      t.locale = locale;\n      t.namespace = namespace;\n      return t;\n    },\n  };\n});\n\nconst mockUser = {\n  id: 1,\n  email: \"user@example.com\",\n  role: UserPermissionRole.USER,\n  name: \"Test User\",\n};\n\nconst mockInput: CreateOnboardingIntentInput = {\n  name: \"Test Organization\",\n  slug: \"test-org\",\n  orgOwnerEmail: \"owner@example.com\",\n  seats: 10,\n  pricePerSeat: 20,\n  isPlatform: false,\n  creationSource: CreationSource.WEBAPP,\n  logo: \"https://example.com/logo.png\",\n  bio: \"Test bio\",\n  brandColor: \"#000000\",\n  bannerUrl: \"https://example.com/banner.png\",\n  teams: [\n    { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n    { id: -1, name: \"Sales\", isBeingMigrated: false, slug: null },\n  ],\n  invitedMembers: [\n    { email: \"member1@example.com\", name: \"Member 1\" },\n    { email: \"member2@example.com\", name: \"Member 2\" },\n  ],\n};\n\ndescribe(\"BillingEnabledOrgOnboardingService\", () => {\n  let service: BillingEnabledOrgOnboardingService;\n  let mockPaymentService: any;\n\n  beforeEach(async () => {\n    vi.resetAllMocks();\n    // @ts-expect-error reset is a method on Prismock\n    await prismock.reset();\n\n    mockPaymentService = {\n      createOrganizationOnboarding: vi.fn().mockImplementation(async (data: any) => {\n        // Actually create the record in prismock so it can be updated later\n        return await prismock.organizationOnboarding.create({\n          data: {\n            id: \"onboarding-123\",\n            name: data.name,\n            slug: data.slug,\n            orgOwnerEmail: data.orgOwnerEmail,\n            seats: data.seats ?? null,\n            pricePerSeat: data.pricePerSeat ?? null,\n            billingPeriod: data.billingPeriod ?? BillingPeriod.MONTHLY,\n            isComplete: false,\n            stripeCustomerId: null,\n            createdById: data.createdByUserId,\n            teams: [],\n            invitedMembers: [],\n            isPlatform: data.isPlatform ?? false,\n            logo: data.logo ?? null,\n            bio: data.bio ?? null,\n            brandColor: data.brandColor ?? null,\n            bannerUrl: data.bannerUrl ?? null,\n          },\n        });\n      }),\n      createPaymentIntent: vi.fn().mockResolvedValue({\n        checkoutUrl: \"https://stripe.com/checkout/session\",\n        organizationOnboarding: {},\n        subscription: {},\n        sessionId: \"session-123\",\n      }),\n    };\n\n    service = new BillingEnabledOrgOnboardingService(mockUser as any, mockPaymentService);\n  });\n\n  describe(\"createOnboardingIntent\", () => {\n    it(\"should create onboarding record\", async () => {\n      await service.createOnboardingIntent(mockInput);\n\n      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n        expect.objectContaining({\n          name: mockInput.name,\n          slug: mockInput.slug,\n          orgOwnerEmail: mockInput.orgOwnerEmail,\n          createdByUserId: mockUser.id,\n        })\n      );\n    });\n\n    it(\"should create Stripe payment intent with teams and invites\", async () => {\n      await service.createOnboardingIntent(mockInput);\n\n      expect(mockPaymentService.createPaymentIntent).toHaveBeenCalledWith(\n        expect.objectContaining({\n          teams: expect.arrayContaining([\n            { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n            { id: -1, name: \"Sales\", isBeingMigrated: false, slug: null },\n          ]),\n          invitedMembers: expect.arrayContaining([\n            { email: \"member1@example.com\", name: \"Member 1\" },\n            { email: \"member2@example.com\", name: \"Member 2\" },\n          ]),\n        }),\n        expect.anything()\n      );\n    });\n\n    it(\"should return checkout URL\", async () => {\n      const result = await service.createOnboardingIntent(mockInput);\n\n      expect(result.checkoutUrl).toBe(\"https://stripe.com/checkout/session\");\n      expect(result.organizationId).toBeNull();\n    });\n\n    it(\"should filter out empty team names\", async () => {\n      const inputWithEmptyTeams = {\n        ...mockInput,\n        teams: [\n          { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n          { id: -1, name: \"  \", isBeingMigrated: false, slug: null },\n          { id: -1, name: \"\", isBeingMigrated: false, slug: null },\n        ],\n      };\n\n      await service.createOnboardingIntent(inputWithEmptyTeams);\n\n      expect(mockPaymentService.createPaymentIntent).toHaveBeenCalledWith(\n        expect.objectContaining({\n          teams: [{ id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null }],\n        }),\n        expect.anything()\n      );\n    });\n\n    it(\"should filter out empty invite emails\", async () => {\n      const inputWithEmptyInvites = {\n        ...mockInput,\n        invitedMembers: [\n          { email: \"member1@example.com\", name: \"Member 1\" },\n          { email: \"  \", name: \"Empty\" },\n          { email: \"\", name: \"Empty 2\" },\n        ],\n      };\n\n      await service.createOnboardingIntent(inputWithEmptyInvites);\n\n      expect(mockPaymentService.createPaymentIntent).toHaveBeenCalledWith(\n        expect.objectContaining({\n          invitedMembers: [{ email: \"member1@example.com\", name: \"Member 1\" }],\n        }),\n        expect.anything()\n      );\n    });\n\n    it(\"should NOT create organization immediately\", async () => {\n      const result = await service.createOnboardingIntent(mockInput);\n\n      // Organization will be created later via Stripe webhook\n      expect(result.organizationId).toBeNull();\n      expect(result.checkoutUrl).not.toBeNull();\n    });\n\n    it(\"should return all required fields\", async () => {\n      const result = await service.createOnboardingIntent(mockInput);\n\n      expect(result).toEqual({\n        userId: mockUser.id,\n        orgOwnerEmail: mockInput.orgOwnerEmail,\n        name: mockInput.name,\n        slug: mockInput.slug,\n        seats: mockInput.seats,\n        pricePerSeat: mockInput.pricePerSeat,\n        billingPeriod: mockInput.billingPeriod,\n        isPlatform: mockInput.isPlatform,\n        organizationOnboardingId: \"onboarding-123\",\n        checkoutUrl: \"https://stripe.com/checkout/session\",\n        organizationId: null,\n      });\n    });\n\n    it(\"should immediately create organization when admin creates org for self\", async () => {\n      vi.spyOn(constants, \"IS_SELF_HOSTED\", \"get\").mockReturnValue(false);\n\n      const adminUser = {\n        id: 1,\n        email: \"admin@example.com\",\n        role: UserPermissionRole.ADMIN,\n        name: \"Admin User\",\n      };\n\n      const adminInput = {\n        ...mockInput,\n        orgOwnerEmail: adminUser.email,\n      };\n\n      await prismock.user.create({\n        data: {\n          id: adminUser.id,\n          email: adminUser.email,\n          name: adminUser.name,\n          username: \"admin\",\n          completedOnboarding: true,\n          emailVerified: new Date(),\n        },\n      });\n\n      const adminService = new BillingEnabledOrgOnboardingService(adminUser as any, mockPaymentService);\n\n      const result = await adminService.createOnboardingIntent(adminInput);\n\n      expect(result.organizationId).not.toBeNull();\n      expect(result.checkoutUrl).toBeNull();\n      expect(mockPaymentService.createPaymentIntent).not.toHaveBeenCalled();\n\n      const onboarding = await prismock.organizationOnboarding.findUnique({\n        where: { id: result.organizationOnboardingId },\n      });\n      expect(onboarding?.isComplete).toBe(true);\n    });\n\n    it(\"should use checkout flow when admin creates org for someone else with no teams/invites (handover)\", async () => {\n      const adminUser = {\n        id: 1,\n        email: \"admin@example.com\",\n        role: UserPermissionRole.ADMIN,\n        name: \"Admin User\",\n      };\n\n      const handoverInput = {\n        ...mockInput,\n        orgOwnerEmail: \"other@example.com\",\n        teams: [],\n        invitedMembers: [],\n      };\n\n      const adminService = new BillingEnabledOrgOnboardingService(adminUser as any, mockPaymentService);\n\n      const result = await adminService.createOnboardingIntent(handoverInput);\n\n      expect(result.organizationId).toBeNull();\n      expect(result.checkoutUrl).toBeNull();\n      expect(result.handoverUrl).toContain(\"/settings/organizations/new/resume\");\n      expect(mockPaymentService.createPaymentIntent).not.toHaveBeenCalled();\n    });\n  });\n\n  describe(\"createOrganization\", () => {\n    // Helper functions for creating test data\n    async function createTestUser(data: {\n      email: string;\n      name?: string;\n      username?: string;\n      metadata?: any;\n      onboardingCompleted?: boolean;\n      emailVerified?: Date | null;\n    }) {\n      return prismock.user.create({\n        data: {\n          email: data.email,\n          name: data.name || \"Test User\",\n          username: data.username || \"testuser\",\n          metadata: data.metadata || {},\n          completedOnboarding: data.onboardingCompleted,\n          emailVerified: data.emailVerified,\n        },\n      });\n    }\n\n    async function createTestOrganization(data: {\n      name: string;\n      slug: string;\n      isOrganization?: boolean;\n      metadata?: any;\n    }) {\n      return prismock.team.create({\n        data: {\n          name: data.name,\n          slug: data.slug,\n          isOrganization: data.isOrganization ?? true,\n          metadata: data.metadata || {},\n        },\n      });\n    }\n\n    async function createTestTeam(data: { name: string; slug: string }) {\n      return prismock.team.create({\n        data: {\n          name: data.name,\n          slug: data.slug,\n          isOrganization: false,\n        },\n      });\n    }\n\n    async function createTestMembership(data: { userId: number; teamId: number; role?: MembershipRole }) {\n      return prismock.membership.create({\n        data: {\n          createdAt: new Date(),\n          userId: data.userId,\n          teamId: data.teamId,\n          role: data.role || MembershipRole.MEMBER,\n          accepted: true,\n        },\n      });\n    }\n\n    async function createTestOnboarding(overrides?: Partial<typeof mockOrganizationOnboardingData>) {\n      return await prismock.organizationOnboarding.create({\n        data: {\n          ...mockOrganizationOnboardingData,\n          ...overrides,\n        },\n      });\n    }\n\n    const mockOrganizationOnboardingData = {\n      id: \"onboarding-123\",\n      organizationId: null,\n      name: \"Test Org\",\n      slug: \"test-org\",\n      orgOwnerEmail: \"owner@example.com\",\n      seats: 5,\n      pricePerSeat: 20,\n      billingPeriod: BillingPeriod.MONTHLY,\n      invitedMembers: [{ email: \"member1@example.com\" }, { email: \"member2@example.com\" }],\n      teams: [\n        { id: 1, name: \"Team To Move\", isBeingMigrated: true, slug: \"new-team-slug\" },\n        { id: -1, name: \"New Team\", isBeingMigrated: false, slug: null },\n      ],\n      isPlatform: false,\n      logo: null,\n      bio: null,\n      brandColor: null,\n      bannerUrl: null,\n      stripeCustomerId: \"cus_123\",\n      isDomainConfigured: false,\n      isComplete: false,\n      createdById: null,\n    };\n\n    it(\"should require payment details for billing-enabled flow\", async () => {\n      vi.spyOn(constants, \"IS_SELF_HOSTED\", \"get\").mockReturnValue(false);\n\n      const mockOrganizationOnboarding = await createTestOnboarding();\n\n      await expect(service.createOrganization(mockOrganizationOnboarding)).rejects.toThrow(\n        \"payment_subscription_id_and_payment_subscription_item_id_are_required\"\n      );\n    });\n\n    it(\"should create organization with existing user as owner\", async () => {\n      vi.spyOn(constants, \"IS_SELF_HOSTED\", \"get\").mockReturnValue(false);\n\n      const mockOrganizationOnboarding = await createTestOnboarding();\n\n      const existingUser = await createTestUser({\n        email: mockOrganizationOnboarding.orgOwnerEmail,\n        name: \"Existing User\",\n        username: \"existinguser\",\n        onboardingCompleted: true,\n        emailVerified: new Date(),\n      });\n\n      const { organization, owner } = await service.createOrganization(mockOrganizationOnboarding, {\n        subsc",
            "cost": 0.17058500000000001
        },
        "calcom__cal.com.main/packages/features/ee/teams/repositories/TeamRepository.ts": {
            "output": "import type { z } from \"zod\";\n\nimport { whereClauseForOrgWithSlugOrRequestedSlug } from \"@calcom/ee/organizations/lib/orgDomains\";\nimport logger from \"@calcom/lib/logger\";\nimport { getParsedTeam } from \"@calcom/lib/server/repository/teamUtils\";\nimport type { PrismaClient } from \"@calcom/prisma\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Prisma } from \"@calcom/prisma/client\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\nimport { teamMetadataSchema } from \"@calcom/prisma/zod-utils\";\n\ntype TeamGetPayloadWithParsedMetadata<TeamSelect extends Prisma.TeamSelect> =\n  | (Omit<Prisma.TeamGetPayload<{ select: TeamSelect }>, \"metadata\" | \"isOrganization\"> & {\n      metadata: z.infer<typeof teamMetadataSchema>;\n      isOrganization: boolean;\n    })\n  | null;\n\ntype GetTeamOrOrgArg<TeamSelect extends Prisma.TeamSelect> = {\n  lookupBy: (\n    | {\n        id: number;\n      }\n    | {\n        slug: string;\n      }\n  ) & {\n    havingMemberWithId?: number;\n  };\n  /**\n   * If we are fetching a team, this is the slug of the organization that the team belongs to.\n   */\n  forOrgWithSlug: string | null;\n  /**\n   * If true, means that we need to fetch an organization with the given slug. Otherwise, we need to fetch a team with the given slug.\n   */\n  isOrg: boolean;\n  teamSelect: TeamSelect;\n};\n\nconst log = logger.getSubLogger({ prefix: [\"repository\", \"team\"] });\n\n/**\n * Gets the team or organization with the given slug or id reliably along with parsed metadata.\n */\nasync function getTeamOrOrg<TeamSelect extends Prisma.TeamSelect>({\n  lookupBy,\n  forOrgWithSlug: forOrgWithSlug,\n  isOrg,\n  teamSelect,\n}: GetTeamOrOrgArg<TeamSelect>): Promise<TeamGetPayloadWithParsedMetadata<TeamSelect>> {\n  const where: Prisma.TeamFindFirstArgs[\"where\"] = {};\n  teamSelect = {\n    ...teamSelect,\n    metadata: true,\n    isOrganization: true,\n  } satisfies TeamSelect;\n  if (lookupBy.havingMemberWithId) where.members = { some: { userId: lookupBy.havingMemberWithId } };\n\n  if (\"id\" in lookupBy) {\n    where.id = lookupBy.id;\n  } else {\n    where.slug = lookupBy.slug;\n  }\n\n  if (isOrg) {\n    // We must fetch only the organization here.\n    // Note that an organization and a team that doesn't belong to an organization, both have parentId null\n    // If the organization has null slug(but requestedSlug is 'test') and the team also has slug 'test', we can't distinguish them without explicitly checking the metadata.isOrganization\n    // Note that, this isn't possible now to have same requestedSlug as the slug of a team not part of an organization. This is legacy teams handling mostly. But it is still safer to be sure that you are fetching an Organization only in case of isOrgView\n    where.isOrganization = true;\n    // We must fetch only the team here.\n  } else {\n    if (forOrgWithSlug) {\n      where.parent = whereClauseForOrgWithSlugOrRequestedSlug(forOrgWithSlug);\n    }\n  }\n\n  log.debug({\n    orgSlug: forOrgWithSlug,\n    teamLookupBy: lookupBy,\n    isOrgView: isOrg,\n    where,\n  });\n\n  const teams = await prisma.team.findMany({\n    where,\n    select: teamSelect,\n  });\n\n  const teamsWithParsedMetadata = teams\n    .map((team) => {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore ts types are way too complciated for this now\n      const parsedMetadata = teamMetadataSchema.parse(team.metadata ?? {});\n      return {\n        ...team,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore It does exist\n        isOrganization: team.isOrganization as boolean,\n        metadata: parsedMetadata,\n      };\n    })\n    // In cases where there are many teams with the same slug, we need to find out the one and only one that matches our criteria\n    .filter((team) => {\n      // We need an org if isOrgView otherwise we need a team\n      return isOrg ? team.isOrganization : !team.isOrganization;\n    });\n\n  if (teamsWithParsedMetadata.length > 1) {\n    log.error(\"Found more than one team/Org. We should be doing something wrong.\", {\n      isOrgView: isOrg,\n      where,\n      teams: teamsWithParsedMetadata.map((team) => {\n        const t = team as unknown as { id: number; slug: string };\n        return {\n          id: t.id,\n          slug: t.slug,\n        };\n      }),\n    });\n  }\n\n  const team = teamsWithParsedMetadata[0];\n  if (!team) return null;\n  // HACK: I am not sure how to make Prisma in peace with TypeScript with this repository pattern\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return team as any;\n}\n\nexport async function getTeam<TeamSelect extends Prisma.TeamSelect>({\n  lookupBy,\n  forOrgWithSlug: forOrgWithSlug,\n  teamSelect,\n}: Omit<GetTeamOrOrgArg<TeamSelect>, \"isOrg\">): Promise<TeamGetPayloadWithParsedMetadata<TeamSelect>> {\n  return getTeamOrOrg({\n    lookupBy,\n    forOrgWithSlug: forOrgWithSlug,\n    isOrg: false,\n    teamSelect,\n  });\n}\n\nexport async function getOrg<TeamSelect extends Prisma.TeamSelect>({\n  lookupBy,\n  forOrgWithSlug: forOrgWithSlug,\n  teamSelect,\n}: Omit<GetTeamOrOrgArg<TeamSelect>, \"isOrg\">): Promise<TeamGetPayloadWithParsedMetadata<TeamSelect>> {\n  return getTeamOrOrg({\n    lookupBy,\n    forOrgWithSlug: forOrgWithSlug,\n    isOrg: true,\n    teamSelect,\n  });\n}\n\nconst teamSelect = {\n  id: true,\n  name: true,\n  slug: true,\n  logoUrl: true,\n  parentId: true,\n  metadata: true,\n  isOrganization: true,\n  organizationSettings: true,\n  isPlatform: true,\n} satisfies Prisma.TeamSelect;\n\nexport class TeamRepository {\n  constructor(private prismaClient: PrismaClient) {}\n\n  async findById({ id }: { id: number }) {\n    const team = await this.prismaClient.team.findUnique({\n      where: {\n        id,\n      },\n      select: teamSelect,\n    });\n    if (!team) {\n      return null;\n    }\n    return getParsedTeam(team);\n  }\n\n  async findByIdIncludePlatformBilling({ id }: { id: number }) {\n    const team = await this.prismaClient.team.findUnique({\n      where: {\n        id,\n      },\n      select: { ...teamSelect, platformBilling: true },\n    });\n    if (!team) {\n      return null;\n    }\n    return getParsedTeam(team);\n  }\n\n  async findAllByParentId({\n    parentId,\n    select = teamSelect,\n  }: {\n    parentId: number;\n    select?: Prisma.TeamSelect;\n  }) {\n    return await this.prismaClient.team.findMany({\n      where: {\n        parentId,\n      },\n      select,\n    });\n  }\n\n  async findByIdAndParentId({\n    id,\n    parentId,\n    select = teamSelect,\n  }: {\n    id: number;\n    parentId: number;\n    select?: Prisma.TeamSelect;\n  }) {\n    return await this.prismaClient.team.findFirst({\n      where: {\n        id,\n        parentId,\n      },\n      select,\n    });\n  }\n\n  async findFirstBySlugAndParentSlug({\n    slug,\n    parentSlug,\n    select = teamSelect,\n  }: {\n    slug: string;\n    parentSlug: string | null;\n    select?: Prisma.TeamSelect;\n  }) {\n    return await this.prismaClient.team.findFirst({\n      where: {\n        slug,\n        parent: parentSlug ? whereClauseForOrgWithSlugOrRequestedSlug(parentSlug) : null,\n      },\n      select,\n    });\n  }\n\n  async deleteById({ id }: { id: number }) {\n    const deletedTeam = await this.prismaClient.$transaction(async (tx) => {\n      await tx.eventType.deleteMany({\n        where: {\n          teamId: id,\n          schedulingType: \"MANAGED\",\n        },\n      });\n\n      // delete all memberships\n      await tx.membership.deleteMany({\n        where: {\n          teamId: id,\n        },\n      });\n\n      const deletedTeam = await tx.team.delete({\n        where: {\n          id: id,\n        },\n      });\n\n      return deletedTeam;\n    });\n\n    return deletedTeam;\n  }\n\n  async findTeamWithMembers(teamId: number) {\n    return await this.prismaClient.team.findUnique({\n      where: { id: teamId },\n      select: {\n        members: {\n          select: {\n            accepted: true,\n          },\n        },\n        id: true,\n        metadata: true,\n        parentId: true,\n        isOrganization: true,\n      },\n    });\n  }\n\n  async findTeamsByUserId({ userId, includeOrgs }: { userId: number; includeOrgs?: boolean }) {\n    const memberships = await this.prismaClient.membership.findMany({\n      where: {\n        // Show all the teams this user belongs to regardless of the team being part of the user's org or not\n        // We don't want to restrict in the listing here. If we need to restrict a situation where a user is part of the org along with being part of a non-org team, we should do that instead of filtering out from here\n        // This became necessary when we started migrating user to Org, without migrating some teams of the user to the org\n        // Also, we would allow a user to be part of multiple orgs, then also it would be necessary.\n        userId: userId,\n      },\n      include: {\n        team: {\n          select: {\n            id: true,\n            name: true,\n            slug: true,\n            logoUrl: true,\n            isOrganization: true,\n            inviteTokens: true,\n            parent: {\n              select: {\n                id: true,\n                slug: true,\n                logoUrl: true,\n                name: true,\n                isOrganization: true,\n              },\n            },\n            parentId: true,\n          },\n        },\n      },\n      orderBy: { role: \"desc\" },\n    });\n\n    return memberships\n      .filter((mmship) => {\n        if (includeOrgs) return true;\n        return !mmship.team.isOrganization;\n      })\n      .map(({ team: { inviteTokens, ...team }, ...membership }) => {\n        // Only return inviteToken if user is OWNER or ADMIN\n        const inviteToken =\n          membership.role === \"OWNER\" || membership.role === \"ADMIN\"\n            ? inviteTokens.find((token) => token.identifier === `invite-link-for-teamId-${team.id}`)\n            : null;\n\n        return {\n          role: membership.role,\n          accepted: membership.accepted,\n          ...team,\n          /** To prevent breaking we only return non-email attached token here, if we have one */\n          inviteToken,\n        };\n      });\n  }\n\n  async findTeamWithOrganizationSettings(teamId: number) {\n    return await this.prismaClient.team.findUnique({\n      where: { id: teamId },\n      select: {\n        parent: {\n          select: {\n            isOrganization: true,\n            organizationSettings: true,\n          },\n        },\n      },\n    });\n  }\n\n  async findParentOrganizationByTeamId(teamId: number) {\n    const team = await this.prismaClient.team.findUnique({\n      where: {\n        id: teamId,\n      },\n      select: {\n        parent: {\n          select: {\n            id: true,\n          },\n        },\n      },\n    });\n\n    return team?.parent;\n  }\n\n  async findOrganizationSettingsBySlug({ slug }: { slug: string }) {\n    return await this.prismaClient.team.findFirst({\n      where: {\n        slug,\n        isOrganization: true,\n      },\n      select: {\n        organizationSettings: {\n          select: {\n            adminGetsNoSlotsNotification: true,\n          },\n        },\n      },\n    });\n  }\n\n  async findTeamSlugById({ id }: { id: number }) {\n    return await this.prismaClient.team.findUnique({\n      where: {\n        id,\n      },\n      select: {\n        slug: true,\n      },\n    });\n  }\n\n  async findTeamWithParentHideBranding({ teamId }: { teamId: number }) {\n    return await this.prismaClient.team.findUnique({\n      where: { id: teamId },\n      select: {\n        hideBranding: true,\n        parent: {\n          select: {\n            hideBranding: true,\n          },\n        },\n      },\n    });\n  }\n\n  async findOrganization({ teamId, userId }: { teamId?: number; userId: number }) {\n    return await this.prismaClient.team.findFirst({\n      where: {\n        isOrganization: true,\n        children: {\n          some: {\n            id: teamId,\n          },\n        },\n        members: {\n          some: {\n            userId,\n            accepted: true,\n          },\n        },\n      },\n      select: {\n        id: true,\n      },\n    });\n  }\n\n  async isSlugAvailableForUpdate({\n    slug,\n    teamId,\n    parentId,\n  }: {\n    slug: string;\n    teamId: number;\n    parentId?: number | null;\n  }) {\n    const whereClause: Prisma.TeamWhereInput = {\n      slug: {\n        equals: slug,\n        mode: \"insensitive\",\n      },\n      parentId: parentId ?? null,\n      NOT: { id: teamId },\n    };\n\n    const conflictingTeam = await this.prismaClient.team.findFirst({\n      where: whereClause,\n      select: { id: true },\n    });\n\n    return !conflictingTeam;\n  }\n\n  async getTeamByIdIfUserIsAdmin({ userId, teamId }: { userId: number; teamId: number }) {\n    return await this.prismaClient.team.findUnique({\n      where: {\n        id: teamId,\n      },\n      select: {\n        id: true,\n        metadata: true,\n        members: {\n          where: {\n            userId,\n            role: {\n              in: [MembershipRole.ADMIN, MembershipRole.OWNER],\n            },\n          },\n        },\n      },\n    });\n  }\n\n  async findOrgTeamsExcludingTeam({ parentId, excludeTeamId }: { parentId: number; excludeTeamId: number }) {\n    return await this.prismaClient.team.findMany({\n      where: {\n        parentI",
            "output_extracted": "import type { z } from \"zod\";\n\nimport { whereClauseForOrgWithSlugOrRequestedSlug } from \"@calcom/ee/organizations/lib/orgDomains\";\nimport logger from \"@calcom/lib/logger\";\nimport { getParsedTeam } from \"@calcom/lib/server/repository/teamUtils\";\nimport type { PrismaClient } from \"@calcom/prisma\";\nimport { prisma } from \"@calcom/prisma\";\nimport type { Prisma } from \"@calcom/prisma/client\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\nimport { teamMetadataSchema } from \"@calcom/prisma/zod-utils\";\n\ntype TeamGetPayloadWithParsedMetadata<TeamSelect extends Prisma.TeamSelect> =\n  | (Omit<Prisma.TeamGetPayload<{ select: TeamSelect }>, \"metadata\" | \"isOrganization\"> & {\n      metadata: z.infer<typeof teamMetadataSchema>;\n      isOrganization: boolean;\n    })\n  | null;\n\ntype GetTeamOrOrgArg<TeamSelect extends Prisma.TeamSelect> = {\n  lookupBy: (\n    | {\n        id: number;\n      }\n    | {\n        slug: string;\n      }\n  ) & {\n    havingMemberWithId?: number;\n  };\n  /**\n   * If we are fetching a team, this is the slug of the organization that the team belongs to.\n   */\n  forOrgWithSlug: string | null;\n  /**\n   * If true, means that we need to fetch an organization with the given slug. Otherwise, we need to fetch a team with the given slug.\n   */\n  isOrg: boolean;\n  teamSelect: TeamSelect;\n};\n\nconst log = logger.getSubLogger({ prefix: [\"repository\", \"team\"] });\n\n/**\n * Gets the team or organization with the given slug or id reliably along with parsed metadata.\n */\nasync function getTeamOrOrg<TeamSelect extends Prisma.TeamSelect>({\n  lookupBy,\n  forOrgWithSlug: forOrgWithSlug,\n  isOrg,\n  teamSelect,\n}: GetTeamOrOrgArg<TeamSelect>): Promise<TeamGetPayloadWithParsedMetadata<TeamSelect>> {\n  const where: Prisma.TeamFindFirstArgs[\"where\"] = {};\n  teamSelect = {\n    ...teamSelect,\n    metadata: true,\n    isOrganization: true,\n  } satisfies TeamSelect;\n  if (lookupBy.havingMemberWithId) where.members = { some: { userId: lookupBy.havingMemberWithId } };\n\n  if (\"id\" in lookupBy) {\n    where.id = lookupBy.id;\n  } else {\n    where.slug = lookupBy.slug;\n  }\n\n  if (isOrg) {\n    // We must fetch only the organization here.\n    // Note that an organization and a team that doesn't belong to an organization, both have parentId null\n    // If the organization has null slug(but requestedSlug is 'test') and the team also has slug 'test', we can't distinguish them without explicitly checking the metadata.isOrganization\n    // Note that, this isn't possible now to have same requestedSlug as the slug of a team not part of an organization. This is legacy teams handling mostly. But it is still safer to be sure that you are fetching an Organization only in case of isOrgView\n    where.isOrganization = true;\n    // We must fetch only the team here.\n  } else {\n    if (forOrgWithSlug) {\n      where.parent = whereClauseForOrgWithSlugOrRequestedSlug(forOrgWithSlug);\n    }\n  }\n\n  log.debug({\n    orgSlug: forOrgWithSlug,\n    teamLookupBy: lookupBy,\n    isOrgView: isOrg,\n    where,\n  });\n\n  const teams = await prisma.team.findMany({\n    where,\n    select: teamSelect,\n  });\n\n  const teamsWithParsedMetadata = teams\n    .map((team) => {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore ts types are way too complciated for this now\n      const parsedMetadata = teamMetadataSchema.parse(team.metadata ?? {});\n      return {\n        ...team,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore It does exist\n        isOrganization: team.isOrganization as boolean,\n        metadata: parsedMetadata,\n      };\n    })\n    // In cases where there are many teams with the same slug, we need to find out the one and only one that matches our criteria\n    .filter((team) => {\n      // We need an org if isOrgView otherwise we need a team\n      return isOrg ? team.isOrganization : !team.isOrganization;\n    });\n\n  if (teamsWithParsedMetadata.length > 1) {\n    log.error(\"Found more than one team/Org. We should be doing something wrong.\", {\n      isOrgView: isOrg,\n      where,\n      teams: teamsWithParsedMetadata.map((team) => {\n        const t = team as unknown as { id: number; slug: string };\n        return {\n          id: t.id,\n          slug: t.slug,\n        };\n      }),\n    });\n  }\n\n  const team = teamsWithParsedMetadata[0];\n  if (!team) return null;\n  // HACK: I am not sure how to make Prisma in peace with TypeScript with this repository pattern\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return team as any;\n}\n\nexport async function getTeam<TeamSelect extends Prisma.TeamSelect>({\n  lookupBy,\n  forOrgWithSlug: forOrgWithSlug,\n  teamSelect,\n}: Omit<GetTeamOrOrgArg<TeamSelect>, \"isOrg\">): Promise<TeamGetPayloadWithParsedMetadata<TeamSelect>> {\n  return getTeamOrOrg({\n    lookupBy,\n    forOrgWithSlug: forOrgWithSlug,\n    isOrg: false,\n    teamSelect,\n  });\n}\n\nexport async function getOrg<TeamSelect extends Prisma.TeamSelect>({\n  lookupBy,\n  forOrgWithSlug: forOrgWithSlug,\n  teamSelect,\n}: Omit<GetTeamOrOrgArg<TeamSelect>, \"isOrg\">): Promise<TeamGetPayloadWithParsedMetadata<TeamSelect>> {\n  return getTeamOrOrg({\n    lookupBy,\n    forOrgWithSlug: forOrgWithSlug,\n    isOrg: true,\n    teamSelect,\n  });\n}\n\nconst teamSelect = {\n  id: true,\n  name: true,\n  slug: true,\n  logoUrl: true,\n  parentId: true,\n  metadata: true,\n  isOrganization: true,\n  organizationSettings: true,\n  isPlatform: true,\n} satisfies Prisma.TeamSelect;\n\nexport class TeamRepository {\n  constructor(private prismaClient: PrismaClient) {}\n\n  async findById({ id }: { id: number }) {\n    const team = await this.prismaClient.team.findUnique({\n      where: {\n        id,\n      },\n      select: teamSelect,\n    });\n    if (!team) {\n      return null;\n    }\n    return getParsedTeam(team);\n  }\n\n  async findByIdIncludePlatformBilling({ id }: { id: number }) {\n    const team = await this.prismaClient.team.findUnique({\n      where: {\n        id,\n      },\n      select: { ...teamSelect, platformBilling: true },\n    });\n    if (!team) {\n      return null;\n    }\n    return getParsedTeam(team);\n  }\n\n  async findAllByParentId({\n    parentId,\n    select = teamSelect,\n  }: {\n    parentId: number;\n    select?: Prisma.TeamSelect;\n  }) {\n    return await this.prismaClient.team.findMany({\n      where: {\n        parentId,\n      },\n      select,\n    });\n  }\n\n  async findByIdAndParentId({\n    id,\n    parentId,\n    select = teamSelect,\n  }: {\n    id: number;\n    parentId: number;\n    select?: Prisma.TeamSelect;\n  }) {\n    return await this.prismaClient.team.findFirst({\n      where: {\n        id,\n        parentId,\n      },\n      select,\n    });\n  }\n\n  async findFirstBySlugAndParentSlug({\n    slug,\n    parentSlug,\n    select = teamSelect,\n  }: {\n    slug: string;\n    parentSlug: string | null;\n    select?: Prisma.TeamSelect;\n  }) {\n    return await this.prismaClient.team.findFirst({\n      where: {\n        slug,\n        parent: parentSlug ? whereClauseForOrgWithSlugOrRequestedSlug(parentSlug) : null,\n      },\n      select,\n    });\n  }\n\n  async deleteById({ id }: { id: number }) {\n    const deletedTeam = await this.prismaClient.$transaction(async (tx) => {\n      await tx.eventType.deleteMany({\n        where: {\n          teamId: id,\n          schedulingType: \"MANAGED\",\n        },\n      });\n\n      // delete all memberships\n      await tx.membership.deleteMany({\n        where: {\n          teamId: id,\n        },\n      });\n\n      const deletedTeam = await tx.team.delete({\n        where: {\n          id: id,\n        },\n      });\n\n      return deletedTeam;\n    });\n\n    return deletedTeam;\n  }\n\n  async findTeamWithMembers(teamId: number) {\n    return await this.prismaClient.team.findUnique({\n      where: { id: teamId },\n      select: {\n        members: {\n          select: {\n            accepted: true,\n          },\n        },\n        id: true,\n        metadata: true,\n        parentId: true,\n        isOrganization: true,\n      },\n    });\n  }\n\n  async findTeamsByUserId({ userId, includeOrgs }: { userId: number; includeOrgs?: boolean }) {\n    const memberships = await this.prismaClient.membership.findMany({\n      where: {\n        // Show all the teams this user belongs to regardless of the team being part of the user's org or not\n        // We don't want to restrict in the listing here. If we need to restrict a situation where a user is part of the org along with being part of a non-org team, we should do that instead of filtering out from here\n        // This became necessary when we started migrating user to Org, without migrating some teams of the user to the org\n        // Also, we would allow a user to be part of multiple orgs, then also it would be necessary.\n        userId: userId,\n      },\n      include: {\n        team: {\n          select: {\n            id: true,\n            name: true,\n            slug: true,\n            logoUrl: true,\n            isOrganization: true,\n            inviteTokens: true,\n            parent: {\n              select: {\n                id: true,\n                slug: true,\n                logoUrl: true,\n                name: true,\n                isOrganization: true,\n              },\n            },\n            parentId: true,\n          },\n        },\n      },\n      orderBy: { role: \"desc\" },\n    });\n\n    return memberships\n      .filter((mmship) => {\n        if (includeOrgs) return true;\n        return !mmship.team.isOrganization;\n      })\n      .map(({ team: { inviteTokens, ...team }, ...membership }) => {\n        // Only return inviteToken if user is OWNER or ADMIN\n        const inviteToken =\n          membership.role === \"OWNER\" || membership.role === \"ADMIN\"\n            ? inviteTokens.find((token) => token.identifier === `invite-link-for-teamId-${team.id}`)\n            : null;\n\n        return {\n          role: membership.role,\n          accepted: membership.accepted,\n          ...team,\n          /** To prevent breaking we only return non-email attached token here, if we have one */\n          inviteToken,\n        };\n      });\n  }\n\n  async findTeamWithOrganizationSettings(teamId: number) {\n    return await this.prismaClient.team.findUnique({\n      where: { id: teamId },\n      select: {\n        parent: {\n          select: {\n            isOrganization: true,\n            organizationSettings: true,\n          },\n        },\n      },\n    });\n  }\n\n  async findParentOrganizationByTeamId(teamId: number) {\n    const team = await this.prismaClient.team.findUnique({\n      where: {\n        id: teamId,\n      },\n      select: {\n        parent: {\n          select: {\n            id: true,\n          },\n        },\n      },\n    });\n\n    return team?.parent;\n  }\n\n  async findOrganizationSettingsBySlug({ slug }: { slug: string }) {\n    return await this.prismaClient.team.findFirst({\n      where: {\n        slug,\n        isOrganization: true,\n      },\n      select: {\n        organizationSettings: {\n          select: {\n            adminGetsNoSlotsNotification: true,\n          },\n        },\n      },\n    });\n  }\n\n  async findTeamSlugById({ id }: { id: number }) {\n    return await this.prismaClient.team.findUnique({\n      where: {\n        id,\n      },\n      select: {\n        slug: true,\n      },\n    });\n  }\n\n  async findTeamWithParentHideBranding({ teamId }: { teamId: number }) {\n    return await this.prismaClient.team.findUnique({\n      where: { id: teamId },\n      select: {\n        hideBranding: true,\n        parent: {\n          select: {\n            hideBranding: true,\n          },\n        },\n      },\n    });\n  }\n\n  async findOrganization({ teamId, userId }: { teamId?: number; userId: number }) {\n    return await this.prismaClient.team.findFirst({\n      where: {\n        isOrganization: true,\n        children: {\n          some: {\n            id: teamId,\n          },\n        },\n        members: {\n          some: {\n            userId,\n            accepted: true,\n          },\n        },\n      },\n      select: {\n        id: true,\n      },\n    });\n  }\n\n  async isSlugAvailableForUpdate({\n    slug,\n    teamId,\n    parentId,\n  }: {\n    slug: string;\n    teamId: number;\n    parentId?: number | null;\n  }) {\n    const whereClause: Prisma.TeamWhereInput = {\n      slug: {\n        equals: slug,\n        mode: \"insensitive\",\n      },\n      parentId: parentId ?? null,\n      NOT: { id: teamId },\n    };\n\n    const conflictingTeam = await this.prismaClient.team.findFirst({\n      where: whereClause,\n      select: { id: true },\n    });\n\n    return !conflictingTeam;\n  }\n\n  async getTeamByIdIfUserIsAdmin({ userId, teamId }: { userId: number; teamId: number }) {\n    return await this.prismaClient.team.findUnique({\n      where: {\n        id: teamId,\n      },\n      select: {\n        id: true,\n        metadata: true,\n        members: {\n          where: {\n            userId,\n            role: {\n              in: [MembershipRole.ADMIN, MembershipRole.OWNER],\n            },\n          },\n        },\n      },\n    });\n  }\n\n  async findOrgTeamsExcludingTeam({ parentId, excludeTeamId }: { parentId: number; excludeTeamId: number }) {\n    return await this.prismaClient.team.findMany({\n      where: {\n        parentI",
            "cost": 0.13317500000000002
        },
        "calcom__cal.com.main/packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts": {
            "output": "import { prisma } from \"@calcom/prisma\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\n\nimport type { TrpcSessionUser } from \"../../../types\";\n\ntype ListOptions = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  };\n};\n\nexport const listOwnedTeamsHandler = async ({ ctx }: ListOptions) => {\n  const user = await prisma.user.findUnique({\n    where: {\n      id: ctx.user.id,\n    },\n    select: {\n      id: true,\n      teams: {\n        where: {\n          accepted: true,\n          role: {\n            in: [MembershipRole.OWNER, MembershipRole.ADMIN],\n          },\n        },\n        select: {\n          team: true,\n        },\n      },\n    },\n  });\n\n  return user?.teams\n    ?.filter((m) => {\n      return !m.team.isOrganization;\n    })\n    ?.map(({ team }) => team);\n};",
            "output_extracted": "import { prisma } from \"@calcom/prisma\";\nimport { MembershipRole } from \"@calcom/prisma/enums\";\n\nimport type { TrpcSessionUser } from \"../../../types\";\n\ntype ListOptions = {\n  ctx: {\n    user: NonNullable<TrpcSessionUser>;\n  };\n};\n\nexport const listOwnedTeamsHandler = async ({ ctx }: ListOptions) => {\n  const user = await prisma.user.findUnique({\n    where: {\n      id: ctx.user.id,\n    },\n    select: {\n      id: true,\n      teams: {\n        where: {\n          accepted: true,\n          role: {\n            in: [MembershipRole.OWNER, MembershipRole.ADMIN],\n          },\n        },\n        select: {\n          team: true,\n        },\n      },\n    },\n  });\n\n  return user?.teams\n    ?.filter((m) => {\n      return !m.team.isOrganization;\n    })\n    ?.map(({ team }) => team);\n};",
            "cost": 0.0134
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25291",
        "repo": "calcom/cal.com",
        "base_commit": "1578dee6223806d7b70d6cbb721e8cae9a3406d7",
        "head_commit": "1f453db4980de963bfe0e078ebd95a0394aa61c3",
        "title": "feat: Ensure teams with conflicting slugs owned by the user are migrated(handled in backend, frontend already had this restriction)",
        "merged_at": "2025-11-22T09:07:28Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25291",
        "test_files": [
            "packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts",
            "packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts"
        ],
        "code_files": [
            "packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts",
            "packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts",
            "packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts",
            "packages/features/ee/teams/repositories/TeamRepository.ts",
            "packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts"
        ],
        "total_changes": 377,
        "num_files": 7,
        "pull_number": 25291,
        "patch": "diff --git a/packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts b/packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts\nindex 362f39fae50fd8..aec24735655b78 100644\n--- a/packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts\n+++ b/packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts\n@@ -9,6 +9,7 @@ import {\n   setupDomain,\n } from \"@calcom/features/ee/organizations/lib/server/orgCreationUtils\";\n import { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\n+import { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n import { DEFAULT_SCHEDULE, getAvailabilityFromSchedule } from \"@calcom/lib/availability\";\n import { WEBAPP_URL } from \"@calcom/lib/constants\";\n@@ -143,8 +144,52 @@ export abstract class BaseOnboardingService implements IOrganizationOnboardingSe\n     return organizationOnboarding;\n   }\n \n-  protected filterTeamsAndInvites(teams: TeamInput[] = [], invitedMembers: InvitedMemberInput[] = []) {\n-    const teamsData = teams\n+  private async ensureConflictingSlugTeamIsMigrated(\n+    orgSlug: string,\n+    teams: TeamInput[] = []\n+  ): Promise<TeamInput[]> {\n+    const teamRepository = new TeamRepository(prisma);\n+    const ownedTeams = await teamRepository.findOwnedTeamsByUserId({ userId: this.user.id });\n+\n+    const conflictingTeam = ownedTeams.find((team) => team.slug === orgSlug);\n+\n+    if (!conflictingTeam) {\n+      return teams;\n+    }\n+\n+    const existingTeam = teams.find((t) => t.id === conflictingTeam.id);\n+\n+    if (existingTeam) {\n+      if (existingTeam.isBeingMigrated) {\n+        return teams;\n+      }\n+\n+      return teams.map((team) =>\n+        team.id === conflictingTeam.id\n+          ? { ...team, isBeingMigrated: true }\n+          : team\n+      );\n+    }\n+\n+    return [\n+      ...teams,\n+      {\n+        id: conflictingTeam.id,\n+        name: conflictingTeam.name,\n+        isBeingMigrated: true,\n+        slug: conflictingTeam.slug,\n+      },\n+    ];\n+  }\n+\n+  protected async buildTeamsAndInvites(\n+    orgSlug: string,\n+    teams: TeamInput[] = [],\n+    invitedMembers: InvitedMemberInput[] = []\n+  ) {\n+    const enrichedTeams = await this.ensureConflictingSlugTeamIsMigrated(orgSlug, teams);\n+\n+    const teamsData = enrichedTeams\n       .filter((team) => team.name.trim().length > 0)\n       .map((team) => ({\n         id: team.id === -1 ? -1 : team.id,\ndiff --git a/packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts b/packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts\nindex f8f059f4c0176c..3b63e0167f48b6 100644\n--- a/packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts\n+++ b/packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts\n@@ -43,7 +43,11 @@ export class BillingEnabledOrgOnboardingService extends BaseOnboardingService {\n       })\n     );\n \n-    const { teamsData, invitedMembersData } = this.filterTeamsAndInvites(input.teams, input.invitedMembers);\n+    const { teamsData, invitedMembersData } = await this.buildTeamsAndInvites(\n+      input.slug,\n+      input.teams,\n+      input.invitedMembers\n+    );\n \n     log.debug(\n       \"BillingEnabledOrgOnboardingService - After filterTeamsAndInvites\",\ndiff --git a/packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts b/packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts\nindex 4a85d589ca617b..d87bcf822b2d1c 100644\n--- a/packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts\n+++ b/packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts\n@@ -28,7 +28,7 @@ const teamsSchema = orgOnboardingTeamsSchema;\n /**\n  * Handles organization onboarding when billing is disabled (self-hosted admin flow).\n  *\n- * Flow:\n+* Flow:\n  * 1. Create onboarding record\n  * 2. Store teams/invites in database\n  * 3. Immediately create organization, teams, and invite members\n@@ -46,8 +46,12 @@ export class SelfHostedOrganizationOnboardingService extends BaseOnboardingServi\n       })\n     );\n \n-    // Step 1: Filter and normalize teams/invites\n-    const { teamsData, invitedMembersData } = this.filterTeamsAndInvites(input.teams, input.invitedMembers);\n+    // Step 1: Build and validate teams/invites (includes conflict slug detection)\n+    const { teamsData, invitedMembersData } = await this.buildTeamsAndInvites(\n+      input.slug,\n+      input.teams,\n+      input.invitedMembers\n+    );\n \n     // Step 2: Create onboarding record with ALL data at once\n     const organizationOnboarding = await this.createOnboardingRecord({\ndiff --git a/packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts b/packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts\nindex 96d02fe588d4e0..6823792acf7866 100644\n--- a/packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts\n+++ b/packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts\n@@ -1,24 +1,35 @@\n-import { describe, expect, it } from \"vitest\";\n+import { describe, expect, it, vi } from \"vitest\";\n \n+import type { User } from \"@calcom/prisma/client\";\n import { UserPermissionRole } from \"@calcom/prisma/enums\";\n \n+vi.mock(\"@calcom/features/ee/teams/repositories/TeamRepository\", () => ({\n+  TeamRepository: class {\n+    constructor() {}\n+    findOwnedTeamsByUserId(_: { userId: number }) {\n+      return Promise.resolve([]);\n+    }\n+  },\n+}));\n+\n import { BaseOnboardingService } from \"../BaseOnboardingService\";\n-import type { CreateOnboardingIntentInput } from \"../types\";\n+import type { CreateOnboardingIntentInput, OnboardingIntentResult } from \"../types\";\n \n class TestableBaseOnboardingService extends BaseOnboardingService {\n-  async createOnboardingIntent(input: CreateOnboardingIntentInput): Promise<any> {\n+  async createOnboardingIntent(_input: CreateOnboardingIntentInput): Promise<OnboardingIntentResult> {\n     throw new Error(\"Not implemented\");\n   }\n \n-  public testFilterTeamsAndInvites(\n+  public async testBuildTeamsAndInvites(\n+    orgSlug: string,\n     teams: CreateOnboardingIntentInput[\"teams\"],\n     invitedMembers: CreateOnboardingIntentInput[\"invitedMembers\"]\n   ) {\n-    return this.filterTeamsAndInvites(teams, invitedMembers);\n+    return this.buildTeamsAndInvites(orgSlug, teams, invitedMembers);\n   }\n }\n \n-const mockUser = {\n+const mockUser: Pick<User, \"id\" | \"email\" | \"role\" | \"name\"> = {\n   id: 1,\n   email: \"user@example.com\",\n   role: UserPermissionRole.USER,\n@@ -26,9 +37,9 @@ const mockUser = {\n };\n \n describe(\"BaseOnboardingService\", () => {\n-  describe(\"filterTeamsAndInvites\", () => {\n-    it(\"should filter out invites with empty emails\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+  describe(\"buildTeamsAndInvites\", () => {\n+    it(\"should filter out invites with empty emails\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const invites = [\n         { email: \"valid@example.com\", teamName: \"Marketing\", role: \"MEMBER\" },\n@@ -37,7 +48,7 @@ describe(\"BaseOnboardingService\", () => {\n         { email: \"another@example.com\", teamName: \"Design\", role: \"MEMBER\" },\n       ];\n \n-      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n+      const { invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", [], invites);\n \n       expect(invitedMembersData).toHaveLength(2);\n       expect(invitedMembersData).toEqual([\n@@ -58,8 +69,8 @@ describe(\"BaseOnboardingService\", () => {\n       ]);\n     });\n \n-    it(\"should preserve all fields from invites including role\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should preserve all fields from invites including role\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const invites = [\n         {\n@@ -78,7 +89,7 @@ describe(\"BaseOnboardingService\", () => {\n         },\n       ];\n \n-      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n+      const { invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", [], invites);\n \n       expect(invitedMembersData).toEqual([\n         {\n@@ -98,15 +109,15 @@ describe(\"BaseOnboardingService\", () => {\n       ]);\n     });\n \n-    it(\"should handle invites without optional fields\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should handle invites without optional fields\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const invites = [\n         { email: \"minimal@example.com\" },\n         { email: \"withteam@example.com\", teamName: \"Sales\" },\n       ];\n \n-      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n+      const { invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", [], invites);\n \n       expect(invitedMembersData).toEqual([\n         {\n@@ -126,8 +137,8 @@ describe(\"BaseOnboardingService\", () => {\n       ]);\n     });\n \n-    it(\"should filter out teams with empty names\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should filter out teams with empty names\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const teams = [\n         { id: 1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n@@ -136,7 +147,7 @@ describe(\"BaseOnboardingService\", () => {\n         { id: 4, name: \"Engineering\", isBeingMigrated: true, slug: \"eng\" },\n       ];\n \n-      const { teamsData } = service.testFilterTeamsAndInvites(teams, []);\n+      const { teamsData } = await service.testBuildTeamsAndInvites(\"test-org\", teams, []);\n \n       expect(teamsData).toHaveLength(2);\n       expect(teamsData).toEqual([\n@@ -145,15 +156,15 @@ describe(\"BaseOnboardingService\", () => {\n       ]);\n     });\n \n-    it(\"should preserve team properties including migration status\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should preserve team properties including migration status\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const teams = [\n         { id: -1, name: \"New Team\", isBeingMigrated: false, slug: null },\n         { id: 42, name: \"Existing Team\", isBeingMigrated: true, slug: \"existing-team\" },\n       ];\n \n-      const { teamsData } = service.testFilterTeamsAndInvites(teams, []);\n+      const { teamsData } = await service.testBuildTeamsAndInvites(\"test-org\", teams, []);\n \n       expect(teamsData).toEqual([\n         { id: -1, name: \"New Team\", isBeingMigrated: false, slug: null },\n@@ -161,26 +172,26 @@ describe(\"BaseOnboardingService\", () => {\n       ]);\n     });\n \n-    it(\"should handle empty teams and invites arrays\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should handle empty teams and invites arrays\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n-      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites([], []);\n+      const { teamsData, invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", [], []);\n \n       expect(teamsData).toEqual([]);\n       expect(invitedMembersData).toEqual([]);\n     });\n \n-    it(\"should handle undefined teams and invites\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should handle undefined teams and invites\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n-      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(undefined, undefined);\n+      const { teamsData, invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", undefined, undefined);\n \n       expect(teamsData).toEqual([]);\n       expect(invitedMembersData).toEqual([]);\n     });\n \n-    it(\"should preserve invites with teamId=-1 for new teams\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should preserve invites with teamId=-1 for new teams\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const teams = [\n         { id: -1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n@@ -192,7 +203,7 @@ describe(\"BaseOnboardingService\", () => {\n         { email: \"user2@example.com\", teamId: -1, teamName: \"Sales\", role: \"ADMIN\" },\n       ];\n \n-      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(teams, invites);\n+      const { teamsData, invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", teams, invites);\n \n       expect(teamsData).toHaveLength(2);\n       expect(invitedMembersData).toHaveLength(2);\n@@ -202,8 +213,8 @@ describe(\"BaseOnboardingService\", () => {\n       expect(invitedMembersData[1].role).toBe(\"ADMIN\");\n     });\n \n-    it(\"should handle mixed scenarios with both org-level and team-specific invites\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should handle mixed scenarios with both org-level and team-specific invites\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const teams = [\n         { id: -1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n@@ -216,7 +227,7 @@ describe(\"BaseOnboardingService\", () => {\n         { email: \"eng@example.com\", teamName: \"Engineering\", teamId: 42, role: \"ADMIN\" },\n       ];\n \n-      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(teams, invites);\n+      const { teamsData, invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", teams, invites);\n \n       expect(teamsData).toHaveLength(2);\n       expect(invitedMembersData).toHaveLength(3);\ndiff --git a/packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts b/packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts\nindex 1879a9c539c108..d1e878627b6dcd 100644\n--- a/packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts\n+++ b/packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts\n@@ -223,6 +223,181 @@ describe(\"BillingEnabledOrgOnboardingService\", () => {\n       });\n     });\n \n+    it(\"should automatically migrate team with conflicting slug\", async () => {\n+      // Create a team owned by the user with the same slug as the org\n+      const conflictingTeam = await prismock.team.create({\n+        data: {\n+          id: 100,\n+          name: \"Test Org Team\",\n+          slug: \"test-org\", // Same as mockInput.slug\n+        },\n+      });\n+\n+      await prismock.membership.create({\n+        data: {\n+          userId: mockUser.id,\n+          teamId: conflictingTeam.id,\n+          role: MembershipRole.OWNER,\n+          accepted: true,\n+        },\n+      });\n+\n+      const inputWithoutConflictingTeam = {\n+        ...mockInput,\n+        teams: [{ id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null }],\n+      };\n+\n+      await service.createOnboardingIntent(inputWithoutConflictingTeam);\n+\n+      // Verify the conflicting team was automatically added to migration\n+      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teams: expect.arrayContaining([\n+            { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n+            { id: 100, name: \"Test Org Team\", isBeingMigrated: true, slug: \"test-org\" },\n+          ]),\n+        })\n+      );\n+    });\n+\n+    it(\"should mark existing team for migration if slug conflicts\", async () => {\n+      // Create a team owned by the user with the same slug as the org\n+      const conflictingTeam = await prismock.team.create({\n+        data: {\n+          id: 100,\n+          name: \"Test Org Team\",\n+          slug: \"test-org\", // Same as mockInput.slug\n+        },\n+      });\n+\n+      await prismock.membership.create({\n+        data: {\n+          userId: mockUser.id,\n+          teamId: conflictingTeam.id,\n+          role: MembershipRole.OWNER,\n+          accepted: true,\n+        },\n+      });\n+\n+      const inputWithConflictingTeamNotMigrated = {\n+        ...mockInput,\n+        teams: [\n+          { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n+          { id: 100, name: \"Test Org Team\", isBeingMigrated: false, slug: \"test-org\" },\n+        ],\n+      };\n+\n+      await service.createOnboardingIntent(inputWithConflictingTeamNotMigrated);\n+\n+      // Verify the conflicting team was marked for migration\n+      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teams: expect.arrayContaining([\n+            { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n+            { id: 100, name: \"Test Org Team\", isBeingMigrated: true, slug: \"test-org\" },\n+          ]),\n+        })\n+      );\n+    });\n+\n+    it(\"should not duplicate team if already marked for migration with conflicting slug\", async () => {\n+      // Create a team owned by the user with the same slug as the org\n+      const conflictingTeam = await prismock.team.create({\n+        data: {\n+          id: 100,\n+          name: \"Test Org Team\",\n+          slug: \"test-org\", // Same as mockInput.slug\n+        },\n+      });\n+\n+      await prismock.membership.create({\n+        data: {\n+          userId: mockUser.id,\n+          teamId: conflictingTeam.id,\n+          role: MembershipRole.OWNER,\n+          accepted: true,\n+        },\n+      });\n+\n+      const inputWithConflictingTeamAlreadyMigrated = {\n+        ...mockInput,\n+        teams: [\n+          { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n+          { id: 100, name: \"Test Org Team\", isBeingMigrated: true, slug: \"test-org\" },\n+        ],\n+      };\n+\n+      await service.createOnboardingIntent(inputWithConflictingTeamAlreadyMigrated);\n+\n+      // Verify no duplication occurred\n+      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teams: [\n+            { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n+            { id: 100, name: \"Test Org Team\", isBeingMigrated: true, slug: \"test-org\" },\n+          ],\n+        })\n+      );\n+    });\n+\n+    it(\"should not migrate team with non-conflicting slug\", async () => {\n+      // Create a team owned by the user with a different slug\n+      const nonConflictingTeam = await prismock.team.create({\n+        data: {\n+          id: 100,\n+          name: \"Different Team\",\n+          slug: \"different-team\",\n+        },\n+      });\n+\n+      await prismock.membership.create({\n+        data: {\n+          userId: mockUser.id,\n+          teamId: nonConflictingTeam.id,\n+          role: MembershipRole.OWNER,\n+          accepted: true,\n+        },\n+      });\n+\n+      await service.createOnboardingIntent(mockInput);\n+\n+      // Verify the non-conflicting team was NOT added\n+      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teams: mockInput.teams,\n+        })\n+      );\n+    });\n+\n+    it(\"should only migrate teams where user is OWNER or ADMIN\", async () => {\n+      // Create a team with conflicting slug but user is only a MEMBER\n+      const teamAsMember = await prismock.team.create({\n+        data: {\n+          id: 100,\n+          name: \"Team As Member\",\n+          slug: \"test-org\",\n+        },\n+      });\n+\n+      await prismock.membership.create({\n+        data: {\n+          userId: mockUser.id,\n+          teamId: teamAsMember.id,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+        },\n+      });\n+\n+      await service.createOnboardingIntent(mockInput);\n+\n+      // Verify the team was NOT migrated (user isn't owner/admin)\n+      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teams: mockInput.teams,\n+        })\n+      );\n+    });\n+\n     it(\"should immediately create organization when admin creates org for self\", async () => {\n       vi.spyOn(constants, \"IS_SELF_HOSTED\", \"get\").mockReturnValue(false);\n \ndiff --git a/packages/features/ee/teams/repositories/TeamRepository.ts b/packages/features/ee/teams/repositories/TeamRepository.ts\nindex 293c5a375bb35b..3dc3c99f066906 100644\n--- a/packages/features/ee/teams/repositories/TeamRepository.ts\n+++ b/packages/features/ee/teams/repositories/TeamRepository.ts\n@@ -333,6 +333,35 @@ export class TeamRepository {\n       }));\n   }\n \n+  /**\n+   * Get teams where the user is an OWNER or ADMIN (excludes organizations)\n+   */\n+  async findOwnedTeamsByUserId({ userId }: { userId: number }) {\n+    const memberships = await this.prismaClient.membership.findMany({\n+      where: {\n+        userId: userId,\n+        accepted: true,\n+        role: {\n+          in: [MembershipRole.OWNER, MembershipRole.ADMIN],\n+        },\n+      },\n+      include: {\n+        team: {\n+          select: {\n+            id: true,\n+            name: true,\n+            slug: true,\n+            isOrganization: true,\n+          },\n+        },\n+      },\n+    });\n+\n+    return memberships\n+      .filter((mmship) => !mmship.team.isOrganization)\n+      .map((mmship) => mmship.team);\n+  }\n+\n   async findTeamWithOrganizationSettings(teamId: number) {\n     return await this.prismaClient.team.findUnique({\n       where: { id: teamId },\ndiff --git a/packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts b/packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts\nindex ca7e53d22e5335..03df2789559deb 100644\n--- a/packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts\n+++ b/packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts\n@@ -1,5 +1,5 @@\n+import { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\n import { prisma } from \"@calcom/prisma\";\n-import { MembershipRole } from \"@calcom/prisma/enums\";\n \n import type { TrpcSessionUser } from \"../../../types\";\n \n@@ -10,29 +10,6 @@ type ListOptions = {\n };\n \n export const listOwnedTeamsHandler = async ({ ctx }: ListOptions) => {\n-  const user = await prisma.user.findUnique({\n-    where: {\n-      id: ctx.user.id,\n-    },\n-    select: {\n-      id: true,\n-      teams: {\n-        where: {\n-          accepted: true,\n-          role: {\n-            in: [MembershipRole.OWNER, MembershipRole.ADMIN],\n-          },\n-        },\n-        select: {\n-          team: true,\n-        },\n-      },\n-    },\n-  });\n-\n-  return user?.teams\n-    ?.filter((m) => {\n-      return !m.team.isOrganization;\n-    })\n-    ?.map(({ team }) => team);\n+  const teamRepository = new TeamRepository(prisma);\n+  return await teamRepository.findOwnedTeamsByUserId({ userId: ctx.user.id });\n };\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}