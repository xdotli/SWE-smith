{
    "cost": 0.35586,
    "rewrites": {
        "calcom__cal.com.main/packages/features/bookings/lib/getLuckyUser.test.ts": {
            "output": "import CalendarManagerMock from \"../../../../tests/libs/__mocks__/CalendarManager\";\nimport prismaMock from \"../../../../tests/libs/__mocks__/prismaMock\";\n\nimport { v4 as uuid } from \"uuid\";\nimport { expect, it, describe, vi, beforeAll } from \"vitest\";\n\nimport dayjs from \"@calcom/dayjs\";\nimport { getLuckyUserService } from \"@calcom/features/di/containers/LuckyUser\";\nimport { buildUser, buildBooking } from \"@calcom/lib/test/builder\";\nimport { AttributeType, RRResetInterval, RRTimestampBasis } from \"@calcom/prisma/enums\";\n\nimport { getIntervalStartDate, getIntervalEndDate } from \"./getLuckyUser\";\n\nconst luckyUserService = getLuckyUserService();\n\ntype NonEmptyArray<T> = [T, ...T[]];\ntype GetLuckyUserAvailableUsersType = NonEmptyArray<ReturnType<typeof buildUser>>;\n\nvi.mock(\"@calcom/app-store/routing-forms/components/react-awesome-query-builder/widgets\", () => ({\n  default: {},\n}));\n\nbeforeAll(() => {\n  vi.setSystemTime(new Date(\"2021-06-20T11:59:59Z\"));\n});\n\nit(\"can find lucky user with maximize availability\", async () => {\n  const users: GetLuckyUserAvailableUsersType = [\n    buildUser({\n      id: 1,\n      username: \"test1\",\n      name: \"Test User 1\",\n      email: \"test1@example.com\",\n      bookings: [\n        {\n          createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n        },\n        {\n          createdAt: new Date(\"2022-01-25T06:30:00.000Z\"),\n        },\n      ],\n    }),\n    buildUser({\n      id: 2,\n      username: \"test2\",\n      name: \"Test User 2\",\n      email: \"test2@example.com\",\n      bookings: [\n        {\n          createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n        },\n      ],\n    }),\n  ];\n\n  CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue({ success: true, data: [] });\n  prismaMock.outOfOfficeEntry.findMany.mockResolvedValue([]);\n\n  prismaMock.user.findMany.mockResolvedValue(users);\n  prismaMock.host.findMany.mockResolvedValue([]);\n  prismaMock.booking.findMany.mockResolvedValue([]);\n\n  await expect(\n    luckyUserService.getLuckyUser({\n      availableUsers: users,\n      eventType: {\n        id: 1,\n        isRRWeightsEnabled: false,\n        team: { rrResetInterval: RRResetInterval.MONTH, rrTimestampBasis: RRTimestampBasis.CREATED_AT },\n        includeNoShowInRRCalculation: false,\n      },\n      allRRHosts: [],\n      routingFormResponse: null,\n    })\n  ).resolves.toStrictEqual(users[1]);\n});\n\nit(\"can find lucky user with maximize availability and priority ranking\", async () => {\n  const users: GetLuckyUserAvailableUsersType = [\n    buildUser({\n      id: 1,\n      username: \"test1\",\n      name: \"Test User 1\",\n      email: \"test1@example.com\",\n      priority: 2,\n      bookings: [\n        {\n          createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n        },\n        {\n          createdAt: new Date(\"2022-01-25T06:30:00.000Z\"),\n        },\n      ],\n    }),\n    buildUser({\n      id: 2,\n      username: \"test2\",\n      name: \"Test User 2\",\n      email: \"test2@example.com\",\n      bookings: [\n        {\n          createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n        },\n      ],\n    }),\n  ];\n\n  CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue({ success: true, data: [] });\n  prismaMock.outOfOfficeEntry.findMany.mockResolvedValue([]);\n\n  prismaMock.user.findMany.mockResolvedValue(users);\n  prismaMock.host.findMany.mockResolvedValue([]);\n  prismaMock.booking.findMany.mockResolvedValue([]);\n\n  // both users have medium priority (one user has no priority set, default to medium) so pick least recently booked\n  await expect(\n    luckyUserService.getLuckyUser({\n      availableUsers: users,\n      eventType: {\n        id: 1,\n        isRRWeightsEnabled: false,\n        team: {\n          rrResetInterval: RRResetInterval.MONTH,\n          rrTimestampBasis: RRTimestampBasis.CREATED_AT,\n        },\n        includeNoShowInRRCalculation: false,\n      },\n      allRRHosts: [],\n      routingFormResponse: null,\n    })\n  ).resolves.toStrictEqual(users[1]);\n\n  const userLowest = buildUser({\n    id: 1,\n    username: \"test1\",\n    name: \"Test User 1\",\n    email: \"test1@example.com\",\n    priority: 0,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T03:30:00.000Z\"),\n      },\n    ],\n  });\n  const userMedium = buildUser({\n    id: 2,\n    username: \"test2\",\n    name: \"Test User 2\",\n    email: \"test2@example.com\",\n    priority: 2,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n      },\n    ],\n  });\n\n  const userHighest = buildUser({\n    id: 2,\n    username: \"test2\",\n    name: \"Test User 2\",\n    email: \"test2@example.com\",\n    priority: 4,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n      },\n    ],\n  });\n\n  const usersWithPriorities: GetLuckyUserAvailableUsersType = [userLowest, userMedium, userHighest];\n  prismaMock.user.findMany.mockResolvedValue(usersWithPriorities);\n  prismaMock.booking.findMany.mockResolvedValue([]);\n  prismaMock.host.findMany.mockResolvedValue([]);\n  // pick the user with the highest priority\n  await expect(\n    luckyUserService.getLuckyUser({\n      availableUsers: usersWithPriorities,\n      eventType: {\n        id: 1,\n        isRRWeightsEnabled: false,\n        team: { rrResetInterval: RRResetInterval.MONTH, rrTimestampBasis: RRTimestampBasis.CREATED_AT },\n        includeNoShowInRRCalculation: false,\n      },\n      allRRHosts: [],\n      routingFormResponse: null,\n    })\n  ).resolves.toStrictEqual(usersWithPriorities[2]);\n\n  const userLow = buildUser({\n    id: 1,\n    username: \"test1\",\n    name: \"Test User 1\",\n    email: \"test1@example.com\",\n    priority: 0,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T02:30:00.000Z\"),\n      },\n    ],\n  });\n  const userHighLeastRecentBooking = buildUser({\n    id: 2,\n    username: \"test2\",\n    name: \"Test User 2\",\n    email: \"tes2t@example.com\",\n    priority: 3,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T03:30:00.000Z\"),\n      },\n    ],\n  });\n\n  const userHighRecentBooking = buildUser({\n    id: 3,\n    username: \"test3\",\n    name: \"Test User 3\",\n    email: \"test3@example.com\",\n    priority: 3,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n      },\n    ],\n  });\n\n  const usersWithSamePriorities: GetLuckyUserAvailableUsersType = [\n    userLow,\n    userHighLeastRecentBooking,\n    userHighRecentBooking,\n  ];\n  prismaMock.user.findMany.mockResolvedValue(usersWithSamePriorities);\n  prismaMock.booking.findMany.mockResolvedValue([]);\n  prismaMock.host.findMany.mockResolvedValue([]);\n\n  // pick the least recently booked user of the two with the highest priority\n  await expect(\n    luckyUserService.getLuckyUser({\n      availableUsers: usersWithSamePriorities,\n      eventType: {\n        id: 1,\n        isRRWeightsEnabled: false,\n        team: { rrResetInterval: RRResetInterval.MONTH, rrTimestampBasis: RRTimestampBasis.CREATED_AT },\n        includeNoShowInRRCalculation: false,\n      },\n      allRRHosts: [],\n      routingFormResponse: null,\n    })\n  ).resolves.toStrictEqual(usersWithSamePriorities[1]);\n});\n\ndescribe(\"maximize availability and weights\", () => {\n  it(\"can find lucky user if hosts have same weights\", async () => {\n    const users: GetLuckyUserAvailableUsersType = [\n      buildUser({\n        id: 1,\n        username: \"test1\",\n        name: \"Test User 1\",\n        email: \"test1@example.com\",\n        priority: 3,\n        weight: 100,\n        bookings: [\n          {\n            createdAt: new Date(\"2022-01-25T06:30:00.000Z\"),\n          },\n          {\n            createdAt: new Date(\"2022-01-25T03:30:00.000Z\"),\n          },\n        ],\n      }),\n      buildUser({\n        id: 2,\n        username: \"test2\",\n        name: \"Test User 2\",\n        email: \"test2@example.com\",\n        priority: 3,\n        weight: 100,\n        bookings: [\n          {\n            createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n          },\n          {\n            createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n          },\n        ],\n      }),\n    ];\n\n    CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue({ success: true, data: [] });\n    prismaMock.outOfOfficeEntry.findMany.mockResolvedValue([]);\n    prismaMock.user.findMany.mockResolvedValue(users);\n    prismaMock.host.findMany.mockResolvedValue([]);\n    prismaMock.booking.findMany.mockResolvedValue([\n      buildBooking({\n        id: 1,\n        userId: 1,\n        createdAt: new Date(\"2022-01-25T06:30:00.000Z\"),\n      }),\n      buildBooking({\n        id: 2,\n        userId: 1,\n        createdAt: new Date(\"2022-01-25T03:30:00.000Z\"),\n      }),\n      buildBooking({\n        id: 3,\n        userId: 2,\n        createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n      }),\n      buildBooking({\n        id: 4,\n        userId: 2,\n        createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n      }),\n    ]);\n\n    const allRRHosts = [\n      {\n        user: {\n          id: users[0].id,\n          email: users[0].email,\n          credentials: [],\n          userLevelSelectedCalendars: [],\n        },\n        weight: users[0].weight,\n        createdAt: new Date(0),\n      },\n      {\n        user: {\n          id: users[1].id,\n          email: users[1].email,\n          credentials: [],\n          userLevelSelectedCalendars: [],\n        },\n        weight: users[1].weight,\n        createdAt: new Date(0),\n      },\n    ];\n\n    await expect(\n      luckyUserService.getLuckyUser({\n        availableUsers: users,\n        eventType: {\n          id: 1,\n          isRRWeightsEnabled: true,\n          team: { rrResetInterval: RRResetInterval.MONTH, rrTimestampBasis: RRTimestampBasis.CREATED_AT },\n          includeNoShowInRRCalculation: false,\n        },\n        allRRHosts,\n        routingFormResponse: null,\n      })\n    ).resolves.toStrictEqual(users[1]);\n\n    const queryArgs = prismaMock.booking.findMany.mock.calls[0][0];\n\n    // Today: 2021-06-20T11:59:59Z, monthly interval\n    expect(queryArgs.where?.createdAt).toEqual(\n      expect.objectContaining({\n        gte: new Date(\"2021-06-01T00:00:00Z\"),\n        lte: new Date(\"2021-06-20T11:59:59.000Z\"),\n      })\n    );\n  });\n\n  it(\"can find lucky user if hosts have different weights\", async () => {\n    const users: GetLuckyUserAvailableUsersType = [\n      buildUser({\n        id: 1,\n        username: \"test1\",\n        name: \"Test User 1\",\n        email: \"test1@example.com\",\n        priority: 3,\n        weight: 200,\n        bookings: [\n          {\n            createdAt: new Date(\"2022-01-25T08:30:00.000Z\"),\n          },\n          {\n            createdAt: new Date(\"2022-01-25T07:30:00.000Z\"),\n          },\n          {\n            createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n          },\n        ],\n      }),\n      buildUser({\n        id: 2,\n        username: \"test2\",\n        name: \"Test User 2\",\n        email: \"test2@example.com\",\n        priority: 3,\n        weight: 100,\n        bookings: [\n          {\n            createdAt: new Date(\"2022-01-25T06:30:00.000Z\"),\n          },\n          {\n            createdAt: new Date(\"2022-01-25T03:30:00.000Z\"),\n          },\n        ],\n      }),\n    ];\n\n    CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue({ success: true, data: [] });\n    prismaMock.outOfOfficeEntry.findMany.mockResolvedValue([]);\n    prismaMock.user.findMany.mockResolvedValue(users);\n    prismaMock.host.findMany.mockResolvedValue([]);\n    prismaMock.booking.findMany.mockResolvedValue([\n      buildBooking({\n        id: 1,\n        userId: 1,\n        createdAt: new Date(\"2022-01-25T08:30:00.000Z\"),\n      }),\n      buildBooking({\n        id: 2,\n        userId: 1,\n        createdAt: new Date(\"2022-01-25T07:30:00.000Z\"),\n      }),\n      buildBooking({\n        id: 3,\n        userId: 1,",
            "output_extracted": "import CalendarManagerMock from \"../../../../tests/libs/__mocks__/CalendarManager\";\nimport prismaMock from \"../../../../tests/libs/__mocks__/prismaMock\";\n\nimport { v4 as uuid } from \"uuid\";\nimport { expect, it, describe, vi, beforeAll } from \"vitest\";\n\nimport dayjs from \"@calcom/dayjs\";\nimport { getLuckyUserService } from \"@calcom/features/di/containers/LuckyUser\";\nimport { buildUser, buildBooking } from \"@calcom/lib/test/builder\";\nimport { AttributeType, RRResetInterval, RRTimestampBasis } from \"@calcom/prisma/enums\";\n\nimport { getIntervalStartDate, getIntervalEndDate } from \"./getLuckyUser\";\n\nconst luckyUserService = getLuckyUserService();\n\ntype NonEmptyArray<T> = [T, ...T[]];\ntype GetLuckyUserAvailableUsersType = NonEmptyArray<ReturnType<typeof buildUser>>;\n\nvi.mock(\"@calcom/app-store/routing-forms/components/react-awesome-query-builder/widgets\", () => ({\n  default: {},\n}));\n\nbeforeAll(() => {\n  vi.setSystemTime(new Date(\"2021-06-20T11:59:59Z\"));\n});\n\nit(\"can find lucky user with maximize availability\", async () => {\n  const users: GetLuckyUserAvailableUsersType = [\n    buildUser({\n      id: 1,\n      username: \"test1\",\n      name: \"Test User 1\",\n      email: \"test1@example.com\",\n      bookings: [\n        {\n          createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n        },\n        {\n          createdAt: new Date(\"2022-01-25T06:30:00.000Z\"),\n        },\n      ],\n    }),\n    buildUser({\n      id: 2,\n      username: \"test2\",\n      name: \"Test User 2\",\n      email: \"test2@example.com\",\n      bookings: [\n        {\n          createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n        },\n      ],\n    }),\n  ];\n\n  CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue({ success: true, data: [] });\n  prismaMock.outOfOfficeEntry.findMany.mockResolvedValue([]);\n\n  prismaMock.user.findMany.mockResolvedValue(users);\n  prismaMock.host.findMany.mockResolvedValue([]);\n  prismaMock.booking.findMany.mockResolvedValue([]);\n\n  await expect(\n    luckyUserService.getLuckyUser({\n      availableUsers: users,\n      eventType: {\n        id: 1,\n        isRRWeightsEnabled: false,\n        team: { rrResetInterval: RRResetInterval.MONTH, rrTimestampBasis: RRTimestampBasis.CREATED_AT },\n        includeNoShowInRRCalculation: false,\n      },\n      allRRHosts: [],\n      routingFormResponse: null,\n    })\n  ).resolves.toStrictEqual(users[1]);\n});\n\nit(\"can find lucky user with maximize availability and priority ranking\", async () => {\n  const users: GetLuckyUserAvailableUsersType = [\n    buildUser({\n      id: 1,\n      username: \"test1\",\n      name: \"Test User 1\",\n      email: \"test1@example.com\",\n      priority: 2,\n      bookings: [\n        {\n          createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n        },\n        {\n          createdAt: new Date(\"2022-01-25T06:30:00.000Z\"),\n        },\n      ],\n    }),\n    buildUser({\n      id: 2,\n      username: \"test2\",\n      name: \"Test User 2\",\n      email: \"test2@example.com\",\n      bookings: [\n        {\n          createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n        },\n      ],\n    }),\n  ];\n\n  CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue({ success: true, data: [] });\n  prismaMock.outOfOfficeEntry.findMany.mockResolvedValue([]);\n\n  prismaMock.user.findMany.mockResolvedValue(users);\n  prismaMock.host.findMany.mockResolvedValue([]);\n  prismaMock.booking.findMany.mockResolvedValue([]);\n\n  // both users have medium priority (one user has no priority set, default to medium) so pick least recently booked\n  await expect(\n    luckyUserService.getLuckyUser({\n      availableUsers: users,\n      eventType: {\n        id: 1,\n        isRRWeightsEnabled: false,\n        team: {\n          rrResetInterval: RRResetInterval.MONTH,\n          rrTimestampBasis: RRTimestampBasis.CREATED_AT,\n        },\n        includeNoShowInRRCalculation: false,\n      },\n      allRRHosts: [],\n      routingFormResponse: null,\n    })\n  ).resolves.toStrictEqual(users[1]);\n\n  const userLowest = buildUser({\n    id: 1,\n    username: \"test1\",\n    name: \"Test User 1\",\n    email: \"test1@example.com\",\n    priority: 0,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T03:30:00.000Z\"),\n      },\n    ],\n  });\n  const userMedium = buildUser({\n    id: 2,\n    username: \"test2\",\n    name: \"Test User 2\",\n    email: \"test2@example.com\",\n    priority: 2,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n      },\n    ],\n  });\n\n  const userHighest = buildUser({\n    id: 2,\n    username: \"test2\",\n    name: \"Test User 2\",\n    email: \"test2@example.com\",\n    priority: 4,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n      },\n    ],\n  });\n\n  const usersWithPriorities: GetLuckyUserAvailableUsersType = [userLowest, userMedium, userHighest];\n  prismaMock.user.findMany.mockResolvedValue(usersWithPriorities);\n  prismaMock.booking.findMany.mockResolvedValue([]);\n  prismaMock.host.findMany.mockResolvedValue([]);\n  // pick the user with the highest priority\n  await expect(\n    luckyUserService.getLuckyUser({\n      availableUsers: usersWithPriorities,\n      eventType: {\n        id: 1,\n        isRRWeightsEnabled: false,\n        team: { rrResetInterval: RRResetInterval.MONTH, rrTimestampBasis: RRTimestampBasis.CREATED_AT },\n        includeNoShowInRRCalculation: false,\n      },\n      allRRHosts: [],\n      routingFormResponse: null,\n    })\n  ).resolves.toStrictEqual(usersWithPriorities[2]);\n\n  const userLow = buildUser({\n    id: 1,\n    username: \"test1\",\n    name: \"Test User 1\",\n    email: \"test1@example.com\",\n    priority: 0,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T02:30:00.000Z\"),\n      },\n    ],\n  });\n  const userHighLeastRecentBooking = buildUser({\n    id: 2,\n    username: \"test2\",\n    name: \"Test User 2\",\n    email: \"tes2t@example.com\",\n    priority: 3,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T03:30:00.000Z\"),\n      },\n    ],\n  });\n\n  const userHighRecentBooking = buildUser({\n    id: 3,\n    username: \"test3\",\n    name: \"Test User 3\",\n    email: \"test3@example.com\",\n    priority: 3,\n    bookings: [\n      {\n        createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n      },\n    ],\n  });\n\n  const usersWithSamePriorities: GetLuckyUserAvailableUsersType = [\n    userLow,\n    userHighLeastRecentBooking,\n    userHighRecentBooking,\n  ];\n  prismaMock.user.findMany.mockResolvedValue(usersWithSamePriorities);\n  prismaMock.booking.findMany.mockResolvedValue([]);\n  prismaMock.host.findMany.mockResolvedValue([]);\n\n  // pick the least recently booked user of the two with the highest priority\n  await expect(\n    luckyUserService.getLuckyUser({\n      availableUsers: usersWithSamePriorities,\n      eventType: {\n        id: 1,\n        isRRWeightsEnabled: false,\n        team: { rrResetInterval: RRResetInterval.MONTH, rrTimestampBasis: RRTimestampBasis.CREATED_AT },\n        includeNoShowInRRCalculation: false,\n      },\n      allRRHosts: [],\n      routingFormResponse: null,\n    })\n  ).resolves.toStrictEqual(usersWithSamePriorities[1]);\n});\n\ndescribe(\"maximize availability and weights\", () => {\n  it(\"can find lucky user if hosts have same weights\", async () => {\n    const users: GetLuckyUserAvailableUsersType = [\n      buildUser({\n        id: 1,\n        username: \"test1\",\n        name: \"Test User 1\",\n        email: \"test1@example.com\",\n        priority: 3,\n        weight: 100,\n        bookings: [\n          {\n            createdAt: new Date(\"2022-01-25T06:30:00.000Z\"),\n          },\n          {\n            createdAt: new Date(\"2022-01-25T03:30:00.000Z\"),\n          },\n        ],\n      }),\n      buildUser({\n        id: 2,\n        username: \"test2\",\n        name: \"Test User 2\",\n        email: \"test2@example.com\",\n        priority: 3,\n        weight: 100,\n        bookings: [\n          {\n            createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n          },\n          {\n            createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n          },\n        ],\n      }),\n    ];\n\n    CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue({ success: true, data: [] });\n    prismaMock.outOfOfficeEntry.findMany.mockResolvedValue([]);\n    prismaMock.user.findMany.mockResolvedValue(users);\n    prismaMock.host.findMany.mockResolvedValue([]);\n    prismaMock.booking.findMany.mockResolvedValue([\n      buildBooking({\n        id: 1,\n        userId: 1,\n        createdAt: new Date(\"2022-01-25T06:30:00.000Z\"),\n      }),\n      buildBooking({\n        id: 2,\n        userId: 1,\n        createdAt: new Date(\"2022-01-25T03:30:00.000Z\"),\n      }),\n      buildBooking({\n        id: 3,\n        userId: 2,\n        createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n      }),\n      buildBooking({\n        id: 4,\n        userId: 2,\n        createdAt: new Date(\"2022-01-25T04:30:00.000Z\"),\n      }),\n    ]);\n\n    const allRRHosts = [\n      {\n        user: {\n          id: users[0].id,\n          email: users[0].email,\n          credentials: [],\n          userLevelSelectedCalendars: [],\n        },\n        weight: users[0].weight,\n        createdAt: new Date(0),\n      },\n      {\n        user: {\n          id: users[1].id,\n          email: users[1].email,\n          credentials: [],\n          userLevelSelectedCalendars: [],\n        },\n        weight: users[1].weight,\n        createdAt: new Date(0),\n      },\n    ];\n\n    await expect(\n      luckyUserService.getLuckyUser({\n        availableUsers: users,\n        eventType: {\n          id: 1,\n          isRRWeightsEnabled: true,\n          team: { rrResetInterval: RRResetInterval.MONTH, rrTimestampBasis: RRTimestampBasis.CREATED_AT },\n          includeNoShowInRRCalculation: false,\n        },\n        allRRHosts,\n        routingFormResponse: null,\n      })\n    ).resolves.toStrictEqual(users[1]);\n\n    const queryArgs = prismaMock.booking.findMany.mock.calls[0][0];\n\n    // Today: 2021-06-20T11:59:59Z, monthly interval\n    expect(queryArgs.where?.createdAt).toEqual(\n      expect.objectContaining({\n        gte: new Date(\"2021-06-01T00:00:00Z\"),\n        lte: new Date(\"2021-06-20T11:59:59.000Z\"),\n      })\n    );\n  });\n\n  it(\"can find lucky user if hosts have different weights\", async () => {\n    const users: GetLuckyUserAvailableUsersType = [\n      buildUser({\n        id: 1,\n        username: \"test1\",\n        name: \"Test User 1\",\n        email: \"test1@example.com\",\n        priority: 3,\n        weight: 200,\n        bookings: [\n          {\n            createdAt: new Date(\"2022-01-25T08:30:00.000Z\"),\n          },\n          {\n            createdAt: new Date(\"2022-01-25T07:30:00.000Z\"),\n          },\n          {\n            createdAt: new Date(\"2022-01-25T05:30:00.000Z\"),\n          },\n        ],\n      }),\n      buildUser({\n        id: 2,\n        username: \"test2\",\n        name: \"Test User 2\",\n        email: \"test2@example.com\",\n        priority: 3,\n        weight: 100,\n        bookings: [\n          {\n            createdAt: new Date(\"2022-01-25T06:30:00.000Z\"),\n          },\n          {\n            createdAt: new Date(\"2022-01-25T03:30:00.000Z\"),\n          },\n        ],\n      }),\n    ];\n\n    CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue({ success: true, data: [] });\n    prismaMock.outOfOfficeEntry.findMany.mockResolvedValue([]);\n    prismaMock.user.findMany.mockResolvedValue(users);\n    prismaMock.host.findMany.mockResolvedValue([]);\n    prismaMock.booking.findMany.mockResolvedValue([\n      buildBooking({\n        id: 1,\n        userId: 1,\n        createdAt: new Date(\"2022-01-25T08:30:00.000Z\"),\n      }),\n      buildBooking({\n        id: 2,\n        userId: 1,\n        createdAt: new Date(\"2022-01-25T07:30:00.000Z\"),\n      }),\n      buildBooking({\n        id: 3,\n        userId: 1,",
            "cost": 0.187355
        },
        "calcom__cal.com.main/packages/features/bookings/lib/getLuckyUser.ts": {
            "output": "import { acrossQueryValueCompatiblity } from \"@calcom/app-store/_utils/raqb/raqbUtils\";\nimport type { FormResponse, Fields } from \"@calcom/app-store/routing-forms/types/types\";\nimport { zodRoutes } from \"@calcom/app-store/routing-forms/zod\";\nimport dayjs from \"@calcom/dayjs\";\nimport type { BookingRepository } from \"@calcom/features/bookings/repositories/BookingRepository\";\nimport { getBusyCalendarTimes } from \"@calcom/features/calendars/lib/CalendarManager\";\nimport { mergeOverlappingRanges } from \"@calcom/features/schedules/lib/date-ranges\";\nimport type { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport logger from \"@calcom/lib/logger\";\nimport { raqbQueryValueSchema } from \"@calcom/lib/raqb/zod\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport type { PrismaAttributeRepository } from \"@calcom/lib/server/repository/PrismaAttributeRepository\";\nimport type { HostRepository } from \"@calcom/lib/server/repository/host\";\nimport type { PrismaOOORepository } from \"@calcom/lib/server/repository/ooo\";\nimport type { Prisma } from \"@calcom/prisma/client\";\nimport type { User, Booking, SelectedCalendar } from \"@calcom/prisma/client\";\nimport type { AttributeType } from \"@calcom/prisma/enums\";\nimport { RRTimestampBasis, RRResetInterval } from \"@calcom/prisma/enums\";\nimport type { EventBusyDate } from \"@calcom/types/Calendar\";\nimport type { CredentialForCalendarService } from \"@calcom/types/Credential\";\n\nconst log = logger.getSubLogger({ prefix: [\"getLuckyUser\"] });\nconst { getAttributesQueryValue } = acrossQueryValueCompatiblity;\n\ntype PartialBooking = Pick<Booking, \"id\" | \"createdAt\" | \"userId\" | \"status\"> & {\n  attendees: { email: string | null }[];\n};\n\ntype PartialUser = Pick<User, \"id\" | \"email\">;\nexport type RoutingFormResponse = {\n  response: Prisma.JsonValue;\n  chosenRouteId: string | null;\n  form: {\n    fields: Prisma.JsonValue;\n    routes: Prisma.JsonValue;\n  };\n};\n\ntype AttributeWithWeights = {\n  name: string;\n  slug: string;\n  type: AttributeType;\n  id: string;\n  options: {\n    id: string;\n    value: string;\n    slug: string;\n    assignedUsers: {\n      weight: number | null;\n      member: {\n        userId: number;\n      };\n    }[];\n  }[];\n};\n\ntype VirtualQueuesDataType = {\n  chosenRouteId: string;\n  fieldOptionData: {\n    fieldId: string;\n    selectedOptionIds: string | number | string[];\n  };\n};\n\ninterface GetLuckyUserParams<T extends PartialUser> {\n  availableUsers: [T, ...T[]]; // ensure contains at least 1\n  eventType: {\n    id: number;\n    isRRWeightsEnabled: boolean;\n    team: {\n      parentId?: number | null;\n      rrResetInterval: RRResetInterval | null;\n      rrTimestampBasis: RRTimestampBasis;\n    } | null;\n    includeNoShowInRRCalculation: boolean;\n  };\n  // all routedTeamMemberIds or all hosts of event types\n  allRRHosts: {\n    user: {\n      id: number;\n      email: string;\n      credentials: CredentialForCalendarService[];\n      userLevelSelectedCalendars: SelectedCalendar[];\n    };\n    createdAt: Date;\n    weight?: number | null;\n  }[];\n  routingFormResponse: RoutingFormResponse | null;\n  meetingStartTime?: Date;\n}\n\n// === Utility Functions kept outside of the class ===\nconst startOfMonth = (date: Date = new Date()) =>\n  new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1));\n\nconst startOfDay = (date: Date = new Date()) =>\n  new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n\nconst endOfDay = (date: Date) =>\n  new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 23, 59, 59, 999));\n\nconst endOfMonth = (date: Date) =>\n  new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + 1, 0, 23, 59, 59, 999));\n\nexport const getIntervalEndDate = ({\n  interval,\n  rrTimestampBasis,\n  meetingStartTime,\n}: {\n  interval: RRResetInterval;\n  rrTimestampBasis: RRTimestampBasis;\n  meetingStartTime?: Date;\n}) => {\n  if (rrTimestampBasis === RRTimestampBasis.START_TIME) {\n    if (!meetingStartTime) {\n      throw new Error(\"Meeting start time is required\");\n    }\n    if (interval === RRResetInterval.DAY) {\n      return endOfDay(meetingStartTime);\n    }\n    return endOfMonth(meetingStartTime);\n  }\n\n  return new Date();\n};\n\nexport const getIntervalStartDate = ({\n  interval,\n  rrTimestampBasis,\n  meetingStartTime,\n}: {\n  interval: RRResetInterval;\n  rrTimestampBasis: RRTimestampBasis;\n  meetingStartTime?: Date;\n}) => {\n  if (rrTimestampBasis === RRTimestampBasis.START_TIME) {\n    if (!meetingStartTime) {\n      throw new Error(\"Meeting start time is required\");\n    }\n    if (interval === RRResetInterval.DAY) {\n      return startOfDay(meetingStartTime);\n    }\n    return startOfMonth(meetingStartTime);\n  }\n\n  if (interval === RRResetInterval.DAY) {\n    return startOfDay();\n  }\n  return startOfMonth();\n};\n\nconst isNonEmptyArray = <T>(arr: T[]): arr is [T, ...T[]] => arr.length > 0;\n\nfunction isFullDayEvent(date1: Date, date2: Date) {\n  const MILLISECONDS_IN_A_DAY = 24 * 60 * 60 * 1000;\n  const difference = Math.abs(date1.getTime() - date2.getTime());\n\n  if (difference % MILLISECONDS_IN_A_DAY === 0) return true;\n}\n\ntype OOODataType = { userId: number; oooEntries: { start: Date; end: Date }[] }[];\n\ntype FetchedData = {\n  bookingsOfNotAvailableUsersOfInterval: PartialBooking[];\n  bookingsOfAvailableUsersOfInterval: PartialBooking[];\n  allRRHostsBookingsOfInterval: PartialBooking[];\n  allRRHostsCreatedInInterval: { userId: number; createdAt: Date }[];\n  organizersWithLastCreated: { id: number; bookings: { createdAt: Date }[] }[];\n  attributeWeights?:\n    | {\n        userId: number;\n        weight: number;\n      }[]\n    | null;\n  virtualQueuesData?: VirtualQueuesDataType | null;\n  oooData: OOODataType;\n};\n\ntype AvailableUserBase = PartialUser & {\n  priority: number | null;\n  weight: number | null;\n};\n\nexport interface ILuckyUserService {\n  bookingRepository: BookingRepository;\n  hostRepository: HostRepository;\n  oooRepository: PrismaOOORepository;\n  userRepository: UserRepository;\n  attributeRepository: PrismaAttributeRepository;\n}\n\nexport class LuckyUserService implements ILuckyUserService {\n  public bookingRepository: BookingRepository;\n  public hostRepository: HostRepository;\n  public oooRepository: PrismaOOORepository;\n  public userRepository: UserRepository;\n  public attributeRepository: PrismaAttributeRepository;\n\n  constructor(deps: ILuckyUserService) {\n    this.bookingRepository = deps.bookingRepository;\n    this.hostRepository = deps.hostRepository;\n    this.oooRepository = deps.oooRepository;\n    this.userRepository = deps.userRepository;\n    this.attributeRepository = deps.attributeRepository;\n  }\n\n  private leastRecentlyBookedUser<T extends PartialUser>({\n    availableUsers,\n    bookingsOfAvailableUsers,\n    organizersWithLastCreated,\n  }: GetLuckyUserParams<T> & {\n    bookingsOfAvailableUsers: PartialBooking[];\n    organizersWithLastCreated: { id: number; bookings: { createdAt: Date }[] }[];\n  }) {\n    const organizerIdAndAtCreatedPair = organizersWithLastCreated.reduce(\n      (keyValuePair: { [userId: number]: Date }, user) => {\n        keyValuePair[user.id] = user.bookings[0]?.createdAt || new Date(0);\n        return keyValuePair;\n      },\n      {}\n    );\n\n    const attendeeUserIdAndAtCreatedPair = bookingsOfAvailableUsers.reduce(\n      (aggregate: { [userId: number]: Date }, booking) => {\n        availableUsers.forEach((user) => {\n          if (aggregate[user.id]) return;\n          if (!booking.attendees.map((attendee) => attendee.email).includes(user.email)) return;\n          if (organizerIdAndAtCreatedPair[user.id] > booking.createdAt) return;\n          aggregate[user.id] = booking.createdAt;\n        });\n        return aggregate;\n      },\n      {}\n    );\n\n    const userIdAndAtCreatedPair = {\n      ...organizerIdAndAtCreatedPair,\n      ...attendeeUserIdAndAtCreatedPair,\n    };\n\n    log.info(\n      \"userIdAndAtCreatedPair\",\n      safeStringify({\n        organizerIdAndAtCreatedPair,\n        attendeeUserIdAndAtCreatedPair,\n        userIdAndAtCreatedPair,\n      })\n    );\n\n    if (!userIdAndAtCreatedPair) {\n      throw new Error(\"Unable to find users by availableUser ids.\");\n    }\n\n    const leastRecentlyBookedUser = availableUsers.sort((a, b) => {\n      if (userIdAndAtCreatedPair[a.id] > userIdAndAtCreatedPair[b.id]) return 1;\n      else if (userIdAndAtCreatedPair[a.id] < userIdAndAtCreatedPair[b.id]) return -1;\n      else return 0;\n    })[0];\n\n    return leastRecentlyBookedUser;\n  }\n\n  private getHostsWithCalibration({\n    hosts,\n    allRRHostsBookingsOfInterval,\n    allRRHostsCreatedInInterval,\n    oooData,\n  }: {\n    hosts: { userId: number; email: string; createdAt: Date }[];\n    allRRHostsBookingsOfInterval: PartialBooking[];\n    allRRHostsCreatedInInterval: { userId: number; createdAt: Date }[];\n    oooData: OOODataType;\n  }) {\n    function calculateNewHostCalibration(newHost: { userId: number; createdAt: Date }) {\n      const existingBookingsBeforeAdded = existingBookings.filter(\n        (booking) => booking.userId !== newHost.userId && booking.createdAt < newHost.createdAt\n      );\n      const hostsAddedBefore = hosts.filter(\n        (host) => host.userId !== newHost.userId && host.createdAt < newHost.createdAt\n      );\n\n      const calibration =\n        existingBookingsBeforeAdded.length && hostsAddedBefore.length\n          ? existingBookingsBeforeAdded.length / hostsAddedBefore.length\n          : 0;\n      log.debug(\n        \"calculateNewHostCalibration\",\n        safeStringify({\n          newHost,\n          existingBookingsBeforeAdded: existingBookingsBeforeAdded.length,\n          hostsAddedBefore: hostsAddedBefore.length,\n          calibration,\n        })\n      );\n      return calibration;\n    }\n\n    const existingBookings = allRRHostsBookingsOfInterval;\n\n    const oooCalibration = new Map<number, number>();\n\n    oooData.forEach(({ userId, oooEntries }) => {\n      let calibration = 0;\n\n      oooEntries.forEach((oooEntry) => {\n        const bookingsInTimeframe = existingBookings.filter(\n          (booking) =>\n            booking.createdAt >= oooEntry.start &&\n            booking.createdAt <= oooEntry.end &&\n            booking.userId !== userId\n        );\n        calibration += bookingsInTimeframe.length / (hosts.length - 1);\n      });\n\n      oooCalibration.set(userId, calibration);\n    });\n\n    let newHostsWithCalibration: Map<\n      number,\n      {\n        calibration: number;\n        userId: number;\n        createdAt: Date;\n      }\n    > = new Map();\n\n    if (allRRHostsCreatedInInterval.length && existingBookings.length) {\n      newHostsWithCalibration = new Map(\n        allRRHostsCreatedInInterval.map((newHost) => [\n          newHost.userId,\n          { ...newHost, calibration: calculateNewHostCalibration(newHost) },\n        ])\n      );\n    }\n\n    return hosts.map((host) => ({\n      ...host,\n      calibration:\n        (newHostsWithCalibration.get(host.userId)?.calibration ?? 0) + (oooCalibration.get(host.userId) ?? 0),\n    }));\n  }\n\n  private getUsersWithHighestPriority<T extends PartialUser & { priority?: number | null }>({\n    availableUsers,\n  }: {\n    availableUsers: T[];\n  }) {\n    const highestPriority = Math.max(...availableUsers.map((user) => user.priority ?? 2));\n    const usersWithHighestPriority = availableUsers.filter(\n      (user) => user.priority === highestPriority || (user.priority == null && highestPriority === 2)\n    );\n    if (!isNonEmptyArray(usersWithHighestPriority)) {\n      throw new Error(\"Internal Error: Highest Priority filter should never return length=0.\");\n    }\n\n    log.info(\n      \"getUsersWithHighestPriority\",\n      safeStringify({\n        highestPriorityUsers: usersWithHighestPriority.map((user) => user.id),\n      })\n    );\n    return usersWithHighestPriority;\n  }\n\n  private filterUsersBasedOnWeights<\n    T extends PartialUser & {\n      weight?: number | null;\n    }\n  >({\n    availableUsers,\n    bookingsOfAvailableUsersOfInterval,\n    bookingsOfNotAvailableUsersOfInterval,\n    allRRHosts,\n    allRRHostsBookingsOfInterval,\n    allRRHostsCreatedInInterval,\n    attributeWeights,\n    oooData,\n  }: GetLuckyUserParams<T> & FetchedData) {\n    const allBookings = bookingsOfAvailableUsersOfInterval.concat(bookingsOfNotAvailableUsersOfInterval);\n\n    const allHostsWithCalibration = this.getHostsWithCalibration({\n      hosts: allRRHosts.map((host) => {\n        return { email: host.user.email, userId: host.user.id,",
            "output_extracted": "import { acrossQueryValueCompatiblity } from \"@calcom/app-store/_utils/raqb/raqbUtils\";\nimport type { FormResponse, Fields } from \"@calcom/app-store/routing-forms/types/types\";\nimport { zodRoutes } from \"@calcom/app-store/routing-forms/zod\";\nimport dayjs from \"@calcom/dayjs\";\nimport type { BookingRepository } from \"@calcom/features/bookings/repositories/BookingRepository\";\nimport { getBusyCalendarTimes } from \"@calcom/features/calendars/lib/CalendarManager\";\nimport { mergeOverlappingRanges } from \"@calcom/features/schedules/lib/date-ranges\";\nimport type { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\nimport logger from \"@calcom/lib/logger\";\nimport { raqbQueryValueSchema } from \"@calcom/lib/raqb/zod\";\nimport { safeStringify } from \"@calcom/lib/safeStringify\";\nimport type { PrismaAttributeRepository } from \"@calcom/lib/server/repository/PrismaAttributeRepository\";\nimport type { HostRepository } from \"@calcom/lib/server/repository/host\";\nimport type { PrismaOOORepository } from \"@calcom/lib/server/repository/ooo\";\nimport type { Prisma } from \"@calcom/prisma/client\";\nimport type { User, Booking, SelectedCalendar } from \"@calcom/prisma/client\";\nimport type { AttributeType } from \"@calcom/prisma/enums\";\nimport { RRTimestampBasis, RRResetInterval } from \"@calcom/prisma/enums\";\nimport type { EventBusyDate } from \"@calcom/types/Calendar\";\nimport type { CredentialForCalendarService } from \"@calcom/types/Credential\";\n\nconst log = logger.getSubLogger({ prefix: [\"getLuckyUser\"] });\nconst { getAttributesQueryValue } = acrossQueryValueCompatiblity;\n\ntype PartialBooking = Pick<Booking, \"id\" | \"createdAt\" | \"userId\" | \"status\"> & {\n  attendees: { email: string | null }[];\n};\n\ntype PartialUser = Pick<User, \"id\" | \"email\">;\nexport type RoutingFormResponse = {\n  response: Prisma.JsonValue;\n  chosenRouteId: string | null;\n  form: {\n    fields: Prisma.JsonValue;\n    routes: Prisma.JsonValue;\n  };\n};\n\ntype AttributeWithWeights = {\n  name: string;\n  slug: string;\n  type: AttributeType;\n  id: string;\n  options: {\n    id: string;\n    value: string;\n    slug: string;\n    assignedUsers: {\n      weight: number | null;\n      member: {\n        userId: number;\n      };\n    }[];\n  }[];\n};\n\ntype VirtualQueuesDataType = {\n  chosenRouteId: string;\n  fieldOptionData: {\n    fieldId: string;\n    selectedOptionIds: string | number | string[];\n  };\n};\n\ninterface GetLuckyUserParams<T extends PartialUser> {\n  availableUsers: [T, ...T[]]; // ensure contains at least 1\n  eventType: {\n    id: number;\n    isRRWeightsEnabled: boolean;\n    team: {\n      parentId?: number | null;\n      rrResetInterval: RRResetInterval | null;\n      rrTimestampBasis: RRTimestampBasis;\n    } | null;\n    includeNoShowInRRCalculation: boolean;\n  };\n  // all routedTeamMemberIds or all hosts of event types\n  allRRHosts: {\n    user: {\n      id: number;\n      email: string;\n      credentials: CredentialForCalendarService[];\n      userLevelSelectedCalendars: SelectedCalendar[];\n    };\n    createdAt: Date;\n    weight?: number | null;\n  }[];\n  routingFormResponse: RoutingFormResponse | null;\n  meetingStartTime?: Date;\n}\n\n// === Utility Functions kept outside of the class ===\nconst startOfMonth = (date: Date = new Date()) =>\n  new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1));\n\nconst startOfDay = (date: Date = new Date()) =>\n  new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n\nconst endOfDay = (date: Date) =>\n  new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 23, 59, 59, 999));\n\nconst endOfMonth = (date: Date) =>\n  new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + 1, 0, 23, 59, 59, 999));\n\nexport const getIntervalEndDate = ({\n  interval,\n  rrTimestampBasis,\n  meetingStartTime,\n}: {\n  interval: RRResetInterval;\n  rrTimestampBasis: RRTimestampBasis;\n  meetingStartTime?: Date;\n}) => {\n  if (rrTimestampBasis === RRTimestampBasis.START_TIME) {\n    if (!meetingStartTime) {\n      throw new Error(\"Meeting start time is required\");\n    }\n    if (interval === RRResetInterval.DAY) {\n      return endOfDay(meetingStartTime);\n    }\n    return endOfMonth(meetingStartTime);\n  }\n\n  return new Date();\n};\n\nexport const getIntervalStartDate = ({\n  interval,\n  rrTimestampBasis,\n  meetingStartTime,\n}: {\n  interval: RRResetInterval;\n  rrTimestampBasis: RRTimestampBasis;\n  meetingStartTime?: Date;\n}) => {\n  if (rrTimestampBasis === RRTimestampBasis.START_TIME) {\n    if (!meetingStartTime) {\n      throw new Error(\"Meeting start time is required\");\n    }\n    if (interval === RRResetInterval.DAY) {\n      return startOfDay(meetingStartTime);\n    }\n    return startOfMonth(meetingStartTime);\n  }\n\n  if (interval === RRResetInterval.DAY) {\n    return startOfDay();\n  }\n  return startOfMonth();\n};\n\nconst isNonEmptyArray = <T>(arr: T[]): arr is [T, ...T[]] => arr.length > 0;\n\nfunction isFullDayEvent(date1: Date, date2: Date) {\n  const MILLISECONDS_IN_A_DAY = 24 * 60 * 60 * 1000;\n  const difference = Math.abs(date1.getTime() - date2.getTime());\n\n  if (difference % MILLISECONDS_IN_A_DAY === 0) return true;\n}\n\ntype OOODataType = { userId: number; oooEntries: { start: Date; end: Date }[] }[];\n\ntype FetchedData = {\n  bookingsOfNotAvailableUsersOfInterval: PartialBooking[];\n  bookingsOfAvailableUsersOfInterval: PartialBooking[];\n  allRRHostsBookingsOfInterval: PartialBooking[];\n  allRRHostsCreatedInInterval: { userId: number; createdAt: Date }[];\n  organizersWithLastCreated: { id: number; bookings: { createdAt: Date }[] }[];\n  attributeWeights?:\n    | {\n        userId: number;\n        weight: number;\n      }[]\n    | null;\n  virtualQueuesData?: VirtualQueuesDataType | null;\n  oooData: OOODataType;\n};\n\ntype AvailableUserBase = PartialUser & {\n  priority: number | null;\n  weight: number | null;\n};\n\nexport interface ILuckyUserService {\n  bookingRepository: BookingRepository;\n  hostRepository: HostRepository;\n  oooRepository: PrismaOOORepository;\n  userRepository: UserRepository;\n  attributeRepository: PrismaAttributeRepository;\n}\n\nexport class LuckyUserService implements ILuckyUserService {\n  public bookingRepository: BookingRepository;\n  public hostRepository: HostRepository;\n  public oooRepository: PrismaOOORepository;\n  public userRepository: UserRepository;\n  public attributeRepository: PrismaAttributeRepository;\n\n  constructor(deps: ILuckyUserService) {\n    this.bookingRepository = deps.bookingRepository;\n    this.hostRepository = deps.hostRepository;\n    this.oooRepository = deps.oooRepository;\n    this.userRepository = deps.userRepository;\n    this.attributeRepository = deps.attributeRepository;\n  }\n\n  private leastRecentlyBookedUser<T extends PartialUser>({\n    availableUsers,\n    bookingsOfAvailableUsers,\n    organizersWithLastCreated,\n  }: GetLuckyUserParams<T> & {\n    bookingsOfAvailableUsers: PartialBooking[];\n    organizersWithLastCreated: { id: number; bookings: { createdAt: Date }[] }[];\n  }) {\n    const organizerIdAndAtCreatedPair = organizersWithLastCreated.reduce(\n      (keyValuePair: { [userId: number]: Date }, user) => {\n        keyValuePair[user.id] = user.bookings[0]?.createdAt || new Date(0);\n        return keyValuePair;\n      },\n      {}\n    );\n\n    const attendeeUserIdAndAtCreatedPair = bookingsOfAvailableUsers.reduce(\n      (aggregate: { [userId: number]: Date }, booking) => {\n        availableUsers.forEach((user) => {\n          if (aggregate[user.id]) return;\n          if (!booking.attendees.map((attendee) => attendee.email).includes(user.email)) return;\n          if (organizerIdAndAtCreatedPair[user.id] > booking.createdAt) return;\n          aggregate[user.id] = booking.createdAt;\n        });\n        return aggregate;\n      },\n      {}\n    );\n\n    const userIdAndAtCreatedPair = {\n      ...organizerIdAndAtCreatedPair,\n      ...attendeeUserIdAndAtCreatedPair,\n    };\n\n    log.info(\n      \"userIdAndAtCreatedPair\",\n      safeStringify({\n        organizerIdAndAtCreatedPair,\n        attendeeUserIdAndAtCreatedPair,\n        userIdAndAtCreatedPair,\n      })\n    );\n\n    if (!userIdAndAtCreatedPair) {\n      throw new Error(\"Unable to find users by availableUser ids.\");\n    }\n\n    const leastRecentlyBookedUser = availableUsers.sort((a, b) => {\n      if (userIdAndAtCreatedPair[a.id] > userIdAndAtCreatedPair[b.id]) return 1;\n      else if (userIdAndAtCreatedPair[a.id] < userIdAndAtCreatedPair[b.id]) return -1;\n      else return 0;\n    })[0];\n\n    return leastRecentlyBookedUser;\n  }\n\n  private getHostsWithCalibration({\n    hosts,\n    allRRHostsBookingsOfInterval,\n    allRRHostsCreatedInInterval,\n    oooData,\n  }: {\n    hosts: { userId: number; email: string; createdAt: Date }[];\n    allRRHostsBookingsOfInterval: PartialBooking[];\n    allRRHostsCreatedInInterval: { userId: number; createdAt: Date }[];\n    oooData: OOODataType;\n  }) {\n    function calculateNewHostCalibration(newHost: { userId: number; createdAt: Date }) {\n      const existingBookingsBeforeAdded = existingBookings.filter(\n        (booking) => booking.userId !== newHost.userId && booking.createdAt < newHost.createdAt\n      );\n      const hostsAddedBefore = hosts.filter(\n        (host) => host.userId !== newHost.userId && host.createdAt < newHost.createdAt\n      );\n\n      const calibration =\n        existingBookingsBeforeAdded.length && hostsAddedBefore.length\n          ? existingBookingsBeforeAdded.length / hostsAddedBefore.length\n          : 0;\n      log.debug(\n        \"calculateNewHostCalibration\",\n        safeStringify({\n          newHost,\n          existingBookingsBeforeAdded: existingBookingsBeforeAdded.length,\n          hostsAddedBefore: hostsAddedBefore.length,\n          calibration,\n        })\n      );\n      return calibration;\n    }\n\n    const existingBookings = allRRHostsBookingsOfInterval;\n\n    const oooCalibration = new Map<number, number>();\n\n    oooData.forEach(({ userId, oooEntries }) => {\n      let calibration = 0;\n\n      oooEntries.forEach((oooEntry) => {\n        const bookingsInTimeframe = existingBookings.filter(\n          (booking) =>\n            booking.createdAt >= oooEntry.start &&\n            booking.createdAt <= oooEntry.end &&\n            booking.userId !== userId\n        );\n        calibration += bookingsInTimeframe.length / (hosts.length - 1);\n      });\n\n      oooCalibration.set(userId, calibration);\n    });\n\n    let newHostsWithCalibration: Map<\n      number,\n      {\n        calibration: number;\n        userId: number;\n        createdAt: Date;\n      }\n    > = new Map();\n\n    if (allRRHostsCreatedInInterval.length && existingBookings.length) {\n      newHostsWithCalibration = new Map(\n        allRRHostsCreatedInInterval.map((newHost) => [\n          newHost.userId,\n          { ...newHost, calibration: calculateNewHostCalibration(newHost) },\n        ])\n      );\n    }\n\n    return hosts.map((host) => ({\n      ...host,\n      calibration:\n        (newHostsWithCalibration.get(host.userId)?.calibration ?? 0) + (oooCalibration.get(host.userId) ?? 0),\n    }));\n  }\n\n  private getUsersWithHighestPriority<T extends PartialUser & { priority?: number | null }>({\n    availableUsers,\n  }: {\n    availableUsers: T[];\n  }) {\n    const highestPriority = Math.max(...availableUsers.map((user) => user.priority ?? 2));\n    const usersWithHighestPriority = availableUsers.filter(\n      (user) => user.priority === highestPriority || (user.priority == null && highestPriority === 2)\n    );\n    if (!isNonEmptyArray(usersWithHighestPriority)) {\n      throw new Error(\"Internal Error: Highest Priority filter should never return length=0.\");\n    }\n\n    log.info(\n      \"getUsersWithHighestPriority\",\n      safeStringify({\n        highestPriorityUsers: usersWithHighestPriority.map((user) => user.id),\n      })\n    );\n    return usersWithHighestPriority;\n  }\n\n  private filterUsersBasedOnWeights<\n    T extends PartialUser & {\n      weight?: number | null;\n    }\n  >({\n    availableUsers,\n    bookingsOfAvailableUsersOfInterval,\n    bookingsOfNotAvailableUsersOfInterval,\n    allRRHosts,\n    allRRHostsBookingsOfInterval,\n    allRRHostsCreatedInInterval,\n    attributeWeights,\n    oooData,\n  }: GetLuckyUserParams<T> & FetchedData) {\n    const allBookings = bookingsOfAvailableUsersOfInterval.concat(bookingsOfNotAvailableUsersOfInterval);\n\n    const allHostsWithCalibration = this.getHostsWithCalibration({\n      hosts: allRRHosts.map((host) => {\n        return { email: host.user.email, userId: host.user.id,",
            "cost": 0.16850500000000002
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "calcom__cal.com.main.25369",
        "repo": "calcom/cal.com",
        "base_commit": "f2b2b6e491cbb850a917a50c6a0cb3850ffd156a",
        "head_commit": "e5d70cdaf686614a5ed92ea99b759f01f3826e84",
        "title": "fix: prevent 500 errors in round-robin scheduling from OOO calibration for single host",
        "merged_at": "2025-11-25T07:13:04Z",
        "html_url": "https://github.com/calcom/cal.com/pull/25369",
        "test_files": [
            "packages/features/bookings/lib/getLuckyUser.test.ts"
        ],
        "code_files": [
            "packages/features/bookings/lib/getLuckyUser.ts"
        ],
        "total_changes": 74,
        "num_files": 2,
        "pull_number": 25369,
        "patch": "diff --git a/packages/features/bookings/lib/getLuckyUser.test.ts b/packages/features/bookings/lib/getLuckyUser.test.ts\nindex 08e553a83bdfcc..4974f6cd1facae 100644\n--- a/packages/features/bookings/lib/getLuckyUser.test.ts\n+++ b/packages/features/bookings/lib/getLuckyUser.test.ts\n@@ -827,6 +827,75 @@ describe(\"maximize availability and weights\", () => {\n     );\n   });\n \n+  it(\"skips OOO calibration when there is only one host\", async () => {\n+    const users: GetLuckyUserAvailableUsersType = [\n+      buildUser({\n+        id: 1,\n+        username: \"test1\",\n+        name: \"Test User 1\",\n+        email: \"test1@example.com\",\n+        bookings: [],\n+      }),\n+    ];\n+\n+    const allRRHosts = [\n+      {\n+        user: {\n+          id: users[0].id,\n+          email: users[0].email,\n+          credentials: [],\n+          userLevelSelectedCalendars: [],\n+        },\n+        weight: users[0].weight,\n+        createdAt: new Date(0),\n+      },\n+    ];\n+\n+    CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue({ success: true, data: [] });\n+\n+    // Mock OOO entry for the single host\n+    prismaMock.outOfOfficeEntry.findMany.mockResolvedValue([\n+      {\n+        start: dayjs().subtract(10, \"day\").toDate(),\n+        end: dayjs().subtract(5, \"day\").toDate(),\n+        userId: users[0].id,\n+      },\n+    ]);\n+\n+    prismaMock.user.findMany.mockResolvedValue(users);\n+    prismaMock.host.findMany.mockResolvedValue([\n+      {\n+        userId: allRRHosts[0].user.id,\n+        weight: allRRHosts[0].weight,\n+        createdAt: allRRHosts[0].createdAt,\n+      },\n+    ]);\n+\n+    // Mock some bookings during the OOO period (though there's only one host)\n+    prismaMock.booking.findMany.mockResolvedValue([\n+      buildBooking({\n+        id: 1,\n+        userId: 1,\n+        createdAt: dayjs().subtract(7, \"days\").toDate(),\n+      }),\n+    ]);\n+\n+    // Should return the only available user without throwing division by zero error\n+    await expect(\n+      luckyUserService.getLuckyUser({\n+        availableUsers: users,\n+        eventType: {\n+          id: 1,\n+          isRRWeightsEnabled: true,\n+          team: { rrResetInterval: RRResetInterval.MONTH, rrTimestampBasis: RRTimestampBasis.CREATED_AT },\n+          includeNoShowInRRCalculation: false,\n+        },\n+        allRRHosts,\n+        routingFormResponse: null,\n+      })\n+    ).resolves.toStrictEqual(users[0]);\n+  });\n+\n   it(\"applies calibration to newly added hosts so they are not penalized unfairly compared to their peers\", async () => {\n     const users: GetLuckyUserAvailableUsersType = [\n       buildUser({\ndiff --git a/packages/features/bookings/lib/getLuckyUser.ts b/packages/features/bookings/lib/getLuckyUser.ts\nindex 8d6c75d8bc5b52..e0afa668f4608d 100644\n--- a/packages/features/bookings/lib/getLuckyUser.ts\n+++ b/packages/features/bookings/lib/getLuckyUser.ts\n@@ -300,6 +300,11 @@ export class LuckyUserService implements ILuckyUserService {\n     const oooCalibration = new Map<number, number>();\n \n     oooData.forEach(({ userId, oooEntries }) => {\n+      // Skip OOO calibration if there's only one host (division by zero would occur)\n+      if (hosts.length <= 1) {\n+        return;\n+      }\n+\n       let calibration = 0;\n \n       oooEntries.forEach((oooEntry) => {\n",
        "pr_mirror": "calcom__cal.com.main"
    }
}