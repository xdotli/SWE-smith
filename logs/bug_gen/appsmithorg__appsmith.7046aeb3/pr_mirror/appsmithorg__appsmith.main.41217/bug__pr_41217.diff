diff --git a/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx b/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx
index b938f72..caf37fe 100644
--- a/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx
+++ b/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx
@@ -200,10 +200,7 @@ const HeaderCellComponent = (props: HeaderProps) => {
   const isColumnEditable =
     props.column.columnProperties.isCellEditable &&
     props.column.columnProperties.isEditable &&
-    isColumnTypeEditable(
-      props.column.columnProperties.columnType,
-      isInfiniteScrollEnabled,
-    );
+    isColumnTypeEditable(props.column.columnProperties.columnType);
 
   const toggleColumnFreeze = (value: StickyType) => {
     handleColumnFreeze &&
@@ -378,4 +375,4 @@ const HeaderCellComponent = (props: HeaderProps) => {
   );
 };
 
-export const HeaderCell = memo(HeaderCellComponent);
+export const HeaderCell = memo(HeaderCellComponent);
\ No newline at end of file
diff --git a/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts b/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts
index 160ab69..9b630e2 100644
--- a/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts
+++ b/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts
@@ -10,6 +10,7 @@ import {
   updateCustomColumnAliasOnLabelChange,
   selectColumnOptionsValidation,
   allowedFirstDayOfWeekRange,
+  updateCellEditabilityOnInfiniteScrollChange,
   updateSearchSortFilterOnInfiniteScrollChange,
 } from "../propertyUtils";
 import _ from "lodash";
@@ -570,584 +571,4 @@ describe("selectColumnOptionsValidation", () => {
 
     it("should check that value should be an array of objects", () => {
       expect(
-        selectColumnOptionsValidation([1, 2], {} as TableWidgetProps, _),
-      ).toEqual({
-        isValid: false,
-        parsed: [1, 2],
-        messages: [
-          `Invalid entry at index: 0. This value does not evaluate to type: { "label": string | number, "value": string | number | boolean }`,
-        ],
-      });
-    });
-
-    it("should check that each value should have label key", () => {
-      expect(
-        selectColumnOptionsValidation(
-          [{ value: "1" }, { value: "2" }],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: false,
-        parsed: [{ value: "1" }, { value: "2" }],
-        messages: [`Invalid entry at index: 0. Missing required key: label`],
-      });
-    });
-
-    it("should check that each value should have value key", () => {
-      expect(
-        selectColumnOptionsValidation(
-          [{ label: "1" }, { label: "2" }],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: false,
-        parsed: [{ label: "1" }, { label: "2" }],
-        messages: [`Invalid entry at index: 0. Missing required key: value`],
-      });
-    });
-
-    it("should check that each value should have unique value", () => {
-      expect(
-        selectColumnOptionsValidation(
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "1" },
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: false,
-        parsed: [
-          { label: "1", value: "1" },
-          { label: "2", value: "1" },
-        ],
-        messages: [
-          "Duplicate values found for the following properties, in the array entries, that must be unique -- value.",
-        ],
-      });
-    });
-
-    it("should check that array of label, value witn invalid values", () => {
-      expect(
-        selectColumnOptionsValidation(
-          [{ label: "1", value: [] }],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: false,
-        parsed: [{ label: "1", value: [] }],
-        messages: [
-          "Invalid entry at index: 0. value does not evaluate to type string | number | boolean",
-        ],
-      });
-
-      expect(
-        selectColumnOptionsValidation(
-          [{ label: true, value: "1" }],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: false,
-        parsed: [{ label: true, value: "1" }],
-        messages: [
-          "Invalid entry at index: 0. label does not evaluate to type string | number",
-        ],
-      });
-    });
-
-    it("should check that array of label, value is valid", () => {
-      expect(
-        selectColumnOptionsValidation(
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "2" },
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: true,
-        parsed: [
-          { label: "1", value: "1" },
-          { label: "2", value: "2" },
-        ],
-        messages: [""],
-      });
-
-      expect(
-        selectColumnOptionsValidation(
-          [
-            { label: "1", value: 1 },
-            { label: "2", value: "2" },
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: true,
-        parsed: [
-          { label: "1", value: 1 },
-          { label: "2", value: "2" },
-        ],
-        messages: [""],
-      });
-
-      expect(
-        selectColumnOptionsValidation(
-          [
-            { label: "1", value: true },
-            { label: "2", value: "2" },
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: true,
-        parsed: [
-          { label: "1", value: true },
-          { label: "2", value: "2" },
-        ],
-        messages: [""],
-      });
-
-      expect(
-        selectColumnOptionsValidation(
-          [
-            { label: 1, value: true },
-            { label: "2", value: "2" },
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: true,
-        parsed: [
-          { label: 1, value: true },
-          { label: "2", value: "2" },
-        ],
-        messages: [""],
-      });
-    });
-  });
-
-  describe("- Array of Array of label, values", () => {
-    it("should check that value should be an array of arrays", () => {
-      expect(
-        selectColumnOptionsValidation([[1, 2], 1], {} as TableWidgetProps, _),
-      ).toEqual({
-        isValid: false,
-        parsed: [],
-        messages: [
-          `This value does not evaluate to type Array<{ "label": string | number, "value": string | number | boolean }>`,
-        ],
-      });
-    });
-
-    it("should check that value should be an array of arrays of object", () => {
-      expect(
-        selectColumnOptionsValidation([[1, 2]], {} as TableWidgetProps, _),
-      ).toEqual({
-        isValid: false,
-        parsed: [[1, 2]],
-        messages: [
-          `Invalid entry at Row: 0 index: 0. This value does not evaluate to type: { "label": string | number, "value": string | number | boolean }`,
-        ],
-      });
-    });
-
-    it("should check that each value should have label key", () => {
-      expect(
-        selectColumnOptionsValidation(
-          [[{ value: "1" }, { value: "2" }]],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: false,
-        parsed: [[{ value: "1" }, { value: "2" }]],
-        messages: [
-          `Invalid entry at Row: 0 index: 0. Missing required key: label`,
-        ],
-      });
-
-      expect(
-        selectColumnOptionsValidation(
-          [
-            [
-              { label: "1", value: "1" },
-              { label: "2", value: "2" },
-            ],
-            [{ value: "1" }, { value: "2" }],
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: false,
-        parsed: [
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "2" },
-          ],
-          [{ value: "1" }, { value: "2" }],
-        ],
-        messages: [
-          `Invalid entry at Row: 1 index: 0. Missing required key: label`,
-        ],
-      });
-    });
-
-    it("should check that each value should have value key", () => {
-      expect(
-        selectColumnOptionsValidation(
-          [[{ label: "1" }, { label: "2" }]],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: false,
-        parsed: [[{ label: "1" }, { label: "2" }]],
-        messages: [
-          `Invalid entry at Row: 0 index: 0. Missing required key: value`,
-        ],
-      });
-
-      expect(
-        selectColumnOptionsValidation(
-          [
-            [
-              { label: "1", value: "1" },
-              { label: "2", value: "2" },
-            ],
-            [{ label: "1" }, { label: "2" }],
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: false,
-        parsed: [
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "2" },
-          ],
-          [{ label: "1" }, { label: "2" }],
-        ],
-        messages: [
-          `Invalid entry at Row: 1 index: 0. Missing required key: value`,
-        ],
-      });
-    });
-
-    it("should check that each value should have unique value", () => {
-      expect(
-        selectColumnOptionsValidation(
-          [
-            [
-              { label: "1", value: "1" },
-              { label: "2", value: "1" },
-            ],
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: false,
-        parsed: [
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "1" },
-          ],
-        ],
-        messages: [
-          "Duplicate values found for the following properties, in the array entries, that must be unique -- value.",
-        ],
-      });
-
-      expect(
-        selectColumnOptionsValidation(
-          [
-            [
-              { label: "1", value: "1" },
-              { label: "2", value: "2" },
-            ],
-            [
-              { label: "1", value: "1" },
-              { label: "2", value: "2" },
-            ],
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: true,
-        parsed: [
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "2" },
-          ],
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "2" },
-          ],
-        ],
-        messages: [""],
-      });
-    });
-
-    it("should check that array of arrays of label, value is valid", () => {
-      expect(
-        selectColumnOptionsValidation(
-          [
-            [
-              { label: "1", value: "1" },
-              { label: "2", value: "2" },
-            ],
-            [
-              { label: "1", value: "1" },
-              { label: "2", value: "2" },
-            ],
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: true,
-        parsed: [
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "2" },
-          ],
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "2" },
-          ],
-        ],
-        messages: [""],
-      });
-    });
-
-    it("should check that array of JSON is valid", () => {
-      expect(
-        selectColumnOptionsValidation(
-          [
-            JSON.stringify([
-              { label: "1", value: "1" },
-              { label: "2", value: "2" },
-            ]),
-            JSON.stringify([
-              { label: "1", value: "1" },
-              { label: "2", value: "2" },
-            ]),
-          ],
-          {} as TableWidgetProps,
-          _,
-        ),
-      ).toEqual({
-        isValid: true,
-        parsed: [
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "2" },
-          ],
-          [
-            { label: "1", value: "1" },
-            { label: "2", value: "2" },
-          ],
-        ],
-        messages: [""],
-      });
-    });
-  });
-});
-
-describe("updateCustomColumnAliasOnLabelChange", () => {
-  it("should return the propertyToUpdate array to update alias for the given custom column", () => {
-    expect(
-      updateCustomColumnAliasOnLabelChange(
-        {} as TableWidgetProps,
-        "primaryColumns.customColumn1.label",
-        "customColumn12",
-      ),
-    ).toEqual([
-      {
-        propertyPath: "primaryColumns.customColumn1.alias",
-        propertyValue: "customColumn12",
-      },
-    ]);
-  });
-
-  it("should not return propertyToUpdate array to update alias for the given column", () => {
-    expect(
-      updateCustomColumnAliasOnLabelChange(
-        {} as TableWidgetProps,
-        "primaryColumns.resume_url.label",
-        "customColumn12",
-      ),
-    ).toEqual(undefined);
-  });
-
-  it("should not return the propertyToUpdate array to update alias when any property other than label property of the custom column gets changed", () => {
-    expect(
-      updateCustomColumnAliasOnLabelChange(
-        {} as TableWidgetProps,
-        "primaryColumns.customColumn1.notlabel",
-        "customColumn12",
-      ),
-    ).toEqual(undefined);
-  });
-
-  it("should return the propertyToUpdate array to update alias for any given custom column", () => {
-    expect(
-      updateCustomColumnAliasOnLabelChange(
-        {} as TableWidgetProps,
-        "primaryColumns.customColumn12345.label",
-        "customColumn12",
-      ),
-    ).toEqual([
-      {
-        propertyPath: "primaryColumns.customColumn12345.alias",
-        propertyValue: "customColumn12",
-      },
-    ]);
-  });
-});
-
-describe("allowedFirstDayOfWeekRange", () => {
-  it("should return valid object value is within 0 to 6", () => {
-    expect(allowedFirstDayOfWeekRange(4)).toEqual({
-      isValid: true,
-      parsed: 4,
-      messages: [],
-    });
-  });
-
-  it("should return valid object value is within 0 to 6", () => {
-    expect(allowedFirstDayOfWeekRange(0)).toEqual({
-      isValid: true,
-      parsed: 0,
-      messages: [],
-    });
-  });
-
-  it("should return invalid object when value is not within 0 to 6", () => {
-    expect(allowedFirstDayOfWeekRange(8)).toEqual({
-      isValid: false,
-      parsed: 0,
-      messages: ["Number should be between 0-6."],
-    });
-  });
-
-  it("should return invalid object when value is not within 0 to 6", () => {
-    expect(allowedFirstDayOfWeekRange(-2)).toEqual({
-      isValid: false,
-      parsed: 0,
-      messages: ["Number should be between 0-6."],
-    });
-  });
-});
-
-describe("Infinite Scroll Update Hooks - ", () => {
-  it("updateAllowAddNewRowOnInfiniteScrollChange - should disable/enable add new row when infinite scroll is toggled", () => {
-    const props = {} as TableWidgetProps;
-
-    // When infinite scroll is enabled
-    expect(
-      updateAllowAddNewRowOnInfiniteScrollChange(
-        props,
-        "infiniteScrollEnabled",
-        true,
-      ),
-    ).toEqual([
-      {
-        propertyPath: "allowAddNewRow",
-        propertyValue: false,
-      },
-    ]);
-
-    // When infinite scroll is disabled
-    expect(
-      updateAllowAddNewRowOnInfiniteScrollChange(
-        props,
-        "infiniteScrollEnabled",
-        false,
-      ),
-    ).toEqual([
-      {
-        propertyPath: "allowAddNewRow",
-        propertyValue: true,
-      },
-    ]);
-
-    // When some other value is passed
-    expect(
-      updateAllowAddNewRowOnInfiniteScrollChange(
-        props,
-        "infiniteScrollEnabled",
-        "some-other-value",
-      ),
-    ).toBeUndefined();
-  });
-
-  it("updateSearchSortFilterOnInfiniteScrollChange - should disable/enable search, filter, sort when infinite scroll is toggled", () => {
-    const props = {} as TableWidgetProps;
-
-    // When infinite scroll is enabled
-    expect(
-      updateSearchSortFilterOnInfiniteScrollChange(
-        props,
-        "infiniteScrollEnabled",
-        true,
-      ),
-    ).toEqual([
-      {
-        propertyPath: "isVisibleSearch",
-        propertyValue: false,
-      },
-      {
-        propertyPath: "isVisibleFilters",
-        propertyValue: false,
-      },
-      {
-        propertyPath: "isSortable",
-        propertyValue: false,
-      },
-    ]);
-
-    // When infinite scroll is disabled
-    expect(
-      updateSearchSortFilterOnInfiniteScrollChange(
-        props,
-        "infiniteScrollEnabled",
-        false,
-      ),
-    ).toEqual([
-      {
-        propertyPath: "isVisibleFilters",
-        propertyValue: true,
-      },
-      {
-        propertyPath: "isVisibleSearch",
-        propertyValue: true,
-      },
-      {
-        propertyPath: "isSortable",
-        propertyValue: true,
-      },
-    ]);
-
-    // When some other value is passed
-    expect(
-      updateSearchSortFilterOnInfiniteScrollChange(
-        props,
-        "infiniteScrollEnabled",
-        "some-other-value",
-      ),
-    ).toBeUndefined();
-  });
-});
+        selectColumnOptionsValidation([1, 2], {} as TableWidgetProps, _),
\ No newline at end of file
diff --git a/app/client/src/widgets/TableWidgetV2/widget/index.tsx b/app/client/src/widgets/TableWidgetV2/widget/index.tsx
index 2e86578..07d1029 100644
--- a/app/client/src/widgets/TableWidgetV2/widget/index.tsx
+++ b/app/client/src/widgets/TableWidgetV2/widget/index.tsx
@@ -448,2662 +448,4 @@ class TableWidgetV2 extends BaseWidget<TableWidgetProps, WidgetState> {
     return (widget: TableWidgetProps, extraDefsToDefine?: ExtraDef) => {
       const config: AutocompletionDefinitions = {
         "!doc":
-          "The Table is the hero widget of Appsmith. You can display data from an API in a table, trigger an action when a user selects a row and even work with large paginated data sets",
-        "!url": "https://docs.appsmith.com/widget-reference/table",
-        selectedRow: generateTypeDef(widget.selectedRow, extraDefsToDefine),
-        selectedRows: generateTypeDef(widget.selectedRows, extraDefsToDefine),
-        selectedRowIndices: generateTypeDef(widget.selectedRowIndices),
-        triggeredRow: generateTypeDef(widget.triggeredRow),
-        updatedRow: generateTypeDef(widget.updatedRow),
-        selectedRowIndex: "number",
-        tableData: generateTypeDef(widget.tableData, extraDefsToDefine),
-        pageNo: "number",
-        pageSize: "number",
-        isVisible: DefaultAutocompleteDefinitions.isVisible,
-        searchText: "string",
-        totalRecordsCount: "number",
-        sortOrder: {
-          column: "string",
-          order: ["asc", "desc"],
-        },
-        updatedRows: generateTypeDef(widget.updatedRows, extraDefsToDefine),
-        updatedRowIndices: generateTypeDef(widget.updatedRowIndices),
-        triggeredRowIndex: generateTypeDef(widget.triggeredRowIndex),
-        pageOffset: generateTypeDef(widget.pageOffset),
-        tableHeaders: generateTypeDef(widget.tableHeaders),
-        newRow: generateTypeDef(widget.newRow),
-        isAddRowInProgress: "bool",
-        previousPageVisited: generateTypeDef(widget.previousPageVisited),
-        nextPageVisited: generateTypeDef(widget.nextPageButtonClicked),
-      };
-
-      if (this.getFeatureFlag(ALLOW_TABLE_WIDGET_SERVER_SIDE_FILTERING)) {
-        config["filters"] = generateTypeDef(widget.filters);
-      }
-
-      return config;
-    };
-  }
-
-  static getDerivedPropertiesMap() {
-    return {
-      selectedRow: `{{(()=>{${derivedProperties.getSelectedRow}})()}}`,
-      triggeredRow: `{{(()=>{${derivedProperties.getTriggeredRow}})()}}`,
-      selectedRows: `{{(()=>{${derivedProperties.getSelectedRows}})()}}`,
-      pageSize: `{{(()=>{${derivedProperties.getPageSize}})()}}`,
-      triggerRowSelection: "{{!!this.onRowSelected}}",
-      processedTableData: `{{(()=>{${derivedProperties.getProcessedTableData}})()}}`,
-      orderedTableColumns: `{{(()=>{${derivedProperties.getOrderedTableColumns}})()}}`,
-      filteredTableData: `{{(()=>{ ${derivedProperties.getFilteredTableData}})()}}`,
-      updatedRows: `{{(()=>{ ${derivedProperties.getUpdatedRows}})()}}`,
-      updatedRowIndices: `{{(()=>{ ${derivedProperties.getUpdatedRowIndices}})()}}`,
-      updatedRow: `{{(()=>{ ${derivedProperties.getUpdatedRow}})()}}`,
-      pageOffset: `{{(()=>{${derivedProperties.getPageOffset}})()}}`,
-      isEditableCellsValid: `{{(()=>{ ${derivedProperties.getEditableCellValidity}})()}}`,
-      tableHeaders: `{{(()=>{${derivedProperties.getTableHeaders}})()}}`,
-    };
-  }
-
-  static getDefaultPropertiesMap(): Record<string, string> {
-    return {
-      searchText: "defaultSearchText",
-      selectedRowIndex: "defaultSelectedRowIndex",
-      selectedRowIndices: "defaultSelectedRowIndices",
-    };
-  }
-
-  static getLoadingProperties(): Array<RegExp> | undefined {
-    return [/\.tableData$/];
-  }
-
-  static getStylesheetConfig(): Stylesheet {
-    return {
-      accentColor: "{{appsmith.theme.colors.primaryColor}}",
-      borderRadius: "{{appsmith.theme.borderRadius.appBorderRadius}}",
-      boxShadow: "{{appsmith.theme.boxShadow.appBoxShadow}}",
-      childStylesheet: {
-        button: {
-          buttonColor: "{{appsmith.theme.colors.primaryColor}}",
-          borderRadius: "{{appsmith.theme.borderRadius.appBorderRadius}}",
-          boxShadow: "none",
-        },
-        menuButton: {
-          menuColor: "{{appsmith.theme.colors.primaryColor}}",
-          borderRadius: "{{appsmith.theme.borderRadius.appBorderRadius}}",
-          boxShadow: "none",
-        },
-        iconButton: {
-          buttonColor: "{{appsmith.theme.colors.primaryColor}}",
-          borderRadius: "{{appsmith.theme.borderRadius.appBorderRadius}}",
-          boxShadow: "none",
-        },
-        editActions: {
-          saveButtonColor: "{{appsmith.theme.colors.primaryColor}}",
-          saveBorderRadius: "{{appsmith.theme.borderRadius.appBorderRadius}}",
-          discardButtonColor: "{{appsmith.theme.colors.primaryColor}}",
-          discardBorderRadius:
-            "{{appsmith.theme.borderRadius.appBorderRadius}}",
-        },
-      },
-    };
-  }
-
-  static getSetterConfig(): SetterConfig {
-    return {
-      __setters: {
-        setVisibility: {
-          path: "isVisible",
-          type: "string",
-        },
-        setSelectedRowIndex: {
-          path: "defaultSelectedRowIndex",
-          type: "number",
-          disabled: "return options.entity.multiRowSelection",
-        },
-        setSelectedRowIndices: {
-          path: "defaultSelectedRowIndices",
-          type: "array",
-          disabled: "return !options.entity.multiRowSelection",
-        },
-        setData: {
-          path: "tableData",
-          type: "array",
-        },
-      },
-    };
-  }
-
-  /*
-   * Function to get the table columns with appropriate render functions
-   * based on columnType
-   */
-  getTableColumns = () => {
-    const {
-      columnWidthMap,
-      infiniteScrollEnabled,
-      isPreviewMode,
-      orderedTableColumns,
-      renderMode,
-      widgetId,
-    } = this.props;
-    const { componentWidth } = this.getPaddingAdjustedDimensions();
-    const widgetLocalStorageState = getColumnOrderByWidgetIdFromLS(widgetId);
-    const memoisdGetColumnsWithLocalStorage =
-      this.memoiseGetColumnsWithLocalStorage(widgetLocalStorageState);
-
-    return memoisdGetColumnsWithLocalStorage(
-      this.renderCell,
-      columnWidthMap,
-      orderedTableColumns,
-      componentWidth,
-      renderMode,
-      isPreviewMode,
-      infiniteScrollEnabled,
-    );
-  };
-
-  transformData = (
-    tableData: Array<Record<string, unknown>>,
-    columns: ReactTableColumnProps[],
-  ) => {
-    return this.memoiseTransformDataWithEditableCell(
-      this.props.editableCell,
-      tableData,
-      columns,
-    );
-  };
-
-  updateDerivedColumnsIndex = (
-    derivedColumns: Record<string, ColumnProperties>,
-    tableColumnCount: number,
-  ) => {
-    if (!derivedColumns) {
-      return [];
-    }
-
-    //update index property of all columns in new derived columns
-    return Object.values(derivedColumns).map(
-      (column: ColumnProperties, index: number) => {
-        return {
-          ...column,
-          index: index + tableColumnCount,
-        };
-      },
-    );
-  };
-
-  /*
-   * Function to create new primary Columns from the tableData
-   * gets called on component mount and on component update
-   */
-  createTablePrimaryColumns = ():
-    | Record<string, ColumnProperties>
-    | undefined => {
-    const {
-      infiniteScrollEnabled,
-      primaryColumns = {},
-      tableData = [],
-    } = this.props;
-
-    if (!_.isArray(tableData) || tableData.length === 0) {
-      return;
-    }
-
-    const existingColumnIds = Object.keys(primaryColumns);
-    const newTableColumns: Record<string, ColumnProperties> = {};
-    const tableStyles = getTableStyles(this.props);
-    const columnKeys: string[] = getAllTableColumnKeys(tableData);
-
-    /*
-     * Generate default column properties for all columns
-     * But do not replace existing columns with the same id
-     */
-    columnKeys.forEach((columnKey, index) => {
-      const existingColumn = this.getColumnByOriginalId(columnKey);
-
-      if (!!existingColumn) {
-        // Use the existing column properties
-        newTableColumns[existingColumn.id] = existingColumn;
-      } else {
-        const hashedColumnKey = sanitizeKey(columnKey, {
-          existingKeys: union(existingColumnIds, Object.keys(newTableColumns)),
-        });
-        // Create column properties for the new column
-        const columnType = getColumnType(tableData, columnKey);
-        const columnProperties = getDefaultColumnProperties(
-          columnKey,
-          hashedColumnKey,
-          index,
-          this.props.widgetName,
-          false,
-          columnType,
-        );
-
-        newTableColumns[columnProperties.id] = {
-          ...columnProperties,
-          ...tableStyles,
-        };
-      }
-    });
-
-    const derivedColumns: Record<string, ColumnProperties> =
-      getDerivedColumns(primaryColumns);
-
-    const updatedDerivedColumns = this.updateDerivedColumnsIndex(
-      derivedColumns,
-      Object.keys(newTableColumns).length,
-    );
-
-    //add derived columns to new Table columns
-    updatedDerivedColumns.forEach((derivedColumn: ColumnProperties) => {
-      newTableColumns[derivedColumn.id] = derivedColumn;
-    });
-
-    const newColumnIds = Object.keys(newTableColumns);
-
-    /**
-     * When infinite scroll is enabled, we need to merge the new columns with the existing ones.
-     * Why?
-     * The infinite scroll behavior differs from the existing server-side pagination in that it merges new incoming data with the existing data.
-     * If the new page contains corrupted data with either more or fewer columns than the existing data, the current product behavior only considers the new columns, which is not ideal for infinite scroll.
-     * Therefore, in this block, we are merging the new columns with the existing ones without removing any data.
-     */
-    if (infiniteScrollEnabled) {
-      const mergedColumns = {
-        ...primaryColumns,
-        ...newTableColumns,
-      };
-
-      if (_.xor(existingColumnIds, Object.keys(mergedColumns)).length > 0) {
-        return mergedColumns;
-      }
-
-      return;
-    }
-
-    // For non-infinite scroll, keep existing logic
-    // check if the columns ids differ
-    if (_.xor(existingColumnIds, newColumnIds).length > 0) {
-      return newTableColumns;
-    } else {
-      return;
-    }
-  };
-
-  /*
-   * Function to update primaryColumns when the tablData schema changes
-   */
-  updateColumnProperties = (
-    tableColumns?: Record<string, ColumnProperties>,
-    shouldPersistLocalOrderWhenTableDataChanges = false,
-  ) => {
-    const { columnOrder = [], primaryColumns = {} } = this.props;
-    const derivedColumns = getDerivedColumns(primaryColumns);
-
-    if (tableColumns) {
-      const existingColumnIds = Object.keys(primaryColumns);
-      const existingDerivedColumnIds = Object.keys(derivedColumns);
-
-      const newColumnIds = Object.keys(tableColumns);
-
-      //Check if there is any difference in the existing and new columns ids
-      if (_.xor(existingColumnIds, newColumnIds).length > 0) {
-        const newColumnIdsToAdd = _.without(newColumnIds, ...existingColumnIds);
-
-        const propertiesToAdd: Record<string, unknown> = {};
-
-        newColumnIdsToAdd.forEach((columnId: string) => {
-          // id could be an empty string
-          if (!!columnId) {
-            Object.entries(tableColumns[columnId]).forEach(([key, value]) => {
-              propertiesToAdd[`primaryColumns.${columnId}.${key}`] = value;
-            });
-          }
-        });
-
-        /*
-         * If new columnOrders have different values from the original columnOrders
-         * Only update when there are new Columns(Derived or Primary)
-         */
-        if (
-          !!newColumnIds.length &&
-          !!_.xor(newColumnIds, columnOrder).length &&
-          !equal(_.sortBy(newColumnIds), _.sortBy(existingDerivedColumnIds))
-        ) {
-          // Maintain original columnOrder and keep new columns at the end
-          let newColumnOrder = _.intersection(columnOrder, newColumnIds);
-
-          newColumnOrder = _.union(newColumnOrder, newColumnIds);
-
-          const compareColumns = (a: string, b: string) => {
-            const aSticky = tableColumns[a].sticky || "none";
-            const bSticky = tableColumns[b].sticky || "none";
-
-            if (aSticky === bSticky) {
-              return 0;
-            }
-
-            return SORT_ORDER[aSticky] - SORT_ORDER[bSticky];
-          };
-
-          // Sort the column order to retain the position of frozen columns
-          newColumnOrder.sort(compareColumns);
-
-          propertiesToAdd["columnOrder"] = newColumnOrder;
-
-          /**
-           * As the table data changes in Deployed app, we also update the local storage.
-           *
-           * this.updateColumnProperties gets executed on mount and on update of the component.
-           * On mount we get new tableColumns that may not have any sticky columns.
-           * This will lead to loss of sticky column that were frozen by the user.
-           * To avoid this and to maintain user's sticky columns we use shouldPersistLocalOrderWhenTableDataChanges below
-           * so as to avoid updating the local storage on mount.
-           **/
-          if (
-            this.props.renderMode === RenderModes.PAGE &&
-            shouldPersistLocalOrderWhenTableDataChanges
-          ) {
-            const leftOrder = newColumnOrder.filter(
-              (col: string) => tableColumns[col].sticky === StickyType.LEFT,
-            );
-            const rightOrder = newColumnOrder.filter(
-              (col: string) => tableColumns[col].sticky === StickyType.RIGHT,
-            );
-
-            this.persistColumnOrder(newColumnOrder, leftOrder, rightOrder);
-          }
-        }
-
-        const propertiesToUpdate: BatchPropertyUpdatePayload = {
-          modify: propertiesToAdd,
-        };
-
-        const pathsToDelete: string[] = [];
-        const columnsIdsToDelete = without(existingColumnIds, ...newColumnIds);
-
-        if (!!columnsIdsToDelete.length) {
-          columnsIdsToDelete.forEach((id: string) => {
-            if (!primaryColumns[id].isDerived) {
-              pathsToDelete.push(`primaryColumns.${id}`);
-            }
-          });
-          propertiesToUpdate.remove = pathsToDelete;
-        }
-
-        super.batchUpdateWidgetProperty(propertiesToUpdate, false);
-      }
-    }
-  };
-
-  //no need to batch meta updates
-  hydrateStickyColumns = () => {
-    const localTableColumnOrder = getColumnOrderByWidgetIdFromLS(
-      this.props.widgetId,
-    );
-    const leftLen: number = Object.keys(
-      pickBy(this.props.primaryColumns, (col) => col.sticky === "left"),
-    ).length;
-
-    const leftOrder = [...(this.props.columnOrder || [])].slice(0, leftLen);
-
-    const rightLen: number = Object.keys(
-      pickBy(this.props.primaryColumns, (col) => col.sticky !== "right"),
-    ).length;
-
-    const rightOrder: string[] = [...(this.props.columnOrder || [])].slice(
-      rightLen,
-    );
-
-    if (localTableColumnOrder) {
-      const {
-        columnOrder,
-        columnUpdatedAt,
-        leftOrder: localLeftOrder,
-        rightOrder: localRightOrder,
-      } = localTableColumnOrder;
-
-      if (this.props.columnUpdatedAt !== columnUpdatedAt) {
-        // Delete and set the column orders defined by the developer
-        deleteLocalTableColumnOrderByWidgetId(this.props.widgetId);
-
-        this.persistColumnOrder(
-          this.props.columnOrder ?? [],
-          leftOrder,
-          rightOrder,
-        );
-      } else {
-        const propertiesToAdd: Record<string, string> = {};
-
-        propertiesToAdd["columnOrder"] = columnOrder;
-
-        /**
-         * We reset the sticky values of the columns that were frozen by the developer.
-         */
-        if (Object.keys(this.props.primaryColumns).length > 0) {
-          columnOrder.forEach((colName: string) => {
-            if (
-              this.props.primaryColumns[colName]?.sticky !== StickyType.NONE
-            ) {
-              propertiesToAdd[`primaryColumns.${colName}.sticky`] =
-                StickyType.NONE;
-            }
-          });
-        }
-
-        /**
-         * We pickup the left and the right frozen columns from the localstorage
-         * and update the sticky value of these columns respectively.
-         */
-
-        if (localLeftOrder.length > 0) {
-          localLeftOrder.forEach((colName: string) => {
-            propertiesToAdd[`primaryColumns.${colName}.sticky`] =
-              StickyType.LEFT;
-          });
-        }
-
-        if (localRightOrder.length > 0) {
-          localRightOrder.forEach((colName: string) => {
-            propertiesToAdd[`primaryColumns.${colName}.sticky`] =
-              StickyType.RIGHT;
-          });
-        }
-
-        const propertiesToUpdate = {
-          modify: propertiesToAdd,
-        };
-
-        super.batchUpdateWidgetProperty(propertiesToUpdate);
-      }
-    } else {
-      // If user deletes local storage or no column orders for the given table widget exists hydrate it with the developer changes.
-      this.persistColumnOrder(
-        this.props.columnOrder ?? [],
-        leftOrder,
-        rightOrder,
-      );
-    }
-  };
-
-  componentDidMount() {
-    const { canFreezeColumn, renderMode, tableData } = this.props;
-
-    if (_.isArray(tableData) && !!tableData.length) {
-      const newPrimaryColumns = this.createTablePrimaryColumns();
-
-      // When the Table data schema changes
-      if (newPrimaryColumns && !!Object.keys(newPrimaryColumns).length) {
-        this.updateColumnProperties(newPrimaryColumns);
-      }
-    }
-
-    if (canFreezeColumn && renderMode === RenderModes.PAGE) {
-      //dont neet to batch this since single action
-      this.hydrateStickyColumns();
-    }
-
-    // Commit Batch Updates property `true` is passed as commitBatchMetaUpdates is not called on componentDidMount and we need to call it for updating the batch updates
-    this.updateInfiniteScrollProperties(true);
-  }
-
-  componentDidUpdate(prevProps: TableWidgetProps) {
-    const {
-      commitBatchMetaUpdates,
-      componentHeight,
-      defaultSelectedRowIndex,
-      defaultSelectedRowIndices,
-      infiniteScrollEnabled,
-      pageNo,
-      pageSize,
-      primaryColumns = {},
-      pushBatchMetaUpdates,
-      serverSidePaginationEnabled,
-      totalRecordsCount,
-    } = this.props;
-
-    // Bail out if tableData is a string. This signifies an error in evaluations
-    if (isString(this.props.tableData)) {
-      return;
-    }
-
-    if (
-      this.props.primaryColumns &&
-      (!equal(prevProps.columnOrder, this.props.columnOrder) ||
-        filter(prevProps.orderedTableColumns, { isVisible: false }).length !==
-          filter(this.props.orderedTableColumns, { isVisible: false }).length ||
-        getAllStickyColumnsCount(prevProps.orderedTableColumns) !==
-          getAllStickyColumnsCount(this.props.orderedTableColumns))
-    ) {
-      if (this.props.renderMode === RenderModes.CANVAS) {
-        super.batchUpdateWidgetProperty(
-          {
-            modify: {
-              columnUpdatedAt: Date.now(),
-            },
-          },
-          false,
-        );
-      }
-    }
-
-    //check if necessary we are batching now updates
-    // Check if tableData is modifed
-    // const isTableDataModified = this.props.tableData !== prevProps.tableData;
-    const isTableDataModified = !equal(
-      this.props.tableData,
-      prevProps.tableData,
-    );
-
-    // If the user has changed the tableData OR
-    // The binding has returned a new value
-    if (isTableDataModified) {
-      this.pushMetaRowDataUpdates(
-        prevProps.filteredTableData,
-        this.props.filteredTableData,
-      );
-
-      pushBatchMetaUpdates("triggeredRowIndex", -1);
-
-      const newColumnIds: string[] = getAllTableColumnKeys(
-        this.props.tableData,
-      );
-      const primaryColumnIds = Object.keys(primaryColumns).filter(
-        (id: string) => !primaryColumns[id].isDerived,
-      );
-
-      if (xor(newColumnIds, primaryColumnIds).length > 0) {
-        const newTableColumns = this.createTablePrimaryColumns();
-
-        if (newTableColumns) {
-          this.updateColumnProperties(newTableColumns, isTableDataModified);
-        }
-
-        pushBatchMetaUpdates("filters", []);
-      }
-
-      /*
-       * Clear transient table data and editablecell when tableData changes
-       */
-      pushBatchMetaUpdates("transientTableData", {});
-      // reset updatedRowIndex whenever transientTableData is flushed.
-      pushBatchMetaUpdates("updatedRowIndex", -1);
-
-      /*
-       * Updating the caching layer on table data modification
-       * Commit Batch Updates property `false` is passed as commitBatchMetaUpdates is called on componentDidUpdate
-       * and we need not to explicitly call it for updating the batch updates
-       * */
-      this.updateInfiniteScrollProperties();
-
-      this.pushClearEditableCellsUpdates();
-      pushBatchMetaUpdates("selectColumnFilterText", {});
-    } else {
-      // TODO: reset the widget on any property change, like if the toggle of infinite scroll is enabled and previously it was disabled, currently we update cachedTableData property to the current tableData at pageNo.
-      /*
-       * Commit Batch Updates property `false` is passed as commitBatchMetaUpdates is called on componentDidUpdate
-       * and we need not to explicitly call it for updating the batch updates
-       * */
-      if (
-        !prevProps.infiniteScrollEnabled &&
-        this.props.infiniteScrollEnabled
-      ) {
-        this.updateInfiniteScrollProperties();
-      }
-    }
-
-    if (!pageNo) {
-      pushBatchMetaUpdates("pageNo", 1);
-      this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);
-    }
-
-    //check if pageNo does not excede the max Page no, due to change of totalRecordsCount
-    if (serverSidePaginationEnabled !== prevProps.serverSidePaginationEnabled) {
-      //reset pageNo when serverSidePaginationEnabled is toggled
-      pushBatchMetaUpdates("pageNo", 1);
-      this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);
-    } else {
-      //check if pageNo does not excede the max Page no, due to change of totalRecordsCount or change of pageSize
-      if (serverSidePaginationEnabled && totalRecordsCount) {
-        const maxAllowedPageNumber = Math.ceil(totalRecordsCount / pageSize);
-
-        if (pageNo > maxAllowedPageNumber) {
-          pushBatchMetaUpdates("pageNo", maxAllowedPageNumber);
-          this.updatePaginationDirectionFlags(PaginationDirection.NEXT_PAGE);
-        }
-      }
-    }
-
-    // Reset widget state when infinite scroll is initially enabled
-    // This should come after all updateInfiniteScrollProperties are done
-    const didInfiniteScrollEnabledChange =
-      prevProps.infiniteScrollEnabled !== infiniteScrollEnabled;
-    const didComponentHeightChange =
-      prevProps.componentHeight !== componentHeight;
-
-    if (
-      didInfiniteScrollEnabledChange ||
-      (infiniteScrollEnabled && didComponentHeightChange)
-    ) {
-      this.resetTableForInfiniteScroll();
-    }
-
-    /*
-     * When defaultSelectedRowIndex or defaultSelectedRowIndices
-     * is changed from property pane
-     */
-    if (
-      !equal(defaultSelectedRowIndex, prevProps.defaultSelectedRowIndex) ||
-      !equal(defaultSelectedRowIndices, prevProps.defaultSelectedRowIndices)
-    ) {
-      this.pushUpdateSelectedRowIndexUpdates();
-    }
-
-    this.pushResetPageNoUpdates(prevProps);
-
-    this.pushResetRowSelectionPropertiesUpdates(prevProps);
-    commitBatchMetaUpdates();
-  }
-
-  pushResetPageNoUpdates = (prevProps: TableWidgetProps) => {
-    const { onPageSizeChange, pageSize, pushBatchMetaUpdates } = this.props;
-
-    if (pageSize !== prevProps.pageSize) {
-      if (onPageSizeChange) {
-        this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);
-        pushBatchMetaUpdates("pageNo", 1, {
-          triggerPropertyName: "onPageSizeChange",
-          dynamicString: onPageSizeChange,
-          event: {
-            type: EventType.ON_PAGE_SIZE_CHANGE,
-          },
-        });
-      } else {
-        pushBatchMetaUpdates("pageNo", 1);
-        this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);
-      }
-    }
-  };
-
-  pushResetRowSelectionPropertiesUpdates = (prevProps: TableWidgetProps) => {
-    const {
-      defaultSelectedRowIndex,
-      defaultSelectedRowIndices,
-      multiRowSelection,
-      pushBatchMetaUpdates,
-    } = this.props;
-
-    // reset selectedRowIndices and selectedRowIndex to defaults
-    if (multiRowSelection !== prevProps.multiRowSelection) {
-      if (multiRowSelection) {
-        if (
-          defaultSelectedRowIndices &&
-          _.isArray(defaultSelectedRowIndices) &&
-          defaultSelectedRowIndices.every((i) => _.isFinite(i))
-        ) {
-          pushBatchMetaUpdates("selectedRowIndices", defaultSelectedRowIndices);
-        }
-
-        pushBatchMetaUpdates("selectedRowIndex", -1);
-      } else {
-        if (
-          !isNil(defaultSelectedRowIndex) &&
-          parseInt(defaultSelectedRowIndex?.toString(), 10) > -1
-        ) {
-          pushBatchMetaUpdates("selectedRowIndex", defaultSelectedRowIndex);
-        }
-
-        pushBatchMetaUpdates("selectedRowIndices", []);
-      }
-    }
-  };
-
-  /*
-   * Function to update selectedRowIndices & selectedRowIndex from
-   * defaultSelectedRowIndices & defaultSelectedRowIndex respectively
-   */
-  pushUpdateSelectedRowIndexUpdates = () => {
-    const {
-      defaultSelectedRowIndex,
-      defaultSelectedRowIndices,
-      multiRowSelection,
-      pushBatchMetaUpdates,
-    } = this.props;
-
-    if (multiRowSelection) {
-      pushBatchMetaUpdates("selectedRowIndices", defaultSelectedRowIndices);
-    } else {
-      pushBatchMetaUpdates("selectedRowIndex", defaultSelectedRowIndex);
-    }
-  };
-
-  /*
-   * Function to update selectedRow details when order of tableData changes
-   */
-  pushMetaRowDataUpdates = (
-    oldTableData: Array<Record<string, unknown>>,
-    newTableData: Array<Record<string, unknown>>,
-  ) => {
-    const {
-      defaultSelectedRowIndex,
-      defaultSelectedRowIndices,
-      multiRowSelection,
-      primaryColumnId,
-      pushBatchMetaUpdates,
-      selectedRowIndex,
-      selectedRowIndices,
-    } = this.props;
-
-    if (multiRowSelection) {
-      const indices = getSelectRowIndices(
-        oldTableData,
-        newTableData,
-        defaultSelectedRowIndices,
-        selectedRowIndices,
-        primaryColumnId,
-      );
-
-      pushBatchMetaUpdates("selectedRowIndices", indices);
-    } else {
-      const index = getSelectRowIndex(
-        oldTableData,
-        newTableData,
-        defaultSelectedRowIndex,
-        selectedRowIndex,
-        primaryColumnId,
-      );
-
-      pushBatchMetaUpdates("selectedRowIndex", index);
-    }
-  };
-
-  getSelectedRowIndices = () => {
-    const { multiRowSelection, selectedRowIndices } = this.props;
-
-    let indices: number[] | undefined;
-
-    if (multiRowSelection) {
-      if (_.isArray(selectedRowIndices)) {
-        indices = selectedRowIndices;
-      } else if (_.isNumber(selectedRowIndices)) {
-        indices = [selectedRowIndices];
-      } else {
-        indices = [];
-      }
-    } else {
-      indices = undefined;
-    }
-
-    return indices;
-  };
-
-  updateFilters = (filters: ReactTableFilter[]) => {
-    const {
-      commitBatchMetaUpdates,
-      enableServerSideFiltering,
-      onTableFilterUpdate,
-      pushBatchMetaUpdates,
-    } = this.props;
-
-    this.pushResetSelectedRowIndexUpdates();
-
-    if (enableServerSideFiltering) {
-      pushBatchMetaUpdates("filters", filters, {
-        triggerPropertyName: "onTableFilterUpdate",
-        dynamicString: onTableFilterUpdate,
-        event: {
-          type: EventType.ON_FILTER_UPDATE,
-        },
-      });
-    } else {
-      pushBatchMetaUpdates("filters", filters);
-    }
-
-    // Reset Page only when a filter is added
-    if (!isEmpty(xorWith(filters, [DEFAULT_FILTER], equal))) {
-      pushBatchMetaUpdates("pageNo", 1);
-      this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);
-    }
-
-    commitBatchMetaUpdates();
-  };
-
-  toggleDrag = (disable: boolean) => {
-    this.disableDrag(disable);
-  };
-
-  getPaddingAdjustedDimensions = () => {
-    // eslint-disable-next-line prefer-const
-    let { componentHeight, componentWidth } = this.props;
-
-    // (2 * WIDGET_PADDING) gives the total horizontal padding (i.e. paddingLeft + paddingRight)
-    componentWidth = componentWidth - 2 * WIDGET_PADDING;
-
-    return { componentHeight, componentWidth };
-  };
-
-  getWidgetView() {
-    const {
-      customIsLoading,
-      customIsLoadingValue,
-      customSortFunction: customSortFunctionData,
-      delimiter,
-      filteredTableData = [],
-      isVisibleDownload,
-      isVisibleFilters,
-      isVisiblePagination,
-      isVisibleSearch,
-      pageSize,
-      primaryColumns,
-      totalRecordsCount,
-    } = this.props;
-
-    const tableColumns = this.getTableColumns() || emptyArr;
-    let data = filteredTableData;
-
-    if (customSortFunctionData && Array.isArray(customSortFunctionData)) {
-      data = customSortFunctionData;
-    }
-
-    const transformedData = this.transformData(data, tableColumns);
-
-    const isVisibleHeaderOptions =
-      isVisibleDownload ||
-      isVisibleFilters ||
-      isVisiblePagination ||
-      isVisibleSearch;
-
-    const { componentHeight, componentWidth } =
-      this.getPaddingAdjustedDimensions();
-    const finalTableData = this.memoisedAddNewRow(
-      transformedData,
-      this.props.isAddRowInProgress,
-      this.props.newRowContent,
-    );
-
-    return (
-      <Suspense fallback={<Skeleton />}>
-        <ReactTableComponent
-          accentColor={this.props.accentColor}
-          allowAddNewRow={this.props.allowAddNewRow}
-          allowRowSelection={!this.props.isAddRowInProgress}
-          allowSorting={!this.props.isAddRowInProgress}
-          applyFilter={this.updateFilters}
-          borderColor={this.props.borderColor}
-          borderRadius={this.props.borderRadius}
-          borderWidth={this.props.borderWidth}
-          boxShadow={this.props.boxShadow}
-          cachedTableData={this.props.cachedTableData}
-          canFreezeColumn={this.props.canFreezeColumn}
-          columnWidthMap={this.props.columnWidthMap}
-          columns={tableColumns}
-          compactMode={this.props.compactMode || CompactModeTypes.DEFAULT}
-          delimiter={delimiter}
-          disableDrag={this.toggleDrag}
-          disabledAddNewRowSave={this.hasInvalidColumnCell()}
-          editMode={this.props.renderMode === RenderModes.CANVAS}
-          editableCell={this.props.editableCell}
-          endOfData={this.props.endOfData}
-          filters={this.props.filters}
-          handleColumnFreeze={this.handleColumnFreeze}
-          handleReorderColumn={this.handleReorderColumn}
-          handleResizeColumn={this.handleResizeColumn}
-          height={componentHeight}
-          isAddRowInProgress={this.props.isAddRowInProgress}
-          isEditableCellsValid={this.props.isEditableCellsValid}
-          isInfiniteScrollEnabled={this.props.infiniteScrollEnabled}
-          isLoading={
-            customIsLoading
-              ? customIsLoadingValue || this.props.isLoading
-              : this.props.isLoading
-          }
-          isSortable={this.props.isSortable ?? true}
-          isVisibleDownload={isVisibleDownload}
-          isVisibleFilters={isVisibleFilters}
-          isVisiblePagination={isVisiblePagination}
-          isVisibleSearch={isVisibleSearch}
-          multiRowSelection={
-            this.props.multiRowSelection && !this.props.isAddRowInProgress
-          }
-          nextPageClick={this.handleNextPageClick}
-          onAddNewRow={this.handleAddNewRowClick}
-          onAddNewRowAction={this.handleAddNewRowAction}
-          onBulkEditDiscard={this.onBulkEditDiscard}
-          onBulkEditSave={this.onBulkEditSave}
-          onConnectData={this.onConnectData}
-          onRowClick={this.handleRowClick}
-          pageNo={this.props.pageNo}
-          pageSize={
-            isVisibleHeaderOptions ? Math.max(1, pageSize) : pageSize + 1
-          }
-          prevPageClick={this.handlePrevPageClick}
-          primaryColumnId={this.props.primaryColumnId}
-          searchKey={this.props.searchText}
-          searchTableData={this.handleSearchTable}
-          selectAllRow={this.handleAllRowSelect}
-          selectedRowIndex={
-            this.props.selectedRowIndex === undefined
-              ? -1
-              : this.props.selectedRowIndex
-          }
-          selectedRowIndices={this.getSelectedRowIndices()}
-          serverSidePaginationEnabled={!!this.props.serverSidePaginationEnabled}
-          showConnectDataOverlay={
-            primaryColumns &&
-            !Object.keys(primaryColumns).length &&
-            this.props.renderMode === RenderModes.CANVAS
-          }
-          sortTableColumn={this.handleColumnSorting}
-          tableData={finalTableData}
-          totalRecordsCount={totalRecordsCount}
-          triggerRowSelection={this.props.triggerRowSelection}
-          unSelectAllRow={this.unSelectAllRow}
-          updatePageNo={this.updatePageNumber}
-          variant={this.props.variant}
-          widgetId={this.props.widgetId}
-          widgetName={this.props.widgetName}
-          width={componentWidth}
-        />
-      </Suspense>
-    );
-  }
-
-  /**
-   * Function to update or add the tableWidgetColumnOrder key in the local storage
-   * tableWidgetColumnOrder = {
-   *  <widget-id>: {
-   *    columnOrder: [],
-   *    leftOrder: [],
-   *    rightOrder: [],
-   *  }
-   * }
-   */
-  persistColumnOrder = (
-    newColumnOrder: string[],
-    leftOrder: string[],
-    rightOrder: string[],
-  ) => {
-    const widgetId = this.props.widgetId;
-    const localTableWidgetColumnOrder = localStorage.getItem(
-      TABLE_COLUMN_ORDER_KEY,
-    );
-    let newTableColumnOrder;
-
-    if (localTableWidgetColumnOrder) {
-      try {
-        let parsedTableWidgetColumnOrder = JSON.parse(
-          localTableWidgetColumnOrder,
-        );
-
-        let columnOrder;
-
-        if (newColumnOrder) {
-          columnOrder = newColumnOrder;
-        } else if (parsedTableWidgetColumnOrder[widgetId]) {
-          columnOrder = parsedTableWidgetColumnOrder[widgetId];
-        } else {
-          columnOrder = this.props.columnOrder;
-        }
-
-        parsedTableWidgetColumnOrder = {
-          ...parsedTableWidgetColumnOrder,
-          [widgetId]: {
-            columnOrder,
-            columnUpdatedAt: this.props.columnUpdatedAt,
-            leftOrder,
-            rightOrder,
-          },
-        };
-
-        newTableColumnOrder = parsedTableWidgetColumnOrder;
-      } catch (e) {
-        log.debug("Unable to parse local column order:", { e });
-      }
-    } else {
-      const tableWidgetColumnOrder = {
-        [widgetId]: {
-          columnOrder: newColumnOrder,
-          columnUpdatedAt: this.props.columnUpdatedAt,
-          leftOrder,
-          rightOrder,
-        },
-      };
-
-      newTableColumnOrder = tableWidgetColumnOrder;
-    }
-
-    localStorage.setItem(
-      TABLE_COLUMN_ORDER_KEY,
-      JSON.stringify(newTableColumnOrder),
-    );
-  };
-
-  handleColumnFreeze = (columnName: string, sticky?: StickyType) => {
-    if (this.props.columnOrder) {
-      let newColumnOrder;
-      const localTableColumnOrder = getColumnOrderByWidgetIdFromLS(
-        this.props.widgetId,
-      );
-
-      if (this.props.renderMode === RenderModes.CANVAS) {
-        newColumnOrder = generateNewColumnOrderFromStickyValue(
-          this.props.primaryColumns,
-          this.props.columnOrder,
-          columnName,
-          sticky,
-        );
-
-        // Updating these properties in batch so that undo/redo gets executed in a combined way.
-        super.batchUpdateWidgetProperty(
-          {
-            modify: {
-              [`primaryColumns.${columnName}.sticky`]: sticky,
-              columnOrder: newColumnOrder,
-            },
-          },
-          true,
-        );
-      } else if (
-        localTableColumnOrder &&
-        this.props.renderMode === RenderModes.PAGE
-      ) {
-        const { leftOrder, rightOrder } = localTableColumnOrder;
-
-        newColumnOrder = generateLocalNewColumnOrderFromStickyValue(
-          localTableColumnOrder.columnOrder,
-          columnName,
-          sticky,
-          leftOrder,
-          rightOrder,
-        );
-        const updatedOrders = updateAndSyncTableLocalColumnOrders(
-          columnName,
-          leftOrder,
-          rightOrder,
-          sticky,
-        );
-
-        this.persistColumnOrder(
-          newColumnOrder,
-          updatedOrders.leftOrder,
-          updatedOrders.rightOrder,
-        );
-
-        super.batchUpdateWidgetProperty(
-          {
-            modify: {
-              [`primaryColumns.${columnName}.sticky`]: sticky,
-              columnOrder: newColumnOrder,
-            },
-          },
-          true,
-        );
-      }
-    }
-  };
-
-  handleReorderColumn = (columnOrder: string[]) => {
-    columnOrder = columnOrder.map((alias) => this.getColumnIdByAlias(alias));
-
-    if (
-      this.props.canFreezeColumn &&
-      this.props.renderMode === RenderModes.PAGE
-    ) {
-      const localTableColumnOrder = getColumnOrderByWidgetIdFromLS(
-        this.props.widgetId,
-      );
-
-      if (localTableColumnOrder) {
-        const { leftOrder, rightOrder } = localTableColumnOrder;
-
-        this.persistColumnOrder(columnOrder, leftOrder, rightOrder);
-      } else {
-        this.persistColumnOrder(columnOrder, [], []);
-      }
-    }
-
-    super.updateWidgetProperty("columnOrder", columnOrder);
-  };
-
-  handleColumnSorting = (columnAccessor: string, isAsc: boolean) => {
-    const columnId = this.getColumnIdByAlias(columnAccessor);
-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-    this.pushResetSelectedRowIndexUpdates(false);
-
-    let sortOrderProps;
-
-    if (columnId) {
-      sortOrderProps = {
-        column: columnId,
-        order: isAsc ? SortOrderTypes.asc : SortOrderTypes.desc,
-      };
-    } else {
-      sortOrderProps = {
-        column: "",
-        order: null,
-      };
-    }
-
-    pushBatchMetaUpdates("sortOrder", sortOrderProps, {
-      triggerPropertyName: "onSort",
-      dynamicString: this.props.onSort,
-      event: {
-        type: EventType.ON_SORT,
-      },
-    });
-    commitBatchMetaUpdates();
-  };
-
-  handleResizeColumn = (columnWidthMap: { [key: string]: number }) => {
-    if (this.props.renderMode === RenderModes.CANVAS) {
-      super.updateWidgetProperty("columnWidthMap", columnWidthMap);
-    } else {
-      //single action no need to batch
-      this.props.updateWidgetMetaProperty("columnWidthMap", columnWidthMap);
-    }
-  };
-
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  handleSearchTable = (searchKey: any) => {
-    const {
-      commitBatchMetaUpdates,
-      multiRowSelection,
-      onSearchTextChanged,
-      pushBatchMetaUpdates,
-    } = this.props;
-
-    /*
-     * Clear rowSelection to avoid selecting filtered rows
-     * based on stale selection indices
-     */
-    if (multiRowSelection) {
-      pushBatchMetaUpdates("selectedRowIndices", []);
-    } else {
-      pushBatchMetaUpdates("selectedRowIndex", -1);
-    }
-
-    pushBatchMetaUpdates("pageNo", 1);
-    this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);
-
-    pushBatchMetaUpdates("searchText", searchKey, {
-      triggerPropertyName: "onSearchTextChanged",
-      dynamicString: onSearchTextChanged,
-      event: {
-        type: EventType.ON_SEARCH,
-      },
-    });
-
-    commitBatchMetaUpdates();
-  };
-
-  /**
-   * This function just pushes the meta update
-   */
-  pushOnColumnEvent = ({
-    action,
-    additionalData = {},
-    eventType,
-    onComplete = noop,
-    row,
-    rowIndex,
-    triggerPropertyName,
-  }: OnColumnEventArgs) => {
-    const { filteredTableData = [], pushBatchMetaUpdates } = this.props;
-
-    const currentRow = row || filteredTableData[rowIndex];
-
-    pushBatchMetaUpdates(
-      "triggeredRowIndex",
-      currentRow?.[ORIGINAL_INDEX_KEY],
-      {
-        triggerPropertyName: triggerPropertyName,
-        dynamicString: action,
-        event: {
-          type: eventType,
-          callback: onComplete,
-        },
-        globalContext: { currentRow, ...additionalData },
-      },
-    );
-  };
-  /*
-   * Function to handle customColumn button type click interactions
-   */
-  onColumnEvent = ({
-    action,
-    additionalData = {},
-    eventType,
-    onComplete = noop,
-    row,
-    rowIndex,
-    triggerPropertyName,
-  }: OnColumnEventArgs) => {
-    if (action) {
-      const { commitBatchMetaUpdates } = this.props;
-
-      this.pushOnColumnEvent({
-        rowIndex,
-        action,
-        onComplete,
-        triggerPropertyName,
-        eventType,
-        row,
-        additionalData,
-      });
-      commitBatchMetaUpdates();
-    } else {
-      onComplete();
-    }
-  };
-
-  onDropdownOptionSelect = (action: string) => {
-    super.executeAction({
-      dynamicString: action,
-      event: {
-        type: EventType.ON_OPTION_CHANGE,
-      },
-    });
-  };
-
-  handleAllRowSelect = (pageData: Record<string, unknown>[]) => {
-    if (this.props.multiRowSelection) {
-      const selectedRowIndices = pageData.map(
-        (row: Record<string, unknown>) => row.index,
-      );
-
-      //single action no need to batch
-      this.props.updateWidgetMetaProperty(
-        "selectedRowIndices",
-        selectedRowIndices,
-      );
-    }
-  };
-
-  handleRowClick = (row: Record<string, unknown>, selectedIndex: number) => {
-    const { multiRowSelection, selectedRowIndex, selectedRowIndices } =
-      this.props;
-    // no need to batch actions here because it a time only one will execute
-
-    if (multiRowSelection) {
-      let indices: Array<number>;
-
-      if (_.isArray(selectedRowIndices)) {
-        indices = [...selectedRowIndices];
-      } else {
-        indices = [];
-      }
-
-      /*
-       * Deselect if the index is already present
-       */
-      if (indices.includes(selectedIndex)) {
-        indices.splice(indices.indexOf(selectedIndex), 1);
-        this.props.updateWidgetMetaProperty("selectedRowIndices", indices);
-      } else {
-        /*
-         * select if the index is not present already
-         */
-        indices.push(selectedIndex);
-
-        this.props.updateWidgetMetaProperty("selectedRowIndices", indices, {
-          triggerPropertyName: "onRowSelected",
-          dynamicString: this.props.onRowSelected,
-          event: {
-            type: EventType.ON_ROW_SELECTED,
-          },
-        });
-      }
-    } else {
-      let index;
-
-      if (isNumber(selectedRowIndex)) {
-        index = selectedRowIndex;
-      } else {
-        index = -1;
-      }
-
-      if (index !== selectedIndex) {
-        this.props.updateWidgetMetaProperty("selectedRowIndex", selectedIndex, {
-          triggerPropertyName: "onRowSelected",
-          dynamicString: this.props.onRowSelected,
-          event: {
-            type: EventType.ON_ROW_SELECTED,
-          },
-        });
-      } else {
-        this.props.updateWidgetMetaProperty("selectedRowIndex", -1);
-      }
-    }
-  };
-
-  updatePageNumber = (pageNo: number, event?: EventType) => {
-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-    const paginationDirection =
-      event == EventType.ON_NEXT_PAGE
-        ? PaginationDirection.NEXT_PAGE
-        : PaginationDirection.PREVIOUS_PAGE;
-
-    this.updatePaginationDirectionFlags(paginationDirection);
-
-    if (event) {
-      pushBatchMetaUpdates("pageNo", pageNo, {
-        triggerPropertyName: "onPageChange",
-        dynamicString: this.props.onPageChange,
-        event: {
-          type: event,
-        },
-      });
-    } else {
-      pushBatchMetaUpdates("pageNo", pageNo);
-    }
-
-    if (this.props.onPageChange) {
-      this.pushResetSelectedRowIndexUpdates();
-    }
-
-    commitBatchMetaUpdates();
-  };
-
-  updatePaginationDirectionFlags = (direction?: PaginationDirection) => {
-    const { pushBatchMetaUpdates } = this.props;
-
-    let previousButtonFlag = false;
-    let nextButtonFlag = false;
-
-    if (direction) {
-      switch (direction) {
-        case PaginationDirection.INITIAL: {
-          previousButtonFlag = false;
-          nextButtonFlag = false;
-          break;
-        }
-        case PaginationDirection.NEXT_PAGE: {
-          nextButtonFlag = true;
-          break;
-        }
-        case PaginationDirection.PREVIOUS_PAGE: {
-          previousButtonFlag = true;
-          break;
-        }
-      }
-    }
-
-    pushBatchMetaUpdates("previousPageVisited", previousButtonFlag);
-    pushBatchMetaUpdates("nextPageVisited", nextButtonFlag);
-  };
-
-  handleNextPageClick = () => {
-    const pageNo = (this.props.pageNo || 1) + 1;
-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-    this.updatePaginationDirectionFlags(PaginationDirection.NEXT_PAGE);
-
-    pushBatchMetaUpdates("pageNo", pageNo, {
-      triggerPropertyName: "onPageChange",
-      dynamicString: this.props.onPageChange,
-      event: {
-        type: EventType.ON_NEXT_PAGE,
-      },
-    });
-
-    if (this.props.onPageChange) {
-      this.pushResetSelectedRowIndexUpdates();
-    }
-
-    commitBatchMetaUpdates();
-  };
-
-  pushResetSelectedRowIndexUpdates = (skipDefault?: boolean) => {
-    const { pushBatchMetaUpdates } = this.props;
-
-    const {
-      defaultSelectedRowIndex,
-      defaultSelectedRowIndices,
-      multiRowSelection,
-    } = this.props;
-
-    if (multiRowSelection) {
-      pushBatchMetaUpdates(
-        "selectedRowIndices",
-        skipDefault ? [] : defaultSelectedRowIndices,
-      );
-    } else {
-      pushBatchMetaUpdates(
-        "selectedRowIndex",
-        skipDefault ? -1 : defaultSelectedRowIndex,
-      );
-    }
-  };
-
-  unSelectAllRow = () => {
-    this.props.updateWidgetMetaProperty("selectedRowIndices", []);
-  };
-
-  handlePrevPageClick = () => {
-    const pageNo = (this.props.pageNo || 1) - 1;
-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-    if (pageNo >= 1) {
-      this.updatePaginationDirectionFlags(PaginationDirection.PREVIOUS_PAGE);
-      pushBatchMetaUpdates("pageNo", pageNo, {
-        triggerPropertyName: "onPageChange",
-        dynamicString: this.props.onPageChange,
-        event: {
-          type: EventType.ON_PREV_PAGE,
-        },
-      });
-
-      if (this.props.onPageChange) {
-        this.pushResetSelectedRowIndexUpdates();
-      }
-    }
-
-    commitBatchMetaUpdates();
-  };
-
-  getColumnIdByAlias(alias: string) {
-    const { primaryColumns } = this.props;
-
-    if (primaryColumns) {
-      const column = Object.values(primaryColumns).find(
-        (column) => column.alias === alias,
-      );
-
-      if (column) {
-        return column.id;
-      }
-    }
-
-    return alias;
-  }
-
-  getColumnByOriginalId(originalId: string) {
-    return Object.values(this.props.primaryColumns).find((column) => {
-      return column.originalId === originalId;
-    });
-  }
-
-  pushTransientTableDataActionsUpdates = (data: TransientDataPayload) => {
-    const { __originalIndex__, ...transientData } = data;
-    const { pushBatchMetaUpdates } = this.props;
-
-    pushBatchMetaUpdates("transientTableData", {
-      ...this.props.transientTableData,
-      [__originalIndex__]: {
-        ...this.props.transientTableData[__originalIndex__],
-        ...transientData,
-      },
-    });
-
-    pushBatchMetaUpdates("updatedRowIndex", __originalIndex__);
-  };
-
-  removeRowFromTransientTableData = (index: number) => {
-    const newTransientTableData = klonaRegularWithTelemetry(
-      this.props.transientTableData,
-      "TableWidgetV2.removeRowFromTransientTableData",
-    );
-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-    if (newTransientTableData) {
-      delete newTransientTableData[index];
-
-      pushBatchMetaUpdates("transientTableData", newTransientTableData);
-    }
-
-    pushBatchMetaUpdates("updatedRowIndex", -1);
-    commitBatchMetaUpdates();
-  };
-
-  getRowOriginalIndex = (index: number) => {
-    const { filteredTableData } = this.props;
-
-    if (filteredTableData) {
-      const row = filteredTableData[index];
-
-      if (row) {
-        return row[ORIGINAL_INDEX_KEY];
-      }
-    }
-
-    return -1;
-  };
-
-  onBulkEditSave = () => {
-    this.props.updateWidgetMetaProperty(
-      "transientTableData",
-      this.props.transientTableData,
-      {
-        triggerPropertyName: "onBulkSave",
-        dynamicString: this.props.onBulkSave,
-        event: {
-          type: EventType.ON_BULK_SAVE,
-        },
-      },
-    );
-  };
-
-  onBulkEditDiscard = () => {
-    this.props.updateWidgetMetaProperty(
-      "transientTableData",
-      {},
-      {
-        triggerPropertyName: "onBulkDiscard",
-        dynamicString: this.props.onBulkDiscard,
-        event: {
-          type: EventType.ON_BULK_DISCARD,
-        },
-      },
-    );
-  };
-
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  renderCell = (props: any) => {
-    const column =
-      this.getColumnByOriginalId(
-        props.cell.column.columnProperties.originalId,
-      ) || props.cell.column.columnProperties;
-    const rowIndex = props.cell.row.index;
-
-    /*
-     * We don't need to render cells that don't display data (button, iconButton, etc)
-     */
-    if (
-      this.props.isAddRowInProgress &&
-      rowIndex === 0 &&
-      ActionColumnTypes.includes(column.columnType)
-    ) {
-      return <CellWrapper />;
-    }
-
-    const isHidden = !column.isVisible;
-    const {
-      compactMode = CompactModeTypes.DEFAULT,
-      filteredTableData = [],
-      multiRowSelection,
-      selectedRowIndex,
-      selectedRowIndices,
-    } = this.props;
-    let row;
-    let originalIndex: number;
-
-    /*
-     * In add new row flow, a temporary row is injected at the top of the tableData, which doesn't
-     * have original row index value. so we are using -1 as the value
-     */
-    if (this.props.isAddRowInProgress) {
-      row = filteredTableData[rowIndex - 1];
-      originalIndex =
-        rowIndex === 0 ? -1 : row?.[ORIGINAL_INDEX_KEY] ?? rowIndex;
-    } else {
-      row = filteredTableData[rowIndex];
-      originalIndex = row ? row[ORIGINAL_INDEX_KEY] ?? rowIndex : rowIndex;
-    }
-
-    const isNewRow = this.props.isAddRowInProgress && rowIndex === 0;
-
-    /*
-     * cellProperties order or size does not change when filter/sorting/grouping is applied
-     * on the data thus original index is needed to identify the column's cell property.
-     */
-    const cellProperties = getCellProperties(column, originalIndex, isNewRow);
-    let isSelected = false;
-
-    if (this.props.transientTableData) {
-      cellProperties.hasUnsavedChanges =
-        this.props.transientTableData.hasOwnProperty(originalIndex) &&
-        this.props.transientTableData[originalIndex].hasOwnProperty(
-          props.cell.column.columnProperties.alias,
-        );
-    }
-
-    if (multiRowSelection) {
-      isSelected =
-        _.isArray(selectedRowIndices) && selectedRowIndices.includes(rowIndex);
-    } else {
-      isSelected = selectedRowIndex === rowIndex;
-    }
-
-    const isColumnEditable =
-      column.isEditable &&
-      isColumnTypeEditable(column.columnType, this.props.infiniteScrollEnabled);
-    const alias = props.cell.column.columnProperties.alias;
-
-    const isCellEditable = isColumnEditable && cellProperties.isCellEditable;
-
-    const isCellEditMode =
-      (props.cell.column.alias === this.props.editableCell?.column &&
-        rowIndex === this.props.editableCell?.index) ||
-      (isNewRow && isColumnEditable);
-
-    const shouldDisableEdit =
-      (this.props.inlineEditingSaveOption ===
-        InlineEditingSaveOptions.ROW_LEVEL &&
-        this.props.updatedRowIndices.length &&
-        this.props.updatedRowIndices.indexOf(originalIndex) === -1) ||
-      (this.hasInvalidColumnCell() && !isNewRow);
-
-    const disabledEditMessage = `Save or discard the ${
-      this.props.isAddRowInProgress ? "newly added" : "unsaved"
-    } row to start editing here`;
-
-    if (this.props.isAddRowInProgress) {
-      cellProperties.isCellDisabled = rowIndex !== 0;
-
-      if (rowIndex === 0) {
-        cellProperties.cellBackground = "";
-      }
-    }
-
-    switch (column.columnType) {
-      case ColumnTypes.BUTTON:
-        return (
-          <ButtonCell
-            allowCellWrapping={cellProperties.allowCellWrapping}
-            cellBackground={cellProperties.cellBackground}
-            columnActions={[
-              {
-                backgroundColor:
-                  cellProperties.buttonColor || this.props.accentColor,
-                eventType: EventType.ON_CLICK,
-                id: column.id,
-                isVisible: true,
-                label: cellProperties.buttonLabel || DEFAULT_BUTTON_LABEL,
-                dynamicTrigger: column.onClick || "",
-                variant: cellProperties.buttonVariant,
-                borderRadius:
-                  cellProperties.borderRadius || this.props.borderRadius,
-                boxShadow: cellProperties.boxShadow,
-              },
-            ]}
-            compactMode={compactMode}
-            fontStyle={cellProperties.fontStyle}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isDisabled={!!cellProperties.isDisabled}
-            isHidden={isHidden}
-            isSelected={isSelected}
-            onCommandClick={(action: string, onComplete: () => void) =>
-              this.onColumnEvent({
-                rowIndex,
-                action,
-                onComplete,
-                triggerPropertyName: "onClick",
-                eventType: EventType.ON_CLICK,
-              })
-            }
-            textColor={cellProperties.textColor}
-            textSize={cellProperties.textSize}
-            verticalAlignment={cellProperties.verticalAlignment}
-          />
-        );
-
-      case ColumnTypes.EDIT_ACTIONS:
-        return (
-          <EditActionCell
-            allowCellWrapping={cellProperties.allowCellWrapping}
-            cellBackground={cellProperties.cellBackground}
-            columnActions={[
-              {
-                id: EditableCellActions.SAVE,
-                label: cellProperties.saveActionLabel,
-                dynamicTrigger: column.onSave || "",
-                eventType: EventType.ON_ROW_SAVE,
-                iconName: cellProperties.saveActionIconName,
-                variant: cellProperties.saveButtonVariant,
-                backgroundColor:
-                  cellProperties.saveButtonColor || this.props.accentColor,
-                iconAlign: cellProperties.saveIconAlign,
-                borderRadius:
-                  cellProperties.saveBorderRadius || this.props.borderRadius,
-                isVisible: cellProperties.isSaveVisible,
-                isDisabled:
-                  cellProperties.isSaveDisabled || this.hasInvalidColumnCell(),
-                boxShadow: cellProperties.boxShadow,
-              },
-              {
-                id: EditableCellActions.DISCARD,
-                label: cellProperties.discardActionLabel,
-                dynamicTrigger: column.onDiscard || "",
-                eventType: EventType.ON_ROW_DISCARD,
-                iconName: cellProperties.discardActionIconName,
-                variant: cellProperties.discardButtonVariant,
-                backgroundColor:
-                  cellProperties.discardButtonColor || this.props.accentColor,
-                iconAlign: cellProperties.discardIconAlign,
-                borderRadius:
-                  cellProperties.discardBorderRadius || this.props.borderRadius,
-                isVisible: cellProperties.isDiscardVisible,
-                isDisabled:
-                  cellProperties.isDiscardDisabled ||
-                  this.hasInvalidColumnCell(),
-                boxShadow: cellProperties.boxShadow,
-              },
-            ]}
-            compactMode={compactMode}
-            fontStyle={cellProperties.fontStyle}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellVisible={cellProperties.isCellVisible}
-            isHidden={isHidden}
-            isSelected={isSelected}
-            onCommandClick={(
-              action: string,
-              onComplete: () => void,
-              eventType: EventType,
-            ) =>
-              this.onColumnEvent({
-                rowIndex,
-                action,
-                onComplete,
-                triggerPropertyName: "onClick",
-                eventType: eventType,
-              })
-            }
-            onDiscard={() =>
-              this.removeRowFromTransientTableData(originalIndex)
-            }
-            textColor={cellProperties.textColor}
-            textSize={cellProperties.textSize}
-            verticalAlignment={cellProperties.verticalAlignment}
-          />
-        );
-
-      case ColumnTypes.SELECT:
-        return (
-          <SelectCell
-            accentColor={this.props.accentColor}
-            alias={props.cell.column.columnProperties.alias}
-            allowCellWrapping={cellProperties.allowCellWrapping}
-            autoOpen={!this.props.isAddRowInProgress}
-            borderRadius={cellProperties.borderRadius}
-            cellBackground={cellProperties.cellBackground}
-            columnType={column.columnType}
-            compactMode={compactMode}
-            disabledEditIcon={
-              shouldDisableEdit || this.props.isAddRowInProgress
-            }
-            disabledEditIconMessage={disabledEditMessage}
-            filterText={
-              this.props.selectColumnFilterText?.[
-                this.props.editableCell?.column || column.alias
-              ]
-            }
-            fontStyle={cellProperties.fontStyle}
-            hasUnsavedChanges={cellProperties.hasUnsavedChanges}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellEditMode={isCellEditMode}
-            isCellEditable={isCellEditable}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isEditable={isColumnEditable}
-            isEditableCellValid={this.isColumnCellValid(alias)}
-            isFilterable={cellProperties.isFilterable}
-            isHidden={isHidden}
-            isNewRow={isNewRow}
-            key={props.key}
-            onFilterChange={this.onSelectFilterChange}
-            onFilterChangeActionString={column.onFilterUpdate}
-            onItemSelect={this.onOptionSelect}
-            onOptionSelectActionString={column.onOptionChange}
-            options={cellProperties.selectOptions}
-            placeholderText={cellProperties.placeholderText}
-            resetFilterTextOnClose={cellProperties.resetFilterTextOnClose}
-            rowIndex={rowIndex}
-            serverSideFiltering={cellProperties.serverSideFiltering}
-            tableWidth={this.props.componentWidth}
-            textColor={cellProperties.textColor}
-            textSize={cellProperties.textSize}
-            toggleCellEditMode={this.toggleCellEditMode}
-            value={props.cell.value}
-            verticalAlignment={cellProperties.verticalAlignment}
-            width={
-              this.props.columnWidthMap?.[column.id] || DEFAULT_COLUMN_WIDTH
-            }
-          />
-        );
-
-      case ColumnTypes.IMAGE:
-        const onClick = column.onClick
-          ? () =>
-              this.onColumnEvent({
-                rowIndex,
-                action: column.onClick,
-                triggerPropertyName: "onClick",
-                eventType: EventType.ON_CLICK,
-              })
-          : noop;
-
-        return (
-          <ImageCell
-            allowCellWrapping={cellProperties.allowCellWrapping}
-            cellBackground={cellProperties.cellBackground}
-            compactMode={compactMode}
-            fontStyle={cellProperties.fontStyle}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            imageSize={cellProperties.imageSize}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isHidden={isHidden}
-            isSelected={isSelected}
-            onClick={onClick}
-            textColor={cellProperties.textColor}
-            textSize={cellProperties.textSize}
-            value={props.cell.value}
-            verticalAlignment={cellProperties.verticalAlignment}
-          />
-        );
-
-      case ColumnTypes.MENU_BUTTON:
-        const getVisibleItems = (rowIndex: number) => {
-          const { configureMenuItems, menuItems, menuItemsSource, sourceData } =
-            cellProperties;
-
-          if (menuItemsSource === MenuItemsSource.STATIC && menuItems) {
-            const visibleItems = Object.values(menuItems)?.filter((item) =>
-              getBooleanPropertyValue(item.isVisible, rowIndex),
-            );
-
-            return visibleItems?.length
-              ? orderBy(visibleItems, ["index"], ["asc"])
-              : [];
-          } else if (
-            menuItemsSource === MenuItemsSource.DYNAMIC &&
-            isArray(sourceData) &&
-            sourceData?.length &&
-            configureMenuItems?.config
-          ) {
-            const { config } = configureMenuItems;
-
-            const getValue = (
-              propertyName: keyof MenuItem,
-              index: number,
-              rowIndex: number,
-            ) => {
-              const value = config[propertyName];
-
-              if (isArray(value) && isArray(value[rowIndex])) {
-                return value[rowIndex][index];
-              } else if (isArray(value)) {
-                return value[index];
-              }
-
-              return value ?? null;
-            };
-
-            const visibleItems = sourceData
-              .map((item, index) => ({
-                ...item,
-                id: index.toString(),
-                isVisible: getValue("isVisible", index, rowIndex),
-                isDisabled: getValue("isDisabled", index, rowIndex),
-                index: index,
-                widgetId: "",
-                label: getValue("label", index, rowIndex),
-                onClick: config?.onClick,
-                textColor: getValue("textColor", index, rowIndex),
-                backgroundColor: getValue("backgroundColor", index, rowIndex),
-                iconAlign: getValue("iconAlign", index, rowIndex),
-                iconColor: getValue("iconColor", index, rowIndex),
-                iconName: getValue("iconName", index, rowIndex),
-              }))
-              .filter((item) => item.isVisible === true);
-
-            return visibleItems;
-          }
-
-          return [];
-        };
-
-        return (
-          <MenuButtonCell
-            allowCellWrapping={cellProperties.allowCellWrapping}
-            borderRadius={
-              cellProperties.borderRadius || this.props.borderRadius
-            }
-            boxShadow={cellProperties.boxShadow}
-            cellBackground={cellProperties.cellBackground}
-            compactMode={compactMode}
-            configureMenuItems={cellProperties.configureMenuItems}
-            fontStyle={cellProperties.fontStyle}
-            getVisibleItems={getVisibleItems}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            iconAlign={cellProperties.iconAlign}
-            iconName={cellProperties.menuButtoniconName || undefined}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isCompact={!!cellProperties.isCompact}
-            isDisabled={!!cellProperties.isDisabled}
-            isHidden={isHidden}
-            isSelected={isSelected}
-            label={cellProperties.menuButtonLabel ?? DEFAULT_MENU_BUTTON_LABEL}
-            menuColor={
-              cellProperties.menuColor || this.props.accentColor || Colors.GREEN
-            }
-            menuItems={cellProperties.menuItems}
-            menuItemsSource={cellProperties.menuItemsSource}
-            menuVariant={cellProperties.menuVariant ?? DEFAULT_MENU_VARIANT}
-            onCommandClick={(
-              action: string,
-              index?: number,
-              onComplete?: () => void,
-            ) => {
-              const additionalData: Record<
-                string,
-                string | number | Record<string, unknown>
-              > = {};
-
-              if (cellProperties?.sourceData && _.isNumber(index)) {
-                additionalData.currentItem = cellProperties.sourceData[index];
-                additionalData.currentIndex = index;
-              }
-
-              return this.onColumnEvent({
-                rowIndex,
-                action,
-                onComplete,
-                triggerPropertyName: "onClick",
-                eventType: EventType.ON_CLICK,
-                additionalData,
-              });
-            }}
-            rowIndex={originalIndex}
-            sourceData={cellProperties.sourceData}
-            textColor={cellProperties.textColor}
-            textSize={cellProperties.textSize}
-            verticalAlignment={cellProperties.verticalAlignment}
-          />
-        );
-
-      case ColumnTypes.ICON_BUTTON:
-        return (
-          <IconButtonCell
-            allowCellWrapping={cellProperties.allowCellWrapping}
-            borderRadius={
-              cellProperties.borderRadius || this.props.borderRadius
-            }
-            boxShadow={cellProperties.boxShadow || "NONE"}
-            buttonColor={
-              cellProperties.buttonColor ||
-              this.props.accentColor ||
-              Colors.GREEN
-            }
-            buttonVariant={cellProperties.buttonVariant || "PRIMARY"}
-            cellBackground={cellProperties.cellBackground}
-            columnActions={[
-              {
-                id: column.id,
-                dynamicTrigger: column.onClick || "",
-              },
-            ]}
-            compactMode={compactMode}
-            disabled={!!cellProperties.isDisabled}
-            fontStyle={cellProperties.fontStyle}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            iconName={(cellProperties.iconName || IconNames.ADD) as IconName}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isHidden={isHidden}
-            isSelected={isSelected}
-            onCommandClick={(action: string, onComplete: () => void) =>
-              this.onColumnEvent({
-                rowIndex,
-                action,
-                onComplete,
-                triggerPropertyName: "onClick",
-                eventType: EventType.ON_CLICK,
-              })
-            }
-            textColor={cellProperties.textColor}
-            textSize={cellProperties.textSize}
-            verticalAlignment={cellProperties.verticalAlignment}
-          />
-        );
-
-      case ColumnTypes.VIDEO:
-        return (
-          <VideoCell
-            allowCellWrapping={cellProperties.allowCellWrapping}
-            cellBackground={cellProperties.cellBackground}
-            compactMode={compactMode}
-            fontStyle={cellProperties.fontStyle}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isHidden={isHidden}
-            textColor={cellProperties.textColor}
-            textSize={cellProperties.textSize}
-            value={props.cell.value}
-            verticalAlignment={cellProperties.verticalAlignment}
-          />
-        );
-
-      case ColumnTypes.CHECKBOX:
-        return (
-          <CheckboxCell
-            accentColor={this.props.accentColor}
-            borderRadius={
-              cellProperties.borderRadius || this.props.borderRadius
-            }
-            cellBackground={cellProperties.cellBackground}
-            compactMode={compactMode}
-            disabledCheckbox={
-              shouldDisableEdit || (this.props.isAddRowInProgress && !isNewRow)
-            }
-            disabledCheckboxMessage={disabledEditMessage}
-            hasUnSavedChanges={cellProperties.hasUnsavedChanges}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellEditable={isCellEditable}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isHidden={isHidden}
-            onChange={() =>
-              this.onCheckChange(
-                column,
-                props.cell.row.values,
-                !props.cell.value,
-                alias,
-                originalIndex,
-                rowIndex,
-              )
-            }
-            value={props.cell.value}
-            verticalAlignment={cellProperties.verticalAlignment}
-          />
-        );
-
-      case ColumnTypes.SWITCH:
-        return (
-          <SwitchCell
-            accentColor={this.props.accentColor}
-            cellBackground={cellProperties.cellBackground}
-            compactMode={compactMode}
-            disabledSwitch={
-              shouldDisableEdit || (this.props.isAddRowInProgress && !isNewRow)
-            }
-            disabledSwitchMessage={disabledEditMessage}
-            hasUnSavedChanges={cellProperties.hasUnsavedChanges}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellEditable={isCellEditable}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isHidden={isHidden}
-            onChange={() =>
-              this.onCheckChange(
-                column,
-                props.cell.row.values,
-                !props.cell.value,
-                alias,
-                originalIndex,
-                rowIndex,
-              )
-            }
-            value={props.cell.value}
-            verticalAlignment={cellProperties.verticalAlignment}
-          />
-        );
-
-      case ColumnTypes.DATE:
-        return (
-          <DateCell
-            accentColor={this.props.accentColor}
-            alias={props.cell.column.columnProperties.alias}
-            borderRadius={this.props.borderRadius}
-            cellBackground={cellProperties.cellBackground}
-            closeOnSelection
-            columnType={column.columnType}
-            compactMode={compactMode}
-            disabledEditIcon={
-              shouldDisableEdit || this.props.isAddRowInProgress
-            }
-            disabledEditIconMessage={disabledEditMessage}
-            firstDayOfWeek={props.cell.column.columnProperties.firstDayOfWeek}
-            fontStyle={cellProperties.fontStyle}
-            hasUnsavedChanges={cellProperties.hasUnsavedChanges}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            inputFormat={cellProperties.inputFormat}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellEditMode={isCellEditMode}
-            isCellEditable={isCellEditable}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isEditableCellValid={this.isColumnCellValid(alias)}
-            isHidden={isHidden}
-            isNewRow={isNewRow}
-            isRequired={
-              props.cell.column.columnProperties.validation
-                .isColumnEditableCellRequired
-            }
-            maxDate={props.cell.column.columnProperties.validation.maxDate}
-            minDate={props.cell.column.columnProperties.validation.minDate}
-            onCellTextChange={this.onCellTextChange}
-            onDateSave={this.onDateSave}
-            onDateSelectedString={
-              props.cell.column.columnProperties.onDateSelected
-            }
-            outputFormat={cellProperties.outputFormat}
-            rowIndex={rowIndex}
-            shortcuts={cellProperties.shortcuts}
-            tableWidth={this.props.componentWidth}
-            textColor={cellProperties.textColor}
-            textSize={cellProperties.textSize}
-            timePrecision={cellProperties.timePrecision || TimePrecision.NONE}
-            toggleCellEditMode={this.toggleCellEditMode}
-            updateNewRowValues={this.updateNewRowValues}
-            validationErrorMessage="This field is required"
-            value={props.cell.value}
-            verticalAlignment={cellProperties.verticalAlignment}
-            widgetId={this.props.widgetId}
-          />
-        );
-
-      case ColumnTypes.HTML:
-        return (
-          <HTMLCell
-            allowCellWrapping={cellProperties.allowCellWrapping}
-            cellBackground={cellProperties.cellBackground}
-            compactMode={compactMode}
-            fontStyle={cellProperties.fontStyle}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isHidden={isHidden}
-            renderMode={this.props.renderMode}
-            textColor={cellProperties.textColor}
-            textSize={cellProperties.textSize}
-            value={props.cell.value}
-            verticalAlignment={cellProperties.verticalAlignment}
-          />
-        );
-
-      default:
-        let validationErrorMessage;
-
-        if (isCellEditMode) {
-          validationErrorMessage =
-            column.validation.isColumnEditableCellRequired &&
-            (isNil(props.cell.value) || props.cell.value === "")
-              ? "This field is required"
-              : column.validation?.errorMessage;
-        }
-
-        return (
-          <PlainTextCell
-            accentColor={this.props.accentColor}
-            alias={props.cell.column.columnProperties.alias}
-            allowCellWrapping={cellProperties.allowCellWrapping}
-            cellBackground={cellProperties.cellBackground}
-            columnType={column.columnType}
-            compactMode={compactMode}
-            currencyCode={cellProperties.currencyCode}
-            decimals={cellProperties.decimals}
-            disabledEditIcon={
-              shouldDisableEdit || this.props.isAddRowInProgress
-            }
-            disabledEditIconMessage={disabledEditMessage}
-            displayText={cellProperties.displayText}
-            fontStyle={cellProperties.fontStyle}
-            hasUnsavedChanges={cellProperties.hasUnsavedChanges}
-            horizontalAlignment={cellProperties.horizontalAlignment}
-            isCellDisabled={cellProperties.isCellDisabled}
-            isCellEditMode={isCellEditMode}
-            isCellEditable={isCellEditable}
-            isCellVisible={cellProperties.isCellVisible ?? true}
-            isEditableCellValid={this.isColumnCellValid(alias)}
-            isHidden={isHidden}
-            isNewRow={isNewRow}
-            notation={cellProperties.notation}
-            onCellTextChange={this.onCellTextChange}
-            onSubmitString={props.cell.column.columnProperties.onSubmit}
-            rowIndex={rowIndex}
-            tableWidth={this.props.componentWidth}
-            textColor={cellProperties.textColor}
-            textSize={cellProperties.textSize}
-            thousandSeparator={cellProperties.thousandSeparator}
-            toggleCellEditMode={this.toggleCellEditMode}
-            validationErrorMessage={validationErrorMessage}
-            value={props.cell.value}
-            verticalAlignment={cellProperties.verticalAlignment}
-            widgetId={this.props.widgetId}
-          />
-        );
-    }
-  };
-
-  onCellTextChange = (
-    value: EditableCell["value"],
-    inputValue: string,
-    alias: string,
-  ) => {
-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-    if (this.props.isAddRowInProgress) {
-      this.updateNewRowValues(alias, inputValue, value);
-    } else {
-      pushBatchMetaUpdates("editableCell", {
-        ...this.props.editableCell,
-        value: value,
-        inputValue,
-      });
-
-      if (this.props.editableCell?.column) {
-        pushBatchMetaUpdates("columnEditableCellValue", {
-          ...this.props.columnEditableCellValue,
-          [this.props.editableCell?.column]: value,
-        });
-      }
-
-      commitBatchMetaUpdates();
-    }
-  };
-
-  toggleCellEditMode = (
-    enable: boolean,
-    rowIndex: number,
-    alias: string,
-    value: string | number,
-    onSubmit?: string,
-    action?: EditableCellActions,
-  ) => {
-    if (this.props.isAddRowInProgress) {
-      return;
-    }
-
-    if (enable) {
-      if (this.inlineEditTimer) {
-        clearTimeout(this.inlineEditTimer);
-      }
-
-      const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-      pushBatchMetaUpdates("editableCell", {
-        column: alias,
-        index: rowIndex,
-        value: value,
-        // To revert back to previous on discard
-        initialValue: value,
-        inputValue: value,
-        __originalIndex__: this.getRowOriginalIndex(rowIndex),
-      });
-      pushBatchMetaUpdates("columnEditableCellValue", {
-        ...this.props.columnEditableCellValue,
-        [alias]: value,
-      });
-
-      /*
-       * We need to clear the selectedRowIndex and selectedRowIndices
-       * if the rows are sorted, to avoid selectedRow jumping to
-       * different page.
-       */
-      if (this.props.sortOrder.column) {
-        if (this.props.multiRowSelection) {
-          pushBatchMetaUpdates("selectedRowIndices", []);
-        } else {
-          pushBatchMetaUpdates("selectedRowIndex", -1);
-        }
-      }
-
-      commitBatchMetaUpdates();
-    } else {
-      if (
-        this.isColumnCellValid(alias) &&
-        action === EditableCellActions.SAVE &&
-        value !== this.props.editableCell?.initialValue
-      ) {
-        const { commitBatchMetaUpdates } = this.props;
-
-        this.pushTransientTableDataActionsUpdates({
-          [ORIGINAL_INDEX_KEY]: this.getRowOriginalIndex(rowIndex),
-          [alias]: this.props.editableCell?.value,
-        });
-
-        if (onSubmit && this.props.editableCell?.column) {
-          //since onSubmit is truthy that makes action truthy as well, so we can push this event
-          this.pushOnColumnEvent({
-            rowIndex: rowIndex,
-            action: onSubmit,
-            triggerPropertyName: "onSubmit",
-            eventType: EventType.ON_SUBMIT,
-            row: {
-              ...this.props.filteredTableData[rowIndex],
-              [this.props.editableCell.column]: this.props.editableCell.value,
-            },
-          });
-        }
-
-        commitBatchMetaUpdates();
-
-        this.clearEditableCell();
-      } else if (
-        action === EditableCellActions.DISCARD ||
-        value === this.props.editableCell?.initialValue
-      ) {
-        this.clearEditableCell();
-      }
-    }
-  };
-
-  onDateSave = (
-    rowIndex: number,
-    alias: string,
-    value: string,
-    onSubmit?: string,
-  ) => {
-    const { commitBatchMetaUpdates } = this.props;
-
-    this.pushTransientTableDataActionsUpdates({
-      [ORIGINAL_INDEX_KEY]: this.getRowOriginalIndex(rowIndex),
-      [alias]: value,
-    });
-
-    if (onSubmit && this.props.editableCell?.column) {
-      //since onSubmit is truthy this makes action truthy as well, so we can push this event
-      this.pushOnColumnEvent({
-        rowIndex: rowIndex,
-        action: onSubmit,
-        triggerPropertyName: "onSubmit",
-        eventType: EventType.ON_SUBMIT,
-        row: {
-          ...this.props.filteredTableData[rowIndex],
-          [this.props.editableCell.column]: value,
-        },
-      });
-    }
-
-    commitBatchMetaUpdates();
-    this.clearEditableCell();
-  };
-  pushClearEditableCellsUpdates = () => {
-    const { pushBatchMetaUpdates } = this.props;
-
-    pushBatchMetaUpdates("editableCell", defaultEditableCell);
-    pushBatchMetaUpdates("columnEditableCellValue", {});
-  };
-
-  clearEditableCell = (skipTimeout?: boolean) => {
-    const clear = () => {
-      const { commitBatchMetaUpdates } = this.props;
-
-      this.pushClearEditableCellsUpdates();
-      commitBatchMetaUpdates();
-    };
-
-    if (skipTimeout) {
-      clear();
-    } else {
-      /*
-       * We need to let the evaulations compute derived property (filteredTableData)
-       * before we clear the editableCell to avoid the text flickering
-       */
-      this.inlineEditTimer = setTimeout(clear, 100);
-    }
-  };
-
-  isColumnCellEditable = (column: ColumnProperties, rowIndex: number) => {
-    return (
-      column.alias === this.props.editableCell?.column &&
-      rowIndex === this.props.editableCell?.index
-    );
-  };
-
-  onOptionSelect = (
-    value: string | number,
-    rowIndex: number,
-    column: string,
-    action?: string,
-  ) => {
-    if (this.props.isAddRowInProgress) {
-      this.updateNewRowValues(column, value, value);
-    } else {
-      const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-      this.pushTransientTableDataActionsUpdates({
-        [ORIGINAL_INDEX_KEY]: this.getRowOriginalIndex(rowIndex),
-        [column]: value,
-      });
-      pushBatchMetaUpdates("editableCell", defaultEditableCell);
-
-      if (action && this.props.editableCell?.column) {
-        //since action is truthy we can push this event
-        this.pushOnColumnEvent({
-          rowIndex,
-          action,
-          triggerPropertyName: "onOptionChange",
-          eventType: EventType.ON_OPTION_CHANGE,
-          row: {
-            ...this.props.filteredTableData[rowIndex],
-            [this.props.editableCell.column]: value,
-          },
-        });
-      }
-
-      commitBatchMetaUpdates();
-    }
-  };
-
-  onSelectFilterChange = (
-    text: string,
-    rowIndex: number,
-    serverSideFiltering: boolean,
-    alias: string,
-    action?: string,
-  ) => {
-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-    pushBatchMetaUpdates("selectColumnFilterText", {
-      ...this.props.selectColumnFilterText,
-      [alias]: text,
-    });
-
-    if (action && serverSideFiltering) {
-      //since action is truthy we can push this event
-      this.pushOnColumnEvent({
-        rowIndex,
-        action,
-        triggerPropertyName: "onFilterUpdate",
-        eventType: EventType.ON_FILTER_UPDATE,
-        row: {
-          ...this.props.filteredTableData[rowIndex],
-        },
-        additionalData: {
-          filterText: text,
-        },
-      });
-    }
-
-    commitBatchMetaUpdates();
-  };
-
-  onCheckChange = (
-    // TODO: Fix this the next time the file is edited
-    // eslint-disable-next-line @typescript-eslint/no-explicit-any
-    column: any,
-    row: Record<string, unknown>,
-    value: boolean,
-    alias: string,
-    originalIndex: number,
-    rowIndex: number,
-  ) => {
-    if (this.props.isAddRowInProgress) {
-      this.updateNewRowValues(alias, value, value);
-    } else {
-      const { commitBatchMetaUpdates } = this.props;
-
-      this.pushTransientTableDataActionsUpdates({
-        [ORIGINAL_INDEX_KEY]: originalIndex,
-        [alias]: value,
-      });
-      commitBatchMetaUpdates();
-      //cannot batch this update because we are not sure if it action is truthy or not
-      this.onColumnEvent({
-        rowIndex,
-        action: column.onCheckChange,
-        triggerPropertyName: "onCheckChange",
-        eventType: EventType.ON_CHECK_CHANGE,
-        row: {
-          ...row,
-          [alias]: value,
-        },
-      });
-    }
-  };
-
-  handleAddNewRowClick = () => {
-    const defaultNewRow = this.props.defaultNewRow || {};
-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-    pushBatchMetaUpdates("isAddRowInProgress", true);
-    pushBatchMetaUpdates("newRowContent", defaultNewRow);
-    pushBatchMetaUpdates("newRow", defaultNewRow);
-
-    // New row gets added at the top of page 1 when client side pagination enabled
-    if (!this.props.serverSidePaginationEnabled) {
-      this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);
-    }
-
-    //Since we're adding a newRowContent thats not part of tableData, the index changes
-    // so we're resetting the row selection
-    pushBatchMetaUpdates("selectedRowIndex", -1);
-    pushBatchMetaUpdates("selectedRowIndices", []);
-    commitBatchMetaUpdates();
-  };
-
-  handleAddNewRowAction = (
-    type: AddNewRowActions,
-    onActionComplete: () => void,
-  ) => {
-    let triggerPropertyName, action, eventType;
-
-    const onComplete = () => {
-      const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-      pushBatchMetaUpdates("isAddRowInProgress", false);
-      pushBatchMetaUpdates("newRowContent", undefined);
-      pushBatchMetaUpdates("newRow", undefined);
-      commitBatchMetaUpdates();
-
-      onActionComplete();
-    };
-
-    if (type === AddNewRowActions.SAVE) {
-      triggerPropertyName = "onAddNewRowSave";
-      action = this.props.onAddNewRowSave;
-      eventType = EventType.ON_ADD_NEW_ROW_SAVE;
-    } else {
-      triggerPropertyName = "onAddNewRowDiscard";
-      action = this.props.onAddNewRowDiscard;
-      eventType = EventType.ON_ADD_NEW_ROW_DISCARD;
-    }
-
-    if (action) {
-      super.executeAction({
-        triggerPropertyName: triggerPropertyName,
-        dynamicString: action,
-        event: {
-          type: eventType,
-          callback: onComplete,
-        },
-      });
-    } else {
-      onComplete();
-    }
-  };
-
-  isColumnCellValid = (columnsAlias: string) => {
-    if (this.props.isEditableCellsValid?.hasOwnProperty(columnsAlias)) {
-      return this.props.isEditableCellsValid[columnsAlias];
-    }
-
-    return true;
-  };
-
-  hasInvalidColumnCell = () => {
-    if (isObject(this.props.isEditableCellsValid)) {
-      return Object.values(this.props.isEditableCellsValid).some((d) => !d);
-    } else {
-      return false;
-    }
-  };
-
-  updateNewRowValues = (
-    alias: string,
-    value: unknown,
-    parsedValue: unknown,
-  ) => {
-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;
-
-    /*
-     * newRowContent holds whatever the user types while newRow holds the parsed value
-     * newRowContent is being used to populate the cell while newRow is being used
-     * for validations.
-     */
-    pushBatchMetaUpdates("newRowContent", {
-      ...this.props.newRowContent,
-      [alias]: value,
-    });
-    pushBatchMetaUpdates("newRow", {
-      ...this.props.newRow,
-      [alias]: parsedValue,
-    });
-    commitBatchMetaUpdates();
-  };
-
-  onConnectData = () => {
-    if (this.props.renderMode === RenderModes.CANVAS) {
-      super.updateOneClickBindingOptionsVisibility(true);
-    }
-  };
-
-  updateInfiniteScrollProperties(shouldCommitBatchUpdates?: boolean) {
-    const {
-      cachedTableData,
-      commitBatchMetaUpdates,
-      infiniteScrollEnabled,
-      pageNo,
-      pageSize,
-      processedTableData,
-      pushBatchMetaUpdates,
-      tableData,
-      totalRecordsCount,
-    } = this.props;
-
-    if (infiniteScrollEnabled) {
-      // Update the cache key for a particular page whenever this function is called. The pageNo data is updated with the tableData.
-      const updatedCachedTableData = {
-        ...(cachedTableData || {}),
-        [pageNo]: tableData,
-      };
-
-      pushBatchMetaUpdates("cachedTableData", updatedCachedTableData);
-
-      // The check (!!totalRecordsCount && processedTableData.length === totalRecordsCount) is added if the totalRecordsCount property is set then match the length with the processedTableData which has all flatted data from each page in a single array except the current tableData page i.e. [ ...array of page 1 data, ...array of page 2 data ]. Another 'or' check is if (tableData.length < pageSize) when totalRecordsCount is undefined. Table data has a single page data and if the data comes out to be lesser than the pageSize, it is assumed that the data is finished.
-      if (window?.navigator?.onLine) {
-        if (
-          (!!totalRecordsCount &&
-            processedTableData.length + tableData.length ===
-              totalRecordsCount) ||
-          (!totalRecordsCount && tableData.length < pageSize)
-        ) {
-          pushBatchMetaUpdates("endOfData", true);
-        } else {
-          pushBatchMetaUpdates("endOfData", false);
-        }
-      }
-
-      if (shouldCommitBatchUpdates) {
-        commitBatchMetaUpdates();
-      }
-    }
-  }
-
-  resetTableForInfiniteScroll = () => {
-    resetWidget(this.props.widgetId, false);
-    this.updatePageNumber(0, EventType.ON_NEXT_PAGE);
-  };
-}
-
-export default TableWidgetV2;
+          "The Table is the hero widget of Appsmith. You can display data from an API in a table, trigger an action when a user selects a row and even work with large
\ No newline at end of file
diff --git a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts
index 96210b4..cc01e14 100644
--- a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts
+++ b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts
@@ -137,10 +137,7 @@ export default {
         const columnType = get(props, `${baseProperty}.columnType`, "");
         const isDerived = get(props, `${baseProperty}.isDerived`, false);
 
-        return (
-          !isColumnTypeEditable(columnType, props.infiniteScrollEnabled) ||
-          isDerived
-        );
+        return !isColumnTypeEditable(columnType) || isDerived;
       },
     },
     {
@@ -296,4 +293,4 @@ export const GeneralStyle = {
       },
     },
   ],
-};
+};
\ No newline at end of file
diff --git a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts
index 48351f3..55e0acf 100644
--- a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts
+++ b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts
@@ -22,6 +22,7 @@ import {
   totalRecordsCountValidation,
   uniqueColumnNameValidation,
   updateAllowAddNewRowOnInfiniteScrollChange,
+  updateCellEditabilityOnInfiniteScrollChange,
   updateColumnOrderHook,
   updateCustomColumnAliasOnLabelChange,
   updateInlineEditingOptionDropdownVisibilityHook,
@@ -196,6 +197,7 @@ export default [
         isTriggerProperty: false,
         updateHook: composePropertyUpdateHook([
           updateAllowAddNewRowOnInfiniteScrollChange,
+          updateCellEditabilityOnInfiniteScrollChange,
           updateSearchSortFilterOnInfiniteScrollChange,
         ]),
         dependencies: ["primaryColumns", "serverSidePaginationEnabled"],
@@ -438,193 +440,4 @@ export default [
       },
       {
         helperText:
-          "Client side only, custom sort function data(overrides default sorting)",
-        helpText:
-          "Function should expect three arguments: tableData, columnId, and order. Return the sorted tableData.",
-        propertyName: "customSortFunction",
-        label: "Custom sort function data",
-        controlType: "TABLE_CUSTOM_SORT",
-        placeholderText:
-          "{{(tableData, columnId, order) => { /* Return sorted table data */ }}}",
-        controlConfig: {
-          maxHeight: "400px",
-          height: "100px",
-        },
-        isTriggerProperty: false,
-        hidden: (props: TableWidgetProps) =>
-          !props.isSortable ||
-          !Widget.getFeatureFlag(CUSTOM_SORT_FUNCTION_ENABLED),
-        dependencies: ["isSortable"],
-      },
-    ],
-    expandedByDefault: false,
-  },
-
-  {
-    sectionName: "Adding a row",
-    shouldDisableSection: (props: TableWidgetProps) =>
-      props.infiniteScrollEnabled,
-    disabledHelpText: INFINITE_SCROLL_DISABLED_HELP_TEXT,
-    dependencies: ["infiniteScrollEnabled"],
-    children: [
-      {
-        propertyName: "allowAddNewRow",
-        helpText: "Enables adding a new row",
-        isJSConvertible: true,
-        label: "Allow adding a row",
-        controlType: "SWITCH",
-        isBindProperty: true,
-        isTriggerProperty: false,
-        validation: {
-          type: ValidationTypes.BOOLEAN,
-        },
-      },
-      {
-        propertyName: "onAddNewRowSave",
-        helpText: "when a add new row save button is clicked",
-        label: "onSave",
-        controlType: "ACTION_SELECTOR",
-        hidden: (props: TableWidgetProps) => {
-          return !props.allowAddNewRow;
-        },
-        dependencies: ["allowAddNewRow", "primaryColumns"],
-        isJSConvertible: true,
-        isBindProperty: true,
-        isTriggerProperty: true,
-        additionalAutoComplete: (props: TableWidgetProps) => {
-          const newRow: Record<string, unknown> = {};
-
-          if (props.primaryColumns) {
-            Object.values(props.primaryColumns)
-              .filter((column) => !column.isDerived)
-              .forEach((column) => {
-                newRow[column.alias] = "";
-              });
-          }
-
-          return {
-            newRow,
-          };
-        },
-      },
-      {
-        propertyName: "onAddNewRowDiscard",
-        helpText: "when a add new row discard button is clicked",
-        label: "onDiscard",
-        controlType: "ACTION_SELECTOR",
-        hidden: (props: TableWidgetProps) => {
-          return !props.allowAddNewRow;
-        },
-        dependencies: ["allowAddNewRow"],
-        isJSConvertible: true,
-        isBindProperty: true,
-        isTriggerProperty: true,
-      },
-      {
-        propertyName: "defaultNewRow",
-        helpText: "Default new row values",
-        label: "Default values",
-        controlType: "INPUT_TEXT",
-        dependencies: ["allowAddNewRow"],
-        hidden: (props: TableWidgetProps) => {
-          return !props.allowAddNewRow;
-        },
-        isBindProperty: true,
-        isTriggerProperty: false,
-        validation: {
-          type: ValidationTypes.OBJECT,
-          params: {
-            default: {},
-          },
-        },
-      },
-    ],
-    expandedByDefault: false,
-  },
-  {
-    sectionName: "General",
-    children: [
-      {
-        helpText: "Controls the visibility of the widget",
-        propertyName: "isVisible",
-        isJSConvertible: true,
-        label: "Visible",
-        controlType: "SWITCH",
-        isBindProperty: true,
-        isTriggerProperty: false,
-        validation: {
-          type: ValidationTypes.BOOLEAN,
-        },
-      },
-      {
-        propertyName: "animateLoading",
-        label: "Animate loading",
-        controlType: "SWITCH",
-        helpText: "Controls the animation loading of the widget",
-        defaultValue: true,
-        isJSConvertible: true,
-        isBindProperty: true,
-        isTriggerProperty: false,
-        validation: { type: ValidationTypes.BOOLEAN },
-      },
-      {
-        propertyName: "customIsLoading",
-        label: `Custom loading state`,
-        controlType: "SWITCH",
-        helpText: "Defines a custom value for the loading state",
-        defaultValue: false,
-        isBindProperty: true,
-        isTriggerProperty: false,
-        validation: { type: ValidationTypes.BOOLEAN },
-      },
-      {
-        propertyName: "customIsLoadingValue",
-        label: "isLoading value",
-        controlType: "INPUT_TEXT",
-        defaultValue: "",
-        isBindProperty: true,
-        isTriggerProperty: false,
-        validation: { type: ValidationTypes.BOOLEAN },
-        hidden: (props: TableWidgetProps) => !props.customIsLoading,
-        dependencies: ["customIsLoading"],
-      },
-      {
-        propertyName: "isVisibleDownload",
-        helpText: "Toggle visibility of the data download",
-        label: "Allow download",
-        controlType: "SWITCH",
-        isJSConvertible: true,
-        isBindProperty: true,
-        isTriggerProperty: false,
-        validation: { type: ValidationTypes.BOOLEAN },
-      },
-      {
-        propertyName: "canFreezeColumn",
-        helpText: "Controls whether the user can freeze columns",
-        label: "Allow column freeze",
-        controlType: "SWITCH",
-        defaultValue: true,
-        isJSConvertible: true,
-        isBindProperty: true,
-        isTriggerProperty: false,
-        validation: { type: ValidationTypes.BOOLEAN },
-      },
-      {
-        propertyName: "delimiter",
-        label: "CSV separator",
-        controlType: "INPUT_TEXT",
-        placeholderText: "Enter CSV separator",
-        helpText: "The character used for separating the CSV download file.",
-        isBindProperty: true,
-        isTriggerProperty: false,
-        defaultValue: ",",
-        validation: {
-          type: ValidationTypes.TEXT,
-        },
-        hidden: (props: TableWidgetProps) => !props.isVisibleDownload,
-        dependencies: ["isVisibleDownload"],
-      },
-    ],
-    expandedByDefault: false,
-  },
-] as PropertyPaneConfig[];
+          "Client side
\ No newline at end of file
diff --git a/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts b/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts
index bf6bb16..52c206e 100644
--- a/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts
+++ b/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts
@@ -481,1035 +481,4 @@ export const SelectColumnOptionsValidations = (
 
   if (typeof value === "string" && value.trim() !== "") {
     /*
-     * when value is a string
-     */
-    try {
-      /*
-       * when the value is an array of string
-       */
-      value = JSON.parse(value);
-    } catch (e) {
-      /*
-       * when the value is an comma seperated strings
-       */
-      value = (value as string).split(",").map((str) => str.trim());
-    }
-  }
-
-  /*
-   * when value is null, undefined and empty string
-   */
-  if (_.isNil(value) || value === "") {
-    isValid = true;
-    parsed = [];
-  } else if (_.isArray(value)) {
-    const hasStringOrNumber = (value as []).every(
-      (item) => _.isString(item) || _.isFinite(item),
-    );
-
-    isValid = hasStringOrNumber;
-    parsed = value;
-    message = hasStringOrNumber ? "" : expectedMessage;
-  } else if (typeof value === "number") {
-    isValid = true;
-    parsed = [value];
-  } else {
-    isValid = false;
-    parsed = value;
-    message = expectedMessage;
-  }
-
-  return {
-    isValid,
-    parsed,
-    messages: [message],
-  };
-};
-
-/*
- * Hook that updates column isDiabled binding when columnType is
- * changed to ColumnTypes.EDIT_ACTIONS.
- */
-export const updateInlineEditingSaveOptionHook = (
-  props: TableWidgetProps,
-  propertyPath: string,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  propertyValue: any,
-): Array<PropertyUpdates> | undefined => {
-  if (propertyValue !== InlineEditingSaveOptions.ROW_LEVEL) {
-    const columnsArray = Object.values(props.primaryColumns);
-    const edtiActionColumn = columnsArray.find(
-      (column) => column.columnType === ColumnTypes.EDIT_ACTIONS,
-    );
-
-    if (edtiActionColumn && edtiActionColumn.id) {
-      const newColumnOrder = _.difference(props.columnOrder, [
-        edtiActionColumn.id,
-      ]);
-
-      return [
-        {
-          propertyPath: `primaryColumns.${edtiActionColumn.id}`,
-          shouldDeleteProperty: true,
-        },
-        {
-          propertyPath: "columnOrder",
-          propertyValue: newColumnOrder,
-        },
-      ];
-    }
-  } else {
-    const columnIdMatcher = propertyPath.match(EDITABLITY_PATH_REGEX);
-    const columnId = columnIdMatcher && columnIdMatcher[1];
-    const isAtleastOneEditableColumnPresent = Object.values(
-      props.primaryColumns,
-    ).some((column) => column.id !== columnId && column.isEditable);
-
-    if (isAtleastOneEditableColumnPresent) {
-      return createEditActionColumn(props);
-    }
-  }
-};
-
-export const updateNumberColumnTypeTextAlignment = (
-  props: TableWidgetProps,
-  propertyPath: string,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  propertyValue: any,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-): Array<{ propertyPath: string; propertyValue: any }> | undefined => {
-  const baseProperty = getBasePropertyPath(propertyPath);
-
-  if (propertyValue === ColumnTypes.NUMBER) {
-    return [
-      {
-        propertyPath: `${baseProperty}.horizontalAlignment`,
-        propertyValue: CellAlignmentTypes.RIGHT,
-      },
-    ];
-  } else {
-    return [
-      {
-        propertyPath: `${baseProperty}.horizontalAlignment`,
-        propertyValue: CellAlignmentTypes.LEFT,
-      },
-    ];
-  }
-
-  return;
-};
-
-/**
- * updates theme stylesheets
- *
- * @param props
- * @param propertyPath
- * @param propertyValue
- */
-export function updateThemeStylesheetsInColumns(
-  props: TableWidgetProps,
-  propertyPath: string,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  propertyValue: any,
-): Array<PropertyUpdates> | undefined {
-  const regex = /^primaryColumns\.(\w+)\.(.*)$/;
-  const matches = propertyPath.match(regex);
-  const columnId = matches?.[1];
-  const columnProperty = matches?.[2];
-
-  if (columnProperty === "columnType") {
-    const propertiesToUpdate: Array<PropertyUpdates> = [];
-    const oldColumnType = get(props, `primaryColumns.${columnId}.columnType`);
-    const newColumnType = propertyValue;
-
-    const propertiesToRemove = Object.keys(
-      props.childStylesheet[oldColumnType] || {},
-    );
-
-    const propertiesToAdd = Object.keys(
-      props.childStylesheet[newColumnType] || {},
-    );
-
-    propertiesToRemove.forEach((propertyKey) => {
-      propertiesToUpdate.push({
-        propertyPath: `primaryColumns.${columnId}.${propertyKey}`,
-        shouldDeleteProperty: true,
-      });
-    });
-
-    propertiesToAdd.forEach((propertyKey) => {
-      const { jsSnippets, stringSegments } = getDynamicBindings(
-        props.childStylesheet[newColumnType][propertyKey],
-      );
-
-      const js = combineDynamicBindings(jsSnippets, stringSegments);
-
-      propertiesToUpdate.push({
-        propertyPath: `primaryColumns.${columnId}.${propertyKey}`,
-        propertyValue: `{{${props.widgetName}.processedTableData.map((currentRow, currentIndex) => ( ${js}))}}`,
-      });
-    });
-
-    if (propertiesToUpdate.length) {
-      /*
-       * Temporary patch to make evaluations to compute inverseDependencyMap when
-       * column type is changed.
-       * TODO(Balaji): remove once https://github.com/appsmithorg/appsmith/issues/14436 gets fixed
-       */
-      propertiesToUpdate.push({
-        propertyPath: `primaryColumns.${columnId}.customAlias`,
-        propertyValue: "",
-      });
-
-      return propertiesToUpdate;
-    }
-  }
-}
-
-/**
- * A function for updateHook to remove the boxShadowColor property post migration.
- * @param props
- * @param propertyPath
- * @param propertyValue
- */
-export const removeBoxShadowColorProp = (
-  props: TableWidgetProps,
-  propertyPath: string,
-) => {
-  const boxShadowColorPath = replacePropertyName(
-    propertyPath,
-    "boxShadowColor",
-  );
-
-  return [
-    {
-      propertyPath: boxShadowColorPath,
-      propertyValue: undefined,
-    },
-  ];
-};
-
-/**
- * This function will replace the property present at the end of the propertyPath with the targetPropertyName.
- * e.g.
- * propertyPath = primaryColumns.action.boxShadow
- * Running this function will give the new propertyPath like below:
- * propertyPath = primaryColumns.action.boxShadowColor
- *
- * @param propertyPath The property path inside a widget
- * @param targetPropertyName Target property name
- * @returns New property path with target property name at the end.
- */
-export const replacePropertyName = (
-  propertyPath: string,
-  targetPropertyName: string,
-) => {
-  const path = propertyPath.split(".");
-
-  path.pop();
-
-  return `${path.join(".")}.${targetPropertyName}`;
-};
-
-export const updateCustomColumnAliasOnLabelChange = (
-  props: TableWidgetProps,
-  propertyPath: string,
-  propertyValue: unknown,
-): Array<PropertyUpdates> | undefined => {
-  // alias will be updated along with label change only for custom columns
-  const regex = /^primaryColumns\.(customColumn\d+)\.label$/;
-
-  if (propertyPath?.length && regex.test(propertyPath)) {
-    return [
-      {
-        propertyPath: propertyPath.replace("label", "alias"),
-        propertyValue: propertyValue,
-      },
-    ];
-  }
-};
-
-export const allowedFirstDayOfWeekRange = (value: number) => {
-  const allowedValues = [0, 1, 2, 3, 4, 5, 6];
-  const isValid = allowedValues.includes(Number(value));
-
-  return {
-    isValid: isValid,
-    parsed: isValid ? Number(value) : 0,
-    messages: isValid ? [] : ["Number should be between 0-6."],
-  };
-};
-
-export const hideByMenuItemsSource = (
-  props: TableWidgetProps,
-  propertyPath: string,
-  menuItemsSource: MenuItemsSource,
-) => {
-  const baseProperty = getBasePropertyPath(propertyPath);
-  const currentMenuItemsSource = get(
-    props,
-    `${baseProperty}.menuItemsSource`,
-    "",
-  );
-
-  return currentMenuItemsSource === menuItemsSource;
-};
-
-export const hideIfMenuItemsSourceDataIsFalsy = (
-  props: TableWidgetProps,
-  propertyPath: string,
-) => {
-  const baseProperty = getBasePropertyPath(propertyPath);
-  const sourceData = get(props, `${baseProperty}.sourceData`, "");
-
-  return !sourceData;
-};
-
-export const updateMenuItemsSource = (
-  props: TableWidgetProps,
-  propertyPath: string,
-  propertyValue: unknown,
-): Array<{ propertyPath: string; propertyValue: unknown }> | undefined => {
-  const propertiesToUpdate: Array<{
-    propertyPath: string;
-    propertyValue: unknown;
-  }> = [];
-  const baseProperty = getBasePropertyPath(propertyPath);
-  const menuItemsSource = get(props, `${baseProperty}.menuItemsSource`);
-
-  if (propertyValue === ColumnTypes.MENU_BUTTON && !menuItemsSource) {
-    // Sets the default value for menuItemsSource to static when
-    // selecting the menu button column type for the first time
-    propertiesToUpdate.push({
-      propertyPath: `${baseProperty}.menuItemsSource`,
-      propertyValue: MenuItemsSource.STATIC,
-    });
-  } else {
-    const sourceData = get(props, `${baseProperty}.sourceData`);
-    const configureMenuItems = get(props, `${baseProperty}.configureMenuItems`);
-    const isMenuItemsSourceChangedFromStaticToDynamic =
-      menuItemsSource === MenuItemsSource.STATIC &&
-      propertyValue === MenuItemsSource.DYNAMIC;
-
-    if (isMenuItemsSourceChangedFromStaticToDynamic) {
-      if (!sourceData) {
-        propertiesToUpdate.push({
-          propertyPath: `${baseProperty}.sourceData`,
-          propertyValue: [],
-        });
-      }
-
-      if (!configureMenuItems) {
-        propertiesToUpdate.push({
-          propertyPath: `${baseProperty}.configureMenuItems`,
-          propertyValue: {
-            label: "Configure menu items",
-            id: "config",
-            config: {
-              id: "config",
-              label: "Menu Item",
-              isVisible: true,
-              isDisabled: false,
-            },
-          },
-        });
-      }
-    }
-  }
-
-  return propertiesToUpdate?.length ? propertiesToUpdate : undefined;
-};
-
-export const updateCurrencyDefaultValues = (
-  props: TableWidgetProps,
-  propertyPath: string,
-  propertyValue: unknown,
-): Array<{ propertyPath: string; propertyValue: unknown }> | undefined => {
-  const propertiesToUpdate: Array<{
-    propertyPath: string;
-    propertyValue: unknown;
-  }> = [];
-  const baseProperty = getBasePropertyPath(propertyPath);
-
-  if (propertyValue === ColumnTypes.CURRENCY) {
-    if (!get(props, `${baseProperty}.currencyCode`)) {
-      propertiesToUpdate.push({
-        propertyPath: `${baseProperty}.currencyCode`,
-        propertyValue: "USD",
-      });
-    }
-
-    if (get(props, `${baseProperty}.decimals`) === undefined) {
-      propertiesToUpdate.push({
-        propertyPath: `${baseProperty}.decimals`,
-        propertyValue: 0,
-      });
-    }
-
-    if (get(props, `${baseProperty}.notation`) === undefined) {
-      propertiesToUpdate.push({
-        propertyPath: `${baseProperty}.notation`,
-        propertyValue: "standard",
-      });
-    }
-
-    if (get(props, `${baseProperty}.thousandSeparator`) === undefined) {
-      propertiesToUpdate.push({
-        propertyPath: `${baseProperty}.thousandSeparator`,
-        propertyValue: true,
-      });
-    }
-  }
-
-  return propertiesToUpdate?.length ? propertiesToUpdate : undefined;
-};
-
-export function selectColumnOptionsValidation(
-  value: unknown,
-  props: TableWidgetProps,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  _?: any,
-) {
-  let _isValid = true,
-    _parsed,
-    _message = "";
-  let uniqueValues: Set<unknown>;
-  const invalidArrayValueMessage = `This value does not evaluate to type: { "label": string | number, "value": string | number | boolean }`;
-  const invalidMessage = `This value does not evaluate to type Array<{ "label": string | number, "value": string | number | boolean }>`;
-  const allowedValueTypes = ["string", "number", "boolean"];
-  const allowedLabelTypes = ["string", "number"];
-
-  const generateErrorMessagePrefix = (
-    rowIndex: number | null,
-    optionIndex: number,
-  ) => {
-    return `Invalid entry at${
-      rowIndex !== null ? ` Row: ${rowIndex}` : ""
-    } index: ${optionIndex}.`;
-  };
-
-  const generateInvalidArrayValueMessage = (
-    rowIndex: number | null,
-    optionIndex: number,
-  ) =>
-    `${generateErrorMessagePrefix(
-      rowIndex,
-      optionIndex,
-    )} ${invalidArrayValueMessage}`;
-
-  const validateOption = (
-    // TODO: Fix this the next time the file is edited
-    // eslint-disable-next-line @typescript-eslint/no-explicit-any
-    option: any,
-    rowIndex: number | null,
-    optionIndex: number,
-  ) => {
-    /*
-     *  Option should
-     *    1. be an object
-     *    2. have label property
-     *    3. label should be of type string | number
-     *    4. have value property
-     *    5. value should be of type string | number | boolean
-     *    6. value should be unique amoig the options array
-     */
-    if (!_.isObject(option)) {
-      // 1
-      return `${generateErrorMessagePrefix(
-        rowIndex,
-        optionIndex,
-      )} This value does not evaluate to type: { "label": string | number, "value": string | number | boolean }`;
-    }
-
-    if (!option.hasOwnProperty("label")) {
-      // 2
-      return `${generateErrorMessagePrefix(
-        rowIndex,
-        optionIndex,
-      )} Missing required key: label`;
-    }
-
-    if (!allowedLabelTypes.includes(typeof option.label)) {
-      // 3
-      return `${generateErrorMessagePrefix(
-        rowIndex,
-        optionIndex,
-      )} label does not evaluate to type ${allowedLabelTypes.join(" | ")}`;
-    }
-
-    if (!option.hasOwnProperty("value")) {
-      // 4
-      return `${generateErrorMessagePrefix(
-        rowIndex,
-        optionIndex,
-      )} Missing required key: value`;
-    }
-
-    if (!allowedValueTypes.includes(typeof option.value)) {
-      // 5
-      return `${generateErrorMessagePrefix(
-        rowIndex,
-        optionIndex,
-      )} value does not evaluate to type ${allowedValueTypes.join(" | ")}`;
-    }
-
-    if (uniqueValues.has(option.value)) {
-      // 6
-      return `Duplicate values found for the following properties, in the array entries, that must be unique -- value.`;
-    } else {
-      uniqueValues.add(option.value);
-    }
-
-    return "";
-  };
-
-  try {
-    if (value === "" || _.isNil(value)) {
-      // empty values
-      return {
-        isValid: true,
-        parsed: [],
-        messages: [""],
-      };
-    } else if (typeof value === "string") {
-      // json string
-      const _value = JSON.parse(value);
-
-      if (Array.isArray(_value)) {
-        value = _value;
-      } else {
-        _isValid = false;
-        _message = invalidMessage;
-      }
-    }
-
-    if (Array.isArray(value)) {
-      if (value.length) {
-        //when value is array of option json string
-        if (value.every((d) => _.isString(d))) {
-          value = value.map((d) => JSON.parse(d));
-        }
-
-        if (Array.isArray(value) && Array.isArray(value[0])) {
-          // value is array of array of label, value
-          //Value should be an array of array
-          if (!value.every((d) => Array.isArray(d))) {
-            _parsed = [];
-            _isValid = false;
-            _message = invalidMessage;
-          } else {
-            _parsed = value;
-            _isValid = true;
-
-            for (let i = 0; i < value.length; i++) {
-              uniqueValues = new Set();
-
-              for (let j = 0; j < value[i].length; j++) {
-                if (_.isNil(value[i][j])) {
-                  _isValid = false;
-                  _message = generateInvalidArrayValueMessage(i, j);
-                  _parsed = [];
-                  break;
-                }
-
-                if ((_message = validateOption(value[i][j], i, j))) {
-                  _isValid = false;
-                  break;
-                }
-              }
-
-              if (!_isValid) {
-                break;
-              }
-            }
-          }
-        } else {
-          uniqueValues = new Set();
-          _parsed = value;
-          _isValid = true;
-
-          for (let i = 0; i < (value as Array<unknown>).length; i++) {
-            if (_.isNil((value as Array<unknown>)[i])) {
-              _isValid = false;
-              _message = generateInvalidArrayValueMessage(null, i);
-              _parsed = [];
-              break;
-            }
-
-            if (
-              (_message = validateOption((value as Array<unknown>)[i], null, i))
-            ) {
-              _isValid = false;
-              break;
-            }
-          }
-        }
-      } else {
-        _isValid = true;
-        _parsed = [];
-      }
-    } else {
-      _parsed = [];
-      _isValid = false;
-      _message = invalidMessage;
-    }
-  } catch (e) {
-    _parsed = [];
-    _isValid = false;
-    _message = invalidMessage;
-  }
-
-  return {
-    isValid: _isValid,
-    parsed: _parsed,
-    messages: [_message],
-  };
-}
-
-export const getColumnPath = (propPath: string) =>
-  propPath.split(".").slice(0, 2).join(".");
-
-export const tableDataValidation = (
-  value: unknown,
-  props: TableWidgetProps,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  _?: any,
-) => {
-  const invalidResponse = {
-    isValid: false,
-    parsed: [],
-    messages: [
-      {
-        name: "TypeError",
-        message: `Invalid value. This field expects an array of objects(Array<Object>) or the result of a Query such as "{{query1.data}}".`,
-      },
-    ],
-  };
-
-  if (value === "") {
-    return {
-      isValid: true,
-      parsed: [],
-    };
-  }
-
-  if (value === undefined || value === null) {
-    return {
-      isValid: false,
-      parsed: [],
-      messages: [
-        {
-          name: "ValidationError",
-          message: "Data is undefined, re-run your query or fix the data",
-        },
-      ],
-    };
-  }
-
-  if (!_.isString(value) && !Array.isArray(value)) {
-    return invalidResponse;
-  }
-
-  let parsed = value;
-
-  if (_.isString(value)) {
-    try {
-      parsed = JSON.parse(value as string);
-    } catch (e) {
-      return invalidResponse;
-    }
-  }
-
-  if (Array.isArray(parsed)) {
-    if (parsed.length === 0) {
-      return {
-        isValid: true,
-        parsed: [],
-      };
-    }
-
-    for (let i = 0; i < parsed.length; i++) {
-      if (!_.isPlainObject(parsed[i])) {
-        return {
-          isValid: false,
-          parsed: [],
-          messages: [
-            {
-              name: "ValidationError",
-              message: `Invalid object at index ${i}`,
-            },
-          ],
-        };
-      }
-    }
-
-    return { isValid: true, parsed };
-  }
-
-  return invalidResponse;
-};
-
-export function textForEachRowValidation(
-  value: unknown,
-  props: TableWidgetProps,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  _: any,
-): ValidationResponse {
-  const generateResponseAndReturn = (
-    isValid = false,
-    message = { name: "", message: "" },
-  ) => {
-    return {
-      isValid,
-      parsed: isValid ? value : [],
-      messages: [message],
-    };
-  };
-
-  const DEFAULT_MESSAGE = {
-    name: "TypeError",
-    message: "The evaluated value should be either a string or a number.",
-  };
-
-  if (
-    _.isString(value) ||
-    _.isNumber(value) ||
-    Array.isArray(value) ||
-    value === undefined
-  ) {
-    if (Array.isArray(value)) {
-      const isValid = value.every((item) => {
-        if (_.isString(item) || _.isNumber(item) || item === undefined) {
-          return true;
-        }
-
-        if (Array.isArray(item)) {
-          return item.every(
-            (subItem) =>
-              _.isString(subItem) ||
-              _.isNumber(subItem) ||
-              subItem === undefined,
-          );
-        }
-
-        return false;
-      });
-
-      return isValid
-        ? generateResponseAndReturn(true)
-        : generateResponseAndReturn(false, DEFAULT_MESSAGE);
-    }
-
-    return generateResponseAndReturn(true);
-  }
-
-  return generateResponseAndReturn(false, DEFAULT_MESSAGE);
-}
-
-export function booleanForEachRowValidation(
-  value: unknown,
-): ValidationResponse {
-  const generateResponseAndReturn = (
-    isValid = false,
-    message = { name: "", message: "" },
-  ) => {
-    return {
-      isValid,
-      parsed: isValid ? value : true,
-      messages: [message],
-    };
-  };
-
-  const isBoolean = (value: unknown) => {
-    const isABoolean = value === true || value === false;
-    const isStringTrueFalse = value === "true" || value === "false";
-
-    return isABoolean || isStringTrueFalse || value === undefined;
-  };
-
-  const DEFAULT_MESSAGE = {
-    name: "TypeError",
-    message: "The evaluated value should be a boolean.",
-  };
-
-  if (isBoolean(value)) {
-    return generateResponseAndReturn(true);
-  }
-
-  if (Array.isArray(value)) {
-    const isValid = value.every((item) => {
-      if (isBoolean(item)) {
-        return true;
-      }
-
-      if (Array.isArray(item)) {
-        return item.every((subItem) => isBoolean(subItem));
-      }
-
-      return false;
-    });
-
-    return isValid
-      ? generateResponseAndReturn(true)
-      : generateResponseAndReturn(false, DEFAULT_MESSAGE);
-  }
-
-  return generateResponseAndReturn(false, DEFAULT_MESSAGE);
-}
-
-export function iconNamesForEachRowValidation(
-  value: unknown,
-  props: TableWidgetProps,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  _: any,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  moment: any,
-  propertyPath: string,
-  config: ValidationConfig,
-): ValidationResponse {
-  const generateResponseAndReturn = (
-    isValid = false,
-    message = { name: "", message: "" },
-  ) => {
-    return {
-      isValid,
-      parsed: isValid ? value : true,
-      messages: [message],
-    };
-  };
-
-  const DEFAULT_MESSAGE = {
-    name: "TypeError",
-    message:
-      "The evaluated value should either be an icon name, undefined, null, or an empty string. We currently use the icons from the Blueprint library. You can see the list of icons at https://blueprintjs.com/docs/#icons",
-  };
-
-  const isIconName = (value: unknown) => {
-    return (
-      config?.params?.allowedValues?.includes(value as string) ||
-      value === undefined ||
-      value === null ||
-      value === ""
-    );
-  };
-
-  if (isIconName(value)) {
-    return generateResponseAndReturn(true);
-  }
-
-  if (Array.isArray(value)) {
-    const isValid = value.every((item) => {
-      if (isIconName(item)) {
-        return true;
-      }
-
-      if (Array.isArray(item)) {
-        return item.every((subItem) => isIconName(subItem));
-      }
-
-      return false;
-    });
-
-    return isValid
-      ? generateResponseAndReturn(true)
-      : generateResponseAndReturn(false, DEFAULT_MESSAGE);
-  }
-
-  return generateResponseAndReturn(false, DEFAULT_MESSAGE);
-}
-
-export function iconPositionForEachRowValidation(
-  value: unknown,
-  props: TableWidgetProps,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  _: any,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  moment: any,
-  propertyPath: string,
-  config: ValidationConfig,
-): ValidationResponse {
-  const generateResponseAndReturn = (
-    isValid = false,
-    message = { name: "", message: "" },
-  ) => {
-    return {
-      isValid,
-      parsed: isValid ? value : true,
-      messages: [message],
-    };
-  };
-
-  const DEFAULT_MESSAGE = {
-    name: "TypeError",
-    message: `The evaluated value should be one of the allowed values => ${config?.params?.allowedValues?.join(
-      ", ",
-    )}, undefined, null, or an empty string`,
-  };
-
-  const isIconPosition = (value: unknown) => {
-    return (
-      config?.params?.allowedValues?.includes(value as string) ||
-      value === undefined ||
-      value === null ||
-      value === ""
-    );
-  };
-
-  if (isIconPosition(value)) {
-    return generateResponseAndReturn(true);
-  }
-
-  if (Array.isArray(value)) {
-    const isValid = value.every((item) => {
-      if (isIconPosition(item)) {
-        return true;
-      }
-
-      if (Array.isArray(item)) {
-        return item.every((subItem) => isIconPosition(subItem));
-      }
-
-      return false;
-    });
-
-    return isValid
-      ? generateResponseAndReturn(true)
-      : generateResponseAndReturn(false, DEFAULT_MESSAGE);
-  }
-
-  return generateResponseAndReturn(false, DEFAULT_MESSAGE);
-}
-
-export function colorForEachRowValidation(
-  value: unknown,
-  props: TableWidgetProps,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  _: any,
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  moment: any,
-  propertyPath: string,
-  config: ValidationConfig,
-): ValidationResponse {
-  const generateResponseAndReturn = (
-    isValid = false,
-    message = { name: "", message: "" },
-  ) => {
-    return {
-      isValid,
-      parsed: isValid ? value : true,
-      messages: [message],
-    };
-  };
-
-  const DEFAULT_MESSAGE = {
-    name: "TypeError",
-    message: `The evaluated value should match ${config?.params?.regex}`,
-  };
-
-  const isColor = (value: unknown) => {
-    return config?.params?.regex?.test(value as string);
-  };
-
-  if (isColor(value)) {
-    return generateResponseAndReturn(true);
-  }
-
-  if (Array.isArray(value)) {
-    const isValid = value.every((item) => {
-      if (isColor(item)) {
-        return true;
-      }
-
-      if (Array.isArray(item)) {
-        return item.every((subItem) => isColor(subItem));
-      }
-
-      return false;
-    });
-
-    return isValid
-      ? generateResponseAndReturn(true)
-      : generateResponseAndReturn(false, DEFAULT_MESSAGE);
-  }
-
-  return generateResponseAndReturn(false, DEFAULT_MESSAGE);
-}
-
-// Infinite scroll not supported for add new row yet
-export const updateAllowAddNewRowOnInfiniteScrollChange = (
-  props: TableWidgetProps,
-  propertyPath: string,
-  propertyValue: unknown,
-): Array<{ propertyPath: string; propertyValue: unknown }> | undefined => {
-  if (propertyValue === true) {
-    return [
-      {
-        propertyPath: "allowAddNewRow",
-        propertyValue: false,
-      },
-    ];
-  } else if (propertyValue === false) {
-    return [
-      {
-        propertyPath: "allowAddNewRow",
-        propertyValue: true,
-      },
-    ];
-  }
-
-  return;
-};
-
-// Infinite scroll not supported for search, sort and filters yet
-export const updateSearchSortFilterOnInfiniteScrollChange = (
-  props: TableWidgetProps,
-  propertyPath: string,
-  propertyValue: unknown,
-): Array<{ propertyPath: string; propertyValue: unknown }> | undefined => {
-  if (propertyValue === true) {
-    return [
-      {
-        propertyPath: "isVisibleSearch",
-        propertyValue: false,
-      },
-      {
-        propertyPath: "isVisibleFilters",
-        propertyValue: false,
-      },
-      {
-        propertyPath: "isSortable",
-        propertyValue: false,
-      },
-    ];
-  } else if (propertyValue === false) {
-    return [
-      {
-        propertyPath: "isVisibleFilters",
-        propertyValue: true,
-      },
-      {
-        propertyPath: "isVisibleSearch",
-        propertyValue: true,
-      },
-      {
-        propertyPath: "isSortable",
-        propertyValue: true,
-      },
-    ];
-  }
-
-  return;
-};
+     *
\ No newline at end of file
diff --git a/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx b/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx
index 769768d..514c00e 100644
--- a/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx
+++ b/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx
@@ -4,7 +4,6 @@ import { RenderModes } from "constants/WidgetConstants";
 import { StickyType } from "../../component/Constants";
 import {
   COLUMN_MIN_WIDTH,
-  ColumnTypes,
   DEFAULT_COLUMN_WIDTH,
   DEFAULT_COLUMN_NAME,
 } from "../../constants";
@@ -22,7 +21,6 @@ export type getColumns = (
   componentWidth: number,
   renderMode: RenderMode,
   isPreviewMode: boolean,
-  infiniteScrollEnabled?: boolean,
 ) => ReactTableColumnProps[];
 
 //TODO: (Vamsi) need to unit test this function
@@ -34,7 +32,6 @@ export const getColumnsPureFn: getColumns = (
   componentWidth,
   renderMode,
   isPreviewMode,
-  infiniteScrollEnabled = false,
 ) => {
   let columns: ReactTableColumnProps[] = [];
   const hiddenColumns: ReactTableColumnProps[] = [];
@@ -45,14 +42,6 @@ export const getColumnsPureFn: getColumns = (
     // TODO: Fix this the next time the file is edited
     // eslint-disable-next-line @typescript-eslint/no-explicit-any
     orderedTableColumns.forEach((column: any) => {
-      // Skip EDIT_ACTIONS columns when infinite scroll is enabled
-      if (
-        infiniteScrollEnabled &&
-        column.columnType === ColumnTypes.EDIT_ACTIONS
-      ) {
-        return;
-      }
-
       const isHidden = !column.isVisible;
 
       const columnData = {
@@ -193,4 +182,4 @@ export const getMemoiseGetColumnsWithLocalStorageFn = () => {
     },
     isEqual,
   );
-};
+};
\ No newline at end of file
diff --git a/app/client/src/widgets/TableWidgetV2/widget/utilities.ts b/app/client/src/widgets/TableWidgetV2/widget/utilities.ts
index 5b2cd64..15cea49 100644
--- a/app/client/src/widgets/TableWidgetV2/widget/utilities.ts
+++ b/app/client/src/widgets/TableWidgetV2/widget/utilities.ts
@@ -510,670 +510,4 @@ export const getCellProperties = (
       ),
       timePrecision: getPropertyValue(
         columnProperties.timePrecision,
-        rowIndex,
-        true,
-      ),
-      currencyCode: getPropertyValue(
-        columnProperties.currencyCode,
-        rowIndex,
-        true,
-      ),
-      decimals: columnProperties.decimals,
-      thousandSeparator: getBooleanPropertyValue(
-        columnProperties.thousandSeparator,
-        rowIndex,
-      ),
-      notation: getPropertyValue(columnProperties.notation, rowIndex, true),
-    } as CellLayoutProperties;
-  }
-
-  return {} as CellLayoutProperties;
-};
-
-const EdtiableColumnTypes: string[] = [
-  ColumnTypes.TEXT,
-  ColumnTypes.NUMBER,
-  ColumnTypes.SELECT,
-  ColumnTypes.CHECKBOX,
-  ColumnTypes.SWITCH,
-  ColumnTypes.DATE,
-  ColumnTypes.CURRENCY,
-];
-
-export function isColumnTypeEditable(
-  columnType: string,
-  isInfiniteScrollEnabled = false,
-) {
-  return EdtiableColumnTypes.includes(columnType) && !isInfiniteScrollEnabled;
-}
-
-/*
- * Nested propeties are not validated when application is refreshed
- * TODO(Balai): Should confirm and create an issue to address this.
- */
-export function getSelectColumnTypeOptions(value: unknown) {
-  const result = SelectColumnOptionsValidations(value, {}, _);
-
-  return result.parsed;
-}
-
-/**
- * returns selected row bg color
- *
- * if the color is dark, use 80% lighter color for selected row
- * if color is light, use 10% darker color for selected row
- *
- * @param accentColor
- */
-export const getSelectedRowBgColor = (accentColor: string) => {
-  const tinyAccentColor = tinycolor(accentColor);
-  const brightness = tinycolor(accentColor).greyscale().getBrightness();
-
-  const percentageBrightness = (brightness / 255) * 100;
-  let nextBrightness = 0;
-
-  switch (true) {
-    case percentageBrightness > 70:
-      nextBrightness = 10;
-      break;
-    case percentageBrightness > 50:
-      nextBrightness = 35;
-      break;
-    case percentageBrightness > 50:
-      nextBrightness = 55;
-      break;
-    default:
-      nextBrightness = 60;
-  }
-
-  if (brightness > 180) {
-    return tinyAccentColor.darken(10).toString();
-  } else {
-    return tinyAccentColor.lighten(nextBrightness).toString();
-  }
-};
-
-/**
- * this is a getter function to get stylesheet value of the property from the config
- *
- * @param props
- * @param propertyPath
- * @param widgetStylesheet
- * @returns
- */
-export const getStylesheetValue = (
-  props: TableWidgetProps,
-  propertyPath: string,
-  widgetStylesheet?: Stylesheet,
-) => {
-  const propertyName = propertyPath.split(".").slice(-1)[0];
-  const columnName = propertyPath.split(".").slice(-2)[0];
-  const columnType = get(props, `primaryColumns.${columnName}.columnType`);
-
-  return get(widgetStylesheet, `childStylesheet.${columnType}.${propertyName}`);
-};
-
-export const reorderColumns = (
-  columns: Record<string, ColumnProperties>,
-  columnOrder: string[],
-) => {
-  const newColumnsInOrder: Record<string, ColumnProperties> = {};
-
-  uniq(columnOrder).forEach((id: string, index: number) => {
-    if (columns[id]) newColumnsInOrder[id] = { ...columns[id], index };
-  });
-  const remaining = without(
-    Object.keys(columns),
-    ...Object.keys(newColumnsInOrder),
-  );
-  const len = Object.keys(newColumnsInOrder).length;
-
-  if (remaining && remaining.length > 0) {
-    remaining.forEach((id: string, index: number) => {
-      newColumnsInOrder[id] = { ...columns[id], index: len + index };
-    });
-  }
-
-  return newColumnsInOrder;
-};
-
-export const getEditActionColumnProperties = () => ({
-  isSaveVisible: true,
-  isDiscardVisible: true,
-  saveIconAlign: "left",
-  discardIconAlign: "left",
-  saveActionLabel: "Save",
-  discardActionLabel: "Discard",
-  saveButtonColor: Colors.GREEN,
-  discardButtonColor: Colors.GREEN,
-});
-
-export const getEditActionColumnDynamicProperties = (widgetName: string) => ({
-  isSaveDisabled: `{{${widgetName}.processedTableData.map((currentRow, currentIndex) => ( !${widgetName}.updatedRowIndices.includes(currentIndex)))}}`,
-  isDiscardDisabled: `{{${widgetName}.processedTableData.map((currentRow, currentIndex) => ( !${widgetName}.updatedRowIndices.includes(currentIndex)))}}`,
-});
-
-export const createColumn = (props: TableWidgetProps, baseName: string) => {
-  const columns = props.primaryColumns || {};
-  const columnsArray = Object.values(columns);
-  const columnIds = columnsArray.map((column) => column.originalId);
-  const newColumnName = getNextEntityName(baseName, columnIds);
-  const lastItemIndex = columnsArray
-    .map((column) => column.index)
-    .sort()
-    .pop();
-
-  const nextIndex = lastItemIndex ? lastItemIndex + 1 : columnIds.length;
-
-  return {
-    ...getDefaultColumnProperties(
-      newColumnName,
-      newColumnName,
-      nextIndex,
-      props.widgetName,
-      true,
-    ),
-    buttonStyle: DEFAULT_BUTTON_COLOR,
-    isDisabled: false,
-    ...getTableStyles(props),
-  };
-};
-
-export const createEditActionColumn = (props: TableWidgetProps) => {
-  const themeProps: Record<string, string> = {};
-
-  if (props.childStylesheet[ColumnTypes.EDIT_ACTIONS]) {
-    Object.entries(props.childStylesheet[ColumnTypes.EDIT_ACTIONS]).forEach(
-      ([key, value]) => {
-        const { jsSnippets, stringSegments } = getDynamicBindings(
-          value as string,
-        );
-
-        const js = combineDynamicBindings(jsSnippets, stringSegments);
-
-        themeProps[key] =
-          `{{${props.widgetName}.processedTableData.map((currentRow, currentIndex) => ( ${js}))}}`;
-      },
-    );
-  }
-
-  const column = {
-    ...createColumn(props, "EditActions"),
-    ...getEditActionColumnProperties(),
-    ...themeProps,
-    columnType: ColumnTypes.EDIT_ACTIONS,
-    label: "Save / Discard",
-    discardButtonVariant: ButtonVariantTypes.TERTIARY,
-    discardButtonColor: Colors.DANGER_SOLID,
-    sticky: StickyType.RIGHT,
-  };
-  const columnOrder = [...(props.columnOrder || [])];
-  const editActionDynamicProperties = getEditActionColumnDynamicProperties(
-    props.widgetName,
-  );
-
-  const rightColumnIndex = columnOrder
-    .map((column) => props.primaryColumns[column])
-    .filter((col) => col.sticky !== StickyType.RIGHT).length;
-
-  columnOrder.splice(rightColumnIndex, 0, column.id);
-
-  return [
-    {
-      propertyPath: `primaryColumns.${column.id}`,
-      propertyValue: {
-        ...column,
-        ...editActionDynamicProperties,
-      },
-    },
-    {
-      propertyPath: `columnOrder`,
-      propertyValue: columnOrder,
-    },
-    ...Object.entries(editActionDynamicProperties).map(([key, value]) => ({
-      propertyPath: `primaryColumns.${column.id}.${key}`,
-      propertyValue: value,
-      isDynamicPropertyPath: true,
-    })),
-  ];
-};
-
-export const getColumnType = (
-  tableData: Array<Record<string, unknown>>,
-  columnKey: string,
-): string => {
-  if (!_.isArray(tableData) || tableData.length === 0 || !columnKey) {
-    return ColumnTypes.TEXT;
-  }
-
-  let columnValue: unknown = null,
-    row = 0;
-  const maxRowsToCheck = 5;
-
-  /*
-    In below while loop we are trying to get a non-null value from
-    subsequent rows in case first few rows are null
-    Limited to checking upto maxRowsToCheck
-  */
-  while (_.isNil(columnValue) && row < maxRowsToCheck) {
-    if (!_.isNil(tableData?.[row]?.[columnKey])) {
-      columnValue = tableData[row][columnKey];
-      break;
-    }
-
-    row++;
-  }
-
-  if (_.isNil(columnValue)) {
-    return ColumnTypes.TEXT;
-  }
-
-  switch (typeof columnValue) {
-    case "number":
-      return ColumnTypes.NUMBER;
-    case "boolean":
-      return ColumnTypes.CHECKBOX;
-    case "string": {
-      const isHTML = /<[^>]*>/.test(columnValue as string);
-
-      if (isHTML) {
-        return ColumnTypes.HTML;
-      }
-
-      const isAnyValidDate = dateFormatOptions.some(({ value: format }) =>
-        moment(columnValue as string, format, true).isValid(),
-      );
-
-      if (isAnyValidDate) {
-        return ColumnTypes.DATE;
-      }
-
-      return ColumnTypes.TEXT;
-    }
-    default:
-      return ColumnTypes.TEXT;
-  }
-};
-
-export const generateLocalNewColumnOrderFromStickyValue = (
-  columnOrder: string[],
-  columnName: string,
-  sticky?: string,
-  leftOrder?: string[],
-  rightOrder?: string[],
-) => {
-  let newColumnOrder = [...columnOrder];
-
-  newColumnOrder = without(newColumnOrder, columnName);
-
-  let columnIndex = -1;
-
-  if (sticky === StickyType.LEFT && leftOrder) {
-    columnIndex = leftOrder.length;
-  } else if (sticky === StickyType.RIGHT && rightOrder) {
-    columnIndex =
-      rightOrder.length !== 0
-        ? columnOrder.indexOf(rightOrder[0]) - 1
-        : columnOrder.length - 1;
-  } else {
-    if (leftOrder?.includes(columnName)) {
-      columnIndex = leftOrder.length - 1;
-    } else if (rightOrder?.includes(columnName)) {
-      columnIndex =
-        rightOrder.length !== 0
-          ? columnOrder.indexOf(rightOrder[0])
-          : columnOrder.length - 1;
-    }
-  }
-
-  newColumnOrder.splice(columnIndex, 0, columnName);
-
-  return newColumnOrder;
-};
-/**
- * Function to get new column order when there is a change in column's sticky value.
- */
-export const generateNewColumnOrderFromStickyValue = (
-  primaryColumns: Record<string, ColumnProperties>,
-  columnOrder: string[],
-  columnName: string,
-  sticky?: string,
-) => {
-  let newColumnOrder = [...columnOrder];
-
-  newColumnOrder = without(newColumnOrder, columnName);
-
-  let columnIndex;
-
-  if (sticky === StickyType.LEFT) {
-    columnIndex = columnOrder
-      .map((column) => primaryColumns[column])
-      .filter((column) => column.sticky === StickyType.LEFT).length;
-  } else if (sticky === StickyType.RIGHT) {
-    columnIndex =
-      columnOrder
-        .map((column) => primaryColumns[column])
-        .filter((column) => column.sticky !== StickyType.RIGHT).length - 1;
-  } else {
-    /**
-     * This block will manage the column order when column is unfrozen.
-     * Unfreezing can happen in CANVAS or PAGE mode.
-     * Logic:
-     * --> If the column is unfrozen when its on the left, then it should be unfrozen after the last left frozen column.
-     * --> If the column is unfrozen when its on the right, then it should be unfrozen before the first right frozen column.
-     */
-    columnIndex = -1;
-
-    const staleStickyValue = primaryColumns[columnName].sticky;
-
-    if (staleStickyValue === StickyType.LEFT) {
-      columnIndex = columnOrder
-        .map((column) => primaryColumns[column])
-        .filter(
-          (column) =>
-            column.sticky === StickyType.LEFT && column.id !== columnName,
-        ).length;
-    } else if (staleStickyValue === StickyType.RIGHT) {
-      columnIndex = columnOrder
-        .map((column) => primaryColumns[column])
-        .filter((column) => column.sticky !== StickyType.RIGHT).length;
-    }
-  }
-
-  newColumnOrder.splice(columnIndex, 0, columnName);
-
-  return newColumnOrder;
-};
-
-export const getSourceDataAndCaluclateKeysForEventAutoComplete = (
-  props: TableWidgetProps,
-): unknown => {
-  const { __evaluation__, primaryColumns } = props;
-  const primaryColumnKeys = primaryColumns ? Object.keys(primaryColumns) : [];
-  const columnName = primaryColumnKeys?.length ? primaryColumnKeys[0] : "";
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  const evaluatedColumns: any = __evaluation__?.evaluatedValues?.primaryColumns;
-
-  if (evaluatedColumns) {
-    const result = getKeysFromSourceDataForEventAutocomplete(
-      evaluatedColumns[columnName]?.sourceData || [],
-    );
-
-    return result;
-  } else {
-    return {};
-  }
-};
-
-export const deleteLocalTableColumnOrderByWidgetId = (widgetId: string) => {
-  try {
-    const localData = localStorage.getItem(TABLE_COLUMN_ORDER_KEY);
-
-    if (localData) {
-      const localColumnOrder = JSON.parse(localData);
-
-      delete localColumnOrder[widgetId];
-      localStorage.setItem(
-        TABLE_COLUMN_ORDER_KEY,
-        JSON.stringify(localColumnOrder),
-      );
-    }
-  } catch (e) {
-    log.debug("Error in reading local data", e);
-  }
-};
-
-export const updateAndSyncTableLocalColumnOrders = (
-  columnName: string,
-  leftOrder: string[],
-  rightOrder: string[],
-  sticky?: StickyType,
-) => {
-  if (sticky === StickyType.LEFT) {
-    leftOrder.push(columnName);
-
-    if (rightOrder) {
-      rightOrder = without(rightOrder, columnName);
-    }
-  } else if (sticky === StickyType.RIGHT) {
-    rightOrder.unshift(columnName);
-
-    // When column is frozen to right from left. Remove the column name from leftOrder
-    if (leftOrder) {
-      leftOrder = without(leftOrder, columnName);
-    }
-  } else {
-    // remove column from both orders:
-    leftOrder = without(leftOrder, columnName);
-    rightOrder = without(rightOrder, columnName);
-  }
-
-  return { leftOrder, rightOrder };
-};
-
-export const getColumnOrderByWidgetIdFromLS = (widgetId: string) => {
-  const localTableWidgetColumnOrder = localStorage.getItem(
-    TABLE_COLUMN_ORDER_KEY,
-  );
-
-  if (localTableWidgetColumnOrder) {
-    try {
-      const parsedTableWidgetColumnOrder = JSON.parse(
-        localTableWidgetColumnOrder,
-      );
-
-      if (parsedTableWidgetColumnOrder[widgetId]) {
-        const { columnOrder, columnUpdatedAt, leftOrder, rightOrder } =
-          parsedTableWidgetColumnOrder[widgetId];
-
-        return {
-          columnOrder,
-          columnUpdatedAt,
-          leftOrder,
-          rightOrder,
-        };
-      }
-    } catch (e) {
-      log.debug("Unable to parse local column order:", { e });
-    }
-  }
-};
-
-export const getAllStickyColumnsCount = (columns: TableColumnProps[]) => {
-  return (
-    filter(columns, { sticky: StickyType.LEFT }).length +
-    filter(columns, { sticky: StickyType.RIGHT }).length
-  );
-};
-
-/**
- *
- * @param currentIndex: current dragging item index
- * @param targetIndex: Index poistion of of header that is being hovered
- * @returns
- */
-export const getHeaderClassNameOnDragDirection = (
-  currentIndex: number,
-  targetIndex: number,
-) => {
-  let parentClasses = "th header-reorder";
-
-  if (currentIndex !== -1) {
-    if (targetIndex > currentIndex) {
-      parentClasses += " highlight-right";
-    } else if (targetIndex < currentIndex) {
-      parentClasses += " highlight-left";
-    }
-  }
-
-  return parentClasses;
-};
-
-export const getIndexByColumnName = (
-  columnName: string,
-  columnOrder?: string[],
-) => {
-  let currentIndex = -1;
-
-  if (columnOrder) {
-    currentIndex = columnOrder.indexOf(columnName);
-  }
-
-  return currentIndex;
-};
-
-/**
- * A function to get all drag and drop handlers for HeaderCell component.
- * @param columns: React table columns
- * @param currentDraggedColumn: The Mutable ref object that references column being dragged
- * @param handleReorderColumn : Function to handle column reordering.
- * @param columnOrder
- * @returns
- */
-export const getDragHandlers = (
-  columns: ReactTableColumnProps[],
-  currentDraggedColumn: React.MutableRefObject<string>,
-  handleReorderColumn: (columnOrder: string[]) => void,
-  columnOrder?: string[],
-) => {
-  const onDrag = (e: React.DragEvent<HTMLDivElement>) => {
-    e.stopPropagation();
-  };
-
-  const onDragEnter = (
-    e: React.DragEvent<HTMLDivElement>,
-    targetIndex: number,
-  ) => {
-    // We get the parent element(.th) so as to apply left and right highlighting
-    const targetElem = e.target as HTMLDivElement;
-    const parentTargetElem = targetElem.closest(".th.header-reorder");
-
-    const currentIndex = getIndexByColumnName(
-      currentDraggedColumn.current,
-      columnOrder,
-    );
-
-    if (parentTargetElem) {
-      parentTargetElem.className = getHeaderClassNameOnDragDirection(
-        currentIndex,
-        targetIndex,
-      );
-    }
-
-    e.stopPropagation();
-    e.preventDefault();
-  };
-
-  const onDragEnd = (e: React.DragEvent<HTMLDivElement>) => {
-    const targetElem = e.target as HTMLDivElement;
-
-    targetElem.className = targetElem.className.replace(
-      " draggable-header--dragging",
-      "",
-    );
-    e.preventDefault();
-  };
-
-  const onDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
-    const targetElem = e.target as HTMLDivElement;
-    const parentTargetElem = targetElem.closest(".th.header-reorder");
-
-    if (parentTargetElem) {
-      parentTargetElem.className = "th header-reorder";
-    }
-
-    e.preventDefault();
-  };
-  const onDragOver = (
-    e: React.DragEvent<HTMLDivElement>,
-    targetIndex: number,
-  ) => {
-    // We get the parent element(.th) so as to apply left and right highlighting
-    const targetElem = e.target as HTMLDivElement;
-    const parentTargetElem = targetElem.closest(".th.header-reorder");
-
-    const currentIndex = getIndexByColumnName(
-      currentDraggedColumn.current,
-      columnOrder,
-    );
-
-    if (parentTargetElem) {
-      parentTargetElem.className = getHeaderClassNameOnDragDirection(
-        currentIndex,
-        targetIndex,
-      );
-    }
-
-    e.stopPropagation();
-    e.preventDefault();
-  };
-
-  const onDragStart = (e: React.DragEvent<HTMLDivElement>, index: number) => {
-    currentDraggedColumn.current = columns[index].alias;
-    const targetElem = e.target as HTMLDivElement;
-
-    targetElem.className = targetElem.className + " draggable-header--dragging";
-    e.stopPropagation();
-  };
-
-  const onDrop = (e: React.DragEvent<HTMLDivElement>, index: number) => {
-    const targetElem = e.target as HTMLDivElement;
-
-    if (currentDraggedColumn.current) {
-      const partialColumnOrder = without(
-        columnOrder,
-        currentDraggedColumn.current,
-      );
-
-      partialColumnOrder.splice(index, 0, currentDraggedColumn.current);
-      handleReorderColumn(partialColumnOrder);
-    }
-
-    targetElem.className = targetElem.className.replace(
-      " draggable-header--dragging",
-      "",
-    );
-    e.stopPropagation();
-  };
-
-  return {
-    onDrag,
-    onDragEnd,
-    onDragEnter,
-    onDragLeave,
-    onDragOver,
-    onDragStart,
-    onDrop,
-  };
-};
-
-export const getSelectOptions = (
-  isNewRow: boolean,
-  rowIndex: number,
-  columnProperties: ColumnProperties,
-) => {
-  if (isNewRow) {
-    if (
-      columnProperties.allowSameOptionsInNewRow &&
-      columnProperties?.selectOptions
-    ) {
-      // Use select options from the first row
-      return getArrayPropertyValue(columnProperties.selectOptions, 0);
-    } else {
-      return columnProperties.newRowSelectOptions;
-    }
-  } else {
-    return getArrayPropertyValue(columnProperties.selectOptions, rowIndex);
-  }
-};
-
-export function convertNumToCompactString(num: number) {
-  if (num >= 1e6) {
-    return (num / 1e6).toFixed(1) + "M";
-  } else if (num >= 1e3) {
-    return (num / 1e3).toFixed(1) + "K";
-  } else {
-    return num.toString();
-  }
-}
+        rowIndex,
\ No newline at end of file
