{
    "cost": 1.1132300000000002,
    "rewrites": {
        "appsmithorg__appsmith.7046aeb3/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx": {
            "output": "import React, {\n  createRef,\n  useCallback,\n  useEffect,\n  useState,\n  memo,\n} from \"react\";\nimport { MenuItem, Tooltip, Menu } from \"@blueprintjs/core\";\n\nimport { Colors } from \"constants/Colors\";\nimport styled from \"styled-components\";\nimport { ControlIcons } from \"icons/ControlIcons\";\nimport type { CellAlignment } from \"../Constants\";\nimport {\n  HEADER_MENU_PORTAL_CLASS,\n  JUSTIFY_CONTENT,\n  MENU_CONTENT_CLASS,\n  MULTISELECT_CHECKBOX_WIDTH,\n  POPOVER_ITEMS_TEXT_MAP,\n  StickyType,\n} from \"../Constants\";\nimport { TooltipContentWrapper } from \"../TableStyledWrappers\";\nimport { isColumnTypeEditable } from \"widgets/TableWidgetV2/widget/utilities\";\nimport { Popover2 } from \"@blueprintjs/popover2\";\nimport { MenuDivider } from \"@design-system/widgets-old\";\nimport { importRemixIcon, importSvg } from \"@design-system/widgets-old\";\nimport { CANVAS_ART_BOARD } from \"constants/componentClassNameConstants\";\nimport { useAppsmithTable } from \"../TableContext\";\n\nconst Check = importRemixIcon(\n  async () => import(\"remixicon-react/CheckFillIcon\"),\n);\nconst ArrowDownIcon = importRemixIcon(\n  async () => import(\"remixicon-react/ArrowDownSLineIcon\"),\n);\nconst EditIcon = importSvg(\n  async () => import(\"assets/icons/control/edit-variant1.svg\"),\n);\n\nconst AscendingIcon = styled(ControlIcons.SORT_CONTROL)`\n  padding: 0;\n  position: relative;\n  top: 3px;\n  cursor: pointer;\n  transform: rotate(180deg);\n  && svg {\n    path {\n      fill: ${Colors.LIGHT_GREYISH_BLUE};\n    }\n  }\n`;\n\nconst DescendingIcon = styled(ControlIcons.SORT_CONTROL)`\n  padding: 0;\n  position: relative;\n  top: 3px;\n  cursor: pointer;\n  && svg {\n    path {\n      fill: ${Colors.LIGHT_GREYISH_BLUE};\n    }\n  }\n`;\n\nconst ColumnNameContainer = styled.div<{\n  horizontalAlignment: CellAlignment;\n}>`\n  display: flex;\n  align-items: center;\n  justify-content: ${(props) =>\n    props?.horizontalAlignment && JUSTIFY_CONTENT[props.horizontalAlignment]};\n`;\n\nconst StyledEditIcon = styled(EditIcon)`\n  width: 14px;\n  min-width: 14px;\n  margin-right: 3px;\n`;\n\nconst TitleWrapper = styled.div`\n  &,\n  span {\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n`;\n\ninterface TitleProps {\n  children: React.ReactNode;\n  tableWidth?: number;\n  width?: number;\n}\n\nfunction Title(props: TitleProps) {\n  const ref = createRef<HTMLDivElement>();\n  const [useToolTip, updateToolTip] = useState(false);\n\n  useEffect(() => {\n    const element = ref.current;\n\n    if (element && element.offsetWidth < element.scrollWidth) {\n      updateToolTip(true);\n    } else {\n      updateToolTip(false);\n    }\n  }, [ref.current, props.width, props.children]);\n\n  return (\n    <TitleWrapper ref={ref}>\n      {useToolTip && props.children ? (\n        <Tooltip\n          autoFocus={false}\n          content={\n            <TooltipContentWrapper width={(props.tableWidth || 300) - 32}>\n              {props.children}\n            </TooltipContentWrapper>\n          }\n          hoverOpenDelay={1000}\n          position=\"top\"\n        >\n          {props.children}\n        </Tooltip>\n      ) : (\n        props.children\n      )}\n    </TitleWrapper>\n  );\n}\n\nconst ICON_SIZE = 16;\n\ninterface HeaderProps {\n  columnName: string;\n  columnIndex: number;\n  isHidden: boolean;\n  isAscOrder?: boolean;\n  columnOrder?: string[];\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  column: any;\n  stickyRightModifier: string;\n  onDrag: (e: React.DragEvent<HTMLDivElement>) => void;\n  onDragEnter: (\n    e: React.DragEvent<HTMLDivElement>,\n    destinationIndex: number,\n  ) => void;\n  onDragStart: (e: React.DragEvent<HTMLDivElement>, index: number) => void;\n  onDrop: (e: React.DragEvent<HTMLDivElement>, index: number) => void;\n  onDragEnd: (e: React.DragEvent<HTMLDivElement>) => void;\n  onDragLeave: (e: React.DragEvent<HTMLDivElement>) => void;\n  onDragOver: (\n    e: React.DragEvent<HTMLDivElement>,\n    destinationIndex: number,\n  ) => void;\n}\n\nconst HeaderCellComponent = (props: HeaderProps) => {\n  const {\n    canFreezeColumn,\n    editMode,\n    handleColumnFreeze,\n    isInfiniteScrollEnabled,\n    isResizingColumn,\n    isSortable,\n    multiRowSelection,\n    sortTableColumn,\n    widgetId,\n    width,\n  } = useAppsmithTable();\n  const [isMenuOpen, setIsMenuOpen] = useState(false);\n\n  const headerProps = { ...props.column.getHeaderProps() };\n\n  headerProps[\"style\"] = {\n    ...headerProps.style,\n    left:\n      props.column.sticky === StickyType.LEFT && multiRowSelection\n        ? MULTISELECT_CHECKBOX_WIDTH + props.column.totalLeft\n        : headerProps.style.left,\n  };\n  const handleSortColumn = () => {\n    if (isResizingColumn.current) return;\n\n    let columnIndex = props.columnIndex;\n\n    if (props.isAscOrder === true) {\n      columnIndex = -1;\n    }\n\n    const sortOrder =\n      props.isAscOrder === undefined ? false : !props.isAscOrder;\n\n    sortTableColumn(columnIndex, sortOrder);\n  };\n\n  const disableSort =\n    isInfiniteScrollEnabled || (editMode === false && isSortable === false);\n\n  const isColumnEditable =\n    props.column.columnProperties.isCellEditable &&\n    props.column.columnProperties.isEditable &&\n    isColumnTypeEditable(props.column.columnProperties.columnType);\n\n  const toggleColumnFreeze = (value: StickyType) => {\n    handleColumnFreeze &&\n      handleColumnFreeze(\n        props.column.id,\n        props.column.sticky !== value ? value : StickyType.NONE,\n      );\n  };\n\n  const onDragStart = useCallback(\n    (e) => {\n      props.onDragStart(e, props.columnIndex);\n    },\n    [props.columnIndex, props.onDragStart],\n  );\n  const onDragEnter = useCallback(\n    (e) => {\n      if (props.column.sticky === StickyType.NONE && !props.isHidden) {\n        props.onDragEnter(e, props.columnIndex);\n      }\n    },\n    [props.onDragEnter, props.column.sticky, props.columnIndex, props.isHidden],\n  );\n\n  const onDragLeave = useCallback(\n    (e) => {\n      if (props.column.sticky === StickyType.NONE && !props.isHidden) {\n        props.onDragLeave(e);\n      }\n    },\n    [props.onDragLeave, props.column.sticky, props.isHidden],\n  );\n\n  const onDragOver = useCallback(\n    (e) => {\n      // Below condition will disable the ability to drop a column on a frozen column\n      if (props.column.sticky === StickyType.NONE && !props.isHidden) {\n        props.onDragOver(e, props.columnIndex);\n      }\n    },\n    [props.onDragOver, props.column.sticky, props.columnIndex, props.isHidden],\n  );\n\n  const onDrop = useCallback(\n    (e) => {\n      props.onDrop(e, props.columnIndex);\n    },\n    [props.onDrop, props.columnIndex],\n  );\n\n  return (\n    <div\n      {...headerProps}\n      className={`th header-reorder ${props.stickyRightModifier}`}\n      data-header={props.columnName}\n    >\n      <div\n        className={!props.isHidden ? `draggable-header` : \"hidden-header\"}\n        draggable={\n          (props.column.sticky === StickyType.NONE && !props.isHidden) ||\n          undefined\n        }\n        onClick={!disableSort && props ? handleSortColumn : undefined}\n        onDrag={props.onDrag}\n        onDragEnd={props.onDragEnd}\n        onDragEnter={onDragEnter}\n        onDragLeave={onDragLeave}\n        onDragOver={onDragOver}\n        onDragStart={onDragStart}\n        onDrop={onDrop}\n      >\n        <ColumnNameContainer\n          horizontalAlignment={\n            props.column.columnProperties.horizontalAlignment\n          }\n        >\n          {isColumnEditable && <StyledEditIcon />}\n          <Title width={width}>\n            {props.columnName.replace(/\\s/g, \"\\u00a0\")}\n          </Title>\n        </ColumnNameContainer>\n      </div>\n      <div\n        className={`header-menu ${\n          !isSortable && !canFreezeColumn && \"hide-menu\"\n        } ${!isMenuOpen && \"hide\"}`}\n      >\n        <Popover2\n          content={\n            <Menu className={MENU_CONTENT_CLASS}>\n              <MenuItem\n                disabled={disableSort}\n                labelElement={props.isAscOrder === true ? <Check /> : undefined}\n                onClick={() => {\n                  sortTableColumn(props.columnIndex, true);\n                }}\n                text={POPOVER_ITEMS_TEXT_MAP.SORT_ASC}\n              />\n              <MenuItem\n                disabled={disableSort}\n                labelElement={\n                  props.isAscOrder === false ? <Check /> : undefined\n                }\n                onClick={() => {\n                  sortTableColumn(props.columnIndex, false);\n                }}\n                text={POPOVER_ITEMS_TEXT_MAP.SORT_DSC}\n              />\n              <MenuDivider\n                style={{\n                  marginLeft: 0,\n                  marginRight: 0,\n                }}\n              />\n              <MenuItem\n                disabled={!canFreezeColumn}\n                labelElement={\n                  props.column.sticky === StickyType.LEFT ? (\n                    <Check />\n                  ) : undefined\n                }\n                onClick={() => {\n                  toggleColumnFreeze(StickyType.LEFT);\n                }}\n                text={POPOVER_ITEMS_TEXT_MAP.FREEZE_LEFT}\n              />\n              <MenuItem\n                disabled={!canFreezeColumn}\n                labelElement={\n                  props.column.sticky === StickyType.RIGHT ? (\n                    <Check />\n                  ) : undefined\n                }\n                onClick={() => {\n                  toggleColumnFreeze(StickyType.RIGHT);\n                }}\n                text={POPOVER_ITEMS_TEXT_MAP.FREEZE_RIGHT}\n              />\n            </Menu>\n          }\n          interactionKind=\"hover\"\n          isOpen={isMenuOpen}\n          minimal\n          onInteraction={setIsMenuOpen}\n          placement=\"bottom-end\"\n          portalClassName={`${HEADER_MENU_PORTAL_CLASS}-${widgetId}`}\n          portalContainer={\n            document.getElementById(CANVAS_ART_BOARD) || undefined\n          }\n        >\n          <ArrowDownIcon className=\"w-5 h-5\" color=\"var(--wds-color-icon)\" />\n        </Popover2>\n      </div>\n      {props.isAscOrder !== undefined ? (\n        <div>\n          {props.isAscOrder ? (\n            <AscendingIcon height={ICON_SIZE} width={ICON_SIZE} />\n          ) : (\n            <DescendingIcon height={ICON_SIZE} width={ICON_SIZE} />\n          )}\n        </div>\n      ) : null}\n      <div\n        {...props.column.getResizerProps()}\n        className={`resizer ${props.column.isResizing ? \"isResizing\" : \"\"}`}\n        onClick={(e: React.MouseEvent<HTMLElement>) => {\n          e.preventDefault();\n          e.stopPropagation();\n        }}\n      />\n    </div>\n  );\n};\n\nexport const HeaderCell = memo(HeaderCellComponent);",
            "output_extracted": "import React, {\n  createRef,\n  useCallback,\n  useEffect,\n  useState,\n  memo,\n} from \"react\";\nimport { MenuItem, Tooltip, Menu } from \"@blueprintjs/core\";\n\nimport { Colors } from \"constants/Colors\";\nimport styled from \"styled-components\";\nimport { ControlIcons } from \"icons/ControlIcons\";\nimport type { CellAlignment } from \"../Constants\";\nimport {\n  HEADER_MENU_PORTAL_CLASS,\n  JUSTIFY_CONTENT,\n  MENU_CONTENT_CLASS,\n  MULTISELECT_CHECKBOX_WIDTH,\n  POPOVER_ITEMS_TEXT_MAP,\n  StickyType,\n} from \"../Constants\";\nimport { TooltipContentWrapper } from \"../TableStyledWrappers\";\nimport { isColumnTypeEditable } from \"widgets/TableWidgetV2/widget/utilities\";\nimport { Popover2 } from \"@blueprintjs/popover2\";\nimport { MenuDivider } from \"@design-system/widgets-old\";\nimport { importRemixIcon, importSvg } from \"@design-system/widgets-old\";\nimport { CANVAS_ART_BOARD } from \"constants/componentClassNameConstants\";\nimport { useAppsmithTable } from \"../TableContext\";\n\nconst Check = importRemixIcon(\n  async () => import(\"remixicon-react/CheckFillIcon\"),\n);\nconst ArrowDownIcon = importRemixIcon(\n  async () => import(\"remixicon-react/ArrowDownSLineIcon\"),\n);\nconst EditIcon = importSvg(\n  async () => import(\"assets/icons/control/edit-variant1.svg\"),\n);\n\nconst AscendingIcon = styled(ControlIcons.SORT_CONTROL)`\n  padding: 0;\n  position: relative;\n  top: 3px;\n  cursor: pointer;\n  transform: rotate(180deg);\n  && svg {\n    path {\n      fill: ${Colors.LIGHT_GREYISH_BLUE};\n    }\n  }\n`;\n\nconst DescendingIcon = styled(ControlIcons.SORT_CONTROL)`\n  padding: 0;\n  position: relative;\n  top: 3px;\n  cursor: pointer;\n  && svg {\n    path {\n      fill: ${Colors.LIGHT_GREYISH_BLUE};\n    }\n  }\n`;\n\nconst ColumnNameContainer = styled.div<{\n  horizontalAlignment: CellAlignment;\n}>`\n  display: flex;\n  align-items: center;\n  justify-content: ${(props) =>\n    props?.horizontalAlignment && JUSTIFY_CONTENT[props.horizontalAlignment]};\n`;\n\nconst StyledEditIcon = styled(EditIcon)`\n  width: 14px;\n  min-width: 14px;\n  margin-right: 3px;\n`;\n\nconst TitleWrapper = styled.div`\n  &,\n  span {\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n`;\n\ninterface TitleProps {\n  children: React.ReactNode;\n  tableWidth?: number;\n  width?: number;\n}\n\nfunction Title(props: TitleProps) {\n  const ref = createRef<HTMLDivElement>();\n  const [useToolTip, updateToolTip] = useState(false);\n\n  useEffect(() => {\n    const element = ref.current;\n\n    if (element && element.offsetWidth < element.scrollWidth) {\n      updateToolTip(true);\n    } else {\n      updateToolTip(false);\n    }\n  }, [ref.current, props.width, props.children]);\n\n  return (\n    <TitleWrapper ref={ref}>\n      {useToolTip && props.children ? (\n        <Tooltip\n          autoFocus={false}\n          content={\n            <TooltipContentWrapper width={(props.tableWidth || 300) - 32}>\n              {props.children}\n            </TooltipContentWrapper>\n          }\n          hoverOpenDelay={1000}\n          position=\"top\"\n        >\n          {props.children}\n        </Tooltip>\n      ) : (\n        props.children\n      )}\n    </TitleWrapper>\n  );\n}\n\nconst ICON_SIZE = 16;\n\ninterface HeaderProps {\n  columnName: string;\n  columnIndex: number;\n  isHidden: boolean;\n  isAscOrder?: boolean;\n  columnOrder?: string[];\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  column: any;\n  stickyRightModifier: string;\n  onDrag: (e: React.DragEvent<HTMLDivElement>) => void;\n  onDragEnter: (\n    e: React.DragEvent<HTMLDivElement>,\n    destinationIndex: number,\n  ) => void;\n  onDragStart: (e: React.DragEvent<HTMLDivElement>, index: number) => void;\n  onDrop: (e: React.DragEvent<HTMLDivElement>, index: number) => void;\n  onDragEnd: (e: React.DragEvent<HTMLDivElement>) => void;\n  onDragLeave: (e: React.DragEvent<HTMLDivElement>) => void;\n  onDragOver: (\n    e: React.DragEvent<HTMLDivElement>,\n    destinationIndex: number,\n  ) => void;\n}\n\nconst HeaderCellComponent = (props: HeaderProps) => {\n  const {\n    canFreezeColumn,\n    editMode,\n    handleColumnFreeze,\n    isInfiniteScrollEnabled,\n    isResizingColumn,\n    isSortable,\n    multiRowSelection,\n    sortTableColumn,\n    widgetId,\n    width,\n  } = useAppsmithTable();\n  const [isMenuOpen, setIsMenuOpen] = useState(false);\n\n  const headerProps = { ...props.column.getHeaderProps() };\n\n  headerProps[\"style\"] = {\n    ...headerProps.style,\n    left:\n      props.column.sticky === StickyType.LEFT && multiRowSelection\n        ? MULTISELECT_CHECKBOX_WIDTH + props.column.totalLeft\n        : headerProps.style.left,\n  };\n  const handleSortColumn = () => {\n    if (isResizingColumn.current) return;\n\n    let columnIndex = props.columnIndex;\n\n    if (props.isAscOrder === true) {\n      columnIndex = -1;\n    }\n\n    const sortOrder =\n      props.isAscOrder === undefined ? false : !props.isAscOrder;\n\n    sortTableColumn(columnIndex, sortOrder);\n  };\n\n  const disableSort =\n    isInfiniteScrollEnabled || (editMode === false && isSortable === false);\n\n  const isColumnEditable =\n    props.column.columnProperties.isCellEditable &&\n    props.column.columnProperties.isEditable &&\n    isColumnTypeEditable(props.column.columnProperties.columnType);\n\n  const toggleColumnFreeze = (value: StickyType) => {\n    handleColumnFreeze &&\n      handleColumnFreeze(\n        props.column.id,\n        props.column.sticky !== value ? value : StickyType.NONE,\n      );\n  };\n\n  const onDragStart = useCallback(\n    (e) => {\n      props.onDragStart(e, props.columnIndex);\n    },\n    [props.columnIndex, props.onDragStart],\n  );\n  const onDragEnter = useCallback(\n    (e) => {\n      if (props.column.sticky === StickyType.NONE && !props.isHidden) {\n        props.onDragEnter(e, props.columnIndex);\n      }\n    },\n    [props.onDragEnter, props.column.sticky, props.columnIndex, props.isHidden],\n  );\n\n  const onDragLeave = useCallback(\n    (e) => {\n      if (props.column.sticky === StickyType.NONE && !props.isHidden) {\n        props.onDragLeave(e);\n      }\n    },\n    [props.onDragLeave, props.column.sticky, props.isHidden],\n  );\n\n  const onDragOver = useCallback(\n    (e) => {\n      // Below condition will disable the ability to drop a column on a frozen column\n      if (props.column.sticky === StickyType.NONE && !props.isHidden) {\n        props.onDragOver(e, props.columnIndex);\n      }\n    },\n    [props.onDragOver, props.column.sticky, props.columnIndex, props.isHidden],\n  );\n\n  const onDrop = useCallback(\n    (e) => {\n      props.onDrop(e, props.columnIndex);\n    },\n    [props.onDrop, props.columnIndex],\n  );\n\n  return (\n    <div\n      {...headerProps}\n      className={`th header-reorder ${props.stickyRightModifier}`}\n      data-header={props.columnName}\n    >\n      <div\n        className={!props.isHidden ? `draggable-header` : \"hidden-header\"}\n        draggable={\n          (props.column.sticky === StickyType.NONE && !props.isHidden) ||\n          undefined\n        }\n        onClick={!disableSort && props ? handleSortColumn : undefined}\n        onDrag={props.onDrag}\n        onDragEnd={props.onDragEnd}\n        onDragEnter={onDragEnter}\n        onDragLeave={onDragLeave}\n        onDragOver={onDragOver}\n        onDragStart={onDragStart}\n        onDrop={onDrop}\n      >\n        <ColumnNameContainer\n          horizontalAlignment={\n            props.column.columnProperties.horizontalAlignment\n          }\n        >\n          {isColumnEditable && <StyledEditIcon />}\n          <Title width={width}>\n            {props.columnName.replace(/\\s/g, \"\\u00a0\")}\n          </Title>\n        </ColumnNameContainer>\n      </div>\n      <div\n        className={`header-menu ${\n          !isSortable && !canFreezeColumn && \"hide-menu\"\n        } ${!isMenuOpen && \"hide\"}`}\n      >\n        <Popover2\n          content={\n            <Menu className={MENU_CONTENT_CLASS}>\n              <MenuItem\n                disabled={disableSort}\n                labelElement={props.isAscOrder === true ? <Check /> : undefined}\n                onClick={() => {\n                  sortTableColumn(props.columnIndex, true);\n                }}\n                text={POPOVER_ITEMS_TEXT_MAP.SORT_ASC}\n              />\n              <MenuItem\n                disabled={disableSort}\n                labelElement={\n                  props.isAscOrder === false ? <Check /> : undefined\n                }\n                onClick={() => {\n                  sortTableColumn(props.columnIndex, false);\n                }}\n                text={POPOVER_ITEMS_TEXT_MAP.SORT_DSC}\n              />\n              <MenuDivider\n                style={{\n                  marginLeft: 0,\n                  marginRight: 0,\n                }}\n              />\n              <MenuItem\n                disabled={!canFreezeColumn}\n                labelElement={\n                  props.column.sticky === StickyType.LEFT ? (\n                    <Check />\n                  ) : undefined\n                }\n                onClick={() => {\n                  toggleColumnFreeze(StickyType.LEFT);\n                }}\n                text={POPOVER_ITEMS_TEXT_MAP.FREEZE_LEFT}\n              />\n              <MenuItem\n                disabled={!canFreezeColumn}\n                labelElement={\n                  props.column.sticky === StickyType.RIGHT ? (\n                    <Check />\n                  ) : undefined\n                }\n                onClick={() => {\n                  toggleColumnFreeze(StickyType.RIGHT);\n                }}\n                text={POPOVER_ITEMS_TEXT_MAP.FREEZE_RIGHT}\n              />\n            </Menu>\n          }\n          interactionKind=\"hover\"\n          isOpen={isMenuOpen}\n          minimal\n          onInteraction={setIsMenuOpen}\n          placement=\"bottom-end\"\n          portalClassName={`${HEADER_MENU_PORTAL_CLASS}-${widgetId}`}\n          portalContainer={\n            document.getElementById(CANVAS_ART_BOARD) || undefined\n          }\n        >\n          <ArrowDownIcon className=\"w-5 h-5\" color=\"var(--wds-color-icon)\" />\n        </Popover2>\n      </div>\n      {props.isAscOrder !== undefined ? (\n        <div>\n          {props.isAscOrder ? (\n            <AscendingIcon height={ICON_SIZE} width={ICON_SIZE} />\n          ) : (\n            <DescendingIcon height={ICON_SIZE} width={ICON_SIZE} />\n          )}\n        </div>\n      ) : null}\n      <div\n        {...props.column.getResizerProps()}\n        className={`resizer ${props.column.isResizing ? \"isResizing\" : \"\"}`}\n        onClick={(e: React.MouseEvent<HTMLElement>) => {\n          e.preventDefault();\n          e.stopPropagation();\n        }}\n      />\n    </div>\n  );\n};\n\nexport const HeaderCell = memo(HeaderCellComponent);",
            "cost": 0.105145
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts": {
            "output": "import { updateAllowAddNewRowOnInfiniteScrollChange } from \"../propertyUtils\";\nimport {\n  totalRecordsCountValidation,\n  uniqueColumnNameValidation,\n  updateColumnStyles,\n  updateColumnOrderHook,\n  getBasePropertyPath,\n  hideByColumnType,\n  uniqueColumnAliasValidation,\n  updateCustomColumnAliasOnLabelChange,\n  selectColumnOptionsValidation,\n  allowedFirstDayOfWeekRange,\n  updateCellEditabilityOnInfiniteScrollChange,\n  updateSearchSortFilterOnInfiniteScrollChange,\n} from \"../propertyUtils\";\nimport _ from \"lodash\";\nimport type { ColumnTypes, TableWidgetProps } from \"../../constants\";\nimport { StickyType } from \"../../component/Constants\";\n\ndescribe(\"PropertyUtils - \", () => {\n  it(\"totalRecordsCountValidation - should test with all possible values\", () => {\n    const ERROR_MESSAGE = [\n      { name: \"ValidationError\", message: \"This value must be a number\" },\n    ];\n\n    const values = [\n      [\n        undefined,\n        {\n          isValid: true,\n          parsed: 0,\n          messages: [],\n        },\n      ],\n      [\n        null,\n        {\n          isValid: true,\n          parsed: 0,\n          messages: [],\n        },\n      ],\n      [\n        \"\",\n        {\n          isValid: true,\n          parsed: 0,\n          messages: [],\n        },\n      ],\n      [\n        {},\n        {\n          isValid: false,\n          parsed: 0,\n          messages: ERROR_MESSAGE,\n        },\n      ],\n      [\n        [],\n        {\n          isValid: false,\n          parsed: 0,\n          messages: ERROR_MESSAGE,\n        },\n      ],\n      [\n        \"test\",\n        {\n          isValid: false,\n          parsed: 0,\n          messages: ERROR_MESSAGE,\n        },\n      ],\n      [\n        \"1\",\n        {\n          isValid: true,\n          parsed: 1,\n          messages: [],\n        },\n      ],\n      [\n        1,\n        {\n          isValid: true,\n          parsed: 1,\n          messages: [],\n        },\n      ],\n    ];\n\n    values.forEach(([input, expected]) => {\n      expect(\n        totalRecordsCountValidation(input, {} as TableWidgetProps, _),\n      ).toEqual(expected);\n    });\n  });\n\n  it(\"uniqueColumnNameValidation - should test with all possible values\", () => {\n    let value = [\n      {\n        label: \"column1\",\n      },\n      {\n        label: \"column2\",\n      },\n      {\n        label: \"column3\",\n      },\n    ];\n\n    expect(\n      uniqueColumnNameValidation(value, {} as TableWidgetProps, _),\n    ).toEqual({\n      isValid: true,\n      parsed: value,\n      messages: [\"\"],\n    });\n\n    value = [\n      {\n        label: \"column1\",\n      },\n      {\n        label: \"column2\",\n      },\n      {\n        label: \"column1\",\n      },\n    ];\n\n    expect(\n      uniqueColumnNameValidation(value, {} as TableWidgetProps, _),\n    ).toEqual({\n      isValid: false,\n      parsed: value,\n      messages: [\"Column names should be unique.\"],\n    });\n  });\n\n  it(\"updateColumnStyles - should test with all possible values\", () => {\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let props: any = {\n      primaryColumns: {\n        1: {\n          id: 1,\n          style: \"someRandomStyleValue\",\n        },\n        2: {\n          id: 2,\n          style: \"someRandomStyleValue\",\n        },\n        3: {\n          id: 3,\n          style: \"someRandomStyleValue\",\n        },\n      },\n    };\n\n    expect(\n      updateColumnStyles(\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        props as any as TableWidgetProps,\n        \"style\",\n        \"someOtherRandomStyleValue\",\n      ),\n    ).toEqual([\n      {\n        propertyPath: \"primaryColumns.1.style\",\n        propertyValue: \"someOtherRandomStyleValue\",\n      },\n      {\n        propertyPath: \"primaryColumns.2.style\",\n        propertyValue: \"someOtherRandomStyleValue\",\n      },\n      {\n        propertyPath: \"primaryColumns.3.style\",\n        propertyValue: \"someOtherRandomStyleValue\",\n      },\n    ]);\n\n    props = {\n      dynamicBindingPathList: [\n        {\n          key: \"primaryColumns.3.style\",\n        },\n      ],\n      primaryColumns: {\n        1: {\n          id: 1,\n          style: \"someRandomStyleValue\",\n        },\n        2: {\n          id: 2,\n          style: \"someRandomStyleValue\",\n        },\n        3: {\n          id: 3,\n          style: \"someRandomStyleValue\",\n        },\n      },\n    };\n\n    expect(\n      updateColumnStyles(\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        props as any as TableWidgetProps,\n        \"style\",\n        \"someOtherRandomStyleValue\",\n      ),\n    ).toEqual([\n      {\n        propertyPath: \"primaryColumns.1.style\",\n        propertyValue: \"someOtherRandomStyleValue\",\n      },\n      {\n        propertyPath: \"primaryColumns.2.style\",\n        propertyValue: \"someOtherRandomStyleValue\",\n      },\n    ]);\n\n    expect(\n      updateColumnStyles(\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        props as any as TableWidgetProps,\n        \"\",\n        \"someOtherRandomStyleValue\",\n      ),\n    ).toEqual(undefined);\n\n    expect(\n      updateColumnStyles(\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        {} as any as TableWidgetProps,\n        \"style\",\n        \"someOtherRandomStyleValue\",\n      ),\n    ).toEqual(undefined);\n\n    expect(\n      updateColumnStyles(\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        {} as any as TableWidgetProps,\n        \"\",\n        \"someOtherRandomStyleValue\",\n      ),\n    ).toEqual(undefined);\n  });\n\n  it(\"updateColumnOrderHook - should test with all possible values\", () => {\n    const defaultStickyValuesForPrimaryCols = {\n      column1: {\n        sticky: StickyType.NONE,\n      },\n      column2: {\n        sticky: StickyType.NONE,\n      },\n      column3: {\n        sticky: StickyType.NONE,\n      },\n    };\n\n    expect(\n      updateColumnOrderHook(\n        {\n          columnOrder: [\"column1\", \"column2\"],\n          primaryColumns: defaultStickyValuesForPrimaryCols,\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } as any as TableWidgetProps,\n        \"primaryColumns.column3\",\n        {\n          id: \"column3\",\n        },\n      ),\n    ).toEqual([\n      {\n        propertyPath: \"columnOrder\",\n        propertyValue: [\"column1\", \"column2\", \"column3\"],\n      },\n      {\n        propertyPath: \"primaryColumns.column3\",\n        propertyValue: {\n          id: \"column3\",\n          labelColor: \"#FFFFFF\",\n        },\n      },\n    ]);\n\n    expect(\n      updateColumnOrderHook(\n        {\n          columnOrder: [\"column1\", \"column2\"],\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } as any as TableWidgetProps,\n        \"\",\n        {\n          id: \"column3\",\n        },\n      ),\n    ).toEqual(undefined);\n\n    expect(\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      updateColumnOrderHook({} as any as TableWidgetProps, \"\", {\n        id: \"column3\",\n      }),\n    ).toEqual(undefined);\n\n    expect(\n      updateColumnOrderHook(\n        {\n          columnOrder: [\"column1\", \"column2\"],\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } as any as TableWidgetProps,\n        \"primaryColumns.column3.iconAlignment\",\n        {\n          id: \"column3\",\n        },\n      ),\n    ).toEqual(undefined);\n  });\n\n  it(\"getBasePropertyPath - should test with all possible values\", () => {\n    expect(getBasePropertyPath(\"primaryColumns.test\")).toBe(\"primaryColumns\");\n    expect(getBasePropertyPath(\"primaryColumns.test.style\")).toBe(\n      \"primaryColumns.test\",\n    );\n    expect(getBasePropertyPath(\"\")).toBe(undefined);\n    expect(getBasePropertyPath(\"primaryColumns\")).toBe(undefined);\n  });\n\n  describe(\"hideByColumnType - \", () => {\n    it(\"should test with column type that should not be hidden\", () => {\n      const prop = {\n        primaryColumns: {\n          column: {\n            columnType: \"text\",\n          },\n        },\n      };\n\n      expect(\n        hideByColumnType(\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          prop as any as TableWidgetProps,\n          \"primaryColumns.column\",\n          [\"text\"] as ColumnTypes[],\n          true,\n        ),\n      ).toBe(false);\n    });\n\n    it(\"should test with column type that should be hidden\", () => {\n      const prop = {\n        primaryColumns: {\n          column: {\n            columnType: \"select\",\n          },\n        },\n      };\n\n      expect(\n        hideByColumnType(\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          prop as any as TableWidgetProps,\n          \"primaryColumns.column\",\n          [\"text\"] as ColumnTypes[],\n          true,\n        ),\n      ).toBe(true);\n    });\n\n    it(\"should test column that should be hidden, with full propertyPath\", () => {\n      const prop = {\n        primaryColumns: {\n          column: {\n            columnType: \"select\",\n          },\n        },\n      };\n\n      expect(\n        hideByColumnType(\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          prop as any as TableWidgetProps,\n          \"primaryColumns.column.buttonColor\",\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          [\"Button\"] as any as ColumnTypes[],\n        ),\n      ).toBe(true);\n    });\n\n    it(\"should test column that should not be hidden, with full propertyPath\", () => {\n      const prop = {\n        primaryColumns: {\n          column: {\n            columnType: \"Button\",\n          },\n        },\n      };\n\n      expect(\n        hideByColumnType(\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          prop as any as TableWidgetProps,\n          \"primaryColumns.column.buttonColor\",\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          [\"Button\"] as any as ColumnTypes[],\n        ),\n      ).toBe(false);\n    });\n  });\n});\n\ndescribe(\"uniqueColumnAliasValidation\", () => {\n  it(\"should validate that duplicate value is not allowed\", () => {\n    expect(\n      uniqueColumnAliasValidation(\n        \"column\",\n        {\n          primaryColumns: {\n            column: {\n              alias: \"column\",\n            },\n            column1: {\n              alias: \"column\",\n            },\n            column2: {\n              alias: \"column2\",\n            },\n          },\n        } as unknown as TableWidgetProps,\n        _,\n      ),\n    ).toEqual({\n      isValid: false,\n      parsed: \"column\",\n      messages: [\"Property names should be unique.\"],\n    });\n  });\n\n  it(\"should validate that empty value is not allowed\", () => {\n    expect(\n      uniqueColumnAliasValidation(\n        \"\",\n        {\n          primaryColumns: {\n            column: {\n              alias: \"column\",\n            },\n            column1: {\n              alias: \"column1\",\n            },\n            column2: {\n              alias: \"column2\",\n            },\n          },\n        } as unknown as TableWidgetProps,\n        _,\n      ),\n    ).toEqual({\n      isValid: false,\n      parsed: \"\",\n      messages: [\"Property name should not be empty.\"],\n    });\n  });\n\n  it(\"should validate that unique value is allowed\", () => {\n    expect(\n      uniqueColumnAliasValidation(\n        \"column1\",\n        {\n          primaryColumns: {\n            column: {\n              alias: \"column\",\n            },\n            column1: {\n              alias: \"column1\",\n            },\n            column2: {\n              alias: \"column2\",\n            },\n          },\n        } as unknown as TableWidgetProps,\n        _,\n      ),\n    ).toEqual({\n      isValid: true,\n      parsed: \"column1\",\n      messages: [\"\"],\n    });\n  });\n});\n\ndescribe(\"selectColumnOptionsValidation\", () => {\n  describe(\"- Array of label, values\", () => {\n    it(\"should check that for empty values are allowed\", () => {\n      [\"\", undefined, null].forEach((value) => {\n        expect(\n          selectColumnOptionsValidation(value, {} as TableWidgetProps, _),\n        ).toEqual({\n          isValid: true,\n          parsed: [],\n          messages: [\"\"],\n        });\n      });\n    });\n\n    it(\"should check that value should be an array\", () => {\n      expect(\n        selectColumnOptionsValidation(\"test\", {} as TableWidgetProps, _),\n      ).toEqual({\n        isValid: false,\n        parsed: [],\n        messages: [\n          `This value does not evaluate to type Array<{ \"label\": string | number, \"value\": string | number | boolean }>`,\n        ],\n      });\n\n      expect(\n        selectColumnOptionsValidation(1, {} as TableWidgetProps, _),\n      ).toEqual({\n        isValid: false,\n        parsed: [],\n        messages: [\n          `This value does not evaluate to type Array<{ \"label\": string | number, \"value\": string | number | boolean }>`,\n        ],\n      });\n\n      expect(\n        selectColumnOptionsValidation([], {} as TableWidgetProps, _),\n      ).toEqual({\n        isValid: true,\n        parsed: [],\n        messages: [\"\"],\n      });\n    });\n\n    it(\"should check that there are no null or undefined values\", () => {\n      expect(\n        selectColumnOptionsValidation(\n          [null, { label: \"2\", value: \"1\" }],\n          {} as TableWidgetProps,\n          _,\n        ),\n      ).toEqual({\n        isValid: false,\n        parsed: [],\n        messages: [\n          `Invalid entry at index: 0. This value does not evaluate to type: { \"label\": string | number, \"value\": string | number | boolean }`,\n        ],\n      });\n    });\n\n    it(\"should check that value should be an array of objects\", () => {\n      expect(\n        selectColumnOptionsValidation([1, 2], {} as TableWidgetProps, _),",
            "output_extracted": "import { updateAllowAddNewRowOnInfiniteScrollChange } from \"../propertyUtils\";\nimport {\n  totalRecordsCountValidation,\n  uniqueColumnNameValidation,\n  updateColumnStyles,\n  updateColumnOrderHook,\n  getBasePropertyPath,\n  hideByColumnType,\n  uniqueColumnAliasValidation,\n  updateCustomColumnAliasOnLabelChange,\n  selectColumnOptionsValidation,\n  allowedFirstDayOfWeekRange,\n  updateCellEditabilityOnInfiniteScrollChange,\n  updateSearchSortFilterOnInfiniteScrollChange,\n} from \"../propertyUtils\";\nimport _ from \"lodash\";\nimport type { ColumnTypes, TableWidgetProps } from \"../../constants\";\nimport { StickyType } from \"../../component/Constants\";\n\ndescribe(\"PropertyUtils - \", () => {\n  it(\"totalRecordsCountValidation - should test with all possible values\", () => {\n    const ERROR_MESSAGE = [\n      { name: \"ValidationError\", message: \"This value must be a number\" },\n    ];\n\n    const values = [\n      [\n        undefined,\n        {\n          isValid: true,\n          parsed: 0,\n          messages: [],\n        },\n      ],\n      [\n        null,\n        {\n          isValid: true,\n          parsed: 0,\n          messages: [],\n        },\n      ],\n      [\n        \"\",\n        {\n          isValid: true,\n          parsed: 0,\n          messages: [],\n        },\n      ],\n      [\n        {},\n        {\n          isValid: false,\n          parsed: 0,\n          messages: ERROR_MESSAGE,\n        },\n      ],\n      [\n        [],\n        {\n          isValid: false,\n          parsed: 0,\n          messages: ERROR_MESSAGE,\n        },\n      ],\n      [\n        \"test\",\n        {\n          isValid: false,\n          parsed: 0,\n          messages: ERROR_MESSAGE,\n        },\n      ],\n      [\n        \"1\",\n        {\n          isValid: true,\n          parsed: 1,\n          messages: [],\n        },\n      ],\n      [\n        1,\n        {\n          isValid: true,\n          parsed: 1,\n          messages: [],\n        },\n      ],\n    ];\n\n    values.forEach(([input, expected]) => {\n      expect(\n        totalRecordsCountValidation(input, {} as TableWidgetProps, _),\n      ).toEqual(expected);\n    });\n  });\n\n  it(\"uniqueColumnNameValidation - should test with all possible values\", () => {\n    let value = [\n      {\n        label: \"column1\",\n      },\n      {\n        label: \"column2\",\n      },\n      {\n        label: \"column3\",\n      },\n    ];\n\n    expect(\n      uniqueColumnNameValidation(value, {} as TableWidgetProps, _),\n    ).toEqual({\n      isValid: true,\n      parsed: value,\n      messages: [\"\"],\n    });\n\n    value = [\n      {\n        label: \"column1\",\n      },\n      {\n        label: \"column2\",\n      },\n      {\n        label: \"column1\",\n      },\n    ];\n\n    expect(\n      uniqueColumnNameValidation(value, {} as TableWidgetProps, _),\n    ).toEqual({\n      isValid: false,\n      parsed: value,\n      messages: [\"Column names should be unique.\"],\n    });\n  });\n\n  it(\"updateColumnStyles - should test with all possible values\", () => {\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let props: any = {\n      primaryColumns: {\n        1: {\n          id: 1,\n          style: \"someRandomStyleValue\",\n        },\n        2: {\n          id: 2,\n          style: \"someRandomStyleValue\",\n        },\n        3: {\n          id: 3,\n          style: \"someRandomStyleValue\",\n        },\n      },\n    };\n\n    expect(\n      updateColumnStyles(\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        props as any as TableWidgetProps,\n        \"style\",\n        \"someOtherRandomStyleValue\",\n      ),\n    ).toEqual([\n      {\n        propertyPath: \"primaryColumns.1.style\",\n        propertyValue: \"someOtherRandomStyleValue\",\n      },\n      {\n        propertyPath: \"primaryColumns.2.style\",\n        propertyValue: \"someOtherRandomStyleValue\",\n      },\n      {\n        propertyPath: \"primaryColumns.3.style\",\n        propertyValue: \"someOtherRandomStyleValue\",\n      },\n    ]);\n\n    props = {\n      dynamicBindingPathList: [\n        {\n          key: \"primaryColumns.3.style\",\n        },\n      ],\n      primaryColumns: {\n        1: {\n          id: 1,\n          style: \"someRandomStyleValue\",\n        },\n        2: {\n          id: 2,\n          style: \"someRandomStyleValue\",\n        },\n        3: {\n          id: 3,\n          style: \"someRandomStyleValue\",\n        },\n      },\n    };\n\n    expect(\n      updateColumnStyles(\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        props as any as TableWidgetProps,\n        \"style\",\n        \"someOtherRandomStyleValue\",\n      ),\n    ).toEqual([\n      {\n        propertyPath: \"primaryColumns.1.style\",\n        propertyValue: \"someOtherRandomStyleValue\",\n      },\n      {\n        propertyPath: \"primaryColumns.2.style\",\n        propertyValue: \"someOtherRandomStyleValue\",\n      },\n    ]);\n\n    expect(\n      updateColumnStyles(\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        props as any as TableWidgetProps,\n        \"\",\n        \"someOtherRandomStyleValue\",\n      ),\n    ).toEqual(undefined);\n\n    expect(\n      updateColumnStyles(\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        {} as any as TableWidgetProps,\n        \"style\",\n        \"someOtherRandomStyleValue\",\n      ),\n    ).toEqual(undefined);\n\n    expect(\n      updateColumnStyles(\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        {} as any as TableWidgetProps,\n        \"\",\n        \"someOtherRandomStyleValue\",\n      ),\n    ).toEqual(undefined);\n  });\n\n  it(\"updateColumnOrderHook - should test with all possible values\", () => {\n    const defaultStickyValuesForPrimaryCols = {\n      column1: {\n        sticky: StickyType.NONE,\n      },\n      column2: {\n        sticky: StickyType.NONE,\n      },\n      column3: {\n        sticky: StickyType.NONE,\n      },\n    };\n\n    expect(\n      updateColumnOrderHook(\n        {\n          columnOrder: [\"column1\", \"column2\"],\n          primaryColumns: defaultStickyValuesForPrimaryCols,\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } as any as TableWidgetProps,\n        \"primaryColumns.column3\",\n        {\n          id: \"column3\",\n        },\n      ),\n    ).toEqual([\n      {\n        propertyPath: \"columnOrder\",\n        propertyValue: [\"column1\", \"column2\", \"column3\"],\n      },\n      {\n        propertyPath: \"primaryColumns.column3\",\n        propertyValue: {\n          id: \"column3\",\n          labelColor: \"#FFFFFF\",\n        },\n      },\n    ]);\n\n    expect(\n      updateColumnOrderHook(\n        {\n          columnOrder: [\"column1\", \"column2\"],\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } as any as TableWidgetProps,\n        \"\",\n        {\n          id: \"column3\",\n        },\n      ),\n    ).toEqual(undefined);\n\n    expect(\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      updateColumnOrderHook({} as any as TableWidgetProps, \"\", {\n        id: \"column3\",\n      }),\n    ).toEqual(undefined);\n\n    expect(\n      updateColumnOrderHook(\n        {\n          columnOrder: [\"column1\", \"column2\"],\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } as any as TableWidgetProps,\n        \"primaryColumns.column3.iconAlignment\",\n        {\n          id: \"column3\",\n        },\n      ),\n    ).toEqual(undefined);\n  });\n\n  it(\"getBasePropertyPath - should test with all possible values\", () => {\n    expect(getBasePropertyPath(\"primaryColumns.test\")).toBe(\"primaryColumns\");\n    expect(getBasePropertyPath(\"primaryColumns.test.style\")).toBe(\n      \"primaryColumns.test\",\n    );\n    expect(getBasePropertyPath(\"\")).toBe(undefined);\n    expect(getBasePropertyPath(\"primaryColumns\")).toBe(undefined);\n  });\n\n  describe(\"hideByColumnType - \", () => {\n    it(\"should test with column type that should not be hidden\", () => {\n      const prop = {\n        primaryColumns: {\n          column: {\n            columnType: \"text\",\n          },\n        },\n      };\n\n      expect(\n        hideByColumnType(\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          prop as any as TableWidgetProps,\n          \"primaryColumns.column\",\n          [\"text\"] as ColumnTypes[],\n          true,\n        ),\n      ).toBe(false);\n    });\n\n    it(\"should test with column type that should be hidden\", () => {\n      const prop = {\n        primaryColumns: {\n          column: {\n            columnType: \"select\",\n          },\n        },\n      };\n\n      expect(\n        hideByColumnType(\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          prop as any as TableWidgetProps,\n          \"primaryColumns.column\",\n          [\"text\"] as ColumnTypes[],\n          true,\n        ),\n      ).toBe(true);\n    });\n\n    it(\"should test column that should be hidden, with full propertyPath\", () => {\n      const prop = {\n        primaryColumns: {\n          column: {\n            columnType: \"select\",\n          },\n        },\n      };\n\n      expect(\n        hideByColumnType(\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          prop as any as TableWidgetProps,\n          \"primaryColumns.column.buttonColor\",\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          [\"Button\"] as any as ColumnTypes[],\n        ),\n      ).toBe(true);\n    });\n\n    it(\"should test column that should not be hidden, with full propertyPath\", () => {\n      const prop = {\n        primaryColumns: {\n          column: {\n            columnType: \"Button\",\n          },\n        },\n      };\n\n      expect(\n        hideByColumnType(\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          prop as any as TableWidgetProps,\n          \"primaryColumns.column.buttonColor\",\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          [\"Button\"] as any as ColumnTypes[],\n        ),\n      ).toBe(false);\n    });\n  });\n});\n\ndescribe(\"uniqueColumnAliasValidation\", () => {\n  it(\"should validate that duplicate value is not allowed\", () => {\n    expect(\n      uniqueColumnAliasValidation(\n        \"column\",\n        {\n          primaryColumns: {\n            column: {\n              alias: \"column\",\n            },\n            column1: {\n              alias: \"column\",\n            },\n            column2: {\n              alias: \"column2\",\n            },\n          },\n        } as unknown as TableWidgetProps,\n        _,\n      ),\n    ).toEqual({\n      isValid: false,\n      parsed: \"column\",\n      messages: [\"Property names should be unique.\"],\n    });\n  });\n\n  it(\"should validate that empty value is not allowed\", () => {\n    expect(\n      uniqueColumnAliasValidation(\n        \"\",\n        {\n          primaryColumns: {\n            column: {\n              alias: \"column\",\n            },\n            column1: {\n              alias: \"column1\",\n            },\n            column2: {\n              alias: \"column2\",\n            },\n          },\n        } as unknown as TableWidgetProps,\n        _,\n      ),\n    ).toEqual({\n      isValid: false,\n      parsed: \"\",\n      messages: [\"Property name should not be empty.\"],\n    });\n  });\n\n  it(\"should validate that unique value is allowed\", () => {\n    expect(\n      uniqueColumnAliasValidation(\n        \"column1\",\n        {\n          primaryColumns: {\n            column: {\n              alias: \"column\",\n            },\n            column1: {\n              alias: \"column1\",\n            },\n            column2: {\n              alias: \"column2\",\n            },\n          },\n        } as unknown as TableWidgetProps,\n        _,\n      ),\n    ).toEqual({\n      isValid: true,\n      parsed: \"column1\",\n      messages: [\"\"],\n    });\n  });\n});\n\ndescribe(\"selectColumnOptionsValidation\", () => {\n  describe(\"- Array of label, values\", () => {\n    it(\"should check that for empty values are allowed\", () => {\n      [\"\", undefined, null].forEach((value) => {\n        expect(\n          selectColumnOptionsValidation(value, {} as TableWidgetProps, _),\n        ).toEqual({\n          isValid: true,\n          parsed: [],\n          messages: [\"\"],\n        });\n      });\n    });\n\n    it(\"should check that value should be an array\", () => {\n      expect(\n        selectColumnOptionsValidation(\"test\", {} as TableWidgetProps, _),\n      ).toEqual({\n        isValid: false,\n        parsed: [],\n        messages: [\n          `This value does not evaluate to type Array<{ \"label\": string | number, \"value\": string | number | boolean }>`,\n        ],\n      });\n\n      expect(\n        selectColumnOptionsValidation(1, {} as TableWidgetProps, _),\n      ).toEqual({\n        isValid: false,\n        parsed: [],\n        messages: [\n          `This value does not evaluate to type Array<{ \"label\": string | number, \"value\": string | number | boolean }>`,\n        ],\n      });\n\n      expect(\n        selectColumnOptionsValidation([], {} as TableWidgetProps, _),\n      ).toEqual({\n        isValid: true,\n        parsed: [],\n        messages: [\"\"],\n      });\n    });\n\n    it(\"should check that there are no null or undefined values\", () => {\n      expect(\n        selectColumnOptionsValidation(\n          [null, { label: \"2\", value: \"1\" }],\n          {} as TableWidgetProps,\n          _,\n        ),\n      ).toEqual({\n        isValid: false,\n        parsed: [],\n        messages: [\n          `Invalid entry at index: 0. This value does not evaluate to type: { \"label\": string | number, \"value\": string | number | boolean }`,\n        ],\n      });\n    });\n\n    it(\"should check that value should be an array of objects\", () => {\n      expect(\n        selectColumnOptionsValidation([1, 2], {} as TableWidgetProps, _),",
            "cost": 0.1534
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/widgets/TableWidgetV2/widget/index.tsx": {
            "output": "import log from \"loglevel\";\nimport memoizeOne from \"memoize-one\";\nimport React, { lazy, Suspense } from \"react\";\n\nimport _, {\n  filter,\n  isArray,\n  isEmpty,\n  isNil,\n  isNumber,\n  isObject,\n  isString,\n  merge,\n  orderBy,\n  pickBy,\n  union,\n  without,\n  xor,\n  xorWith,\n} from \"lodash\";\n\nimport type { IconName } from \"@blueprintjs/icons\";\nimport { IconNames } from \"@blueprintjs/icons\";\nimport type { BatchPropertyUpdatePayload } from \"actions/controlActions\";\nimport Skeleton from \"components/utils/Skeleton\";\nimport { EventType } from \"constants/AppsmithActionConstants/ActionConstants\";\nimport { Colors } from \"constants/Colors\";\nimport { FILL_WIDGET_MIN_WIDTH } from \"constants/minWidthConstants\";\nimport {\n  RenderModes,\n  WIDGET_PADDING,\n  WIDGET_TAGS,\n} from \"constants/WidgetConstants\";\nimport type { SetterConfig, Stylesheet } from \"entities/AppTheming\";\nimport equal from \"fast-deep-equal/es6\";\nimport {\n  FlexVerticalAlignment,\n  ResponsiveBehavior,\n} from \"layoutSystems/common/utils/constants\";\nimport { noop, retryPromise } from \"utils/AppsmithUtils\";\nimport type { ExtraDef } from \"utils/autocomplete/defCreatorUtils\";\nimport { generateTypeDef } from \"utils/autocomplete/defCreatorUtils\";\nimport type { DynamicPath } from \"utils/DynamicBindingUtils\";\nimport { klonaRegularWithTelemetry } from \"utils/helpers\";\nimport localStorage from \"utils/localStorage\";\nimport type {\n  AnvilConfig,\n  AutocompletionDefinitions,\n  PropertyUpdates,\n  SnipingModeProperty,\n} from \"WidgetProvider/types\";\nimport type {\n  WidgetQueryConfig,\n  WidgetQueryGenerationFormConfig,\n} from \"WidgetQueryGenerators/types\";\nimport type { WidgetProps, WidgetState } from \"widgets/BaseWidget\";\nimport BaseWidget from \"widgets/BaseWidget\";\nimport { TimePrecision } from \"widgets/DatePickerWidget2/constants\";\nimport type { MenuItem } from \"widgets/MenuButtonWidget/constants\";\nimport { MenuItemsSource } from \"widgets/MenuButtonWidget/constants\";\nimport {\n  DefaultAutocompleteDefinitions,\n  sanitizeKey,\n} from \"widgets/WidgetUtils\";\nimport { ButtonCell } from \"../component/cellComponents/ButtonCell\";\nimport { CheckboxCell } from \"../component/cellComponents/CheckboxCell\";\nimport { DateCell } from \"../component/cellComponents/DateCell\";\nimport { EditActionCell } from \"../component/cellComponents/EditActionsCell\";\nimport HTMLCell from \"../component/cellComponents/HTMLCell\";\nimport { IconButtonCell } from \"../component/cellComponents/IconButtonCell\";\nimport { ImageCell } from \"../component/cellComponents/ImageCell\";\nimport { MenuButtonCell } from \"../component/cellComponents/MenuButtonCell\";\nimport PlainTextCell from \"../component/cellComponents/PlainTextCell\";\nimport { SelectCell } from \"../component/cellComponents/SelectCell\";\nimport { SwitchCell } from \"../component/cellComponents/SwitchCell\";\nimport { VideoCell } from \"../component/cellComponents/VideoCell\";\nimport type {\n  ColumnProperties,\n  ReactTableColumnProps,\n  ReactTableFilter,\n} from \"../component/Constants\";\nimport {\n  AddNewRowActions,\n  CompactModeTypes,\n  DEFAULT_FILTER,\n  SORT_ORDER,\n  SortOrderTypes,\n  StickyType,\n} from \"../component/Constants\";\nimport { CellWrapper } from \"../component/TableStyledWrappers\";\nimport type {\n  EditableCell,\n  OnColumnEventArgs,\n  TableWidgetProps,\n  TransientDataPayload,\n} from \"../constants\";\nimport {\n  ActionColumnTypes,\n  ALLOW_TABLE_WIDGET_SERVER_SIDE_FILTERING,\n  ColumnTypes,\n  DEFAULT_BUTTON_LABEL,\n  DEFAULT_COLUMN_WIDTH,\n  DEFAULT_MENU_BUTTON_LABEL,\n  DEFAULT_MENU_VARIANT,\n  defaultEditableCell,\n  EditableCellActions,\n  InlineEditingSaveOptions,\n  ORIGINAL_INDEX_KEY,\n  PaginationDirection,\n  TABLE_COLUMN_ORDER_KEY,\n} from \"../constants\";\nimport IconSVG from \"../icon.svg\";\nimport ThumbnailSVG from \"../thumbnail.svg\";\nimport derivedProperties from \"./parseDerivedProperties\";\nimport contentConfig from \"./propertyConfig/contentConfig\";\nimport styleConfig from \"./propertyConfig/styleConfig\";\nimport type { getColumns } from \"./reactTableUtils/getColumnsPureFn\";\nimport { getMemoiseGetColumnsWithLocalStorageFn } from \"./reactTableUtils/getColumnsPureFn\";\nimport type {\n  tableData,\n  transformDataWithEditableCell,\n} from \"./reactTableUtils/transformDataPureFn\";\nimport { getMemoiseTransformDataWithEditableCell } from \"./reactTableUtils/transformDataPureFn\";\nimport {\n  createEditActionColumn,\n  deleteLocalTableColumnOrderByWidgetId,\n  generateLocalNewColumnOrderFromStickyValue,\n  generateNewColumnOrderFromStickyValue,\n  getAllStickyColumnsCount,\n  getAllTableColumnKeys,\n  getBooleanPropertyValue,\n  getCellProperties,\n  getColumnOrderByWidgetIdFromLS,\n  getColumnType,\n  getDefaultColumnProperties,\n  getDerivedColumns,\n  getSelectRowIndex,\n  getSelectRowIndices,\n  getTableStyles,\n  isColumnTypeEditable,\n  updateAndSyncTableLocalColumnOrders,\n} from \"./utilities\";\nimport resetWidget from \"workers/Evaluation/fns/resetWidget\";\n\nconst ReactTableComponent = lazy(async () =>\n  retryPromise(async () => import(\"../component\")),\n);\n\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst emptyArr: any = [];\n\ntype addNewRowToTable = (\n  tableData: tableData,\n  isAddRowInProgress: boolean,\n  newRowContent: Record<string, unknown>,\n) => tableData;\n\nconst getMemoisedAddNewRow = (): addNewRowToTable =>\n  memoizeOne((tableData, isAddRowInProgress, newRowContent) => {\n    if (isAddRowInProgress) {\n      return [newRowContent, ...tableData];\n    }\n\n    return tableData;\n  });\n\nclass TableWidgetV2 extends BaseWidget<TableWidgetProps, WidgetState> {\n  inlineEditTimer: number | null = null;\n  memoisedAddNewRow: addNewRowToTable;\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  memoiseGetColumnsWithLocalStorage: (localStorage: any) => getColumns;\n  memoiseTransformDataWithEditableCell: transformDataWithEditableCell;\n\n  static type = \"TABLE_WIDGET_V2\";\n\n  static getConfig() {\n    return {\n      name: \"Table\",\n      iconSVG: IconSVG,\n      thumbnailSVG: ThumbnailSVG,\n      tags: [WIDGET_TAGS.SUGGESTED_WIDGETS, WIDGET_TAGS.DISPLAY],\n      needsMeta: true,\n      needsHeightForContent: true,\n    };\n  }\n\n  static getDefaults() {\n    return {\n      flexVerticalAlignment: FlexVerticalAlignment.Top,\n      responsiveBehavior: ResponsiveBehavior.Fill,\n      minWidth: FILL_WIDGET_MIN_WIDTH,\n      rows: 28,\n      canFreezeColumn: true,\n      columnUpdatedAt: Date.now(),\n      columns: 34,\n      animateLoading: true,\n      defaultSelectedRowIndex: 0,\n      defaultSelectedRowIndices: [0],\n      label: \"Data\",\n      widgetName: \"Table\",\n      searchKey: \"\",\n      textSize: \"0.875rem\",\n      horizontalAlignment: \"LEFT\",\n      verticalAlignment: \"CENTER\",\n      totalRecordsCount: 0,\n      defaultPageSize: 0,\n      dynamicPropertyPathList: [],\n      borderColor: Colors.GREY_5,\n      borderWidth: \"1\",\n      dynamicBindingPathList: [],\n      primaryColumns: {},\n      tableData: \"\",\n      columnWidthMap: {},\n      columnOrder: [],\n      enableClientSideSearch: true,\n      isVisibleSearch: true,\n      isVisibleFilters: false,\n      isVisibleDownload: true,\n      isVisiblePagination: true,\n      isSortable: true,\n      delimiter: \",\",\n      version: 2,\n      inlineEditingSaveOption: InlineEditingSaveOptions.ROW_LEVEL,\n      enableServerSideFiltering: TableWidgetV2.getFeatureFlag(\n        ALLOW_TABLE_WIDGET_SERVER_SIDE_FILTERING,\n      )\n        ? false\n        : undefined,\n      customIsLoading: false,\n      customIsLoadingValue: \"\",\n      cachedTableData: {},\n      endOfData: false,\n    };\n  }\n\n  static getMethods() {\n    return {\n      getQueryGenerationConfig: (widget: WidgetProps) => {\n        return {\n          select: {\n            limit: `${widget.widgetName}.pageSize`,\n            where: `${widget.widgetName}.searchText`,\n            offset: `${widget.widgetName}.pageOffset`,\n            orderBy: `${widget.widgetName}.sortOrder.column`,\n            sortOrder: `${widget.widgetName}.sortOrder.order !== \"desc\"`,\n          },\n          create: {\n            value: `(${widget.widgetName}.newRow || {})`,\n          },\n          update: {\n            value: `${widget.widgetName}.updatedRow`,\n            where: `${widget.widgetName}.updatedRow`,\n          },\n          totalRecord: true,\n        };\n      },\n      getPropertyUpdatesForQueryBinding: (\n        queryConfig: WidgetQueryConfig,\n        _widget: WidgetProps,\n        formConfig: WidgetQueryGenerationFormConfig,\n      ) => {\n        const widget = _widget as TableWidgetProps;\n\n        let modify = {};\n        const dynamicPropertyPathList: DynamicPath[] = [];\n\n        if (queryConfig.select) {\n          modify = merge(modify, {\n            tableData: queryConfig.select.data,\n            onPageChange: queryConfig.select.run,\n            serverSidePaginationEnabled: true,\n            onSearchTextChanged: formConfig.searchableColumn\n              ? queryConfig.select.run\n              : undefined,\n            onSort: queryConfig.select.run,\n            enableClientSideSearch: !formConfig.searchableColumn,\n            primaryColumnId: formConfig.primaryColumn,\n            isVisibleDownload: false,\n          });\n\n          dynamicPropertyPathList.push({ key: \"tableData\" });\n        }\n\n        if (queryConfig.create) {\n          modify = merge(modify, {\n            onAddNewRowSave: queryConfig.create.run,\n            allowAddNewRow: true,\n            ...Object.keys(widget.primaryColumns).reduce(\n              (prev: Record<string, boolean>, curr) => {\n                if (formConfig.primaryColumn !== curr) {\n                  prev[`primaryColumns.${curr}.isEditable`] = true;\n                  prev[`primaryColumns.${curr}.isCellEditable`] = true;\n                }\n\n                prev[`showInlineEditingOptionDropdown`] = true;\n\n                return prev;\n              },\n              {},\n            ),\n          });\n        }\n\n        if (queryConfig.update) {\n          let editAction = {};\n\n          if (\n            !Object.values(widget.primaryColumns).some(\n              (column) => column.columnType === ColumnTypes.EDIT_ACTIONS,\n            )\n          ) {\n            editAction = Object.values(createEditActionColumn(widget)).reduce(\n              (\n                prev: Record<string, unknown>,\n                curr: {\n                  propertyPath: string;\n                  propertyValue: unknown;\n                  isDynamicPropertyPath?: boolean;\n                },\n              ) => {\n                prev[curr.propertyPath] = curr.propertyValue;\n\n                if (curr.isDynamicPropertyPath) {\n                  dynamicPropertyPathList.push({ key: curr.propertyPath });\n                }\n\n                return prev;\n              },\n              {},\n            );\n          }\n\n          modify = merge(modify, {\n            ...editAction,\n            [`primaryColumns.EditActions1.onSave`]: queryConfig.update.run,\n          });\n        }\n\n        if (queryConfig.total_record) {\n          modify = merge(modify, {\n            totalRecordsCount: queryConfig.total_record.data,\n          });\n        }\n\n        return {\n          modify,\n          dynamicUpdates: {\n            dynamicPropertyPathList,\n          },\n        };\n      },\n      getSnipingModeUpdates: (\n        propValueMap: SnipingModeProperty,\n      ): PropertyUpdates[] => {\n        return [\n          {\n            propertyPath: \"tableData\",\n            propertyValue: propValueMap.data,\n            isDynamicPropertyPath: !!propValueMap.isDynamicPropertyPath,\n          },\n        ];\n      },\n      getOneClickBindingConnectableWidgetConfig: (widget: WidgetProps) => {\n        return {\n          widgetBindPath: `${widget.widgetName}.selectedRow`,\n          message: `Make sure ${widget.widgetName} is bound to the same data source`,\n        };\n      },\n    };\n  }\n\n  static getAutoLayoutConfig() {\n    return {\n      widgetSize: [\n        {\n          viewportMinWidth: 0,\n          configuration: () => {\n            return {\n              minWidth: \"280px\",\n              minHeight: \"300px\",\n            };\n          },\n        },\n      ],\n    };\n  }\n\n  static getAnvilConfig(): AnvilConfig | null {\n    return {\n      isLargeWidget: false,\n      widgetSize: {\n        maxHeight: {},\n        maxWidth: {},\n        minHeight: { base: \"300px\" },\n        minWidth: { base: \"280px\" },\n      },\n    };\n  }\n\n  static getPropertyPaneContentConfig() {\n    return contentConfig;\n  }\n\n  static getPropertyPaneStyleConfig() {\n    return styleConfig;\n  }\n\n  constructor(props: TableWidgetProps) {\n    super(props);\n    // generate new cache instances so that each table widget instance has its own respective cache instance\n    this.memoisedAddNewRow = getMemoisedAddNewRow();\n    this.memoiseGetColumnsWithLocalStorage =\n      getMemoiseGetColumnsWithLocalStorageFn();\n    this.memoiseTransformDataWithEditableCell =\n      getMemoiseTransformDataWithEditableCell();\n  }\n\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static getMetaPropertiesMap(): Record<string, any> {\n    return {\n      pageNo: 1,\n      selectedRowIndex: undefined,\n      selectedRowIndices: undefined,\n      searchText: undefined,\n      triggeredRowIndex: undefined,\n      filters: [],\n      sortOrder: {\n        column: \"\",\n        order: null,\n      },\n      transientTableData: {},\n      updatedRowIndex: -1,\n      editableCell: defaultEditableCell,\n      columnEditableCellValue: {},\n      selectColumnFilterText: {},\n      isAddRowInProgress: false,\n      newRowContent: undefined,\n      newRow: undefined,\n      previousPageVisited: false,\n      nextPageVisited: false,\n    };\n  }\n\n  static getAutocompleteDefinitions(): AutocompletionDefinitions {\n    return (widget: TableWidgetProps, extraDefsToDefine?: ExtraDef) => {\n      const config: AutocompletionDefinitions = {\n        \"!doc\":\n          \"The Table is the hero widget of Appsmith. You can display data from an API in a table, trigger an action when a user selects a row and even work with large",
            "output_extracted": "import log from \"loglevel\";\nimport memoizeOne from \"memoize-one\";\nimport React, { lazy, Suspense } from \"react\";\n\nimport _, {\n  filter,\n  isArray,\n  isEmpty,\n  isNil,\n  isNumber,\n  isObject,\n  isString,\n  merge,\n  orderBy,\n  pickBy,\n  union,\n  without,\n  xor,\n  xorWith,\n} from \"lodash\";\n\nimport type { IconName } from \"@blueprintjs/icons\";\nimport { IconNames } from \"@blueprintjs/icons\";\nimport type { BatchPropertyUpdatePayload } from \"actions/controlActions\";\nimport Skeleton from \"components/utils/Skeleton\";\nimport { EventType } from \"constants/AppsmithActionConstants/ActionConstants\";\nimport { Colors } from \"constants/Colors\";\nimport { FILL_WIDGET_MIN_WIDTH } from \"constants/minWidthConstants\";\nimport {\n  RenderModes,\n  WIDGET_PADDING,\n  WIDGET_TAGS,\n} from \"constants/WidgetConstants\";\nimport type { SetterConfig, Stylesheet } from \"entities/AppTheming\";\nimport equal from \"fast-deep-equal/es6\";\nimport {\n  FlexVerticalAlignment,\n  ResponsiveBehavior,\n} from \"layoutSystems/common/utils/constants\";\nimport { noop, retryPromise } from \"utils/AppsmithUtils\";\nimport type { ExtraDef } from \"utils/autocomplete/defCreatorUtils\";\nimport { generateTypeDef } from \"utils/autocomplete/defCreatorUtils\";\nimport type { DynamicPath } from \"utils/DynamicBindingUtils\";\nimport { klonaRegularWithTelemetry } from \"utils/helpers\";\nimport localStorage from \"utils/localStorage\";\nimport type {\n  AnvilConfig,\n  AutocompletionDefinitions,\n  PropertyUpdates,\n  SnipingModeProperty,\n} from \"WidgetProvider/types\";\nimport type {\n  WidgetQueryConfig,\n  WidgetQueryGenerationFormConfig,\n} from \"WidgetQueryGenerators/types\";\nimport type { WidgetProps, WidgetState } from \"widgets/BaseWidget\";\nimport BaseWidget from \"widgets/BaseWidget\";\nimport { TimePrecision } from \"widgets/DatePickerWidget2/constants\";\nimport type { MenuItem } from \"widgets/MenuButtonWidget/constants\";\nimport { MenuItemsSource } from \"widgets/MenuButtonWidget/constants\";\nimport {\n  DefaultAutocompleteDefinitions,\n  sanitizeKey,\n} from \"widgets/WidgetUtils\";\nimport { ButtonCell } from \"../component/cellComponents/ButtonCell\";\nimport { CheckboxCell } from \"../component/cellComponents/CheckboxCell\";\nimport { DateCell } from \"../component/cellComponents/DateCell\";\nimport { EditActionCell } from \"../component/cellComponents/EditActionsCell\";\nimport HTMLCell from \"../component/cellComponents/HTMLCell\";\nimport { IconButtonCell } from \"../component/cellComponents/IconButtonCell\";\nimport { ImageCell } from \"../component/cellComponents/ImageCell\";\nimport { MenuButtonCell } from \"../component/cellComponents/MenuButtonCell\";\nimport PlainTextCell from \"../component/cellComponents/PlainTextCell\";\nimport { SelectCell } from \"../component/cellComponents/SelectCell\";\nimport { SwitchCell } from \"../component/cellComponents/SwitchCell\";\nimport { VideoCell } from \"../component/cellComponents/VideoCell\";\nimport type {\n  ColumnProperties,\n  ReactTableColumnProps,\n  ReactTableFilter,\n} from \"../component/Constants\";\nimport {\n  AddNewRowActions,\n  CompactModeTypes,\n  DEFAULT_FILTER,\n  SORT_ORDER,\n  SortOrderTypes,\n  StickyType,\n} from \"../component/Constants\";\nimport { CellWrapper } from \"../component/TableStyledWrappers\";\nimport type {\n  EditableCell,\n  OnColumnEventArgs,\n  TableWidgetProps,\n  TransientDataPayload,\n} from \"../constants\";\nimport {\n  ActionColumnTypes,\n  ALLOW_TABLE_WIDGET_SERVER_SIDE_FILTERING,\n  ColumnTypes,\n  DEFAULT_BUTTON_LABEL,\n  DEFAULT_COLUMN_WIDTH,\n  DEFAULT_MENU_BUTTON_LABEL,\n  DEFAULT_MENU_VARIANT,\n  defaultEditableCell,\n  EditableCellActions,\n  InlineEditingSaveOptions,\n  ORIGINAL_INDEX_KEY,\n  PaginationDirection,\n  TABLE_COLUMN_ORDER_KEY,\n} from \"../constants\";\nimport IconSVG from \"../icon.svg\";\nimport ThumbnailSVG from \"../thumbnail.svg\";\nimport derivedProperties from \"./parseDerivedProperties\";\nimport contentConfig from \"./propertyConfig/contentConfig\";\nimport styleConfig from \"./propertyConfig/styleConfig\";\nimport type { getColumns } from \"./reactTableUtils/getColumnsPureFn\";\nimport { getMemoiseGetColumnsWithLocalStorageFn } from \"./reactTableUtils/getColumnsPureFn\";\nimport type {\n  tableData,\n  transformDataWithEditableCell,\n} from \"./reactTableUtils/transformDataPureFn\";\nimport { getMemoiseTransformDataWithEditableCell } from \"./reactTableUtils/transformDataPureFn\";\nimport {\n  createEditActionColumn,\n  deleteLocalTableColumnOrderByWidgetId,\n  generateLocalNewColumnOrderFromStickyValue,\n  generateNewColumnOrderFromStickyValue,\n  getAllStickyColumnsCount,\n  getAllTableColumnKeys,\n  getBooleanPropertyValue,\n  getCellProperties,\n  getColumnOrderByWidgetIdFromLS,\n  getColumnType,\n  getDefaultColumnProperties,\n  getDerivedColumns,\n  getSelectRowIndex,\n  getSelectRowIndices,\n  getTableStyles,\n  isColumnTypeEditable,\n  updateAndSyncTableLocalColumnOrders,\n} from \"./utilities\";\nimport resetWidget from \"workers/Evaluation/fns/resetWidget\";\n\nconst ReactTableComponent = lazy(async () =>\n  retryPromise(async () => import(\"../component\")),\n);\n\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst emptyArr: any = [];\n\ntype addNewRowToTable = (\n  tableData: tableData,\n  isAddRowInProgress: boolean,\n  newRowContent: Record<string, unknown>,\n) => tableData;\n\nconst getMemoisedAddNewRow = (): addNewRowToTable =>\n  memoizeOne((tableData, isAddRowInProgress, newRowContent) => {\n    if (isAddRowInProgress) {\n      return [newRowContent, ...tableData];\n    }\n\n    return tableData;\n  });\n\nclass TableWidgetV2 extends BaseWidget<TableWidgetProps, WidgetState> {\n  inlineEditTimer: number | null = null;\n  memoisedAddNewRow: addNewRowToTable;\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  memoiseGetColumnsWithLocalStorage: (localStorage: any) => getColumns;\n  memoiseTransformDataWithEditableCell: transformDataWithEditableCell;\n\n  static type = \"TABLE_WIDGET_V2\";\n\n  static getConfig() {\n    return {\n      name: \"Table\",\n      iconSVG: IconSVG,\n      thumbnailSVG: ThumbnailSVG,\n      tags: [WIDGET_TAGS.SUGGESTED_WIDGETS, WIDGET_TAGS.DISPLAY],\n      needsMeta: true,\n      needsHeightForContent: true,\n    };\n  }\n\n  static getDefaults() {\n    return {\n      flexVerticalAlignment: FlexVerticalAlignment.Top,\n      responsiveBehavior: ResponsiveBehavior.Fill,\n      minWidth: FILL_WIDGET_MIN_WIDTH,\n      rows: 28,\n      canFreezeColumn: true,\n      columnUpdatedAt: Date.now(),\n      columns: 34,\n      animateLoading: true,\n      defaultSelectedRowIndex: 0,\n      defaultSelectedRowIndices: [0],\n      label: \"Data\",\n      widgetName: \"Table\",\n      searchKey: \"\",\n      textSize: \"0.875rem\",\n      horizontalAlignment: \"LEFT\",\n      verticalAlignment: \"CENTER\",\n      totalRecordsCount: 0,\n      defaultPageSize: 0,\n      dynamicPropertyPathList: [],\n      borderColor: Colors.GREY_5,\n      borderWidth: \"1\",\n      dynamicBindingPathList: [],\n      primaryColumns: {},\n      tableData: \"\",\n      columnWidthMap: {},\n      columnOrder: [],\n      enableClientSideSearch: true,\n      isVisibleSearch: true,\n      isVisibleFilters: false,\n      isVisibleDownload: true,\n      isVisiblePagination: true,\n      isSortable: true,\n      delimiter: \",\",\n      version: 2,\n      inlineEditingSaveOption: InlineEditingSaveOptions.ROW_LEVEL,\n      enableServerSideFiltering: TableWidgetV2.getFeatureFlag(\n        ALLOW_TABLE_WIDGET_SERVER_SIDE_FILTERING,\n      )\n        ? false\n        : undefined,\n      customIsLoading: false,\n      customIsLoadingValue: \"\",\n      cachedTableData: {},\n      endOfData: false,\n    };\n  }\n\n  static getMethods() {\n    return {\n      getQueryGenerationConfig: (widget: WidgetProps) => {\n        return {\n          select: {\n            limit: `${widget.widgetName}.pageSize`,\n            where: `${widget.widgetName}.searchText`,\n            offset: `${widget.widgetName}.pageOffset`,\n            orderBy: `${widget.widgetName}.sortOrder.column`,\n            sortOrder: `${widget.widgetName}.sortOrder.order !== \"desc\"`,\n          },\n          create: {\n            value: `(${widget.widgetName}.newRow || {})`,\n          },\n          update: {\n            value: `${widget.widgetName}.updatedRow`,\n            where: `${widget.widgetName}.updatedRow`,\n          },\n          totalRecord: true,\n        };\n      },\n      getPropertyUpdatesForQueryBinding: (\n        queryConfig: WidgetQueryConfig,\n        _widget: WidgetProps,\n        formConfig: WidgetQueryGenerationFormConfig,\n      ) => {\n        const widget = _widget as TableWidgetProps;\n\n        let modify = {};\n        const dynamicPropertyPathList: DynamicPath[] = [];\n\n        if (queryConfig.select) {\n          modify = merge(modify, {\n            tableData: queryConfig.select.data,\n            onPageChange: queryConfig.select.run,\n            serverSidePaginationEnabled: true,\n            onSearchTextChanged: formConfig.searchableColumn\n              ? queryConfig.select.run\n              : undefined,\n            onSort: queryConfig.select.run,\n            enableClientSideSearch: !formConfig.searchableColumn,\n            primaryColumnId: formConfig.primaryColumn,\n            isVisibleDownload: false,\n          });\n\n          dynamicPropertyPathList.push({ key: \"tableData\" });\n        }\n\n        if (queryConfig.create) {\n          modify = merge(modify, {\n            onAddNewRowSave: queryConfig.create.run,\n            allowAddNewRow: true,\n            ...Object.keys(widget.primaryColumns).reduce(\n              (prev: Record<string, boolean>, curr) => {\n                if (formConfig.primaryColumn !== curr) {\n                  prev[`primaryColumns.${curr}.isEditable`] = true;\n                  prev[`primaryColumns.${curr}.isCellEditable`] = true;\n                }\n\n                prev[`showInlineEditingOptionDropdown`] = true;\n\n                return prev;\n              },\n              {},\n            ),\n          });\n        }\n\n        if (queryConfig.update) {\n          let editAction = {};\n\n          if (\n            !Object.values(widget.primaryColumns).some(\n              (column) => column.columnType === ColumnTypes.EDIT_ACTIONS,\n            )\n          ) {\n            editAction = Object.values(createEditActionColumn(widget)).reduce(\n              (\n                prev: Record<string, unknown>,\n                curr: {\n                  propertyPath: string;\n                  propertyValue: unknown;\n                  isDynamicPropertyPath?: boolean;\n                },\n              ) => {\n                prev[curr.propertyPath] = curr.propertyValue;\n\n                if (curr.isDynamicPropertyPath) {\n                  dynamicPropertyPathList.push({ key: curr.propertyPath });\n                }\n\n                return prev;\n              },\n              {},\n            );\n          }\n\n          modify = merge(modify, {\n            ...editAction,\n            [`primaryColumns.EditActions1.onSave`]: queryConfig.update.run,\n          });\n        }\n\n        if (queryConfig.total_record) {\n          modify = merge(modify, {\n            totalRecordsCount: queryConfig.total_record.data,\n          });\n        }\n\n        return {\n          modify,\n          dynamicUpdates: {\n            dynamicPropertyPathList,\n          },\n        };\n      },\n      getSnipingModeUpdates: (\n        propValueMap: SnipingModeProperty,\n      ): PropertyUpdates[] => {\n        return [\n          {\n            propertyPath: \"tableData\",\n            propertyValue: propValueMap.data,\n            isDynamicPropertyPath: !!propValueMap.isDynamicPropertyPath,\n          },\n        ];\n      },\n      getOneClickBindingConnectableWidgetConfig: (widget: WidgetProps) => {\n        return {\n          widgetBindPath: `${widget.widgetName}.selectedRow`,\n          message: `Make sure ${widget.widgetName} is bound to the same data source`,\n        };\n      },\n    };\n  }\n\n  static getAutoLayoutConfig() {\n    return {\n      widgetSize: [\n        {\n          viewportMinWidth: 0,\n          configuration: () => {\n            return {\n              minWidth: \"280px\",\n              minHeight: \"300px\",\n            };\n          },\n        },\n      ],\n    };\n  }\n\n  static getAnvilConfig(): AnvilConfig | null {\n    return {\n      isLargeWidget: false,\n      widgetSize: {\n        maxHeight: {},\n        maxWidth: {},\n        minHeight: { base: \"300px\" },\n        minWidth: { base: \"280px\" },\n      },\n    };\n  }\n\n  static getPropertyPaneContentConfig() {\n    return contentConfig;\n  }\n\n  static getPropertyPaneStyleConfig() {\n    return styleConfig;\n  }\n\n  constructor(props: TableWidgetProps) {\n    super(props);\n    // generate new cache instances so that each table widget instance has its own respective cache instance\n    this.memoisedAddNewRow = getMemoisedAddNewRow();\n    this.memoiseGetColumnsWithLocalStorage =\n      getMemoiseGetColumnsWithLocalStorageFn();\n    this.memoiseTransformDataWithEditableCell =\n      getMemoiseTransformDataWithEditableCell();\n  }\n\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static getMetaPropertiesMap(): Record<string, any> {\n    return {\n      pageNo: 1,\n      selectedRowIndex: undefined,\n      selectedRowIndices: undefined,\n      searchText: undefined,\n      triggeredRowIndex: undefined,\n      filters: [],\n      sortOrder: {\n        column: \"\",\n        order: null,\n      },\n      transientTableData: {},\n      updatedRowIndex: -1,\n      editableCell: defaultEditableCell,\n      columnEditableCellValue: {},\n      selectColumnFilterText: {},\n      isAddRowInProgress: false,\n      newRowContent: undefined,\n      newRow: undefined,\n      previousPageVisited: false,\n      nextPageVisited: false,\n    };\n  }\n\n  static getAutocompleteDefinitions(): AutocompletionDefinitions {\n    return (widget: TableWidgetProps, extraDefsToDefine?: ExtraDef) => {\n      const config: AutocompletionDefinitions = {\n        \"!doc\":\n          \"The Table is the hero widget of Appsmith. You can display data from an API in a table, trigger an action when a user selects a row and even work with large",
            "cost": 0.24933
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts": {
            "output": "import { ValidationTypes } from \"constants/WidgetValidation\";\nimport type { TableWidgetProps } from \"widgets/TableWidgetV2/constants\";\nimport { ColumnTypes } from \"widgets/TableWidgetV2/constants\";\nimport { get } from \"lodash\";\nimport {\n  getBasePropertyPath,\n  hideByColumnType,\n  updateColumnLevelEditability,\n  updateColumnOrderWhenFrozen,\n  updateInlineEditingOptionDropdownVisibilityHook,\n} from \"../../propertyUtils\";\nimport { isColumnTypeEditable } from \"../../utilities\";\nimport { composePropertyUpdateHook } from \"widgets/WidgetUtils\";\nimport { ButtonVariantTypes } from \"components/constants\";\nimport { StickyType } from \"widgets/TableWidgetV2/component/Constants\";\n\nexport default {\n  sectionName: \"General\",\n  children: [\n    {\n      propertyName: \"isCellVisible\",\n      dependencies: [\"primaryColumns\", \"columnType\"],\n      label: \"Visible\",\n      helpText: \"Controls the visibility of the cell in the column\",\n      defaultValue: true,\n      controlType: \"SWITCH\",\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.BOOLEAN,\n        },\n      },\n    },\n    {\n      propertyName: \"isDisabled\",\n      label: \"Disabled\",\n      helpText: \"Controls the disabled state of the button\",\n      defaultValue: false,\n      controlType: \"SWITCH\",\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.BOOLEAN,\n        },\n      },\n      dependencies: [\"primaryColumns\", \"columnOrder\"],\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [\n          ColumnTypes.ICON_BUTTON,\n          ColumnTypes.MENU_BUTTON,\n          ColumnTypes.BUTTON,\n        ]);\n      },\n    },\n    {\n      propertyName: \"isCompact\",\n      helpText: \"Decides if menu items will consume lesser space\",\n      label: \"Compact\",\n      controlType: \"SWITCH\",\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      isBindProperty: true,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.BOOLEAN,\n        },\n      },\n      isTriggerProperty: false,\n      dependencies: [\"primaryColumns\", \"columnOrder\"],\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [ColumnTypes.MENU_BUTTON]);\n      },\n    },\n    {\n      propertyName: \"allowCellWrapping\",\n      dependencies: [\"primaryColumns\", \"columnType\"],\n      label: \"Cell wrapping\",\n      helpText: \"Allows content of the cell to be wrapped\",\n      defaultValue: false,\n      controlType: \"SWITCH\",\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.BOOLEAN,\n        },\n      },\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [\n          ColumnTypes.TEXT,\n          ColumnTypes.NUMBER,\n          ColumnTypes.URL,\n        ]);\n      },\n    },\n    {\n      propertyName: \"isCellEditable\",\n      dependencies: [\n        \"primaryColumns\",\n        \"columnOrder\",\n        \"columnType\",\n        \"childStylesheet\",\n        \"inlineEditingSaveOption\",\n      ],\n      label: \"Editable\",\n      helpText: \"Controls the cell's editablity\",\n      defaultValue: false,\n      controlType: \"SWITCH\",\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      updateHook: composePropertyUpdateHook([\n        updateColumnLevelEditability,\n        updateInlineEditingOptionDropdownVisibilityHook,\n      ]),\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.BOOLEAN,\n        },\n      },\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        const baseProperty = getBasePropertyPath(propertyPath);\n        const columnType = get(props, `${baseProperty}.columnType`, \"\");\n        const isDerived = get(props, `${baseProperty}.isDerived`, false);\n\n        return !isColumnTypeEditable(columnType) || isDerived;\n      },\n    },\n    {\n      propertyName: \"sticky\",\n      helpText:\n        \"Choose column that needs to be frozen left or right of the table\",\n      controlType: \"ICON_TABS\",\n      defaultValue: StickyType.NONE,\n      label: \"Column freeze\",\n      fullWidth: true,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      dependencies: [\"primaryColumns\", \"columnOrder\"],\n      options: [\n        {\n          startIcon: \"contract-left-line\",\n          value: StickyType.LEFT,\n        },\n        {\n          startIcon: \"column-freeze\",\n          value: StickyType.NONE,\n        },\n        {\n          startIcon: \"contract-right-line\",\n          value: StickyType.RIGHT,\n        },\n      ],\n      updateHook: updateColumnOrderWhenFrozen,\n    },\n  ],\n};\n\nexport const GeneralStyle = {\n  sectionName: \"General\",\n  children: [\n    {\n      propertyName: \"buttonVariant\",\n      label: \"Button variant\",\n      controlType: \"ICON_TABS\",\n      fullWidth: true,\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      helpText: \"Sets the variant\",\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [\n          ColumnTypes.ICON_BUTTON,\n          ColumnTypes.BUTTON,\n        ]);\n      },\n      dependencies: [\"primaryColumns\", \"columnOrder\"],\n      options: [\n        {\n          label: \"Primary\",\n          value: ButtonVariantTypes.PRIMARY,\n        },\n        {\n          label: \"Secondary\",\n          value: ButtonVariantTypes.SECONDARY,\n        },\n        {\n          label: \"Tertiary\",\n          value: ButtonVariantTypes.TERTIARY,\n        },\n      ],\n      defaultValue: ButtonVariantTypes.PRIMARY,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.TEXT,\n          params: {\n            default: ButtonVariantTypes.PRIMARY,\n            allowedValues: [\n              ButtonVariantTypes.PRIMARY,\n              ButtonVariantTypes.SECONDARY,\n              ButtonVariantTypes.TERTIARY,\n            ],\n          },\n        },\n      },\n    },\n    {\n      propertyName: \"menuVariant\",\n      label: \"Button variant\",\n      controlType: \"ICON_TABS\",\n      fullWidth: true,\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      helpText: \"Sets the variant of the menu button\",\n      options: [\n        {\n          label: \"Primary\",\n          value: ButtonVariantTypes.PRIMARY,\n        },\n        {\n          label: \"Secondary\",\n          value: ButtonVariantTypes.SECONDARY,\n        },\n        {\n          label: \"Tertiary\",\n          value: ButtonVariantTypes.TERTIARY,\n        },\n      ],\n      isJSConvertible: true,\n      dependencies: [\"primaryColumns\", \"columnOrder\"],\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [ColumnTypes.MENU_BUTTON]);\n      },\n      isBindProperty: true,\n      isTriggerProperty: false,\n      defaultValue: ButtonVariantTypes.PRIMARY,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.TEXT,\n          params: {\n            default: ButtonVariantTypes.PRIMARY,\n            allowedValues: [\n              ButtonVariantTypes.PRIMARY,\n              ButtonVariantTypes.SECONDARY,\n              ButtonVariantTypes.TERTIARY,\n            ],\n          },\n        },\n      },\n    },\n    {\n      propertyName: \"imageSize\",\n      dependencies: [\"primaryColumns\", \"columnType\"],\n      label: \"Image Size\",\n      helpText: \"Sets the size of the image\",\n      defaultValue: \"DEFAULT\",\n      controlType: \"ICON_TABS\",\n      fullWidth: true,\n      options: [\n        {\n          label: \"Default\",\n          value: \"DEFAULT\",\n        },\n        {\n          label: \"Medium\",\n          value: \"MEDIUM\",\n        },\n        {\n          label: \"Large\",\n          value: \"LARGE\",\n        },\n      ],\n      isBindProperty: false,\n      isTriggerProperty: false,\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [ColumnTypes.IMAGE]);\n      },\n    },\n  ],\n};",
            "output_extracted": "import { ValidationTypes } from \"constants/WidgetValidation\";\nimport type { TableWidgetProps } from \"widgets/TableWidgetV2/constants\";\nimport { ColumnTypes } from \"widgets/TableWidgetV2/constants\";\nimport { get } from \"lodash\";\nimport {\n  getBasePropertyPath,\n  hideByColumnType,\n  updateColumnLevelEditability,\n  updateColumnOrderWhenFrozen,\n  updateInlineEditingOptionDropdownVisibilityHook,\n} from \"../../propertyUtils\";\nimport { isColumnTypeEditable } from \"../../utilities\";\nimport { composePropertyUpdateHook } from \"widgets/WidgetUtils\";\nimport { ButtonVariantTypes } from \"components/constants\";\nimport { StickyType } from \"widgets/TableWidgetV2/component/Constants\";\n\nexport default {\n  sectionName: \"General\",\n  children: [\n    {\n      propertyName: \"isCellVisible\",\n      dependencies: [\"primaryColumns\", \"columnType\"],\n      label: \"Visible\",\n      helpText: \"Controls the visibility of the cell in the column\",\n      defaultValue: true,\n      controlType: \"SWITCH\",\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.BOOLEAN,\n        },\n      },\n    },\n    {\n      propertyName: \"isDisabled\",\n      label: \"Disabled\",\n      helpText: \"Controls the disabled state of the button\",\n      defaultValue: false,\n      controlType: \"SWITCH\",\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.BOOLEAN,\n        },\n      },\n      dependencies: [\"primaryColumns\", \"columnOrder\"],\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [\n          ColumnTypes.ICON_BUTTON,\n          ColumnTypes.MENU_BUTTON,\n          ColumnTypes.BUTTON,\n        ]);\n      },\n    },\n    {\n      propertyName: \"isCompact\",\n      helpText: \"Decides if menu items will consume lesser space\",\n      label: \"Compact\",\n      controlType: \"SWITCH\",\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      isBindProperty: true,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.BOOLEAN,\n        },\n      },\n      isTriggerProperty: false,\n      dependencies: [\"primaryColumns\", \"columnOrder\"],\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [ColumnTypes.MENU_BUTTON]);\n      },\n    },\n    {\n      propertyName: \"allowCellWrapping\",\n      dependencies: [\"primaryColumns\", \"columnType\"],\n      label: \"Cell wrapping\",\n      helpText: \"Allows content of the cell to be wrapped\",\n      defaultValue: false,\n      controlType: \"SWITCH\",\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.BOOLEAN,\n        },\n      },\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [\n          ColumnTypes.TEXT,\n          ColumnTypes.NUMBER,\n          ColumnTypes.URL,\n        ]);\n      },\n    },\n    {\n      propertyName: \"isCellEditable\",\n      dependencies: [\n        \"primaryColumns\",\n        \"columnOrder\",\n        \"columnType\",\n        \"childStylesheet\",\n        \"inlineEditingSaveOption\",\n      ],\n      label: \"Editable\",\n      helpText: \"Controls the cell's editablity\",\n      defaultValue: false,\n      controlType: \"SWITCH\",\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      updateHook: composePropertyUpdateHook([\n        updateColumnLevelEditability,\n        updateInlineEditingOptionDropdownVisibilityHook,\n      ]),\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.BOOLEAN,\n        },\n      },\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        const baseProperty = getBasePropertyPath(propertyPath);\n        const columnType = get(props, `${baseProperty}.columnType`, \"\");\n        const isDerived = get(props, `${baseProperty}.isDerived`, false);\n\n        return !isColumnTypeEditable(columnType) || isDerived;\n      },\n    },\n    {\n      propertyName: \"sticky\",\n      helpText:\n        \"Choose column that needs to be frozen left or right of the table\",\n      controlType: \"ICON_TABS\",\n      defaultValue: StickyType.NONE,\n      label: \"Column freeze\",\n      fullWidth: true,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      dependencies: [\"primaryColumns\", \"columnOrder\"],\n      options: [\n        {\n          startIcon: \"contract-left-line\",\n          value: StickyType.LEFT,\n        },\n        {\n          startIcon: \"column-freeze\",\n          value: StickyType.NONE,\n        },\n        {\n          startIcon: \"contract-right-line\",\n          value: StickyType.RIGHT,\n        },\n      ],\n      updateHook: updateColumnOrderWhenFrozen,\n    },\n  ],\n};\n\nexport const GeneralStyle = {\n  sectionName: \"General\",\n  children: [\n    {\n      propertyName: \"buttonVariant\",\n      label: \"Button variant\",\n      controlType: \"ICON_TABS\",\n      fullWidth: true,\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      isJSConvertible: true,\n      helpText: \"Sets the variant\",\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [\n          ColumnTypes.ICON_BUTTON,\n          ColumnTypes.BUTTON,\n        ]);\n      },\n      dependencies: [\"primaryColumns\", \"columnOrder\"],\n      options: [\n        {\n          label: \"Primary\",\n          value: ButtonVariantTypes.PRIMARY,\n        },\n        {\n          label: \"Secondary\",\n          value: ButtonVariantTypes.SECONDARY,\n        },\n        {\n          label: \"Tertiary\",\n          value: ButtonVariantTypes.TERTIARY,\n        },\n      ],\n      defaultValue: ButtonVariantTypes.PRIMARY,\n      isBindProperty: true,\n      isTriggerProperty: false,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.TEXT,\n          params: {\n            default: ButtonVariantTypes.PRIMARY,\n            allowedValues: [\n              ButtonVariantTypes.PRIMARY,\n              ButtonVariantTypes.SECONDARY,\n              ButtonVariantTypes.TERTIARY,\n            ],\n          },\n        },\n      },\n    },\n    {\n      propertyName: \"menuVariant\",\n      label: \"Button variant\",\n      controlType: \"ICON_TABS\",\n      fullWidth: true,\n      customJSControl: \"TABLE_COMPUTE_VALUE\",\n      helpText: \"Sets the variant of the menu button\",\n      options: [\n        {\n          label: \"Primary\",\n          value: ButtonVariantTypes.PRIMARY,\n        },\n        {\n          label: \"Secondary\",\n          value: ButtonVariantTypes.SECONDARY,\n        },\n        {\n          label: \"Tertiary\",\n          value: ButtonVariantTypes.TERTIARY,\n        },\n      ],\n      isJSConvertible: true,\n      dependencies: [\"primaryColumns\", \"columnOrder\"],\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [ColumnTypes.MENU_BUTTON]);\n      },\n      isBindProperty: true,\n      isTriggerProperty: false,\n      defaultValue: ButtonVariantTypes.PRIMARY,\n      validation: {\n        type: ValidationTypes.ARRAY_OF_TYPE_OR_TYPE,\n        params: {\n          type: ValidationTypes.TEXT,\n          params: {\n            default: ButtonVariantTypes.PRIMARY,\n            allowedValues: [\n              ButtonVariantTypes.PRIMARY,\n              ButtonVariantTypes.SECONDARY,\n              ButtonVariantTypes.TERTIARY,\n            ],\n          },\n        },\n      },\n    },\n    {\n      propertyName: \"imageSize\",\n      dependencies: [\"primaryColumns\", \"columnType\"],\n      label: \"Image Size\",\n      helpText: \"Sets the size of the image\",\n      defaultValue: \"DEFAULT\",\n      controlType: \"ICON_TABS\",\n      fullWidth: true,\n      options: [\n        {\n          label: \"Default\",\n          value: \"DEFAULT\",\n        },\n        {\n          label: \"Medium\",\n          value: \"MEDIUM\",\n        },\n        {\n          label: \"Large\",\n          value: \"LARGE\",\n        },\n      ],\n      isBindProperty: false,\n      isTriggerProperty: false,\n      hidden: (props: TableWidgetProps, propertyPath: string) => {\n        return hideByColumnType(props, propertyPath, [ColumnTypes.IMAGE]);\n      },\n    },\n  ],\n};",
            "cost": 0.08143500000000001
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts": {
            "output": "import type { PropertyPaneConfig } from \"constants/PropertyControlConstants\";\nimport { ValidationTypes } from \"constants/WidgetValidation\";\nimport {\n  createMessage,\n  TABLE_WIDGET_TOTAL_RECORD_TOOLTIP,\n} from \"ee/constants/messages\";\nimport { EvaluationSubstitutionType } from \"constants/EvaluationConstants\";\nimport { AutocompleteDataType } from \"utils/autocomplete/AutocompleteDataType\";\nimport type { TableWidgetProps } from \"widgets/TableWidgetV2/constants\";\nimport {\n  INFINITE_SCROLL_ENABLED,\n  InlineEditingSaveOptions,\n} from \"widgets/TableWidgetV2/constants\";\nimport { composePropertyUpdateHook } from \"widgets/WidgetUtils\";\nimport {\n  ALLOW_TABLE_WIDGET_SERVER_SIDE_FILTERING,\n  CUSTOM_SORT_FUNCTION_ENABLED,\n} from \"../../constants\";\nimport Widget from \"../index\";\nimport {\n  tableDataValidation,\n  totalRecordsCountValidation,\n  uniqueColumnNameValidation,\n  updateAllowAddNewRowOnInfiniteScrollChange,\n  updateCellEditabilityOnInfiniteScrollChange,\n  updateColumnOrderHook,\n  updateCustomColumnAliasOnLabelChange,\n  updateInlineEditingOptionDropdownVisibilityHook,\n  updateInlineEditingSaveOptionHook,\n  updateSearchSortFilterOnInfiniteScrollChange,\n} from \"../propertyUtils\";\nimport panelConfig from \"./PanelConfig\";\n\nconst INFINITE_SCROLL_DISABLED_HELP_TEXT =\n  \"This feature is disabled because infinite scroll is enabled\";\n\nexport default [\n  {\n    sectionName: \"Data\",\n    children: [\n      {\n        helpText:\n          \"Takes in an array of objects to display rows in the table. Bind data from an API using {{}}\",\n        propertyName: \"tableData\",\n        label: \"Table data\",\n        controlType: \"ONE_CLICK_BINDING_CONTROL\",\n        controlConfig: {\n          searchableColumn: true,\n          maxHeight: \"400px\",\n        },\n        placeholderText: '[{ \"name\": \"John\" }]',\n        inputType: \"ARRAY\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        isJSConvertible: true,\n        validation: {\n          type: ValidationTypes.FUNCTION,\n          params: {\n            fn: tableDataValidation,\n            expected: {\n              type: \"Array\",\n              example: `[{ \"name\": \"John\" }]`,\n              autocompleteDataType: AutocompleteDataType.ARRAY,\n            },\n          },\n        },\n        evaluationSubstitutionType: EvaluationSubstitutionType.SMART_SUBSTITUTE,\n        shouldSwitchToNormalMode: (\n          isDynamic: boolean,\n          isToggleDisabled: boolean,\n          triggerFlag?: boolean,\n        ) => triggerFlag && isDynamic && !isToggleDisabled,\n      },\n      {\n        propertyName: \"primaryColumns\",\n        controlType: \"PRIMARY_COLUMNS_V2\",\n        label: \"Columns\",\n        updateHook: composePropertyUpdateHook([\n          updateColumnOrderHook,\n          updateInlineEditingOptionDropdownVisibilityHook,\n          updateCustomColumnAliasOnLabelChange,\n        ]),\n        dependencies: [\n          \"primaryColumns\",\n          \"columnOrder\",\n          \"childStylesheet\",\n          \"inlineEditingSaveOption\",\n          \"textColor\",\n          \"textSize\",\n          \"fontStyle\",\n          \"cellBackground\",\n          \"verticalAlignment\",\n          \"horizontalAlignment\",\n        ],\n        isBindProperty: false,\n        isTriggerProperty: false,\n        validation: {\n          type: ValidationTypes.FUNCTION,\n          params: {\n            fn: uniqueColumnNameValidation,\n            expected: {\n              type: \"Unique column names\",\n              example: \"abc\",\n              autocompleteDataType: AutocompleteDataType.STRING,\n            },\n          },\n        },\n        panelConfig,\n      },\n      {\n        propertyName: \"inlineEditingSaveOption\",\n        helpText: \"Choose the save experience to save the edited cell\",\n        label: \"Update mode\",\n        controlType: \"ICON_TABS\",\n        defaultValue: InlineEditingSaveOptions.ROW_LEVEL,\n        fullWidth: true,\n        isBindProperty: true,\n        isTriggerProperty: false,\n        hidden: (props: TableWidgetProps) => {\n          return (\n            !props.showInlineEditingOptionDropdown &&\n            !Object.values(props.primaryColumns).find(\n              (column) => column.isEditable,\n            )\n          );\n        },\n        dependencies: [\n          \"primaryColumns\",\n          \"columnOrder\",\n          \"childStylesheet\",\n          \"showInlineEditingOptionDropdown\",\n        ],\n        options: [\n          {\n            label: \"Single Row\",\n            value: InlineEditingSaveOptions.ROW_LEVEL,\n          },\n          {\n            label: \"Multi Row\",\n            value: InlineEditingSaveOptions.CUSTOM,\n          },\n        ],\n        updateHook: updateInlineEditingSaveOptionHook,\n      },\n      {\n        helpText:\n          \"Assigns a unique column which helps maintain selectedRows and triggeredRows based on value\",\n        propertyName: \"primaryColumnId\",\n        dependencies: [\"primaryColumns\"],\n        label: \"Primary key column\",\n        controlType: \"PRIMARY_COLUMNS_DROPDOWN\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: { type: ValidationTypes.TEXT },\n      },\n    ],\n    // Added this prop to indicate that data section needs to be expanded by default\n    // Rest all sections needs to be collapsed\n    // We already have a isDefaultOpen prop configured to keep a section expanded or not\n    // but introducing new prop so that we can control is based on flag\n    // Once we decide to keep this feature, we can go back to using isDefaultOpen and removeexpandedByDefault\n    expandedByDefault: true,\n  },\n  {\n    sectionName: \"Pagination\",\n    children: [\n      {\n        propertyName: \"isVisiblePagination\",\n        helpText: \"Toggle visibility of the pagination\",\n        label: \"Show pagination\",\n        controlType: \"SWITCH\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: { type: ValidationTypes.BOOLEAN },\n      },\n      {\n        helpText:\n          \"Bind the Table.pageNo property in your API and call it onPageChange\",\n        propertyName: \"serverSidePaginationEnabled\",\n        label: \"Server side pagination\",\n        controlType: \"SWITCH\",\n        isBindProperty: false,\n        isTriggerProperty: false,\n        shouldDisableSection: (props: TableWidgetProps) =>\n          props.infiniteScrollEnabled,\n        disabledHelpText: INFINITE_SCROLL_DISABLED_HELP_TEXT,\n        dependencies: [\"infiniteScrollEnabled\"],\n      },\n      {\n        helpText:\n          \"Bind the Table.pageNo property in your API and call it onPageChange\",\n        propertyName: \"infiniteScrollEnabled\",\n        label: \"Infinite scroll\",\n        controlType: \"SWITCH\",\n        isBindProperty: false,\n        isTriggerProperty: false,\n        updateHook: composePropertyUpdateHook([\n          updateAllowAddNewRowOnInfiniteScrollChange,\n          updateCellEditabilityOnInfiniteScrollChange,\n          updateSearchSortFilterOnInfiniteScrollChange,\n        ]),\n        dependencies: [\"primaryColumns\", \"serverSidePaginationEnabled\"],\n        hidden: (props: TableWidgetProps) =>\n          !Widget.getFeatureFlag(INFINITE_SCROLL_ENABLED) ||\n          !props.serverSidePaginationEnabled,\n      },\n      {\n        helpText: createMessage(TABLE_WIDGET_TOTAL_RECORD_TOOLTIP),\n        propertyName: \"totalRecordsCount\",\n        label: \"Total Records\",\n        controlType: \"INPUT_TEXT\",\n        placeholderText: \"Enter total record count\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: {\n          type: ValidationTypes.FUNCTION,\n          params: {\n            fn: totalRecordsCountValidation,\n            expected: {\n              type: \"Number\",\n              example: \"10\",\n              autocompleteDataType: AutocompleteDataType.STRING,\n            },\n          },\n        },\n        hidden: (props: TableWidgetProps) => !props.serverSidePaginationEnabled,\n        dependencies: [\"serverSidePaginationEnabled\"],\n      },\n      {\n        helpText: \"when a table page is changed\",\n        propertyName: \"onPageChange\",\n        label: \"onPageChange\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n        hidden: (props: TableWidgetProps) => !props.serverSidePaginationEnabled,\n        dependencies: [\"serverSidePaginationEnabled\"],\n      },\n      {\n        helpText: \"when a table page size is changed\",\n        propertyName: \"onPageSizeChange\",\n        label: \"onPageSizeChange\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n        hidden: (props: TableWidgetProps) => !props.serverSidePaginationEnabled,\n        dependencies: [\"serverSidePaginationEnabled\"],\n      },\n    ],\n    expandedByDefault: false,\n  },\n  {\n    sectionName: \"Search & filters\",\n    shouldDisableSection: (props: TableWidgetProps) =>\n      props.infiniteScrollEnabled,\n    disabledHelpText: INFINITE_SCROLL_DISABLED_HELP_TEXT,\n    dependencies: [\"infiniteScrollEnabled\"],\n    children: [\n      {\n        propertyName: \"isVisibleSearch\",\n        helpText: \"Toggle visibility of the search box\",\n        label: \"Allow searching\",\n        controlType: \"SWITCH\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: { type: ValidationTypes.BOOLEAN },\n      },\n      {\n        propertyName: \"enableClientSideSearch\",\n        label: \"Client side search\",\n        helpText: \"Searches all results only on the data which is loaded\",\n        controlType: \"SWITCH\",\n        isBindProperty: false,\n        isTriggerProperty: false,\n        hidden: (props: TableWidgetProps) => !props.isVisibleSearch,\n        dependencies: [\"isVisibleSearch\"],\n      },\n      {\n        propertyName: \"enableServerSideFiltering\",\n        label: \"Server side filtering\",\n        helpText: \"Filters all the results on the server side\",\n        controlType: \"SWITCH\",\n        isBindProperty: false,\n        isTriggerProperty: false,\n        defaultValue: false,\n        hidden: () =>\n          !Widget.getFeatureFlag(ALLOW_TABLE_WIDGET_SERVER_SIDE_FILTERING),\n      },\n      {\n        propertyName: \"onTableFilterUpdate\",\n        label: \"onTableFilterUpdate\",\n        helpText: \"when table filter is modified by the user\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n        hidden: (props: TableWidgetProps) => !props.enableServerSideFiltering,\n        dependencies: [\"enableServerSideFiltering\"],\n      },\n      {\n        propertyName: \"defaultSearchText\",\n        label: \"Default search text\",\n        helpText: \"Adds a search text by default\",\n        controlType: \"INPUT_TEXT\",\n        placeholderText: \"{{appsmith.user.name}}\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: { type: ValidationTypes.TEXT },\n        hidden: (props: TableWidgetProps) => !props.isVisibleSearch,\n        dependencies: [\"isVisibleSearch\"],\n      },\n      {\n        propertyName: \"onSearchTextChanged\",\n        label: \"onSearchTextChanged\",\n        helpText: \"when search text is modified by the user\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n        hidden: (props: TableWidgetProps) => !props.isVisibleSearch,\n        dependencies: [\"isVisibleSearch\"],\n      },\n      {\n        propertyName: \"isVisibleFilters\",\n        helpText: \"Toggle visibility of the filters\",\n        label: \"Allow filtering\",\n        controlType: \"SWITCH\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: { type: ValidationTypes.BOOLEAN },\n      },\n    ],\n    expandedByDefault: false,\n  },\n  {\n    sectionName: \"Row selection\",\n    children: [\n      {\n        helpText: \"Selects row(s) by default\",\n        propertyName: \"defaultSelectedRowIndices\",\n        label: \"Default selected rows\",\n        controlType: \"INPUT_TEXT\",\n        placeholderText: \"[0]\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: {\n          type: ValidationTypes.ARRAY,\n          params: {\n            children: {\n              type: ValidationTypes.NUMBER,\n              params: {\n                min: -1,\n                default: -1,\n              },\n            },\n          },\n        },\n        hidden: (props: TableWidgetProps) => {\n          return !props.multiRowSelection;\n        },\n        dependencies: [\"multiRowSelection\"],\n      },\n      {\n        helpText: \"Selects row by default\",\n        propertyName: \"defaultSelectedRowIndex\",\n        label: \"Default selected row\",\n        controlType: \"INPUT_TEXT\",\n        defaultValue: 0,\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: {\n          type: ValidationTypes.NUMBER,\n          params: {\n            min: -1,\n            default: -1,\n          },\n        },\n        hidden: (props: TableWidgetProps) => {\n          return props.multiRowSelection;\n        },\n        dependencies: [\"multiRowSelection\"],\n      },\n      {\n        propertyName: \"multiRowSelection\",\n        label: \"Enable multi-row selection\",\n        helpText: \"Allows users to select multiple rows\",\n        controlType: \"SWITCH\",\n        isBindProperty: false,\n        isTriggerProperty: false,\n      },\n      {\n        helpText: \"when a table row is selected\",\n        propertyName: \"onRowSelected\",\n        label: \"onRowSelected\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n      },\n    ],\n    expandedByDefault: false,\n  },\n  {\n    sectionName: \"Sorting\",\n    shouldDisableSection: (props: TableWidgetProps) =>\n      props.infiniteScrollEnabled,\n    disabledHelpText: INFINITE_SCROLL_DISABLED_HELP_TEXT,\n    dependencies: [\"infiniteScrollEnabled\"],\n    children: [\n      {\n        helpText: \"Controls sorting in View Mode\",\n        propertyName: \"isSortable\",\n        isJSConvertible: true,\n        label: \"Column sorting\",\n        controlType: \"SWITCH\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: {\n          type: ValidationTypes.BOOLEAN,\n          params: {\n            default: true,\n          },\n        },\n      },\n      {\n        helpText: \"when a table column is sorted\",\n        propertyName: \"onSort\",\n        label: \"onSort\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n        hidden: (props: TableWidgetProps) => !props.isSortable,\n        dependencies: [\"isSortable\"],\n      },\n      {\n        helperText:\n          \"Client side",
            "output_extracted": "import type { PropertyPaneConfig } from \"constants/PropertyControlConstants\";\nimport { ValidationTypes } from \"constants/WidgetValidation\";\nimport {\n  createMessage,\n  TABLE_WIDGET_TOTAL_RECORD_TOOLTIP,\n} from \"ee/constants/messages\";\nimport { EvaluationSubstitutionType } from \"constants/EvaluationConstants\";\nimport { AutocompleteDataType } from \"utils/autocomplete/AutocompleteDataType\";\nimport type { TableWidgetProps } from \"widgets/TableWidgetV2/constants\";\nimport {\n  INFINITE_SCROLL_ENABLED,\n  InlineEditingSaveOptions,\n} from \"widgets/TableWidgetV2/constants\";\nimport { composePropertyUpdateHook } from \"widgets/WidgetUtils\";\nimport {\n  ALLOW_TABLE_WIDGET_SERVER_SIDE_FILTERING,\n  CUSTOM_SORT_FUNCTION_ENABLED,\n} from \"../../constants\";\nimport Widget from \"../index\";\nimport {\n  tableDataValidation,\n  totalRecordsCountValidation,\n  uniqueColumnNameValidation,\n  updateAllowAddNewRowOnInfiniteScrollChange,\n  updateCellEditabilityOnInfiniteScrollChange,\n  updateColumnOrderHook,\n  updateCustomColumnAliasOnLabelChange,\n  updateInlineEditingOptionDropdownVisibilityHook,\n  updateInlineEditingSaveOptionHook,\n  updateSearchSortFilterOnInfiniteScrollChange,\n} from \"../propertyUtils\";\nimport panelConfig from \"./PanelConfig\";\n\nconst INFINITE_SCROLL_DISABLED_HELP_TEXT =\n  \"This feature is disabled because infinite scroll is enabled\";\n\nexport default [\n  {\n    sectionName: \"Data\",\n    children: [\n      {\n        helpText:\n          \"Takes in an array of objects to display rows in the table. Bind data from an API using {{}}\",\n        propertyName: \"tableData\",\n        label: \"Table data\",\n        controlType: \"ONE_CLICK_BINDING_CONTROL\",\n        controlConfig: {\n          searchableColumn: true,\n          maxHeight: \"400px\",\n        },\n        placeholderText: '[{ \"name\": \"John\" }]',\n        inputType: \"ARRAY\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        isJSConvertible: true,\n        validation: {\n          type: ValidationTypes.FUNCTION,\n          params: {\n            fn: tableDataValidation,\n            expected: {\n              type: \"Array\",\n              example: `[{ \"name\": \"John\" }]`,\n              autocompleteDataType: AutocompleteDataType.ARRAY,\n            },\n          },\n        },\n        evaluationSubstitutionType: EvaluationSubstitutionType.SMART_SUBSTITUTE,\n        shouldSwitchToNormalMode: (\n          isDynamic: boolean,\n          isToggleDisabled: boolean,\n          triggerFlag?: boolean,\n        ) => triggerFlag && isDynamic && !isToggleDisabled,\n      },\n      {\n        propertyName: \"primaryColumns\",\n        controlType: \"PRIMARY_COLUMNS_V2\",\n        label: \"Columns\",\n        updateHook: composePropertyUpdateHook([\n          updateColumnOrderHook,\n          updateInlineEditingOptionDropdownVisibilityHook,\n          updateCustomColumnAliasOnLabelChange,\n        ]),\n        dependencies: [\n          \"primaryColumns\",\n          \"columnOrder\",\n          \"childStylesheet\",\n          \"inlineEditingSaveOption\",\n          \"textColor\",\n          \"textSize\",\n          \"fontStyle\",\n          \"cellBackground\",\n          \"verticalAlignment\",\n          \"horizontalAlignment\",\n        ],\n        isBindProperty: false,\n        isTriggerProperty: false,\n        validation: {\n          type: ValidationTypes.FUNCTION,\n          params: {\n            fn: uniqueColumnNameValidation,\n            expected: {\n              type: \"Unique column names\",\n              example: \"abc\",\n              autocompleteDataType: AutocompleteDataType.STRING,\n            },\n          },\n        },\n        panelConfig,\n      },\n      {\n        propertyName: \"inlineEditingSaveOption\",\n        helpText: \"Choose the save experience to save the edited cell\",\n        label: \"Update mode\",\n        controlType: \"ICON_TABS\",\n        defaultValue: InlineEditingSaveOptions.ROW_LEVEL,\n        fullWidth: true,\n        isBindProperty: true,\n        isTriggerProperty: false,\n        hidden: (props: TableWidgetProps) => {\n          return (\n            !props.showInlineEditingOptionDropdown &&\n            !Object.values(props.primaryColumns).find(\n              (column) => column.isEditable,\n            )\n          );\n        },\n        dependencies: [\n          \"primaryColumns\",\n          \"columnOrder\",\n          \"childStylesheet\",\n          \"showInlineEditingOptionDropdown\",\n        ],\n        options: [\n          {\n            label: \"Single Row\",\n            value: InlineEditingSaveOptions.ROW_LEVEL,\n          },\n          {\n            label: \"Multi Row\",\n            value: InlineEditingSaveOptions.CUSTOM,\n          },\n        ],\n        updateHook: updateInlineEditingSaveOptionHook,\n      },\n      {\n        helpText:\n          \"Assigns a unique column which helps maintain selectedRows and triggeredRows based on value\",\n        propertyName: \"primaryColumnId\",\n        dependencies: [\"primaryColumns\"],\n        label: \"Primary key column\",\n        controlType: \"PRIMARY_COLUMNS_DROPDOWN\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: { type: ValidationTypes.TEXT },\n      },\n    ],\n    // Added this prop to indicate that data section needs to be expanded by default\n    // Rest all sections needs to be collapsed\n    // We already have a isDefaultOpen prop configured to keep a section expanded or not\n    // but introducing new prop so that we can control is based on flag\n    // Once we decide to keep this feature, we can go back to using isDefaultOpen and removeexpandedByDefault\n    expandedByDefault: true,\n  },\n  {\n    sectionName: \"Pagination\",\n    children: [\n      {\n        propertyName: \"isVisiblePagination\",\n        helpText: \"Toggle visibility of the pagination\",\n        label: \"Show pagination\",\n        controlType: \"SWITCH\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: { type: ValidationTypes.BOOLEAN },\n      },\n      {\n        helpText:\n          \"Bind the Table.pageNo property in your API and call it onPageChange\",\n        propertyName: \"serverSidePaginationEnabled\",\n        label: \"Server side pagination\",\n        controlType: \"SWITCH\",\n        isBindProperty: false,\n        isTriggerProperty: false,\n        shouldDisableSection: (props: TableWidgetProps) =>\n          props.infiniteScrollEnabled,\n        disabledHelpText: INFINITE_SCROLL_DISABLED_HELP_TEXT,\n        dependencies: [\"infiniteScrollEnabled\"],\n      },\n      {\n        helpText:\n          \"Bind the Table.pageNo property in your API and call it onPageChange\",\n        propertyName: \"infiniteScrollEnabled\",\n        label: \"Infinite scroll\",\n        controlType: \"SWITCH\",\n        isBindProperty: false,\n        isTriggerProperty: false,\n        updateHook: composePropertyUpdateHook([\n          updateAllowAddNewRowOnInfiniteScrollChange,\n          updateCellEditabilityOnInfiniteScrollChange,\n          updateSearchSortFilterOnInfiniteScrollChange,\n        ]),\n        dependencies: [\"primaryColumns\", \"serverSidePaginationEnabled\"],\n        hidden: (props: TableWidgetProps) =>\n          !Widget.getFeatureFlag(INFINITE_SCROLL_ENABLED) ||\n          !props.serverSidePaginationEnabled,\n      },\n      {\n        helpText: createMessage(TABLE_WIDGET_TOTAL_RECORD_TOOLTIP),\n        propertyName: \"totalRecordsCount\",\n        label: \"Total Records\",\n        controlType: \"INPUT_TEXT\",\n        placeholderText: \"Enter total record count\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: {\n          type: ValidationTypes.FUNCTION,\n          params: {\n            fn: totalRecordsCountValidation,\n            expected: {\n              type: \"Number\",\n              example: \"10\",\n              autocompleteDataType: AutocompleteDataType.STRING,\n            },\n          },\n        },\n        hidden: (props: TableWidgetProps) => !props.serverSidePaginationEnabled,\n        dependencies: [\"serverSidePaginationEnabled\"],\n      },\n      {\n        helpText: \"when a table page is changed\",\n        propertyName: \"onPageChange\",\n        label: \"onPageChange\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n        hidden: (props: TableWidgetProps) => !props.serverSidePaginationEnabled,\n        dependencies: [\"serverSidePaginationEnabled\"],\n      },\n      {\n        helpText: \"when a table page size is changed\",\n        propertyName: \"onPageSizeChange\",\n        label: \"onPageSizeChange\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n        hidden: (props: TableWidgetProps) => !props.serverSidePaginationEnabled,\n        dependencies: [\"serverSidePaginationEnabled\"],\n      },\n    ],\n    expandedByDefault: false,\n  },\n  {\n    sectionName: \"Search & filters\",\n    shouldDisableSection: (props: TableWidgetProps) =>\n      props.infiniteScrollEnabled,\n    disabledHelpText: INFINITE_SCROLL_DISABLED_HELP_TEXT,\n    dependencies: [\"infiniteScrollEnabled\"],\n    children: [\n      {\n        propertyName: \"isVisibleSearch\",\n        helpText: \"Toggle visibility of the search box\",\n        label: \"Allow searching\",\n        controlType: \"SWITCH\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: { type: ValidationTypes.BOOLEAN },\n      },\n      {\n        propertyName: \"enableClientSideSearch\",\n        label: \"Client side search\",\n        helpText: \"Searches all results only on the data which is loaded\",\n        controlType: \"SWITCH\",\n        isBindProperty: false,\n        isTriggerProperty: false,\n        hidden: (props: TableWidgetProps) => !props.isVisibleSearch,\n        dependencies: [\"isVisibleSearch\"],\n      },\n      {\n        propertyName: \"enableServerSideFiltering\",\n        label: \"Server side filtering\",\n        helpText: \"Filters all the results on the server side\",\n        controlType: \"SWITCH\",\n        isBindProperty: false,\n        isTriggerProperty: false,\n        defaultValue: false,\n        hidden: () =>\n          !Widget.getFeatureFlag(ALLOW_TABLE_WIDGET_SERVER_SIDE_FILTERING),\n      },\n      {\n        propertyName: \"onTableFilterUpdate\",\n        label: \"onTableFilterUpdate\",\n        helpText: \"when table filter is modified by the user\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n        hidden: (props: TableWidgetProps) => !props.enableServerSideFiltering,\n        dependencies: [\"enableServerSideFiltering\"],\n      },\n      {\n        propertyName: \"defaultSearchText\",\n        label: \"Default search text\",\n        helpText: \"Adds a search text by default\",\n        controlType: \"INPUT_TEXT\",\n        placeholderText: \"{{appsmith.user.name}}\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: { type: ValidationTypes.TEXT },\n        hidden: (props: TableWidgetProps) => !props.isVisibleSearch,\n        dependencies: [\"isVisibleSearch\"],\n      },\n      {\n        propertyName: \"onSearchTextChanged\",\n        label: \"onSearchTextChanged\",\n        helpText: \"when search text is modified by the user\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n        hidden: (props: TableWidgetProps) => !props.isVisibleSearch,\n        dependencies: [\"isVisibleSearch\"],\n      },\n      {\n        propertyName: \"isVisibleFilters\",\n        helpText: \"Toggle visibility of the filters\",\n        label: \"Allow filtering\",\n        controlType: \"SWITCH\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: { type: ValidationTypes.BOOLEAN },\n      },\n    ],\n    expandedByDefault: false,\n  },\n  {\n    sectionName: \"Row selection\",\n    children: [\n      {\n        helpText: \"Selects row(s) by default\",\n        propertyName: \"defaultSelectedRowIndices\",\n        label: \"Default selected rows\",\n        controlType: \"INPUT_TEXT\",\n        placeholderText: \"[0]\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: {\n          type: ValidationTypes.ARRAY,\n          params: {\n            children: {\n              type: ValidationTypes.NUMBER,\n              params: {\n                min: -1,\n                default: -1,\n              },\n            },\n          },\n        },\n        hidden: (props: TableWidgetProps) => {\n          return !props.multiRowSelection;\n        },\n        dependencies: [\"multiRowSelection\"],\n      },\n      {\n        helpText: \"Selects row by default\",\n        propertyName: \"defaultSelectedRowIndex\",\n        label: \"Default selected row\",\n        controlType: \"INPUT_TEXT\",\n        defaultValue: 0,\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: {\n          type: ValidationTypes.NUMBER,\n          params: {\n            min: -1,\n            default: -1,\n          },\n        },\n        hidden: (props: TableWidgetProps) => {\n          return props.multiRowSelection;\n        },\n        dependencies: [\"multiRowSelection\"],\n      },\n      {\n        propertyName: \"multiRowSelection\",\n        label: \"Enable multi-row selection\",\n        helpText: \"Allows users to select multiple rows\",\n        controlType: \"SWITCH\",\n        isBindProperty: false,\n        isTriggerProperty: false,\n      },\n      {\n        helpText: \"when a table row is selected\",\n        propertyName: \"onRowSelected\",\n        label: \"onRowSelected\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n      },\n    ],\n    expandedByDefault: false,\n  },\n  {\n    sectionName: \"Sorting\",\n    shouldDisableSection: (props: TableWidgetProps) =>\n      props.infiniteScrollEnabled,\n    disabledHelpText: INFINITE_SCROLL_DISABLED_HELP_TEXT,\n    dependencies: [\"infiniteScrollEnabled\"],\n    children: [\n      {\n        helpText: \"Controls sorting in View Mode\",\n        propertyName: \"isSortable\",\n        isJSConvertible: true,\n        label: \"Column sorting\",\n        controlType: \"SWITCH\",\n        isBindProperty: true,\n        isTriggerProperty: false,\n        validation: {\n          type: ValidationTypes.BOOLEAN,\n          params: {\n            default: true,\n          },\n        },\n      },\n      {\n        helpText: \"when a table column is sorted\",\n        propertyName: \"onSort\",\n        label: \"onSort\",\n        controlType: \"ACTION_SELECTOR\",\n        isJSConvertible: true,\n        isBindProperty: true,\n        isTriggerProperty: true,\n        hidden: (props: TableWidgetProps) => !props.isSortable,\n        dependencies: [\"isSortable\"],\n      },\n      {\n        helperText:\n          \"Client side",
            "cost": 0.13631500000000002
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts": {
            "output": "import { Alignment } from \"@blueprintjs/core\";\nimport type { ColumnProperties } from \"../component/Constants\";\nimport { StickyType } from \"../component/Constants\";\nimport { CellAlignmentTypes } from \"../component/Constants\";\nimport type { TableWidgetProps } from \"../constants\";\nimport { ColumnTypes, InlineEditingSaveOptions } from \"../constants\";\nimport _, { findIndex, get, isBoolean } from \"lodash\";\nimport { Colors } from \"constants/Colors\";\nimport {\n  combineDynamicBindings,\n  getDynamicBindings,\n} from \"utils/DynamicBindingUtils\";\nimport {\n  createEditActionColumn,\n  generateNewColumnOrderFromStickyValue,\n} from \"./utilities\";\nimport type { PropertyUpdates } from \"WidgetProvider/types\";\nimport { MenuItemsSource } from \"widgets/MenuButtonWidget/constants\";\nimport type { ValidationConfig } from \"constants/PropertyControlConstants\";\nimport type { ValidationResponse } from \"constants/WidgetValidation\";\n\nexport function totalRecordsCountValidation(\n  value: unknown,\n  props: TableWidgetProps,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _?: any,\n) {\n  const ERROR_MESSAGE = \"This value must be a number\";\n  const defaultValue = 0;\n\n  /*\n   * Undefined, null and empty string\n   */\n  if (_.isNil(value) || value === \"\") {\n    return {\n      isValid: true,\n      parsed: defaultValue,\n      messages: [],\n    };\n  } else if (\n    (!_.isFinite(value) && !_.isString(value)) ||\n    (_.isString(value) && !/^\\d+\\.?\\d*$/.test(value as string))\n  ) {\n    /*\n     * objects, array, string (but not cast-able to number type)\n     */\n    return {\n      isValid: false,\n      parsed: defaultValue,\n      messages: [{ name: \"ValidationError\", message: ERROR_MESSAGE }],\n    };\n  } else {\n    /*\n     * Number or number type cast-able\n     */\n    return {\n      isValid: true,\n      parsed: Number(value),\n      messages: [],\n    };\n  }\n}\n\nexport function uniqueColumnNameValidation(\n  value: unknown,\n  props: TableWidgetProps,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _?: any,\n) {\n  const tableColumnLabels = _.map(value, \"label\");\n  const duplicates = tableColumnLabels.find(\n    (val: string, index: number, arr: string[]) => arr.indexOf(val) !== index,\n  );\n\n  if (value && !!duplicates) {\n    return {\n      isValid: false,\n      parsed: value,\n      messages: [\"Column names should be unique.\"],\n    };\n  } else {\n    return {\n      isValid: true,\n      parsed: value,\n      messages: [\"\"],\n    };\n  }\n}\n\nexport function uniqueColumnAliasValidation(\n  value: unknown,\n  props: TableWidgetProps,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _?: any,\n) {\n  const aliases = _.map(Object.values(props.primaryColumns), \"alias\");\n  const duplicates = aliases.find(\n    (val: string, index: number, arr: string[]) => arr.indexOf(val) !== index,\n  );\n\n  if (!value) {\n    return {\n      isValid: false,\n      parsed: value,\n      messages: [\"Property name should not be empty.\"],\n    };\n  } else if (value && !!duplicates) {\n    return {\n      isValid: false,\n      parsed: value,\n      messages: [\"Property names should be unique.\"],\n    };\n  } else {\n    return {\n      isValid: true,\n      parsed: value,\n      messages: [\"\"],\n    };\n  }\n}\n\n/*\n * Hook to update all column styles, when global table styles are updated.\n */\nexport const updateColumnStyles = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  propertyValue: any,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Array<{ propertyPath: string; propertyValue: any }> | undefined => {\n  const { primaryColumns = {} } = props;\n  const propertiesToUpdate: Array<{\n    propertyPath: string;\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    propertyValue: any;\n  }> = [];\n  const styleName = propertyPath.split(\".\").shift();\n\n  // TODO: Figure out how propertyPaths will work when a nested property control is updating another property\n  if (primaryColumns && styleName) {\n    Object.values(primaryColumns).map((column: ColumnProperties) => {\n      const propertyPath = `primaryColumns.${column.id}.${styleName}`;\n\n      const notADynamicBinding =\n        !props.dynamicBindingPathList ||\n        props.dynamicBindingPathList.findIndex(\n          (item) => item.key === propertyPath,\n        ) === -1;\n\n      if (notADynamicBinding) {\n        propertiesToUpdate.push({\n          propertyPath,\n          propertyValue,\n        });\n      }\n    });\n\n    if (propertiesToUpdate.length > 0) {\n      return propertiesToUpdate;\n    }\n  } else {\n    return;\n  }\n};\n\n// Select default Icon Alignment when an icon is chosen\nexport function updateIconAlignment(\n  props: TableWidgetProps,\n  propertyPath: string,\n  propertyValue: string,\n) {\n  const property = getBasePropertyPath(propertyPath);\n  const iconAlign = get(props, `${property}.iconAlign`, \"\");\n  const propertiesToUpdate = [{ propertyPath, propertyValue }];\n\n  if (iconAlign) {\n    propertiesToUpdate.push({\n      propertyPath: \"iconAlign\",\n      propertyValue: Alignment.LEFT,\n    });\n  }\n\n  return propertiesToUpdate;\n}\n\n/*\n * Hook that updates columns order when a new column\n * gets added to the primaryColumns\n */\nexport const updateColumnOrderHook = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  propertyValue: any,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Array<{ propertyPath: string; propertyValue: any }> | undefined => {\n  const propertiesToUpdate: Array<{\n    propertyPath: string;\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    propertyValue: any;\n  }> = [];\n\n  if (props && propertyValue && /^primaryColumns\\.\\w+$/.test(propertyPath)) {\n    const newColumnOrder = [...(props.columnOrder || [])];\n\n    const rightColumnIndex = findIndex(\n      newColumnOrder,\n      (colName: string) =>\n        props.primaryColumns[colName]?.sticky === StickyType.RIGHT,\n    );\n\n    if (rightColumnIndex !== -1) {\n      newColumnOrder.splice(rightColumnIndex, 0, propertyValue.id);\n    } else {\n      newColumnOrder.splice(newColumnOrder.length, 0, propertyValue.id);\n    }\n\n    propertiesToUpdate.push({\n      propertyPath: \"columnOrder\",\n      propertyValue: newColumnOrder,\n    });\n\n    const newId = propertyValue.id;\n\n    if (newId) {\n      // sets default value for some properties\n      propertyValue.labelColor = Colors.WHITE;\n\n      propertiesToUpdate.push({\n        propertyPath: `primaryColumns.${newId}`,\n        propertyValue,\n      });\n    }\n  }\n\n  if (propertiesToUpdate.length > 0) {\n    return propertiesToUpdate;\n  } else {\n    return;\n  }\n};\n\nconst EDITABLITY_PATH_REGEX = /^primaryColumns\\.(\\w+)\\.isEditable$/;\n\nfunction isMatchingEditablePath(propertyPath: string) {\n  return (\n    EDITABLITY_PATH_REGEX.test(propertyPath) ||\n    CELL_EDITABLITY_PATH_REGEX.test(propertyPath)\n  );\n}\n\nexport const updateInlineEditingOptionDropdownVisibilityHook = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  propertyValue: any,\n): Array<PropertyUpdates> | undefined => {\n  let propertiesToUpdate = [];\n\n  if (\n    props &&\n    !props.showInlineEditingOptionDropdown &&\n    propertyValue &&\n    isMatchingEditablePath(propertyPath)\n  ) {\n    propertiesToUpdate.push({\n      propertyPath: `showInlineEditingOptionDropdown`,\n      propertyValue: true,\n    });\n  }\n\n  if (\n    props &&\n    isMatchingEditablePath(propertyPath) &&\n    props.inlineEditingSaveOption === InlineEditingSaveOptions.ROW_LEVEL &&\n    isBoolean(propertyValue)\n  ) {\n    if (propertyValue) {\n      const editActionsColumn = Object.values(props.primaryColumns).find(\n        (column) => column.columnType === ColumnTypes.EDIT_ACTIONS,\n      );\n\n      if (!editActionsColumn) {\n        propertiesToUpdate = [\n          ...propertiesToUpdate,\n          ...createEditActionColumn(props),\n        ];\n      }\n    } else {\n      const regex = /^primaryColumns\\.(\\w+)\\.(\\w+)$/;\n      const columnIdMatcher = propertyPath.match(regex);\n      const columnId = columnIdMatcher && columnIdMatcher[1];\n      const isAtleastOneColumnEditablePresent = Object.values(\n        props.primaryColumns,\n      ).some((column) => column.id !== columnId && column.isEditable);\n\n      if (!isAtleastOneColumnEditablePresent) {\n        const columnsArray = Object.values(props.primaryColumns);\n        const edtiActionColumn = columnsArray.find(\n          (column) => column.columnType === ColumnTypes.EDIT_ACTIONS,\n        );\n\n        if (edtiActionColumn && edtiActionColumn.id) {\n          const newColumnOrder = _.difference(props.columnOrder, [\n            edtiActionColumn.id,\n          ]);\n\n          propertiesToUpdate = [\n            ...propertiesToUpdate,\n            {\n              propertyPath: `primaryColumns.${edtiActionColumn.id}`,\n              shouldDeleteProperty: true,\n            },\n            {\n              propertyPath: \"columnOrder\",\n              propertyValue: newColumnOrder,\n            },\n          ];\n        }\n      }\n    }\n  }\n\n  if (propertiesToUpdate.length) {\n    return propertiesToUpdate;\n  }\n\n  return;\n};\n\nconst CELL_EDITABLITY_PATH_REGEX = /^primaryColumns\\.(\\w+)\\.isCellEditable$/;\n\n/**\n * Hook that updates frozen column's old indices and also adds columns to the frozen positions.\n */\nexport const updateColumnOrderWhenFrozen = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  propertyValue: string,\n) => {\n  if (props && props.columnOrder) {\n    const newColumnOrder = generateNewColumnOrderFromStickyValue(\n      props.primaryColumns,\n      props.columnOrder,\n      propertyPath.split(\".\")[1],\n      propertyValue,\n    );\n\n    return [\n      {\n        propertyPath: \"columnOrder\",\n        propertyValue: newColumnOrder,\n      },\n    ];\n  }\n};\n/*\n * Hook that updates column level editability when cell level editability is\n * updaed.\n */\nexport const updateColumnLevelEditability = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  propertyValue: any,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Array<{ propertyPath: string; propertyValue: any }> | undefined => {\n  if (\n    props &&\n    CELL_EDITABLITY_PATH_REGEX.test(propertyPath) &&\n    isBoolean(propertyValue)\n  ) {\n    const match = CELL_EDITABLITY_PATH_REGEX.exec(propertyPath) || [];\n    const columnIdHash = match[1];\n\n    if (columnIdHash) {\n      return [\n        {\n          propertyPath: `primaryColumns.${columnIdHash}.isEditable`,\n          propertyValue: propertyValue,\n        },\n      ];\n    } else {\n      return;\n    }\n  } else {\n    return;\n  }\n};\n\n/*\n * Gets the base property path excluding the current property.\n * For example, for  `primaryColumns[5].computedValue` it will return\n * `primaryColumns[5]`\n */\nexport const getBasePropertyPath = (\n  propertyPath: string,\n): string | undefined => {\n  const propertyPathRegex = /^(.*)\\.\\w+$/g;\n  const matches = [...propertyPath.matchAll(propertyPathRegex)][0];\n\n  if (matches && _.isArray(matches) && matches.length === 2) {\n    return matches[1];\n  } else {\n    return;\n  }\n};\n\n/*\n * Function to check if column should be hidden, based on\n * the given columnTypes\n */\nexport const hideByColumnType = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  columnTypes: ColumnTypes[],\n  shouldUsePropertyPath?: boolean,\n) => {\n  let baseProperty;\n\n  if (shouldUsePropertyPath) {\n    baseProperty = propertyPath;\n  } else {\n    baseProperty = getBasePropertyPath(propertyPath);\n  }\n\n  const columnType = get(props, `${baseProperty}.columnType`, \"\");\n\n  return !columnTypes.includes(columnType);\n};\n\n/*\n * Function to check if column should be shown, based on\n * the given columnTypes\n */\nexport const showByColumnType = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  columnTypes: ColumnTypes[],\n  shouldUsePropertyPath?: boolean,\n) => {\n  let baseProperty;\n\n  if (shouldUsePropertyPath) {\n    baseProperty = propertyPath;\n  } else {\n    baseProperty = getBasePropertyPath(propertyPath);\n  }\n\n  const columnType = get(props, `${baseProperty}.columnType`, \"\");\n\n  return columnTypes.includes(columnType);\n};\n\nexport const SelectColumnOptionsValidations = (\n  value: unknown,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  props: any,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _?: any,\n) => {\n  let isValid = true;\n  let parsed = value;\n  let message = \"\";\n  const expectedMessage = \"value should be an array of string\";\n\n  if (typeof value === \"string\" && value.trim() !== \"\") {\n    /*\n     *",
            "output_extracted": "import { Alignment } from \"@blueprintjs/core\";\nimport type { ColumnProperties } from \"../component/Constants\";\nimport { StickyType } from \"../component/Constants\";\nimport { CellAlignmentTypes } from \"../component/Constants\";\nimport type { TableWidgetProps } from \"../constants\";\nimport { ColumnTypes, InlineEditingSaveOptions } from \"../constants\";\nimport _, { findIndex, get, isBoolean } from \"lodash\";\nimport { Colors } from \"constants/Colors\";\nimport {\n  combineDynamicBindings,\n  getDynamicBindings,\n} from \"utils/DynamicBindingUtils\";\nimport {\n  createEditActionColumn,\n  generateNewColumnOrderFromStickyValue,\n} from \"./utilities\";\nimport type { PropertyUpdates } from \"WidgetProvider/types\";\nimport { MenuItemsSource } from \"widgets/MenuButtonWidget/constants\";\nimport type { ValidationConfig } from \"constants/PropertyControlConstants\";\nimport type { ValidationResponse } from \"constants/WidgetValidation\";\n\nexport function totalRecordsCountValidation(\n  value: unknown,\n  props: TableWidgetProps,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _?: any,\n) {\n  const ERROR_MESSAGE = \"This value must be a number\";\n  const defaultValue = 0;\n\n  /*\n   * Undefined, null and empty string\n   */\n  if (_.isNil(value) || value === \"\") {\n    return {\n      isValid: true,\n      parsed: defaultValue,\n      messages: [],\n    };\n  } else if (\n    (!_.isFinite(value) && !_.isString(value)) ||\n    (_.isString(value) && !/^\\d+\\.?\\d*$/.test(value as string))\n  ) {\n    /*\n     * objects, array, string (but not cast-able to number type)\n     */\n    return {\n      isValid: false,\n      parsed: defaultValue,\n      messages: [{ name: \"ValidationError\", message: ERROR_MESSAGE }],\n    };\n  } else {\n    /*\n     * Number or number type cast-able\n     */\n    return {\n      isValid: true,\n      parsed: Number(value),\n      messages: [],\n    };\n  }\n}\n\nexport function uniqueColumnNameValidation(\n  value: unknown,\n  props: TableWidgetProps,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _?: any,\n) {\n  const tableColumnLabels = _.map(value, \"label\");\n  const duplicates = tableColumnLabels.find(\n    (val: string, index: number, arr: string[]) => arr.indexOf(val) !== index,\n  );\n\n  if (value && !!duplicates) {\n    return {\n      isValid: false,\n      parsed: value,\n      messages: [\"Column names should be unique.\"],\n    };\n  } else {\n    return {\n      isValid: true,\n      parsed: value,\n      messages: [\"\"],\n    };\n  }\n}\n\nexport function uniqueColumnAliasValidation(\n  value: unknown,\n  props: TableWidgetProps,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _?: any,\n) {\n  const aliases = _.map(Object.values(props.primaryColumns), \"alias\");\n  const duplicates = aliases.find(\n    (val: string, index: number, arr: string[]) => arr.indexOf(val) !== index,\n  );\n\n  if (!value) {\n    return {\n      isValid: false,\n      parsed: value,\n      messages: [\"Property name should not be empty.\"],\n    };\n  } else if (value && !!duplicates) {\n    return {\n      isValid: false,\n      parsed: value,\n      messages: [\"Property names should be unique.\"],\n    };\n  } else {\n    return {\n      isValid: true,\n      parsed: value,\n      messages: [\"\"],\n    };\n  }\n}\n\n/*\n * Hook to update all column styles, when global table styles are updated.\n */\nexport const updateColumnStyles = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  propertyValue: any,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Array<{ propertyPath: string; propertyValue: any }> | undefined => {\n  const { primaryColumns = {} } = props;\n  const propertiesToUpdate: Array<{\n    propertyPath: string;\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    propertyValue: any;\n  }> = [];\n  const styleName = propertyPath.split(\".\").shift();\n\n  // TODO: Figure out how propertyPaths will work when a nested property control is updating another property\n  if (primaryColumns && styleName) {\n    Object.values(primaryColumns).map((column: ColumnProperties) => {\n      const propertyPath = `primaryColumns.${column.id}.${styleName}`;\n\n      const notADynamicBinding =\n        !props.dynamicBindingPathList ||\n        props.dynamicBindingPathList.findIndex(\n          (item) => item.key === propertyPath,\n        ) === -1;\n\n      if (notADynamicBinding) {\n        propertiesToUpdate.push({\n          propertyPath,\n          propertyValue,\n        });\n      }\n    });\n\n    if (propertiesToUpdate.length > 0) {\n      return propertiesToUpdate;\n    }\n  } else {\n    return;\n  }\n};\n\n// Select default Icon Alignment when an icon is chosen\nexport function updateIconAlignment(\n  props: TableWidgetProps,\n  propertyPath: string,\n  propertyValue: string,\n) {\n  const property = getBasePropertyPath(propertyPath);\n  const iconAlign = get(props, `${property}.iconAlign`, \"\");\n  const propertiesToUpdate = [{ propertyPath, propertyValue }];\n\n  if (iconAlign) {\n    propertiesToUpdate.push({\n      propertyPath: \"iconAlign\",\n      propertyValue: Alignment.LEFT,\n    });\n  }\n\n  return propertiesToUpdate;\n}\n\n/*\n * Hook that updates columns order when a new column\n * gets added to the primaryColumns\n */\nexport const updateColumnOrderHook = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  propertyValue: any,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Array<{ propertyPath: string; propertyValue: any }> | undefined => {\n  const propertiesToUpdate: Array<{\n    propertyPath: string;\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    propertyValue: any;\n  }> = [];\n\n  if (props && propertyValue && /^primaryColumns\\.\\w+$/.test(propertyPath)) {\n    const newColumnOrder = [...(props.columnOrder || [])];\n\n    const rightColumnIndex = findIndex(\n      newColumnOrder,\n      (colName: string) =>\n        props.primaryColumns[colName]?.sticky === StickyType.RIGHT,\n    );\n\n    if (rightColumnIndex !== -1) {\n      newColumnOrder.splice(rightColumnIndex, 0, propertyValue.id);\n    } else {\n      newColumnOrder.splice(newColumnOrder.length, 0, propertyValue.id);\n    }\n\n    propertiesToUpdate.push({\n      propertyPath: \"columnOrder\",\n      propertyValue: newColumnOrder,\n    });\n\n    const newId = propertyValue.id;\n\n    if (newId) {\n      // sets default value for some properties\n      propertyValue.labelColor = Colors.WHITE;\n\n      propertiesToUpdate.push({\n        propertyPath: `primaryColumns.${newId}`,\n        propertyValue,\n      });\n    }\n  }\n\n  if (propertiesToUpdate.length > 0) {\n    return propertiesToUpdate;\n  } else {\n    return;\n  }\n};\n\nconst EDITABLITY_PATH_REGEX = /^primaryColumns\\.(\\w+)\\.isEditable$/;\n\nfunction isMatchingEditablePath(propertyPath: string) {\n  return (\n    EDITABLITY_PATH_REGEX.test(propertyPath) ||\n    CELL_EDITABLITY_PATH_REGEX.test(propertyPath)\n  );\n}\n\nexport const updateInlineEditingOptionDropdownVisibilityHook = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  propertyValue: any,\n): Array<PropertyUpdates> | undefined => {\n  let propertiesToUpdate = [];\n\n  if (\n    props &&\n    !props.showInlineEditingOptionDropdown &&\n    propertyValue &&\n    isMatchingEditablePath(propertyPath)\n  ) {\n    propertiesToUpdate.push({\n      propertyPath: `showInlineEditingOptionDropdown`,\n      propertyValue: true,\n    });\n  }\n\n  if (\n    props &&\n    isMatchingEditablePath(propertyPath) &&\n    props.inlineEditingSaveOption === InlineEditingSaveOptions.ROW_LEVEL &&\n    isBoolean(propertyValue)\n  ) {\n    if (propertyValue) {\n      const editActionsColumn = Object.values(props.primaryColumns).find(\n        (column) => column.columnType === ColumnTypes.EDIT_ACTIONS,\n      );\n\n      if (!editActionsColumn) {\n        propertiesToUpdate = [\n          ...propertiesToUpdate,\n          ...createEditActionColumn(props),\n        ];\n      }\n    } else {\n      const regex = /^primaryColumns\\.(\\w+)\\.(\\w+)$/;\n      const columnIdMatcher = propertyPath.match(regex);\n      const columnId = columnIdMatcher && columnIdMatcher[1];\n      const isAtleastOneColumnEditablePresent = Object.values(\n        props.primaryColumns,\n      ).some((column) => column.id !== columnId && column.isEditable);\n\n      if (!isAtleastOneColumnEditablePresent) {\n        const columnsArray = Object.values(props.primaryColumns);\n        const edtiActionColumn = columnsArray.find(\n          (column) => column.columnType === ColumnTypes.EDIT_ACTIONS,\n        );\n\n        if (edtiActionColumn && edtiActionColumn.id) {\n          const newColumnOrder = _.difference(props.columnOrder, [\n            edtiActionColumn.id,\n          ]);\n\n          propertiesToUpdate = [\n            ...propertiesToUpdate,\n            {\n              propertyPath: `primaryColumns.${edtiActionColumn.id}`,\n              shouldDeleteProperty: true,\n            },\n            {\n              propertyPath: \"columnOrder\",\n              propertyValue: newColumnOrder,\n            },\n          ];\n        }\n      }\n    }\n  }\n\n  if (propertiesToUpdate.length) {\n    return propertiesToUpdate;\n  }\n\n  return;\n};\n\nconst CELL_EDITABLITY_PATH_REGEX = /^primaryColumns\\.(\\w+)\\.isCellEditable$/;\n\n/**\n * Hook that updates frozen column's old indices and also adds columns to the frozen positions.\n */\nexport const updateColumnOrderWhenFrozen = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  propertyValue: string,\n) => {\n  if (props && props.columnOrder) {\n    const newColumnOrder = generateNewColumnOrderFromStickyValue(\n      props.primaryColumns,\n      props.columnOrder,\n      propertyPath.split(\".\")[1],\n      propertyValue,\n    );\n\n    return [\n      {\n        propertyPath: \"columnOrder\",\n        propertyValue: newColumnOrder,\n      },\n    ];\n  }\n};\n/*\n * Hook that updates column level editability when cell level editability is\n * updaed.\n */\nexport const updateColumnLevelEditability = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  propertyValue: any,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Array<{ propertyPath: string; propertyValue: any }> | undefined => {\n  if (\n    props &&\n    CELL_EDITABLITY_PATH_REGEX.test(propertyPath) &&\n    isBoolean(propertyValue)\n  ) {\n    const match = CELL_EDITABLITY_PATH_REGEX.exec(propertyPath) || [];\n    const columnIdHash = match[1];\n\n    if (columnIdHash) {\n      return [\n        {\n          propertyPath: `primaryColumns.${columnIdHash}.isEditable`,\n          propertyValue: propertyValue,\n        },\n      ];\n    } else {\n      return;\n    }\n  } else {\n    return;\n  }\n};\n\n/*\n * Gets the base property path excluding the current property.\n * For example, for  `primaryColumns[5].computedValue` it will return\n * `primaryColumns[5]`\n */\nexport const getBasePropertyPath = (\n  propertyPath: string,\n): string | undefined => {\n  const propertyPathRegex = /^(.*)\\.\\w+$/g;\n  const matches = [...propertyPath.matchAll(propertyPathRegex)][0];\n\n  if (matches && _.isArray(matches) && matches.length === 2) {\n    return matches[1];\n  } else {\n    return;\n  }\n};\n\n/*\n * Function to check if column should be hidden, based on\n * the given columnTypes\n */\nexport const hideByColumnType = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  columnTypes: ColumnTypes[],\n  shouldUsePropertyPath?: boolean,\n) => {\n  let baseProperty;\n\n  if (shouldUsePropertyPath) {\n    baseProperty = propertyPath;\n  } else {\n    baseProperty = getBasePropertyPath(propertyPath);\n  }\n\n  const columnType = get(props, `${baseProperty}.columnType`, \"\");\n\n  return !columnTypes.includes(columnType);\n};\n\n/*\n * Function to check if column should be shown, based on\n * the given columnTypes\n */\nexport const showByColumnType = (\n  props: TableWidgetProps,\n  propertyPath: string,\n  columnTypes: ColumnTypes[],\n  shouldUsePropertyPath?: boolean,\n) => {\n  let baseProperty;\n\n  if (shouldUsePropertyPath) {\n    baseProperty = propertyPath;\n  } else {\n    baseProperty = getBasePropertyPath(propertyPath);\n  }\n\n  const columnType = get(props, `${baseProperty}.columnType`, \"\");\n\n  return columnTypes.includes(columnType);\n};\n\nexport const SelectColumnOptionsValidations = (\n  value: unknown,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  props: any,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _?: any,\n) => {\n  let isValid = true;\n  let parsed = value;\n  let message = \"\";\n  const expectedMessage = \"value should be an array of string\";\n\n  if (typeof value === \"string\" && value.trim() !== \"\") {\n    /*\n     *",
            "cost": 0.169745
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx": {
            "output": "import { isBoolean, isArray, findIndex, isEqual } from \"lodash\";\nimport type { RenderMode } from \"constants/WidgetConstants\";\nimport { RenderModes } from \"constants/WidgetConstants\";\nimport { StickyType } from \"../../component/Constants\";\nimport {\n  COLUMN_MIN_WIDTH,\n  DEFAULT_COLUMN_WIDTH,\n  DEFAULT_COLUMN_NAME,\n} from \"../../constants\";\nimport type { ReactTableColumnProps } from \"../../component/Constants\";\nimport memoizeOne from \"memoize-one\";\n\nexport type getColumns = (\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  renderCell: any,\n  columnWidthMap: { [key: string]: number } | undefined,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  orderedTableColumns: any,\n  componentWidth: number,\n  renderMode: RenderMode,\n  isPreviewMode: boolean,\n) => ReactTableColumnProps[];\n\n//TODO: (Vamsi) need to unit test this function\n\nexport const getColumnsPureFn: getColumns = (\n  renderCell,\n  columnWidthMap = {},\n  orderedTableColumns = [],\n  componentWidth,\n  renderMode,\n  isPreviewMode,\n) => {\n  let columns: ReactTableColumnProps[] = [];\n  const hiddenColumns: ReactTableColumnProps[] = [];\n\n  let totalColumnWidth = 0;\n\n  if (isArray(orderedTableColumns)) {\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    orderedTableColumns.forEach((column: any) => {\n      const isHidden = !column.isVisible;\n\n      const columnData = {\n        id: column.id,\n        Header:\n          column.hasOwnProperty(\"label\") && typeof column.label === \"string\"\n            ? column.label\n            : DEFAULT_COLUMN_NAME,\n        alias: column.alias,\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        accessor: (row: any) => row[column.alias],\n        width: columnWidthMap[column.id] || DEFAULT_COLUMN_WIDTH,\n        minWidth: COLUMN_MIN_WIDTH,\n        draggable: true,\n        isHidden: false,\n        isAscOrder: column.isAscOrder,\n        isDerived: column.isDerived,\n        sticky: column.sticky,\n        metaProperties: {\n          isHidden: isHidden,\n          type: column.columnType,\n          format: column.outputFormat || \"\",\n          inputFormat: column.inputFormat || \"\",\n          decimals: column.decimals || 0,\n        },\n        columnProperties: column,\n        Cell: renderCell,\n      };\n\n      const isAllCellVisible: boolean | boolean[] = column.isCellVisible;\n\n      /*\n       * If all cells are not visible or column itself is not visible,\n       * set isHidden and push it to hiddenColumns array else columns array\n       */\n      if (\n        (isBoolean(isAllCellVisible) && !isAllCellVisible) ||\n        (isArray(isAllCellVisible) &&\n          isAllCellVisible.every((visibility) => visibility === false)) ||\n        isHidden\n      ) {\n        columnData.isHidden = true;\n        hiddenColumns.push(columnData);\n      } else {\n        totalColumnWidth += columnData.width;\n        columns.push(columnData);\n      }\n    });\n  }\n\n  const lastColumnIndex = columns.length - 1;\n\n  if (totalColumnWidth < componentWidth) {\n    /*\n      This \"if\" block is responsible for upsizing the last column width\n      if there is space left in the table container towards the right\n    */\n    if (columns[lastColumnIndex]) {\n      const lastColumnWidth =\n        columns[lastColumnIndex].width || DEFAULT_COLUMN_WIDTH;\n      const remainingWidth = componentWidth - totalColumnWidth;\n\n      // Adding the remaining width i.e. space left towards the right, to the last column width\n      columns[lastColumnIndex].width = lastColumnWidth + remainingWidth;\n    }\n  } else if (totalColumnWidth > componentWidth) {\n    /*\n      This \"else-if\" block is responsible for downsizing the last column width\n      if the last column spills over resulting in horizontal scroll\n    */\n    const extraWidth = totalColumnWidth - componentWidth;\n\n    if (columns[lastColumnIndex]) {\n      const lastColWidth =\n        columns[lastColumnIndex].width || DEFAULT_COLUMN_WIDTH;\n\n      /*\n      Below if condition explanation:\n      Condition 1: (lastColWidth > COLUMN_MIN_WIDTH)\n        We will downsize the last column only if its greater than COLUMN_MIN_WIDTH\n      Condition 2: (extraWidth < lastColWidth)\n        This condition checks whether the last column is the only column that is spilling over.\n        If more than one columns are spilling over we won't downsize the last column\n    */\n      if (lastColWidth > COLUMN_MIN_WIDTH && extraWidth < lastColWidth) {\n        const availableWidthForLastColumn = lastColWidth - extraWidth;\n\n        /*\n        Below we are making sure last column width doesn't go lower than COLUMN_MIN_WIDTH again\n        as availableWidthForLastColumn might go lower than COLUMN_MIN_WIDTH in some cases\n      */\n        columns[lastColumnIndex].width =\n          availableWidthForLastColumn < COLUMN_MIN_WIDTH\n            ? COLUMN_MIN_WIDTH\n            : availableWidthForLastColumn;\n      }\n    }\n  }\n\n  /*\n   * In canvas render mode, hidden columns are rendered at the end of the table, so users can\n   * edit the hidden columns without having to make them visible first.\n   */\n  if (\n    hiddenColumns.length &&\n    renderMode === RenderModes.CANVAS &&\n    !isPreviewMode\n  ) {\n    // Get the index of the first column that is frozen to right\n    const rightFrozenColumnIdx = findIndex(\n      columns,\n      (col) => col.sticky === StickyType.RIGHT,\n    );\n\n    if (rightFrozenColumnIdx !== -1) {\n      columns.splice(rightFrozenColumnIdx, 0, ...hiddenColumns);\n    } else {\n      columns = columns.concat(hiddenColumns);\n    }\n  }\n\n  return columns.filter((column: ReactTableColumnProps) => !!column.id);\n};\n\n// the result of this cache function is a prop for the useTable hook, this prop needs to memoised as per their docs\n// we have noticed expensive computation from the useTable if columns isnt memoised\nexport const getMemoiseGetColumnsWithLocalStorageFn = () => {\n  const memoisedGetColumns = memoizeOne(getColumnsPureFn);\n\n  return memoizeOne(\n    //we are not using this parameter it is used by the memoisation comparator\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    (widgetLocalStorageState) => {\n      memoisedGetColumns.clear();\n\n      return memoisedGetColumns as getColumns;\n    },\n    isEqual,\n  );\n};",
            "output_extracted": "import { isBoolean, isArray, findIndex, isEqual } from \"lodash\";\nimport type { RenderMode } from \"constants/WidgetConstants\";\nimport { RenderModes } from \"constants/WidgetConstants\";\nimport { StickyType } from \"../../component/Constants\";\nimport {\n  COLUMN_MIN_WIDTH,\n  DEFAULT_COLUMN_WIDTH,\n  DEFAULT_COLUMN_NAME,\n} from \"../../constants\";\nimport type { ReactTableColumnProps } from \"../../component/Constants\";\nimport memoizeOne from \"memoize-one\";\n\nexport type getColumns = (\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  renderCell: any,\n  columnWidthMap: { [key: string]: number } | undefined,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  orderedTableColumns: any,\n  componentWidth: number,\n  renderMode: RenderMode,\n  isPreviewMode: boolean,\n) => ReactTableColumnProps[];\n\n//TODO: (Vamsi) need to unit test this function\n\nexport const getColumnsPureFn: getColumns = (\n  renderCell,\n  columnWidthMap = {},\n  orderedTableColumns = [],\n  componentWidth,\n  renderMode,\n  isPreviewMode,\n) => {\n  let columns: ReactTableColumnProps[] = [];\n  const hiddenColumns: ReactTableColumnProps[] = [];\n\n  let totalColumnWidth = 0;\n\n  if (isArray(orderedTableColumns)) {\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    orderedTableColumns.forEach((column: any) => {\n      const isHidden = !column.isVisible;\n\n      const columnData = {\n        id: column.id,\n        Header:\n          column.hasOwnProperty(\"label\") && typeof column.label === \"string\"\n            ? column.label\n            : DEFAULT_COLUMN_NAME,\n        alias: column.alias,\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        accessor: (row: any) => row[column.alias],\n        width: columnWidthMap[column.id] || DEFAULT_COLUMN_WIDTH,\n        minWidth: COLUMN_MIN_WIDTH,\n        draggable: true,\n        isHidden: false,\n        isAscOrder: column.isAscOrder,\n        isDerived: column.isDerived,\n        sticky: column.sticky,\n        metaProperties: {\n          isHidden: isHidden,\n          type: column.columnType,\n          format: column.outputFormat || \"\",\n          inputFormat: column.inputFormat || \"\",\n          decimals: column.decimals || 0,\n        },\n        columnProperties: column,\n        Cell: renderCell,\n      };\n\n      const isAllCellVisible: boolean | boolean[] = column.isCellVisible;\n\n      /*\n       * If all cells are not visible or column itself is not visible,\n       * set isHidden and push it to hiddenColumns array else columns array\n       */\n      if (\n        (isBoolean(isAllCellVisible) && !isAllCellVisible) ||\n        (isArray(isAllCellVisible) &&\n          isAllCellVisible.every((visibility) => visibility === false)) ||\n        isHidden\n      ) {\n        columnData.isHidden = true;\n        hiddenColumns.push(columnData);\n      } else {\n        totalColumnWidth += columnData.width;\n        columns.push(columnData);\n      }\n    });\n  }\n\n  const lastColumnIndex = columns.length - 1;\n\n  if (totalColumnWidth < componentWidth) {\n    /*\n      This \"if\" block is responsible for upsizing the last column width\n      if there is space left in the table container towards the right\n    */\n    if (columns[lastColumnIndex]) {\n      const lastColumnWidth =\n        columns[lastColumnIndex].width || DEFAULT_COLUMN_WIDTH;\n      const remainingWidth = componentWidth - totalColumnWidth;\n\n      // Adding the remaining width i.e. space left towards the right, to the last column width\n      columns[lastColumnIndex].width = lastColumnWidth + remainingWidth;\n    }\n  } else if (totalColumnWidth > componentWidth) {\n    /*\n      This \"else-if\" block is responsible for downsizing the last column width\n      if the last column spills over resulting in horizontal scroll\n    */\n    const extraWidth = totalColumnWidth - componentWidth;\n\n    if (columns[lastColumnIndex]) {\n      const lastColWidth =\n        columns[lastColumnIndex].width || DEFAULT_COLUMN_WIDTH;\n\n      /*\n      Below if condition explanation:\n      Condition 1: (lastColWidth > COLUMN_MIN_WIDTH)\n        We will downsize the last column only if its greater than COLUMN_MIN_WIDTH\n      Condition 2: (extraWidth < lastColWidth)\n        This condition checks whether the last column is the only column that is spilling over.\n        If more than one columns are spilling over we won't downsize the last column\n    */\n      if (lastColWidth > COLUMN_MIN_WIDTH && extraWidth < lastColWidth) {\n        const availableWidthForLastColumn = lastColWidth - extraWidth;\n\n        /*\n        Below we are making sure last column width doesn't go lower than COLUMN_MIN_WIDTH again\n        as availableWidthForLastColumn might go lower than COLUMN_MIN_WIDTH in some cases\n      */\n        columns[lastColumnIndex].width =\n          availableWidthForLastColumn < COLUMN_MIN_WIDTH\n            ? COLUMN_MIN_WIDTH\n            : availableWidthForLastColumn;\n      }\n    }\n  }\n\n  /*\n   * In canvas render mode, hidden columns are rendered at the end of the table, so users can\n   * edit the hidden columns without having to make them visible first.\n   */\n  if (\n    hiddenColumns.length &&\n    renderMode === RenderModes.CANVAS &&\n    !isPreviewMode\n  ) {\n    // Get the index of the first column that is frozen to right\n    const rightFrozenColumnIdx = findIndex(\n      columns,\n      (col) => col.sticky === StickyType.RIGHT,\n    );\n\n    if (rightFrozenColumnIdx !== -1) {\n      columns.splice(rightFrozenColumnIdx, 0, ...hiddenColumns);\n    } else {\n      columns = columns.concat(hiddenColumns);\n    }\n  }\n\n  return columns.filter((column: ReactTableColumnProps) => !!column.id);\n};\n\n// the result of this cache function is a prop for the useTable hook, this prop needs to memoised as per their docs\n// we have noticed expensive computation from the useTable if columns isnt memoised\nexport const getMemoiseGetColumnsWithLocalStorageFn = () => {\n  const memoisedGetColumns = memoizeOne(getColumnsPureFn);\n\n  return memoizeOne(\n    //we are not using this parameter it is used by the memoisation comparator\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    (widgetLocalStorageState) => {\n      memoisedGetColumns.clear();\n\n      return memoisedGetColumns as getColumns;\n    },\n    isEqual,\n  );\n};",
            "cost": 0.06183000000000001
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/widgets/TableWidgetV2/widget/utilities.ts": {
            "output": "import { Colors } from \"constants/Colors\";\nimport { FontStyleTypes } from \"constants/WidgetConstants\";\nimport _, { filter, isBoolean, isObject, uniq, without } from \"lodash\";\nimport tinycolor from \"tinycolor2\";\nimport type {\n  CellLayoutProperties,\n  ColumnProperties,\n  ReactTableColumnProps,\n  TableColumnProps,\n  TableStyles,\n} from \"../component/Constants\";\nimport {\n  CellAlignmentTypes,\n  StickyType,\n  VerticalAlignmentTypes,\n} from \"../component/Constants\";\nimport {\n  ColumnTypes,\n  DEFAULT_BUTTON_COLOR,\n  DEFAULT_COLUMN_WIDTH,\n  TABLE_COLUMN_ORDER_KEY,\n} from \"../constants\";\nimport { SelectColumnOptionsValidations } from \"./propertyUtils\";\nimport type { TableWidgetProps } from \"../constants\";\nimport { get } from \"lodash\";\nimport { getNextEntityName } from \"utils/AppsmithUtils\";\nimport {\n  combineDynamicBindings,\n  getDynamicBindings,\n} from \"utils/DynamicBindingUtils\";\nimport { ButtonVariantTypes } from \"components/constants\";\nimport { dateFormatOptions } from \"WidgetProvider/constants\";\nimport moment from \"moment\";\nimport type { Stylesheet } from \"entities/AppTheming\";\nimport { getKeysFromSourceDataForEventAutocomplete } from \"widgets/MenuButtonWidget/widget/helper\";\nimport log from \"loglevel\";\nimport type React from \"react\";\n\ntype TableData = Array<Record<string, unknown>>;\n\n/*\n * When the table data changes we need to find the new index of the\n * selectedRow by using the primary key\n */\nexport const getOriginalRowIndex = (\n  prevTableData: TableData,\n  tableData: TableData,\n  selectedRowIndex: number | undefined,\n  primaryColumnId: string,\n): number => {\n  let primaryKey = \"\";\n  let index = -1;\n\n  if (prevTableData && prevTableData.length == 0) {\n    return selectedRowIndex ?? index;\n  }\n\n  if (\n    !_.isNil(selectedRowIndex) &&\n    prevTableData &&\n    prevTableData[selectedRowIndex]\n  ) {\n    primaryKey = prevTableData[selectedRowIndex][primaryColumnId] as string;\n  }\n\n  if (!!primaryKey && tableData) {\n    index = tableData.findIndex((row) => row[primaryColumnId] === primaryKey);\n  }\n\n  return index;\n};\n\nexport const getSelectRowIndex = (\n  prevTableData: TableData,\n  tableData: TableData,\n  defaultSelectedRowIndex: string | number | number[] | undefined,\n  selectedRowIndex: number | undefined,\n  primaryColumnId: string | undefined,\n) => {\n  let index = _.isNumber(defaultSelectedRowIndex)\n    ? defaultSelectedRowIndex\n    : -1;\n\n  if (\n    selectedRowIndex !== -1 &&\n    !_.isNil(selectedRowIndex) &&\n    primaryColumnId\n  ) {\n    index = getOriginalRowIndex(\n      prevTableData,\n      tableData,\n      selectedRowIndex,\n      primaryColumnId,\n    );\n  }\n\n  return index;\n};\n\nexport const getSelectRowIndices = (\n  prevTableData: TableData,\n  tableData: TableData,\n  defaultSelectedRowIndices: string | number | number[] | undefined,\n  selectedRowIndices: number[] | undefined,\n  primaryColumnId: string | undefined,\n) => {\n  let indices: number[];\n\n  if (primaryColumnId && _.isArray(selectedRowIndices)) {\n    indices = selectedRowIndices;\n  } else if (_.isArray(defaultSelectedRowIndices)) {\n    indices = defaultSelectedRowIndices;\n  } else {\n    indices = [];\n  }\n\n  if (primaryColumnId) {\n    return indices\n      .map((index: number) =>\n        getOriginalRowIndex(prevTableData, tableData, index, primaryColumnId),\n      )\n      .filter((index) => index !== -1);\n  } else {\n    return indices;\n  }\n};\n\n//TODO(Balaji): we shouldn't replace special characters\nexport const removeSpecialChars = (value: string, limit?: number) => {\n  const separatorRegex = /\\W+/;\n\n  return value\n    .split(separatorRegex)\n    .join(\"_\")\n    .slice(0, limit || 30);\n};\n\n/*\n * Function to get list of columns from the tabledata\n */\nexport const getAllTableColumnKeys = (\n  tableData?: Array<Record<string, unknown>>,\n) => {\n  const columnKeys: Set<string> = new Set();\n\n  if (_.isArray(tableData)) {\n    tableData.forEach((row) => {\n      Object.keys(row).forEach((key) => {\n        columnKeys.add(key);\n      });\n    });\n  }\n\n  return Array.from(columnKeys);\n};\n\nexport function getTableStyles(props: TableStyles) {\n  return {\n    textColor: props.textColor,\n    textSize: props.textSize,\n    fontStyle: props.fontStyle,\n    cellBackground: props.cellBackground,\n    verticalAlignment: props.verticalAlignment,\n    horizontalAlignment: props.horizontalAlignment,\n  };\n}\n\nexport function escapeString(str: string) {\n  /*\n   * Match all the unescaped `\"`\n   *  match `\"` that follows any character except `\\`. ([^\\\\]\\\")\n   */\n  return str.replace(/[^\\\\]\"/g, (match) => {\n    return match.substr(0, match.length - 1) + `\\\"`;\n  });\n}\n\nexport function getDefaultColumnProperties(\n  id: string,\n  sanitizedId: string,\n  index: number,\n  widgetName: string,\n  isDerived?: boolean,\n  columnType?: string,\n): ColumnProperties {\n  const columnProps = {\n    allowCellWrapping: false,\n    allowSameOptionsInNewRow: true,\n    index: index,\n    width: DEFAULT_COLUMN_WIDTH,\n    originalId: id,\n    id: sanitizedId,\n    alias: id,\n    horizontalAlignment: CellAlignmentTypes.LEFT,\n    verticalAlignment: VerticalAlignmentTypes.CENTER,\n    columnType: columnType || ColumnTypes.TEXT,\n    textColor: Colors.THUNDER,\n    textSize: \"0.875rem\",\n    fontStyle: FontStyleTypes.REGULAR,\n    enableFilter: true,\n    enableSort: true,\n    isVisible: true,\n    isDisabled: false,\n    isCellEditable: false,\n    isEditable: false,\n    isCellVisible: true,\n    isDerived: !!isDerived,\n    label: id,\n    isSaveVisible: true,\n    isDiscardVisible: true,\n    computedValue: isDerived\n      ? \"\"\n      : `{{(() => { const tableData = ${widgetName}.processedTableData || []; return tableData.length > 0 ? tableData.map((currentRow, currentIndex) => (currentRow[\"${escapeString(\n          id,\n        )}\"])) : ${escapeString(id)} })()}}`,\n    sticky: StickyType.NONE,\n    validation: {},\n    currencyCode: \"USD\",\n    decimals: 0,\n    thousandSeparator: true,\n    notation: \"standard\" as Intl.NumberFormatOptions[\"notation\"],\n  };\n\n  return columnProps;\n}\n\n/*\n * Function to extract derived columns from the primary columns\n */\nexport function getDerivedColumns(\n  primaryColumns: Record<string, ColumnProperties>,\n): Record<string, ColumnProperties> {\n  const derivedColumns: Record<string, ColumnProperties> = {};\n\n  if (primaryColumns) {\n    Object.keys(primaryColumns).forEach((columnId) => {\n      if (primaryColumns[columnId] && primaryColumns[columnId].isDerived) {\n        derivedColumns[columnId] = primaryColumns[columnId];\n      }\n    });\n  }\n\n  return derivedColumns;\n}\n\nexport const getPropertyValue = (\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  index: number,\n  preserveCase = false,\n  isSourceData = false,\n) => {\n  if (value && isObject(value) && !Array.isArray(value)) {\n    return value;\n  }\n\n  if (value && Array.isArray(value) && value[index]) {\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const getValueForSourceData = (value: any, index: number) => {\n      return Array.isArray(value[index]) ? value[index] : value;\n    };\n\n    return isSourceData\n      ? getValueForSourceData(value, index)\n      : preserveCase\n        ? value[index].toString()\n        : value[index].toString().toUpperCase();\n  } else if (value) {\n    return preserveCase ? value.toString() : value.toString().toUpperCase();\n  } else {\n    return value;\n  }\n};\nexport const getBooleanPropertyValue = (value: unknown, index: number) => {\n  if (isBoolean(value)) {\n    return value;\n  }\n\n  if (Array.isArray(value) && isBoolean(value[index])) {\n    return value[index];\n  }\n\n  return !!value;\n};\n\nexport const getArrayPropertyValue = (value: unknown, index: number) => {\n  if (Array.isArray(value) && value.length > 0) {\n    if (Array.isArray(value[0])) {\n      // value is array of arrays of label value\n      return value[index];\n    } else {\n      // value is array of label value\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\n\nexport const getCellProperties = (\n  columnProperties: ColumnProperties,\n  rowIndex: number,\n  isAddRowInProgress = false,\n) => {\n  if (columnProperties) {\n    return {\n      horizontalAlignment: getPropertyValue(\n        columnProperties.horizontalAlignment,\n        rowIndex,\n      ),\n      verticalAlignment: getPropertyValue(\n        columnProperties.verticalAlignment,\n        rowIndex,\n      ),\n      cellBackground: getPropertyValue(\n        columnProperties.cellBackground,\n        rowIndex,\n      ),\n      buttonColor: getPropertyValue(columnProperties.buttonColor, rowIndex),\n      buttonLabel: getPropertyValue(\n        columnProperties.buttonLabel,\n        rowIndex,\n        true,\n      ),\n      menuButtonLabel: getPropertyValue(\n        columnProperties.menuButtonLabel,\n        rowIndex,\n        true,\n      ),\n      iconName: getPropertyValue(columnProperties.iconName, rowIndex, true),\n      menuButtoniconName: getPropertyValue(\n        columnProperties.menuButtoniconName,\n        rowIndex,\n        true,\n      ),\n      menuItemsSource: getPropertyValue(\n        columnProperties.menuItemsSource,\n        rowIndex,\n        true,\n      ),\n      sourceData: getPropertyValue(\n        columnProperties.sourceData,\n        rowIndex,\n        false,\n        true,\n      ),\n      configureMenuItems: columnProperties.configureMenuItems,\n      buttonVariant: getPropertyValue(\n        columnProperties.buttonVariant,\n        rowIndex,\n        true,\n      ),\n      borderRadius: getPropertyValue(\n        columnProperties.borderRadius,\n        rowIndex,\n        true,\n      ),\n      boxShadow: getPropertyValue(columnProperties.boxShadow, rowIndex, true),\n      iconButtonStyle: getPropertyValue(\n        columnProperties.iconButtonStyle,\n        rowIndex,\n        true,\n      ),\n      textSize: getPropertyValue(columnProperties.textSize, rowIndex),\n      textColor: getPropertyValue(columnProperties.textColor, rowIndex),\n      fontStyle: getPropertyValue(columnProperties.fontStyle, rowIndex), //Fix this\n      isVisible: getBooleanPropertyValue(columnProperties.isVisible, rowIndex),\n      isDisabled: getBooleanPropertyValue(\n        columnProperties.isDisabled,\n        rowIndex,\n      ),\n      isCellVisible: getBooleanPropertyValue(\n        columnProperties.isCellVisible,\n        rowIndex,\n      ),\n      displayText: getPropertyValue(\n        columnProperties.displayText,\n        rowIndex,\n        true,\n      ),\n      iconAlign: getPropertyValue(columnProperties.iconAlign, rowIndex, true),\n      isCompact: getPropertyValue(columnProperties.isCompact, rowIndex),\n      menuColor: getPropertyValue(columnProperties.menuColor, rowIndex, true),\n      menuItems: getPropertyValue(columnProperties.menuItems, rowIndex),\n      menuVariant: getPropertyValue(\n        columnProperties.menuVariant,\n        rowIndex,\n        true,\n      ),\n      isCellEditable: getBooleanPropertyValue(\n        columnProperties.isCellEditable,\n        rowIndex,\n      ),\n      allowCellWrapping: getBooleanPropertyValue(\n        columnProperties.allowCellWrapping,\n        rowIndex,\n      ),\n      // EditActions related properties\n      saveButtonVariant: getPropertyValue(\n        columnProperties.saveButtonVariant,\n        rowIndex,\n        true,\n      ),\n      saveButtonColor: getPropertyValue(\n        columnProperties.saveButtonColor,\n        rowIndex,\n        true,\n      ),\n      saveIconAlign: getPropertyValue(\n        columnProperties.saveIconAlign,\n        rowIndex,\n        true,\n      ),\n      saveBorderRadius: getPropertyValue(\n        columnProperties.saveBorderRadius,\n        rowIndex,\n        true,\n      ),\n      saveActionLabel: getPropertyValue(\n        columnProperties.saveActionLabel,\n        rowIndex,\n        true,\n      ),\n      saveActionIconName: getPropertyValue(\n        columnProperties.saveActionIconName,\n        rowIndex,\n        true,\n      ),\n      isSaveVisible: getBooleanPropertyValue(\n        columnProperties.isSaveVisible,\n        rowIndex,\n      ),\n      isSaveDisabled: getBooleanPropertyValue(\n        columnProperties.isSaveDisabled,\n        rowIndex,\n      ),\n      discardButtonVariant: getPropertyValue(\n        columnProperties.discardButtonVariant,\n        rowIndex,\n        true,\n      ),\n      discardButtonColor: getPropertyValue(\n        columnProperties.discardButtonColor,\n        rowIndex,\n        true,\n      ),\n      discardIconAlign: getPropertyValue(\n        columnProperties.discardIconAlign,\n        rowIndex,\n        true,\n      ),\n      discardBorderRadius: getPropertyValue(\n        columnProperties.discardBorderRadius,\n        rowIndex,\n        true,\n      ),\n      discardActionLabel: getPropertyValue(\n        columnProperties.discardActionLabel,\n        rowIndex,\n        true,\n      ),\n      discardActionIconName: getPropertyValue(\n        columnProperties.discardActionIconName,\n        rowIndex,\n        true,\n      ),\n      isDiscardVisible: getBooleanPropertyValue(\n        columnProperties.isDiscardVisible,\n        rowIndex,\n      ),\n      isDiscardDisabled: getBooleanPropertyValue(\n        columnProperties.isDiscardDisabled,\n        rowIndex,\n      ),\n      imageSize: getPropertyValue(columnProperties.imageSize, rowIndex, true),\n      isFilterable: getBooleanPropertyValue(\n        columnProperties.isFilterable,\n        rowIndex,\n      ),\n      serverSideFiltering: getBooleanPropertyValue(\n        columnProperties.serverSideFiltering,\n        rowIndex,\n      ),\n      placeholderText: getPropertyValue(\n        columnProperties.placeholderText,\n        rowIndex,\n        true,\n      ),\n      resetFilterTextOnClose: getPropertyValue(\n        columnProperties.resetFilterTextOnClose,\n        rowIndex,\n      ),\n      inputFormat: getPropertyValue(\n        columnProperties.inputFormat,\n        rowIndex,\n        true,\n      ),\n      outputFormat: getPropertyValue(\n        columnProperties.outputFormat,\n        rowIndex,\n        true,\n      ),\n      shortcuts: getBooleanPropertyValue(columnProperties.shortcuts, rowIndex),\n      selectOptions: getSelectOptions(\n        isAddRowInProgress,\n        rowIndex,\n        columnProperties,\n      ),\n      timePrecision: getPropertyValue(\n        columnProperties.timePrecision,\n        rowIndex,",
            "output_extracted": "import { Colors } from \"constants/Colors\";\nimport { FontStyleTypes } from \"constants/WidgetConstants\";\nimport _, { filter, isBoolean, isObject, uniq, without } from \"lodash\";\nimport tinycolor from \"tinycolor2\";\nimport type {\n  CellLayoutProperties,\n  ColumnProperties,\n  ReactTableColumnProps,\n  TableColumnProps,\n  TableStyles,\n} from \"../component/Constants\";\nimport {\n  CellAlignmentTypes,\n  StickyType,\n  VerticalAlignmentTypes,\n} from \"../component/Constants\";\nimport {\n  ColumnTypes,\n  DEFAULT_BUTTON_COLOR,\n  DEFAULT_COLUMN_WIDTH,\n  TABLE_COLUMN_ORDER_KEY,\n} from \"../constants\";\nimport { SelectColumnOptionsValidations } from \"./propertyUtils\";\nimport type { TableWidgetProps } from \"../constants\";\nimport { get } from \"lodash\";\nimport { getNextEntityName } from \"utils/AppsmithUtils\";\nimport {\n  combineDynamicBindings,\n  getDynamicBindings,\n} from \"utils/DynamicBindingUtils\";\nimport { ButtonVariantTypes } from \"components/constants\";\nimport { dateFormatOptions } from \"WidgetProvider/constants\";\nimport moment from \"moment\";\nimport type { Stylesheet } from \"entities/AppTheming\";\nimport { getKeysFromSourceDataForEventAutocomplete } from \"widgets/MenuButtonWidget/widget/helper\";\nimport log from \"loglevel\";\nimport type React from \"react\";\n\ntype TableData = Array<Record<string, unknown>>;\n\n/*\n * When the table data changes we need to find the new index of the\n * selectedRow by using the primary key\n */\nexport const getOriginalRowIndex = (\n  prevTableData: TableData,\n  tableData: TableData,\n  selectedRowIndex: number | undefined,\n  primaryColumnId: string,\n): number => {\n  let primaryKey = \"\";\n  let index = -1;\n\n  if (prevTableData && prevTableData.length == 0) {\n    return selectedRowIndex ?? index;\n  }\n\n  if (\n    !_.isNil(selectedRowIndex) &&\n    prevTableData &&\n    prevTableData[selectedRowIndex]\n  ) {\n    primaryKey = prevTableData[selectedRowIndex][primaryColumnId] as string;\n  }\n\n  if (!!primaryKey && tableData) {\n    index = tableData.findIndex((row) => row[primaryColumnId] === primaryKey);\n  }\n\n  return index;\n};\n\nexport const getSelectRowIndex = (\n  prevTableData: TableData,\n  tableData: TableData,\n  defaultSelectedRowIndex: string | number | number[] | undefined,\n  selectedRowIndex: number | undefined,\n  primaryColumnId: string | undefined,\n) => {\n  let index = _.isNumber(defaultSelectedRowIndex)\n    ? defaultSelectedRowIndex\n    : -1;\n\n  if (\n    selectedRowIndex !== -1 &&\n    !_.isNil(selectedRowIndex) &&\n    primaryColumnId\n  ) {\n    index = getOriginalRowIndex(\n      prevTableData,\n      tableData,\n      selectedRowIndex,\n      primaryColumnId,\n    );\n  }\n\n  return index;\n};\n\nexport const getSelectRowIndices = (\n  prevTableData: TableData,\n  tableData: TableData,\n  defaultSelectedRowIndices: string | number | number[] | undefined,\n  selectedRowIndices: number[] | undefined,\n  primaryColumnId: string | undefined,\n) => {\n  let indices: number[];\n\n  if (primaryColumnId && _.isArray(selectedRowIndices)) {\n    indices = selectedRowIndices;\n  } else if (_.isArray(defaultSelectedRowIndices)) {\n    indices = defaultSelectedRowIndices;\n  } else {\n    indices = [];\n  }\n\n  if (primaryColumnId) {\n    return indices\n      .map((index: number) =>\n        getOriginalRowIndex(prevTableData, tableData, index, primaryColumnId),\n      )\n      .filter((index) => index !== -1);\n  } else {\n    return indices;\n  }\n};\n\n//TODO(Balaji): we shouldn't replace special characters\nexport const removeSpecialChars = (value: string, limit?: number) => {\n  const separatorRegex = /\\W+/;\n\n  return value\n    .split(separatorRegex)\n    .join(\"_\")\n    .slice(0, limit || 30);\n};\n\n/*\n * Function to get list of columns from the tabledata\n */\nexport const getAllTableColumnKeys = (\n  tableData?: Array<Record<string, unknown>>,\n) => {\n  const columnKeys: Set<string> = new Set();\n\n  if (_.isArray(tableData)) {\n    tableData.forEach((row) => {\n      Object.keys(row).forEach((key) => {\n        columnKeys.add(key);\n      });\n    });\n  }\n\n  return Array.from(columnKeys);\n};\n\nexport function getTableStyles(props: TableStyles) {\n  return {\n    textColor: props.textColor,\n    textSize: props.textSize,\n    fontStyle: props.fontStyle,\n    cellBackground: props.cellBackground,\n    verticalAlignment: props.verticalAlignment,\n    horizontalAlignment: props.horizontalAlignment,\n  };\n}\n\nexport function escapeString(str: string) {\n  /*\n   * Match all the unescaped `\"`\n   *  match `\"` that follows any character except `\\`. ([^\\\\]\\\")\n   */\n  return str.replace(/[^\\\\]\"/g, (match) => {\n    return match.substr(0, match.length - 1) + `\\\"`;\n  });\n}\n\nexport function getDefaultColumnProperties(\n  id: string,\n  sanitizedId: string,\n  index: number,\n  widgetName: string,\n  isDerived?: boolean,\n  columnType?: string,\n): ColumnProperties {\n  const columnProps = {\n    allowCellWrapping: false,\n    allowSameOptionsInNewRow: true,\n    index: index,\n    width: DEFAULT_COLUMN_WIDTH,\n    originalId: id,\n    id: sanitizedId,\n    alias: id,\n    horizontalAlignment: CellAlignmentTypes.LEFT,\n    verticalAlignment: VerticalAlignmentTypes.CENTER,\n    columnType: columnType || ColumnTypes.TEXT,\n    textColor: Colors.THUNDER,\n    textSize: \"0.875rem\",\n    fontStyle: FontStyleTypes.REGULAR,\n    enableFilter: true,\n    enableSort: true,\n    isVisible: true,\n    isDisabled: false,\n    isCellEditable: false,\n    isEditable: false,\n    isCellVisible: true,\n    isDerived: !!isDerived,\n    label: id,\n    isSaveVisible: true,\n    isDiscardVisible: true,\n    computedValue: isDerived\n      ? \"\"\n      : `{{(() => { const tableData = ${widgetName}.processedTableData || []; return tableData.length > 0 ? tableData.map((currentRow, currentIndex) => (currentRow[\"${escapeString(\n          id,\n        )}\"])) : ${escapeString(id)} })()}}`,\n    sticky: StickyType.NONE,\n    validation: {},\n    currencyCode: \"USD\",\n    decimals: 0,\n    thousandSeparator: true,\n    notation: \"standard\" as Intl.NumberFormatOptions[\"notation\"],\n  };\n\n  return columnProps;\n}\n\n/*\n * Function to extract derived columns from the primary columns\n */\nexport function getDerivedColumns(\n  primaryColumns: Record<string, ColumnProperties>,\n): Record<string, ColumnProperties> {\n  const derivedColumns: Record<string, ColumnProperties> = {};\n\n  if (primaryColumns) {\n    Object.keys(primaryColumns).forEach((columnId) => {\n      if (primaryColumns[columnId] && primaryColumns[columnId].isDerived) {\n        derivedColumns[columnId] = primaryColumns[columnId];\n      }\n    });\n  }\n\n  return derivedColumns;\n}\n\nexport const getPropertyValue = (\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  index: number,\n  preserveCase = false,\n  isSourceData = false,\n) => {\n  if (value && isObject(value) && !Array.isArray(value)) {\n    return value;\n  }\n\n  if (value && Array.isArray(value) && value[index]) {\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const getValueForSourceData = (value: any, index: number) => {\n      return Array.isArray(value[index]) ? value[index] : value;\n    };\n\n    return isSourceData\n      ? getValueForSourceData(value, index)\n      : preserveCase\n        ? value[index].toString()\n        : value[index].toString().toUpperCase();\n  } else if (value) {\n    return preserveCase ? value.toString() : value.toString().toUpperCase();\n  } else {\n    return value;\n  }\n};\nexport const getBooleanPropertyValue = (value: unknown, index: number) => {\n  if (isBoolean(value)) {\n    return value;\n  }\n\n  if (Array.isArray(value) && isBoolean(value[index])) {\n    return value[index];\n  }\n\n  return !!value;\n};\n\nexport const getArrayPropertyValue = (value: unknown, index: number) => {\n  if (Array.isArray(value) && value.length > 0) {\n    if (Array.isArray(value[0])) {\n      // value is array of arrays of label value\n      return value[index];\n    } else {\n      // value is array of label value\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\n\nexport const getCellProperties = (\n  columnProperties: ColumnProperties,\n  rowIndex: number,\n  isAddRowInProgress = false,\n) => {\n  if (columnProperties) {\n    return {\n      horizontalAlignment: getPropertyValue(\n        columnProperties.horizontalAlignment,\n        rowIndex,\n      ),\n      verticalAlignment: getPropertyValue(\n        columnProperties.verticalAlignment,\n        rowIndex,\n      ),\n      cellBackground: getPropertyValue(\n        columnProperties.cellBackground,\n        rowIndex,\n      ),\n      buttonColor: getPropertyValue(columnProperties.buttonColor, rowIndex),\n      buttonLabel: getPropertyValue(\n        columnProperties.buttonLabel,\n        rowIndex,\n        true,\n      ),\n      menuButtonLabel: getPropertyValue(\n        columnProperties.menuButtonLabel,\n        rowIndex,\n        true,\n      ),\n      iconName: getPropertyValue(columnProperties.iconName, rowIndex, true),\n      menuButtoniconName: getPropertyValue(\n        columnProperties.menuButtoniconName,\n        rowIndex,\n        true,\n      ),\n      menuItemsSource: getPropertyValue(\n        columnProperties.menuItemsSource,\n        rowIndex,\n        true,\n      ),\n      sourceData: getPropertyValue(\n        columnProperties.sourceData,\n        rowIndex,\n        false,\n        true,\n      ),\n      configureMenuItems: columnProperties.configureMenuItems,\n      buttonVariant: getPropertyValue(\n        columnProperties.buttonVariant,\n        rowIndex,\n        true,\n      ),\n      borderRadius: getPropertyValue(\n        columnProperties.borderRadius,\n        rowIndex,\n        true,\n      ),\n      boxShadow: getPropertyValue(columnProperties.boxShadow, rowIndex, true),\n      iconButtonStyle: getPropertyValue(\n        columnProperties.iconButtonStyle,\n        rowIndex,\n        true,\n      ),\n      textSize: getPropertyValue(columnProperties.textSize, rowIndex),\n      textColor: getPropertyValue(columnProperties.textColor, rowIndex),\n      fontStyle: getPropertyValue(columnProperties.fontStyle, rowIndex), //Fix this\n      isVisible: getBooleanPropertyValue(columnProperties.isVisible, rowIndex),\n      isDisabled: getBooleanPropertyValue(\n        columnProperties.isDisabled,\n        rowIndex,\n      ),\n      isCellVisible: getBooleanPropertyValue(\n        columnProperties.isCellVisible,\n        rowIndex,\n      ),\n      displayText: getPropertyValue(\n        columnProperties.displayText,\n        rowIndex,\n        true,\n      ),\n      iconAlign: getPropertyValue(columnProperties.iconAlign, rowIndex, true),\n      isCompact: getPropertyValue(columnProperties.isCompact, rowIndex),\n      menuColor: getPropertyValue(columnProperties.menuColor, rowIndex, true),\n      menuItems: getPropertyValue(columnProperties.menuItems, rowIndex),\n      menuVariant: getPropertyValue(\n        columnProperties.menuVariant,\n        rowIndex,\n        true,\n      ),\n      isCellEditable: getBooleanPropertyValue(\n        columnProperties.isCellEditable,\n        rowIndex,\n      ),\n      allowCellWrapping: getBooleanPropertyValue(\n        columnProperties.allowCellWrapping,\n        rowIndex,\n      ),\n      // EditActions related properties\n      saveButtonVariant: getPropertyValue(\n        columnProperties.saveButtonVariant,\n        rowIndex,\n        true,\n      ),\n      saveButtonColor: getPropertyValue(\n        columnProperties.saveButtonColor,\n        rowIndex,\n        true,\n      ),\n      saveIconAlign: getPropertyValue(\n        columnProperties.saveIconAlign,\n        rowIndex,\n        true,\n      ),\n      saveBorderRadius: getPropertyValue(\n        columnProperties.saveBorderRadius,\n        rowIndex,\n        true,\n      ),\n      saveActionLabel: getPropertyValue(\n        columnProperties.saveActionLabel,\n        rowIndex,\n        true,\n      ),\n      saveActionIconName: getPropertyValue(\n        columnProperties.saveActionIconName,\n        rowIndex,\n        true,\n      ),\n      isSaveVisible: getBooleanPropertyValue(\n        columnProperties.isSaveVisible,\n        rowIndex,\n      ),\n      isSaveDisabled: getBooleanPropertyValue(\n        columnProperties.isSaveDisabled,\n        rowIndex,\n      ),\n      discardButtonVariant: getPropertyValue(\n        columnProperties.discardButtonVariant,\n        rowIndex,\n        true,\n      ),\n      discardButtonColor: getPropertyValue(\n        columnProperties.discardButtonColor,\n        rowIndex,\n        true,\n      ),\n      discardIconAlign: getPropertyValue(\n        columnProperties.discardIconAlign,\n        rowIndex,\n        true,\n      ),\n      discardBorderRadius: getPropertyValue(\n        columnProperties.discardBorderRadius,\n        rowIndex,\n        true,\n      ),\n      discardActionLabel: getPropertyValue(\n        columnProperties.discardActionLabel,\n        rowIndex,\n        true,\n      ),\n      discardActionIconName: getPropertyValue(\n        columnProperties.discardActionIconName,\n        rowIndex,\n        true,\n      ),\n      isDiscardVisible: getBooleanPropertyValue(\n        columnProperties.isDiscardVisible,\n        rowIndex,\n      ),\n      isDiscardDisabled: getBooleanPropertyValue(\n        columnProperties.isDiscardDisabled,\n        rowIndex,\n      ),\n      imageSize: getPropertyValue(columnProperties.imageSize, rowIndex, true),\n      isFilterable: getBooleanPropertyValue(\n        columnProperties.isFilterable,\n        rowIndex,\n      ),\n      serverSideFiltering: getBooleanPropertyValue(\n        columnProperties.serverSideFiltering,\n        rowIndex,\n      ),\n      placeholderText: getPropertyValue(\n        columnProperties.placeholderText,\n        rowIndex,\n        true,\n      ),\n      resetFilterTextOnClose: getPropertyValue(\n        columnProperties.resetFilterTextOnClose,\n        rowIndex,\n      ),\n      inputFormat: getPropertyValue(\n        columnProperties.inputFormat,\n        rowIndex,\n        true,\n      ),\n      outputFormat: getPropertyValue(\n        columnProperties.outputFormat,\n        rowIndex,\n        true,\n      ),\n      shortcuts: getBooleanPropertyValue(columnProperties.shortcuts, rowIndex),\n      selectOptions: getSelectOptions(\n        isAddRowInProgress,\n        rowIndex,\n        columnProperties,\n      ),\n      timePrecision: getPropertyValue(\n        columnProperties.timePrecision,\n        rowIndex,",
            "cost": 0.15603
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "appsmithorg__appsmith.main.41217",
        "repo": "appsmithorg/appsmith",
        "base_commit": "49dfbd233930187670f70430b5fdefe7351020db",
        "head_commit": "4d0ff9c41d97c55a94a3d261b962faef492f453a",
        "title": "fix: updates the logic to not interfere with DSL when infinitescroll is enabled",
        "merged_at": "2025-09-25T10:31:59Z",
        "html_url": "https://github.com/appsmithorg/appsmith/pull/41217",
        "test_files": [
            "app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts"
        ],
        "code_files": [
            "app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx",
            "app/client/src/widgets/TableWidgetV2/widget/index.tsx",
            "app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts",
            "app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts",
            "app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts",
            "app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx",
            "app/client/src/widgets/TableWidgetV2/widget/utilities.ts"
        ],
        "total_changes": 171,
        "num_files": 8,
        "pull_number": 41217,
        "patch": "diff --git a/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx b/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx\nindex 9bc73b67ea4..b938f722a96 100644\n--- a/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx\n+++ b/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx\n@@ -200,7 +200,10 @@ const HeaderCellComponent = (props: HeaderProps) => {\n   const isColumnEditable =\n     props.column.columnProperties.isCellEditable &&\n     props.column.columnProperties.isEditable &&\n-    isColumnTypeEditable(props.column.columnProperties.columnType);\n+    isColumnTypeEditable(\n+      props.column.columnProperties.columnType,\n+      isInfiniteScrollEnabled,\n+    );\n \n   const toggleColumnFreeze = (value: StickyType) => {\n     handleColumnFreeze &&\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts b/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts\nindex 2d3eb8985b8..160ab69d5f8 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts\n+++ b/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts\n@@ -10,7 +10,6 @@ import {\n   updateCustomColumnAliasOnLabelChange,\n   selectColumnOptionsValidation,\n   allowedFirstDayOfWeekRange,\n-  updateCellEditabilityOnInfiniteScrollChange,\n   updateSearchSortFilterOnInfiniteScrollChange,\n } from \"../propertyUtils\";\n import _ from \"lodash\";\n@@ -1151,96 +1150,4 @@ describe(\"Infinite Scroll Update Hooks - \", () => {\n       ),\n     ).toBeUndefined();\n   });\n-\n-  it(\"updateCellEditabilityOnInfiniteScrollChange - should disable cell editability when infinite scroll is enabled\", () => {\n-    // Setup mock primary columns\n-    const props = {\n-      primaryColumns: {\n-        column1: {\n-          id: \"column1\",\n-          alias: \"column1\",\n-          isEditable: true,\n-          isCellEditable: true,\n-        },\n-        column2: {\n-          id: \"column2\",\n-          alias: \"column2\",\n-          isEditable: true,\n-          isCellEditable: true,\n-        },\n-      },\n-    } as unknown as TableWidgetProps;\n-\n-    // When infinite scroll is enabled\n-    expect(\n-      updateCellEditabilityOnInfiniteScrollChange(\n-        props,\n-        \"infiniteScrollEnabled\",\n-        true,\n-      ),\n-    ).toEqual([\n-      {\n-        propertyPath: \"primaryColumns.column1.isCellEditable\",\n-        propertyValue: false,\n-      },\n-      {\n-        propertyPath: \"primaryColumns.column1.isEditable\",\n-        propertyValue: false,\n-      },\n-      {\n-        propertyPath: \"primaryColumns.column2.isCellEditable\",\n-        propertyValue: false,\n-      },\n-      {\n-        propertyPath: \"primaryColumns.column2.isEditable\",\n-        propertyValue: false,\n-      },\n-    ]);\n-\n-    // When infinite scroll is disabled\n-    expect(\n-      updateCellEditabilityOnInfiniteScrollChange(\n-        props,\n-        \"infiniteScrollEnabled\",\n-        false,\n-      ),\n-    ).toEqual([\n-      {\n-        propertyPath: \"primaryColumns.column1.isCellEditable\",\n-        propertyValue: true,\n-      },\n-      {\n-        propertyPath: \"primaryColumns.column1.isEditable\",\n-        propertyValue: true,\n-      },\n-      {\n-        propertyPath: \"primaryColumns.column2.isCellEditable\",\n-        propertyValue: true,\n-      },\n-      {\n-        propertyPath: \"primaryColumns.column2.isEditable\",\n-        propertyValue: true,\n-      },\n-    ]);\n-\n-    // Test with no primary columns\n-    const propsWithoutColumns = {} as TableWidgetProps;\n-\n-    expect(\n-      updateCellEditabilityOnInfiniteScrollChange(\n-        propsWithoutColumns,\n-        \"infiniteScrollEnabled\",\n-        true,\n-      ),\n-    ).toBeUndefined();\n-\n-    // When some other value is passed\n-    expect(\n-      updateCellEditabilityOnInfiniteScrollChange(\n-        props,\n-        \"infiniteScrollEnabled\",\n-        \"some-other-value\",\n-      ),\n-    ).toBeUndefined();\n-  });\n });\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/index.tsx b/app/client/src/widgets/TableWidgetV2/widget/index.tsx\nindex 78a21afa3f4..2e865783bec 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/index.tsx\n+++ b/app/client/src/widgets/TableWidgetV2/widget/index.tsx\n@@ -580,6 +580,7 @@ class TableWidgetV2 extends BaseWidget<TableWidgetProps, WidgetState> {\n   getTableColumns = () => {\n     const {\n       columnWidthMap,\n+      infiniteScrollEnabled,\n       isPreviewMode,\n       orderedTableColumns,\n       renderMode,\n@@ -597,6 +598,7 @@ class TableWidgetV2 extends BaseWidget<TableWidgetProps, WidgetState> {\n       componentWidth,\n       renderMode,\n       isPreviewMode,\n+      infiniteScrollEnabled,\n     );\n   };\n \n@@ -2067,7 +2069,8 @@ class TableWidgetV2 extends BaseWidget<TableWidgetProps, WidgetState> {\n     }\n \n     const isColumnEditable =\n-      column.isEditable && isColumnTypeEditable(column.columnType);\n+      column.isEditable &&\n+      isColumnTypeEditable(column.columnType, this.props.infiniteScrollEnabled);\n     const alias = props.cell.column.columnProperties.alias;\n \n     const isCellEditable = isColumnEditable && cellProperties.isCellEditable;\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts\nindex 82ccf971bc5..96210b4dd02 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts\n+++ b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts\n@@ -137,7 +137,10 @@ export default {\n         const columnType = get(props, `${baseProperty}.columnType`, \"\");\n         const isDerived = get(props, `${baseProperty}.isDerived`, false);\n \n-        return !isColumnTypeEditable(columnType) || isDerived;\n+        return (\n+          !isColumnTypeEditable(columnType, props.infiniteScrollEnabled) ||\n+          isDerived\n+        );\n       },\n     },\n     {\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts\nindex 02de96fffcc..48351f35538 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts\n+++ b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts\n@@ -22,7 +22,6 @@ import {\n   totalRecordsCountValidation,\n   uniqueColumnNameValidation,\n   updateAllowAddNewRowOnInfiniteScrollChange,\n-  updateCellEditabilityOnInfiniteScrollChange,\n   updateColumnOrderHook,\n   updateCustomColumnAliasOnLabelChange,\n   updateInlineEditingOptionDropdownVisibilityHook,\n@@ -197,7 +196,6 @@ export default [\n         isTriggerProperty: false,\n         updateHook: composePropertyUpdateHook([\n           updateAllowAddNewRowOnInfiniteScrollChange,\n-          updateCellEditabilityOnInfiniteScrollChange,\n           updateSearchSortFilterOnInfiniteScrollChange,\n         ]),\n         dependencies: [\"primaryColumns\", \"serverSidePaginationEnabled\"],\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts b/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts\nindex c92a573664f..bf6bb16960d 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts\n+++ b/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts\n@@ -1513,46 +1513,3 @@ export const updateSearchSortFilterOnInfiniteScrollChange = (\n \n   return;\n };\n-\n-// Disable cell editability when infinite scroll is enabled\n-export const updateCellEditabilityOnInfiniteScrollChange = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  propertyValue: unknown,\n-): Array<{ propertyPath: string; propertyValue: unknown }> | undefined => {\n-  if (!props.primaryColumns) return;\n-\n-  const updates: Array<{ propertyPath: string; propertyValue: unknown }> = [];\n-\n-  if (propertyValue === true) {\n-    Object.entries(props.primaryColumns).forEach(([, column]) => {\n-      const columnName = column.alias;\n-\n-      updates.push({\n-        propertyPath: `primaryColumns.${columnName}.isCellEditable`,\n-        propertyValue: false,\n-      });\n-\n-      updates.push({\n-        propertyPath: `primaryColumns.${columnName}.isEditable`,\n-        propertyValue: false,\n-      });\n-    });\n-  } else if (propertyValue === false) {\n-    Object.entries(props.primaryColumns).forEach(([, column]) => {\n-      const columnName = column.alias;\n-\n-      updates.push({\n-        propertyPath: `primaryColumns.${columnName}.isCellEditable`,\n-        propertyValue: true,\n-      });\n-\n-      updates.push({\n-        propertyPath: `primaryColumns.${columnName}.isEditable`,\n-        propertyValue: true,\n-      });\n-    });\n-  }\n-\n-  return updates.length > 0 ? updates : undefined;\n-};\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx b/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx\nindex 47e97e27666..769768d68d2 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx\n+++ b/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx\n@@ -4,6 +4,7 @@ import { RenderModes } from \"constants/WidgetConstants\";\n import { StickyType } from \"../../component/Constants\";\n import {\n   COLUMN_MIN_WIDTH,\n+  ColumnTypes,\n   DEFAULT_COLUMN_WIDTH,\n   DEFAULT_COLUMN_NAME,\n } from \"../../constants\";\n@@ -21,6 +22,7 @@ export type getColumns = (\n   componentWidth: number,\n   renderMode: RenderMode,\n   isPreviewMode: boolean,\n+  infiniteScrollEnabled?: boolean,\n ) => ReactTableColumnProps[];\n \n //TODO: (Vamsi) need to unit test this function\n@@ -32,6 +34,7 @@ export const getColumnsPureFn: getColumns = (\n   componentWidth,\n   renderMode,\n   isPreviewMode,\n+  infiniteScrollEnabled = false,\n ) => {\n   let columns: ReactTableColumnProps[] = [];\n   const hiddenColumns: ReactTableColumnProps[] = [];\n@@ -42,6 +45,14 @@ export const getColumnsPureFn: getColumns = (\n     // TODO: Fix this the next time the file is edited\n     // eslint-disable-next-line @typescript-eslint/no-explicit-any\n     orderedTableColumns.forEach((column: any) => {\n+      // Skip EDIT_ACTIONS columns when infinite scroll is enabled\n+      if (\n+        infiniteScrollEnabled &&\n+        column.columnType === ColumnTypes.EDIT_ACTIONS\n+      ) {\n+        return;\n+      }\n+\n       const isHidden = !column.isVisible;\n \n       const columnData = {\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/utilities.ts b/app/client/src/widgets/TableWidgetV2/widget/utilities.ts\nindex c1c17d8160c..5b2cd649cc5 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/utilities.ts\n+++ b/app/client/src/widgets/TableWidgetV2/widget/utilities.ts\n@@ -540,8 +540,11 @@ const EdtiableColumnTypes: string[] = [\n   ColumnTypes.CURRENCY,\n ];\n \n-export function isColumnTypeEditable(columnType: string) {\n-  return EdtiableColumnTypes.includes(columnType);\n+export function isColumnTypeEditable(\n+  columnType: string,\n+  isInfiniteScrollEnabled = false,\n+) {\n+  return EdtiableColumnTypes.includes(columnType) && !isInfiniteScrollEnabled;\n }\n \n /*\n",
        "pr_mirror": "appsmithorg__appsmith.7046aeb3"
    }
}