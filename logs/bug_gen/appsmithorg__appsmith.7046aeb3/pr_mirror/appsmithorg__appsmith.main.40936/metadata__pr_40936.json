{
    "cost": 0.355655,
    "rewrites": {
        "appsmithorg__appsmith.7046aeb3/app/client/src/ce/entities/FeatureFlag.ts": {
            "output": "// Please follow naming convention : https://www.notion.so/appsmith/Using-Feature-Flags-in-Appsmith-d362fe7acc7d4ef0aa12e1f5f9b83b5f?pvs=4#f6d4242e56284e84af25cadef71b7aeb to create feature flags.\nexport const FEATURE_FLAG = {\n  TEST_FLAG: \"TEST_FLAG\",\n  release_datasource_environments_enabled:\n    \"release_datasource_environments_enabled\",\n  release_appnavigationlogoupload_enabled:\n    \"release_appnavigationlogoupload_enabled\",\n  release_embed_hide_share_settings_enabled:\n    \"release_embed_hide_share_settings_enabled\",\n  release_table_serverside_filtering_enabled:\n    \"release_table_serverside_filtering_enabled\",\n  license_branding_enabled: \"license_branding_enabled\",\n  license_sso_saml_enabled: \"license_sso_saml_enabled\",\n  license_sso_oidc_enabled: \"license_sso_oidc_enabled\",\n  license_private_embeds_enabled: \"license_private_embeds_enabled\",\n  release_show_publish_app_to_community_enabled:\n    \"release_show_publish_app_to_community_enabled\",\n  license_gac_enabled: \"license_gac_enabled\",\n  release_anvil_enabled: \"release_anvil_enabled\",\n  license_ai_agent_enabled: \"license_ai_agent_enabled\",\n  license_git_branch_protection_enabled:\n    \"license_git_branch_protection_enabled\",\n  license_git_continuous_delivery_enabled:\n    \"license_git_continuous_delivery_enabled\",\n  license_widget_rtl_support_enabled: \"license_widget_rtl_support_enabled\",\n  ab_one_click_learning_popover_enabled:\n    \"ab_one_click_learning_popover_enabled\",\n  ab_appsmith_ai_query: \"ab_appsmith_ai_query\",\n  rollout_remove_feature_walkthrough_enabled:\n    \"rollout_remove_feature_walkthrough_enabled\",\n  rollout_eslint_enabled: \"rollout_eslint_enabled\",\n  release_drag_drop_building_blocks_enabled:\n    \"release_drag_drop_building_blocks_enabled\",\n  release_layout_conversion_enabled: \"release_layout_conversion_enabled\",\n  release_git_persist_branch_enabled: \"release_git_persist_branch_enabled\",\n  release_ide_animations_enabled: \"release_ide_animations_enabled\",\n  release_ide_datasource_selector_enabled:\n    \"release_ide_datasource_selector_enabled\",\n  release_custom_widget_ai_builder: \"release_custom_widget_ai_builder\",\n  release_evaluation_scope_cache: \"release_evaluation_scope_cache\",\n  release_gs_all_sheets_options_enabled:\n    \"release_gs_all_sheets_options_enabled\",\n  release_git_modularisation_enabled: \"release_git_modularisation_enabled\",\n  release_git_api_contracts_enabled: \"release_git_api_contracts_enabled\",\n  kill_session_recordings_enabled: \"kill_session_recordings_enabled\",\n  config_mask_session_recordings_enabled:\n    \"config_mask_session_recordings_enabled\",\n  config_user_session_recordings_enabled:\n    \"config_user_session_recordings_enabled\",\n  release_external_saas_plugins_enabled:\n    \"release_external_saas_plugins_enabled\",\n  release_table_infinitescroll_enabled: \"release_table_infinitescroll_enabled\",\n  license_multi_org_enabled: \"license_multi_org_enabled\",\n  release_table_custom_sort_function_enabled:\n    \"release_table_custom_sort_function_enabled\",\n  release_git_package_enabled: \"release_git_package_enabled\",\n  license_external_saas_plugins_enabled:\n    \"license_external_saas_plugins_enabled\",\n  release_computation_cache_enabled: \"release_computation_cache_enabled\",\n  release_ai_chat_integrations_enabled: \"release_ai_chat_integrations_enabled\",\n  release_reactive_actions_enabled: \"release_reactive_actions_enabled\",\n  license_ai_agent_instance_enabled: \"license_ai_agent_instance_enabled\",\n  release_jsobjects_onpageunloadactions_enabled:\n    \"release_jsobjects_onpageunloadactions_enabled\",\n  release_static_url_enabled: \"release_static_url_enabled\",\n  release_window_dimensions_enabled: \"release_window_dimensions_enabled\",\n} as const;\n\nexport type FeatureFlag = keyof typeof FEATURE_FLAG;\n\nexport type FeatureFlags = Record<FeatureFlag, boolean>;\n\nexport const DEFAULT_FEATURE_FLAG_VALUE: FeatureFlags = {\n  TEST_FLAG: true,\n  release_datasource_environments_enabled: false,\n  release_appnavigationlogoupload_enabled: false,\n  release_embed_hide_share_settings_enabled: false,\n  release_table_serverside_filtering_enabled: false,\n  license_branding_enabled: false,\n  license_sso_saml_enabled: false,\n  license_sso_oidc_enabled: false,\n  license_private_embeds_enabled: false,\n  release_show_publish_app_to_community_enabled: false,\n  license_gac_enabled: false,\n  release_anvil_enabled: false,\n  license_ai_agent_enabled: false,\n  release_drag_drop_building_blocks_enabled: false,\n  license_git_branch_protection_enabled: false,\n  license_git_continuous_delivery_enabled: false,\n  license_widget_rtl_support_enabled: false,\n  ab_one_click_learning_popover_enabled: false,\n  ab_appsmith_ai_query: false,\n  rollout_remove_feature_walkthrough_enabled: true,\n  rollout_eslint_enabled: false,\n  release_layout_conversion_enabled: false,\n  release_git_persist_branch_enabled: false,\n  release_ide_animations_enabled: false,\n  release_ide_datasource_selector_enabled: false,\n  release_custom_widget_ai_builder: false,\n  release_evaluation_scope_cache: false,\n  release_gs_all_sheets_options_enabled: false,\n  release_git_modularisation_enabled: false,\n  release_git_api_contracts_enabled: false,\n  kill_session_recordings_enabled: false,\n  config_user_session_recordings_enabled: true,\n  config_mask_session_recordings_enabled: true,\n  release_external_saas_plugins_enabled: false,\n  release_table_infinitescroll_enabled: false,\n  license_multi_org_enabled: false,\n  release_table_custom_sort_function_enabled: false,\n  release_git_package_enabled: false,\n  license_external_saas_plugins_enabled: false,\n  release_computation_cache_enabled: false,\n  release_ai_chat_integrations_enabled: false,\n  release_reactive_actions_enabled: false,\n  license_ai_agent_instance_enabled: false,\n  release_jsobjects_onpageunloadactions_enabled: false,\n  release_static_url_enabled: false,\n  release_window_dimensions_enabled: false,\n};\n\nexport const AB_TESTING_EVENT_KEYS = {\n  abTestingFlagLabel: \"abTestingFlagLabel\",\n  abTestingFlagValue: \"abTestingFlagValue\",\n};",
            "output_extracted": "// Please follow naming convention : https://www.notion.so/appsmith/Using-Feature-Flags-in-Appsmith-d362fe7acc7d4ef0aa12e1f5f9b83b5f?pvs=4#f6d4242e56284e84af25cadef71b7aeb to create feature flags.\nexport const FEATURE_FLAG = {\n  TEST_FLAG: \"TEST_FLAG\",\n  release_datasource_environments_enabled:\n    \"release_datasource_environments_enabled\",\n  release_appnavigationlogoupload_enabled:\n    \"release_appnavigationlogoupload_enabled\",\n  release_embed_hide_share_settings_enabled:\n    \"release_embed_hide_share_settings_enabled\",\n  release_table_serverside_filtering_enabled:\n    \"release_table_serverside_filtering_enabled\",\n  license_branding_enabled: \"license_branding_enabled\",\n  license_sso_saml_enabled: \"license_sso_saml_enabled\",\n  license_sso_oidc_enabled: \"license_sso_oidc_enabled\",\n  license_private_embeds_enabled: \"license_private_embeds_enabled\",\n  release_show_publish_app_to_community_enabled:\n    \"release_show_publish_app_to_community_enabled\",\n  license_gac_enabled: \"license_gac_enabled\",\n  release_anvil_enabled: \"release_anvil_enabled\",\n  license_ai_agent_enabled: \"license_ai_agent_enabled\",\n  license_git_branch_protection_enabled:\n    \"license_git_branch_protection_enabled\",\n  license_git_continuous_delivery_enabled:\n    \"license_git_continuous_delivery_enabled\",\n  license_widget_rtl_support_enabled: \"license_widget_rtl_support_enabled\",\n  ab_one_click_learning_popover_enabled:\n    \"ab_one_click_learning_popover_enabled\",\n  ab_appsmith_ai_query: \"ab_appsmith_ai_query\",\n  rollout_remove_feature_walkthrough_enabled:\n    \"rollout_remove_feature_walkthrough_enabled\",\n  rollout_eslint_enabled: \"rollout_eslint_enabled\",\n  release_drag_drop_building_blocks_enabled:\n    \"release_drag_drop_building_blocks_enabled\",\n  release_layout_conversion_enabled: \"release_layout_conversion_enabled\",\n  release_git_persist_branch_enabled: \"release_git_persist_branch_enabled\",\n  release_ide_animations_enabled: \"release_ide_animations_enabled\",\n  release_ide_datasource_selector_enabled:\n    \"release_ide_datasource_selector_enabled\",\n  release_custom_widget_ai_builder: \"release_custom_widget_ai_builder\",\n  release_evaluation_scope_cache: \"release_evaluation_scope_cache\",\n  release_gs_all_sheets_options_enabled:\n    \"release_gs_all_sheets_options_enabled\",\n  release_git_modularisation_enabled: \"release_git_modularisation_enabled\",\n  release_git_api_contracts_enabled: \"release_git_api_contracts_enabled\",\n  kill_session_recordings_enabled: \"kill_session_recordings_enabled\",\n  config_mask_session_recordings_enabled:\n    \"config_mask_session_recordings_enabled\",\n  config_user_session_recordings_enabled:\n    \"config_user_session_recordings_enabled\",\n  release_external_saas_plugins_enabled:\n    \"release_external_saas_plugins_enabled\",\n  release_table_infinitescroll_enabled: \"release_table_infinitescroll_enabled\",\n  license_multi_org_enabled: \"license_multi_org_enabled\",\n  release_table_custom_sort_function_enabled:\n    \"release_table_custom_sort_function_enabled\",\n  release_git_package_enabled: \"release_git_package_enabled\",\n  license_external_saas_plugins_enabled:\n    \"license_external_saas_plugins_enabled\",\n  release_computation_cache_enabled: \"release_computation_cache_enabled\",\n  release_ai_chat_integrations_enabled: \"release_ai_chat_integrations_enabled\",\n  release_reactive_actions_enabled: \"release_reactive_actions_enabled\",\n  license_ai_agent_instance_enabled: \"license_ai_agent_instance_enabled\",\n  release_jsobjects_onpageunloadactions_enabled:\n    \"release_jsobjects_onpageunloadactions_enabled\",\n  release_static_url_enabled: \"release_static_url_enabled\",\n  release_window_dimensions_enabled: \"release_window_dimensions_enabled\",\n} as const;\n\nexport type FeatureFlag = keyof typeof FEATURE_FLAG;\n\nexport type FeatureFlags = Record<FeatureFlag, boolean>;\n\nexport const DEFAULT_FEATURE_FLAG_VALUE: FeatureFlags = {\n  TEST_FLAG: true,\n  release_datasource_environments_enabled: false,\n  release_appnavigationlogoupload_enabled: false,\n  release_embed_hide_share_settings_enabled: false,\n  release_table_serverside_filtering_enabled: false,\n  license_branding_enabled: false,\n  license_sso_saml_enabled: false,\n  license_sso_oidc_enabled: false,\n  license_private_embeds_enabled: false,\n  release_show_publish_app_to_community_enabled: false,\n  license_gac_enabled: false,\n  release_anvil_enabled: false,\n  license_ai_agent_enabled: false,\n  release_drag_drop_building_blocks_enabled: false,\n  license_git_branch_protection_enabled: false,\n  license_git_continuous_delivery_enabled: false,\n  license_widget_rtl_support_enabled: false,\n  ab_one_click_learning_popover_enabled: false,\n  ab_appsmith_ai_query: false,\n  rollout_remove_feature_walkthrough_enabled: true,\n  rollout_eslint_enabled: false,\n  release_layout_conversion_enabled: false,\n  release_git_persist_branch_enabled: false,\n  release_ide_animations_enabled: false,\n  release_ide_datasource_selector_enabled: false,\n  release_custom_widget_ai_builder: false,\n  release_evaluation_scope_cache: false,\n  release_gs_all_sheets_options_enabled: false,\n  release_git_modularisation_enabled: false,\n  release_git_api_contracts_enabled: false,\n  kill_session_recordings_enabled: false,\n  config_user_session_recordings_enabled: true,\n  config_mask_session_recordings_enabled: true,\n  release_external_saas_plugins_enabled: false,\n  release_table_infinitescroll_enabled: false,\n  license_multi_org_enabled: false,\n  release_table_custom_sort_function_enabled: false,\n  release_git_package_enabled: false,\n  license_external_saas_plugins_enabled: false,\n  release_computation_cache_enabled: false,\n  release_ai_chat_integrations_enabled: false,\n  release_reactive_actions_enabled: false,\n  license_ai_agent_instance_enabled: false,\n  release_jsobjects_onpageunloadactions_enabled: false,\n  release_static_url_enabled: false,\n  release_window_dimensions_enabled: false,\n};\n\nexport const AB_TESTING_EVENT_KEYS = {\n  abTestingFlagLabel: \"abTestingFlagLabel\",\n  abTestingFlagValue: \"abTestingFlagValue\",\n};",
            "cost": 0.06297000000000001
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/ce/sagas/userSagas.tsx": {
            "output": "import {\n  all,\n  call,\n  fork,\n  put,\n  select,\n  take,\n  type TakeEffect,\n} from \"redux-saga/effects\";\nimport type {\n  ReduxAction,\n  ReduxActionWithPromise,\n} from \"actions/ReduxActionTypes\";\nimport {\n  ReduxActionTypes,\n  ReduxActionErrorTypes,\n} from \"ee/constants/ReduxActionConstants\";\nimport { reset } from \"redux-form\";\nimport type {\n  ForgotPasswordRequest,\n  VerifyTokenRequest,\n  TokenPasswordUpdateRequest,\n  UpdateUserRequest,\n  LeaveWorkspaceRequest,\n} from \"ee/api/UserApi\";\nimport UserApi from \"ee/api/UserApi\";\nimport { AUTH_LOGIN_URL, SETUP } from \"constants/routes\";\nimport history from \"utils/history\";\nimport type { ApiResponse } from \"api/ApiResponses\";\nimport type { ErrorActionPayload } from \"sagas/ErrorSagas\";\nimport {\n  validateResponse,\n  getResponseErrorMessage,\n  callAPI,\n} from \"sagas/ErrorSagas\";\nimport {\n  logoutUserSuccess,\n  logoutUserError,\n  verifyInviteSuccess,\n  verifyInviteError,\n  invitedUserSignupError,\n  invitedUserSignupSuccess,\n  fetchFeatureFlagsSuccess,\n  fetchFeatureFlagsError,\n  fetchProductAlertSuccess,\n  fetchProductAlertFailure,\n  fetchFeatureFlagsInit,\n} from \"actions/userActions\";\nimport AnalyticsUtil from \"ee/utils/AnalyticsUtil\";\nimport { INVITE_USERS_TO_WORKSPACE_FORM } from \"ee/constants/forms\";\nimport type { User } from \"constants/userConstants\";\nimport {\n  flushErrorsAndRedirect,\n  safeCrashAppRequest,\n} from \"actions/errorActions\";\nimport localStorage from \"utils/localStorage\";\nimport log from \"loglevel\";\n\nimport {\n  getCurrentUser,\n  getFeatureFlagsFetched,\n} from \"selectors/usersSelectors\";\nimport {\n  getEnableStartSignposting,\n  getFirstTimeUserOnboardingApplicationIds,\n  getFirstTimeUserOnboardingIntroModalVisibility,\n} from \"utils/storage\";\nimport { getAppsmithConfigs } from \"ee/configs\";\nimport type { FeatureFlags } from \"ee/entities/FeatureFlag\";\nimport { DEFAULT_FEATURE_FLAG_VALUE } from \"ee/entities/FeatureFlag\";\nimport UsagePulse from \"usagePulse\";\nimport { toast } from \"@appsmith/ads\";\nimport { isAirgapped } from \"ee/utils/airgapHelpers\";\nimport {\n  USER_PROFILE_PICTURE_UPLOAD_FAILED,\n  UPDATE_USER_DETAILS_FAILED,\n} from \"ee/constants/messages\";\nimport { createMessage } from \"@appsmith/ads-old\";\nimport type {\n  ProductAlert,\n  ProductAlertConfig,\n} from \"reducers/uiReducers/usersReducer\";\nimport { selectFeatureFlags } from \"ee/selectors/featureFlagsSelectors\";\nimport { getFromServerWhenNoPrefetchedResult } from \"sagas/helper\";\nimport type { SessionRecordingConfig } from \"utils/Analytics/mixpanel\";\nimport {\n  segmentInitSuccess,\n  segmentInitUncertain,\n} from \"actions/analyticsActions\";\nimport { getSegmentState } from \"selectors/analyticsSelectors\";\n\nexport function* getCurrentUserSaga(action?: {\n  payload?: { userProfile?: ApiResponse };\n}) {\n  const userProfile = action?.payload?.userProfile;\n\n  try {\n    const response: ApiResponse = yield call(\n      getFromServerWhenNoPrefetchedResult,\n      userProfile,\n      () => call(UserApi.getCurrentUser),\n    );\n\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (isValidResponse) {\n      yield put({\n        type: ReduxActionTypes.FETCH_USER_DETAILS_SUCCESS,\n        payload: response.data,\n      });\n    }\n  } catch (error) {\n    yield put({\n      type: ReduxActionErrorTypes.FETCH_USER_DETAILS_ERROR,\n      payload: {\n        error,\n      },\n    });\n\n    yield put(safeCrashAppRequest());\n  }\n}\n\nfunction* getSessionRecordingConfig() {\n  const featureFlags: FeatureFlags = yield select(selectFeatureFlags);\n\n  // This is a organization level flag to kill session recordings\n  // If this is true, we do not do any session recordings\n  if (featureFlags.kill_session_recordings_enabled) {\n    return {\n      enabled: false,\n      mask: false,\n    };\n  }\n\n  // This is a user level flag to control session recordings for a user\n  // If this is false, we do not do any session recordings\n  if (!featureFlags.config_user_session_recordings_enabled) {\n    return {\n      enabled: false,\n      mask: false,\n    };\n  }\n\n  // Now we know that both organization and user level flags are not blocking session recordings\n  return {\n    enabled: true,\n    // Check if we need to mask the session recordings from feature flags\n    mask: featureFlags.config_mask_session_recordings_enabled,\n  };\n}\n\nfunction* initTrackers(currentUser: User) {\n  try {\n    const isFFFetched: boolean = yield select(getFeatureFlagsFetched);\n\n    if (!isFFFetched) {\n      yield take(ReduxActionTypes.FETCH_FEATURE_FLAGS_SUCCESS);\n    }\n\n    const sessionRecordingConfig: SessionRecordingConfig = yield call(\n      getSessionRecordingConfig,\n    );\n\n    yield call(AnalyticsUtil.initialize, currentUser, sessionRecordingConfig);\n    yield put(segmentInitSuccess());\n  } catch (e) {\n    log.error(e);\n    yield put(segmentInitUncertain());\n  }\n}\n\nfunction* waitForInitialization() {\n  const currentUser: User = yield select(getCurrentUser);\n  // Dependents for starting tracking\n  const isFFFetched: boolean = yield select(getFeatureFlagsFetched);\n  const isSegmentInitialized: string | undefined =\n    yield select(getSegmentState);\n\n  const waits: TakeEffect[] = [];\n\n  // FF is required to know if GAC is enabled for the user\n  if (!isFFFetched) {\n    yield fork(fetchFeatureFlagsInit);\n    waits.push(take(ReduxActionTypes.FETCH_FEATURE_FLAGS_SUCCESS));\n  }\n\n  // If the user is anonymous, we need to wait for the editor or viewer to initialize\n  if (currentUser?.isAnonymous) {\n    waits.push(\n      take([\n        ReduxActionTypes.INITIALIZE_EDITOR_SUCCESS,\n        ReduxActionTypes.INITIALIZE_PAGE_VIEWER_SUCCESS,\n      ]),\n    );\n\n    // If the user is anonymous, we need to wait for the segment to initialize\n    // As it will provide the anonymous id\n    if (isSegmentInitialized === undefined) {\n      waits.push(\n        take([\n          ReduxActionTypes.SEGMENT_INITIALIZED,\n          ReduxActionTypes.SEGMENT_INIT_UNCERTAIN,\n        ]),\n      );\n    }\n  }\n\n  // Only wait for actions that are still pending\n  yield all(waits);\n}\n\nfunction* restartUserTracking() {\n  const currentUser: User = yield select(getCurrentUser);\n  const { enableTelemetry } = currentUser;\n  const isAirgappedInstance = isAirgapped();\n\n  if (!isAirgappedInstance) {\n    // We need to stop and start tracking activity to ensure that the tracking\n    // from previous session is not carried forward\n    yield call(UsagePulse.stopTrackingActivity);\n\n    // Wait for any items that are required for tracking\n    yield call(waitForInitialization);\n\n    const featureFlags: FeatureFlags = yield select(selectFeatureFlags);\n\n    const isGACEnabled = featureFlags?.license_gac_enabled;\n\n    const isFreeLicense = !isGACEnabled;\n\n    yield call(\n      UsagePulse.startTrackingActivity,\n      enableTelemetry && getAppsmithConfigs().segment.enabled,\n      currentUser?.isAnonymous ?? false,\n      isFreeLicense,\n    );\n  }\n}\n\nexport function* runUserSideEffectsSaga() {\n  const currentUser: User = yield select(getCurrentUser);\n  const { enableTelemetry } = currentUser;\n\n  yield fork(restartUserTracking);\n\n  if (enableTelemetry) {\n    yield fork(initTrackers, currentUser);\n  } else {\n    yield call(AnalyticsUtil.avoidTracking);\n    yield put(segmentInitSuccess());\n  }\n\n  if (currentUser.emptyInstance) {\n    history.replace(SETUP);\n  }\n}\n\nexport function* forgotPasswordSaga(\n  action: ReduxActionWithPromise<ForgotPasswordRequest>,\n) {\n  const { email, reject, resolve } = action.payload;\n\n  try {\n    const request: ForgotPasswordRequest = { email };\n    const response: ApiResponse = yield callAPI(\n      UserApi.forgotPassword,\n      request,\n    );\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (!isValidResponse) {\n      const errorMessage: string | undefined =\n        yield getResponseErrorMessage(response);\n\n      yield call(reject, { _error: errorMessage });\n    } else {\n      yield put({\n        type: ReduxActionTypes.FORGOT_PASSWORD_SUCCESS,\n      });\n      yield call(resolve);\n    }\n  } catch (error) {\n    log.error(error);\n    yield call(reject, { _error: (error as Error).message });\n    yield put({\n      type: ReduxActionErrorTypes.FORGOT_PASSWORD_ERROR,\n    });\n  }\n}\n\nexport function* resetPasswordSaga(\n  action: ReduxActionWithPromise<TokenPasswordUpdateRequest>,\n) {\n  const { email, password, reject, resolve, token } = action.payload;\n\n  try {\n    const request: TokenPasswordUpdateRequest = {\n      email,\n      password,\n      token,\n    };\n    const response: ApiResponse = yield callAPI(UserApi.resetPassword, request);\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (!isValidResponse) {\n      const errorMessage: string | undefined =\n        yield getResponseErrorMessage(response);\n\n      yield call(reject, { _error: errorMessage });\n    } else {\n      yield put({\n        type: ReduxActionTypes.RESET_USER_PASSWORD_SUCCESS,\n      });\n      yield call(resolve);\n    }\n  } catch (error) {\n    log.error(error);\n    yield call(reject, { _error: (error as Error).message });\n    yield put({\n      type: ReduxActionErrorTypes.RESET_USER_PASSWORD_ERROR,\n      payload: {\n        error: (error as Error).message,\n      },\n    });\n  }\n}\n\nexport function* invitedUserSignupSaga(\n  action: ReduxActionWithPromise<TokenPasswordUpdateRequest>,\n) {\n  const { email, password, reject, resolve, token } = action.payload;\n\n  try {\n    const request: TokenPasswordUpdateRequest = { email, password, token };\n    const response: ApiResponse = yield callAPI(\n      UserApi.confirmInvitedUserSignup,\n      request,\n    );\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (!isValidResponse) {\n      const errorMessage: string | undefined =\n        yield getResponseErrorMessage(response);\n\n      yield call(reject, { _error: errorMessage });\n    } else {\n      yield put(invitedUserSignupSuccess());\n      yield call(resolve);\n    }\n  } catch (error) {\n    log.error(error);\n    yield call(reject, { _error: (error as Error).message });\n    yield put(invitedUserSignupError(error));\n  }\n}\n\ninterface InviteUserPayload {\n  email: string;\n  permissionGroupId: string;\n}\n\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function* inviteUser(payload: InviteUserPayload, reject: any) {\n  const response: ApiResponse = yield callAPI(UserApi.inviteUser, payload);\n  const isValidResponse: boolean = yield validateResponse(response);\n\n  if (!isValidResponse) {\n    let errorMessage = `${payload.email}:  `;\n\n    errorMessage += getResponseErrorMessage(response);\n    yield call(reject, { _error: errorMessage });\n  }\n\n  yield;\n}\n\nexport function* inviteUsers(\n  action: ReduxActionWithPromise<{\n    data: {\n      usernames: string[];\n      workspaceId: string;\n      permissionGroupId: string;\n      recaptchaToken?: string;\n    };\n  }>,\n) {\n  const { data, reject, resolve } = action.payload;\n\n  try {\n    const response: ApiResponse<{ id: string; username: string }[]> =\n      yield callAPI(UserApi.inviteUser, {\n        usernames: data.usernames,\n        permissionGroupId: data.permissionGroupId,\n        recaptchaToken: data.recaptchaToken,\n      });\n    const isValidResponse: boolean = yield validateResponse(response, false);\n\n    if (!isValidResponse) {\n      let errorMessage = `${data.usernames}:  `;\n\n      errorMessage += getResponseErrorMessage(response);\n      yield call(reject, { _error: errorMessage });\n    }\n\n    yield put({\n      type: ReduxActionTypes.FETCH_ALL_USERS_INIT,\n      payload: {\n        workspaceId: data.workspaceId,\n      },\n    });\n    const { data: responseData } = response;\n\n    yield put({\n      type: ReduxActionTypes.INVITED_USERS_TO_WORKSPACE,\n      payload: {\n        workspaceId: data.workspaceId,\n        users: responseData.map((user: { id: string; username: string }) => ({\n          userId: user.id,\n          username: user.username,\n          permissionGroupId: data.permissionGroupId,\n        })),\n      },\n    });\n    yield call(resolve);\n    yield put(reset(INVITE_USERS_TO_WORKSPACE_FORM));\n  } catch (error) {\n    yield call(reject, { _error: (error as Error).message });\n  }\n}\n\nexport function* updateUserDetailsSaga(action: ReduxAction<UpdateUserRequest>) {\n  try {\n    const { email, intercomConsentGiven, name, proficiency, useCase } =\n      action.payload;\n\n    const response: ApiResponse = yield callAPI(UserApi.updateUser, {\n      email,\n      name,\n      proficiency,\n      useCase,\n      intercomConsentGiven,\n    });\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (isValidResponse) {\n      yield put({\n        type: ReduxActionTypes.UPDATE_USER_DETAILS_SUCCESS,\n        payload: response.data,\n      });\n    }\n  } catch (error) {\n    const payload: ErrorActionPayload = {\n      show: true,\n      error: {\n        message:\n          (error as Error).message ?? createMessage(UPDATE_USER_DETAILS_FAILED),\n      },\n    };\n\n    yield put({\n      type: ReduxActionErrorTypes.UPDATE_USER_DETAILS_ERROR,\n      payload,\n    });\n  }\n}\n\nexport function* verifyResetPasswordTokenSaga(\n  action: ReduxAction<VerifyTokenRequest>,\n) {\n  try {\n    const request: VerifyTokenRequest = action.payload;\n    const response: ApiResponse = yield call(\n      UserApi.verifyResetPasswordToken,\n      request,\n    );\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (isValidResponse && response.data) {\n      yield put({\n        type: ReduxActionTypes.RESET_PASSWORD_VERIFY_TOKEN_SUCCESS,\n      });\n    } else {\n      yield put({\n        type: ReduxActionErrorTypes.RESET_PASSWORD_VERIFY_TOKEN_ERROR,",
            "output_extracted": "import {\n  all,\n  call,\n  fork,\n  put,\n  select,\n  take,\n  type TakeEffect,\n} from \"redux-saga/effects\";\nimport type {\n  ReduxAction,\n  ReduxActionWithPromise,\n} from \"actions/ReduxActionTypes\";\nimport {\n  ReduxActionTypes,\n  ReduxActionErrorTypes,\n} from \"ee/constants/ReduxActionConstants\";\nimport { reset } from \"redux-form\";\nimport type {\n  ForgotPasswordRequest,\n  VerifyTokenRequest,\n  TokenPasswordUpdateRequest,\n  UpdateUserRequest,\n  LeaveWorkspaceRequest,\n} from \"ee/api/UserApi\";\nimport UserApi from \"ee/api/UserApi\";\nimport { AUTH_LOGIN_URL, SETUP } from \"constants/routes\";\nimport history from \"utils/history\";\nimport type { ApiResponse } from \"api/ApiResponses\";\nimport type { ErrorActionPayload } from \"sagas/ErrorSagas\";\nimport {\n  validateResponse,\n  getResponseErrorMessage,\n  callAPI,\n} from \"sagas/ErrorSagas\";\nimport {\n  logoutUserSuccess,\n  logoutUserError,\n  verifyInviteSuccess,\n  verifyInviteError,\n  invitedUserSignupError,\n  invitedUserSignupSuccess,\n  fetchFeatureFlagsSuccess,\n  fetchFeatureFlagsError,\n  fetchProductAlertSuccess,\n  fetchProductAlertFailure,\n  fetchFeatureFlagsInit,\n} from \"actions/userActions\";\nimport AnalyticsUtil from \"ee/utils/AnalyticsUtil\";\nimport { INVITE_USERS_TO_WORKSPACE_FORM } from \"ee/constants/forms\";\nimport type { User } from \"constants/userConstants\";\nimport {\n  flushErrorsAndRedirect,\n  safeCrashAppRequest,\n} from \"actions/errorActions\";\nimport localStorage from \"utils/localStorage\";\nimport log from \"loglevel\";\n\nimport {\n  getCurrentUser,\n  getFeatureFlagsFetched,\n} from \"selectors/usersSelectors\";\nimport {\n  getEnableStartSignposting,\n  getFirstTimeUserOnboardingApplicationIds,\n  getFirstTimeUserOnboardingIntroModalVisibility,\n} from \"utils/storage\";\nimport { getAppsmithConfigs } from \"ee/configs\";\nimport type { FeatureFlags } from \"ee/entities/FeatureFlag\";\nimport { DEFAULT_FEATURE_FLAG_VALUE } from \"ee/entities/FeatureFlag\";\nimport UsagePulse from \"usagePulse\";\nimport { toast } from \"@appsmith/ads\";\nimport { isAirgapped } from \"ee/utils/airgapHelpers\";\nimport {\n  USER_PROFILE_PICTURE_UPLOAD_FAILED,\n  UPDATE_USER_DETAILS_FAILED,\n} from \"ee/constants/messages\";\nimport { createMessage } from \"@appsmith/ads-old\";\nimport type {\n  ProductAlert,\n  ProductAlertConfig,\n} from \"reducers/uiReducers/usersReducer\";\nimport { selectFeatureFlags } from \"ee/selectors/featureFlagsSelectors\";\nimport { getFromServerWhenNoPrefetchedResult } from \"sagas/helper\";\nimport type { SessionRecordingConfig } from \"utils/Analytics/mixpanel\";\nimport {\n  segmentInitSuccess,\n  segmentInitUncertain,\n} from \"actions/analyticsActions\";\nimport { getSegmentState } from \"selectors/analyticsSelectors\";\n\nexport function* getCurrentUserSaga(action?: {\n  payload?: { userProfile?: ApiResponse };\n}) {\n  const userProfile = action?.payload?.userProfile;\n\n  try {\n    const response: ApiResponse = yield call(\n      getFromServerWhenNoPrefetchedResult,\n      userProfile,\n      () => call(UserApi.getCurrentUser),\n    );\n\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (isValidResponse) {\n      yield put({\n        type: ReduxActionTypes.FETCH_USER_DETAILS_SUCCESS,\n        payload: response.data,\n      });\n    }\n  } catch (error) {\n    yield put({\n      type: ReduxActionErrorTypes.FETCH_USER_DETAILS_ERROR,\n      payload: {\n        error,\n      },\n    });\n\n    yield put(safeCrashAppRequest());\n  }\n}\n\nfunction* getSessionRecordingConfig() {\n  const featureFlags: FeatureFlags = yield select(selectFeatureFlags);\n\n  // This is a organization level flag to kill session recordings\n  // If this is true, we do not do any session recordings\n  if (featureFlags.kill_session_recordings_enabled) {\n    return {\n      enabled: false,\n      mask: false,\n    };\n  }\n\n  // This is a user level flag to control session recordings for a user\n  // If this is false, we do not do any session recordings\n  if (!featureFlags.config_user_session_recordings_enabled) {\n    return {\n      enabled: false,\n      mask: false,\n    };\n  }\n\n  // Now we know that both organization and user level flags are not blocking session recordings\n  return {\n    enabled: true,\n    // Check if we need to mask the session recordings from feature flags\n    mask: featureFlags.config_mask_session_recordings_enabled,\n  };\n}\n\nfunction* initTrackers(currentUser: User) {\n  try {\n    const isFFFetched: boolean = yield select(getFeatureFlagsFetched);\n\n    if (!isFFFetched) {\n      yield take(ReduxActionTypes.FETCH_FEATURE_FLAGS_SUCCESS);\n    }\n\n    const sessionRecordingConfig: SessionRecordingConfig = yield call(\n      getSessionRecordingConfig,\n    );\n\n    yield call(AnalyticsUtil.initialize, currentUser, sessionRecordingConfig);\n    yield put(segmentInitSuccess());\n  } catch (e) {\n    log.error(e);\n    yield put(segmentInitUncertain());\n  }\n}\n\nfunction* waitForInitialization() {\n  const currentUser: User = yield select(getCurrentUser);\n  // Dependents for starting tracking\n  const isFFFetched: boolean = yield select(getFeatureFlagsFetched);\n  const isSegmentInitialized: string | undefined =\n    yield select(getSegmentState);\n\n  const waits: TakeEffect[] = [];\n\n  // FF is required to know if GAC is enabled for the user\n  if (!isFFFetched) {\n    yield fork(fetchFeatureFlagsInit);\n    waits.push(take(ReduxActionTypes.FETCH_FEATURE_FLAGS_SUCCESS));\n  }\n\n  // If the user is anonymous, we need to wait for the editor or viewer to initialize\n  if (currentUser?.isAnonymous) {\n    waits.push(\n      take([\n        ReduxActionTypes.INITIALIZE_EDITOR_SUCCESS,\n        ReduxActionTypes.INITIALIZE_PAGE_VIEWER_SUCCESS,\n      ]),\n    );\n\n    // If the user is anonymous, we need to wait for the segment to initialize\n    // As it will provide the anonymous id\n    if (isSegmentInitialized === undefined) {\n      waits.push(\n        take([\n          ReduxActionTypes.SEGMENT_INITIALIZED,\n          ReduxActionTypes.SEGMENT_INIT_UNCERTAIN,\n        ]),\n      );\n    }\n  }\n\n  // Only wait for actions that are still pending\n  yield all(waits);\n}\n\nfunction* restartUserTracking() {\n  const currentUser: User = yield select(getCurrentUser);\n  const { enableTelemetry } = currentUser;\n  const isAirgappedInstance = isAirgapped();\n\n  if (!isAirgappedInstance) {\n    // We need to stop and start tracking activity to ensure that the tracking\n    // from previous session is not carried forward\n    yield call(UsagePulse.stopTrackingActivity);\n\n    // Wait for any items that are required for tracking\n    yield call(waitForInitialization);\n\n    const featureFlags: FeatureFlags = yield select(selectFeatureFlags);\n\n    const isGACEnabled = featureFlags?.license_gac_enabled;\n\n    const isFreeLicense = !isGACEnabled;\n\n    yield call(\n      UsagePulse.startTrackingActivity,\n      enableTelemetry && getAppsmithConfigs().segment.enabled,\n      currentUser?.isAnonymous ?? false,\n      isFreeLicense,\n    );\n  }\n}\n\nexport function* runUserSideEffectsSaga() {\n  const currentUser: User = yield select(getCurrentUser);\n  const { enableTelemetry } = currentUser;\n\n  yield fork(restartUserTracking);\n\n  if (enableTelemetry) {\n    yield fork(initTrackers, currentUser);\n  } else {\n    yield call(AnalyticsUtil.avoidTracking);\n    yield put(segmentInitSuccess());\n  }\n\n  if (currentUser.emptyInstance) {\n    history.replace(SETUP);\n  }\n}\n\nexport function* forgotPasswordSaga(\n  action: ReduxActionWithPromise<ForgotPasswordRequest>,\n) {\n  const { email, reject, resolve } = action.payload;\n\n  try {\n    const request: ForgotPasswordRequest = { email };\n    const response: ApiResponse = yield callAPI(\n      UserApi.forgotPassword,\n      request,\n    );\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (!isValidResponse) {\n      const errorMessage: string | undefined =\n        yield getResponseErrorMessage(response);\n\n      yield call(reject, { _error: errorMessage });\n    } else {\n      yield put({\n        type: ReduxActionTypes.FORGOT_PASSWORD_SUCCESS,\n      });\n      yield call(resolve);\n    }\n  } catch (error) {\n    log.error(error);\n    yield call(reject, { _error: (error as Error).message });\n    yield put({\n      type: ReduxActionErrorTypes.FORGOT_PASSWORD_ERROR,\n    });\n  }\n}\n\nexport function* resetPasswordSaga(\n  action: ReduxActionWithPromise<TokenPasswordUpdateRequest>,\n) {\n  const { email, password, reject, resolve, token } = action.payload;\n\n  try {\n    const request: TokenPasswordUpdateRequest = {\n      email,\n      password,\n      token,\n    };\n    const response: ApiResponse = yield callAPI(UserApi.resetPassword, request);\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (!isValidResponse) {\n      const errorMessage: string | undefined =\n        yield getResponseErrorMessage(response);\n\n      yield call(reject, { _error: errorMessage });\n    } else {\n      yield put({\n        type: ReduxActionTypes.RESET_USER_PASSWORD_SUCCESS,\n      });\n      yield call(resolve);\n    }\n  } catch (error) {\n    log.error(error);\n    yield call(reject, { _error: (error as Error).message });\n    yield put({\n      type: ReduxActionErrorTypes.RESET_USER_PASSWORD_ERROR,\n      payload: {\n        error: (error as Error).message,\n      },\n    });\n  }\n}\n\nexport function* invitedUserSignupSaga(\n  action: ReduxActionWithPromise<TokenPasswordUpdateRequest>,\n) {\n  const { email, password, reject, resolve, token } = action.payload;\n\n  try {\n    const request: TokenPasswordUpdateRequest = { email, password, token };\n    const response: ApiResponse = yield callAPI(\n      UserApi.confirmInvitedUserSignup,\n      request,\n    );\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (!isValidResponse) {\n      const errorMessage: string | undefined =\n        yield getResponseErrorMessage(response);\n\n      yield call(reject, { _error: errorMessage });\n    } else {\n      yield put(invitedUserSignupSuccess());\n      yield call(resolve);\n    }\n  } catch (error) {\n    log.error(error);\n    yield call(reject, { _error: (error as Error).message });\n    yield put(invitedUserSignupError(error));\n  }\n}\n\ninterface InviteUserPayload {\n  email: string;\n  permissionGroupId: string;\n}\n\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function* inviteUser(payload: InviteUserPayload, reject: any) {\n  const response: ApiResponse = yield callAPI(UserApi.inviteUser, payload);\n  const isValidResponse: boolean = yield validateResponse(response);\n\n  if (!isValidResponse) {\n    let errorMessage = `${payload.email}:  `;\n\n    errorMessage += getResponseErrorMessage(response);\n    yield call(reject, { _error: errorMessage });\n  }\n\n  yield;\n}\n\nexport function* inviteUsers(\n  action: ReduxActionWithPromise<{\n    data: {\n      usernames: string[];\n      workspaceId: string;\n      permissionGroupId: string;\n      recaptchaToken?: string;\n    };\n  }>,\n) {\n  const { data, reject, resolve } = action.payload;\n\n  try {\n    const response: ApiResponse<{ id: string; username: string }[]> =\n      yield callAPI(UserApi.inviteUser, {\n        usernames: data.usernames,\n        permissionGroupId: data.permissionGroupId,\n        recaptchaToken: data.recaptchaToken,\n      });\n    const isValidResponse: boolean = yield validateResponse(response, false);\n\n    if (!isValidResponse) {\n      let errorMessage = `${data.usernames}:  `;\n\n      errorMessage += getResponseErrorMessage(response);\n      yield call(reject, { _error: errorMessage });\n    }\n\n    yield put({\n      type: ReduxActionTypes.FETCH_ALL_USERS_INIT,\n      payload: {\n        workspaceId: data.workspaceId,\n      },\n    });\n    const { data: responseData } = response;\n\n    yield put({\n      type: ReduxActionTypes.INVITED_USERS_TO_WORKSPACE,\n      payload: {\n        workspaceId: data.workspaceId,\n        users: responseData.map((user: { id: string; username: string }) => ({\n          userId: user.id,\n          username: user.username,\n          permissionGroupId: data.permissionGroupId,\n        })),\n      },\n    });\n    yield call(resolve);\n    yield put(reset(INVITE_USERS_TO_WORKSPACE_FORM));\n  } catch (error) {\n    yield call(reject, { _error: (error as Error).message });\n  }\n}\n\nexport function* updateUserDetailsSaga(action: ReduxAction<UpdateUserRequest>) {\n  try {\n    const { email, intercomConsentGiven, name, proficiency, useCase } =\n      action.payload;\n\n    const response: ApiResponse = yield callAPI(UserApi.updateUser, {\n      email,\n      name,\n      proficiency,\n      useCase,\n      intercomConsentGiven,\n    });\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (isValidResponse) {\n      yield put({\n        type: ReduxActionTypes.UPDATE_USER_DETAILS_SUCCESS,\n        payload: response.data,\n      });\n    }\n  } catch (error) {\n    const payload: ErrorActionPayload = {\n      show: true,\n      error: {\n        message:\n          (error as Error).message ?? createMessage(UPDATE_USER_DETAILS_FAILED),\n      },\n    };\n\n    yield put({\n      type: ReduxActionErrorTypes.UPDATE_USER_DETAILS_ERROR,\n      payload,\n    });\n  }\n}\n\nexport function* verifyResetPasswordTokenSaga(\n  action: ReduxAction<VerifyTokenRequest>,\n) {\n  try {\n    const request: VerifyTokenRequest = action.payload;\n    const response: ApiResponse = yield call(\n      UserApi.verifyResetPasswordToken,\n      request,\n    );\n    const isValidResponse: boolean = yield validateResponse(response);\n\n    if (isValidResponse && response.data) {\n      yield put({\n        type: ReduxActionTypes.RESET_PASSWORD_VERIFY_TOKEN_SUCCESS,\n      });\n    } else {\n      yield put({\n        type: ReduxActionErrorTypes.RESET_PASSWORD_VERIFY_TOKEN_ERROR,",
            "cost": 0.14255500000000002
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/ce/utils/AnalyticsUtil.tsx": {
            "output": "import log from \"loglevel\";\nimport { getAppsmithConfigs } from \"ee/configs\";\nimport type { User } from \"constants/userConstants\";\nimport { ANONYMOUS_USERNAME } from \"constants/userConstants\";\nimport type { EventName } from \"ee/utils/analyticsUtilTypes\";\nimport type { EventProperties } from \"@segment/analytics-next\";\n\nimport SegmentSingleton from \"utils/Analytics/segment\";\nimport MixpanelSingleton, {\n  type SessionRecordingConfig,\n} from \"utils/Analytics/mixpanel\";\nimport { appsmithTelemetry } from \"instrumentation\";\nimport SmartlookUtil from \"utils/Analytics/smartlook\";\nimport TrackedUser from \"ee/utils/Analytics/trackedUser\";\n\nimport {\n  initLicense,\n  initInstanceId,\n  getInstanceId,\n  getEventExtraProperties,\n} from \"ee/utils/Analytics/getEventExtraProperties\";\n\nexport enum AnalyticsEventType {\n  error = \"error\",\n}\n\nlet blockErrorLogs = false;\nlet segmentAnalytics: SegmentSingleton | null = null;\n\nasync function initialize(\n  user: User,\n  sessionRecordingConfig: SessionRecordingConfig,\n) {\n  // SentryUtil.init();\n  await SmartlookUtil.init();\n\n  segmentAnalytics = SegmentSingleton.getInstance();\n\n  await segmentAnalytics.init();\n\n  // Mixpanel needs to be initialized after Segment\n  await MixpanelSingleton.getInstance().init(sessionRecordingConfig);\n\n  // Identify the user after all services are initialized\n  await identifyUser(user);\n}\n\nfunction logEvent(\n  eventName: EventName,\n  eventData?: EventProperties,\n  eventType?: AnalyticsEventType,\n) {\n  if (blockErrorLogs && eventType === AnalyticsEventType.error) {\n    return;\n  }\n\n  const finalEventData = {\n    ...eventData,\n    ...getEventExtraProperties(),\n  };\n\n  if (segmentAnalytics) {\n    segmentAnalytics.track(eventName, finalEventData);\n  }\n}\n\nasync function identifyUser(userData: User, sendAdditionalData?: boolean) {\n  const { appVersion } = getAppsmithConfigs();\n\n  // we don't want to identify anonymous users (anonymous users are not logged-in users)\n  if (userData.isAnonymous || userData.username === ANONYMOUS_USERNAME) {\n    return;\n  }\n\n  // Initialize the TrackedUser singleton\n  const trackedUserInstance = TrackedUser.init(userData);\n\n  const trackedUser = trackedUserInstance.getUser();\n  const instanceId = getInstanceId();\n\n  const additionalData = {\n    id: trackedUser.userId,\n    version: `Appsmith ${appVersion.edition} ${appVersion.id}`,\n    instanceId,\n  };\n\n  if (segmentAnalytics) {\n    const userProperties = {\n      ...trackedUser,\n      ...(sendAdditionalData ? additionalData : {}),\n    };\n\n    log.debug(\"Identify User \" + trackedUser.userId);\n    await segmentAnalytics.identify(trackedUser.userId, userProperties);\n  }\n\n  appsmithTelemetry.identifyUser(trackedUser.userId, userData);\n\n  if (trackedUser.email) {\n    SmartlookUtil.identify(trackedUser.userId, trackedUser.email);\n  }\n}\n\nfunction setBlockErrorLogs(value: boolean) {\n  blockErrorLogs = value;\n}\n\nfunction getAnonymousId(): string | undefined | null {\n  const { segment } = getAppsmithConfigs();\n\n  if (segmentAnalytics) {\n    const user = segmentAnalytics.getUser();\n\n    if (user) {\n      return user.anonymousId();\n    }\n  } else if (segment.enabled) {\n    return localStorage.getItem(\"ajs_anonymous_id\")?.replaceAll('\"', \"\");\n  }\n}\n\nfunction reset() {\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const windowDoc: any = window;\n\n  if (windowDoc.Intercom) {\n    windowDoc.Intercom(\"shutdown\");\n  }\n\n  segmentAnalytics && segmentAnalytics.reset();\n}\n\nfunction avoidTracking() {\n  segmentAnalytics = SegmentSingleton.getInstance();\n\n  segmentAnalytics.avoidTracking();\n}\n\nexport {\n  initialize,\n  logEvent,\n  identifyUser,\n  initInstanceId,\n  setBlockErrorLogs,\n  getAnonymousId,\n  reset,\n  getEventExtraProperties,\n  initLicense,\n  avoidTracking,\n};",
            "output_extracted": "import log from \"loglevel\";\nimport { getAppsmithConfigs } from \"ee/configs\";\nimport type { User } from \"constants/userConstants\";\nimport { ANONYMOUS_USERNAME } from \"constants/userConstants\";\nimport type { EventName } from \"ee/utils/analyticsUtilTypes\";\nimport type { EventProperties } from \"@segment/analytics-next\";\n\nimport SegmentSingleton from \"utils/Analytics/segment\";\nimport MixpanelSingleton, {\n  type SessionRecordingConfig,\n} from \"utils/Analytics/mixpanel\";\nimport { appsmithTelemetry } from \"instrumentation\";\nimport SmartlookUtil from \"utils/Analytics/smartlook\";\nimport TrackedUser from \"ee/utils/Analytics/trackedUser\";\n\nimport {\n  initLicense,\n  initInstanceId,\n  getInstanceId,\n  getEventExtraProperties,\n} from \"ee/utils/Analytics/getEventExtraProperties\";\n\nexport enum AnalyticsEventType {\n  error = \"error\",\n}\n\nlet blockErrorLogs = false;\nlet segmentAnalytics: SegmentSingleton | null = null;\n\nasync function initialize(\n  user: User,\n  sessionRecordingConfig: SessionRecordingConfig,\n) {\n  // SentryUtil.init();\n  await SmartlookUtil.init();\n\n  segmentAnalytics = SegmentSingleton.getInstance();\n\n  await segmentAnalytics.init();\n\n  // Mixpanel needs to be initialized after Segment\n  await MixpanelSingleton.getInstance().init(sessionRecordingConfig);\n\n  // Identify the user after all services are initialized\n  await identifyUser(user);\n}\n\nfunction logEvent(\n  eventName: EventName,\n  eventData?: EventProperties,\n  eventType?: AnalyticsEventType,\n) {\n  if (blockErrorLogs && eventType === AnalyticsEventType.error) {\n    return;\n  }\n\n  const finalEventData = {\n    ...eventData,\n    ...getEventExtraProperties(),\n  };\n\n  if (segmentAnalytics) {\n    segmentAnalytics.track(eventName, finalEventData);\n  }\n}\n\nasync function identifyUser(userData: User, sendAdditionalData?: boolean) {\n  const { appVersion } = getAppsmithConfigs();\n\n  // we don't want to identify anonymous users (anonymous users are not logged-in users)\n  if (userData.isAnonymous || userData.username === ANONYMOUS_USERNAME) {\n    return;\n  }\n\n  // Initialize the TrackedUser singleton\n  const trackedUserInstance = TrackedUser.init(userData);\n\n  const trackedUser = trackedUserInstance.getUser();\n  const instanceId = getInstanceId();\n\n  const additionalData = {\n    id: trackedUser.userId,\n    version: `Appsmith ${appVersion.edition} ${appVersion.id}`,\n    instanceId,\n  };\n\n  if (segmentAnalytics) {\n    const userProperties = {\n      ...trackedUser,\n      ...(sendAdditionalData ? additionalData : {}),\n    };\n\n    log.debug(\"Identify User \" + trackedUser.userId);\n    await segmentAnalytics.identify(trackedUser.userId, userProperties);\n  }\n\n  appsmithTelemetry.identifyUser(trackedUser.userId, userData);\n\n  if (trackedUser.email) {\n    SmartlookUtil.identify(trackedUser.userId, trackedUser.email);\n  }\n}\n\nfunction setBlockErrorLogs(value: boolean) {\n  blockErrorLogs = value;\n}\n\nfunction getAnonymousId(): string | undefined | null {\n  const { segment } = getAppsmithConfigs();\n\n  if (segmentAnalytics) {\n    const user = segmentAnalytics.getUser();\n\n    if (user) {\n      return user.anonymousId();\n    }\n  } else if (segment.enabled) {\n    return localStorage.getItem(\"ajs_anonymous_id\")?.replaceAll('\"', \"\");\n  }\n}\n\nfunction reset() {\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const windowDoc: any = window;\n\n  if (windowDoc.Intercom) {\n    windowDoc.Intercom(\"shutdown\");\n  }\n\n  segmentAnalytics && segmentAnalytics.reset();\n}\n\nfunction avoidTracking() {\n  segmentAnalytics = SegmentSingleton.getInstance();\n\n  segmentAnalytics.avoidTracking();\n}\n\nexport {\n  initialize,\n  logEvent,\n  identifyUser,\n  initInstanceId,\n  setBlockErrorLogs,\n  getAnonymousId,\n  reset,\n  getEventExtraProperties,\n  initLicense,\n  avoidTracking,\n};",
            "cost": 0.04117
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/utils/Analytics/segment.test.ts": {
            "output": "import SegmentSingleton from \"./segment\";\nimport { getAppsmithConfigs } from \"ee/configs\";\nimport log from \"loglevel\";\n\n// Mock external dependencies\njest.mock(\"ee/configs\");\njest.mock(\"loglevel\");\njest.mock(\"@segment/analytics-next\", () => ({\n  AnalyticsBrowser: {\n    load: jest.fn(),\n  },\n}));\n\n// Mock implementations\nconst mockAnalytics = {\n  track: jest.fn(),\n  identify: jest.fn(),\n  addSourceMiddleware: jest.fn(),\n  reset: jest.fn(),\n  user: jest.fn(),\n};\n\nconst mockAnalyticsBrowser = {\n  load: jest.fn().mockResolvedValue([mockAnalytics]),\n};\n\n// Setup before each test\nbeforeEach(() => {\n  jest.clearAllMocks();\n\n  // Reset singleton instance\n  (SegmentSingleton as unknown as { instance: unknown }).instance = undefined;\n\n  // Default mock for getAppsmithConfigs\n  (getAppsmithConfigs as jest.Mock).mockReturnValue({\n    segment: {\n      enabled: true,\n      apiKey: \"test-api-key\",\n      ceKey: \"test-ce-key\",\n    },\n  });\n\n  // Set up AnalyticsBrowser mock\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  require(\"@segment/analytics-next\").AnalyticsBrowser = mockAnalyticsBrowser;\n});\n\ndescribe(\"SegmentSingleton\", () => {\n  describe(\"getInstance\", () => {\n    it(\"should return the same instance when called multiple times\", () => {\n      const instance1 = SegmentSingleton.getInstance();\n      const instance2 = SegmentSingleton.getInstance();\n\n      expect(instance1).toBe(instance2);\n    });\n  });\n\n  describe(\"init\", () => {\n    it(\"should initialize successfully with API key\", async () => {\n      const segment = SegmentSingleton.getInstance();\n      const result = await segment.init();\n\n      expect(result).toBe(true);\n      expect(mockAnalyticsBrowser.load).toHaveBeenCalledWith(\n        { writeKey: \"test-api-key\" },\n        expect.any(Object),\n      );\n    });\n\n    it(\"should not initialize when segment is disabled\", async () => {\n      (getAppsmithConfigs as jest.Mock).mockReturnValue({\n        segment: { enabled: false },\n      });\n\n      const segment = SegmentSingleton.getInstance();\n      const result = await segment.init();\n\n      expect(result).toBe(true);\n      expect(mockAnalyticsBrowser.load).not.toHaveBeenCalled();\n    });\n\n    it(\"should use ceKey when apiKey is not available\", async () => {\n      (getAppsmithConfigs as jest.Mock).mockReturnValue({\n        segment: {\n          enabled: true,\n          apiKey: \"\",\n          ceKey: \"test-ce-key\",\n        },\n      });\n\n      const segment = SegmentSingleton.getInstance();\n      const result = await segment.init();\n\n      expect(result).toBe(true);\n      expect(mockAnalyticsBrowser.load).toHaveBeenCalledWith(\n        { writeKey: \"test-ce-key\" },\n        expect.any(Object),\n      );\n    });\n  });\n\n  describe(\"track\", () => {\n    it(\"should queue events when not initialized\", () => {\n      const segment = SegmentSingleton.getInstance();\n      const eventData = { test: \"data\" };\n\n      segment.track(\"test-event\", eventData);\n\n      expect(mockAnalytics.track).not.toHaveBeenCalled();\n      expect(log.debug).toHaveBeenCalledWith(\n        \"Event queued for later processing\",\n        \"test-event\",\n        eventData,\n      );\n    });\n\n    it(\"should process queued events after initialization\", async () => {\n      const segment = SegmentSingleton.getInstance();\n      const eventData = { test: \"data\" };\n\n      segment.track(\"test-event\", eventData);\n      await segment.init();\n\n      expect(mockAnalytics.track).toHaveBeenCalledWith(\"test-event\", eventData);\n    });\n\n    it(\"should track events directly when initialized\", async () => {\n      const segment = SegmentSingleton.getInstance();\n\n      await segment.init();\n\n      const eventData = { test: \"data\" };\n\n      segment.track(\"test-event\", eventData);\n\n      expect(mockAnalytics.track).toHaveBeenCalledWith(\"test-event\", eventData);\n    });\n  });\n\n  describe(\"identify\", () => {\n    it(\"should call analytics identify when initialized\", async () => {\n      const segment = SegmentSingleton.getInstance();\n\n      await segment.init();\n\n      const userId = \"test-user\";\n      const traits = { name: \"Test User\" };\n\n      await segment.identify(userId, traits);\n\n      expect(mockAnalytics.identify).toHaveBeenCalledWith(userId, traits);\n    });\n  });\n\n  describe(\"reset\", () => {\n    it(\"should call analytics reset when initialized\", async () => {\n      const segment = SegmentSingleton.getInstance();\n\n      await segment.init();\n\n      segment.reset();\n\n      expect(mockAnalytics.reset).toHaveBeenCalled();\n    });\n  });\n\n  describe(\"error handling\", () => {\n    it(\"should handle initialization failure\", async () => {\n      mockAnalyticsBrowser.load.mockRejectedValueOnce(new Error(\"Init failed\"));\n\n      const segment = SegmentSingleton.getInstance();\n      const result = await segment.init();\n\n      expect(result).toBe(false);\n      expect(log.error).toHaveBeenCalledWith(\n        \"Failed to initialize Segment:\",\n        expect.any(Error),\n      );\n    });\n  });\n  describe(\"avoidTracking\", () => {\n    it(\"should not track events after avoidTracking is called\", async () => {\n      const segment = SegmentSingleton.getInstance();\n\n      await segment.init();\n\n      // Track an event before calling avoidTracking\n      segment.track(\"pre-avoid-event\", { data: \"value\" });\n      expect(mockAnalytics.track).toHaveBeenCalledTimes(1);\n\n      // Call avoidTracking\n      segment.avoidTracking();\n\n      // Track an event after calling avoidTracking\n      segment.track(\"post-avoid-event\", { data: \"value\" });\n\n      // Should still have only been called once (from the first event)\n      expect(mockAnalytics.track).toHaveBeenCalledTimes(1);\n      expect(log.debug).toHaveBeenCalledWith(\n        expect.stringContaining(\"Event fired locally\"),\n        \"post-avoid-event\",\n        { data: \"value\" },\n      );\n    });\n\n    it(\"should flush queued events when avoidTracking is called before initialization\", async () => {\n      const segment = SegmentSingleton.getInstance();\n\n      // Queue some events\n      segment.track(\"queued-event-1\", { data: \"value1\" });\n      segment.track(\"queued-event-2\", { data: \"value2\" });\n\n      // Call avoidTracking before initialization\n      segment.avoidTracking();\n\n      // Initialize\n      await segment.init();\n\n      // Analytics track should not be called since we're avoiding tracking\n      expect(mockAnalytics.track).not.toHaveBeenCalled();\n    });\n  });\n});",
            "output_extracted": "import SegmentSingleton from \"./segment\";\nimport { getAppsmithConfigs } from \"ee/configs\";\nimport log from \"loglevel\";\n\n// Mock external dependencies\njest.mock(\"ee/configs\");\njest.mock(\"loglevel\");\njest.mock(\"@segment/analytics-next\", () => ({\n  AnalyticsBrowser: {\n    load: jest.fn(),\n  },\n}));\n\n// Mock implementations\nconst mockAnalytics = {\n  track: jest.fn(),\n  identify: jest.fn(),\n  addSourceMiddleware: jest.fn(),\n  reset: jest.fn(),\n  user: jest.fn(),\n};\n\nconst mockAnalyticsBrowser = {\n  load: jest.fn().mockResolvedValue([mockAnalytics]),\n};\n\n// Setup before each test\nbeforeEach(() => {\n  jest.clearAllMocks();\n\n  // Reset singleton instance\n  (SegmentSingleton as unknown as { instance: unknown }).instance = undefined;\n\n  // Default mock for getAppsmithConfigs\n  (getAppsmithConfigs as jest.Mock).mockReturnValue({\n    segment: {\n      enabled: true,\n      apiKey: \"test-api-key\",\n      ceKey: \"test-ce-key\",\n    },\n  });\n\n  // Set up AnalyticsBrowser mock\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  require(\"@segment/analytics-next\").AnalyticsBrowser = mockAnalyticsBrowser;\n});\n\ndescribe(\"SegmentSingleton\", () => {\n  describe(\"getInstance\", () => {\n    it(\"should return the same instance when called multiple times\", () => {\n      const instance1 = SegmentSingleton.getInstance();\n      const instance2 = SegmentSingleton.getInstance();\n\n      expect(instance1).toBe(instance2);\n    });\n  });\n\n  describe(\"init\", () => {\n    it(\"should initialize successfully with API key\", async () => {\n      const segment = SegmentSingleton.getInstance();\n      const result = await segment.init();\n\n      expect(result).toBe(true);\n      expect(mockAnalyticsBrowser.load).toHaveBeenCalledWith(\n        { writeKey: \"test-api-key\" },\n        expect.any(Object),\n      );\n    });\n\n    it(\"should not initialize when segment is disabled\", async () => {\n      (getAppsmithConfigs as jest.Mock).mockReturnValue({\n        segment: { enabled: false },\n      });\n\n      const segment = SegmentSingleton.getInstance();\n      const result = await segment.init();\n\n      expect(result).toBe(true);\n      expect(mockAnalyticsBrowser.load).not.toHaveBeenCalled();\n    });\n\n    it(\"should use ceKey when apiKey is not available\", async () => {\n      (getAppsmithConfigs as jest.Mock).mockReturnValue({\n        segment: {\n          enabled: true,\n          apiKey: \"\",\n          ceKey: \"test-ce-key\",\n        },\n      });\n\n      const segment = SegmentSingleton.getInstance();\n      const result = await segment.init();\n\n      expect(result).toBe(true);\n      expect(mockAnalyticsBrowser.load).toHaveBeenCalledWith(\n        { writeKey: \"test-ce-key\" },\n        expect.any(Object),\n      );\n    });\n  });\n\n  describe(\"track\", () => {\n    it(\"should queue events when not initialized\", () => {\n      const segment = SegmentSingleton.getInstance();\n      const eventData = { test: \"data\" };\n\n      segment.track(\"test-event\", eventData);\n\n      expect(mockAnalytics.track).not.toHaveBeenCalled();\n      expect(log.debug).toHaveBeenCalledWith(\n        \"Event queued for later processing\",\n        \"test-event\",\n        eventData,\n      );\n    });\n\n    it(\"should process queued events after initialization\", async () => {\n      const segment = SegmentSingleton.getInstance();\n      const eventData = { test: \"data\" };\n\n      segment.track(\"test-event\", eventData);\n      await segment.init();\n\n      expect(mockAnalytics.track).toHaveBeenCalledWith(\"test-event\", eventData);\n    });\n\n    it(\"should track events directly when initialized\", async () => {\n      const segment = SegmentSingleton.getInstance();\n\n      await segment.init();\n\n      const eventData = { test: \"data\" };\n\n      segment.track(\"test-event\", eventData);\n\n      expect(mockAnalytics.track).toHaveBeenCalledWith(\"test-event\", eventData);\n    });\n  });\n\n  describe(\"identify\", () => {\n    it(\"should call analytics identify when initialized\", async () => {\n      const segment = SegmentSingleton.getInstance();\n\n      await segment.init();\n\n      const userId = \"test-user\";\n      const traits = { name: \"Test User\" };\n\n      await segment.identify(userId, traits);\n\n      expect(mockAnalytics.identify).toHaveBeenCalledWith(userId, traits);\n    });\n  });\n\n  describe(\"reset\", () => {\n    it(\"should call analytics reset when initialized\", async () => {\n      const segment = SegmentSingleton.getInstance();\n\n      await segment.init();\n\n      segment.reset();\n\n      expect(mockAnalytics.reset).toHaveBeenCalled();\n    });\n  });\n\n  describe(\"error handling\", () => {\n    it(\"should handle initialization failure\", async () => {\n      mockAnalyticsBrowser.load.mockRejectedValueOnce(new Error(\"Init failed\"));\n\n      const segment = SegmentSingleton.getInstance();\n      const result = await segment.init();\n\n      expect(result).toBe(false);\n      expect(log.error).toHaveBeenCalledWith(\n        \"Failed to initialize Segment:\",\n        expect.any(Error),\n      );\n    });\n  });\n  describe(\"avoidTracking\", () => {\n    it(\"should not track events after avoidTracking is called\", async () => {\n      const segment = SegmentSingleton.getInstance();\n\n      await segment.init();\n\n      // Track an event before calling avoidTracking\n      segment.track(\"pre-avoid-event\", { data: \"value\" });\n      expect(mockAnalytics.track).toHaveBeenCalledTimes(1);\n\n      // Call avoidTracking\n      segment.avoidTracking();\n\n      // Track an event after calling avoidTracking\n      segment.track(\"post-avoid-event\", { data: \"value\" });\n\n      // Should still have only been called once (from the first event)\n      expect(mockAnalytics.track).toHaveBeenCalledTimes(1);\n      expect(log.debug).toHaveBeenCalledWith(\n        expect.stringContaining(\"Event fired locally\"),\n        \"post-avoid-event\",\n        { data: \"value\" },\n      );\n    });\n\n    it(\"should flush queued events when avoidTracking is called before initialization\", async () => {\n      const segment = SegmentSingleton.getInstance();\n\n      // Queue some events\n      segment.track(\"queued-event-1\", { data: \"value1\" });\n      segment.track(\"queued-event-2\", { data: \"value2\" });\n\n      // Call avoidTracking before initialization\n      segment.avoidTracking();\n\n      // Initialize\n      await segment.init();\n\n      // Analytics track should not be called since we're avoiding tracking\n      expect(mockAnalytics.track).not.toHaveBeenCalled();\n    });\n  });\n});",
            "cost": 0.066465
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/utils/Analytics/segment.ts": {
            "output": "import {\n  type Analytics,\n  type EventProperties,\n  type MiddlewareFunction,\n  type UserTraits,\n  AnalyticsBrowser,\n} from \"@segment/analytics-next\";\nimport { getAppsmithConfigs } from \"ee/configs\";\nimport log from \"loglevel\";\n\nenum InitializationStatus {\n  WAITING = \"waiting\",\n  INITIALIZED = \"initialized\",\n  FAILED = \"failed\",\n  NOT_REQUIRED = \"not_required\",\n}\n\nclass SegmentSingleton {\n  private static instance: SegmentSingleton;\n  private analytics: Analytics | null = null;\n  private eventQueue: Array<{ name: string; data: EventProperties }> = [];\n  private initState: InitializationStatus = InitializationStatus.WAITING;\n\n  public static getInstance(): SegmentSingleton {\n    if (!SegmentSingleton.instance) {\n      SegmentSingleton.instance = new SegmentSingleton();\n    }\n\n    return SegmentSingleton.instance;\n  }\n\n  public getUser() {\n    if (this.analytics) {\n      return this.analytics.user();\n    }\n  }\n\n  private getWriteKey(): string | undefined {\n    const { segment } = getAppsmithConfigs();\n\n    // This value is only enabled for Appsmith's cloud hosted version. It is not set in self-hosted environments\n    if (segment.apiKey) {\n      return segment.apiKey;\n    }\n\n    // This value is set in self-hosted environments. But if the analytics are disabled, it's never used.\n    if (segment.ceKey) {\n      return segment.ceKey;\n    }\n  }\n\n  public async init(): Promise<boolean> {\n    const { segment } = getAppsmithConfigs();\n\n    if (!segment.enabled) {\n      this.avoidTracking();\n\n      return true;\n    }\n\n    if (this.analytics) {\n      log.warn(\"Segment is already initialized.\");\n\n      return true;\n    }\n\n    const writeKey = this.getWriteKey();\n\n    if (!writeKey) {\n      log.error(\"Segment key was not found.\");\n      this.avoidTracking();\n\n      return true;\n    }\n\n    try {\n      const [analytics] = await AnalyticsBrowser.load(\n        { writeKey },\n        {\n          integrations: {\n            \"Segment.io\": {\n              deliveryStrategy: {\n                strategy: \"batching\", // The delivery strategy used for sending events to Segment\n                config: {\n                  size: 100, // The batch size is the threshold that forces all batched events to be sent once it's reached.\n                  timeout: 1000, // The number of milliseconds that forces all events queued for batching to be sent, regardless of the batch size, once it's reached\n                },\n              },\n            },\n          },\n        },\n      );\n\n      this.analytics = analytics;\n      this.initState = InitializationStatus.INITIALIZED;\n      // Process queued events after successful initialization\n      this.processEventQueue();\n\n      return true;\n    } catch (error) {\n      log.error(\"Failed to initialize Segment:\", error);\n      // Clear the queue if error occurred in init\n      this.flushEventQueue();\n      this.initState = InitializationStatus.FAILED;\n\n      return false;\n    }\n  }\n\n  private processEventQueue() {\n    while (this.eventQueue.length > 0) {\n      const event = this.eventQueue.shift();\n\n      if (event) {\n        this.track(event.name, event.data);\n      }\n    }\n  }\n\n  private flushEventQueue() {\n    this.eventQueue = [];\n  }\n\n  public track(eventName: string, eventData: EventProperties) {\n    if (this.initState === InitializationStatus.WAITING) {\n      // Only queue events if we're in WAITING state\n      this.eventQueue.push({ name: eventName, data: eventData });\n      log.debug(\"Event queued for later processing\", eventName, eventData);\n    }\n\n    if (\n      this.initState === InitializationStatus.NOT_REQUIRED ||\n      !this.analytics\n    ) {\n      log.debug(\"Event fired locally\", eventName, eventData);\n\n      return;\n    }\n\n    log.debug(\"Event fired\", eventName, eventData);\n    this.analytics.track(eventName, eventData);\n  }\n\n  public async identify(userId: string, traits: UserTraits) {\n    if (this.analytics) {\n      await this.analytics.identify(userId, traits);\n    }\n  }\n\n  public async addMiddleware(middleware: MiddlewareFunction) {\n    if (this.analytics) {\n      await this.analytics.addSourceMiddleware(middleware);\n    }\n  }\n\n  public avoidTracking() {\n    this.initState = InitializationStatus.NOT_REQUIRED;\n    this.flushEventQueue();\n  }\n\n  public reset() {\n    if (this.analytics) {\n      this.analytics.reset();\n    }\n  }\n}\n\nexport default SegmentSingleton;",
            "output_extracted": "import {\n  type Analytics,\n  type EventProperties,\n  type MiddlewareFunction,\n  type UserTraits,\n  AnalyticsBrowser,\n} from \"@segment/analytics-next\";\nimport { getAppsmithConfigs } from \"ee/configs\";\nimport log from \"loglevel\";\n\nenum InitializationStatus {\n  WAITING = \"waiting\",\n  INITIALIZED = \"initialized\",\n  FAILED = \"failed\",\n  NOT_REQUIRED = \"not_required\",\n}\n\nclass SegmentSingleton {\n  private static instance: SegmentSingleton;\n  private analytics: Analytics | null = null;\n  private eventQueue: Array<{ name: string; data: EventProperties }> = [];\n  private initState: InitializationStatus = InitializationStatus.WAITING;\n\n  public static getInstance(): SegmentSingleton {\n    if (!SegmentSingleton.instance) {\n      SegmentSingleton.instance = new SegmentSingleton();\n    }\n\n    return SegmentSingleton.instance;\n  }\n\n  public getUser() {\n    if (this.analytics) {\n      return this.analytics.user();\n    }\n  }\n\n  private getWriteKey(): string | undefined {\n    const { segment } = getAppsmithConfigs();\n\n    // This value is only enabled for Appsmith's cloud hosted version. It is not set in self-hosted environments\n    if (segment.apiKey) {\n      return segment.apiKey;\n    }\n\n    // This value is set in self-hosted environments. But if the analytics are disabled, it's never used.\n    if (segment.ceKey) {\n      return segment.ceKey;\n    }\n  }\n\n  public async init(): Promise<boolean> {\n    const { segment } = getAppsmithConfigs();\n\n    if (!segment.enabled) {\n      this.avoidTracking();\n\n      return true;\n    }\n\n    if (this.analytics) {\n      log.warn(\"Segment is already initialized.\");\n\n      return true;\n    }\n\n    const writeKey = this.getWriteKey();\n\n    if (!writeKey) {\n      log.error(\"Segment key was not found.\");\n      this.avoidTracking();\n\n      return true;\n    }\n\n    try {\n      const [analytics] = await AnalyticsBrowser.load(\n        { writeKey },\n        {\n          integrations: {\n            \"Segment.io\": {\n              deliveryStrategy: {\n                strategy: \"batching\", // The delivery strategy used for sending events to Segment\n                config: {\n                  size: 100, // The batch size is the threshold that forces all batched events to be sent once it's reached.\n                  timeout: 1000, // The number of milliseconds that forces all events queued for batching to be sent, regardless of the batch size, once it's reached\n                },\n              },\n            },\n          },\n        },\n      );\n\n      this.analytics = analytics;\n      this.initState = InitializationStatus.INITIALIZED;\n      // Process queued events after successful initialization\n      this.processEventQueue();\n\n      return true;\n    } catch (error) {\n      log.error(\"Failed to initialize Segment:\", error);\n      // Clear the queue if error occurred in init\n      this.flushEventQueue();\n      this.initState = InitializationStatus.FAILED;\n\n      return false;\n    }\n  }\n\n  private processEventQueue() {\n    while (this.eventQueue.length > 0) {\n      const event = this.eventQueue.shift();\n\n      if (event) {\n        this.track(event.name, event.data);\n      }\n    }\n  }\n\n  private flushEventQueue() {\n    this.eventQueue = [];\n  }\n\n  public track(eventName: string, eventData: EventProperties) {\n    if (this.initState === InitializationStatus.WAITING) {\n      // Only queue events if we're in WAITING state\n      this.eventQueue.push({ name: eventName, data: eventData });\n      log.debug(\"Event queued for later processing\", eventName, eventData);\n    }\n\n    if (\n      this.initState === InitializationStatus.NOT_REQUIRED ||\n      !this.analytics\n    ) {\n      log.debug(\"Event fired locally\", eventName, eventData);\n\n      return;\n    }\n\n    log.debug(\"Event fired\", eventName, eventData);\n    this.analytics.track(eventName, eventData);\n  }\n\n  public async identify(userId: string, traits: UserTraits) {\n    if (this.analytics) {\n      await this.analytics.identify(userId, traits);\n    }\n  }\n\n  public async addMiddleware(middleware: MiddlewareFunction) {\n    if (this.analytics) {\n      await this.analytics.addSourceMiddleware(middleware);\n    }\n  }\n\n  public avoidTracking() {\n    this.initState = InitializationStatus.NOT_REQUIRED;\n    this.flushEventQueue();\n  }\n\n  public reset() {\n    if (this.analytics) {\n      this.analytics.reset();\n    }\n  }\n}\n\nexport default SegmentSingleton;",
            "cost": 0.042495000000000005
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "appsmithorg__appsmith.main.40936",
        "repo": "appsmithorg/appsmith",
        "base_commit": "c17dc3aabc4475bc267ed936cf29f634f6792731",
        "head_commit": "ba524fe2f769b6f8d2c72e0332560dd5e0c0465e",
        "title": "chore: Disable anonymous user tracking when feature flag turned on",
        "merged_at": "2025-07-02T07:20:51Z",
        "html_url": "https://github.com/appsmithorg/appsmith/pull/40936",
        "test_files": [
            "app/client/src/utils/Analytics/segment.test.ts"
        ],
        "code_files": [
            "app/client/src/ce/entities/FeatureFlag.ts",
            "app/client/src/ce/sagas/userSagas.tsx",
            "app/client/src/ce/utils/AnalyticsUtil.tsx",
            "app/client/src/utils/Analytics/segment.ts"
        ],
        "total_changes": 126,
        "num_files": 8,
        "pull_number": 40936,
        "patch": "diff --git a/app/client/src/ce/entities/FeatureFlag.ts b/app/client/src/ce/entities/FeatureFlag.ts\nindex 120af37c6d6..d8efbcae67d 100644\n--- a/app/client/src/ce/entities/FeatureFlag.ts\n+++ b/app/client/src/ce/entities/FeatureFlag.ts\n@@ -62,6 +62,8 @@ export const FEATURE_FLAG = {\n   license_ai_agent_instance_enabled: \"license_ai_agent_instance_enabled\",\n   release_jsobjects_onpageunloadactions_enabled:\n     \"release_jsobjects_onpageunloadactions_enabled\",\n+  configure_block_event_tracking_for_anonymous_users:\n+    \"configure_block_event_tracking_for_anonymous_users\",\n } as const;\n \n export type FeatureFlag = keyof typeof FEATURE_FLAG;\n@@ -113,6 +115,7 @@ export const DEFAULT_FEATURE_FLAG_VALUE: FeatureFlags = {\n   release_reactive_actions_enabled: false,\n   license_ai_agent_instance_enabled: false,\n   release_jsobjects_onpageunloadactions_enabled: false,\n+  configure_block_event_tracking_for_anonymous_users: false,\n };\n \n export const AB_TESTING_EVENT_KEYS = {\ndiff --git a/app/client/src/ce/sagas/userSagas.tsx b/app/client/src/ce/sagas/userSagas.tsx\nindex 874d041f04c..c83357d335a 100644\n--- a/app/client/src/ce/sagas/userSagas.tsx\n+++ b/app/client/src/ce/sagas/userSagas.tsx\n@@ -7,6 +7,7 @@ import {\n   take,\n   type TakeEffect,\n } from \"redux-saga/effects\";\n+import type { SagaIterator } from \"redux-saga\";\n import type {\n   ReduxAction,\n   ReduxActionWithPromise,\n@@ -88,6 +89,7 @@ import {\n   segmentInitUncertain,\n } from \"actions/analyticsActions\";\n import { getSegmentState } from \"selectors/analyticsSelectors\";\n+import { getOrganizationConfig } from \"ee/selectors/organizationSelectors\";\n \n export function* getCurrentUserSaga(action?: {\n   payload?: { userProfile?: ApiResponse };\n@@ -150,7 +152,28 @@ function* getSessionRecordingConfig() {\n   };\n }\n \n-function* initTrackers(currentUser: User) {\n+function shouldTrackUser(\n+  currentUser: User,\n+  licenseActive: boolean,\n+  featureFlag: boolean,\n+): boolean {\n+  try {\n+    const isAnonymous =\n+      currentUser?.isAnonymous || currentUser?.username === \"anonymousUser\";\n+\n+    if (!isAnonymous) {\n+      return true;\n+    }\n+\n+    const telemetryOn = currentUser?.enableTelemetry ?? false;\n+\n+    return isAnonymous && (licenseActive || (telemetryOn && !featureFlag));\n+  } catch (error) {\n+    return true;\n+  }\n+}\n+\n+function* initTrackers(currentUser: User): SagaIterator {\n   try {\n     const isFFFetched: boolean = yield select(getFeatureFlagsFetched);\n \n@@ -162,7 +185,21 @@ function* initTrackers(currentUser: User) {\n       getSessionRecordingConfig,\n     );\n \n-    yield call(AnalyticsUtil.initialize, currentUser, sessionRecordingConfig);\n+    const featureFlags: FeatureFlags = yield select(selectFeatureFlags);\n+    const organizationConfig = yield select(getOrganizationConfig);\n+\n+    const shouldTrack = shouldTrackUser(\n+      currentUser,\n+      organizationConfig.license.active,\n+      featureFlags.configure_block_event_tracking_for_anonymous_users,\n+    );\n+\n+    yield call(\n+      AnalyticsUtil.initialize,\n+      currentUser,\n+      sessionRecordingConfig,\n+      shouldTrack,\n+    );\n     yield put(segmentInitSuccess());\n   } catch (e) {\n     log.error(e);\ndiff --git a/app/client/src/ce/utils/AnalyticsUtil.tsx b/app/client/src/ce/utils/AnalyticsUtil.tsx\nindex bcd16f595d4..1312995a432 100644\n--- a/app/client/src/ce/utils/AnalyticsUtil.tsx\n+++ b/app/client/src/ce/utils/AnalyticsUtil.tsx\n@@ -30,13 +30,14 @@ let segmentAnalytics: SegmentSingleton | null = null;\n async function initialize(\n   user: User,\n   sessionRecordingConfig: SessionRecordingConfig,\n+  shouldTrackUser: boolean,\n ) {\n   // SentryUtil.init();\n   await SmartlookUtil.init();\n \n   segmentAnalytics = SegmentSingleton.getInstance();\n \n-  await segmentAnalytics.init();\n+  await segmentAnalytics.init(shouldTrackUser);\n \n   // Mixpanel needs to be initialized after Segment\n   await MixpanelSingleton.getInstance().init(sessionRecordingConfig);\ndiff --git a/app/client/src/utils/Analytics/segment.test.ts b/app/client/src/utils/Analytics/segment.test.ts\nindex 3a67b1c2a79..274919bc099 100644\n--- a/app/client/src/utils/Analytics/segment.test.ts\n+++ b/app/client/src/utils/Analytics/segment.test.ts\n@@ -58,7 +58,7 @@ describe(\"SegmentSingleton\", () => {\n   describe(\"init\", () => {\n     it(\"should initialize successfully with API key\", async () => {\n       const segment = SegmentSingleton.getInstance();\n-      const result = await segment.init();\n+      const result = await segment.init(true);\n \n       expect(result).toBe(true);\n       expect(mockAnalyticsBrowser.load).toHaveBeenCalledWith(\n@@ -73,7 +73,15 @@ describe(\"SegmentSingleton\", () => {\n       });\n \n       const segment = SegmentSingleton.getInstance();\n-      const result = await segment.init();\n+      const result = await segment.init(true);\n+\n+      expect(result).toBe(true);\n+      expect(mockAnalyticsBrowser.load).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"should not initialize when shouldTrackUser is false\", async () => {\n+      const segment = SegmentSingleton.getInstance();\n+      const result = await segment.init(false);\n \n       expect(result).toBe(true);\n       expect(mockAnalyticsBrowser.load).not.toHaveBeenCalled();\n@@ -89,7 +97,7 @@ describe(\"SegmentSingleton\", () => {\n       });\n \n       const segment = SegmentSingleton.getInstance();\n-      const result = await segment.init();\n+      const result = await segment.init(true);\n \n       expect(result).toBe(true);\n       expect(mockAnalyticsBrowser.load).toHaveBeenCalledWith(\n@@ -119,7 +127,7 @@ describe(\"SegmentSingleton\", () => {\n       const eventData = { test: \"data\" };\n \n       segment.track(\"test-event\", eventData);\n-      await segment.init();\n+      await segment.init(true);\n \n       expect(mockAnalytics.track).toHaveBeenCalledWith(\"test-event\", eventData);\n     });\n@@ -127,7 +135,7 @@ describe(\"SegmentSingleton\", () => {\n     it(\"should track events directly when initialized\", async () => {\n       const segment = SegmentSingleton.getInstance();\n \n-      await segment.init();\n+      await segment.init(true);\n \n       const eventData = { test: \"data\" };\n \n@@ -141,7 +149,7 @@ describe(\"SegmentSingleton\", () => {\n     it(\"should call analytics identify when initialized\", async () => {\n       const segment = SegmentSingleton.getInstance();\n \n-      await segment.init();\n+      await segment.init(true);\n \n       const userId = \"test-user\";\n       const traits = { name: \"Test User\" };\n@@ -156,7 +164,7 @@ describe(\"SegmentSingleton\", () => {\n     it(\"should call analytics reset when initialized\", async () => {\n       const segment = SegmentSingleton.getInstance();\n \n-      await segment.init();\n+      await segment.init(true);\n \n       segment.reset();\n \n@@ -169,7 +177,7 @@ describe(\"SegmentSingleton\", () => {\n       mockAnalyticsBrowser.load.mockRejectedValueOnce(new Error(\"Init failed\"));\n \n       const segment = SegmentSingleton.getInstance();\n-      const result = await segment.init();\n+      const result = await segment.init(true);\n \n       expect(result).toBe(false);\n       expect(log.error).toHaveBeenCalledWith(\n@@ -182,7 +190,7 @@ describe(\"SegmentSingleton\", () => {\n     it(\"should not track events after avoidTracking is called\", async () => {\n       const segment = SegmentSingleton.getInstance();\n \n-      await segment.init();\n+      await segment.init(true);\n \n       // Track an event before calling avoidTracking\n       segment.track(\"pre-avoid-event\", { data: \"value\" });\n@@ -214,7 +222,7 @@ describe(\"SegmentSingleton\", () => {\n       segment.avoidTracking();\n \n       // Initialize\n-      await segment.init();\n+      await segment.init(true);\n \n       // Analytics track should not be called since we're avoiding tracking\n       expect(mockAnalytics.track).not.toHaveBeenCalled();\ndiff --git a/app/client/src/utils/Analytics/segment.ts b/app/client/src/utils/Analytics/segment.ts\nindex d03c89f5fd9..c15055484ca 100644\n--- a/app/client/src/utils/Analytics/segment.ts\n+++ b/app/client/src/utils/Analytics/segment.ts\n@@ -49,7 +49,7 @@ class SegmentSingleton {\n     }\n   }\n \n-  public async init(): Promise<boolean> {\n+  public async init(shouldTrackUser: boolean): Promise<boolean> {\n     const { segment } = getAppsmithConfigs();\n \n     if (!segment.enabled) {\n@@ -58,6 +58,12 @@ class SegmentSingleton {\n       return true;\n     }\n \n+    if (!shouldTrackUser) {\n+      this.avoidTracking();\n+\n+      return true;\n+    }\n+\n     if (this.analytics) {\n       log.warn(\"Segment is already initialized.\");\n \ndiff --git a/app/server/appsmith-interfaces/src/main/java/com/appsmith/external/enums/FeatureFlagEnum.java b/app/server/appsmith-interfaces/src/main/java/com/appsmith/external/enums/FeatureFlagEnum.java\nindex 3d26e6c8f3d..49309885d8f 100644\n--- a/app/server/appsmith-interfaces/src/main/java/com/appsmith/external/enums/FeatureFlagEnum.java\n+++ b/app/server/appsmith-interfaces/src/main/java/com/appsmith/external/enums/FeatureFlagEnum.java\n@@ -15,6 +15,7 @@ public enum FeatureFlagEnum {\n     release_embed_hide_share_settings_enabled,\n     rollout_datasource_test_rate_limit_enabled,\n     release_gs_all_sheets_options_enabled,\n+    configure_block_event_tracking_for_anonymous_users,\n     /**\n      * Feature flag to detect if the git reset optimization is enabled\n      */\ndiff --git a/app/server/appsmith-server/src/main/java/com/appsmith/server/services/AnalyticsServiceImpl.java b/app/server/appsmith-server/src/main/java/com/appsmith/server/services/AnalyticsServiceImpl.java\nindex 22073d5952e..35720c5f4ca 100644\n--- a/app/server/appsmith-server/src/main/java/com/appsmith/server/services/AnalyticsServiceImpl.java\n+++ b/app/server/appsmith-server/src/main/java/com/appsmith/server/services/AnalyticsServiceImpl.java\n@@ -9,6 +9,7 @@\n import com.segment.analytics.Analytics;\n import lombok.extern.slf4j.Slf4j;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Lazy;\n import org.springframework.stereotype.Service;\n \n @Slf4j\n@@ -24,7 +25,8 @@ public AnalyticsServiceImpl(\n             UserUtils userUtils,\n             ProjectProperties projectProperties,\n             UserDataRepository userDataRepository,\n-            DeploymentProperties deploymentProperties) {\n+            DeploymentProperties deploymentProperties,\n+            @Lazy FeatureFlagService featureFlagService) {\n         super(\n                 analytics,\n                 sessionUserService,\n@@ -33,6 +35,7 @@ public AnalyticsServiceImpl(\n                 userUtils,\n                 projectProperties,\n                 deploymentProperties,\n-                userDataRepository);\n+                userDataRepository,\n+                featureFlagService);\n     }\n }\ndiff --git a/app/server/appsmith-server/src/main/java/com/appsmith/server/services/ce/AnalyticsServiceCEImpl.java b/app/server/appsmith-server/src/main/java/com/appsmith/server/services/ce/AnalyticsServiceCEImpl.java\nindex 4fb98dd8a18..92d32e1eb72 100644\n--- a/app/server/appsmith-server/src/main/java/com/appsmith/server/services/ce/AnalyticsServiceCEImpl.java\n+++ b/app/server/appsmith-server/src/main/java/com/appsmith/server/services/ce/AnalyticsServiceCEImpl.java\n@@ -1,6 +1,7 @@\n package com.appsmith.server.services.ce;\n \n import com.appsmith.external.constants.AnalyticsEvents;\n+import com.appsmith.external.enums.FeatureFlagEnum;\n import com.appsmith.external.helpers.Identifiable;\n import com.appsmith.external.models.ActionDTO;\n import com.appsmith.external.models.BaseDomain;\n@@ -15,6 +16,7 @@\n import com.appsmith.server.helpers.UserUtils;\n import com.appsmith.server.repositories.UserDataRepository;\n import com.appsmith.server.services.ConfigService;\n+import com.appsmith.server.services.FeatureFlagService;\n import com.appsmith.server.services.SessionUserService;\n import com.segment.analytics.Analytics;\n import com.segment.analytics.messages.IdentifyMessage;\n@@ -24,6 +26,7 @@\n import org.apache.commons.lang3.ObjectUtils;\n import org.apache.commons.lang3.StringUtils;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Lazy;\n import reactor.core.publisher.Mono;\n \n import java.util.HashMap;\n@@ -48,6 +51,7 @@ public class AnalyticsServiceCEImpl implements AnalyticsServiceCE {\n     private final SessionUserService sessionUserService;\n     private final CommonConfig commonConfig;\n     private final ConfigService configService;\n+    private final FeatureFlagService featureFlagService;\n \n     private final UserUtils userUtils;\n \n@@ -65,11 +69,13 @@ public AnalyticsServiceCEImpl(\n             UserUtils userUtils,\n             ProjectProperties projectProperties,\n             DeploymentProperties deploymentProperties,\n-            UserDataRepository userDataRepository) {\n+            UserDataRepository userDataRepository,\n+            @Lazy FeatureFlagService featureFlagService) {\n         this.analytics = analytics;\n         this.sessionUserService = sessionUserService;\n         this.commonConfig = commonConfig;\n         this.configService = configService;\n+        this.featureFlagService = featureFlagService;\n         this.userUtils = userUtils;\n         this.projectProperties = projectProperties;\n         this.deploymentProperties = deploymentProperties;\n@@ -319,7 +325,26 @@ public <T> Mono<T> sendObjectEvent(AnalyticsEvents event, T object, Map<String,\n \n         Mono<User> userMono = sessionUserService.getCurrentUser().switchIfEmpty(Mono.just(anonymousUser));\n \n-        return userMono.flatMap(user -> Mono.zip(\n+        return userMono.flatMap(user -> {\n+                    // if the user is anonymous, check if the feature flag\n+                    // configure_block_event_tracking_for_anonymous_users is enabled.  If yes, then do not send the\n+                    // analytics event.\n+                    if (user.isAnonymous()) {\n+                        return featureFlagService\n+                                .check(FeatureFlagEnum.configure_block_event_tracking_for_anonymous_users)\n+                                .flatMap(isDisabled -> {\n+                                    if (isDisabled) {\n+                                        log.debug(\"Analytics event {} is not sent for anonymous user\", eventTag);\n+                                        return Mono.empty();\n+                                    } else {\n+                                        return Mono.just(user);\n+                                    }\n+                                });\n+                    }\n+\n+                    return Mono.just(user);\n+                })\n+                .flatMap(user -> Mono.zip(\n                         user.isAnonymous()\n                                 ? ExchangeUtils.getAnonymousUserIdFromCurrentRequest()\n                                 : Mono.just(user.getUsername()),\n@@ -363,8 +388,10 @@ public <T> Mono<T> sendObjectEvent(AnalyticsEvents event, T object, Map<String,\n                         analyticsProperties.remove(FieldName.CLOUD_HOSTED_EXTRA_PROPS);\n                     }\n \n-                    return sendEvent(eventTag, username, analyticsProperties).thenReturn(object);\n-                });\n+                    return sendEvent(eventTag, username, analyticsProperties);\n+                })\n+                // Return the original object after sending the event\n+                .then(Mono.just(object));\n     }\n \n     /**\n",
        "pr_mirror": "appsmithorg__appsmith.7046aeb3"
    }
}