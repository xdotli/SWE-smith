{
    "cost": 0.24047000000000002,
    "rewrites": {
        "appsmithorg__appsmith.7046aeb3/app/client/src/ce/workers/Evaluation/evaluationUtils.ts": {
            "output": "import type { DependencyMap, EvaluationError } from \"utils/DynamicBindingUtils\";\nimport {\n  EVAL_ERROR_PATH,\n  isChildPropertyPath,\n  isDynamicValue,\n  PropertyEvaluationErrorType,\n  isPathDynamicTrigger,\n  isPathADynamicBinding,\n} from \"utils/DynamicBindingUtils\";\nimport type { Diff } from \"deep-diff\";\nimport type {\n  DataTreeEntity,\n  DataTree,\n  ConfigTree,\n} from \"entities/DataTree/dataTreeTypes\";\nimport { ENTITY_TYPE } from \"ee/entities/DataTree/types\";\nimport _, { difference, get, has, isEmpty, isNil, set } from \"lodash\";\nimport type { WidgetTypeConfigMap } from \"WidgetProvider/factory/types\";\nimport { PluginType } from \"entities/Plugin\";\nimport { klona } from \"klona/full\";\nimport { warn as logWarn } from \"loglevel\";\nimport type { EvalMetaUpdates } from \"ee/workers/common/DataTreeEvaluator/types\";\nimport type {\n  JSActionEntityConfig,\n  PrivateWidgets,\n  JSActionEntity,\n  ActionEntity,\n  AppsmithEntity,\n  WidgetEntity,\n  DataTreeEntityConfig,\n  WidgetEntityConfig,\n  ActionEntityConfig,\n} from \"ee/entities/DataTree/types\";\nimport type { EvalProps } from \"workers/common/DataTreeEvaluator\";\nimport { validateWidgetProperty } from \"workers/common/DataTreeEvaluator/validationUtils\";\nimport { isWidgetActionOrJsObject } from \"ee/entities/DataTree/utils\";\nimport type { Difference } from \"microdiff\";\n\n// Dropdown1.options[1].value -> Dropdown1.options[1]\n// Dropdown1.options[1] -> Dropdown1.options\n// Dropdown1.options -> Dropdown1\nexport const IMMEDIATE_PARENT_REGEX = /^(.*)(\\..*|\\[.*\\])$/;\n\nexport enum DataTreeDiffEvent {\n  NEW = \"NEW\",\n  DELETE = \"DELETE\",\n  EDIT = \"EDIT\",\n  NOOP = \"NOOP\", // No Operation (don't do anything)\n}\n\nexport interface DataTreeDiff {\n  payload: {\n    propertyPath: string;\n    value?: string;\n  };\n  event: DataTreeDiffEvent;\n}\n\nexport class CrashingError extends Error {}\n\nexport const convertPathToString = (arrPath: Array<string | number>) => {\n  let string = \"\";\n\n  arrPath.forEach((segment) => {\n    if (isInt(segment)) {\n      string = string + \"[\" + segment + \"]\";\n    } else {\n      if (string.length !== 0) {\n        string = string + \".\";\n      }\n\n      string = string + segment;\n    }\n  });\n\n  return string;\n};\n\n// Todo: improve the logic here\n// Right now NaN, Infinity, floats, everything works\nfunction isInt(val: string | number): boolean {\n  return Number.isInteger(val) || (_.isString(val) && /^\\d+$/.test(val));\n}\n\n// Removes the entity name from the property path\nexport function getEntityNameAndPropertyPath(fullPath: string): {\n  entityName: string;\n  propertyPath: string;\n} {\n  const indexOfFirstDot = fullPath.indexOf(\".\");\n\n  if (indexOfFirstDot === -1) {\n    // No dot was found so path is the entity name itself\n    return {\n      entityName: fullPath,\n      propertyPath: \"\",\n    };\n  }\n\n  const entityName = fullPath.substring(0, indexOfFirstDot);\n  const propertyPath = fullPath.substring(indexOfFirstDot + 1);\n\n  return { entityName, propertyPath };\n}\n\nexport function translateCollectionDiffs(\n  propertyPath: string,\n  data: unknown,\n  event: DataTreeDiffEvent,\n) {\n  const dataTreeDiffs: DataTreeDiff[] = [];\n\n  if (Array.isArray(data)) {\n    data.forEach((diff, idx) => {\n      dataTreeDiffs.push({\n        event,\n        payload: {\n          propertyPath: `${propertyPath}[${idx}]`,\n        },\n      });\n    });\n  } else if (isTrueObject(data)) {\n    Object.keys(data).forEach((diffKey) => {\n      const path = `${propertyPath}.${diffKey}`;\n\n      dataTreeDiffs.push({\n        event,\n        payload: {\n          propertyPath: path,\n        },\n      });\n    });\n  }\n\n  return dataTreeDiffs;\n}\n\n//these paths are not required to go through evaluate tree as these are internal properties\nconst ignorePathsForEvalRegex =\n  \".(reactivePaths|bindingPaths|triggerPaths|validationPaths|dynamicBindingPathList)\";\n\n//match if paths are part of ignorePathsForEvalRegex\nconst isUninterestingChangeForDependencyUpdate = (path: string) => {\n  return path.match(ignorePathsForEvalRegex);\n};\n\nexport const translateDiffEventToDataTreeDiffEvent = (\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  difference: Diff<any, any>,\n  unEvalDataTree: DataTree,\n): DataTreeDiff | DataTreeDiff[] => {\n  let result: DataTreeDiff | DataTreeDiff[] = {\n    payload: {\n      propertyPath: \"\",\n      value: \"\",\n    },\n    event: DataTreeDiffEvent.NOOP,\n  };\n\n  if (!difference.path) {\n    return result;\n  }\n\n  const propertyPath = convertPathToString(difference.path);\n\n  // add propertyPath to NOOP event\n  result.payload = {\n    propertyPath,\n    value: \"\",\n  };\n\n  //we do not need evaluate these paths because these are internal paths\n  const isUninterestingPathForUpdateTree =\n    isUninterestingChangeForDependencyUpdate(propertyPath);\n\n  if (!!isUninterestingPathForUpdateTree) {\n    return result;\n  }\n\n  const { entityName } = getEntityNameAndPropertyPath(propertyPath);\n  const entity = unEvalDataTree[entityName];\n  const isJsAction = isJSAction(entity);\n\n  switch (difference.kind) {\n    case \"N\": {\n      result.event = DataTreeDiffEvent.NEW;\n      result.payload = {\n        propertyPath,\n      };\n      break;\n    }\n    case \"D\": {\n      result.event = DataTreeDiffEvent.DELETE;\n      result.payload = { propertyPath };\n      break;\n    }\n    case \"E\": {\n      const rhsChange =\n        typeof difference.rhs === \"string\" &&\n        (isDynamicValue(difference.rhs) || isJsAction);\n\n      const lhsChange =\n        typeof difference.lhs === \"string\" &&\n        (isDynamicValue(difference.lhs) || isJsAction);\n\n      if (rhsChange || lhsChange) {\n        result = [\n          {\n            event:\n              difference.lhs === undefined\n                ? DataTreeDiffEvent.NEW\n                : DataTreeDiffEvent.EDIT,\n            payload: {\n              propertyPath,\n              value: difference.rhs,\n            },\n          },\n        ];\n        /**\n         * If lhs is an array/object\n         * Add delete events for all memberExpressions\n         */\n\n        const dataTreeDeleteDiffs = translateCollectionDiffs(\n          propertyPath,\n          difference.lhs,\n          DataTreeDiffEvent.DELETE,\n        );\n\n        result = result.concat(dataTreeDeleteDiffs);\n      } else if (difference.lhs === undefined || difference.rhs === undefined) {\n        // Handle static value changes that change structure that can lead to\n        // old bindings being eligible\n        if (difference.lhs === undefined && !isNil(difference.rhs)) {\n          result.event = DataTreeDiffEvent.NEW;\n          result.payload = { propertyPath };\n        }\n\n        if (difference.rhs === undefined && !isNil(difference.lhs)) {\n          result = [\n            {\n              event: DataTreeDiffEvent.EDIT,\n              payload: {\n                propertyPath,\n                value: difference.rhs,\n              },\n            },\n          ];\n\n          const dataTreeDeleteDiffs = translateCollectionDiffs(\n            propertyPath,\n            difference.lhs,\n            DataTreeDiffEvent.DELETE,\n          );\n\n          result = dataTreeDeleteDiffs.concat(result);\n        }\n      } else if (\n        isTrueObject(difference.lhs) &&\n        !isTrueObject(difference.rhs)\n      ) {\n        // This will happen for static value changes where a property went\n        // from being an object to any other type like string or number\n        // in such a case we want to delete all nested paths of the\n        // original lhs object\n\n        result = translateCollectionDiffs(\n          propertyPath,\n          difference.lhs,\n          DataTreeDiffEvent.DELETE,\n        );\n\n        // when an object is being replaced by an array\n        // list all new array accessors that are being added\n        // so dependencies will be created based on existing bindings\n        if (Array.isArray(difference.rhs)) {\n          result = result.concat(\n            translateCollectionDiffs(\n              propertyPath,\n              difference.rhs,\n              DataTreeDiffEvent.NEW,\n            ),\n          );\n        }\n      } else if (\n        !isTrueObject(difference.lhs) &&\n        isTrueObject(difference.rhs)\n      ) {\n        // This will happen for static value changes where a property went\n        // from being any other type like string or number to an object\n        // in such a case we want to add all nested paths of the\n        // new rhs object\n        result = translateCollectionDiffs(\n          propertyPath,\n          difference.rhs,\n          DataTreeDiffEvent.NEW,\n        );\n\n        // when an array is being replaced by an object\n        // remove all array accessors that are deleted\n        // so dependencies by existing bindings are removed\n        if (Array.isArray(difference.lhs)) {\n          result = result.concat(\n            translateCollectionDiffs(\n              propertyPath,\n              difference.lhs,\n              DataTreeDiffEvent.DELETE,\n            ),\n          );\n        }\n      }\n\n      break;\n    }\n    case \"A\": {\n      return translateDiffEventToDataTreeDiffEvent(\n        {\n          ...difference.item,\n          path: [...difference.path, difference.index],\n        },\n        unEvalDataTree,\n      );\n    }\n    default: {\n      break;\n    }\n  }\n\n  return result;\n};\n\nexport const translateDiffArrayIndexAccessors = (\n  propertyPath: string,\n  array: unknown[],\n  event: DataTreeDiffEvent,\n) => {\n  const result: DataTreeDiff[] = [];\n\n  array.forEach((data, index) => {\n    const path = `${propertyPath}[${index}]`;\n\n    result.push({\n      event,\n      payload: {\n        propertyPath: path,\n      },\n    });\n  });\n\n  return result;\n};\n/*\n  Table1.selectedRow\n  Table1.selectedRow.email: [\"Input1.defaultText\"]\n */\n\nexport const addDependantsOfNestedPropertyPaths = (\n  parentPaths: Array<string>,\n  inverseMap: DependencyMap,\n): Set<string> => {\n  const withNestedPaths: Set<string> = new Set(parentPaths);\n  const dependantNodes = Object.keys(inverseMap);\n\n  parentPaths.forEach((propertyPath) => {\n    dependantNodes\n      .filter((dependantNodePath) =>\n        isChildPropertyPath(propertyPath, dependantNodePath),\n      )\n      .forEach((dependantNodePath) => {\n        inverseMap[dependantNodePath].forEach((path) => {\n          withNestedPaths.add(path);\n        });\n      });\n  });\n\n  return withNestedPaths;\n};\n\nexport function isWidget(\n  entity: Partial<DataTreeEntity> | DataTreeEntityConfig,\n): entity is WidgetEntity | WidgetEntityConfig {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.WIDGET\n  );\n}\n\nexport const shouldSuppressAutoComplete = (widget: WidgetEntity) =>\n  Boolean(widget.suppressAutoComplete);\n\nexport const shouldSuppressDebuggerError = (widget: WidgetEntity) =>\n  Boolean(widget.suppressDebuggerError);\n\nexport function isAction(\n  entity: Partial<DataTreeEntity>,\n): entity is ActionEntity {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.ACTION\n  );\n}\n\nexport function isActionConfig(\n  entity: DataTreeEntityConfig,\n): entity is ActionEntityConfig {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.ACTION\n  );\n}\n\nexport function isAppsmithEntity(\n  entity: DataTreeEntity,\n): entity is AppsmithEntity {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.APPSMITH\n  );\n}\n\nexport function isJSAction(entity: DataTreeEntity): entity is JSActionEntity {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.JSACTION\n  );\n}\n/**\n *\n * isAnyJSAction checks if the entity is a JSAction ( or a JSModuleInstance on EE )\n */\nexport function isAnyJSAction(entity: DataTreeEntity) {\n  return isJSAction(entity);\n}\n\nexport function isJSActionConfig(\n  entity: DataTreeEntityConfig,\n): entity is JSActionEntityConfig {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.JSACTION\n  );\n}\n\nexport function isJSObject(entity: DataTreeEntity): entity is JSActionEntity {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.JSACTION &&\n    \"pluginType\" in entity &&\n    entity.pluginType === PluginType.JS\n  );\n}\n\nexport function isDataTreeEntity(entity: unknown) {\n  return !!entity && typeof entity === \"object\" && \"ENTITY_TYPE\" in entity;\n}\n\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const serialiseToBigInt = (value: any) =>\n  JSON.stringify(value, (_, v) => (typeof v === \"bigint\" ? v.toString() : v));\n\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const removeFunctionsAndSerialzeBigInt = (value: any) =>\n  JSON.parse(serialiseToBigInt(value));\n// We need to remove functions from data tree to avoid any unexpected identifier while JSON parsing\n// Check issue https://github.com/appsmithorg/appsmith/issues/719\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const removeFunctions = (value: any) => {\n  if (_.isFunction(value)) {\n    return \"Function call\";\n  } else if (_.isObject(value)) {\n    return removeFunctionsAndSerialzeBigInt(value);\n  } else {\n    return value;\n  }\n};\n\nexport const makeParentsDependOnChildren = (\n  depMap: DependencyMap,\n  allkeys: Record<string, true>,\n): DependencyMap => {\n  //",
            "output_extracted": "import type { DependencyMap, EvaluationError } from \"utils/DynamicBindingUtils\";\nimport {\n  EVAL_ERROR_PATH,\n  isChildPropertyPath,\n  isDynamicValue,\n  PropertyEvaluationErrorType,\n  isPathDynamicTrigger,\n  isPathADynamicBinding,\n} from \"utils/DynamicBindingUtils\";\nimport type { Diff } from \"deep-diff\";\nimport type {\n  DataTreeEntity,\n  DataTree,\n  ConfigTree,\n} from \"entities/DataTree/dataTreeTypes\";\nimport { ENTITY_TYPE } from \"ee/entities/DataTree/types\";\nimport _, { difference, get, has, isEmpty, isNil, set } from \"lodash\";\nimport type { WidgetTypeConfigMap } from \"WidgetProvider/factory/types\";\nimport { PluginType } from \"entities/Plugin\";\nimport { klona } from \"klona/full\";\nimport { warn as logWarn } from \"loglevel\";\nimport type { EvalMetaUpdates } from \"ee/workers/common/DataTreeEvaluator/types\";\nimport type {\n  JSActionEntityConfig,\n  PrivateWidgets,\n  JSActionEntity,\n  ActionEntity,\n  AppsmithEntity,\n  WidgetEntity,\n  DataTreeEntityConfig,\n  WidgetEntityConfig,\n  ActionEntityConfig,\n} from \"ee/entities/DataTree/types\";\nimport type { EvalProps } from \"workers/common/DataTreeEvaluator\";\nimport { validateWidgetProperty } from \"workers/common/DataTreeEvaluator/validationUtils\";\nimport { isWidgetActionOrJsObject } from \"ee/entities/DataTree/utils\";\nimport type { Difference } from \"microdiff\";\n\n// Dropdown1.options[1].value -> Dropdown1.options[1]\n// Dropdown1.options[1] -> Dropdown1.options\n// Dropdown1.options -> Dropdown1\nexport const IMMEDIATE_PARENT_REGEX = /^(.*)(\\..*|\\[.*\\])$/;\n\nexport enum DataTreeDiffEvent {\n  NEW = \"NEW\",\n  DELETE = \"DELETE\",\n  EDIT = \"EDIT\",\n  NOOP = \"NOOP\", // No Operation (don't do anything)\n}\n\nexport interface DataTreeDiff {\n  payload: {\n    propertyPath: string;\n    value?: string;\n  };\n  event: DataTreeDiffEvent;\n}\n\nexport class CrashingError extends Error {}\n\nexport const convertPathToString = (arrPath: Array<string | number>) => {\n  let string = \"\";\n\n  arrPath.forEach((segment) => {\n    if (isInt(segment)) {\n      string = string + \"[\" + segment + \"]\";\n    } else {\n      if (string.length !== 0) {\n        string = string + \".\";\n      }\n\n      string = string + segment;\n    }\n  });\n\n  return string;\n};\n\n// Todo: improve the logic here\n// Right now NaN, Infinity, floats, everything works\nfunction isInt(val: string | number): boolean {\n  return Number.isInteger(val) || (_.isString(val) && /^\\d+$/.test(val));\n}\n\n// Removes the entity name from the property path\nexport function getEntityNameAndPropertyPath(fullPath: string): {\n  entityName: string;\n  propertyPath: string;\n} {\n  const indexOfFirstDot = fullPath.indexOf(\".\");\n\n  if (indexOfFirstDot === -1) {\n    // No dot was found so path is the entity name itself\n    return {\n      entityName: fullPath,\n      propertyPath: \"\",\n    };\n  }\n\n  const entityName = fullPath.substring(0, indexOfFirstDot);\n  const propertyPath = fullPath.substring(indexOfFirstDot + 1);\n\n  return { entityName, propertyPath };\n}\n\nexport function translateCollectionDiffs(\n  propertyPath: string,\n  data: unknown,\n  event: DataTreeDiffEvent,\n) {\n  const dataTreeDiffs: DataTreeDiff[] = [];\n\n  if (Array.isArray(data)) {\n    data.forEach((diff, idx) => {\n      dataTreeDiffs.push({\n        event,\n        payload: {\n          propertyPath: `${propertyPath}[${idx}]`,\n        },\n      });\n    });\n  } else if (isTrueObject(data)) {\n    Object.keys(data).forEach((diffKey) => {\n      const path = `${propertyPath}.${diffKey}`;\n\n      dataTreeDiffs.push({\n        event,\n        payload: {\n          propertyPath: path,\n        },\n      });\n    });\n  }\n\n  return dataTreeDiffs;\n}\n\n//these paths are not required to go through evaluate tree as these are internal properties\nconst ignorePathsForEvalRegex =\n  \".(reactivePaths|bindingPaths|triggerPaths|validationPaths|dynamicBindingPathList)\";\n\n//match if paths are part of ignorePathsForEvalRegex\nconst isUninterestingChangeForDependencyUpdate = (path: string) => {\n  return path.match(ignorePathsForEvalRegex);\n};\n\nexport const translateDiffEventToDataTreeDiffEvent = (\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  difference: Diff<any, any>,\n  unEvalDataTree: DataTree,\n): DataTreeDiff | DataTreeDiff[] => {\n  let result: DataTreeDiff | DataTreeDiff[] = {\n    payload: {\n      propertyPath: \"\",\n      value: \"\",\n    },\n    event: DataTreeDiffEvent.NOOP,\n  };\n\n  if (!difference.path) {\n    return result;\n  }\n\n  const propertyPath = convertPathToString(difference.path);\n\n  // add propertyPath to NOOP event\n  result.payload = {\n    propertyPath,\n    value: \"\",\n  };\n\n  //we do not need evaluate these paths because these are internal paths\n  const isUninterestingPathForUpdateTree =\n    isUninterestingChangeForDependencyUpdate(propertyPath);\n\n  if (!!isUninterestingPathForUpdateTree) {\n    return result;\n  }\n\n  const { entityName } = getEntityNameAndPropertyPath(propertyPath);\n  const entity = unEvalDataTree[entityName];\n  const isJsAction = isJSAction(entity);\n\n  switch (difference.kind) {\n    case \"N\": {\n      result.event = DataTreeDiffEvent.NEW;\n      result.payload = {\n        propertyPath,\n      };\n      break;\n    }\n    case \"D\": {\n      result.event = DataTreeDiffEvent.DELETE;\n      result.payload = { propertyPath };\n      break;\n    }\n    case \"E\": {\n      const rhsChange =\n        typeof difference.rhs === \"string\" &&\n        (isDynamicValue(difference.rhs) || isJsAction);\n\n      const lhsChange =\n        typeof difference.lhs === \"string\" &&\n        (isDynamicValue(difference.lhs) || isJsAction);\n\n      if (rhsChange || lhsChange) {\n        result = [\n          {\n            event:\n              difference.lhs === undefined\n                ? DataTreeDiffEvent.NEW\n                : DataTreeDiffEvent.EDIT,\n            payload: {\n              propertyPath,\n              value: difference.rhs,\n            },\n          },\n        ];\n        /**\n         * If lhs is an array/object\n         * Add delete events for all memberExpressions\n         */\n\n        const dataTreeDeleteDiffs = translateCollectionDiffs(\n          propertyPath,\n          difference.lhs,\n          DataTreeDiffEvent.DELETE,\n        );\n\n        result = result.concat(dataTreeDeleteDiffs);\n      } else if (difference.lhs === undefined || difference.rhs === undefined) {\n        // Handle static value changes that change structure that can lead to\n        // old bindings being eligible\n        if (difference.lhs === undefined && !isNil(difference.rhs)) {\n          result.event = DataTreeDiffEvent.NEW;\n          result.payload = { propertyPath };\n        }\n\n        if (difference.rhs === undefined && !isNil(difference.lhs)) {\n          result = [\n            {\n              event: DataTreeDiffEvent.EDIT,\n              payload: {\n                propertyPath,\n                value: difference.rhs,\n              },\n            },\n          ];\n\n          const dataTreeDeleteDiffs = translateCollectionDiffs(\n            propertyPath,\n            difference.lhs,\n            DataTreeDiffEvent.DELETE,\n          );\n\n          result = dataTreeDeleteDiffs.concat(result);\n        }\n      } else if (\n        isTrueObject(difference.lhs) &&\n        !isTrueObject(difference.rhs)\n      ) {\n        // This will happen for static value changes where a property went\n        // from being an object to any other type like string or number\n        // in such a case we want to delete all nested paths of the\n        // original lhs object\n\n        result = translateCollectionDiffs(\n          propertyPath,\n          difference.lhs,\n          DataTreeDiffEvent.DELETE,\n        );\n\n        // when an object is being replaced by an array\n        // list all new array accessors that are being added\n        // so dependencies will be created based on existing bindings\n        if (Array.isArray(difference.rhs)) {\n          result = result.concat(\n            translateCollectionDiffs(\n              propertyPath,\n              difference.rhs,\n              DataTreeDiffEvent.NEW,\n            ),\n          );\n        }\n      } else if (\n        !isTrueObject(difference.lhs) &&\n        isTrueObject(difference.rhs)\n      ) {\n        // This will happen for static value changes where a property went\n        // from being any other type like string or number to an object\n        // in such a case we want to add all nested paths of the\n        // new rhs object\n        result = translateCollectionDiffs(\n          propertyPath,\n          difference.rhs,\n          DataTreeDiffEvent.NEW,\n        );\n\n        // when an array is being replaced by an object\n        // remove all array accessors that are deleted\n        // so dependencies by existing bindings are removed\n        if (Array.isArray(difference.lhs)) {\n          result = result.concat(\n            translateCollectionDiffs(\n              propertyPath,\n              difference.lhs,\n              DataTreeDiffEvent.DELETE,\n            ),\n          );\n        }\n      }\n\n      break;\n    }\n    case \"A\": {\n      return translateDiffEventToDataTreeDiffEvent(\n        {\n          ...difference.item,\n          path: [...difference.path, difference.index],\n        },\n        unEvalDataTree,\n      );\n    }\n    default: {\n      break;\n    }\n  }\n\n  return result;\n};\n\nexport const translateDiffArrayIndexAccessors = (\n  propertyPath: string,\n  array: unknown[],\n  event: DataTreeDiffEvent,\n) => {\n  const result: DataTreeDiff[] = [];\n\n  array.forEach((data, index) => {\n    const path = `${propertyPath}[${index}]`;\n\n    result.push({\n      event,\n      payload: {\n        propertyPath: path,\n      },\n    });\n  });\n\n  return result;\n};\n/*\n  Table1.selectedRow\n  Table1.selectedRow.email: [\"Input1.defaultText\"]\n */\n\nexport const addDependantsOfNestedPropertyPaths = (\n  parentPaths: Array<string>,\n  inverseMap: DependencyMap,\n): Set<string> => {\n  const withNestedPaths: Set<string> = new Set(parentPaths);\n  const dependantNodes = Object.keys(inverseMap);\n\n  parentPaths.forEach((propertyPath) => {\n    dependantNodes\n      .filter((dependantNodePath) =>\n        isChildPropertyPath(propertyPath, dependantNodePath),\n      )\n      .forEach((dependantNodePath) => {\n        inverseMap[dependantNodePath].forEach((path) => {\n          withNestedPaths.add(path);\n        });\n      });\n  });\n\n  return withNestedPaths;\n};\n\nexport function isWidget(\n  entity: Partial<DataTreeEntity> | DataTreeEntityConfig,\n): entity is WidgetEntity | WidgetEntityConfig {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.WIDGET\n  );\n}\n\nexport const shouldSuppressAutoComplete = (widget: WidgetEntity) =>\n  Boolean(widget.suppressAutoComplete);\n\nexport const shouldSuppressDebuggerError = (widget: WidgetEntity) =>\n  Boolean(widget.suppressDebuggerError);\n\nexport function isAction(\n  entity: Partial<DataTreeEntity>,\n): entity is ActionEntity {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.ACTION\n  );\n}\n\nexport function isActionConfig(\n  entity: DataTreeEntityConfig,\n): entity is ActionEntityConfig {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.ACTION\n  );\n}\n\nexport function isAppsmithEntity(\n  entity: DataTreeEntity,\n): entity is AppsmithEntity {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.APPSMITH\n  );\n}\n\nexport function isJSAction(entity: DataTreeEntity): entity is JSActionEntity {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.JSACTION\n  );\n}\n/**\n *\n * isAnyJSAction checks if the entity is a JSAction ( or a JSModuleInstance on EE )\n */\nexport function isAnyJSAction(entity: DataTreeEntity) {\n  return isJSAction(entity);\n}\n\nexport function isJSActionConfig(\n  entity: DataTreeEntityConfig,\n): entity is JSActionEntityConfig {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.JSACTION\n  );\n}\n\nexport function isJSObject(entity: DataTreeEntity): entity is JSActionEntity {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.JSACTION &&\n    \"pluginType\" in entity &&\n    entity.pluginType === PluginType.JS\n  );\n}\n\nexport function isDataTreeEntity(entity: unknown) {\n  return !!entity && typeof entity === \"object\" && \"ENTITY_TYPE\" in entity;\n}\n\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const serialiseToBigInt = (value: any) =>\n  JSON.stringify(value, (_, v) => (typeof v === \"bigint\" ? v.toString() : v));\n\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const removeFunctionsAndSerialzeBigInt = (value: any) =>\n  JSON.parse(serialiseToBigInt(value));\n// We need to remove functions from data tree to avoid any unexpected identifier while JSON parsing\n// Check issue https://github.com/appsmithorg/appsmith/issues/719\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const removeFunctions = (value: any) => {\n  if (_.isFunction(value)) {\n    return \"Function call\";\n  } else if (_.isObject(value)) {\n    return removeFunctionsAndSerialzeBigInt(value);\n  } else {\n    return value;\n  }\n};\n\nexport const makeParentsDependOnChildren = (\n  depMap: DependencyMap,\n  allkeys: Record<string, true>,\n): DependencyMap => {\n  //",
            "cost": 0.15889
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/entities/DependencyMap/DependencyMapUtils.ts": {
            "output": "import toposort from \"toposort\";\nimport type DependencyMap from \".\";\nimport {\n  entityTypeCheckForPathDynamicTrigger,\n  getEntityNameAndPropertyPath,\n  IMMEDIATE_PARENT_REGEX,\n} from \"ee/workers/Evaluation/evaluationUtils\";\nimport type { ConfigTree } from \"entities/DataTree/dataTreeTypes\";\nimport { isPathDynamicTrigger } from \"utils/DynamicBindingUtils\";\n\ntype SortDependencies =\n  | {\n      success: true;\n      sortedDependencies: string[];\n    }\n  | { success: false; cyclicNode: string; error: unknown };\n\nexport class DependencyMapUtils {\n  // inspired by https://www.npmjs.com/package/toposort#sorting-dependencies\n  static sortDependencies(\n    dependencyMap: DependencyMap,\n    configTree?: ConfigTree,\n  ): SortDependencies {\n    const dependencyTree: Array<[string, string | undefined]> = [];\n    const dependencies = dependencyMap.rawDependencies;\n\n    for (const [node, deps] of dependencies.entries()) {\n      if (deps.size) {\n        deps.forEach((dep) => dependencyTree.push([node, dep]));\n      } else {\n        // Set no dependency\n        dependencyTree.push([node, undefined]);\n      }\n    }\n\n    try {\n      const sortedDependencies = toposort(dependencyTree)\n        .reverse()\n        .filter((edge) => !!edge);\n\n      if (configTree) {\n        this.detectReactiveDependencyMisuse(dependencyMap, configTree);\n      }\n\n      return { success: true, sortedDependencies };\n    } catch (error) {\n      // Cyclic dependency found. Extract node\n      const cyclicNodes = (error as Error).message.match(\n        new RegExp('Cyclic dependency, node was:\"(.*)\"'),\n      );\n      const node = cyclicNodes ? cyclicNodes[1] : \"\";\n\n      return { success: false, cyclicNode: node, error };\n    }\n  }\n  // this function links childNode to its parent as a dependency for the entire dependencyGraph\n  static makeParentsDependOnChildren(dependencyMap: DependencyMap) {\n    const dependencies = dependencyMap.rawDependencies;\n\n    for (const [node, deps] of dependencies.entries()) {\n      this.makeParentsDependOnChild(dependencyMap, node);\n      deps.forEach((dep) => {\n        this.makeParentsDependOnChild(dependencyMap, dep);\n      });\n    }\n\n    return dependencyMap;\n  }\n\n  // this function links childNode to its parent as a dependency for only affectedNodes in the graph\n  static linkAffectedChildNodesToParent(\n    dependencyMap: DependencyMap,\n    affectedSet: Set<string>,\n  ) {\n    const dependencies = dependencyMap.rawDependencies;\n\n    // We don't want to process the same node multiple times\n    // STEP 1: Collect all unique nodes that need processing\n    const nodesToProcess = new Set<string>();\n\n    for (const [node, deps] of dependencies.entries()) {\n      if (affectedSet.has(node)) {\n        nodesToProcess.add(node); // Just add to set, don't call function yet\n      }\n\n      for (const dep of deps) {\n        if (affectedSet.has(dep)) {\n          nodesToProcess.add(dep); // Just add to set, don't call function yet\n        }\n      }\n    }\n\n    // STEP 2: Process each unique node exactly once\n    for (const nodeToProcess of nodesToProcess) {\n      DependencyMapUtils.makeParentsDependOnChild(dependencyMap, nodeToProcess);\n    }\n  }\n\n  static makeParentsDependOnChild = (\n    dependencyMap: DependencyMap,\n    child: string,\n  ) => {\n    // Skip adding dependencies for paths containing .data\n    if (child.includes(\".data\")) {\n      return;\n    }\n\n    let curKey = child;\n    let matches: string[] | null;\n\n    while ((matches = curKey.match(IMMEDIATE_PARENT_REGEX)) !== null) {\n      const immediateParent = matches[1];\n      const existingImmediateParentDeps =\n        dependencyMap.getDirectDependencies(immediateParent) || [];\n      const existingImmediateParentDepsSet = new Set(\n        existingImmediateParentDeps,\n      );\n\n      // Add child to immediate parent's dependencies if not already present\n      // don't perform addDependency unnecessarily\n      if (!existingImmediateParentDepsSet.has(curKey)) {\n        existingImmediateParentDeps.push(curKey);\n        dependencyMap.addDependency(\n          immediateParent,\n          existingImmediateParentDeps,\n        );\n      }\n\n      curKey = immediateParent;\n    }\n  };\n\n  static isTriggerPath(path: string, configTree: ConfigTree) {\n    const { entityName, propertyPath } = getEntityNameAndPropertyPath(path);\n    const entityConfig = configTree[entityName];\n\n    if (!entityConfig) {\n      return false;\n    }\n\n    if (entityTypeCheckForPathDynamicTrigger(entityConfig)) {\n      return isPathDynamicTrigger(entityConfig, propertyPath);\n    }\n\n    return false;\n  }\n\n  static isDataPath(path: string) {\n    return path.endsWith(\".data\");\n  }\n\n  static detectReactiveDependencyMisuse(\n    dependencyMap: DependencyMap,\n    configTree: ConfigTree,\n  ) {\n    const dependencies = dependencyMap.rawDependencies;\n\n    // Helper function to get all transitive dependencies\n    const getAllTransitiveDependencies = (node: string): Set<string> => {\n      const allDeps = new Set<string>();\n      const queue = [node];\n\n      while (queue.length > 0) {\n        const current = queue.shift()!;\n        const deps = dependencyMap.getDirectDependencies(current) || [];\n\n        for (const dep of deps) {\n          if (!allDeps.has(dep)) {\n            allDeps.add(dep);\n            queue.push(dep);\n          }\n        }\n      }\n\n      return allDeps;\n    };\n\n    for (const [node, deps] of dependencies.entries()) {\n      // Get all dependencies including transitive ones\n      const allDeps = new Set<string>();\n      const queue = Array.from(deps);\n\n      while (queue.length > 0) {\n        const dep = queue.shift()!;\n\n        if (!allDeps.has(dep)) {\n          allDeps.add(dep);\n          const depDeps = dependencyMap.getDirectDependencies(dep) || [];\n\n          queue.push(...depDeps);\n        }\n      }\n\n      // Separate dependencies into trigger paths and data paths\n      const triggerPaths = Array.from(deps).filter((dep) =>\n        this.isTriggerPath(dep, configTree),\n      );\n      const dataPaths = Array.from(deps).filter((dep) => this.isDataPath(dep));\n\n      // For each trigger path, check if there's a data path from the same entity\n      for (const triggerPath of triggerPaths) {\n        const triggerEntity = triggerPath.split(\".\")[0];\n\n        // Find data paths from the same entity\n        const sameEntityDataPaths = dataPaths.filter((dataPath) => {\n          const dataEntity = dataPath.split(\".\")[0];\n\n          return dataEntity === triggerEntity;\n        });\n\n        if (sameEntityDataPaths.length > 0) {\n          // Check if any of these data paths depend on the trigger path (directly or indirectly)\n          for (const dataPath of sameEntityDataPaths) {\n            const dataPathTransitiveDeps =\n              getAllTransitiveDependencies(dataPath);\n\n            if (dataPathTransitiveDeps.has(triggerPath)) {\n              const error = new Error(\n                `Reactive dependency misuse: '${node}' depends on both trigger path '${triggerPath}' and data path '${dataPath}' from the same entity, and '${dataPath}' depends on '${triggerPath}' (directly or indirectly). This can cause unexpected reactivity.`,\n              );\n\n              // Add custom properties\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (error as any).node = node;\n\n              throw error;\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "output_extracted": "import toposort from \"toposort\";\nimport type DependencyMap from \".\";\nimport {\n  entityTypeCheckForPathDynamicTrigger,\n  getEntityNameAndPropertyPath,\n  IMMEDIATE_PARENT_REGEX,\n} from \"ee/workers/Evaluation/evaluationUtils\";\nimport type { ConfigTree } from \"entities/DataTree/dataTreeTypes\";\nimport { isPathDynamicTrigger } from \"utils/DynamicBindingUtils\";\n\ntype SortDependencies =\n  | {\n      success: true;\n      sortedDependencies: string[];\n    }\n  | { success: false; cyclicNode: string; error: unknown };\n\nexport class DependencyMapUtils {\n  // inspired by https://www.npmjs.com/package/toposort#sorting-dependencies\n  static sortDependencies(\n    dependencyMap: DependencyMap,\n    configTree?: ConfigTree,\n  ): SortDependencies {\n    const dependencyTree: Array<[string, string | undefined]> = [];\n    const dependencies = dependencyMap.rawDependencies;\n\n    for (const [node, deps] of dependencies.entries()) {\n      if (deps.size) {\n        deps.forEach((dep) => dependencyTree.push([node, dep]));\n      } else {\n        // Set no dependency\n        dependencyTree.push([node, undefined]);\n      }\n    }\n\n    try {\n      const sortedDependencies = toposort(dependencyTree)\n        .reverse()\n        .filter((edge) => !!edge);\n\n      if (configTree) {\n        this.detectReactiveDependencyMisuse(dependencyMap, configTree);\n      }\n\n      return { success: true, sortedDependencies };\n    } catch (error) {\n      // Cyclic dependency found. Extract node\n      const cyclicNodes = (error as Error).message.match(\n        new RegExp('Cyclic dependency, node was:\"(.*)\"'),\n      );\n      const node = cyclicNodes ? cyclicNodes[1] : \"\";\n\n      return { success: false, cyclicNode: node, error };\n    }\n  }\n  // this function links childNode to its parent as a dependency for the entire dependencyGraph\n  static makeParentsDependOnChildren(dependencyMap: DependencyMap) {\n    const dependencies = dependencyMap.rawDependencies;\n\n    for (const [node, deps] of dependencies.entries()) {\n      this.makeParentsDependOnChild(dependencyMap, node);\n      deps.forEach((dep) => {\n        this.makeParentsDependOnChild(dependencyMap, dep);\n      });\n    }\n\n    return dependencyMap;\n  }\n\n  // this function links childNode to its parent as a dependency for only affectedNodes in the graph\n  static linkAffectedChildNodesToParent(\n    dependencyMap: DependencyMap,\n    affectedSet: Set<string>,\n  ) {\n    const dependencies = dependencyMap.rawDependencies;\n\n    // We don't want to process the same node multiple times\n    // STEP 1: Collect all unique nodes that need processing\n    const nodesToProcess = new Set<string>();\n\n    for (const [node, deps] of dependencies.entries()) {\n      if (affectedSet.has(node)) {\n        nodesToProcess.add(node); // Just add to set, don't call function yet\n      }\n\n      for (const dep of deps) {\n        if (affectedSet.has(dep)) {\n          nodesToProcess.add(dep); // Just add to set, don't call function yet\n        }\n      }\n    }\n\n    // STEP 2: Process each unique node exactly once\n    for (const nodeToProcess of nodesToProcess) {\n      DependencyMapUtils.makeParentsDependOnChild(dependencyMap, nodeToProcess);\n    }\n  }\n\n  static makeParentsDependOnChild = (\n    dependencyMap: DependencyMap,\n    child: string,\n  ) => {\n    // Skip adding dependencies for paths containing .data\n    if (child.includes(\".data\")) {\n      return;\n    }\n\n    let curKey = child;\n    let matches: string[] | null;\n\n    while ((matches = curKey.match(IMMEDIATE_PARENT_REGEX)) !== null) {\n      const immediateParent = matches[1];\n      const existingImmediateParentDeps =\n        dependencyMap.getDirectDependencies(immediateParent) || [];\n      const existingImmediateParentDepsSet = new Set(\n        existingImmediateParentDeps,\n      );\n\n      // Add child to immediate parent's dependencies if not already present\n      // don't perform addDependency unnecessarily\n      if (!existingImmediateParentDepsSet.has(curKey)) {\n        existingImmediateParentDeps.push(curKey);\n        dependencyMap.addDependency(\n          immediateParent,\n          existingImmediateParentDeps,\n        );\n      }\n\n      curKey = immediateParent;\n    }\n  };\n\n  static isTriggerPath(path: string, configTree: ConfigTree) {\n    const { entityName, propertyPath } = getEntityNameAndPropertyPath(path);\n    const entityConfig = configTree[entityName];\n\n    if (!entityConfig) {\n      return false;\n    }\n\n    if (entityTypeCheckForPathDynamicTrigger(entityConfig)) {\n      return isPathDynamicTrigger(entityConfig, propertyPath);\n    }\n\n    return false;\n  }\n\n  static isDataPath(path: string) {\n    return path.endsWith(\".data\");\n  }\n\n  static detectReactiveDependencyMisuse(\n    dependencyMap: DependencyMap,\n    configTree: ConfigTree,\n  ) {\n    const dependencies = dependencyMap.rawDependencies;\n\n    // Helper function to get all transitive dependencies\n    const getAllTransitiveDependencies = (node: string): Set<string> => {\n      const allDeps = new Set<string>();\n      const queue = [node];\n\n      while (queue.length > 0) {\n        const current = queue.shift()!;\n        const deps = dependencyMap.getDirectDependencies(current) || [];\n\n        for (const dep of deps) {\n          if (!allDeps.has(dep)) {\n            allDeps.add(dep);\n            queue.push(dep);\n          }\n        }\n      }\n\n      return allDeps;\n    };\n\n    for (const [node, deps] of dependencies.entries()) {\n      // Get all dependencies including transitive ones\n      const allDeps = new Set<string>();\n      const queue = Array.from(deps);\n\n      while (queue.length > 0) {\n        const dep = queue.shift()!;\n\n        if (!allDeps.has(dep)) {\n          allDeps.add(dep);\n          const depDeps = dependencyMap.getDirectDependencies(dep) || [];\n\n          queue.push(...depDeps);\n        }\n      }\n\n      // Separate dependencies into trigger paths and data paths\n      const triggerPaths = Array.from(deps).filter((dep) =>\n        this.isTriggerPath(dep, configTree),\n      );\n      const dataPaths = Array.from(deps).filter((dep) => this.isDataPath(dep));\n\n      // For each trigger path, check if there's a data path from the same entity\n      for (const triggerPath of triggerPaths) {\n        const triggerEntity = triggerPath.split(\".\")[0];\n\n        // Find data paths from the same entity\n        const sameEntityDataPaths = dataPaths.filter((dataPath) => {\n          const dataEntity = dataPath.split(\".\")[0];\n\n          return dataEntity === triggerEntity;\n        });\n\n        if (sameEntityDataPaths.length > 0) {\n          // Check if any of these data paths depend on the trigger path (directly or indirectly)\n          for (const dataPath of sameEntityDataPaths) {\n            const dataPathTransitiveDeps =\n              getAllTransitiveDependencies(dataPath);\n\n            if (dataPathTransitiveDeps.has(triggerPath)) {\n              const error = new Error(\n                `Reactive dependency misuse: '${node}' depends on both trigger path '${triggerPath}' and data path '${dataPath}' from the same entity, and '${dataPath}' depends on '${triggerPath}' (directly or indirectly). This can cause unexpected reactivity.`,\n              );\n\n              // Add custom properties\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (error as any).node = node;\n\n              throw error;\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "cost": 0.08158
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "appsmithorg__appsmith.main.41049",
        "repo": "appsmithorg/appsmith",
        "base_commit": "7bcd86d87f161926ac10547fbaec993d8ae9355a",
        "head_commit": "05c9f6481e464dc802b2b556a0eba48c66cc3030",
        "title": "fix: Updating the function definition for checking reactive cyclic dependencies",
        "merged_at": "2025-06-27T11:16:45Z",
        "html_url": "https://github.com/appsmithorg/appsmith/pull/41049",
        "test_files": [
            "app/client/src/entities/DependencyMap/__tests__/DependencyMapUtils.test.ts"
        ],
        "code_files": [
            "app/client/src/ce/workers/Evaluation/evaluationUtils.ts",
            "app/client/src/entities/DependencyMap/DependencyMapUtils.ts"
        ],
        "total_changes": 484,
        "num_files": 3,
        "pull_number": 41049,
        "patch": "diff --git a/app/client/src/ce/workers/Evaluation/evaluationUtils.ts b/app/client/src/ce/workers/Evaluation/evaluationUtils.ts\nindex 293fe0a221a..443fbb318c0 100644\n--- a/app/client/src/ce/workers/Evaluation/evaluationUtils.ts\n+++ b/app/client/src/ce/workers/Evaluation/evaluationUtils.ts\n@@ -413,7 +413,9 @@ export function isAppsmithEntity(\n   );\n }\n \n-export function isJSAction(entity: DataTreeEntity): entity is JSActionEntity {\n+export function isJSAction(\n+  entity: Partial<DataTreeEntity>,\n+): entity is JSActionEntity {\n   return (\n     typeof entity === \"object\" &&\n     \"ENTITY_TYPE\" in entity &&\ndiff --git a/app/client/src/entities/DependencyMap/DependencyMapUtils.ts b/app/client/src/entities/DependencyMap/DependencyMapUtils.ts\nindex 9e4cb175ad7..933343f9e24 100644\n--- a/app/client/src/entities/DependencyMap/DependencyMapUtils.ts\n+++ b/app/client/src/entities/DependencyMap/DependencyMapUtils.ts\n@@ -4,9 +4,13 @@ import {\n   entityTypeCheckForPathDynamicTrigger,\n   getEntityNameAndPropertyPath,\n   IMMEDIATE_PARENT_REGEX,\n+  isAction,\n+  isJSAction,\n } from \"ee/workers/Evaluation/evaluationUtils\";\n import type { ConfigTree } from \"entities/DataTree/dataTreeTypes\";\n import { isPathDynamicTrigger } from \"utils/DynamicBindingUtils\";\n+import { WorkerEnv } from \"workers/Evaluation/handlers/workerEnv\";\n+import { ActionRunBehaviour } from \"PluginActionEditor/types/PluginActionTypes\";\n \n type SortDependencies =\n   | {\n@@ -23,6 +27,9 @@ export class DependencyMapUtils {\n   ): SortDependencies {\n     const dependencyTree: Array<[string, string | undefined]> = [];\n     const dependencies = dependencyMap.rawDependencies;\n+    const featureFlags = WorkerEnv.getFeatureFlags();\n+    const isReactiveActionsEnabled =\n+      featureFlags.release_reactive_actions_enabled;\n \n     for (const [node, deps] of dependencies.entries()) {\n       if (deps.size) {\n@@ -38,7 +45,7 @@ export class DependencyMapUtils {\n         .reverse()\n         .filter((edge) => !!edge);\n \n-      if (configTree) {\n+      if (configTree && isReactiveActionsEnabled) {\n         this.detectReactiveDependencyMisuse(dependencyMap, configTree);\n       }\n \n@@ -163,81 +170,91 @@ export class DependencyMapUtils {\n   ) {\n     const dependencies = dependencyMap.rawDependencies;\n \n-    // Helper function to get all transitive dependencies\n-    const getAllTransitiveDependencies = (node: string): Set<string> => {\n-      const allDeps = new Set<string>();\n-      const queue = [node];\n+    for (const node of dependencies.keys()) {\n+      const { entityName: nodeName } = getEntityNameAndPropertyPath(node);\n+      const nodeConfig = configTree[nodeName];\n \n-      while (queue.length > 0) {\n-        const current = queue.shift()!;\n-        const deps = dependencyMap.getDirectDependencies(current) || [];\n+      const isJSActionEntity = isJSAction(nodeConfig);\n+      const isActionEntity = isAction(nodeConfig);\n \n-        for (const dep of deps) {\n-          if (!allDeps.has(dep)) {\n-            allDeps.add(dep);\n-            queue.push(dep);\n-          }\n-        }\n+      if (isJSActionEntity) {\n+        // Only continue if at least one function is automatic\n+        const hasAutomaticFunc = Object.values(nodeConfig.meta).some(\n+          (jsFunction) =>\n+            jsFunction.runBehaviour === ActionRunBehaviour.AUTOMATIC,\n+        );\n+\n+        if (!hasAutomaticFunc) continue;\n+      } else if (isActionEntity) {\n+        // Only continue if runBehaviour is AUTOMATIC\n+        if (nodeConfig.runBehaviour !== ActionRunBehaviour.AUTOMATIC) continue;\n+      } else {\n+        // If not a JSAction, or Action, skip\n+        continue;\n       }\n \n-      return allDeps;\n-    };\n+      // For each entity, check if both .run and a .data path are present\n+      let hasRun = false;\n+      let hasData = false;\n+      let dataPath = \"\";\n+      let runPath = \"\";\n \n-    for (const [node, deps] of dependencies.entries()) {\n-      // Get all dependencies including transitive ones\n-      const allDeps = new Set<string>();\n-      const queue = Array.from(deps);\n+      const transitiveDeps = this.getAllTransitiveDependencies(\n+        dependencyMap,\n+        node,\n+      );\n \n-      while (queue.length > 0) {\n-        const dep = queue.shift()!;\n+      for (const dep of transitiveDeps) {\n+        const { entityName } = getEntityNameAndPropertyPath(dep);\n+        const entityConfig = configTree[entityName];\n \n-        if (!allDeps.has(dep)) {\n-          allDeps.add(dep);\n-          const depDeps = dependencyMap.getDirectDependencies(dep) || [];\n+        if (entityConfig && entityConfig.ENTITY_TYPE === \"ACTION\") {\n+          if (this.isTriggerPath(dep, configTree)) {\n+            hasRun = true;\n+            runPath = dep;\n+          }\n \n-          queue.push(...depDeps);\n+          if (DependencyMapUtils.isDataPath(dep)) {\n+            hasData = true;\n+            dataPath = dep;\n+          }\n+\n+          if (hasRun && hasData) {\n+            throw Object.assign(\n+              new Error(\n+                `Reactive dependency misuse: '${node}' depends on both trigger path '${runPath}' and data path '${dataPath}' from the same entity. This can cause unexpected reactivity.`,\n+              ),\n+              { node, triggerPath: runPath, dataPath },\n+            );\n+          }\n         }\n       }\n+    }\n+  }\n \n-      // Separate dependencies into trigger paths and data paths\n-      const triggerPaths = Array.from(deps).filter((dep) =>\n-        this.isTriggerPath(dep, configTree),\n-      );\n-      const dataPaths = Array.from(deps).filter((dep) => this.isDataPath(dep));\n-\n-      // For each trigger path, check if there's a data path from the same entity\n-      for (const triggerPath of triggerPaths) {\n-        const triggerEntity = triggerPath.split(\".\")[0];\n-\n-        // Find data paths from the same entity\n-        const sameEntityDataPaths = dataPaths.filter((dataPath) => {\n-          const dataEntity = dataPath.split(\".\")[0];\n-\n-          return dataEntity === triggerEntity;\n-        });\n-\n-        if (sameEntityDataPaths.length > 0) {\n-          // Check if any of these data paths depend on the trigger path (directly or indirectly)\n-          for (const dataPath of sameEntityDataPaths) {\n-            const dataPathTransitiveDeps =\n-              getAllTransitiveDependencies(dataPath);\n-\n-            if (dataPathTransitiveDeps.has(triggerPath)) {\n-              const error = new Error(\n-                `Reactive dependency misuse: '${node}' depends on both trigger path '${triggerPath}' and data path '${dataPath}' from the same entity, and '${dataPath}' depends on '${triggerPath}' (directly or indirectly). This can cause unexpected reactivity.`,\n-              );\n-\n-              // Add custom properties\n-              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n-              // @ts-ignore\n-              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-              (error as any).node = node;\n-\n-              throw error;\n-            }\n-          }\n+  /**\n+   * Returns all transitive dependencies (direct and indirect, no duplicates) for a given node.\n+   */\n+  static getAllTransitiveDependencies(\n+    dependencyMap: DependencyMap,\n+    node: string,\n+  ): string[] {\n+    const dependencies = dependencyMap.rawDependencies;\n+    const visited = new Set<string>();\n+\n+    function traverse(current: string) {\n+      const directDeps = dependencies.get(current) || new Set<string>();\n+\n+      for (const dep of directDeps) {\n+        if (!visited.has(dep)) {\n+          visited.add(dep);\n+          traverse(dep);\n         }\n       }\n     }\n+\n+    traverse(node);\n+\n+    return Array.from(visited);\n   }\n }\ndiff --git a/app/client/src/entities/DependencyMap/__tests__/DependencyMapUtils.test.ts b/app/client/src/entities/DependencyMap/__tests__/DependencyMapUtils.test.ts\nnew file mode 100644\nindex 00000000000..74fa30cf7e7\n--- /dev/null\n+++ b/app/client/src/entities/DependencyMap/__tests__/DependencyMapUtils.test.ts\n@@ -0,0 +1,337 @@\n+import DependencyMap from \"../index\";\n+import { DependencyMapUtils } from \"../DependencyMapUtils\";\n+import { PluginType } from \"entities/Plugin\";\n+import {\n+  ENTITY_TYPE,\n+  type DataTreeEntityConfig,\n+  type MetaArgs,\n+} from \"ee/entities/DataTree/types\";\n+import type { ActionRunBehaviourType } from \"PluginActionEditor/types/PluginActionTypes\";\n+\n+describe(\"detectReactiveDependencyMisuse\", () => {\n+  function makeConfigTreeWithAction(\n+    entityName: string,\n+    runBehaviour: ActionRunBehaviourType = \"AUTOMATIC\",\n+  ): DataTreeEntityConfig {\n+    return {\n+      ENTITY_TYPE: ENTITY_TYPE.ACTION,\n+      dynamicTriggerPathList: [{ key: \"run\" }],\n+      dynamicBindingPathList: [],\n+      bindingPaths: {},\n+      reactivePaths: {},\n+      dependencyMap: {},\n+      logBlackList: {},\n+      pluginType: PluginType.API,\n+      pluginId: \"mockPluginId\",\n+      actionId: \"mockActionId\",\n+      name: entityName,\n+      runBehaviour,\n+    };\n+  }\n+\n+  function makeConfigTreeWithJSAction(\n+    entityName: string,\n+    meta: Record<string, MetaArgs> = {},\n+  ): DataTreeEntityConfig {\n+    return {\n+      ENTITY_TYPE: ENTITY_TYPE.JSACTION,\n+      meta,\n+      dynamicBindingPathList: [],\n+      actionNames: new Set([\"myFun1\", \"myFun2\"]),\n+      bindingPaths: {},\n+      reactivePaths: {},\n+      dependencyMap: {},\n+      pluginType: PluginType.JS,\n+      name: entityName,\n+      actionId: \"mockJSActionId\",\n+      dynamicTriggerPathList: [],\n+      variables: [],\n+    };\n+  }\n+\n+  function makeConfigTreeWithWidget(entityName: string): DataTreeEntityConfig {\n+    return {\n+      ENTITY_TYPE: ENTITY_TYPE.WIDGET,\n+      bindingPaths: {},\n+      reactivePaths: {},\n+      triggerPaths: {},\n+      validationPaths: {},\n+      logBlackList: {},\n+      propertyOverrideDependency: {},\n+      overridingPropertyPaths: {},\n+      privateWidgets: {},\n+      widgetId: \"mockWidgetId\",\n+      defaultMetaProps: [],\n+      type: \"MOCK_WIDGET_TYPE\",\n+      dynamicBindingPathList: [],\n+      name: entityName,\n+    };\n+  }\n+\n+  it(\"does not throw for Widget entity\", () => {\n+    const dependencyMap = new DependencyMap();\n+\n+    dependencyMap.addNodes({\n+      Widget1: true,\n+      \"Widget1.run\": true,\n+      \"Widget1.data\": true,\n+    });\n+    dependencyMap.addDependency(\"Widget1\", [\"Widget1.run\", \"Widget1.data\"]);\n+    const configTree = {\n+      Widget1: makeConfigTreeWithWidget(\"Widget1\"),\n+    };\n+\n+    expect(() => {\n+      DependencyMapUtils.detectReactiveDependencyMisuse(\n+        dependencyMap,\n+        configTree,\n+      );\n+    }).not.toThrow();\n+  });\n+\n+  it(\"does not throw for MANUAL ACTION entity\", () => {\n+    const dependencyMap = new DependencyMap();\n+\n+    dependencyMap.addNodes({\n+      \"JSObject1.myFun1\": true,\n+      \"Query3.run\": true,\n+      \"Query3.data\": true,\n+    });\n+    dependencyMap.addDependency(\"JSObject1.myFun1\", [\n+      \"Query3.run\",\n+      \"Query3.data\",\n+    ]);\n+    const configTree = {\n+      Query3: makeConfigTreeWithAction(\"Query3\", \"MANUAL\"),\n+      JSObject1: makeConfigTreeWithJSAction(\"JSObject1\", {\n+        myFun1: {\n+          runBehaviour: \"MANUAL\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+        myFun2: {\n+          runBehaviour: \"MANUAL\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+      }),\n+    };\n+\n+    expect(() => {\n+      DependencyMapUtils.detectReactiveDependencyMisuse(\n+        dependencyMap,\n+        configTree,\n+      );\n+    }).not.toThrow();\n+  });\n+\n+  it(\"does not throw for JSAction entity with no AUTOMATIC function\", () => {\n+    const dependencyMap = new DependencyMap();\n+\n+    dependencyMap.addNodes({\n+      \"JSObject1.myFun1\": true,\n+      \"JSObject1.myFun2\": true,\n+      \"Query2.run\": true,\n+      \"Query2.data\": true,\n+    });\n+    // JSObject1.myFun2 depends on Query2.run\n+    dependencyMap.addDependency(\"JSObject1.myFun2\", [\"Query2.run\"]);\n+    // JSObject1.myFun1 depends on both JSObject1.myFun2 and and Query2.data (transitive)\n+    dependencyMap.addDependency(\"JSObject1.myFun1\", [\n+      \"JSObject1.myFun2\",\n+      \"Query2.data\",\n+    ]);\n+\n+    // meta has no AUTOMATIC runBehaviour\n+    const configTree = {\n+      JSObject1: makeConfigTreeWithJSAction(\"JSObject1\", {\n+        myFun1: {\n+          runBehaviour: \"MANUAL\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+        myFun2: {\n+          runBehaviour: \"MANUAL\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+      }),\n+      Query2: makeConfigTreeWithAction(\"Query2\", \"AUTOMATIC\"),\n+    };\n+\n+    expect(() => {\n+      DependencyMapUtils.detectReactiveDependencyMisuse(\n+        dependencyMap,\n+        configTree,\n+      );\n+    }).not.toThrow();\n+  });\n+\n+  it(\"does not throw if a node depends only on .run or only on .data for AUTOMATIC ACTION\", () => {\n+    const configTree = {\n+      Api1: makeConfigTreeWithAction(\"Api1\", \"AUTOMATIC\"),\n+      JSObject1: makeConfigTreeWithJSAction(\"JSObject1\", {\n+        myFun1: {\n+          runBehaviour: \"AUTOMATIC\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+        myFun2: {\n+          runBehaviour: \"AUTOMATIC\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+      }),\n+      JSObject2: makeConfigTreeWithJSAction(\"JSObject2\", {\n+        myFun1: {\n+          runBehaviour: \"AUTOMATIC\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+        myFun2: {\n+          runBehaviour: \"AUTOMATIC\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+      }),\n+    };\n+\n+    // Only .run\n+    const depMapRun = new DependencyMap();\n+\n+    depMapRun.addNodes({ \"JSObject1.myFun1\": true, \"Api1.run\": true });\n+    depMapRun.addDependency(\"JSObject1.myFun1\", [\"Api1.run\"]);\n+\n+    expect(() => {\n+      DependencyMapUtils.detectReactiveDependencyMisuse(depMapRun, configTree);\n+    }).not.toThrow();\n+\n+    // Only .data\n+    const depMapData = new DependencyMap();\n+\n+    depMapData.addNodes({ \"JSObject2.myFun1\": true, \"Api1.data\": true });\n+    depMapData.addDependency(\"JSObject2.myFun1\", [\"Api1.data\"]);\n+    expect(() => {\n+      DependencyMapUtils.detectReactiveDependencyMisuse(depMapData, configTree);\n+    }).not.toThrow();\n+  });\n+\n+  it(\"throws if a node depends on both .run and .data of the same AUTOMATIC ACTION entity\", () => {\n+    const dependencyMap = new DependencyMap();\n+\n+    // Add nodes\n+    dependencyMap.addNodes({\n+      \"JSObject1.myFun1\": true,\n+      \"Query1.run\": true,\n+      \"Query1.data\": true,\n+    });\n+    // JSObject1.myFun1 depends on both Query1.run and Query1.data\n+    dependencyMap.addDependency(\"JSObject1.myFun1\", [\n+      \"Query1.run\",\n+      \"Query1.data\",\n+    ]);\n+    const configTree = {\n+      JSObject1: makeConfigTreeWithJSAction(\"JSObject1\", {\n+        myFun1: {\n+          runBehaviour: \"AUTOMATIC\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+        myFun2: {\n+          runBehaviour: \"MANUAL\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+      }),\n+      Query1: makeConfigTreeWithAction(\"Query1\", \"AUTOMATIC\"),\n+    };\n+\n+    expect(() => {\n+      DependencyMapUtils.detectReactiveDependencyMisuse(\n+        dependencyMap,\n+        configTree,\n+      );\n+    }).toThrow(/Reactive dependency misuse/);\n+  });\n+\n+  it(\"throws if a node depends on both .run and .data of the same AUTOMATIC ACTION entity via transitive dependency\", () => {\n+    const dependencyMap = new DependencyMap();\n+\n+    dependencyMap.addNodes({\n+      \"JSObject1.myFun1\": true,\n+      \"JSObject1.myFun2\": true,\n+      \"Query2.run\": true,\n+      \"Query2.data\": true,\n+    });\n+    // JSObject1.myFun2 depends on Query2.run\n+    dependencyMap.addDependency(\"JSObject1.myFun2\", [\"Query2.run\"]);\n+    // JSObject1.myFun1 depends on both JSObject1.myFun2 and and Query2.data (transitive)\n+    dependencyMap.addDependency(\"JSObject1.myFun1\", [\n+      \"JSObject1.myFun2\",\n+      \"Query2.data\",\n+    ]);\n+    const configTree = {\n+      Query2: makeConfigTreeWithAction(\"Query2\", \"AUTOMATIC\"),\n+      JSObject1: makeConfigTreeWithJSAction(\"JSObject1\", {\n+        myFun1: {\n+          runBehaviour: \"AUTOMATIC\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+        myFun2: {\n+          runBehaviour: \"MANUAL\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+      }),\n+    };\n+\n+    expect(() => {\n+      DependencyMapUtils.detectReactiveDependencyMisuse(\n+        dependencyMap,\n+        configTree,\n+      );\n+    }).toThrow(/Reactive dependency misuse/);\n+  });\n+\n+  it(\"throws for JSAction entity with at least one AUTOMATIC function\", () => {\n+    // meta has one AUTOMATIC runBehaviour\n+    const dependencyMap = new DependencyMap();\n+\n+    dependencyMap.addNodes({\n+      \"JSObject1.myFun1\": true,\n+      \"JSObject1.myFun2\": true,\n+      \"Query2.run\": true,\n+      \"Query2.data\": true,\n+    });\n+    // JSObject1.myFun2 depends on Query2.run\n+    dependencyMap.addDependency(\"JSObject1.myFun2\", [\"Query2.run\"]);\n+    // JSObject1.myFun1 depends on both JSObject1.myFun2 and and Query2.data (transitive)\n+    dependencyMap.addDependency(\"JSObject1.myFun1\", [\n+      \"JSObject1.myFun2\",\n+      \"Query2.data\",\n+    ]);\n+    const configTree = {\n+      JSObject1: makeConfigTreeWithJSAction(\"JSObject1\", {\n+        myFun1: {\n+          runBehaviour: \"AUTOMATIC\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+        myFun2: {\n+          runBehaviour: \"MANUAL\",\n+          arguments: [],\n+          confirmBeforeExecute: false,\n+        },\n+      }),\n+      Query2: makeConfigTreeWithAction(\"Query2\", \"MANUAL\"),\n+    };\n+\n+    expect(() => {\n+      DependencyMapUtils.detectReactiveDependencyMisuse(\n+        dependencyMap,\n+        configTree,\n+      );\n+    }).toThrow(/Reactive dependency misuse/);\n+  });\n+});\n",
        "pr_mirror": "appsmithorg__appsmith.7046aeb3"
    }
}