{
    "cost": 0.53247,
    "rewrites": {
        "appsmithorg__appsmith.7046aeb3/app/client/src/actions/pageActions.tsx": {
            "output": "import type { WidgetType } from \"constants/WidgetConstants\";\nimport type { AnyReduxAction, ReduxAction } from \"./ReduxActionTypes\";\nimport {\n  ReduxActionErrorTypes,\n  ReduxActionTypes,\n  WidgetReduxActionTypes,\n} from \"ee/constants/ReduxActionConstants\";\nimport type { DynamicPath } from \"utils/DynamicBindingUtils\";\nimport AnalyticsUtil from \"ee/utils/AnalyticsUtil\";\nimport type { WidgetOperation, WidgetProps } from \"widgets/BaseWidget\";\nimport type {\n  FetchPageResponse,\n  PageLayout,\n  SavePageResponse,\n  UpdatePageRequest,\n  UpdatePageResponse,\n} from \"api/PageApi\";\nimport type { UrlDataState } from \"reducers/entityReducers/appReducer\";\nimport type { APP_MODE } from \"entities/App\";\nimport type { CanvasWidgetsReduxState } from \"ee/reducers/entityReducers/canvasWidgetsReducer\";\nimport type { ENTITY_TYPE } from \"ee/entities/AppsmithConsole/utils\";\nimport type { Replayable } from \"entities/Replay/ReplayEntity/ReplayEditor\";\nimport type { DSLWidget } from \"WidgetProvider/types\";\nimport type {\n  LayoutOnLoadActionErrors,\n  PageAction,\n} from \"../constants/AppsmithActionConstants/ActionConstants\";\nimport { ReplayOperation } from \"entities/Replay/ReplayEntity/ReplayOperations\";\nimport type { PACKAGE_PULL_STATUS } from \"ee/constants/ModuleConstants\";\nimport type { ApiResponse } from \"api/ApiResponses\";\nimport type { EvaluationReduxAction } from \"./EvaluationReduxActionTypes\";\nimport { appsmithTelemetry } from \"instrumentation\";\nimport type { NavigateToAnotherPagePayload } from \"sagas/ActionExecution/NavigateActionSaga/types\";\n\nexport interface FetchPageListPayload {\n  applicationId: string;\n  mode: APP_MODE;\n}\n\nexport interface updateLayoutOptions {\n  isRetry?: boolean;\n  shouldReplay?: boolean;\n  updatedWidgetIds?: string[];\n}\n\nexport interface FetchPageActionPayload {\n  id: string;\n  isFirstLoad?: boolean;\n  pageWithMigratedDsl?: FetchPageResponse;\n}\n\nexport const fetchPageAction = (\n  pageId: string,\n  isFirstLoad = false,\n  pageWithMigratedDsl?: FetchPageResponse,\n): ReduxAction<FetchPageActionPayload> => {\n  return {\n    type: ReduxActionTypes.FETCH_PAGE_INIT,\n    payload: {\n      id: pageId,\n      isFirstLoad,\n      pageWithMigratedDsl,\n    },\n  };\n};\n\n// fetch a published page\nexport interface FetchPublishedPageActionPayload {\n  pageId: string;\n  bustCache?: boolean;\n  pageWithMigratedDsl?: FetchPageResponse;\n}\n\nexport interface FetchPublishedPageResourcesPayload {\n  pageId: string;\n  basePageId: string;\n  branch: string;\n}\n\nexport const fetchPublishedPageAction = (\n  pageId: string,\n  bustCache = false,\n  pageWithMigratedDsl?: FetchPageResponse,\n): ReduxAction<FetchPublishedPageActionPayload> => ({\n  type: ReduxActionTypes.FETCH_PUBLISHED_PAGE_INIT,\n  payload: {\n    pageId,\n    bustCache,\n    pageWithMigratedDsl,\n  },\n});\n\nexport const fetchPageSuccess = (): EvaluationReduxAction<undefined> => {\n  return {\n    type: ReduxActionTypes.FETCH_PAGE_SUCCESS,\n    payload: undefined,\n  };\n};\n\nexport const fetchPublishedPageSuccess =\n  (): EvaluationReduxAction<undefined> => ({\n    type: ReduxActionTypes.FETCH_PUBLISHED_PAGE_SUCCESS,\n    payload: undefined,\n  });\n\n/**\n * After all page entities are fetched like DSL, actions and JsObjects,\n * we trigger evaluation using this redux action, here we supply postEvalActions\n * to trigger action after evaluation has been completed like executeOnPageLoadAction\n *\n * @param {Array<AnyReduxAction>} postEvalActions\n */\nexport const fetchAllPageEntityCompletion = (\n  postEvalActions: Array<AnyReduxAction>,\n) => ({\n  type: ReduxActionTypes.FETCH_ALL_PAGE_ENTITY_COMPLETION,\n  postEvalActions,\n  payload: undefined,\n});\n\nexport interface UpdateCurrentPagePayload {\n  id: string;\n  slug?: string;\n  permissions?: string[];\n}\n\nexport const updateCurrentPage = (\n  id: string,\n  slug?: string,\n  permissions?: string[],\n): ReduxAction<UpdateCurrentPagePayload> => ({\n  type: ReduxActionTypes.SWITCH_CURRENT_PAGE_ID,\n  payload: { id, slug, permissions },\n});\n\nexport interface UpdateCanvasPayload {\n  pageWidgetId: string;\n  widgets: { [widgetId: string]: WidgetProps };\n  currentLayoutId: string;\n  currentPageId: string;\n  currentPageName: string;\n  currentApplicationId: string;\n  dsl: Partial<DSLWidget>;\n  pageActions: PageAction[][];\n  updatedWidgetIds?: string[];\n  layoutOnLoadActionErrors?: LayoutOnLoadActionErrors[];\n}\n\nexport const initCanvasLayout = (\n  payload: UpdateCanvasPayload,\n): ReduxAction<UpdateCanvasPayload> => {\n  return {\n    type: ReduxActionTypes.INIT_CANVAS_LAYOUT,\n    payload,\n  };\n};\n\nexport const setLastUpdatedTime = (payload: number): ReduxAction<number> => ({\n  type: ReduxActionTypes.SET_LAST_UPDATED_TIME,\n  payload,\n});\n\nexport const savePageSuccess = (payload: SavePageResponse) => {\n  return {\n    type: ReduxActionTypes.SAVE_PAGE_SUCCESS,\n    payload,\n  };\n};\n\nexport const updateWidgetNameSuccess = () => {\n  return {\n    type: ReduxActionTypes.UPDATE_WIDGET_NAME_SUCCESS,\n  };\n};\n\nexport const deletePageSuccess = () => {\n  return {\n    type: ReduxActionTypes.DELETE_PAGE_SUCCESS,\n  };\n};\n\nexport const updateAndSaveLayout = (\n  widgets: CanvasWidgetsReduxState,\n  options: updateLayoutOptions = {},\n) => {\n  const { isRetry, shouldReplay, updatedWidgetIds } = options;\n\n  return {\n    type: ReduxActionTypes.UPDATE_LAYOUT,\n    payload: { widgets, isRetry, shouldReplay, updatedWidgetIds },\n  };\n};\n\nexport const saveLayout = (isRetry?: boolean) => {\n  return {\n    type: ReduxActionTypes.SAVE_PAGE_INIT,\n    payload: { isRetry },\n  };\n};\n\nexport interface CreatePageActionPayload {\n  applicationId: string;\n  name: string;\n  layouts: Partial<PageLayout>[];\n}\n\nexport const createPageAction = (\n  applicationId: string,\n  pageName: string,\n  layouts: Partial<PageLayout>[],\n  workspaceId: string,\n  instanceId?: string,\n) => {\n  AnalyticsUtil.logEvent(\"CREATE_PAGE\", {\n    pageName,\n    workspaceId,\n    instanceId,\n  });\n\n  return {\n    type: ReduxActionTypes.CREATE_PAGE_INIT,\n    payload: {\n      applicationId,\n      name: pageName,\n      layouts,\n    },\n  };\n};\n\nexport const createNewPageFromEntities = (\n  applicationId: string,\n  pageName: string,\n  workspaceId: string,\n  instanceId?: string,\n) => {\n  AnalyticsUtil.logEvent(\"CREATE_PAGE\", {\n    pageName,\n    workspaceId,\n    instanceId,\n  });\n\n  return {\n    type: ReduxActionTypes.CREATE_NEW_PAGE_FROM_ENTITIES,\n    payload: {\n      applicationId,\n      name: pageName,\n    },\n  };\n};\n\n// cloning a page\nexport interface ClonePageActionPayload {\n  id: string;\n  blockNavigation?: boolean;\n}\n\nexport const clonePageInit = (\n  pageId: string,\n  blockNavigation?: boolean,\n): ReduxAction<ClonePageActionPayload> => {\n  return {\n    type: ReduxActionTypes.CLONE_PAGE_INIT,\n    payload: {\n      id: pageId,\n      blockNavigation,\n    },\n  };\n};\n\nexport interface ClonePageSuccessPayload {\n  pageName: string;\n  description?: string;\n  pageId: string;\n  basePageId: string;\n  layoutId: string;\n  isDefault: boolean;\n  slug: string;\n}\n\nexport const clonePageSuccess = ({\n  basePageId,\n  layoutId,\n  pageId,\n  pageName,\n  slug,\n}: ClonePageSuccessPayload) => {\n  return {\n    type: ReduxActionTypes.CLONE_PAGE_SUCCESS,\n    payload: {\n      pageId,\n      basePageId,\n      pageName,\n      layoutId,\n      slug,\n    },\n  };\n};\n\n// Fetches resources required for published page, currently only used for fetching actions\n// In future we can reuse this for fetching other page level resources in published mode\nexport const fetchPublishedPageResources = ({\n  basePageId,\n  branch,\n  pageId,\n}: FetchPublishedPageResourcesPayload): ReduxAction<FetchPublishedPageResourcesPayload> => ({\n  type: ReduxActionTypes.FETCH_PUBLISHED_PAGE_RESOURCES_INIT,\n  payload: {\n    pageId,\n    basePageId,\n    branch,\n  },\n});\n\n// update a page\n\nexport interface UpdatePageActionPayload {\n  id: string;\n  name?: string;\n  isHidden?: boolean;\n  customSlug?: string;\n}\n\nexport const updatePageAction = (\n  payload: UpdatePageActionPayload,\n): ReduxAction<UpdatePageActionPayload> => {\n  if (!payload.id) {\n    appsmithTelemetry.captureException(\n      new Error(\"Attempting to update page without page id\"),\n      {\n        errorName: \"PageActions_UpdatePage\",\n      },\n    );\n  }\n\n  return {\n    type: ReduxActionTypes.UPDATE_PAGE_INIT,\n    payload,\n  };\n};\n\nexport const updatePageSuccess = (payload: UpdatePageResponse) => {\n  return {\n    type: ReduxActionTypes.UPDATE_PAGE_SUCCESS,\n    payload,\n  };\n};\n\nexport const updatePageError = (payload: UpdatePageErrorPayload) => {\n  return {\n    type: ReduxActionErrorTypes.UPDATE_PAGE_ERROR,\n    payload,\n  };\n};\n\nexport interface UpdatePageErrorPayload {\n  request: UpdatePageRequest;\n  error: unknown;\n}\n\nexport interface WidgetAddChild {\n  widgetId: string;\n  widgetName?: string;\n  type: WidgetType;\n  leftColumn: number;\n  topRow: number;\n  columns: number;\n  rows: number;\n  parentRowSpace: number;\n  parentColumnSpace: number;\n  newWidgetId: string;\n  tabId: string;\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  props?: Record<string, any>;\n  dynamicBindingPathList?: DynamicPath[];\n}\n\nexport interface WidgetRemoveChild {\n  widgetId: string;\n  childWidgetId: string;\n}\n\nexport interface WidgetDelete {\n  widgetId?: string;\n  parentId?: string;\n  disallowUndo?: boolean;\n  isShortcut?: boolean;\n}\n\nexport interface MultipleWidgetDeletePayload {\n  widgetIds: string[];\n  disallowUndo?: boolean;\n  isShortcut?: boolean;\n}\n\nexport interface WidgetResize {\n  widgetId: string;\n  parentId: string;\n  leftColumn?: number;\n  rightColumn?: number;\n  topRow?: number;\n  bottomRow?: number;\n  mobileLeftColumn?: number;\n  mobileRightColumn?: number;\n  mobileTopRow?: number;\n  mobileBottomRow?: number;\n  snapColumnSpace: number;\n  snapRowSpace: number;\n}\n\nexport interface ModalWidgetResize {\n  height: number;\n  width: number;\n  widgetId: string;\n  canvasWidgetId: string;\n}\n\nexport interface WidgetAddChildren {\n  widgetId: string;\n  children: Array<{\n    type: WidgetType;\n    widgetId: string;\n    parentId: string;\n    parentRowSpace: number;\n    parentColumnSpace: number;\n    leftColumn: number;\n    rightColumn: number;\n    topRow: number;\n    bottomRow: number;\n    isLoading: boolean;\n  }>;\n}\n\nexport interface WidgetUpdateProperty {\n  widgetId: string;\n  propertyPath: string;\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  propertyValue: any;\n}\n\nexport const updateWidget = (\n  operation: WidgetOperation,\n  widgetId: string,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  payload: any,\n): ReduxAction<\n  | WidgetAddChild\n  | WidgetResize\n  | WidgetDelete\n  | WidgetAddChildren\n  | WidgetUpdateProperty\n> => {\n  return {\n    type: WidgetReduxActionTypes[\"WIDGET_\" + operation],\n    payload: { widgetId, ...payload },\n  };\n};\n\nexport const setUrlData = (\n  payload: UrlDataState,\n): ReduxAction<UrlDataState> => {\n  return {\n    type: ReduxActionTypes.SET_URL_DATA,\n    payload,\n  };\n};\n\nexport const setAppMode = (payload: APP_MODE): ReduxAction<APP_MODE> => {\n  return {\n    type: ReduxActionTypes.SET_APP_MODE,\n    payload,\n  };\n};\n\nexport const updateAppStore = (\n  payload: Record<string, unknown>,\n): EvaluationReduxAction<Record<string, unknown>> => {\n  return {\n    type: ReduxActionTypes.UPDATE_APP_STORE,\n    payload,\n  };\n};\n\nexport interface ReduxActionWithExtraParams<T> extends ReduxAction<T> {\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  extraParams: Record<any, any>;\n}\n\nexport interface GenerateCRUDSuccess {\n  page: {\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    layouts: Array<any>;\n    id: string;\n    baseId: string;\n    name: string;\n    isDefault?: boolean;\n    slug: string;\n    description?: string;\n  };\n  isNewPage: boolean;\n}\n\nexport const generateTemplateSuccess = (payload: GenerateCRUDSuccess) => {\n  return {\n    type: ReduxActionTypes.GENERATE_TEMPLATE_PAGE_SUCCESS,\n    payload,\n  };\n};\n\nexport const generateTemplateError = () => {\n  return {\n    type: ReduxActionErrorTypes.GENERATE_TEMPLATE_PAGE_ERROR,\n  };\n};\n\nexport interface GenerateTemplatePageActionPayload {\n  pageId: string;\n  tableName: string;\n  datasourceId: string;\n  applicationId: string;\n  columns?: string[];\n  searchColumn?: string;\n  mode?: string;\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  pluginSpecificParams?: Record<any, any>;\n}\n\nexport const generateTemplateToUpdatePage = ({\n  applicationId,\n  columns,\n  datasourceId,\n  mode,",
            "output_extracted": "import type { WidgetType } from \"constants/WidgetConstants\";\nimport type { AnyReduxAction, ReduxAction } from \"./ReduxActionTypes\";\nimport {\n  ReduxActionErrorTypes,\n  ReduxActionTypes,\n  WidgetReduxActionTypes,\n} from \"ee/constants/ReduxActionConstants\";\nimport type { DynamicPath } from \"utils/DynamicBindingUtils\";\nimport AnalyticsUtil from \"ee/utils/AnalyticsUtil\";\nimport type { WidgetOperation, WidgetProps } from \"widgets/BaseWidget\";\nimport type {\n  FetchPageResponse,\n  PageLayout,\n  SavePageResponse,\n  UpdatePageRequest,\n  UpdatePageResponse,\n} from \"api/PageApi\";\nimport type { UrlDataState } from \"reducers/entityReducers/appReducer\";\nimport type { APP_MODE } from \"entities/App\";\nimport type { CanvasWidgetsReduxState } from \"ee/reducers/entityReducers/canvasWidgetsReducer\";\nimport type { ENTITY_TYPE } from \"ee/entities/AppsmithConsole/utils\";\nimport type { Replayable } from \"entities/Replay/ReplayEntity/ReplayEditor\";\nimport type { DSLWidget } from \"WidgetProvider/types\";\nimport type {\n  LayoutOnLoadActionErrors,\n  PageAction,\n} from \"../constants/AppsmithActionConstants/ActionConstants\";\nimport { ReplayOperation } from \"entities/Replay/ReplayEntity/ReplayOperations\";\nimport type { PACKAGE_PULL_STATUS } from \"ee/constants/ModuleConstants\";\nimport type { ApiResponse } from \"api/ApiResponses\";\nimport type { EvaluationReduxAction } from \"./EvaluationReduxActionTypes\";\nimport { appsmithTelemetry } from \"instrumentation\";\nimport type { NavigateToAnotherPagePayload } from \"sagas/ActionExecution/NavigateActionSaga/types\";\n\nexport interface FetchPageListPayload {\n  applicationId: string;\n  mode: APP_MODE;\n}\n\nexport interface updateLayoutOptions {\n  isRetry?: boolean;\n  shouldReplay?: boolean;\n  updatedWidgetIds?: string[];\n}\n\nexport interface FetchPageActionPayload {\n  id: string;\n  isFirstLoad?: boolean;\n  pageWithMigratedDsl?: FetchPageResponse;\n}\n\nexport const fetchPageAction = (\n  pageId: string,\n  isFirstLoad = false,\n  pageWithMigratedDsl?: FetchPageResponse,\n): ReduxAction<FetchPageActionPayload> => {\n  return {\n    type: ReduxActionTypes.FETCH_PAGE_INIT,\n    payload: {\n      id: pageId,\n      isFirstLoad,\n      pageWithMigratedDsl,\n    },\n  };\n};\n\n// fetch a published page\nexport interface FetchPublishedPageActionPayload {\n  pageId: string;\n  bustCache?: boolean;\n  pageWithMigratedDsl?: FetchPageResponse;\n}\n\nexport interface FetchPublishedPageResourcesPayload {\n  pageId: string;\n  basePageId: string;\n  branch: string;\n}\n\nexport const fetchPublishedPageAction = (\n  pageId: string,\n  bustCache = false,\n  pageWithMigratedDsl?: FetchPageResponse,\n): ReduxAction<FetchPublishedPageActionPayload> => ({\n  type: ReduxActionTypes.FETCH_PUBLISHED_PAGE_INIT,\n  payload: {\n    pageId,\n    bustCache,\n    pageWithMigratedDsl,\n  },\n});\n\nexport const fetchPageSuccess = (): EvaluationReduxAction<undefined> => {\n  return {\n    type: ReduxActionTypes.FETCH_PAGE_SUCCESS,\n    payload: undefined,\n  };\n};\n\nexport const fetchPublishedPageSuccess =\n  (): EvaluationReduxAction<undefined> => ({\n    type: ReduxActionTypes.FETCH_PUBLISHED_PAGE_SUCCESS,\n    payload: undefined,\n  });\n\n/**\n * After all page entities are fetched like DSL, actions and JsObjects,\n * we trigger evaluation using this redux action, here we supply postEvalActions\n * to trigger action after evaluation has been completed like executeOnPageLoadAction\n *\n * @param {Array<AnyReduxAction>} postEvalActions\n */\nexport const fetchAllPageEntityCompletion = (\n  postEvalActions: Array<AnyReduxAction>,\n) => ({\n  type: ReduxActionTypes.FETCH_ALL_PAGE_ENTITY_COMPLETION,\n  postEvalActions,\n  payload: undefined,\n});\n\nexport interface UpdateCurrentPagePayload {\n  id: string;\n  slug?: string;\n  permissions?: string[];\n}\n\nexport const updateCurrentPage = (\n  id: string,\n  slug?: string,\n  permissions?: string[],\n): ReduxAction<UpdateCurrentPagePayload> => ({\n  type: ReduxActionTypes.SWITCH_CURRENT_PAGE_ID,\n  payload: { id, slug, permissions },\n});\n\nexport interface UpdateCanvasPayload {\n  pageWidgetId: string;\n  widgets: { [widgetId: string]: WidgetProps };\n  currentLayoutId: string;\n  currentPageId: string;\n  currentPageName: string;\n  currentApplicationId: string;\n  dsl: Partial<DSLWidget>;\n  pageActions: PageAction[][];\n  updatedWidgetIds?: string[];\n  layoutOnLoadActionErrors?: LayoutOnLoadActionErrors[];\n}\n\nexport const initCanvasLayout = (\n  payload: UpdateCanvasPayload,\n): ReduxAction<UpdateCanvasPayload> => {\n  return {\n    type: ReduxActionTypes.INIT_CANVAS_LAYOUT,\n    payload,\n  };\n};\n\nexport const setLastUpdatedTime = (payload: number): ReduxAction<number> => ({\n  type: ReduxActionTypes.SET_LAST_UPDATED_TIME,\n  payload,\n});\n\nexport const savePageSuccess = (payload: SavePageResponse) => {\n  return {\n    type: ReduxActionTypes.SAVE_PAGE_SUCCESS,\n    payload,\n  };\n};\n\nexport const updateWidgetNameSuccess = () => {\n  return {\n    type: ReduxActionTypes.UPDATE_WIDGET_NAME_SUCCESS,\n  };\n};\n\nexport const deletePageSuccess = () => {\n  return {\n    type: ReduxActionTypes.DELETE_PAGE_SUCCESS,\n  };\n};\n\nexport const updateAndSaveLayout = (\n  widgets: CanvasWidgetsReduxState,\n  options: updateLayoutOptions = {},\n) => {\n  const { isRetry, shouldReplay, updatedWidgetIds } = options;\n\n  return {\n    type: ReduxActionTypes.UPDATE_LAYOUT,\n    payload: { widgets, isRetry, shouldReplay, updatedWidgetIds },\n  };\n};\n\nexport const saveLayout = (isRetry?: boolean) => {\n  return {\n    type: ReduxActionTypes.SAVE_PAGE_INIT,\n    payload: { isRetry },\n  };\n};\n\nexport interface CreatePageActionPayload {\n  applicationId: string;\n  name: string;\n  layouts: Partial<PageLayout>[];\n}\n\nexport const createPageAction = (\n  applicationId: string,\n  pageName: string,\n  layouts: Partial<PageLayout>[],\n  workspaceId: string,\n  instanceId?: string,\n) => {\n  AnalyticsUtil.logEvent(\"CREATE_PAGE\", {\n    pageName,\n    workspaceId,\n    instanceId,\n  });\n\n  return {\n    type: ReduxActionTypes.CREATE_PAGE_INIT,\n    payload: {\n      applicationId,\n      name: pageName,\n      layouts,\n    },\n  };\n};\n\nexport const createNewPageFromEntities = (\n  applicationId: string,\n  pageName: string,\n  workspaceId: string,\n  instanceId?: string,\n) => {\n  AnalyticsUtil.logEvent(\"CREATE_PAGE\", {\n    pageName,\n    workspaceId,\n    instanceId,\n  });\n\n  return {\n    type: ReduxActionTypes.CREATE_NEW_PAGE_FROM_ENTITIES,\n    payload: {\n      applicationId,\n      name: pageName,\n    },\n  };\n};\n\n// cloning a page\nexport interface ClonePageActionPayload {\n  id: string;\n  blockNavigation?: boolean;\n}\n\nexport const clonePageInit = (\n  pageId: string,\n  blockNavigation?: boolean,\n): ReduxAction<ClonePageActionPayload> => {\n  return {\n    type: ReduxActionTypes.CLONE_PAGE_INIT,\n    payload: {\n      id: pageId,\n      blockNavigation,\n    },\n  };\n};\n\nexport interface ClonePageSuccessPayload {\n  pageName: string;\n  description?: string;\n  pageId: string;\n  basePageId: string;\n  layoutId: string;\n  isDefault: boolean;\n  slug: string;\n}\n\nexport const clonePageSuccess = ({\n  basePageId,\n  layoutId,\n  pageId,\n  pageName,\n  slug,\n}: ClonePageSuccessPayload) => {\n  return {\n    type: ReduxActionTypes.CLONE_PAGE_SUCCESS,\n    payload: {\n      pageId,\n      basePageId,\n      pageName,\n      layoutId,\n      slug,\n    },\n  };\n};\n\n// Fetches resources required for published page, currently only used for fetching actions\n// In future we can reuse this for fetching other page level resources in published mode\nexport const fetchPublishedPageResources = ({\n  basePageId,\n  branch,\n  pageId,\n}: FetchPublishedPageResourcesPayload): ReduxAction<FetchPublishedPageResourcesPayload> => ({\n  type: ReduxActionTypes.FETCH_PUBLISHED_PAGE_RESOURCES_INIT,\n  payload: {\n    pageId,\n    basePageId,\n    branch,\n  },\n});\n\n// update a page\n\nexport interface UpdatePageActionPayload {\n  id: string;\n  name?: string;\n  isHidden?: boolean;\n  customSlug?: string;\n}\n\nexport const updatePageAction = (\n  payload: UpdatePageActionPayload,\n): ReduxAction<UpdatePageActionPayload> => {\n  if (!payload.id) {\n    appsmithTelemetry.captureException(\n      new Error(\"Attempting to update page without page id\"),\n      {\n        errorName: \"PageActions_UpdatePage\",\n      },\n    );\n  }\n\n  return {\n    type: ReduxActionTypes.UPDATE_PAGE_INIT,\n    payload,\n  };\n};\n\nexport const updatePageSuccess = (payload: UpdatePageResponse) => {\n  return {\n    type: ReduxActionTypes.UPDATE_PAGE_SUCCESS,\n    payload,\n  };\n};\n\nexport const updatePageError = (payload: UpdatePageErrorPayload) => {\n  return {\n    type: ReduxActionErrorTypes.UPDATE_PAGE_ERROR,\n    payload,\n  };\n};\n\nexport interface UpdatePageErrorPayload {\n  request: UpdatePageRequest;\n  error: unknown;\n}\n\nexport interface WidgetAddChild {\n  widgetId: string;\n  widgetName?: string;\n  type: WidgetType;\n  leftColumn: number;\n  topRow: number;\n  columns: number;\n  rows: number;\n  parentRowSpace: number;\n  parentColumnSpace: number;\n  newWidgetId: string;\n  tabId: string;\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  props?: Record<string, any>;\n  dynamicBindingPathList?: DynamicPath[];\n}\n\nexport interface WidgetRemoveChild {\n  widgetId: string;\n  childWidgetId: string;\n}\n\nexport interface WidgetDelete {\n  widgetId?: string;\n  parentId?: string;\n  disallowUndo?: boolean;\n  isShortcut?: boolean;\n}\n\nexport interface MultipleWidgetDeletePayload {\n  widgetIds: string[];\n  disallowUndo?: boolean;\n  isShortcut?: boolean;\n}\n\nexport interface WidgetResize {\n  widgetId: string;\n  parentId: string;\n  leftColumn?: number;\n  rightColumn?: number;\n  topRow?: number;\n  bottomRow?: number;\n  mobileLeftColumn?: number;\n  mobileRightColumn?: number;\n  mobileTopRow?: number;\n  mobileBottomRow?: number;\n  snapColumnSpace: number;\n  snapRowSpace: number;\n}\n\nexport interface ModalWidgetResize {\n  height: number;\n  width: number;\n  widgetId: string;\n  canvasWidgetId: string;\n}\n\nexport interface WidgetAddChildren {\n  widgetId: string;\n  children: Array<{\n    type: WidgetType;\n    widgetId: string;\n    parentId: string;\n    parentRowSpace: number;\n    parentColumnSpace: number;\n    leftColumn: number;\n    rightColumn: number;\n    topRow: number;\n    bottomRow: number;\n    isLoading: boolean;\n  }>;\n}\n\nexport interface WidgetUpdateProperty {\n  widgetId: string;\n  propertyPath: string;\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  propertyValue: any;\n}\n\nexport const updateWidget = (\n  operation: WidgetOperation,\n  widgetId: string,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  payload: any,\n): ReduxAction<\n  | WidgetAddChild\n  | WidgetResize\n  | WidgetDelete\n  | WidgetAddChildren\n  | WidgetUpdateProperty\n> => {\n  return {\n    type: WidgetReduxActionTypes[\"WIDGET_\" + operation],\n    payload: { widgetId, ...payload },\n  };\n};\n\nexport const setUrlData = (\n  payload: UrlDataState,\n): ReduxAction<UrlDataState> => {\n  return {\n    type: ReduxActionTypes.SET_URL_DATA,\n    payload,\n  };\n};\n\nexport const setAppMode = (payload: APP_MODE): ReduxAction<APP_MODE> => {\n  return {\n    type: ReduxActionTypes.SET_APP_MODE,\n    payload,\n  };\n};\n\nexport const updateAppStore = (\n  payload: Record<string, unknown>,\n): EvaluationReduxAction<Record<string, unknown>> => {\n  return {\n    type: ReduxActionTypes.UPDATE_APP_STORE,\n    payload,\n  };\n};\n\nexport interface ReduxActionWithExtraParams<T> extends ReduxAction<T> {\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  extraParams: Record<any, any>;\n}\n\nexport interface GenerateCRUDSuccess {\n  page: {\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    layouts: Array<any>;\n    id: string;\n    baseId: string;\n    name: string;\n    isDefault?: boolean;\n    slug: string;\n    description?: string;\n  };\n  isNewPage: boolean;\n}\n\nexport const generateTemplateSuccess = (payload: GenerateCRUDSuccess) => {\n  return {\n    type: ReduxActionTypes.GENERATE_TEMPLATE_PAGE_SUCCESS,\n    payload,\n  };\n};\n\nexport const generateTemplateError = () => {\n  return {\n    type: ReduxActionErrorTypes.GENERATE_TEMPLATE_PAGE_ERROR,\n  };\n};\n\nexport interface GenerateTemplatePageActionPayload {\n  pageId: string;\n  tableName: string;\n  datasourceId: string;\n  applicationId: string;\n  columns?: string[];\n  searchColumn?: string;\n  mode?: string;\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  pluginSpecificParams?: Record<any, any>;\n}\n\nexport const generateTemplateToUpdatePage = ({\n  applicationId,\n  columns,\n  datasourceId,\n  mode,",
            "cost": 0.13464
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/pages/AppIDE/components/PageList/PageEntity.tsx": {
            "output": "import React, { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { useLocation } from \"react-router\";\n\nimport type { Page } from \"entities/Page\";\nimport { defaultPageIcon, pageIcon } from \"pages/Editor/Explorer/ExplorerIcons\";\nimport { getHasManagePagePermission } from \"ee/utils/BusinessFeatures/permissionPageHelpers\";\nimport { useFeatureFlag } from \"utils/hooks/useFeatureFlag\";\nimport { FEATURE_FLAG } from \"ee/entities/FeatureFlag\";\nimport { ContextMenu } from \"./ContextMenu\";\nimport {\n  getCurrentApplicationId,\n  getCurrentPageId,\n} from \"selectors/editorSelectors\";\nimport { PERMISSION_TYPE, isPermitted } from \"ee/utils/permissionHelpers\";\nimport { getCurrentApplication } from \"ee/selectors/applicationSelectors\";\nimport type { DefaultRootState } from \"react-redux\";\nimport { updatePageAction } from \"actions/pageActions\";\nimport { useGetPageFocusUrl } from \"./hooks/useGetPageFocusUrl\";\nimport AnalyticsUtil from \"ee/utils/AnalyticsUtil\";\nimport { toggleInOnboardingWidgetSelection } from \"actions/onboardingActions\";\nimport history, { NavigationMethod } from \"utils/history\";\nimport { EntityItem } from \"@appsmith/ads\";\nimport { useNameEditorState } from \"IDE/hooks/useNameEditorState\";\nimport { useValidateEntityName } from \"IDE\";\nimport { noop } from \"lodash\";\n\nexport const PageEntity = ({\n  onClick,\n  page,\n}: {\n  page: Page;\n  onClick?: () => void;\n}) => {\n  const dispatch = useDispatch();\n  const location = useLocation();\n  const navigateToUrl = useGetPageFocusUrl(page.basePageId);\n  const ref = useRef<null | HTMLDivElement>(null);\n\n  const currentPageId = useSelector(getCurrentPageId);\n  const isFeatureEnabled = useFeatureFlag(FEATURE_FLAG.license_gac_enabled);\n  const applicationId = useSelector(getCurrentApplicationId);\n  const userAppPermissions = useSelector(\n    (state: DefaultRootState) =>\n      getCurrentApplication(state)?.userPermissions ?? [],\n  );\n\n  const { editingEntity, enterEditMode, exitEditMode, updatingEntity } =\n    useNameEditorState();\n  const validateName = useValidateEntityName({\n    entityName: page.pageName,\n  });\n\n  const icon = page.isDefault ? defaultPageIcon : pageIcon;\n  const isCurrentPage = currentPageId === page.pageId;\n  const pagePermissions = page.userPermissions;\n\n  const canManagePages = getHasManagePagePermission(\n    isFeatureEnabled,\n    pagePermissions,\n  );\n  const hasExportPermission = isPermitted(\n    userAppPermissions ?? [],\n    PERMISSION_TYPE.EXPORT_APPLICATION,\n  );\n\n  useEffect(\n    function scrollPageIntoView() {\n      if (ref.current && isCurrentPage) {\n        ref.current.scrollIntoView({\n          inline: \"nearest\",\n          block: \"nearest\",\n        });\n      }\n    },\n    [ref, isCurrentPage],\n  );\n\n  const handleEnterEditMode = () => {\n    enterEditMode(page.pageId);\n  };\n\n  const handleDoubleClick = canManagePages ? handleEnterEditMode : noop;\n\n  const switchPage = useCallback(() => {\n    AnalyticsUtil.logEvent(\"PAGE_NAME_CLICK\", {\n      name: page.pageName,\n      fromUrl: location.pathname,\n      type: \"PAGES\",\n      toUrl: navigateToUrl,\n    });\n    dispatch(toggleInOnboardingWidgetSelection(true));\n    history.push(navigateToUrl, {\n      invokedBy: NavigationMethod.EntityExplorer,\n    });\n\n    if (onClick) {\n      onClick();\n    }\n  }, [location.pathname, navigateToUrl, dispatch, page.pageName, onClick]);\n\n  const contextMenu = useMemo(\n    () => (\n      <ContextMenu\n        applicationId={applicationId as string}\n        hasExportPermission={hasExportPermission}\n        isCurrentPage={isCurrentPage}\n        isDefaultPage={page.isDefault}\n        isHidden={!!page.isHidden}\n        key={page.pageId + \"_context-menu\"}\n        onItemSelected={onClick}\n        pageId={page.pageId}\n        pageName={page.pageName}\n      />\n    ),\n    [\n      applicationId,\n      hasExportPermission,\n      isCurrentPage,\n      page.isDefault,\n      page.isHidden,\n      page.pageId,\n      page.pageName,\n      onClick,\n    ],\n  );\n\n  const nameEditorConfig = useMemo(() => {\n    return {\n      canEdit: canManagePages,\n      isEditing: editingEntity === page.pageId,\n      isLoading: updatingEntity === page.pageId,\n      onEditComplete: exitEditMode,\n      onNameSave: (newName: string) =>\n        dispatch(\n          updatePageAction({\n            id: page.pageId,\n            name: newName,\n            isHidden: !!page.isHidden,\n          }),\n        ),\n      validateName: (newName: string) => validateName(newName),\n      normalizeName: false,\n    };\n  }, [\n    canManagePages,\n    dispatch,\n    editingEntity,\n    exitEditMode,\n    page,\n    updatingEntity,\n    validateName,\n  ]);\n\n  return (\n    <EntityItem\n      className={`page fullWidth ${isCurrentPage && \"activePage\"}`}\n      id={page.pageId}\n      isSelected={isCurrentPage}\n      isSubtle={page.isHidden}\n      key={page.pageId}\n      nameEditorConfig={nameEditorConfig}\n      onClick={!isCurrentPage ? switchPage : noop}\n      onDoubleClick={handleDoubleClick}\n      rightControl={contextMenu}\n      rightControlVisibility=\"hover\"\n      startIcon={icon}\n      title={page.pageName}\n    />\n  );\n};",
            "output_extracted": "import React, { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { useLocation } from \"react-router\";\n\nimport type { Page } from \"entities/Page\";\nimport { defaultPageIcon, pageIcon } from \"pages/Editor/Explorer/ExplorerIcons\";\nimport { getHasManagePagePermission } from \"ee/utils/BusinessFeatures/permissionPageHelpers\";\nimport { useFeatureFlag } from \"utils/hooks/useFeatureFlag\";\nimport { FEATURE_FLAG } from \"ee/entities/FeatureFlag\";\nimport { ContextMenu } from \"./ContextMenu\";\nimport {\n  getCurrentApplicationId,\n  getCurrentPageId,\n} from \"selectors/editorSelectors\";\nimport { PERMISSION_TYPE, isPermitted } from \"ee/utils/permissionHelpers\";\nimport { getCurrentApplication } from \"ee/selectors/applicationSelectors\";\nimport type { DefaultRootState } from \"react-redux\";\nimport { updatePageAction } from \"actions/pageActions\";\nimport { useGetPageFocusUrl } from \"./hooks/useGetPageFocusUrl\";\nimport AnalyticsUtil from \"ee/utils/AnalyticsUtil\";\nimport { toggleInOnboardingWidgetSelection } from \"actions/onboardingActions\";\nimport history, { NavigationMethod } from \"utils/history\";\nimport { EntityItem } from \"@appsmith/ads\";\nimport { useNameEditorState } from \"IDE/hooks/useNameEditorState\";\nimport { useValidateEntityName } from \"IDE\";\nimport { noop } from \"lodash\";\n\nexport const PageEntity = ({\n  onClick,\n  page,\n}: {\n  page: Page;\n  onClick?: () => void;\n}) => {\n  const dispatch = useDispatch();\n  const location = useLocation();\n  const navigateToUrl = useGetPageFocusUrl(page.basePageId);\n  const ref = useRef<null | HTMLDivElement>(null);\n\n  const currentPageId = useSelector(getCurrentPageId);\n  const isFeatureEnabled = useFeatureFlag(FEATURE_FLAG.license_gac_enabled);\n  const applicationId = useSelector(getCurrentApplicationId);\n  const userAppPermissions = useSelector(\n    (state: DefaultRootState) =>\n      getCurrentApplication(state)?.userPermissions ?? [],\n  );\n\n  const { editingEntity, enterEditMode, exitEditMode, updatingEntity } =\n    useNameEditorState();\n  const validateName = useValidateEntityName({\n    entityName: page.pageName,\n  });\n\n  const icon = page.isDefault ? defaultPageIcon : pageIcon;\n  const isCurrentPage = currentPageId === page.pageId;\n  const pagePermissions = page.userPermissions;\n\n  const canManagePages = getHasManagePagePermission(\n    isFeatureEnabled,\n    pagePermissions,\n  );\n  const hasExportPermission = isPermitted(\n    userAppPermissions ?? [],\n    PERMISSION_TYPE.EXPORT_APPLICATION,\n  );\n\n  useEffect(\n    function scrollPageIntoView() {\n      if (ref.current && isCurrentPage) {\n        ref.current.scrollIntoView({\n          inline: \"nearest\",\n          block: \"nearest\",\n        });\n      }\n    },\n    [ref, isCurrentPage],\n  );\n\n  const handleEnterEditMode = () => {\n    enterEditMode(page.pageId);\n  };\n\n  const handleDoubleClick = canManagePages ? handleEnterEditMode : noop;\n\n  const switchPage = useCallback(() => {\n    AnalyticsUtil.logEvent(\"PAGE_NAME_CLICK\", {\n      name: page.pageName,\n      fromUrl: location.pathname,\n      type: \"PAGES\",\n      toUrl: navigateToUrl,\n    });\n    dispatch(toggleInOnboardingWidgetSelection(true));\n    history.push(navigateToUrl, {\n      invokedBy: NavigationMethod.EntityExplorer,\n    });\n\n    if (onClick) {\n      onClick();\n    }\n  }, [location.pathname, navigateToUrl, dispatch, page.pageName, onClick]);\n\n  const contextMenu = useMemo(\n    () => (\n      <ContextMenu\n        applicationId={applicationId as string}\n        hasExportPermission={hasExportPermission}\n        isCurrentPage={isCurrentPage}\n        isDefaultPage={page.isDefault}\n        isHidden={!!page.isHidden}\n        key={page.pageId + \"_context-menu\"}\n        onItemSelected={onClick}\n        pageId={page.pageId}\n        pageName={page.pageName}\n      />\n    ),\n    [\n      applicationId,\n      hasExportPermission,\n      isCurrentPage,\n      page.isDefault,\n      page.isHidden,\n      page.pageId,\n      page.pageName,\n      onClick,\n    ],\n  );\n\n  const nameEditorConfig = useMemo(() => {\n    return {\n      canEdit: canManagePages,\n      isEditing: editingEntity === page.pageId,\n      isLoading: updatingEntity === page.pageId,\n      onEditComplete: exitEditMode,\n      onNameSave: (newName: string) =>\n        dispatch(\n          updatePageAction({\n            id: page.pageId,\n            name: newName,\n            isHidden: !!page.isHidden,\n          }),\n        ),\n      validateName: (newName: string) => validateName(newName),\n      normalizeName: false,\n    };\n  }, [\n    canManagePages,\n    dispatch,\n    editingEntity,\n    exitEditMode,\n    page,\n    updatingEntity,\n    validateName,\n  ]);\n\n  return (\n    <EntityItem\n      className={`page fullWidth ${isCurrentPage && \"activePage\"}`}\n      id={page.pageId}\n      isSelected={isCurrentPage}\n      isSubtle={page.isHidden}\n      key={page.pageId}\n      nameEditorConfig={nameEditorConfig}\n      onClick={!isCurrentPage ? switchPage : noop}\n      onDoubleClick={handleDoubleClick}\n      rightControl={contextMenu}\n      rightControlVisibility=\"hover\"\n      startIcon={icon}\n      title={page.pageName}\n    />\n  );\n};",
            "cost": 0.052930000000000005
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/sagas/ActionExecution/PluginActionSaga.ts": {
            "output": "import {\n  all,\n  call,\n  delay,\n  put,\n  select,\n  take,\n  takeLatest,\n} from \"redux-saga/effects\";\nimport {\n  clearActionResponse,\n  executePageLoadActions,\n  executePluginActionError,\n  executePluginActionRequest,\n  executePluginActionSuccess,\n  runAction,\n  updateAction,\n  updateActionData,\n} from \"actions/pluginActionActions\";\nimport { handleExecuteJSFunctionSaga } from \"sagas/JSPaneSagas\";\n\nimport type { ApplicationPayload } from \"entities/Application\";\nimport type { ReduxAction } from \"actions/ReduxActionTypes\";\nimport {\n  ReduxActionErrorTypes,\n  ReduxActionTypes,\n} from \"ee/constants/ReduxActionConstants\";\nimport type {\n  ActionExecutionResponse,\n  ActionResponse,\n  ExecuteActionRequest,\n  PaginationField,\n} from \"api/ActionAPI\";\nimport ActionAPI from \"api/ActionAPI\";\nimport {\n  getAction,\n  getCurrentActions,\n  getCurrentPageNameByActionId,\n  getDatasource,\n  getJSCollectionFromAllEntities,\n  getPlugin,\n} from \"ee/selectors/entitiesSelector\";\nimport {\n  getAppMode,\n  getCurrentApplication,\n} from \"ee/selectors/applicationSelectors\";\nimport {\n  find,\n  flatten,\n  get,\n  isArray,\n  isArrayBuffer,\n  isEmpty,\n  isNil,\n  isString,\n  set,\n  unset,\n  zipObject,\n} from \"lodash\";\nimport AppsmithConsole from \"utils/AppsmithConsole\";\nimport { ENTITY_TYPE, PLATFORM_ERROR } from \"ee/entities/AppsmithConsole/utils\";\nimport {\n  extractClientDefinedErrorMetadata,\n  validateResponse,\n} from \"sagas/ErrorSagas\";\nimport AnalyticsUtil from \"ee/utils/AnalyticsUtil\";\nimport type { Action } from \"entities/Action\";\nimport { ActionExecutionContext } from \"entities/Action\";\nimport LOG_TYPE from \"entities/AppsmithConsole/logtype\";\nimport {\n  ACTION_EXECUTION_CANCELLED,\n  ACTION_EXECUTION_FAILED,\n  createMessage,\n  ERROR_ACTION_EXECUTE_FAIL,\n  ERROR_FAIL_ON_PAGE_LOAD_ACTIONS,\n  ERROR_PLUGIN_ACTION_EXECUTE,\n  SWITCH_ENVIRONMENT_SUCCESS,\n} from \"ee/constants/messages\";\nimport type {\n  LayoutOnLoadActionErrors,\n  PageAction,\n} from \"constants/AppsmithActionConstants/ActionConstants\";\nimport { EventType } from \"constants/AppsmithActionConstants/ActionConstants\";\nimport {\n  getCurrentApplicationId,\n  getCurrentBasePageId,\n  getCurrentPageId,\n  getIsSavingEntity,\n  getLayoutOnLoadActions,\n  getLayoutOnLoadIssues,\n  getLayoutOnUnloadActions,\n} from \"selectors/editorSelectors\";\nimport log from \"loglevel\";\nimport { EMPTY_RESPONSE } from \"components/editorComponents/emptyResponse\";\nimport type { DefaultRootState } from \"react-redux\";\nimport { DEFAULT_EXECUTE_ACTION_TIMEOUT_MS } from \"ee/constants/ApiConstants\";\nimport { evaluateActionBindings } from \"sagas/EvaluationsSaga\";\nimport { isBlobUrl, parseBlobUrl } from \"utils/AppsmithUtils\";\nimport { getType, Types } from \"utils/TypeHelpers\";\nimport { matchPath } from \"react-router\";\nimport {\n  API_EDITOR_BASE_PATH,\n  API_EDITOR_ID_PATH,\n  API_EDITOR_PATH_WITH_SELECTED_PAGE_ID,\n  INTEGRATION_EDITOR_PATH,\n  matchQueryBuilderPath,\n  QUERIES_EDITOR_BASE_PATH,\n  QUERIES_EDITOR_ID_PATH,\n} from \"constants/routes\";\nimport { SAAS_EDITOR_API_ID_PATH } from \"pages/Editor/SaaSEditor/constants\";\nimport { APP_MODE } from \"entities/App\";\nimport { FileDataTypes } from \"WidgetProvider/types\";\nimport { hideDebuggerErrors } from \"actions/debuggerActions\";\nimport {\n  ActionValidationError,\n  getErrorAsString,\n  PluginActionExecutionError,\n  PluginTriggerFailureError,\n  UserCancelledActionExecutionError,\n} from \"sagas/ActionExecution/errorUtils\";\nimport { shouldBeDefined, trimQueryString } from \"utils/helpers\";\nimport { requestModalConfirmationSaga } from \"sagas/UtilSagas\";\nimport { ModalType } from \"reducers/uiReducers/modalActionReducer\";\nimport { matchBasePath } from \"ee/pages/Editor/Explorer/helpers\";\nimport {\n  findDatatype,\n  isTrueObject,\n} from \"ee/workers/Evaluation/evaluationUtils\";\nimport { type Plugin, PluginType } from \"entities/Plugin\";\nimport { getIsAnvilEnabledInCurrentApplication } from \"../../layoutSystems/anvil/integrations/selectors\";\nimport { setDefaultActionDisplayFormat } from \"./PluginActionSagaUtils\";\nimport { checkAndLogErrorsIfCyclicDependency } from \"sagas/helper\";\nimport { toast } from \"@appsmith/ads\";\nimport type { TRunDescription } from \"workers/Evaluation/fns/actionFns\";\nimport { DEBUGGER_TAB_KEYS } from \"components/editorComponents/Debugger/constants\";\nimport { FILE_SIZE_LIMIT_FOR_BLOBS } from \"constants/WidgetConstants\";\nimport type { ActionData } from \"ee/reducers/entityReducers/actionsReducer\";\nimport { handleStoreOperations } from \"./StoreActionSaga\";\nimport { fetchPageAction } from \"actions/pageActions\";\nimport type { Datasource } from \"entities/Datasource\";\nimport { softRefreshDatasourceStructure } from \"actions/datasourceActions\";\nimport {\n  getCurrentEnvironmentDetails,\n  getCurrentEnvironmentName,\n} from \"ee/selectors/environmentSelectors\";\nimport { getIsActionCreatedInApp } from \"ee/utils/getIsActionCreatedInApp\";\nimport {\n  endSpan,\n  setAttributesToSpan,\n  startRootSpan,\n} from \"instrumentation/generateTraces\";\nimport {\n  getActionExecutionAnalytics,\n  getActionProperties,\n  getJSActionPathNameToDisplay,\n  getPluginActionNameToDisplay,\n} from \"ee/utils/actionExecutionUtils\";\nimport type { JSAction, JSCollection } from \"entities/JSCollection\";\nimport { getAllowedActionAnalyticsKeys } from \"constants/AppsmithActionConstants/formConfig/ActionAnalyticsConfig\";\nimport {\n  changeQuery,\n  isActionDirty,\n  isActionSaving,\n  setPluginActionEditorDebuggerState,\n} from \"PluginActionEditor/store\";\nimport { objectKeys } from \"@appsmith/utils\";\nimport type { Span } from \"instrumentation/types\";\nimport {\n  selectGitConnectModalOpen,\n  selectGitOpsModalOpen,\n} from \"selectors/gitModSelectors\";\nimport { createActionExecutionResponse } from \"./PluginActionSagaUtils\";\nimport { ActionRunBehaviour } from \"PluginActionEditor/types/PluginActionTypes\";\nimport { appsmithTelemetry } from \"instrumentation\";\n\ninterface FilePickerInstumentationObject {\n  numberOfFiles: number;\n  totalSize: number;\n  fileTypes: Array<string>;\n  fileSizes: Array<number>;\n}\n\nexport const getActionTimeout = (\n  state: DefaultRootState,\n  actionId: string,\n): number | undefined => {\n  const action = find(state.entities.actions, (a) => a.config.id === actionId);\n\n  if (action) {\n    const timeout = get(\n      action,\n      \"config.actionConfiguration.timeoutInMillisecond\",\n      DEFAULT_EXECUTE_ACTION_TIMEOUT_MS,\n    );\n\n    if (timeout) {\n      // Extra timeout padding to account for network calls\n      return timeout + 5000;\n    }\n\n    return undefined;\n  }\n\n  return undefined;\n};\n\nconst isErrorResponse = (response: ActionExecutionResponse) => {\n  return !response.data.isExecutionSuccess;\n};\n\n/**\n *\n * @param blobUrl string A blob url with type added a query param\n * @returns promise that resolves to file content\n */\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction* readBlob(blobUrl: string): any {\n  const [url, fileType] = parseBlobUrl(blobUrl);\n  const file = yield fetch(url).then(async (r) => r.blob());\n\n  return yield new Promise((resolve) => {\n    const reader = new FileReader();\n\n    if (fileType === FileDataTypes.Base64) {\n      reader.readAsDataURL(file);\n    } else if (fileType === FileDataTypes.Binary) {\n      if (file.size < FILE_SIZE_LIMIT_FOR_BLOBS) {\n        //check size of the file, if less than 5mb, go with binary string method\n        // TODO: this method is deprecated, use readAsText instead\n        reader.readAsBinaryString(file);\n      } else {\n        // For files greater than 5 mb, use array buffer method\n        // This is to remove the bloat from the file which is added\n        // when using read as binary string method\n        reader.readAsArrayBuffer(file);\n      }\n    } else {\n      reader.readAsText(file);\n    }\n\n    reader.onloadend = () => {\n      resolve(reader.result);\n    };\n  });\n}\n\n/**\n * This function resolves :\n * - individual objects containing blob urls\n * - blob urls directly\n * - else returns the value unchanged\n * - finds datatype of evaluated value\n * - binds dataype to payload\n *\n * @param value\n * @param executeActionRequest\n * @param index\n * @param isArray\n * @param arrDatatype\n */\n\nfunction* resolvingBlobUrls(\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  executeActionRequest: ExecuteActionRequest,\n  index: number,\n  isArray?: boolean,\n  arrDatatype?: string[],\n) {\n  //Get datatypes of evaluated value.\n  const dataType: string = findDatatype(value);\n\n  //If array elements then dont push datatypes to payload.\n  isArray\n    ? arrDatatype?.push(dataType)\n    : (executeActionRequest.paramProperties[`k${index}`] = {\n        datatype: dataType,\n      });\n\n  if (isTrueObject(value)) {\n    const blobUrlPaths: string[] = [];\n\n    objectKeys(value).forEach((propertyName) => {\n      if (isBlobUrl(value[propertyName])) {\n        blobUrlPaths.push(propertyName);\n      }\n    });\n\n    for (const blobUrlPath of blobUrlPaths) {\n      const blobUrl = value[blobUrlPath] as string;\n      const resolvedBlobValue: unknown = yield call(readBlob, blobUrl);\n\n      set(value, blobUrlPath, resolvedBlobValue);\n\n      // We need to store the url path map to be able to update the blob data\n      // and send the info to server\n\n      // Here we fetch the blobUrlPathMap from the action payload and update it\n      const blobUrlPathMap = get(value, \"blobUrlPaths\", {}) as Record<\n        string,\n        string\n      >;\n\n      set(blobUrlPathMap, blobUrlPath, blobUrl);\n      set(value, \"blobUrlPaths\", blobUrlPathMap);\n    }\n  } else if (isBlobUrl(value)) {\n    // @ts-expect-error: Values can take many types\n    value = yield call(readBlob, value);\n  }\n\n  return value;\n}\n\n// Function that updates the blob data in the action payload for large file\n// uploads\nfunction updateBlobDataFromUrls(\n  blobUrlPaths: Record<string, string>,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  newVal: any,\n  blobMap: string[],\n  blobDataMap: Record<string, Blob>,\n) {\n  Object.entries(blobUrlPaths as Record<string, string>).forEach(\n    // blobUrl: string eg: blob:1234-1234-1234?type=binary\n    ([path, blobUrl]) => {\n      if (isArrayBuffer(newVal[path])) {\n        // remove the ?type=binary from the blob url if present\n        const sanitisedBlobURL = blobUrl.split(\"?\")[0];\n\n        blobMap.push(sanitisedBlobURL);\n        set(blobDataMap, sanitisedBlobURL, new Blob([newVal[path]]));\n        set(newVal, path, sanitisedBlobURL);\n      }\n    },\n  );\n}\n\n/**\n * Api1\n * URL: https://example.com/{{Text1.text}}\n * Body: {\n *     \"name\": \"{{this.params.name}}\",\n *     \"age\": {{this.params.age}},\n *     \"gender\": {{Dropdown1.selectedOptionValue}}\n * }\n *\n * If you call\n * Api1.run(undefined, undefined, { name: \"Hetu\", age: Input1.text });\n *\n * executionParams is { name: \"Hetu\", age: Input1.text }\n * bindings is [\n *   \"Text1.text\",\n *   \"Dropdown1.selectedOptionValue\",\n *   \"this.params.name\",\n *   \"this.params.age\",\n * ]\n *\n * Return will be [\n *   { key: \"Text1.text\", value: \"updateUser\" },\n *   { key: \"Dropdown1.selectedOptionValue\", value: \"M\" },\n *   { key: \"this.params.name\", value: \"Hetu\" },\n *   { key: \"this.params.age\", value: 26 },\n * ]\n * @param bindings\n * @param formData\n * @param executeActionRequest\n * @param filePickerInstrumentation\n * @param executionParams\n */\nfunction* evaluateActionParams(\n  bindings: string[] | undefined,\n  formData: FormData,\n  executeActionRequest: ExecuteActionRequest,\n  filePickerInstrumentation: FilePickerInstumentationObject,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  executionParams?: Record<string, any> | string,\n) {\n  if (isNil(bindings) || bindings.length === 0) {\n    formData.append(\"executeActionDTO\", JSON.stringify(executeActionRequest));\n\n    return [];\n  }\n\n  // Evaluated all bindings of the actions. Pass executionParams if any\n  // @ts-expect-error: Values can take many types\n  const values = yield call(evaluateActionBindings, bindings, executionParams);\n\n  const bindingsMap: Record<string, string> = {};\n  const bindingBlob = [];\n  const evaluatedParams = zipObject(bindings, values);\n\n  // Maintain a blob data map to resolve blob urls of large files as array buffer\n  const blobDataMap: Record<string, Blob> = {};\n\n  // if json bindings have filepicker reference, we need to init the instrumentation object\n  // which we will send post execution\n  const recordFilePickerInstrumentation = bindings.some((binding) =>\n    binding.includes(\".files\"),\n  );\n\n  // Add keys values to formData for the multipart submission\n  for (let i = 0; i < bindings.length; i++) {\n    const key = bindings[i];\n    let value = isArray(values) && values[i];\n\n    let useBlobMaps = false;\n    // Maintain a blob map to resolve blob",
            "output_extracted": "import {\n  all,\n  call,\n  delay,\n  put,\n  select,\n  take,\n  takeLatest,\n} from \"redux-saga/effects\";\nimport {\n  clearActionResponse,\n  executePageLoadActions,\n  executePluginActionError,\n  executePluginActionRequest,\n  executePluginActionSuccess,\n  runAction,\n  updateAction,\n  updateActionData,\n} from \"actions/pluginActionActions\";\nimport { handleExecuteJSFunctionSaga } from \"sagas/JSPaneSagas\";\n\nimport type { ApplicationPayload } from \"entities/Application\";\nimport type { ReduxAction } from \"actions/ReduxActionTypes\";\nimport {\n  ReduxActionErrorTypes,\n  ReduxActionTypes,\n} from \"ee/constants/ReduxActionConstants\";\nimport type {\n  ActionExecutionResponse,\n  ActionResponse,\n  ExecuteActionRequest,\n  PaginationField,\n} from \"api/ActionAPI\";\nimport ActionAPI from \"api/ActionAPI\";\nimport {\n  getAction,\n  getCurrentActions,\n  getCurrentPageNameByActionId,\n  getDatasource,\n  getJSCollectionFromAllEntities,\n  getPlugin,\n} from \"ee/selectors/entitiesSelector\";\nimport {\n  getAppMode,\n  getCurrentApplication,\n} from \"ee/selectors/applicationSelectors\";\nimport {\n  find,\n  flatten,\n  get,\n  isArray,\n  isArrayBuffer,\n  isEmpty,\n  isNil,\n  isString,\n  set,\n  unset,\n  zipObject,\n} from \"lodash\";\nimport AppsmithConsole from \"utils/AppsmithConsole\";\nimport { ENTITY_TYPE, PLATFORM_ERROR } from \"ee/entities/AppsmithConsole/utils\";\nimport {\n  extractClientDefinedErrorMetadata,\n  validateResponse,\n} from \"sagas/ErrorSagas\";\nimport AnalyticsUtil from \"ee/utils/AnalyticsUtil\";\nimport type { Action } from \"entities/Action\";\nimport { ActionExecutionContext } from \"entities/Action\";\nimport LOG_TYPE from \"entities/AppsmithConsole/logtype\";\nimport {\n  ACTION_EXECUTION_CANCELLED,\n  ACTION_EXECUTION_FAILED,\n  createMessage,\n  ERROR_ACTION_EXECUTE_FAIL,\n  ERROR_FAIL_ON_PAGE_LOAD_ACTIONS,\n  ERROR_PLUGIN_ACTION_EXECUTE,\n  SWITCH_ENVIRONMENT_SUCCESS,\n} from \"ee/constants/messages\";\nimport type {\n  LayoutOnLoadActionErrors,\n  PageAction,\n} from \"constants/AppsmithActionConstants/ActionConstants\";\nimport { EventType } from \"constants/AppsmithActionConstants/ActionConstants\";\nimport {\n  getCurrentApplicationId,\n  getCurrentBasePageId,\n  getCurrentPageId,\n  getIsSavingEntity,\n  getLayoutOnLoadActions,\n  getLayoutOnLoadIssues,\n  getLayoutOnUnloadActions,\n} from \"selectors/editorSelectors\";\nimport log from \"loglevel\";\nimport { EMPTY_RESPONSE } from \"components/editorComponents/emptyResponse\";\nimport type { DefaultRootState } from \"react-redux\";\nimport { DEFAULT_EXECUTE_ACTION_TIMEOUT_MS } from \"ee/constants/ApiConstants\";\nimport { evaluateActionBindings } from \"sagas/EvaluationsSaga\";\nimport { isBlobUrl, parseBlobUrl } from \"utils/AppsmithUtils\";\nimport { getType, Types } from \"utils/TypeHelpers\";\nimport { matchPath } from \"react-router\";\nimport {\n  API_EDITOR_BASE_PATH,\n  API_EDITOR_ID_PATH,\n  API_EDITOR_PATH_WITH_SELECTED_PAGE_ID,\n  INTEGRATION_EDITOR_PATH,\n  matchQueryBuilderPath,\n  QUERIES_EDITOR_BASE_PATH,\n  QUERIES_EDITOR_ID_PATH,\n} from \"constants/routes\";\nimport { SAAS_EDITOR_API_ID_PATH } from \"pages/Editor/SaaSEditor/constants\";\nimport { APP_MODE } from \"entities/App\";\nimport { FileDataTypes } from \"WidgetProvider/types\";\nimport { hideDebuggerErrors } from \"actions/debuggerActions\";\nimport {\n  ActionValidationError,\n  getErrorAsString,\n  PluginActionExecutionError,\n  PluginTriggerFailureError,\n  UserCancelledActionExecutionError,\n} from \"sagas/ActionExecution/errorUtils\";\nimport { shouldBeDefined, trimQueryString } from \"utils/helpers\";\nimport { requestModalConfirmationSaga } from \"sagas/UtilSagas\";\nimport { ModalType } from \"reducers/uiReducers/modalActionReducer\";\nimport { matchBasePath } from \"ee/pages/Editor/Explorer/helpers\";\nimport {\n  findDatatype,\n  isTrueObject,\n} from \"ee/workers/Evaluation/evaluationUtils\";\nimport { type Plugin, PluginType } from \"entities/Plugin\";\nimport { getIsAnvilEnabledInCurrentApplication } from \"../../layoutSystems/anvil/integrations/selectors\";\nimport { setDefaultActionDisplayFormat } from \"./PluginActionSagaUtils\";\nimport { checkAndLogErrorsIfCyclicDependency } from \"sagas/helper\";\nimport { toast } from \"@appsmith/ads\";\nimport type { TRunDescription } from \"workers/Evaluation/fns/actionFns\";\nimport { DEBUGGER_TAB_KEYS } from \"components/editorComponents/Debugger/constants\";\nimport { FILE_SIZE_LIMIT_FOR_BLOBS } from \"constants/WidgetConstants\";\nimport type { ActionData } from \"ee/reducers/entityReducers/actionsReducer\";\nimport { handleStoreOperations } from \"./StoreActionSaga\";\nimport { fetchPageAction } from \"actions/pageActions\";\nimport type { Datasource } from \"entities/Datasource\";\nimport { softRefreshDatasourceStructure } from \"actions/datasourceActions\";\nimport {\n  getCurrentEnvironmentDetails,\n  getCurrentEnvironmentName,\n} from \"ee/selectors/environmentSelectors\";\nimport { getIsActionCreatedInApp } from \"ee/utils/getIsActionCreatedInApp\";\nimport {\n  endSpan,\n  setAttributesToSpan,\n  startRootSpan,\n} from \"instrumentation/generateTraces\";\nimport {\n  getActionExecutionAnalytics,\n  getActionProperties,\n  getJSActionPathNameToDisplay,\n  getPluginActionNameToDisplay,\n} from \"ee/utils/actionExecutionUtils\";\nimport type { JSAction, JSCollection } from \"entities/JSCollection\";\nimport { getAllowedActionAnalyticsKeys } from \"constants/AppsmithActionConstants/formConfig/ActionAnalyticsConfig\";\nimport {\n  changeQuery,\n  isActionDirty,\n  isActionSaving,\n  setPluginActionEditorDebuggerState,\n} from \"PluginActionEditor/store\";\nimport { objectKeys } from \"@appsmith/utils\";\nimport type { Span } from \"instrumentation/types\";\nimport {\n  selectGitConnectModalOpen,\n  selectGitOpsModalOpen,\n} from \"selectors/gitModSelectors\";\nimport { createActionExecutionResponse } from \"./PluginActionSagaUtils\";\nimport { ActionRunBehaviour } from \"PluginActionEditor/types/PluginActionTypes\";\nimport { appsmithTelemetry } from \"instrumentation\";\n\ninterface FilePickerInstumentationObject {\n  numberOfFiles: number;\n  totalSize: number;\n  fileTypes: Array<string>;\n  fileSizes: Array<number>;\n}\n\nexport const getActionTimeout = (\n  state: DefaultRootState,\n  actionId: string,\n): number | undefined => {\n  const action = find(state.entities.actions, (a) => a.config.id === actionId);\n\n  if (action) {\n    const timeout = get(\n      action,\n      \"config.actionConfiguration.timeoutInMillisecond\",\n      DEFAULT_EXECUTE_ACTION_TIMEOUT_MS,\n    );\n\n    if (timeout) {\n      // Extra timeout padding to account for network calls\n      return timeout + 5000;\n    }\n\n    return undefined;\n  }\n\n  return undefined;\n};\n\nconst isErrorResponse = (response: ActionExecutionResponse) => {\n  return !response.data.isExecutionSuccess;\n};\n\n/**\n *\n * @param blobUrl string A blob url with type added a query param\n * @returns promise that resolves to file content\n */\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction* readBlob(blobUrl: string): any {\n  const [url, fileType] = parseBlobUrl(blobUrl);\n  const file = yield fetch(url).then(async (r) => r.blob());\n\n  return yield new Promise((resolve) => {\n    const reader = new FileReader();\n\n    if (fileType === FileDataTypes.Base64) {\n      reader.readAsDataURL(file);\n    } else if (fileType === FileDataTypes.Binary) {\n      if (file.size < FILE_SIZE_LIMIT_FOR_BLOBS) {\n        //check size of the file, if less than 5mb, go with binary string method\n        // TODO: this method is deprecated, use readAsText instead\n        reader.readAsBinaryString(file);\n      } else {\n        // For files greater than 5 mb, use array buffer method\n        // This is to remove the bloat from the file which is added\n        // when using read as binary string method\n        reader.readAsArrayBuffer(file);\n      }\n    } else {\n      reader.readAsText(file);\n    }\n\n    reader.onloadend = () => {\n      resolve(reader.result);\n    };\n  });\n}\n\n/**\n * This function resolves :\n * - individual objects containing blob urls\n * - blob urls directly\n * - else returns the value unchanged\n * - finds datatype of evaluated value\n * - binds dataype to payload\n *\n * @param value\n * @param executeActionRequest\n * @param index\n * @param isArray\n * @param arrDatatype\n */\n\nfunction* resolvingBlobUrls(\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  executeActionRequest: ExecuteActionRequest,\n  index: number,\n  isArray?: boolean,\n  arrDatatype?: string[],\n) {\n  //Get datatypes of evaluated value.\n  const dataType: string = findDatatype(value);\n\n  //If array elements then dont push datatypes to payload.\n  isArray\n    ? arrDatatype?.push(dataType)\n    : (executeActionRequest.paramProperties[`k${index}`] = {\n        datatype: dataType,\n      });\n\n  if (isTrueObject(value)) {\n    const blobUrlPaths: string[] = [];\n\n    objectKeys(value).forEach((propertyName) => {\n      if (isBlobUrl(value[propertyName])) {\n        blobUrlPaths.push(propertyName);\n      }\n    });\n\n    for (const blobUrlPath of blobUrlPaths) {\n      const blobUrl = value[blobUrlPath] as string;\n      const resolvedBlobValue: unknown = yield call(readBlob, blobUrl);\n\n      set(value, blobUrlPath, resolvedBlobValue);\n\n      // We need to store the url path map to be able to update the blob data\n      // and send the info to server\n\n      // Here we fetch the blobUrlPathMap from the action payload and update it\n      const blobUrlPathMap = get(value, \"blobUrlPaths\", {}) as Record<\n        string,\n        string\n      >;\n\n      set(blobUrlPathMap, blobUrlPath, blobUrl);\n      set(value, \"blobUrlPaths\", blobUrlPathMap);\n    }\n  } else if (isBlobUrl(value)) {\n    // @ts-expect-error: Values can take many types\n    value = yield call(readBlob, value);\n  }\n\n  return value;\n}\n\n// Function that updates the blob data in the action payload for large file\n// uploads\nfunction updateBlobDataFromUrls(\n  blobUrlPaths: Record<string, string>,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  newVal: any,\n  blobMap: string[],\n  blobDataMap: Record<string, Blob>,\n) {\n  Object.entries(blobUrlPaths as Record<string, string>).forEach(\n    // blobUrl: string eg: blob:1234-1234-1234?type=binary\n    ([path, blobUrl]) => {\n      if (isArrayBuffer(newVal[path])) {\n        // remove the ?type=binary from the blob url if present\n        const sanitisedBlobURL = blobUrl.split(\"?\")[0];\n\n        blobMap.push(sanitisedBlobURL);\n        set(blobDataMap, sanitisedBlobURL, new Blob([newVal[path]]));\n        set(newVal, path, sanitisedBlobURL);\n      }\n    },\n  );\n}\n\n/**\n * Api1\n * URL: https://example.com/{{Text1.text}}\n * Body: {\n *     \"name\": \"{{this.params.name}}\",\n *     \"age\": {{this.params.age}},\n *     \"gender\": {{Dropdown1.selectedOptionValue}}\n * }\n *\n * If you call\n * Api1.run(undefined, undefined, { name: \"Hetu\", age: Input1.text });\n *\n * executionParams is { name: \"Hetu\", age: Input1.text }\n * bindings is [\n *   \"Text1.text\",\n *   \"Dropdown1.selectedOptionValue\",\n *   \"this.params.name\",\n *   \"this.params.age\",\n * ]\n *\n * Return will be [\n *   { key: \"Text1.text\", value: \"updateUser\" },\n *   { key: \"Dropdown1.selectedOptionValue\", value: \"M\" },\n *   { key: \"this.params.name\", value: \"Hetu\" },\n *   { key: \"this.params.age\", value: 26 },\n * ]\n * @param bindings\n * @param formData\n * @param executeActionRequest\n * @param filePickerInstrumentation\n * @param executionParams\n */\nfunction* evaluateActionParams(\n  bindings: string[] | undefined,\n  formData: FormData,\n  executeActionRequest: ExecuteActionRequest,\n  filePickerInstrumentation: FilePickerInstumentationObject,\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  executionParams?: Record<string, any> | string,\n) {\n  if (isNil(bindings) || bindings.length === 0) {\n    formData.append(\"executeActionDTO\", JSON.stringify(executeActionRequest));\n\n    return [];\n  }\n\n  // Evaluated all bindings of the actions. Pass executionParams if any\n  // @ts-expect-error: Values can take many types\n  const values = yield call(evaluateActionBindings, bindings, executionParams);\n\n  const bindingsMap: Record<string, string> = {};\n  const bindingBlob = [];\n  const evaluatedParams = zipObject(bindings, values);\n\n  // Maintain a blob data map to resolve blob urls of large files as array buffer\n  const blobDataMap: Record<string, Blob> = {};\n\n  // if json bindings have filepicker reference, we need to init the instrumentation object\n  // which we will send post execution\n  const recordFilePickerInstrumentation = bindings.some((binding) =>\n    binding.includes(\".files\"),\n  );\n\n  // Add keys values to formData for the multipart submission\n  for (let i = 0; i < bindings.length; i++) {\n    const key = bindings[i];\n    let value = isArray(values) && values[i];\n\n    let useBlobMaps = false;\n    // Maintain a blob map to resolve blob",
            "cost": 0.18515500000000001
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/selectors/editorSelectors.tsx": {
            "output": "import { createSelector } from \"reselect\";\n\nimport type { DefaultRootState } from \"react-redux\";\nimport type {\n  CanvasWidgetsReduxState,\n  FlattenedWidgetProps,\n} from \"ee/reducers/entityReducers/canvasWidgetsReducer\";\nimport type {\n  AppLayoutConfig,\n  PageListReduxState,\n} from \"reducers/entityReducers/pageListReducer\";\nimport type { WidgetCardProps, WidgetProps } from \"widgets/BaseWidget\";\n\nimport { ApplicationVersion } from \"ee/actions/applicationActions\";\nimport type {\n  OccupiedSpace,\n  WidgetSpace,\n} from \"constants/CanvasEditorConstants\";\nimport { PLACEHOLDER_APP_SLUG, PLACEHOLDER_PAGE_SLUG } from \"constants/routes\";\nimport { DefaultDimensionMap, RenderModes } from \"constants/WidgetConstants\";\nimport { APP_MODE } from \"entities/App\";\nimport { find, sortBy } from \"lodash\";\nimport {\n  getDataTree,\n  getLoadingEntities,\n  getConfigTree,\n} from \"selectors/dataTreeSelectors\";\nimport type { MainCanvasReduxState } from \"ee/reducers/uiReducers/mainCanvasReducer\";\n\nimport { getActionEditorSavingMap } from \"PluginActionEditor/store\";\nimport {\n  getCanvasWidgets,\n  getAllJSCollectionActions,\n  getJSCollections,\n} from \"ee/selectors/entitiesSelector\";\nimport { checkIsDropTarget } from \"WidgetProvider/factory/helpers\";\nimport { buildChildWidgetTree } from \"utils/widgetRenderUtils\";\nimport { LOCAL_STORAGE_KEYS } from \"utils/localStorage\";\nimport type { CanvasWidgetStructure } from \"WidgetProvider/types\";\nimport { denormalize } from \"utils/canvasStructureHelpers\";\nimport { isAutoHeightEnabledForWidget } from \"widgets/WidgetUtils\";\nimport WidgetFactory from \"WidgetProvider/factory\";\nimport { isAirgapped } from \"ee/utils/airgapHelpers\";\nimport { getIsAnonymousDataPopupVisible } from \"./onboardingSelectors\";\nimport { WDS_V2_WIDGET_MAP } from \"widgets/wds/constants\";\nimport { LayoutSystemTypes } from \"layoutSystems/types\";\nimport { getLayoutSystemType } from \"./layoutSystemSelectors\";\nimport { protectedModeSelector } from \"./gitSyncSelectors\";\nimport { getIsAnvilLayout } from \"layoutSystems/anvil/integrations/selectors\";\nimport { getCurrentApplication } from \"ee/selectors/applicationSelectors\";\nimport type { Page } from \"entities/Page\";\nimport { objectKeys } from \"@appsmith/utils\";\nimport type { MetaWidgetsReduxState } from \"reducers/entityReducers/metaWidgetsReducer\";\nimport { ActionRunBehaviour } from \"PluginActionEditor/types/PluginActionTypes\";\nimport { getWidgetConfigsVersion } from \"WidgetProvider/factory/widgetConfigVersion\";\n\nconst getIsDraggingOrResizing = (state: DefaultRootState) =>\n  state.ui.widgetDragResize.isResizing || state.ui.widgetDragResize.isDragging;\n\nconst getIsResizing = (state: DefaultRootState) =>\n  state.ui.widgetDragResize.isResizing;\n\nconst getPageListState = (state: DefaultRootState) => state.entities.pageList;\n\nconst getWidgets = (state: DefaultRootState): CanvasWidgetsReduxState =>\n  state.entities.canvasWidgets;\n\nexport const getIsEditorInitialized = (state: DefaultRootState) =>\n  state.ui.editor.initialized;\n\nexport const getIsWidgetConfigBuilt = (state: DefaultRootState) =>\n  state.ui.editor.widgetConfigBuilt;\n\nexport const getIsEditorLoading = (state: DefaultRootState) =>\n  state.ui.editor.loadingStates.loading;\n\nexport const getIsFetchingPage = (state: DefaultRootState) =>\n  state.ui.editor.loadingStates.isPageSwitching;\n\nexport const getLoadingError = (state: DefaultRootState) =>\n  state.ui.editor.loadingStates.loadingError;\n\nexport const getIsPageSaving = createSelector(\n  [\n    getActionEditorSavingMap,\n    (state: DefaultRootState) => state.ui.jsPane.isSaving,\n    (state: DefaultRootState) => state.ui.appTheming.isSaving,\n    (state: DefaultRootState) =>\n      state.ui.applications.isSavingNavigationSetting,\n    (state: DefaultRootState) => state.ui.editor.loadingStates.savingEntity,\n    (state: DefaultRootState) => state.ui.editor.loadingStates.saving,\n  ],\n  (\n    savingActions,\n    savingJSObjects,\n    isSavingAppTheme,\n    isSavingNavigationSetting,\n    isEditorSavingEntity,\n    isEditorSaving,\n  ) => {\n    const areActionsSaving = objectKeys(savingActions).some(\n      (actionId) => savingActions[actionId],\n    );\n    const areJsObjectsSaving = objectKeys(savingJSObjects).some(\n      (collectionId) => savingJSObjects[collectionId],\n    );\n\n    return (\n      isEditorSavingEntity ||\n      areActionsSaving ||\n      areJsObjectsSaving ||\n      isSavingAppTheme ||\n      isEditorSaving ||\n      isSavingNavigationSetting\n    );\n  },\n);\n\nexport const snipingModeSelector = (state: DefaultRootState) =>\n  state.ui.editor.isSnipingMode;\n\nexport const snipingModeBindToSelector = (state: DefaultRootState) =>\n  state.ui.editor.snipModeBindTo;\n\nexport const getPageSavingError = (state: DefaultRootState) => {\n  return state.ui.editor.loadingStates.savingError;\n};\n\nexport const getLayoutOnLoadActions = (state: DefaultRootState) =>\n  state.ui.editor.pageActions || [];\n\nexport const getLayoutOnUnloadActions = createSelector(\n  getAllJSCollectionActions,\n  (jsActions) => {\n    return jsActions.filter((action) => {\n      return action.runBehaviour === ActionRunBehaviour.ON_PAGE_UNLOAD;\n    });\n  },\n);\n\nexport const getLayoutOnLoadIssues = (state: DefaultRootState) => {\n  return state.ui.editor.layoutOnLoadActionErrors || [];\n};\n\nexport const getOnLoadActionsWithExecutionStatus = (state: DefaultRootState) =>\n  state.ui.editor.onLoadActionExecution;\n\nexport const getIsPublishingApplication = (state: DefaultRootState) =>\n  state.ui.editor.loadingStates.publishing;\n\nexport const getPublishingError = (state: DefaultRootState) =>\n  state.ui.editor.loadingStates.publishingError;\n\nexport const getCurrentLayoutId = (\n  state: DefaultRootState,\n): string | undefined => state.ui.editor.currentLayoutId;\n\nexport const getPageList = (state: DefaultRootState) =>\n  state.entities.pageList.pages;\n\nexport const getPageById = (pageId: string) =>\n  createSelector(getPageList, (pages: Page[]) =>\n    pages.find((page) => page.pageId === pageId),\n  );\n\nexport const getPageByBaseId = (basePageId: string) =>\n  createSelector(getPageList, (pages: Page[]) =>\n    pages.find((page) => page.basePageId === basePageId),\n  );\n\nexport const getCurrentPageId = (state: DefaultRootState) =>\n  state.entities.pageList.currentPageId;\n\nexport const getCurrentBasePageId = (state: DefaultRootState) =>\n  state.entities.pageList.currentBasePageId;\n\nexport const getBasePageIdFromStaticSlug = createSelector(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [getPageList, (_: any, staticPageSlug: string) => staticPageSlug],\n  (pages: Page[], staticPageSlug: string) => {\n    if (!staticPageSlug || !pages.length) {\n      return null;\n    }\n\n    // Find page by matching uniqueSlug property\n    const matchingPage = pages.find(\n      (page) => page.uniqueSlug === staticPageSlug,\n    );\n\n    if (matchingPage) {\n      return matchingPage.basePageId;\n    }\n\n    return null;\n  },\n);\n\nexport const getCurrentPagePermissions = createSelector(\n  getCurrentPageId,\n  getPageList,\n  (pageId, pages) => {\n    pages.find((page) => page.pageId === pageId);\n  },\n);\n\nexport const getPagePermissions = (state: DefaultRootState) => {\n  const pageId = getCurrentPageId(state);\n  const page = find(state.entities.pageList.pages, { pageId });\n\n  return page?.userPermissions || [];\n};\n\nexport const selectCurrentPageSlug = createSelector(\n  getCurrentPageId,\n  getPageList,\n  (pageId, pages) =>\n    pages.find((page) => page.pageId === pageId)?.slug || PLACEHOLDER_PAGE_SLUG,\n);\n\nexport const getCurrentPageDescription = createSelector(\n  getCurrentPageId,\n  getPageList,\n  (pageId, pages) => pages.find((page) => page.pageId === pageId)?.description,\n);\n\nexport const selectPageSlugToIdMap = createSelector(getPageList, (pages) =>\n  pages.reduce(\n    (acc, page: Page) => {\n      // Comeback\n      acc[page.pageId] = page.slug || \"\";\n\n      return acc;\n    },\n    {} as Record<string, string>,\n  ),\n);\n\nexport const getCurrentApplicationId = (state: DefaultRootState) =>\n  state.entities.pageList.applicationId || \"\";\n\nexport const getCurrentBaseApplicationId = (state: DefaultRootState) =>\n  state.entities.pageList.baseApplicationId || \"\";\n\nexport const selectCurrentApplicationSlug = (state: DefaultRootState) =>\n  state.ui.applications.currentApplication?.slug || PLACEHOLDER_APP_SLUG;\n\nexport const selectApplicationVersion = (state: DefaultRootState) =>\n  state.ui.applications.currentApplication?.applicationVersion ||\n  ApplicationVersion.DEFAULT;\n\nexport const getIsStaticUrlEnabled = (state: DefaultRootState) =>\n  !!state.ui.applications.currentApplication?.staticUrlSettings?.enabled;\n\nexport const selectPageSlugById = (pageId: string) =>\n  createSelector(getPageList, (pages) => {\n    const page = pages.find((page) => page.pageId === pageId);\n\n    return page?.slug || PLACEHOLDER_PAGE_SLUG;\n  });\n\nexport const selectURLSlugs = createSelector(\n  getCurrentApplication,\n  getPageList,\n  getCurrentPageId,\n  (application, pages, pageId) => {\n    const applicationSlug = application?.slug || PLACEHOLDER_APP_SLUG;\n    const currentPage: Page | undefined = pages.find(\n      (page) => page.pageId === pageId,\n    );\n    const pageSlug = currentPage?.slug || PLACEHOLDER_PAGE_SLUG;\n    const customSlug = currentPage?.customSlug;\n\n    return { applicationSlug, pageSlug, customSlug };\n  },\n);\n\nexport const getRenderMode = (state: DefaultRootState) => {\n  return state.entities.app.mode === APP_MODE.EDIT\n    ? RenderModes.CANVAS\n    : RenderModes.PAGE;\n};\n\nexport const getIsViewMode = (state: DefaultRootState) =>\n  state.entities.app.mode === APP_MODE.PUBLISHED;\n\nexport const getIsPersistingPageSlug = (\n  state: DefaultRootState,\n  pageId: string,\n) => state.entities.app.pageSlug[pageId]?.isPersisting || false;\n\nexport const getIsErrorPersistingPageSlug = (\n  state: DefaultRootState,\n  pageId: string,\n) => state.entities.app.pageSlug[pageId]?.isError || false;\n\nexport const getIsValidatingPageSlug = (state: DefaultRootState) =>\n  state.entities.app.pageSlugValidation.isValidating;\n\nexport const getIsPageSlugValid = (state: DefaultRootState) =>\n  state.entities.app.pageSlugValidation.isValid;\n\nexport const getViewModePageList = createSelector(\n  getPageList,\n  getCurrentPageId,\n  (pageList: PageListReduxState[\"pages\"], currentPageId?: string) => {\n    if (currentPageId) {\n      const currentPage = pageList.find(\n        (page) => page.pageId === currentPageId,\n      );\n\n      if (!!currentPage?.isHidden) {\n        return [currentPage];\n      }\n\n      const visiblePages = pageList.filter((page) => !page.isHidden);\n\n      return visiblePages;\n    }\n\n    return [];\n  },\n);\n\nconst defaultLayout: AppLayoutConfig = {\n  type: \"FLUID\",\n};\n\nconst getAppLayout = (state: DefaultRootState) =>\n  state.ui.applications.currentApplication?.appLayout || defaultLayout;\n\nexport const getIsMobileCanvasLayout = createSelector(\n  getAppLayout,\n  (appLayout: AppLayoutConfig) => appLayout.type === \"MOBILE\",\n);\n\nexport const getIsAutoLayout = createSelector(\n  getLayoutSystemType,\n  (layoutSystemType) => layoutSystemType === LayoutSystemTypes.AUTO,\n);\n\nexport const getCurrentApplicationLayout = createSelector(\n  getAppLayout,\n  getLayoutSystemType,\n  (appLayout: AppLayoutConfig, layoutSystemType) => {\n    return layoutSystemType === LayoutSystemTypes.FIXED\n      ? appLayout\n      : defaultLayout;\n  },\n);\n\nexport const getCanvasWidth = (state: DefaultRootState) =>\n  state.ui.mainCanvas.width;\nexport const getMainCanvasProps = (state: DefaultRootState) =>\n  state.ui.mainCanvas;\n\nexport const getMetaWidgets = (state: DefaultRootState) =>\n  state.entities.metaWidgets;\n\n/**\n * What are template meta widgets?\n *\n * A template meta widget is as meta widget which can be used as a template widget.\n * At the time of writing this, the use of template widget is with the List widget, where\n * a template widget is any widget that is dropped inside the List widget first row canvas.\n *\n * Why do we need a template meta widget?\n *\n * A list widget take the template widgets and clones it multiple times and renders it as rows.\n * These template widgets in an app of a list widget reside in canvasWidget reducer and is part of the\n * DSL. But when a list widget is part of a UI module and this UI module is used in an app, all the widget\n * under this module widget are meta widget inlcuding the list widget itself. Since all the widget are meta\n * widgets and the list widget also genereates meta widgets, we need to have a way to identify these template\n * widgets and feed it to the List widget so that it can replicate and behave natively.\n *\n * How do we identify a template meta widget?\n *\n * A template meta widget is any meta widget which has the property `isTemplate` set to true.\n * The usage of this property is upon the widget to decide how to use it and currently only the List widget\n * uses this property.\n *\n */\n\nexport const getTemplateMetaWidgets = createSelector(\n  getMetaWidgets,\n  (metaWidgets) => {\n    const templateMetaWidgets: MetaWidgetsReduxState = {};\n\n    Object.values(metaWidgets).forEach((metaWidget) => {\n      if (metaWidget.isTemplate) {\n        templateMetaWidgets[metaWidget.widgetId] = metaWidget;\n      }\n    });\n\n    return templateMetaWidgets;\n  },\n);\n\nexport const getMetaWidget = (metaWidgetId: string) =>\n  createSelector(getMetaWidgets, (metaWidgets) => {\n    return metaWidgets[metaWidgetId];",
            "output_extracted": "import { createSelector } from \"reselect\";\n\nimport type { DefaultRootState } from \"react-redux\";\nimport type {\n  CanvasWidgetsReduxState,\n  FlattenedWidgetProps,\n} from \"ee/reducers/entityReducers/canvasWidgetsReducer\";\nimport type {\n  AppLayoutConfig,\n  PageListReduxState,\n} from \"reducers/entityReducers/pageListReducer\";\nimport type { WidgetCardProps, WidgetProps } from \"widgets/BaseWidget\";\n\nimport { ApplicationVersion } from \"ee/actions/applicationActions\";\nimport type {\n  OccupiedSpace,\n  WidgetSpace,\n} from \"constants/CanvasEditorConstants\";\nimport { PLACEHOLDER_APP_SLUG, PLACEHOLDER_PAGE_SLUG } from \"constants/routes\";\nimport { DefaultDimensionMap, RenderModes } from \"constants/WidgetConstants\";\nimport { APP_MODE } from \"entities/App\";\nimport { find, sortBy } from \"lodash\";\nimport {\n  getDataTree,\n  getLoadingEntities,\n  getConfigTree,\n} from \"selectors/dataTreeSelectors\";\nimport type { MainCanvasReduxState } from \"ee/reducers/uiReducers/mainCanvasReducer\";\n\nimport { getActionEditorSavingMap } from \"PluginActionEditor/store\";\nimport {\n  getCanvasWidgets,\n  getAllJSCollectionActions,\n  getJSCollections,\n} from \"ee/selectors/entitiesSelector\";\nimport { checkIsDropTarget } from \"WidgetProvider/factory/helpers\";\nimport { buildChildWidgetTree } from \"utils/widgetRenderUtils\";\nimport { LOCAL_STORAGE_KEYS } from \"utils/localStorage\";\nimport type { CanvasWidgetStructure } from \"WidgetProvider/types\";\nimport { denormalize } from \"utils/canvasStructureHelpers\";\nimport { isAutoHeightEnabledForWidget } from \"widgets/WidgetUtils\";\nimport WidgetFactory from \"WidgetProvider/factory\";\nimport { isAirgapped } from \"ee/utils/airgapHelpers\";\nimport { getIsAnonymousDataPopupVisible } from \"./onboardingSelectors\";\nimport { WDS_V2_WIDGET_MAP } from \"widgets/wds/constants\";\nimport { LayoutSystemTypes } from \"layoutSystems/types\";\nimport { getLayoutSystemType } from \"./layoutSystemSelectors\";\nimport { protectedModeSelector } from \"./gitSyncSelectors\";\nimport { getIsAnvilLayout } from \"layoutSystems/anvil/integrations/selectors\";\nimport { getCurrentApplication } from \"ee/selectors/applicationSelectors\";\nimport type { Page } from \"entities/Page\";\nimport { objectKeys } from \"@appsmith/utils\";\nimport type { MetaWidgetsReduxState } from \"reducers/entityReducers/metaWidgetsReducer\";\nimport { ActionRunBehaviour } from \"PluginActionEditor/types/PluginActionTypes\";\nimport { getWidgetConfigsVersion } from \"WidgetProvider/factory/widgetConfigVersion\";\n\nconst getIsDraggingOrResizing = (state: DefaultRootState) =>\n  state.ui.widgetDragResize.isResizing || state.ui.widgetDragResize.isDragging;\n\nconst getIsResizing = (state: DefaultRootState) =>\n  state.ui.widgetDragResize.isResizing;\n\nconst getPageListState = (state: DefaultRootState) => state.entities.pageList;\n\nconst getWidgets = (state: DefaultRootState): CanvasWidgetsReduxState =>\n  state.entities.canvasWidgets;\n\nexport const getIsEditorInitialized = (state: DefaultRootState) =>\n  state.ui.editor.initialized;\n\nexport const getIsWidgetConfigBuilt = (state: DefaultRootState) =>\n  state.ui.editor.widgetConfigBuilt;\n\nexport const getIsEditorLoading = (state: DefaultRootState) =>\n  state.ui.editor.loadingStates.loading;\n\nexport const getIsFetchingPage = (state: DefaultRootState) =>\n  state.ui.editor.loadingStates.isPageSwitching;\n\nexport const getLoadingError = (state: DefaultRootState) =>\n  state.ui.editor.loadingStates.loadingError;\n\nexport const getIsPageSaving = createSelector(\n  [\n    getActionEditorSavingMap,\n    (state: DefaultRootState) => state.ui.jsPane.isSaving,\n    (state: DefaultRootState) => state.ui.appTheming.isSaving,\n    (state: DefaultRootState) =>\n      state.ui.applications.isSavingNavigationSetting,\n    (state: DefaultRootState) => state.ui.editor.loadingStates.savingEntity,\n    (state: DefaultRootState) => state.ui.editor.loadingStates.saving,\n  ],\n  (\n    savingActions,\n    savingJSObjects,\n    isSavingAppTheme,\n    isSavingNavigationSetting,\n    isEditorSavingEntity,\n    isEditorSaving,\n  ) => {\n    const areActionsSaving = objectKeys(savingActions).some(\n      (actionId) => savingActions[actionId],\n    );\n    const areJsObjectsSaving = objectKeys(savingJSObjects).some(\n      (collectionId) => savingJSObjects[collectionId],\n    );\n\n    return (\n      isEditorSavingEntity ||\n      areActionsSaving ||\n      areJsObjectsSaving ||\n      isSavingAppTheme ||\n      isEditorSaving ||\n      isSavingNavigationSetting\n    );\n  },\n);\n\nexport const snipingModeSelector = (state: DefaultRootState) =>\n  state.ui.editor.isSnipingMode;\n\nexport const snipingModeBindToSelector = (state: DefaultRootState) =>\n  state.ui.editor.snipModeBindTo;\n\nexport const getPageSavingError = (state: DefaultRootState) => {\n  return state.ui.editor.loadingStates.savingError;\n};\n\nexport const getLayoutOnLoadActions = (state: DefaultRootState) =>\n  state.ui.editor.pageActions || [];\n\nexport const getLayoutOnUnloadActions = createSelector(\n  getAllJSCollectionActions,\n  (jsActions) => {\n    return jsActions.filter((action) => {\n      return action.runBehaviour === ActionRunBehaviour.ON_PAGE_UNLOAD;\n    });\n  },\n);\n\nexport const getLayoutOnLoadIssues = (state: DefaultRootState) => {\n  return state.ui.editor.layoutOnLoadActionErrors || [];\n};\n\nexport const getOnLoadActionsWithExecutionStatus = (state: DefaultRootState) =>\n  state.ui.editor.onLoadActionExecution;\n\nexport const getIsPublishingApplication = (state: DefaultRootState) =>\n  state.ui.editor.loadingStates.publishing;\n\nexport const getPublishingError = (state: DefaultRootState) =>\n  state.ui.editor.loadingStates.publishingError;\n\nexport const getCurrentLayoutId = (\n  state: DefaultRootState,\n): string | undefined => state.ui.editor.currentLayoutId;\n\nexport const getPageList = (state: DefaultRootState) =>\n  state.entities.pageList.pages;\n\nexport const getPageById = (pageId: string) =>\n  createSelector(getPageList, (pages: Page[]) =>\n    pages.find((page) => page.pageId === pageId),\n  );\n\nexport const getPageByBaseId = (basePageId: string) =>\n  createSelector(getPageList, (pages: Page[]) =>\n    pages.find((page) => page.basePageId === basePageId),\n  );\n\nexport const getCurrentPageId = (state: DefaultRootState) =>\n  state.entities.pageList.currentPageId;\n\nexport const getCurrentBasePageId = (state: DefaultRootState) =>\n  state.entities.pageList.currentBasePageId;\n\nexport const getBasePageIdFromStaticSlug = createSelector(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [getPageList, (_: any, staticPageSlug: string) => staticPageSlug],\n  (pages: Page[], staticPageSlug: string) => {\n    if (!staticPageSlug || !pages.length) {\n      return null;\n    }\n\n    // Find page by matching uniqueSlug property\n    const matchingPage = pages.find(\n      (page) => page.uniqueSlug === staticPageSlug,\n    );\n\n    if (matchingPage) {\n      return matchingPage.basePageId;\n    }\n\n    return null;\n  },\n);\n\nexport const getCurrentPagePermissions = createSelector(\n  getCurrentPageId,\n  getPageList,\n  (pageId, pages) => {\n    pages.find((page) => page.pageId === pageId);\n  },\n);\n\nexport const getPagePermissions = (state: DefaultRootState) => {\n  const pageId = getCurrentPageId(state);\n  const page = find(state.entities.pageList.pages, { pageId });\n\n  return page?.userPermissions || [];\n};\n\nexport const selectCurrentPageSlug = createSelector(\n  getCurrentPageId,\n  getPageList,\n  (pageId, pages) =>\n    pages.find((page) => page.pageId === pageId)?.slug || PLACEHOLDER_PAGE_SLUG,\n);\n\nexport const getCurrentPageDescription = createSelector(\n  getCurrentPageId,\n  getPageList,\n  (pageId, pages) => pages.find((page) => page.pageId === pageId)?.description,\n);\n\nexport const selectPageSlugToIdMap = createSelector(getPageList, (pages) =>\n  pages.reduce(\n    (acc, page: Page) => {\n      // Comeback\n      acc[page.pageId] = page.slug || \"\";\n\n      return acc;\n    },\n    {} as Record<string, string>,\n  ),\n);\n\nexport const getCurrentApplicationId = (state: DefaultRootState) =>\n  state.entities.pageList.applicationId || \"\";\n\nexport const getCurrentBaseApplicationId = (state: DefaultRootState) =>\n  state.entities.pageList.baseApplicationId || \"\";\n\nexport const selectCurrentApplicationSlug = (state: DefaultRootState) =>\n  state.ui.applications.currentApplication?.slug || PLACEHOLDER_APP_SLUG;\n\nexport const selectApplicationVersion = (state: DefaultRootState) =>\n  state.ui.applications.currentApplication?.applicationVersion ||\n  ApplicationVersion.DEFAULT;\n\nexport const getIsStaticUrlEnabled = (state: DefaultRootState) =>\n  !!state.ui.applications.currentApplication?.staticUrlSettings?.enabled;\n\nexport const selectPageSlugById = (pageId: string) =>\n  createSelector(getPageList, (pages) => {\n    const page = pages.find((page) => page.pageId === pageId);\n\n    return page?.slug || PLACEHOLDER_PAGE_SLUG;\n  });\n\nexport const selectURLSlugs = createSelector(\n  getCurrentApplication,\n  getPageList,\n  getCurrentPageId,\n  (application, pages, pageId) => {\n    const applicationSlug = application?.slug || PLACEHOLDER_APP_SLUG;\n    const currentPage: Page | undefined = pages.find(\n      (page) => page.pageId === pageId,\n    );\n    const pageSlug = currentPage?.slug || PLACEHOLDER_PAGE_SLUG;\n    const customSlug = currentPage?.customSlug;\n\n    return { applicationSlug, pageSlug, customSlug };\n  },\n);\n\nexport const getRenderMode = (state: DefaultRootState) => {\n  return state.entities.app.mode === APP_MODE.EDIT\n    ? RenderModes.CANVAS\n    : RenderModes.PAGE;\n};\n\nexport const getIsViewMode = (state: DefaultRootState) =>\n  state.entities.app.mode === APP_MODE.PUBLISHED;\n\nexport const getIsPersistingPageSlug = (\n  state: DefaultRootState,\n  pageId: string,\n) => state.entities.app.pageSlug[pageId]?.isPersisting || false;\n\nexport const getIsErrorPersistingPageSlug = (\n  state: DefaultRootState,\n  pageId: string,\n) => state.entities.app.pageSlug[pageId]?.isError || false;\n\nexport const getIsValidatingPageSlug = (state: DefaultRootState) =>\n  state.entities.app.pageSlugValidation.isValidating;\n\nexport const getIsPageSlugValid = (state: DefaultRootState) =>\n  state.entities.app.pageSlugValidation.isValid;\n\nexport const getViewModePageList = createSelector(\n  getPageList,\n  getCurrentPageId,\n  (pageList: PageListReduxState[\"pages\"], currentPageId?: string) => {\n    if (currentPageId) {\n      const currentPage = pageList.find(\n        (page) => page.pageId === currentPageId,\n      );\n\n      if (!!currentPage?.isHidden) {\n        return [currentPage];\n      }\n\n      const visiblePages = pageList.filter((page) => !page.isHidden);\n\n      return visiblePages;\n    }\n\n    return [];\n  },\n);\n\nconst defaultLayout: AppLayoutConfig = {\n  type: \"FLUID\",\n};\n\nconst getAppLayout = (state: DefaultRootState) =>\n  state.ui.applications.currentApplication?.appLayout || defaultLayout;\n\nexport const getIsMobileCanvasLayout = createSelector(\n  getAppLayout,\n  (appLayout: AppLayoutConfig) => appLayout.type === \"MOBILE\",\n);\n\nexport const getIsAutoLayout = createSelector(\n  getLayoutSystemType,\n  (layoutSystemType) => layoutSystemType === LayoutSystemTypes.AUTO,\n);\n\nexport const getCurrentApplicationLayout = createSelector(\n  getAppLayout,\n  getLayoutSystemType,\n  (appLayout: AppLayoutConfig, layoutSystemType) => {\n    return layoutSystemType === LayoutSystemTypes.FIXED\n      ? appLayout\n      : defaultLayout;\n  },\n);\n\nexport const getCanvasWidth = (state: DefaultRootState) =>\n  state.ui.mainCanvas.width;\nexport const getMainCanvasProps = (state: DefaultRootState) =>\n  state.ui.mainCanvas;\n\nexport const getMetaWidgets = (state: DefaultRootState) =>\n  state.entities.metaWidgets;\n\n/**\n * What are template meta widgets?\n *\n * A template meta widget is as meta widget which can be used as a template widget.\n * At the time of writing this, the use of template widget is with the List widget, where\n * a template widget is any widget that is dropped inside the List widget first row canvas.\n *\n * Why do we need a template meta widget?\n *\n * A list widget take the template widgets and clones it multiple times and renders it as rows.\n * These template widgets in an app of a list widget reside in canvasWidget reducer and is part of the\n * DSL. But when a list widget is part of a UI module and this UI module is used in an app, all the widget\n * under this module widget are meta widget inlcuding the list widget itself. Since all the widget are meta\n * widgets and the list widget also genereates meta widgets, we need to have a way to identify these template\n * widgets and feed it to the List widget so that it can replicate and behave natively.\n *\n * How do we identify a template meta widget?\n *\n * A template meta widget is any meta widget which has the property `isTemplate` set to true.\n * The usage of this property is upon the widget to decide how to use it and currently only the List widget\n * uses this property.\n *\n */\n\nexport const getTemplateMetaWidgets = createSelector(\n  getMetaWidgets,\n  (metaWidgets) => {\n    const templateMetaWidgets: MetaWidgetsReduxState = {};\n\n    Object.values(metaWidgets).forEach((metaWidget) => {\n      if (metaWidget.isTemplate) {\n        templateMetaWidgets[metaWidget.widgetId] = metaWidget;\n      }\n    });\n\n    return templateMetaWidgets;\n  },\n);\n\nexport const getMetaWidget = (metaWidgetId: string) =>\n  createSelector(getMetaWidgets, (metaWidgets) => {\n    return metaWidgets[metaWidgetId];",
            "cost": 0.15974500000000003
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "appsmithorg__appsmith.main.41074",
        "repo": "appsmithorg/appsmith",
        "base_commit": "b4d5685d21fd757e87cde24c002b5aa79783b528",
        "head_commit": "8ea04e6bb1312d9f468ed3d74ccc080ed6e9bac9",
        "title": "feat: implements onPageUnload functionality for the edit app mode page selector",
        "merged_at": "2025-07-03T06:54:53Z",
        "html_url": "https://github.com/appsmithorg/appsmith/pull/41074",
        "test_files": [
            "app/client/src/selectors/__tests__/editorSelectors/pluginActionSelectors.test.ts"
        ],
        "code_files": [
            "app/client/src/actions/pageActions.tsx",
            "app/client/src/pages/AppIDE/components/PageList/PageEntity.tsx",
            "app/client/src/sagas/ActionExecution/PluginActionSaga.ts",
            "app/client/src/selectors/editorSelectors.tsx"
        ],
        "total_changes": 109,
        "num_files": 5,
        "pull_number": 41074,
        "patch": "diff --git a/app/client/src/actions/pageActions.tsx b/app/client/src/actions/pageActions.tsx\nindex 47aa7f95dda..f776940728c 100644\n--- a/app/client/src/actions/pageActions.tsx\n+++ b/app/client/src/actions/pageActions.tsx\n@@ -31,6 +31,7 @@ import type { ApiResponse } from \"api/ApiResponses\";\n import type { EvaluationReduxAction } from \"./EvaluationReduxActionTypes\";\n import { appsmithTelemetry } from \"instrumentation\";\n import type { NavigateToAnotherPagePayload } from \"sagas/ActionExecution/NavigateActionSaga/types\";\n+import type { Path } from \"history\";\n \n export interface FetchPageListPayload {\n   applicationId: string;\n@@ -699,7 +700,7 @@ export const setupPublishedPage = (\n });\n \n export const navigateToAnotherPage = (\n-  payload: NavigateToAnotherPagePayload,\n+  payload: NavigateToAnotherPagePayload | Path,\n ) => ({\n   type: ReduxActionTypes.NAVIGATE_TO_ANOTHER_PAGE,\n   payload,\ndiff --git a/app/client/src/pages/AppIDE/components/PageList/PageEntity.tsx b/app/client/src/pages/AppIDE/components/PageList/PageEntity.tsx\nindex fb71d77ffc7..2d0ac0ab02e 100644\n--- a/app/client/src/pages/AppIDE/components/PageList/PageEntity.tsx\n+++ b/app/client/src/pages/AppIDE/components/PageList/PageEntity.tsx\n@@ -15,11 +15,10 @@ import {\n import { PERMISSION_TYPE, isPermitted } from \"ee/utils/permissionHelpers\";\n import { getCurrentApplication } from \"ee/selectors/applicationSelectors\";\n import type { DefaultRootState } from \"react-redux\";\n-import { updatePageAction } from \"actions/pageActions\";\n+import { navigateToAnotherPage, updatePageAction } from \"actions/pageActions\";\n import { useGetPageFocusUrl } from \"./hooks/useGetPageFocusUrl\";\n import AnalyticsUtil from \"ee/utils/AnalyticsUtil\";\n import { toggleInOnboardingWidgetSelection } from \"actions/onboardingActions\";\n-import history, { NavigationMethod } from \"utils/history\";\n import { EntityItem } from \"@appsmith/ads\";\n import { useNameEditorState } from \"IDE/hooks/useNameEditorState\";\n import { useValidateEntityName } from \"IDE\";\n@@ -90,9 +89,7 @@ export const PageEntity = ({\n       toUrl: navigateToUrl,\n     });\n     dispatch(toggleInOnboardingWidgetSelection(true));\n-    history.push(navigateToUrl, {\n-      invokedBy: NavigationMethod.EntityExplorer,\n-    });\n+    dispatch(navigateToAnotherPage(navigateToUrl));\n \n     if (onClick) {\n       onClick();\ndiff --git a/app/client/src/sagas/ActionExecution/PluginActionSaga.ts b/app/client/src/sagas/ActionExecution/PluginActionSaga.ts\nindex b9856cf37b7..9d748bb7bc2 100644\n--- a/app/client/src/sagas/ActionExecution/PluginActionSaga.ts\n+++ b/app/client/src/sagas/ActionExecution/PluginActionSaga.ts\n@@ -1702,14 +1702,18 @@ export function* executePageUnloadActionsSaga() {\n   const span = startRootSpan(\"executePageUnloadActionsSaga\");\n \n   try {\n-    const pageActions: Action[] = yield select(getLayoutOnUnloadActions);\n-    const actionCount = pageActions.length;\n+    const pageOnUnloadActions: Action[] = yield select(\n+      getLayoutOnUnloadActions,\n+    );\n+    const actionCount = pageOnUnloadActions.length;\n \n     setAttributesToSpan(span, { numActions: actionCount });\n \n     // Execute unload actions in parallel batches\n     yield all(\n-      pageActions.map((action) => call(executeOnPageUnloadJSAction, action)),\n+      pageOnUnloadActions.map((action) =>\n+        call(executeOnPageUnloadJSAction, action),\n+      ),\n     );\n \n     // Publish success event after all actions are executed\ndiff --git a/app/client/src/selectors/__tests__/editorSelectors/pluginActionSelectors.test.ts b/app/client/src/selectors/__tests__/editorSelectors/pluginActionSelectors.test.ts\nnew file mode 100644\nindex 00000000000..31ddc869a9f\n--- /dev/null\n+++ b/app/client/src/selectors/__tests__/editorSelectors/pluginActionSelectors.test.ts\n@@ -0,0 +1,71 @@\n+import type { DefaultRootState } from \"react-redux\";\n+import { getLayoutOnUnloadActions } from \"selectors/editorSelectors\";\n+\n+describe(\"getLayoutOnUnloadActions\", () => {\n+  it(\"should filter actions by current page ID\", () => {\n+    const state = {\n+      entities: {\n+        pageList: { currentPageId: \"page1\" },\n+        jsActions: [\n+          {\n+            isLoading: false,\n+            config: {\n+              id: \"collection1\",\n+              pageId: \"page1\",\n+              actions: [\n+                {\n+                  id: \"action1\",\n+                  pageId: \"page1\",\n+                  runBehaviour: \"ON_PAGE_UNLOAD\",\n+                  name: \"myFun1\",\n+                  fullyQualifiedName: \"JSObject1.myFun1\",\n+                  collectionId: \"collection1\",\n+                },\n+                {\n+                  id: \"action3\",\n+                  pageId: \"page1\",\n+                  runBehaviour: \"ON_PAGE_LOAD\",\n+                  name: \"myFun2\",\n+                  fullyQualifiedName: \"JSObject1.myFun2\",\n+                  collectionId: \"collection1\",\n+                },\n+              ],\n+            },\n+          },\n+          {\n+            isLoading: false,\n+            config: {\n+              id: \"collection2\",\n+              pageId: \"page2\",\n+              actions: [\n+                {\n+                  id: \"action2\",\n+                  pageId: \"page2\",\n+                  runBehaviour: \"ON_PAGE_UNLOAD\",\n+                  name: \"myFun1\",\n+                  fullyQualifiedName: \"JSObject2.myFun1\",\n+                  collectionId: \"collection2\",\n+                },\n+              ],\n+            },\n+          },\n+        ],\n+      },\n+    };\n+\n+    const result = getLayoutOnUnloadActions(\n+      state as unknown as DefaultRootState,\n+    );\n+\n+    expect(result).toEqual([\n+      {\n+        id: \"action1\",\n+        pageId: \"page1\",\n+        runBehaviour: \"ON_PAGE_UNLOAD\",\n+        name: \"myFun1\",\n+        fullyQualifiedName: \"JSObject1.myFun1\",\n+        collectionId: \"collection1\",\n+      },\n+    ]);\n+  });\n+});\ndiff --git a/app/client/src/selectors/editorSelectors.tsx b/app/client/src/selectors/editorSelectors.tsx\nindex b220b6ab771..28614887208 100644\n--- a/app/client/src/selectors/editorSelectors.tsx\n+++ b/app/client/src/selectors/editorSelectors.tsx\n@@ -125,16 +125,21 @@ export const getPageSavingError = (state: DefaultRootState) => {\n   return state.ui.editor.loadingStates.savingError;\n };\n \n+export const getCurrentPageId = (state: DefaultRootState) =>\n+  state.entities.pageList.currentPageId;\n+\n export const getLayoutOnLoadActions = (state: DefaultRootState) =>\n   state.ui.editor.pageActions || [];\n \n export const getLayoutOnUnloadActions = createSelector(\n+  getCurrentPageId,\n   getAllJSCollectionActions,\n-  (jsActions) => {\n-    return jsActions.filter((action) => {\n-      return action.runBehaviour === ActionRunBehaviour.ON_PAGE_UNLOAD;\n-    });\n-  },\n+  (currentPageId, jsActions) =>\n+    jsActions.filter(\n+      (action) =>\n+        action.runBehaviour === ActionRunBehaviour.ON_PAGE_UNLOAD &&\n+        action.pageId === currentPageId,\n+    ),\n );\n \n export const getLayoutOnLoadIssues = (state: DefaultRootState) => {\n@@ -167,9 +172,6 @@ export const getPageByBaseId = (basePageId: string) =>\n     pages.find((page) => page.basePageId === basePageId),\n   );\n \n-export const getCurrentPageId = (state: DefaultRootState) =>\n-  state.entities.pageList.currentPageId;\n-\n export const getCurrentBasePageId = (state: DefaultRootState) =>\n   state.entities.pageList.currentBasePageId;\n \n",
        "pr_mirror": "appsmithorg__appsmith.7046aeb3"
    }
}