diff --git a/app/client/src/actions/pageActions.tsx b/app/client/src/actions/pageActions.tsx
index 6212b4e..32b103d 100644
--- a/app/client/src/actions/pageActions.tsx
+++ b/app/client/src/actions/pageActions.tsx
@@ -31,7 +31,6 @@ import type { ApiResponse } from "api/ApiResponses";
 import type { EvaluationReduxAction } from "./EvaluationReduxActionTypes";
 import { appsmithTelemetry } from "instrumentation";
 import type { NavigateToAnotherPagePayload } from "sagas/ActionExecution/NavigateActionSaga/types";
-import type { Path } from "history";
 
 export interface FetchPageListPayload {
   applicationId: string;
@@ -535,193 +534,4 @@ export const generateTemplateToUpdatePage = ({
   applicationId,
   columns,
   datasourceId,
-  mode,
-  pageId,
-  pluginSpecificParams,
-  searchColumn,
-  tableName,
-}: GenerateTemplatePageActionPayload): ReduxActionWithExtraParams<GenerateTemplatePageActionPayload> => {
-  return {
-    type: ReduxActionTypes.GENERATE_TEMPLATE_PAGE_INIT,
-    payload: {
-      pageId,
-      tableName,
-      datasourceId,
-      applicationId,
-      columns,
-      searchColumn,
-      pluginSpecificParams,
-    },
-    extraParams: {
-      mode,
-    },
-  };
-};
-
-export function updateReplayEntity(
-  entityId: string,
-  entity: Replayable,
-  entityType: ENTITY_TYPE,
-) {
-  return {
-    type: ReduxActionTypes.UPDATE_REPLAY_ENTITY,
-    payload: { entityId, entity, entityType },
-  };
-}
-
-export function undoAction() {
-  return {
-    type: ReduxActionTypes.UNDO_REDO_OPERATION,
-    payload: {
-      operation: ReplayOperation.UNDO,
-    },
-  };
-}
-
-export function redoAction() {
-  return {
-    type: ReduxActionTypes.UNDO_REDO_OPERATION,
-    payload: {
-      operation: ReplayOperation.REDO,
-    },
-  };
-}
-
-// delete a page
-
-export interface DeletePageActionPayload {
-  id: string;
-}
-
-export const deletePageAction = (
-  pageId: string,
-): ReduxAction<DeletePageActionPayload> => {
-  return {
-    type: ReduxActionTypes.DELETE_PAGE_INIT,
-    payload: {
-      id: pageId,
-    },
-  };
-};
-
-export interface SetDefaultPageActionPayload {
-  id: string;
-  applicationId: string;
-}
-
-export const setPageAsDefault = (
-  pageId: string,
-  applicationId: string,
-): ReduxAction<SetDefaultPageActionPayload> => {
-  return {
-    type: ReduxActionTypes.SET_DEFAULT_APPLICATION_PAGE_INIT,
-    payload: {
-      id: pageId,
-      applicationId,
-    },
-  };
-};
-
-export interface SetPageOrderActionPayload {
-  pageId: string;
-  order: number;
-  applicationId: string;
-}
-
-export const setPageOrder = (
-  applicationId: string,
-  pageId: string,
-  order: number,
-): ReduxAction<SetPageOrderActionPayload> => {
-  return {
-    type: ReduxActionTypes.SET_PAGE_ORDER_INIT,
-    payload: {
-      pageId: pageId,
-      order: order,
-      applicationId,
-    },
-  };
-};
-
-export const resetPageList = () => ({
-  type: ReduxActionTypes.RESET_PAGE_LIST,
-});
-
-export const resetApplicationWidgets = () => ({
-  type: ReduxActionTypes.RESET_APPLICATION_WIDGET_STATE_REQUEST,
-});
-
-// TODO: Fix this the next time the file is edited
-// eslint-disable-next-line @typescript-eslint/no-explicit-any
-export const fetchPageDSLs = (payload?: any) => ({
-  type: ReduxActionTypes.POPULATE_PAGEDSLS_INIT,
-  payload,
-});
-
-export interface SetupPageActionPayload {
-  id: string;
-  isFirstLoad?: boolean;
-  pageWithMigratedDsl?: FetchPageResponse;
-  packagePullStatus?: ApiResponse<PACKAGE_PULL_STATUS>;
-}
-
-export const setupPageAction = ({
-  id,
-  isFirstLoad = false,
-  packagePullStatus,
-  pageWithMigratedDsl,
-}: SetupPageActionPayload) => ({
-  type: ReduxActionTypes.SETUP_PAGE_INIT,
-  payload: {
-    id,
-    isFirstLoad,
-    pageWithMigratedDsl,
-    packagePullStatus,
-  },
-});
-
-export interface SetupPublishedPageActionPayload {
-  pageId: string;
-  bustCache: boolean;
-  pageWithMigratedDsl?: FetchPageResponse;
-}
-
-export const setupPublishedPage = (
-  pageId: string,
-  bustCache = false,
-  pageWithMigratedDsl?: FetchPageResponse,
-): ReduxAction<SetupPublishedPageActionPayload> => ({
-  type: ReduxActionTypes.SETUP_PUBLISHED_PAGE_INIT,
-  payload: {
-    pageId,
-    bustCache,
-    pageWithMigratedDsl,
-  },
-});
-
-export const navigateToAnotherPage = (
-  payload: NavigateToAnotherPagePayload | Path,
-) => ({
-  type: ReduxActionTypes.NAVIGATE_TO_ANOTHER_PAGE,
-  payload,
-});
-
-export const persistPageSlug = (pageId: string, slug: string) => {
-  return {
-    type: ReduxActionTypes.PERSIST_PAGE_SLUG,
-    payload: {
-      pageId,
-      slug,
-    },
-  };
-};
-
-export const validatePageSlug = (pageId: string, slug: string) => {
-  return {
-    type: ReduxActionTypes.VALIDATE_PAGE_SLUG,
-    payload: {
-      pageId,
-      slug,
-    },
-  };
-};
+  mode,
\ No newline at end of file
diff --git a/app/client/src/pages/AppIDE/components/PageList/PageEntity.tsx b/app/client/src/pages/AppIDE/components/PageList/PageEntity.tsx
index cd51b11..b7ac0f2 100644
--- a/app/client/src/pages/AppIDE/components/PageList/PageEntity.tsx
+++ b/app/client/src/pages/AppIDE/components/PageList/PageEntity.tsx
@@ -15,15 +15,15 @@ import {
 import { PERMISSION_TYPE, isPermitted } from "ee/utils/permissionHelpers";
 import { getCurrentApplication } from "ee/selectors/applicationSelectors";
 import type { DefaultRootState } from "react-redux";
-import { navigateToAnotherPage, updatePageAction } from "actions/pageActions";
+import { updatePageAction } from "actions/pageActions";
 import { useGetPageFocusUrl } from "./hooks/useGetPageFocusUrl";
 import AnalyticsUtil from "ee/utils/AnalyticsUtil";
 import { toggleInOnboardingWidgetSelection } from "actions/onboardingActions";
+import history, { NavigationMethod } from "utils/history";
 import { EntityItem } from "@appsmith/ads";
 import { useNameEditorState } from "IDE/hooks/useNameEditorState";
 import { useValidateEntityName } from "IDE";
 import { noop } from "lodash";
-import { NavigationMethod } from "utils/history";
 
 export const PageEntity = ({
   onClick,
@@ -90,14 +90,9 @@ export const PageEntity = ({
       toUrl: navigateToUrl,
     });
     dispatch(toggleInOnboardingWidgetSelection(true));
-    dispatch(
-      navigateToAnotherPage({
-        pageURL: navigateToUrl,
-        state: {
-          invokedBy: NavigationMethod.EntityExplorer,
-        },
-      }),
-    );
+    history.push(navigateToUrl, {
+      invokedBy: NavigationMethod.EntityExplorer,
+    });
 
     if (onClick) {
       onClick();
@@ -173,4 +168,4 @@ export const PageEntity = ({
       title={page.pageName}
     />
   );
-};
+};
\ No newline at end of file
diff --git a/app/client/src/sagas/ActionExecution/PluginActionSaga.ts b/app/client/src/sagas/ActionExecution/PluginActionSaga.ts
index 00fd7bf..5db352f 100644
--- a/app/client/src/sagas/ActionExecution/PluginActionSaga.ts
+++ b/app/client/src/sagas/ActionExecution/PluginActionSaga.ts
@@ -409,1354 +409,4 @@ function* evaluateActionParams(
     let value = isArray(values) && values[i];
 
     let useBlobMaps = false;
-    // Maintain a blob map to resolve blob urls of large files
-    const blobMap: Array<string> = [];
-
-    if (isArray(value)) {
-      const tempArr = [];
-      const arrDatatype: Array<string> = [];
-
-      // array of objects containing blob urls that is loops and individual object is checked for resolution of blob urls.
-
-      const BATCH_CHUNK_SIZE = 100;
-
-      for (let j = 0; j < value.length; j++) {
-        const val = value[j];
-        // TODO: Fix this the next time the file is edited
-        // eslint-disable-next-line @typescript-eslint/no-explicit-any
-        const newVal: Record<string, any> = yield call(
-          resolvingBlobUrls,
-          val,
-          executeActionRequest,
-          i,
-          true,
-          arrDatatype,
-        );
-
-        if (newVal.hasOwnProperty("blobUrlPaths")) {
-          updateBlobDataFromUrls(
-            newVal.blobUrlPaths,
-            newVal,
-            blobMap,
-            blobDataMap,
-          );
-          useBlobMaps = true;
-          unset(newVal, "blobUrlPaths");
-          evaluatedParams[key] = "blob";
-        }
-
-        tempArr.push(newVal);
-
-        if (key.includes(".files") && recordFilePickerInstrumentation) {
-          filePickerInstrumentation["numberOfFiles"] += 1;
-          const { size, type } = newVal;
-
-          filePickerInstrumentation["totalSize"] += size;
-          filePickerInstrumentation["fileSizes"].push(size);
-          filePickerInstrumentation["fileTypes"].push(type);
-          evaluatedParams[key] = "file";
-        }
-
-        if ((j + 1) % BATCH_CHUNK_SIZE === 0) {
-          // Yield control back to the event loop and empty the stack trace
-          yield delay(0);
-        }
-      }
-
-      //Adding array datatype along with the datatype of first element of the array
-      executeActionRequest.paramProperties[`k${i}`] = {
-        datatype: { array: [arrDatatype[0]] },
-      };
-      value = tempArr;
-    } else {
-      // @ts-expect-error: Values can take many types
-      value = yield call(resolvingBlobUrls, value, executeActionRequest, i);
-
-      if (key.includes(".files") && recordFilePickerInstrumentation) {
-        filePickerInstrumentation["numberOfFiles"] += 1;
-        filePickerInstrumentation["totalSize"] += value.size;
-        filePickerInstrumentation["fileSizes"].push(value.size);
-        filePickerInstrumentation["fileTypes"].push(value.type);
-        evaluatedParams[key] = "file";
-      }
-    }
-
-    if (typeof value === "object") {
-      // This is used in cases of large files, we store the bloburls with the path they were set in
-      // This helps in creating a unique map of blob urls to blob data when passing to the server
-      if (!!value && value.hasOwnProperty("blobUrlPaths")) {
-        updateBlobDataFromUrls(value.blobUrlPaths, value, blobMap, blobDataMap);
-        unset(value, "blobUrlPaths");
-        evaluatedParams[key] = "blob";
-      }
-
-      // Handle null values separately to avoid stringifying them
-      if (value === null) {
-        value = null;
-        evaluatedParams[key] = null;
-      } else {
-        value = JSON.stringify(value);
-        evaluatedParams[key] = value;
-      }
-    }
-
-    // If there are no blob urls in the value, we can directly add it to the formData
-    // If there are blob urls, we need to add them to the blobDataMap
-    if (!useBlobMaps) {
-      // Handle null values separately to avoid creating a Blob with "null" string
-      if (value === null) {
-        value = null;
-      } else {
-        value = new Blob([value], { type: "text/plain" });
-      }
-    }
-
-    bindingsMap[key] = `k${i}`;
-    bindingBlob.push({ name: `k${i}`, value: value });
-
-    // We need to add the blob map to the param properties
-    // This will allow the server to handle the scenaio of large files upload using blob data
-    const paramProperties = executeActionRequest.paramProperties[`k${i}`];
-
-    if (!!paramProperties && typeof paramProperties === "object") {
-      paramProperties["blobIdentifiers"] = blobMap;
-    }
-  }
-
-  formData.append("executeActionDTO", JSON.stringify(executeActionRequest));
-  formData.append("parameterMap", JSON.stringify(bindingsMap));
-  bindingBlob?.forEach((item) => formData.append(item.name, item.value));
-
-  // Append blob data map to formData if not empty
-  if (!isEmpty(blobDataMap)) {
-    // blobDataMap is used to resolve blob urls of large files as array buffer
-    // we need to add each blob data to formData as a separate entry
-    Object.entries(blobDataMap).forEach(([path, blobData]) =>
-      formData.append(path, blobData),
-    );
-  }
-
-  return evaluatedParams;
-}
-
-export default function* executePluginActionTriggerSaga(
-  pluginAction: TRunDescription,
-  eventType: EventType,
-) {
-  const span = startRootSpan("executePluginActionTriggerSaga");
-  const { payload: pluginPayload } = pluginAction;
-  const { actionId, onError, params } = pluginPayload;
-
-  if (getType(params) !== Types.OBJECT) {
-    throw new ActionValidationError(
-      "RUN_PLUGIN_ACTION",
-      "params",
-      Types.OBJECT,
-      getType(params),
-    );
-  }
-
-  setAttributesToSpan(span, {
-    actionId: actionId,
-  });
-
-  const action = shouldBeDefined<Action>(
-    yield select(getAction, actionId),
-    `Action not found for id - ${actionId}`,
-  );
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  const datasourceId: string = (action?.datasource as any)?.id;
-  const plugin: Plugin = yield select(getPlugin, action?.pluginId);
-  const currentApp: ApplicationPayload = yield select(getCurrentApplication);
-
-  const currentEnvDetails: { id: string; name: string } = yield select(
-    getCurrentEnvironmentDetails,
-  );
-
-  const pluginActionNameToDisplay = getPluginActionNameToDisplay(action);
-
-  const actionExecutionAnalytics = getActionExecutionAnalytics(
-    action,
-    plugin,
-    params,
-    currentApp,
-    datasourceId,
-  );
-
-  AnalyticsUtil.logEvent("EXECUTE_ACTION", actionExecutionAnalytics);
-  const pagination =
-    eventType === EventType.ON_NEXT_PAGE
-      ? "NEXT"
-      : eventType === EventType.ON_PREV_PAGE
-        ? "PREV"
-        : undefined;
-
-  const executePluginActionResponse: ExecutePluginActionResponse = yield call(
-    executePluginActionSaga,
-    action,
-    pagination,
-    params,
-    undefined,
-    span,
-  );
-  const { isError, payload } = executePluginActionResponse;
-
-  if (isError) {
-    AppsmithConsole.addErrors([
-      {
-        payload: {
-          id: actionId,
-          iconId: action.pluginId,
-          logType: LOG_TYPE.ACTION_EXECUTION_ERROR,
-          text: `Failed execution in ${payload.duration}(ms)`,
-          environmentName: currentEnvDetails.name,
-          source: {
-            type: ENTITY_TYPE.ACTION,
-            name: pluginActionNameToDisplay,
-            id: actionId,
-            httpMethod: action?.actionConfiguration?.httpMethod,
-            pluginType: action.pluginType,
-          },
-          state: {
-            error: !isString(payload.body)
-              ? JSON.stringify(payload.body)
-              : payload.body,
-            request: payload.request,
-          },
-          pluginErrorDetails: payload.pluginErrorDetails,
-        },
-      },
-    ]);
-    AnalyticsUtil.logEvent("EXECUTE_ACTION_FAILURE", {
-      ...actionExecutionAnalytics,
-      ...payload.pluginErrorDetails,
-    });
-
-    if (onError) {
-      throw new PluginTriggerFailureError(
-        createMessage(ERROR_ACTION_EXECUTE_FAIL, pluginActionNameToDisplay),
-        [payload.body, params],
-      );
-    } else {
-      throw new PluginTriggerFailureError(
-        createMessage(ERROR_PLUGIN_ACTION_EXECUTE, pluginActionNameToDisplay),
-        [
-          payload.body,
-          params,
-          {
-            isExecutionSuccess: payload.isExecutionSuccess,
-            statusCode: payload.statusCode,
-            headers: payload.headers,
-          },
-        ],
-      );
-    }
-  } else {
-    AnalyticsUtil.logEvent("EXECUTE_ACTION_SUCCESS", actionExecutionAnalytics);
-    AppsmithConsole.info({
-      logType: LOG_TYPE.ACTION_EXECUTION_SUCCESS,
-      text: `Successfully executed in ${payload.duration}(ms)`,
-      source: {
-        type: ENTITY_TYPE.ACTION,
-        name: pluginActionNameToDisplay,
-        id: actionId,
-      },
-      state: {
-        response: payload.body,
-        request: payload.request,
-      },
-    });
-  }
-
-  return [
-    payload.body,
-    params,
-    {
-      isExecutionSuccess: payload.isExecutionSuccess,
-      statusCode: payload.statusCode,
-      headers: payload.headers,
-    },
-  ];
-}
-
-function* runActionShortcutSaga() {
-  const pathname = window.location.pathname;
-  const baseMatch = matchBasePath(pathname);
-
-  if (!baseMatch) return;
-
-  // get gitSyncModal status
-  const isGitOpsModalOpen: boolean = yield select(selectGitOpsModalOpen);
-  const isGitConnectModalOpen: boolean = yield select(
-    selectGitConnectModalOpen,
-  );
-
-  // if git sync modal is open, prevent action from being executed via shortcut keys.
-  if (isGitOpsModalOpen || isGitConnectModalOpen) return;
-
-  const { path } = baseMatch;
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  const match: any = matchPath(pathname, {
-    path: [
-      trimQueryString(`${path}${API_EDITOR_BASE_PATH}`),
-      trimQueryString(`${path}${API_EDITOR_ID_PATH}`),
-      trimQueryString(`${path}${QUERIES_EDITOR_BASE_PATH}`),
-      trimQueryString(`${path}${QUERIES_EDITOR_ID_PATH}`),
-      trimQueryString(`${path}${API_EDITOR_PATH_WITH_SELECTED_PAGE_ID}`),
-      trimQueryString(`${path}${INTEGRATION_EDITOR_PATH}`),
-      trimQueryString(`${path}${SAAS_EDITOR_API_ID_PATH}`),
-    ],
-    exact: true,
-    strict: false,
-  });
-
-  if (!match || !match.params) return;
-
-  const { baseApiId, baseQueryId } = match.params;
-  const actionId = baseApiId || baseQueryId;
-
-  if (actionId) {
-    yield put(runAction(actionId));
-  } else {
-    return;
-  }
-}
-
-interface RunActionError {
-  name: string;
-  message: string;
-  clientDefinedError?: boolean;
-}
-
-export function* runActionSaga(
-  reduxAction: ReduxAction<{
-    id: string;
-    paginationField?: PaginationField;
-    skipOpeningDebugger: boolean;
-    action?: Action;
-    actionExecutionContext?: ActionExecutionContext;
-  }>,
-) {
-  const span = startRootSpan("runActionSaga");
-  const actionId = reduxAction.payload.id;
-  const isSaving: boolean = yield select(isActionSaving(actionId));
-  const isDirty: boolean = yield select(isActionDirty(actionId));
-  const isSavingEntity: boolean = yield select(getIsSavingEntity);
-
-  if (isSaving || isDirty || isSavingEntity) {
-    if (isDirty && !isSaving) {
-      yield put(updateAction({ id: actionId }));
-      yield take(ReduxActionTypes.UPDATE_ACTION_SUCCESS);
-    }
-  }
-
-  const currentEnvDetails: { id: string; name: string } = yield select(
-    getCurrentEnvironmentDetails,
-  );
-  const actionObject =
-    reduxAction.payload.action ||
-    shouldBeDefined<Action>(
-      yield select(getAction, actionId),
-      `action not found for id - ${actionId}`,
-    );
-  const plugin: Plugin = yield select(getPlugin, actionObject?.pluginId);
-  const datasource: Datasource = yield select(
-    getDatasource,
-    // TODO: Fix this the next time the file is edited
-    // eslint-disable-next-line @typescript-eslint/no-explicit-any
-    (actionObject?.datasource as any)?.id,
-  );
-  const pageName: string = yield select(getCurrentPageNameByActionId, actionId);
-
-  const { paginationField } = reduxAction.payload;
-
-  // open response tab in debugger on exection of action.
-  if (!reduxAction.payload.skipOpeningDebugger) {
-    yield put(
-      setPluginActionEditorDebuggerState({
-        open: true,
-        selectedTab: DEBUGGER_TAB_KEYS.RESPONSE_TAB,
-      }),
-    );
-  }
-
-  let payload = EMPTY_RESPONSE;
-  let isError = true;
-  let error: RunActionError = {
-    name: "",
-    message: "",
-  };
-
-  const pluginActionNameToDisplay = getPluginActionNameToDisplay(actionObject);
-
-  try {
-    const executePluginActionResponse: ExecutePluginActionResponse = yield call(
-      executePluginActionSaga,
-      actionObject,
-      paginationField,
-      {},
-      true,
-      span,
-    );
-
-    payload = executePluginActionResponse.payload;
-    isError = executePluginActionResponse.isError;
-  } catch (e) {
-    // When running from the pane, we just want to end the saga if the user has
-    // cancelled the call. No need to log any errors
-    if (e instanceof UserCancelledActionExecutionError) {
-      // cancel action but do not throw any error.
-      yield put({
-        type: ReduxActionErrorTypes.RUN_ACTION_ERROR,
-        payload: {
-          error: e.name,
-          id: reduxAction.payload.id,
-          show: false,
-        },
-      });
-      toast.show(
-        createMessage(ACTION_EXECUTION_CANCELLED, pluginActionNameToDisplay),
-        {
-          kind: "error",
-        },
-      );
-
-      return;
-    }
-
-    log.error(e);
-    error = { name: (e as Error).name, message: (e as Error).message };
-
-    const clientDefinedErrorMetadata = extractClientDefinedErrorMetadata(e);
-
-    if (clientDefinedErrorMetadata) {
-      set(
-        payload,
-        "statusCode",
-        `${clientDefinedErrorMetadata?.statusCode || ""}`,
-      );
-      set(payload, "request", {});
-      set(
-        payload,
-        "pluginErrorDetails",
-        clientDefinedErrorMetadata?.pluginErrorDetails,
-      );
-      set(error, "clientDefinedError", true);
-    }
-  }
-
-  // Error should be readable error if present.
-  // Otherwise, payload's body.
-  // Default to "An unexpected error occurred" if none is available
-
-  const readableError = payload.readableError
-    ? {
-        name: "PluginExecutionError",
-        message: getErrorAsString(payload.readableError),
-      }
-    : undefined;
-
-  const payloadBodyError = payload.body
-    ? {
-        name: "PluginExecutionError",
-        message: getErrorAsString(payload.body),
-      }
-    : undefined;
-
-  const clientDefinedError = error.clientDefinedError
-    ? {
-        name: "PluginExecutionError",
-        message: error?.message,
-        clientDefinedError: true,
-      }
-    : undefined;
-
-  const defaultError = {
-    name: "PluginExecutionError",
-    message: "An unexpected error occurred",
-  };
-
-  const allowedActionAnalyticsKeys = getAllowedActionAnalyticsKeys(
-    plugin?.packageName,
-  );
-  const actionAnalyticsPayload = getActionProperties(
-    actionObject,
-    allowedActionAnalyticsKeys,
-  );
-
-  if (isError) {
-    error =
-      readableError || payloadBodyError || clientDefinedError || defaultError;
-
-    // In case of debugger, both the current error message
-    // and the readableError needs to be present,
-    // since the readableError may be malformed for certain errors.
-
-    const appsmithConsoleErrorMessageList = [
-      {
-        message: error,
-        type: PLATFORM_ERROR.PLUGIN_EXECUTION,
-        subType: payload.errorType,
-      },
-    ];
-
-    if (error === readableError && !!payloadBodyError) {
-      appsmithConsoleErrorMessageList.push({
-        message: payloadBodyError,
-        type: PLATFORM_ERROR.PLUGIN_EXECUTION,
-        subType: payload.errorType,
-      });
-    }
-
-    AppsmithConsole.addErrors([
-      {
-        payload: {
-          id: actionId,
-          iconId: actionObject.pluginId,
-          logType: LOG_TYPE.ACTION_EXECUTION_ERROR,
-          environmentName: currentEnvDetails.name,
-          text: `Failed execution in ${payload.duration}(ms)`,
-          source: {
-            type: ENTITY_TYPE.ACTION,
-            name: pluginActionNameToDisplay,
-            id: actionId,
-            httpMethod: actionObject?.actionConfiguration?.httpMethod,
-            pluginType: actionObject.pluginType,
-          },
-          state: {
-            error: error.message,
-            request: payload.request,
-          },
-          pluginErrorDetails: payload?.pluginErrorDetails,
-        },
-      },
-    ]);
-
-    yield put({
-      type: ReduxActionErrorTypes.RUN_ACTION_ERROR,
-      payload: {
-        error: appsmithConsoleErrorMessageList[0].message,
-        id: reduxAction.payload.id,
-        show: false,
-      },
-    });
-    AnalyticsUtil.logEvent("EXECUTE_ACTION_FAILURE", {
-      actionId,
-      actionName: pluginActionNameToDisplay,
-      environmentId: currentEnvDetails.id,
-      environmentName: currentEnvDetails.name,
-      pageName: pageName,
-      apiType: "INTERNAL",
-      datasourceId: datasource?.id,
-      pluginName: plugin?.name,
-      isMock: !!datasource?.isMock,
-      actionConfig: actionAnalyticsPayload,
-      ...payload?.pluginErrorDetails,
-      source: reduxAction.payload.actionExecutionContext,
-    });
-
-    return;
-  }
-
-  AnalyticsUtil.logEvent("EXECUTE_ACTION", {
-    actionId,
-    actionName: pluginActionNameToDisplay,
-    environmentId: currentEnvDetails.id,
-    environmentName: currentEnvDetails.name,
-    pageName: pageName,
-    responseTime: payload.duration,
-    apiType: "INTERNAL",
-    datasourceId: datasource?.id,
-    pluginName: plugin?.name,
-    isMock: !!datasource?.isMock,
-    actionConfig: actionAnalyticsPayload,
-    source: reduxAction.payload.actionExecutionContext,
-    runBehaviour: actionObject?.runBehaviour,
-  });
-
-  yield put({
-    type: ReduxActionTypes.RUN_ACTION_SUCCESS,
-    payload: { [actionId]: payload },
-  });
-
-  if (payload.isExecutionSuccess) {
-    AppsmithConsole.info({
-      logType: LOG_TYPE.ACTION_EXECUTION_SUCCESS,
-      text: `Successfully executed in ${payload.duration}(ms)`,
-      source: {
-        type: ENTITY_TYPE.ACTION,
-        name: pluginActionNameToDisplay,
-        id: actionId,
-      },
-      state: {
-        response: payload.body,
-        request: payload.request,
-      },
-    });
-  }
-}
-
-// This gets called for "onPageLoad" JS actions
-function* executeOnPageLoadJSAction(pageAction: PageAction) {
-  const collectionId: string = pageAction.collectionId || "";
-  const pageId: string | undefined = yield select(getCurrentPageId);
-
-  if (!collectionId) return;
-
-  const collection: JSCollection = yield select(
-    getJSCollectionFromAllEntities,
-    collectionId,
-  );
-
-  if (!collection) {
-    appsmithTelemetry.captureException(
-      new Error(
-        "Collection present in layoutOnLoadActions but no collection exists ",
-      ),
-      {
-        errorName: "MissingJSCollection",
-        extra: {
-          collectionId,
-          actionId: pageAction.id,
-          pageId,
-        },
-      },
-    );
-
-    return;
-  }
-
-  const jsAction = collection.actions.find(
-    (action: JSAction) => action.id === pageAction.id,
-  );
-
-  if (!!jsAction) {
-    if (jsAction.confirmBeforeExecute) {
-      const jsActionPathNameToDisplay = getJSActionPathNameToDisplay(
-        jsAction,
-        collection,
-      );
-      const modalPayload = {
-        name: jsActionPathNameToDisplay,
-        modalOpen: true,
-        modalType: ModalType.RUN_ACTION,
-      };
-
-      const confirmed: boolean = yield call(
-        requestModalConfirmationSaga,
-        modalPayload,
-      );
-
-      if (!confirmed) {
-        yield put({
-          type: ReduxActionTypes.RUN_ACTION_CANCELLED,
-          payload: { id: pageAction.id },
-        });
-
-        const jsActionPathNameToDisplay = getJSActionPathNameToDisplay(
-          jsAction,
-          collection,
-        );
-
-        toast.show(
-          createMessage(ACTION_EXECUTION_CANCELLED, jsActionPathNameToDisplay),
-          {
-            kind: "error",
-          },
-        );
-
-        // Don't proceed to executing the js function
-        return;
-      }
-    }
-
-    const data = {
-      action: jsAction,
-      collection,
-      isExecuteJSFunc: true,
-      onPageLoad: true,
-    };
-
-    yield call(handleExecuteJSFunctionSaga, data);
-  }
-}
-
-function* executePageLoadAction(
-  pageAction: PageAction,
-  span?: Span,
-  actionExecutionContext?: ActionExecutionContext,
-) {
-  const currentEnvDetails: { id: string; name: string } = yield select(
-    getCurrentEnvironmentDetails,
-  );
-
-  if (pageAction.hasOwnProperty("collectionId")) {
-    yield call(executeOnPageLoadJSAction, pageAction);
-  } else {
-    const pageId: string | undefined = yield select(getCurrentPageId);
-    let currentApp: ApplicationPayload = yield select(getCurrentApplication);
-
-    currentApp = currentApp || {};
-    const appMode: APP_MODE | undefined = yield select(getAppMode);
-
-    // action is required to fetch the pluginId and pluginType.
-    const action = shouldBeDefined<Action>(
-      yield select(getAction, pageAction.id),
-      `action not found for id - ${pageAction.id}`,
-    );
-
-    // TODO: Fix this the next time the file is edited
-    // eslint-disable-next-line @typescript-eslint/no-explicit-any
-    const datasourceId: string = (action?.datasource as any)?.id;
-    const datasource: Datasource = yield select(getDatasource, datasourceId);
-    const plugin: Plugin = yield select(getPlugin, action?.pluginId);
-    const isAnvilEnabled: boolean = yield select(
-      getIsAnvilEnabledInCurrentApplication,
-    );
-
-    AnalyticsUtil.logEvent("EXECUTE_ACTION", {
-      type: pageAction.pluginType,
-      name: pageAction.name,
-      pageId: pageId,
-      appMode: appMode,
-      appId: currentApp.id,
-      onPageLoad: true,
-      appName: currentApp.name,
-      environmentId: currentEnvDetails.id,
-      environmentName: currentEnvDetails.name,
-      isExampleApp: currentApp.appIsExample,
-      pluginName: plugin?.name,
-      datasourceId: datasourceId,
-      isMock: !!datasource?.isMock,
-      actionId: pageAction?.id,
-      inputParams: 0,
-      source: !!actionExecutionContext
-        ? actionExecutionContext
-        : ActionExecutionContext.PAGE_LOAD,
-      runBehaviour: action?.runBehaviour,
-    });
-
-    const actionName = getPluginActionNameToDisplay(
-      pageAction as unknown as Action,
-    );
-
-    let payload = EMPTY_RESPONSE;
-    let isError = true;
-    let error = {
-      name: "PluginExecutionError",
-      message: createMessage(ACTION_EXECUTION_FAILED, actionName),
-    };
-
-    try {
-      const executePluginActionResponse: ExecutePluginActionResponse =
-        yield call(
-          executePluginActionSaga,
-          action,
-          undefined,
-          undefined,
-          undefined,
-          span,
-        );
-
-      payload = executePluginActionResponse.payload;
-      isError = executePluginActionResponse.isError;
-    } catch (e) {
-      log.error(e);
-
-      if (e instanceof UserCancelledActionExecutionError) {
-        error = {
-          name: "PluginExecutionError",
-          message: createMessage(ACTION_EXECUTION_CANCELLED, actionName),
-        };
-      }
-    }
-
-    // open response tab in debugger on exection of action on page load.
-    // Only if current page is the page on which the action is executed.
-    if (
-      window.location.pathname.includes(pageAction.id) &&
-      !(isAnvilEnabled && pageAction.pluginType === PluginType.AI)
-    )
-      yield put(
-        setPluginActionEditorDebuggerState({
-          open: true,
-          selectedTab: DEBUGGER_TAB_KEYS.RESPONSE_TAB,
-        }),
-      );
-
-    if (isError) {
-      AppsmithConsole.addErrors([
-        {
-          payload: {
-            id: pageAction.id,
-            iconId: action.pluginId,
-            logType: LOG_TYPE.ACTION_EXECUTION_ERROR,
-            environmentName: currentEnvDetails.name,
-            text: `Failed execution in ${payload.duration}(ms)`,
-            source: {
-              type: ENTITY_TYPE.ACTION,
-              name: actionName,
-              id: pageAction.id,
-              httpMethod: action?.actionConfiguration?.httpMethod,
-              pluginType: action.pluginType,
-            },
-            state: {
-              error:
-                payload.pluginErrorDetails?.downstreamErrorMessage ||
-                error.message,
-              request: payload.request,
-            },
-            pluginErrorDetails: payload.pluginErrorDetails,
-          },
-        },
-      ]);
-
-      yield put(
-        executePluginActionError({
-          actionId: pageAction.id,
-          isPageLoad: true,
-          error: { message: error.message },
-          data: payload,
-        }),
-      );
-
-      AnalyticsUtil.logEvent("EXECUTE_ACTION_FAILURE", {
-        type: pageAction.pluginType,
-        name: actionName,
-        pageId: pageId,
-        appMode: appMode,
-        appId: currentApp.id,
-        onPageLoad: true,
-        appName: currentApp.name,
-        environmentId: currentEnvDetails.id,
-        environmentName: currentEnvDetails.name,
-        isExampleApp: currentApp.appIsExample,
-        pluginName: plugin?.name,
-        datasourceId: datasourceId,
-        isMock: !!datasource?.isMock,
-        actionId: pageAction?.id,
-        inputParams: 0,
-        ...payload.pluginErrorDetails,
-        source: !!actionExecutionContext
-          ? actionExecutionContext
-          : ActionExecutionContext.PAGE_LOAD,
-      });
-    } else {
-      AnalyticsUtil.logEvent("EXECUTE_ACTION_SUCCESS", {
-        type: pageAction.pluginType,
-        name: actionName,
-        pageId: pageId,
-        appMode: appMode,
-        appId: currentApp.id,
-        onPageLoad: true,
-        appName: currentApp.name,
-        environmentId: currentEnvDetails.id,
-        environmentName: currentEnvDetails.name,
-        isExampleApp: currentApp.appIsExample,
-        pluginName: plugin?.name,
-        datasourceId: datasourceId,
-        isMock: !!datasource?.isMock,
-        actionId: pageAction?.id,
-        inputParams: 0,
-        source: !!actionExecutionContext
-          ? actionExecutionContext
-          : ActionExecutionContext.PAGE_LOAD,
-      });
-
-      yield take(ReduxActionTypes.SET_EVALUATED_TREE);
-    }
-  }
-}
-
-function* executePageLoadActionsSaga(
-  actionPayload: ReduxAction<{
-    actionExecutionContext?: ActionExecutionContext;
-  }>,
-) {
-  const span = startRootSpan("executePageLoadActionsSaga");
-
-  try {
-    const pageActions: PageAction[][] = yield select(getLayoutOnLoadActions);
-    const layoutOnLoadActionErrors: LayoutOnLoadActionErrors[] = yield select(
-      getLayoutOnLoadIssues,
-    );
-    const actionCount = flatten(pageActions).length;
-
-    setAttributesToSpan(span, { numActions: actionCount });
-
-    // when cyclical depedency issue is there,
-    // none of the page load actions would be executed
-    for (const actionSet of pageActions) {
-      // Load all sets in parallel
-      // @ts-expect-error: no idea how to type this
-      yield* yield all(
-        actionSet.map((apiAction) =>
-          call(
-            executePageLoadAction,
-            apiAction,
-            span,
-            actionPayload.payload.actionExecutionContext,
-          ),
-        ),
-      );
-    }
-
-    yield put({
-      type: ReduxActionTypes.SET_ONLOAD_ACTION_EXECUTED,
-      payload: true,
-    });
-
-    // We show errors in the debugger once onPageLoad actions
-    // are executed
-    yield put(hideDebuggerErrors(false));
-    checkAndLogErrorsIfCyclicDependency(layoutOnLoadActionErrors);
-  } catch (e) {
-    log.error(e);
-    AppsmithConsole.error({
-      text: createMessage(ERROR_FAIL_ON_PAGE_LOAD_ACTIONS),
-    });
-  }
-  endSpan(span);
-}
-
-interface ExecutePluginActionResponse {
-  payload: ActionResponse;
-  isError: boolean;
-}
-
-/*
- * This saga handles the complete plugin action execution flow. It will respond with a
- * payload and isError property which indicates if the response is of an error type.
- * In case of the execution was not completed, it will throw errors of type
- * PluginActionExecutionError which needs to be handled by any saga that calls this.
- * */
-function* executePluginActionSaga(
-  pluginAction: Action,
-  paginationField?: PaginationField,
-  params?: Record<string, unknown>,
-  isUserInitiated?: boolean,
-  parentSpan?: Span,
-) {
-  const actionId = pluginAction.id;
-  const baseActionId = pluginAction.baseId;
-  const pluginActionNameToDisplay = getPluginActionNameToDisplay(pluginAction);
-
-  setAttributesToSpan(parentSpan, {
-    actionId,
-    pluginName: pluginActionNameToDisplay,
-  });
-
-  if (pluginAction.confirmBeforeExecute) {
-    const modalPayload = {
-      name: pluginActionNameToDisplay,
-      modalOpen: true,
-      modalType: ModalType.RUN_ACTION,
-    };
-
-    const confirmed: unknown = yield call(
-      requestModalConfirmationSaga,
-      modalPayload,
-    );
-
-    if (!confirmed) {
-      yield put({
-        type: ReduxActionTypes.RUN_ACTION_CANCELLED,
-        payload: { id: actionId },
-      });
-      throw new UserCancelledActionExecutionError();
-    }
-  }
-
-  yield put(executePluginActionRequest({ id: actionId }));
-
-  const appMode: APP_MODE | undefined = yield select(getAppMode);
-  const timeout: number | undefined = yield select(getActionTimeout, actionId);
-
-  const executeActionRequest: ExecuteActionRequest = {
-    actionId: actionId,
-    viewMode: appMode === APP_MODE.PUBLISHED,
-    paramProperties: {},
-    analyticsProperties: {
-      isUserInitiated: !!isUserInitiated,
-    },
-  };
-
-  if (paginationField) {
-    executeActionRequest.paginationField = paginationField;
-  }
-
-  const formData = new FormData();
-
-  // Initialising instrumentation object, will only be populated in case
-  // files are being uplaoded
-  const filePickerInstrumentation: FilePickerInstumentationObject = {
-    numberOfFiles: 0,
-    totalSize: 0,
-    fileTypes: [],
-    fileSizes: [],
-  };
-
-  const evaluatedBindings: Record<string, unknown> = yield call(
-    evaluateActionParams,
-    pluginAction.jsonPathKeys,
-    formData,
-    executeActionRequest,
-    filePickerInstrumentation,
-    params,
-  );
-
-  AppsmithConsole.info({
-    text: "Began execution",
-    source: {
-      type: ENTITY_TYPE.ACTION,
-      name: pluginAction.name,
-      id: actionId,
-    },
-    state: { requestParams: { ...params, ...evaluatedBindings } },
-  });
-
-  let payload = EMPTY_RESPONSE;
-  let response: ActionExecutionResponse;
-
-  try {
-    response = yield ActionAPI.executeAction(formData, timeout);
-
-    const isError = isErrorResponse(response);
-
-    yield validateResponse(response);
-    payload = createActionExecutionResponse(response);
-
-    yield put(
-      executePluginActionSuccess({
-        id: actionId,
-        baseId: baseActionId,
-        response: payload,
-        isActionCreatedInApp: getIsActionCreatedInApp(pluginAction),
-      }),
-    );
-
-    yield put(
-      updateActionData(
-        [
-          {
-            entityName: pluginAction.name,
-            dataPath: "data",
-            data: payload.body,
-          },
-        ],
-        parentSpan,
-      ),
-    );
-    // TODO: Plugins are not always fetched before on page load actions are executed.
-    try {
-      let plugin: Plugin | undefined;
-
-      if (!!pluginAction.pluginId) {
-        plugin = shouldBeDefined<Plugin>(
-          yield select(getPlugin, pluginAction.pluginId),
-          `Plugin not found for id - ${pluginAction.pluginId}`,
-        );
-      }
-
-      // sets the default display format for action response e.g Raw, Json or Table
-      yield setDefaultActionDisplayFormat(actionId, plugin, payload);
-    } catch (e) {
-      log.error("plugin no found", e);
-    }
-
-    if (filePickerInstrumentation.numberOfFiles > 0) {
-      triggerFileUploadInstrumentation(
-        filePickerInstrumentation,
-        isError ? "ERROR" : "SUCCESS",
-        response.data.statusCode,
-        pluginAction.name,
-        pluginAction.pluginType,
-        response.clientMeta.duration,
-      );
-    }
-
-    return {
-      payload,
-      isError,
-    };
-  } catch (e) {
-    // TODO: Fix this the next time the file is edited
-    // eslint-disable-next-line @typescript-eslint/no-explicit-any
-    if ("clientDefinedError" in (e as any)) {
-      // Case: error from client side validation
-      if (filePickerInstrumentation.numberOfFiles > 0) {
-        triggerFileUploadInstrumentation(
-          filePickerInstrumentation,
-          "ERROR",
-          "400",
-          pluginAction.name,
-          pluginAction.pluginType,
-          "NA",
-        );
-      }
-
-      throw e;
-    }
-
-    yield put(
-      executePluginActionSuccess({
-        id: actionId,
-        baseId: baseActionId,
-        response: EMPTY_RESPONSE,
-        isActionCreatedInApp: getIsActionCreatedInApp(pluginAction),
-      }),
-    );
-    yield put(
-      updateActionData(
-        [
-          {
-            entityName: pluginAction.name,
-            dataPath: "data",
-            data: EMPTY_RESPONSE.body,
-          },
-        ],
-        parentSpan,
-      ),
-    );
-
-    if (e instanceof UserCancelledActionExecutionError) {
-      // Case: user cancelled the request of file upload
-      if (filePickerInstrumentation.numberOfFiles > 0) {
-        triggerFileUploadInstrumentation(
-          filePickerInstrumentation,
-          "CANCELLED",
-          "499",
-          pluginAction.name,
-          pluginAction.pluginType,
-          "NA",
-        );
-      }
-
-      throw new UserCancelledActionExecutionError();
-    }
-
-    // In case there is no response from server and files are being uploaded
-    // we report it as INVALID_RESPONSE. The server didn't send any code or the
-    // request was cancelled due to timeout
-    if (filePickerInstrumentation.numberOfFiles > 0) {
-      triggerFileUploadInstrumentation(
-        filePickerInstrumentation,
-        "INVALID_RESPONSE",
-        "444",
-        pluginAction.name,
-        pluginAction.pluginType,
-        "NA",
-      );
-    }
-
-    throw new PluginActionExecutionError("Response not valid", false);
-  }
-}
-
-// Function to send the file upload event to segment
-function triggerFileUploadInstrumentation(
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  filePickerInfo: Record<string, any>,
-  status: string,
-  statusCode: string,
-  pluginName: string,
-  pluginType: string,
-  timeTaken: string,
-) {
-  const { fileSizes, fileTypes, numberOfFiles, totalSize } = filePickerInfo;
-
-  AnalyticsUtil.logEvent("FILE_UPLOAD_COMPLETE", {
-    totalSize,
-    fileSizes,
-    numberOfFiles,
-    fileTypes,
-    status,
-    statusCode,
-    pluginName,
-    pluginType,
-    timeTaken,
-  });
-}
-
-// Function to clear the action responses for the actions which are not runBehaviour: ON_PAGE_LOAD.
-function* clearTriggerActionResponse() {
-  const currentPageActions: ActionData[] = yield select(getCurrentActions);
-
-  for (const action of currentPageActions) {
-    // Clear the action response if the action has data and is not runBehaviour: ON_PAGE_LOAD.
-    if (
-      action.data &&
-      action.config.runBehaviour !== ActionRunBehaviour.ON_PAGE_LOAD
-    ) {
-      yield put(clearActionResponse(action.config.id));
-      yield put(
-        updateActionData([
-          {
-            entityName: action.config.name,
-            dataPath: "data",
-            data: undefined,
-          },
-        ]),
-      );
-    }
-  }
-}
-
-// Function to soft refresh the all the actions on the page.
-function* softRefreshActionsSaga() {
-  //get current pageId
-  const pageId: string = yield select(getCurrentPageId);
-  const applicationId: string = yield select(getCurrentApplicationId);
-
-  // Fetch the page data before refreshing the actions.
-  yield put(fetchPageAction(pageId));
-  //wait for the page to be fetched.
-  yield take([
-    ReduxActionErrorTypes.FETCH_PAGE_ERROR,
-    ReduxActionTypes.FETCH_PAGE_SUCCESS,
-  ]);
-  // Clear appsmith store
-  yield call(handleStoreOperations, [
-    {
-      payload: null,
-      type: "CLEAR_STORE",
-    },
-  ]);
-  // Clear all the action responses on the page
-  yield call(clearTriggerActionResponse);
-  //Rerun all the page load actions on the page
-  yield put(
-    executePageLoadActions(
-      ActionExecutionContext.REFRESH_ACTIONS_ON_ENV_CHANGE,
-    ),
-  );
-  try {
-    // we fork to prevent the call from blocking
-    yield put(softRefreshDatasourceStructure());
-  } catch (error) {}
-  //This will refresh the query editor with the latest datasource structure.
-  // TODO: fix typing of matchQueryBuilderPath, it always returns "any" which can lead to bugs
-  const isQueryPane = matchQueryBuilderPath(window.location.pathname);
-
-  //This is reuired only when the query editor is open.
-  if (isQueryPane) {
-    const basePageId: string = yield select(getCurrentBasePageId);
-
-    yield put(
-      changeQuery({
-        baseQueryId: isQueryPane.params.baseQueryId,
-        basePageId,
-        applicationId,
-      }),
-    );
-  }
-
-  const currentEnvName: string = yield select(getCurrentEnvironmentName);
-
-  toast.show(createMessage(SWITCH_ENVIRONMENT_SUCCESS, currentEnvName), {
-    kind: "success",
-  });
-  yield put({ type: ReduxActionTypes.SWITCH_ENVIRONMENT_SUCCESS });
-}
-
-// This gets called for "onPageUnload" JS actions
-function* executeOnPageUnloadJSAction(pageAction: Action) {
-  const collectionId: string = pageAction.collectionId || "";
-  const pageId: string | undefined = yield select(getCurrentPageId);
-
-  if (!collectionId) return;
-
-  const collection: JSCollection = yield select(
-    getJSCollectionFromAllEntities,
-    collectionId,
-  );
-
-  if (!collection) {
-    appsmithTelemetry.captureException(
-      new Error(
-        "Collection present in layoutOnUnloadActions but no collection exists ",
-      ),
-      {
-        errorName: "MissingJSCollection",
-        extra: {
-          collectionId,
-          actionId: pageAction.id,
-          pageId,
-        },
-      },
-    );
-
-    return;
-  }
-
-  const jsAction = collection.actions.find(
-    (action: JSAction) => action.id === pageAction.id,
-  );
-
-  if (!!jsAction) {
-    yield call(handleExecuteJSFunctionSaga, {
-      action: jsAction,
-      collection,
-      isExecuteJSFunc: true,
-      onPageLoad: false,
-    });
-  }
-}
-
-export function* executePageUnloadActionsSaga() {
-  const span = startRootSpan("executePageUnloadActionsSaga");
-
-  try {
-    const pageOnUnloadActions: Action[] = yield select(
-      getLayoutOnUnloadActions,
-    );
-    const actionCount = pageOnUnloadActions.length;
-
-    setAttributesToSpan(span, { numActions: actionCount });
-
-    // Execute unload actions in parallel batches
-    yield all(
-      pageOnUnloadActions.map((action) =>
-        call(executeOnPageUnloadJSAction, action),
-      ),
-    );
-
-    // Publish success event after all actions are executed
-    yield put({
-      type: ReduxActionTypes.EXECUTE_PAGE_UNLOAD_ACTIONS_SUCCESS,
-    });
-  } catch (e) {
-    log.error(e);
-    AppsmithConsole.error({
-      text: "Failed to execute actions during page unload",
-    });
-    // Publish error event if something goes wrong
-    yield put({
-      type: ReduxActionTypes.EXECUTE_PAGE_UNLOAD_ACTIONS_ERROR,
-    });
-  }
-  endSpan(span);
-}
-// End of Selection
-
-export function* watchPluginActionExecutionSagas() {
-  yield all([
-    takeLatest(ReduxActionTypes.RUN_ACTION_REQUEST, runActionSaga),
-    takeLatest(
-      ReduxActionTypes.RUN_ACTION_SHORTCUT_REQUEST,
-      runActionShortcutSaga,
-    ),
-    takeLatest(
-      ReduxActionTypes.EXECUTE_PAGE_LOAD_ACTIONS,
-      executePageLoadActionsSaga,
-    ),
-    takeLatest(ReduxActionTypes.PLUGIN_SOFT_REFRESH, softRefreshActionsSaga),
-    takeLatest(
-      ReduxActionTypes.EXECUTE_PAGE_UNLOAD_ACTIONS,
-      executePageUnloadActionsSaga,
-    ),
-  ]);
-}
+    // Maintain a blob map to resolve blob
\ No newline at end of file
diff --git a/app/client/src/selectors/__tests__/editorSelectors/pluginActionSelectors.test.ts b/app/client/src/selectors/__tests__/editorSelectors/pluginActionSelectors.test.ts
deleted file mode 100644
index 31ddc86..0000000
--- a/app/client/src/selectors/__tests__/editorSelectors/pluginActionSelectors.test.ts
+++ /dev/null
@@ -1,71 +0,0 @@
-import type { DefaultRootState } from "react-redux";
-import { getLayoutOnUnloadActions } from "selectors/editorSelectors";
-
-describe("getLayoutOnUnloadActions", () => {
-  it("should filter actions by current page ID", () => {
-    const state = {
-      entities: {
-        pageList: { currentPageId: "page1" },
-        jsActions: [
-          {
-            isLoading: false,
-            config: {
-              id: "collection1",
-              pageId: "page1",
-              actions: [
-                {
-                  id: "action1",
-                  pageId: "page1",
-                  runBehaviour: "ON_PAGE_UNLOAD",
-                  name: "myFun1",
-                  fullyQualifiedName: "JSObject1.myFun1",
-                  collectionId: "collection1",
-                },
-                {
-                  id: "action3",
-                  pageId: "page1",
-                  runBehaviour: "ON_PAGE_LOAD",
-                  name: "myFun2",
-                  fullyQualifiedName: "JSObject1.myFun2",
-                  collectionId: "collection1",
-                },
-              ],
-            },
-          },
-          {
-            isLoading: false,
-            config: {
-              id: "collection2",
-              pageId: "page2",
-              actions: [
-                {
-                  id: "action2",
-                  pageId: "page2",
-                  runBehaviour: "ON_PAGE_UNLOAD",
-                  name: "myFun1",
-                  fullyQualifiedName: "JSObject2.myFun1",
-                  collectionId: "collection2",
-                },
-              ],
-            },
-          },
-        ],
-      },
-    };
-
-    const result = getLayoutOnUnloadActions(
-      state as unknown as DefaultRootState,
-    );
-
-    expect(result).toEqual([
-      {
-        id: "action1",
-        pageId: "page1",
-        runBehaviour: "ON_PAGE_UNLOAD",
-        name: "myFun1",
-        fullyQualifiedName: "JSObject1.myFun1",
-        collectionId: "collection1",
-      },
-    ]);
-  });
-});
diff --git a/app/client/src/selectors/editorSelectors.tsx b/app/client/src/selectors/editorSelectors.tsx
index fdbe693..bcd88ce 100644
--- a/app/client/src/selectors/editorSelectors.tsx
+++ b/app/client/src/selectors/editorSelectors.tsx
@@ -126,21 +126,16 @@ export const getPageSavingError = (state: DefaultRootState) => {
   return state.ui.editor.loadingStates.savingError;
 };
 
-export const getCurrentPageId = (state: DefaultRootState) =>
-  state.entities.pageList.currentPageId;
-
 export const getLayoutOnLoadActions = (state: DefaultRootState) =>
   state.ui.editor.pageActions || [];
 
 export const getLayoutOnUnloadActions = createSelector(
-  getCurrentPageId,
   getAllJSCollectionActions,
-  (currentPageId, jsActions) =>
-    jsActions.filter(
-      (action) =>
-        action.runBehaviour === ActionRunBehaviour.ON_PAGE_UNLOAD &&
-        action.pageId === currentPageId,
-    ),
+  (jsActions) => {
+    return jsActions.filter((action) => {
+      return action.runBehaviour === ActionRunBehaviour.ON_PAGE_UNLOAD;
+    });
+  },
 );
 
 export const getLayoutOnLoadIssues = (state: DefaultRootState) => {
@@ -173,6 +168,9 @@ export const getPageByBaseId = (basePageId: string) =>
     pages.find((page) => page.basePageId === basePageId),
   );
 
+export const getCurrentPageId = (state: DefaultRootState) =>
+  state.entities.pageList.currentPageId;
+
 export const getCurrentBasePageId = (state: DefaultRootState) =>
   state.entities.pageList.currentBasePageId;
 
@@ -399,705 +397,4 @@ export const getTemplateMetaWidgets = createSelector(
 
 export const getMetaWidget = (metaWidgetId: string) =>
   createSelector(getMetaWidgets, (metaWidgets) => {
-    return metaWidgets[metaWidgetId];
-  });
-
-export const getMetaWidgetChildrenStructure = (
-  parentWidgetId: string,
-  type: string,
-  hasMetaWidgets = false,
-) =>
-  createSelector(getMetaWidgets, (metaWidgets) => {
-    if (!hasMetaWidgets) return [];
-
-    const structure: CanvasWidgetStructure[] = [];
-
-    Object.values(metaWidgets).forEach((metaWidget) => {
-      if (metaWidget.parentId === parentWidgetId) {
-        structure.push(
-          denormalize(metaWidget.widgetId, metaWidgets, {
-            widgetTypeForHaltingRecursion: type,
-          }),
-        );
-      }
-    });
-
-    return structure;
-  });
-
-export const getCurrentPageName = createSelector(
-  getPageListState,
-  (pageList: PageListReduxState) =>
-    pageList.pages.find((page) => page.pageId === pageList.currentPageId)
-      ?.pageName,
-);
-
-const isModuleWidget = (
-  config: ReturnType<typeof WidgetFactory.getConfigs>[string],
-) => config.type.startsWith("MODULE_WIDGET_");
-
-export const getWidgetCards = createSelector(
-  getIsAutoLayout,
-  getIsAnvilLayout,
-  getWidgetConfigsVersion, // Add dependency on widget configs version
-  (isAutoLayout, isAnvilLayout) => {
-    const widgetConfigs = WidgetFactory.getConfigs();
-    const widgetConfigsArray = Object.values(widgetConfigs);
-    const layoutSystemBasesWidgets = widgetConfigsArray.filter((config) => {
-      const isAnvilWidget = Object.values(WDS_V2_WIDGET_MAP).includes(
-        config.type,
-      );
-
-      if (isAnvilLayout) {
-        return isAnvilWidget;
-      }
-
-      return !isAnvilWidget;
-    });
-    const cards = layoutSystemBasesWidgets.filter((config) => {
-      if (isAirgapped()) {
-        return config.widgetName !== "Map" && !config.hideCard;
-      }
-
-      return !config.hideCard && !isModuleWidget(config);
-    });
-
-    const _cards: WidgetCardProps[] = cards.map((config) => {
-      const {
-        detachFromLayout = false,
-        displayName,
-        displayOrder,
-        iconSVG,
-        isSearchWildcard,
-        key,
-        searchTags,
-        tags,
-        thumbnailSVG,
-        type,
-      } = config;
-      let { columns, rows } = config;
-      const autoLayoutConfig = WidgetFactory.getWidgetAutoLayoutConfig(type);
-
-      if (isAutoLayout && autoLayoutConfig) {
-        rows = autoLayoutConfig?.defaults?.rows ?? rows;
-        columns = autoLayoutConfig?.defaults?.columns ?? columns;
-      }
-
-      const { IconCmp, ThumbnailCmp } = WidgetFactory.getWidgetMethods(
-        config.type,
-      );
-
-      return {
-        key,
-        type,
-        rows,
-        columns,
-        detachFromLayout,
-        displayName,
-        displayOrder,
-        icon: iconSVG,
-        thumbnail: thumbnailSVG,
-        IconCmp,
-        ThumbnailCmp,
-        searchTags,
-        tags,
-        isDynamicHeight: isAutoHeightEnabledForWidget(config as WidgetProps),
-        isSearchWildcard: isSearchWildcard,
-      };
-    });
-    const sortedCards = sortBy(_cards, ["displayName"]);
-
-    return sortedCards;
-  },
-);
-const getIsMobileBreakPoint = (state: DefaultRootState) =>
-  state.ui.mainCanvas.isMobile;
-
-export const getIsAutoLayoutMobileBreakPoint = createSelector(
-  getIsAutoLayout,
-  getIsMobileBreakPoint,
-  (isAutoLayout, isMobileBreakPoint) => {
-    return isAutoLayout && isMobileBreakPoint;
-  },
-);
-
-export const getDimensionMap = createSelector(
-  getIsAutoLayoutMobileBreakPoint,
-  (isAutoLayoutMobileBreakPoint: boolean) => {
-    return isAutoLayoutMobileBreakPoint
-      ? {
-          leftColumn: "mobileLeftColumn",
-          rightColumn: "mobileRightColumn",
-          topRow: "mobileTopRow",
-          bottomRow: "mobileBottomRow",
-        }
-      : DefaultDimensionMap;
-  },
-);
-const addWidgetDimensionProxy = (
-  // TODO: Fix this the next time the file is edited
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  dimensionMap: any,
-  widgets: CanvasWidgetsReduxState,
-) => {
-  const dimensions = Object.keys(dimensionMap);
-  const proxyHandler = {
-    // TODO: Fix this the next time the file is edited
-    // eslint-disable-next-line @typescript-eslint/no-explicit-any
-    get(target: any, prop: any) {
-      if (dimensions.includes(prop)) {
-        const actualMap = dimensionMap[prop];
-
-        if (!!target[actualMap]) {
-          return target[actualMap];
-        }
-      }
-
-      return Reflect.get(target, prop);
-    },
-  };
-
-  return Object.keys(widgets).reduce((allWidgets, each) => {
-    const widget = { ...allWidgets[each] };
-    const proxyWidget = new Proxy(widget, proxyHandler);
-
-    allWidgets = {
-      ...allWidgets,
-      [each]: proxyWidget,
-    };
-
-    return allWidgets;
-  }, widgets);
-};
-
-export const getWidgetsForBreakpoint = createSelector(
-  getDimensionMap,
-  getIsAutoLayoutMobileBreakPoint,
-  getWidgets,
-  (
-    // TODO: Fix this the next time the file is edited
-    // eslint-disable-next-line @typescript-eslint/no-explicit-any
-    dimensionMap: any,
-    isAutoLayoutMobileBreakPoint: boolean,
-    widgets: CanvasWidgetsReduxState,
-  ): CanvasWidgetsReduxState => {
-    if (isAutoLayoutMobileBreakPoint) {
-      return addWidgetDimensionProxy(dimensionMap, widgets);
-    } else {
-      return widgets;
-    }
-  },
-);
-
-export const computeMainContainerWidget = (
-  widget: FlattenedWidgetProps,
-  mainCanvasProps: MainCanvasReduxState,
-) => ({
-  ...widget,
-  rightColumn: mainCanvasProps.width,
-  minHeight: mainCanvasProps.height,
-});
-
-export const getChildWidgets = createSelector(
-  [
-    getCanvasWidgets,
-    getMetaWidgets,
-    getDataTree,
-    getLoadingEntities,
-    getConfigTree,
-    (_state: DefaultRootState, widgetId: string) => widgetId,
-  ],
-  buildChildWidgetTree,
-);
-
-const getOccupiedSpacesForContainer = (
-  containerWidgetId: string,
-  widgets: FlattenedWidgetProps[],
-): OccupiedSpace[] => {
-  return widgets.map((widget) => {
-    const occupiedSpace: OccupiedSpace = {
-      id: widget.widgetId,
-      parentId: containerWidgetId,
-      left: widget.leftColumn,
-      top: widget.topRow,
-      bottom: widget.bottomRow,
-      right: widget.rightColumn,
-    };
-
-    return occupiedSpace;
-  });
-};
-
-const getWidgetSpacesForContainer = (
-  containerWidgetId: string,
-  widgets: FlattenedWidgetProps[],
-  dimensionMap: typeof DefaultDimensionMap,
-): WidgetSpace[] => {
-  const {
-    bottomRow: bottomRowMap,
-    leftColumn: leftColumnMap,
-    rightColumn: rightColumnMap,
-    topRow: topRowMap,
-  } = dimensionMap;
-
-  return widgets.map((widget) => {
-    const hasAutoHeight = isAutoHeightEnabledForWidget(widget);
-    const fixedHeight = hasAutoHeight
-      ? widget.bottomRow - widget.topRow
-      : undefined;
-    const occupiedSpace: WidgetSpace = {
-      id: widget.widgetId,
-      parentId: containerWidgetId,
-      left: widget[leftColumnMap],
-      top: widget[topRowMap],
-      bottom: widget[bottomRowMap],
-      right: widget[rightColumnMap],
-      type: widget.type,
-      isDropTarget: checkIsDropTarget(widget.type),
-      fixedHeight,
-    };
-
-    return occupiedSpace;
-  });
-};
-
-/**
- * Method to build occupied spaces
- *
- * @param widgets canvas Widgets
- * @param fetchNow would return undefined if false
- * @returns An array of occupied spaces
- */
-const generateOccupiedSpacesMap = (
-  widgets: CanvasWidgetsReduxState,
-  fetchNow = true,
-  dimensionMap = DefaultDimensionMap,
-): { [containerWidgetId: string]: WidgetSpace[] } => {
-  const occupiedSpaces: {
-    [containerWidgetId: string]: WidgetSpace[];
-  } = {};
-
-  if (!fetchNow) return {};
-
-  // Get all widgets with type "CONTAINER_WIDGET" and has children
-  const containerWidgets: FlattenedWidgetProps[] = Object.values(
-    widgets,
-  ).filter((widget) => widget.children && widget.children.length > 0);
-
-  // If we have any container widgets
-  if (containerWidgets) {
-    containerWidgets.forEach((containerWidget: FlattenedWidgetProps) => {
-      const containerWidgetId = containerWidget.widgetId;
-      // Get child widgets for the container
-      const childWidgets = Object.keys(widgets).filter(
-        (widgetId) =>
-          containerWidget.children &&
-          containerWidget.children.indexOf(widgetId) > -1 &&
-          !widgets[widgetId].detachFromLayout,
-      );
-
-      // Get the occupied spaces in this container
-      // Assign it to the containerWidgetId key in occupiedSpaces
-      occupiedSpaces[containerWidgetId] = getWidgetSpacesForContainer(
-        containerWidgetId,
-        childWidgets.map((widgetId) => widgets[widgetId]),
-        dimensionMap,
-      );
-    });
-  }
-
-  // Return undefined if there are no occupiedSpaces.
-  return Object.keys(occupiedSpaces).length > 0 ? occupiedSpaces : {};
-};
-
-// returns occupied spaces
-export const getOccupiedSpaces = createSelector(
-  getWidgets,
-  (
-    widgets: CanvasWidgetsReduxState,
-  ): { [containerWidgetId: string]: OccupiedSpace[] } | undefined => {
-    const occupiedSpaces: {
-      [containerWidgetId: string]: OccupiedSpace[];
-    } = {};
-    // Get all widgets with type "CONTAINER_WIDGET" and has children
-    const containerWidgets: FlattenedWidgetProps[] = Object.values(
-      widgets,
-    ).filter((widget) => widget.children && widget.children.length > 0);
-
-    // If we have any container widgets
-    if (containerWidgets) {
-      containerWidgets.forEach((containerWidget: FlattenedWidgetProps) => {
-        const containerWidgetId = containerWidget.widgetId;
-        // Get child widgets for the container
-        // TODO: PERF_FIX (abhinav): This is iterating over all widgets for every widget which has children
-        // We can optimise this by iterating through the children for each widget which has children
-        const childWidgets = Object.keys(widgets).filter(
-          (widgetId) =>
-            containerWidget.children &&
-            containerWidget.children.indexOf(widgetId) > -1 &&
-            !widgets[widgetId].detachFromLayout,
-        );
-
-        // Get the occupied spaces in this container
-        // Assign it to the containerWidgetId key in occupiedSpaces
-        occupiedSpaces[containerWidgetId] = getOccupiedSpacesForContainer(
-          containerWidgetId,
-          childWidgets.map((widgetId) => widgets[widgetId]),
-        );
-      });
-    }
-
-    // Return undefined if there are no occupiedSpaces.
-    return Object.keys(occupiedSpaces).length > 0 ? occupiedSpaces : undefined;
-  },
-);
-
-export const getOccupiedSpacesGroupedByParentCanvas = createSelector(
-  getWidgetsForBreakpoint,
-  (
-    widgets: CanvasWidgetsReduxState,
-  ): {
-    occupiedSpaces: {
-      [parentCanvasWidgetId: string]: Record<
-        string,
-        OccupiedSpace & { originalTop: number; originalBottom: number }
-      >;
-    };
-    canvasLevelMap: Record<string, number>;
-  } => {
-    const occupiedSpaces: {
-      [parentCanvasWidgetId: string]: Record<
-        string,
-        OccupiedSpace & { originalTop: number; originalBottom: number }
-      >;
-    } = {};
-    // Get all widgets with type "CANVAS_WIDGET" and has children
-    // What we're really doing is getting all widgets inside a drop target
-    const canvasWidgets: FlattenedWidgetProps[] = Object.values(widgets).filter(
-      (widget) => widget.type === "CANVAS_WIDGET",
-    );
-
-    // Levels signify how deeply nested a canvas is.
-    // For example, the main canvas is always at level 0, if a container exists on the canvas
-    // Then the canvas within this container will be level 1, and so on.
-    const canvasLevelMap: Record<string, number> = {};
-
-    // If we have any canvas widgets
-    if (canvasWidgets) {
-      // Iterate through the list of canvas widgets
-      canvasWidgets.forEach((canvasWidget: FlattenedWidgetProps) => {
-        // Set the canvas widget id
-        const canvasWidgetId = canvasWidget.widgetId;
-
-        // Get the nesting level of this Canvas:
-        let parentId = canvasWidget.parentId;
-        let level = 0;
-
-        while (parentId) {
-          const parent = widgets[parentId];
-
-          if (parent.type === "CANVAS_WIDGET") level++;
-
-          parentId = parent.parentId;
-        }
-
-        canvasLevelMap[canvasWidget.widgetId] = level;
-        // Initialise the occupied spaces with an empty array
-        occupiedSpaces[canvasWidgetId] = {};
-
-        // If this canvas widget has children
-        if (canvasWidget.children && canvasWidget.children.length > 0) {
-          // Iterate through all children
-          canvasWidget.children.forEach((childWidgetId: string) => {
-            // Get the widget props
-            const widget = widgets[childWidgetId];
-
-            // If the widget is not detached from layout, which means
-            // They actually exist by being displayed within the canvas
-            // (unlike a modal widget or another canvas widget)
-            if (!widget.detachFromLayout) {
-              // Add the occupied space co-ordinates to the initialised array
-              occupiedSpaces[canvasWidgetId][widget.widgetId] = {
-                id: widget.widgetId,
-                parentId: canvasWidgetId,
-                left: widget.leftColumn,
-                top: widget.topRow,
-                bottom: widget.bottomRow,
-                right: widget.rightColumn,
-                originalTop: widget.originalTopRow,
-                originalBottom: widget.originalBottomRow,
-              };
-            }
-          });
-        }
-      });
-    }
-
-    // Return the occupied spaces and the canvas levels.
-    // In an empty canvas occupied spaces will be like so: { "0": [] }
-    return { occupiedSpaces, canvasLevelMap };
-  },
-);
-
-// returns occupied spaces only while dragging or moving
-export const getOccupiedSpacesWhileMoving = createSelector(
-  getWidgets,
-  getIsDraggingOrResizing,
-  getDimensionMap,
-  generateOccupiedSpacesMap,
-);
-
-/**
- *
- * @param widgets
- * @param fetchNow returns undined if false
- * @param containerId id of container whose occupied spaces we are fetching
- * @returns
- */
-const generateOccupiedSpacesForContainer = (
-  widgets: CanvasWidgetsReduxState,
-  fetchNow: boolean,
-  containerId: string | undefined,
-): OccupiedSpace[] | undefined => {
-  if (containerId === null || containerId === undefined || !fetchNow)
-    return undefined;
-
-  const containerWidget: FlattenedWidgetProps = widgets[containerId];
-
-  if (!containerWidget || !containerWidget.children) return undefined;
-
-  // Get child widgets for the container
-  const childWidgets = Object.keys(widgets).filter(
-    (widgetId) =>
-      containerWidget.children &&
-      containerWidget.children.indexOf(widgetId) > -1 &&
-      !widgets[widgetId].detachFromLayout,
-  );
-
-  const occupiedSpaces = getOccupiedSpacesForContainer(
-    containerId,
-    childWidgets.map((widgetId) => widgets[widgetId]),
-  );
-
-  return occupiedSpaces;
-};
-
-// same as getOccupiedSpaces but gets only the container specific ocupied Spaces
-export function getOccupiedSpacesSelectorForContainer(
-  containerId: string | undefined,
-) {
-  return createSelector(getWidgets, (widgets: CanvasWidgetsReduxState) => {
-    return generateOccupiedSpacesForContainer(widgets, true, containerId);
-  });
-}
-
-/**
- *
- * @param widgets
- * @param fetchNow returns undined if false
- * @param containerId id of container whose occupied spaces we are fetching
- * @returns
- */
-const generateWidgetSpacesForContainer = (
-  widgets: CanvasWidgetsReduxState,
-  fetchNow: boolean,
-  containerId: string | undefined,
-  dimensionMap: typeof DefaultDimensionMap,
-): WidgetSpace[] | undefined => {
-  if (containerId === null || containerId === undefined || !fetchNow)
-    return undefined;
-
-  const containerWidget: FlattenedWidgetProps = widgets[containerId];
-
-  if (!containerWidget || !containerWidget.children) return undefined;
-
-  // Get child widgets for the container
-  const childWidgets = Object.keys(widgets).filter(
-    (widgetId) =>
-      containerWidget.children &&
-      containerWidget.children.indexOf(widgetId) > -1 &&
-      !widgets[widgetId].detachFromLayout,
-  );
-
-  const occupiedSpaces = getWidgetSpacesForContainer(
-    containerId,
-    childWidgets.map((widgetId) => widgets[widgetId]),
-    dimensionMap,
-  );
-
-  return occupiedSpaces;
-};
-
-// same as getOccupiedSpaces but gets only the container specific ocupied Spaces only while resizing
-export function getContainerOccupiedSpacesSelectorWhileResizing(
-  containerId: string | undefined,
-) {
-  return createSelector(
-    getWidgets,
-    getIsResizing,
-    (widgets: CanvasWidgetsReduxState, isResizing: boolean) => {
-      return generateOccupiedSpacesForContainer(
-        widgets,
-        isResizing,
-        containerId,
-      );
-    },
-  );
-}
-
-// same as getOccupiedSpaces but gets only the container specific occupied Spaces
-export function getContainerWidgetSpacesSelector(
-  containerId: string | undefined,
-) {
-  return createSelector(
-    getWidgets,
-    getDimensionMap,
-    (
-      widgets: CanvasWidgetsReduxState,
-      dimensionMap: typeof DefaultDimensionMap,
-    ) => {
-      return generateWidgetSpacesForContainer(
-        widgets,
-        true,
-        containerId,
-        dimensionMap,
-      );
-    },
-  );
-}
-
-// same as getOccupiedSpaces but gets only the container specific occupied Spaces
-export function getContainerWidgetSpacesSelectorWhileMoving(
-  containerId: string | undefined,
-) {
-  return createSelector(
-    getWidgets,
-    getIsDraggingOrResizing,
-    getDimensionMap,
-    (
-      widgets: CanvasWidgetsReduxState,
-      isDraggingOrResizing: boolean,
-      dimensionMap,
-    ) => {
-      return generateWidgetSpacesForContainer(
-        widgets,
-        isDraggingOrResizing,
-        containerId,
-        dimensionMap,
-      );
-    },
-  );
-}
-
-export const getJSCollectionDataById = createSelector(
-  [
-    getJSCollections,
-    (state: DefaultRootState, collectionId: string) => collectionId,
-  ],
-  (jsActions, collectionId) => {
-    const action = jsActions.find(
-      (action) => action.config.id === collectionId,
-    );
-
-    if (action) {
-      return action;
-    } else {
-      return undefined;
-    }
-  },
-);
-
-export const getJSCollectionDataByBaseId = createSelector(
-  [
-    getJSCollections,
-    (state: DefaultRootState, baseCollectionId: string) => baseCollectionId,
-  ],
-  (jsActions, baseCollectionId) => {
-    const action = jsActions.find(
-      (action) => action.config.baseId === baseCollectionId,
-    );
-
-    if (action) {
-      return action;
-    } else {
-      return undefined;
-    }
-  },
-);
-
-export const getApplicationLastDeployedAt = (state: DefaultRootState) =>
-  state.ui.applications.currentApplication?.lastDeployedAt;
-
-/**
- * returns the `state.ui.editor.isPreviewMode`
- *
- * @param state DefaultRootState
- * @returns boolean
- */
-export const previewModeSelector = (state: DefaultRootState) => {
-  return state.ui.editor.isPreviewMode;
-};
-
-/**
- * This selector is used to identify if the application is in an edit-only state,
- * meaning it is in the canvas render mode but not in preview or protected mode.
- * This is useful for enabling or disabling certain UI elements or functionalities
- * that are only applicable in this specific mode.
- */
-export const isEditOnlyModeSelector = createSelector(
-  getRenderMode,
-  previewModeSelector,
-  protectedModeSelector,
-  (renderMode, isPreviewMode, isProtectedMode) =>
-    renderMode === RenderModes.CANVAS && !(isPreviewMode || isProtectedMode),
-);
-
-/**
- * returns the `state.ui.editor.zoomLevel`
- *
- * @param state DefaultRootState
- * @returns number
- */
-export const getZoomLevel = (state: DefaultRootState) => {
-  return state.ui.editor.zoomLevel;
-};
-
-/**
- * returns the `state.ui.editor.savingEntity`
- *
- * @param state DefaultRootState
- * @returns boolean
- */
-export const getIsSavingEntity = (state: DefaultRootState) =>
-  state.ui.editor.loadingStates.savingEntity;
-
-export const selectJSCollections = (state: DefaultRootState) =>
-  state.entities.jsActions;
-
-export const showCanvasTopSectionSelector = createSelector(
-  getCanvasWidgets,
-  previewModeSelector,
-  getCurrentPageId,
-  getIsAnonymousDataPopupVisible,
-  (canvasWidgets, inPreviewMode, pageId, isAnonymousDataPopupVisible) => {
-    const state = JSON.parse(
-      localStorage.getItem(LOCAL_STORAGE_KEYS.CANVAS_CARDS_STATE) ?? "{}",
-    );
-
-    if (
-      !state[pageId] ||
-      Object.keys(canvasWidgets).length > 1 ||
-      inPreviewMode ||
-      isAnonymousDataPopupVisible
-    )
-      return false;
-
-    return true;
-  },
-);
-
-export const getGsheetToken = (state: DefaultRootState) =>
-  state.entities.datasources.gsheetToken;
-
-export const getGsheetProjectID = (state: DefaultRootState) =>
-  state.entities.datasources.gsheetProjectID;
+    return metaWidgets[metaWidgetId];
\ No newline at end of file
