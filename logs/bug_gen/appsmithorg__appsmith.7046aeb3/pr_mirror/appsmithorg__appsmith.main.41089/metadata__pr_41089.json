{
    "cost": 0.8792500000000001,
    "rewrites": {
        "appsmithorg__appsmith.7046aeb3/app/client/src/workers/Evaluation/__tests__/evaluation.test.ts": {
            "output": "import type {\n  WidgetEntity,\n  WidgetEntityConfig,\n  ActionEntityConfig,\n  ActionEntity,\n} from \"ee/entities/DataTree/types\";\nimport type { UnEvalTree, ConfigTree } from \"entities/DataTree/dataTreeTypes\";\nimport { ENTITY_TYPE } from \"ee/entities/DataTree/types\";\nimport type { WidgetTypeConfigMap } from \"WidgetProvider/factory/types\";\nimport { RenderModes } from \"constants/WidgetConstants\";\nimport { PluginType } from \"entities/Plugin\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport { ValidationTypes } from \"constants/WidgetValidation\";\nimport WidgetFactory from \"WidgetProvider/factory\";\nimport { generateDataTreeWidget } from \"entities/DataTree/dataTreeWidget\";\nimport { sortObjectWithArray } from \"../../../utils/treeUtils\";\nimport klona from \"klona\";\nimport { APP_MODE } from \"entities/App\";\nimport { ActionRunBehaviour } from \"PluginActionEditor/types/PluginActionTypes\";\nimport { EvaluationSubstitutionType } from \"constants/EvaluationConstants\";\n\nconst klonaFullSpy = jest.fn();\n\njest.mock(\"klona/full\", () => ({\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  klona: (arg: any) => {\n    klonaFullSpy(arg);\n\n    return klona.klona(arg);\n  },\n}));\nconst klonaJsonSpy = jest.fn();\n\njest.mock(\"klona/json\", () => ({\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  klona: (arg: any) => {\n    klonaJsonSpy(arg);\n\n    return klona.klona(arg);\n  },\n}));\n\nexport const WIDGET_CONFIG_MAP: WidgetTypeConfigMap = {\n  CONTAINER_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  TEXT_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {\n      value: \"{{ this.text }}\",\n    },\n    metaProperties: {},\n  },\n  BUTTON_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  INPUT_WIDGET_V2: {\n    defaultProperties: {\n      text: \"defaultText\",\n    },\n    derivedProperties: {\n      isValid:\n        '{{\\n        function(){\\n          let parsedRegex = null;\\n          if (this.regex) {\\n            /*\\n            * break up the regexp pattern into 4 parts: given regex, regex prefix , regex pattern, regex flags\\n            * Example /test/i will be split into [\"/test/gi\", \"/\", \"test\", \"gi\"]\\n            */\\n            const regexParts = this.regex.match(/(\\\\/?)(.+)\\\\1([a-z]*)/i);\\n            if (!regexParts) {\\n              parsedRegex = new RegExp(this.regex);\\n            } else {\\n              /*\\n              * if we don\\'t have a regex flags (gmisuy), convert provided string into regexp directly\\n              /*\\n              if (regexParts[3] && !/^(?!.*?(.).*?\\\\1)[gmisuy]+$/.test(regexParts[3])) {\\n                parsedRegex = RegExp(this.regex);\\n              }\\n              /*\\n              * if we have a regex flags, use it to form regexp\\n              */\\n              parsedRegex = new RegExp(regexParts[2], regexParts[3]);\\n            }\\n          }\\n          if (this.inputType === \"EMAIL\") {\\n            const emailRegex = new RegExp(/^\\\\w+([\\\\.-]?\\\\w+)*@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+$/);\\n            return emailRegex.test(this.text);\\n          }\\n          else if (this.inputType === \"NUMBER\") {\\n            return !isNaN(this.text)\\n          }\\n          else if (this.isRequired) {\\n            if(this.text && this.text.length) {\\n              if (parsedRegex) {\\n                return parsedRegex.test(this.text)\\n              } else {\\n                return true;\\n              }\\n            } else {\\n              return false;\\n            }\\n          } if (parsedRegex) {\\n            return parsedRegex.test(this.text)\\n          } else {\\n            return true;\\n          }\\n        }()\\n      }}',\n      value: \"{{this.text}}\",\n    },\n    metaProperties: {\n      isFocused: false,\n      isDirty: false,\n    },\n  },\n  CHECKBOX_WIDGET: {\n    defaultProperties: {\n      isChecked: \"defaultCheckedState\",\n    },\n    derivedProperties: {\n      value: \"{{this.isChecked}}\",\n    },\n    metaProperties: {},\n  },\n  SELECT_WIDGET: {\n    defaultProperties: {\n      selectedOption: \"defaultOptionValue\",\n      filterText: \"\",\n    },\n    derivedProperties: {\n      selectedOptionLabel: `{{_.isPlainObject(this.selectedOption) ? this.selectedOption?.label : this.selectedOption}}`,\n      selectedOptionValue: `{{_.isPlainObject(this.selectedOption) ? this.selectedOption?.value : this.selectedOption}}`,\n      isValid: `{{this.isRequired  ? !!this.selectedOptionValue || this.selectedOptionValue === 0 : true}}`,\n    },\n    metaProperties: {\n      selectedOption: undefined,\n      filterText: \"\",\n    },\n  },\n  RADIO_GROUP_WIDGET: {\n    defaultProperties: {\n      selectedOptionValue: \"defaultOptionValue\",\n    },\n    derivedProperties: {\n      selectedOption:\n        \"{{_.find(this.options, { value: this.selectedOptionValue })}}\",\n      isValid: \"{{ this.isRequired ? !!this.selectedOptionValue : true }}\",\n      value: \"{{this.selectedOptionValue}}\",\n    },\n    metaProperties: {},\n  },\n  IMAGE_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  TABLE_WIDGET: {\n    defaultProperties: {\n      searchText: \"defaultSearchText\",\n      selectedRowIndex: \"defaultSelectedRow\",\n      selectedRowIndices: \"defaultSelectedRow\",\n    },\n    derivedProperties: {\n      selectedRow: `{{ _.get(this.filteredTableData, this.selectedRowIndex, _.mapValues(this.filteredTableData[0], () => undefined)) }}`,\n      selectedRows: `{{ this.filteredTableData.filter((item, i) => selectedRowIndices.includes(i) }); }}`,\n    },\n    metaProperties: {\n      pageNo: 1,\n      selectedRows: [],\n    },\n  },\n  TABLE_WIDGET_V2: {\n    defaultProperties: {\n      searchText: \"defaultSearchText\",\n      selectedRowIndex: \"defaultSelectedRow\",\n      selectedRowIndices: \"defaultSelectedRow\",\n    },\n    derivedProperties: {\n      selectedRow: `{{ _.get(this.filteredTableData, this.selectedRowIndex, _.mapValues(this.filteredTableData[0], () => undefined)) }}`,\n      selectedRows: `{{ this.filteredTableData.filter((item, i) => selectedRowIndices.includes(i) }); }}`,\n    },\n    metaProperties: {\n      pageNo: 1,\n      selectedRow: {},\n      selectedRows: [],\n    },\n  },\n  VIDEO_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {\n      playState: \"NOT_STARTED\",\n    },\n  },\n  FILE_PICKER_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {\n      isValid: \"{{ this.isRequired ? this.files.length > 0 : true }}\",\n      value: \"{{this.files}}\",\n    },\n    metaProperties: {\n      files: [],\n      uploadedFileData: {},\n    },\n  },\n  DATE_PICKER_WIDGET: {\n    defaultProperties: {\n      selectedDate: \"defaultDate\",\n    },\n    derivedProperties: {\n      isValid: \"{{ this.isRequired ? !!this.selectedDate : true }}\",\n      value: \"{{ this.selectedDate }}\",\n    },\n    metaProperties: {},\n  },\n  DATE_PICKER_WIDGET2: {\n    defaultProperties: {\n      selectedDate: \"defaultDate\",\n    },\n    derivedProperties: {\n      isValid: \"{{ this.isRequired ? !!this.selectedDate : true }}\",\n      value: \"{{ this.selectedDate }}\",\n    },\n    metaProperties: {},\n  },\n  TABS_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {\n      selectedTab:\n        \"{{_.find(this.tabs, { widgetId: this.selectedTabWidgetId }).label}}\",\n    },\n    metaProperties: {},\n  },\n  MODAL_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  RICH_TEXT_EDITOR_WIDGET: {\n    defaultProperties: {\n      text: \"defaultText\",\n    },\n    derivedProperties: {\n      value: \"{{this.text}}\",\n    },\n    metaProperties: {},\n  },\n  CHART_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  FORM_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  FORM_BUTTON_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  MAP_WIDGET: {\n    defaultProperties: {\n      markers: \"defaultMarkers\",\n      center: \"mapCenter\",\n    },\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  CANVAS_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  ICON_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  SKELETON_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n};\n\nexport const BASE_WIDGET = {\n  widgetId: \"randomID\",\n  widgetName: \"randomWidgetName\",\n  bottomRow: 0,\n  isLoading: false,\n  leftColumn: 0,\n  parentColumnSpace: 0,\n  parentRowSpace: 0,\n  renderMode: RenderModes.CANVAS,\n  rightColumn: 0,\n  topRow: 0,\n  type: \"SKELETON_WIDGET\",\n  parentId: \"0\",\n  version: 1,\n  ENTITY_TYPE: ENTITY_TYPE.WIDGET,\n  meta: {},\n} as unknown as WidgetEntity;\n\nexport const BASE_WIDGET_CONFIG = {\n  logBlackList: {},\n  widgetId: \"randomID\",\n  type: \"SKELETON_WIDGET\",\n  ENTITY_TYPE: ENTITY_TYPE.WIDGET,\n} as unknown as WidgetEntityConfig;\n\nexport const BASE_ACTION: ActionEntity = {\n  clear: {},\n  actionId: \"randomId\",\n  datasourceUrl: \"\",\n  config: {\n    timeoutInMillisecond: 10,\n  },\n  isLoading: false,\n  run: {},\n  data: {},\n  responseMeta: { isExecutionSuccess: false },\n  ENTITY_TYPE: ENTITY_TYPE.ACTION,\n};\nexport const BASE_ACTION_CONFIG: ActionEntityConfig = {\n  actionId: \"randomId\",\n  logBlackList: {},\n  pluginId: \"\",\n  name: \"randomActionName\",\n  dynamicBindingPathList: [],\n  pluginType: PluginType.API,\n  ENTITY_TYPE: ENTITY_TYPE.ACTION,\n  bindingPaths: {},\n  reactivePaths: {\n    isLoading: EvaluationSubstitutionType.TEMPLATE,\n    data: EvaluationSubstitutionType.TEMPLATE,\n  },\n  dependencyMap: {},\n  dynamicTriggerPathList: [],\n  runBehaviour: ActionRunBehaviour.MANUAL,\n};\n\nconst metaMock = jest.spyOn(WidgetFactory, \"getWidgetMetaPropertiesMap\");\n\nconst mockDefault = jest.spyOn(WidgetFactory, \"getWidgetDefaultPropertiesMap\");\n\nconst mockDerived = jest.spyOn(WidgetFactory, \"getWidgetDerivedPropertiesMap\");\n\nconst initialdependencies = {\n  Dropdown1: [\n    \"Dropdown1.defaultOptionValue\",\n    \"Dropdown1.filterText\",\n    \"Dropdown1.isValid\",\n    \"Dropdown1.meta\",\n    \"Dropdown1.selectedOption\",\n    \"Dropdown1.selectedOptionLabel\",\n    \"Dropdown1.selectedOptionValue\",\n  ],\n  \"Dropdown1.isValid\": [\"Dropdown1.selectedOptionValue\"],\n  \"Dropdown1.filterText\": [\"Dropdown1.meta.filterText\"],\n  \"Dropdown1.meta\": [\n    \"Dropdown1.meta.filterText\",\n    \"Dropdown1.meta.selectedOption\",\n  ],\n  \"Dropdown1.selectedOption\": [\n    \"Dropdown1.defaultOptionValue\",\n    \"Dropdown1.meta.selectedOption\",\n  ],\n  \"Dropdown1.selectedOptionLabel\": [\"Dropdown1.selectedOption\"],\n  \"Dropdown1.selectedOptionValue\": [\"Dropdown1.selectedOption\"],\n  Table1: [\n    \"Table1.defaultSearchText\",\n    \"Table1.defaultSelectedRow\",\n    \"Table1.searchText\",\n    \"Table1.selectedRow\",\n    \"Table1.selectedRowIndex\",\n    \"Table1.selectedRowIndices\",\n    \"Table1.selectedRows\",\n    \"Table1.tableData\",\n  ],\n  \"Table1.searchText\": [\"Table1.defaultSearchText\"],\n  \"Table1.selectedRow\": [\"Table1.selectedRowIndex\"],\n  \"Table1.selectedRowIndex\": [\"Table1.defaultSelectedRow\"],\n  \"Table1.selectedRowIndices\": [\"Table1.defaultSelectedRow\"],\n  \"Table1.selectedRows\": [],\n  \"Table1.tableData\": [\"Text1.text\"],\n  Text1: [\"Text1.text\", \"Text1.value\"],\n  \"Text1.value\": [\"Text1.text\"],\n  Text2: [\"Text2.text\", \"Text2.value\"],\n  \"Text2.text\": [\"Text1.text\"],\n  \"Text2.value\": [\"Text2.text\"],\n  Text3: [\"Text3.text\", \"Text3.value\"],\n  \"Text3.value\": [\"Text3.text\"],\n  \"Text3.text\": [\"Text1.text\"],\n  Text4: [\"Text4.text\", \"Text4.value\"],\n  \"Text4.text\": [\"Table1.selectedRow\"],\n  \"Text4.value\": [\"Text4.text\"],\n};\n\ndescribe(\"DataTreeEvaluator\", () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n  metaMock.mockImplementation((type) => {\n    return WIDGET_CONFIG_MAP[type].metaProperties;\n  });\n  mockDefault.mockImplementation((type) => {\n    return WIDGET_CONFIG_MAP[type].defaultProperties;\n  });\n  mockDerived.mockImplementation((type) => {\n    return WIDGET_CONFIG_MAP[type].derivedProperties;\n  });\n  //Input1\n  const { configEntity, unEvalEntity } = generateDataTreeWidget(\n    {\n      ...BASE_WIDGET,\n      text: undefined,\n      defaultText: \"Default value\",\n      widgetName: \"Input1\",\n      type: \"INPUT_WIDGET_V2\",\n      reactivePaths: {\n        defaultText: EvaluationSubstitutionType.TEMPLATE,\n        isValid: EvaluationSub",
            "output_extracted": "import type {\n  WidgetEntity,\n  WidgetEntityConfig,\n  ActionEntityConfig,\n  ActionEntity,\n} from \"ee/entities/DataTree/types\";\nimport type { UnEvalTree, ConfigTree } from \"entities/DataTree/dataTreeTypes\";\nimport { ENTITY_TYPE } from \"ee/entities/DataTree/types\";\nimport type { WidgetTypeConfigMap } from \"WidgetProvider/factory/types\";\nimport { RenderModes } from \"constants/WidgetConstants\";\nimport { PluginType } from \"entities/Plugin\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport { ValidationTypes } from \"constants/WidgetValidation\";\nimport WidgetFactory from \"WidgetProvider/factory\";\nimport { generateDataTreeWidget } from \"entities/DataTree/dataTreeWidget\";\nimport { sortObjectWithArray } from \"../../../utils/treeUtils\";\nimport klona from \"klona\";\nimport { APP_MODE } from \"entities/App\";\nimport { ActionRunBehaviour } from \"PluginActionEditor/types/PluginActionTypes\";\nimport { EvaluationSubstitutionType } from \"constants/EvaluationConstants\";\n\nconst klonaFullSpy = jest.fn();\n\njest.mock(\"klona/full\", () => ({\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  klona: (arg: any) => {\n    klonaFullSpy(arg);\n\n    return klona.klona(arg);\n  },\n}));\nconst klonaJsonSpy = jest.fn();\n\njest.mock(\"klona/json\", () => ({\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  klona: (arg: any) => {\n    klonaJsonSpy(arg);\n\n    return klona.klona(arg);\n  },\n}));\n\nexport const WIDGET_CONFIG_MAP: WidgetTypeConfigMap = {\n  CONTAINER_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  TEXT_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {\n      value: \"{{ this.text }}\",\n    },\n    metaProperties: {},\n  },\n  BUTTON_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  INPUT_WIDGET_V2: {\n    defaultProperties: {\n      text: \"defaultText\",\n    },\n    derivedProperties: {\n      isValid:\n        '{{\\n        function(){\\n          let parsedRegex = null;\\n          if (this.regex) {\\n            /*\\n            * break up the regexp pattern into 4 parts: given regex, regex prefix , regex pattern, regex flags\\n            * Example /test/i will be split into [\"/test/gi\", \"/\", \"test\", \"gi\"]\\n            */\\n            const regexParts = this.regex.match(/(\\\\/?)(.+)\\\\1([a-z]*)/i);\\n            if (!regexParts) {\\n              parsedRegex = new RegExp(this.regex);\\n            } else {\\n              /*\\n              * if we don\\'t have a regex flags (gmisuy), convert provided string into regexp directly\\n              /*\\n              if (regexParts[3] && !/^(?!.*?(.).*?\\\\1)[gmisuy]+$/.test(regexParts[3])) {\\n                parsedRegex = RegExp(this.regex);\\n              }\\n              /*\\n              * if we have a regex flags, use it to form regexp\\n              */\\n              parsedRegex = new RegExp(regexParts[2], regexParts[3]);\\n            }\\n          }\\n          if (this.inputType === \"EMAIL\") {\\n            const emailRegex = new RegExp(/^\\\\w+([\\\\.-]?\\\\w+)*@\\\\w+([\\\\.-]?\\\\w+)*(\\\\.\\\\w{2,3})+$/);\\n            return emailRegex.test(this.text);\\n          }\\n          else if (this.inputType === \"NUMBER\") {\\n            return !isNaN(this.text)\\n          }\\n          else if (this.isRequired) {\\n            if(this.text && this.text.length) {\\n              if (parsedRegex) {\\n                return parsedRegex.test(this.text)\\n              } else {\\n                return true;\\n              }\\n            } else {\\n              return false;\\n            }\\n          } if (parsedRegex) {\\n            return parsedRegex.test(this.text)\\n          } else {\\n            return true;\\n          }\\n        }()\\n      }}',\n      value: \"{{this.text}}\",\n    },\n    metaProperties: {\n      isFocused: false,\n      isDirty: false,\n    },\n  },\n  CHECKBOX_WIDGET: {\n    defaultProperties: {\n      isChecked: \"defaultCheckedState\",\n    },\n    derivedProperties: {\n      value: \"{{this.isChecked}}\",\n    },\n    metaProperties: {},\n  },\n  SELECT_WIDGET: {\n    defaultProperties: {\n      selectedOption: \"defaultOptionValue\",\n      filterText: \"\",\n    },\n    derivedProperties: {\n      selectedOptionLabel: `{{_.isPlainObject(this.selectedOption) ? this.selectedOption?.label : this.selectedOption}}`,\n      selectedOptionValue: `{{_.isPlainObject(this.selectedOption) ? this.selectedOption?.value : this.selectedOption}}`,\n      isValid: `{{this.isRequired  ? !!this.selectedOptionValue || this.selectedOptionValue === 0 : true}}`,\n    },\n    metaProperties: {\n      selectedOption: undefined,\n      filterText: \"\",\n    },\n  },\n  RADIO_GROUP_WIDGET: {\n    defaultProperties: {\n      selectedOptionValue: \"defaultOptionValue\",\n    },\n    derivedProperties: {\n      selectedOption:\n        \"{{_.find(this.options, { value: this.selectedOptionValue })}}\",\n      isValid: \"{{ this.isRequired ? !!this.selectedOptionValue : true }}\",\n      value: \"{{this.selectedOptionValue}}\",\n    },\n    metaProperties: {},\n  },\n  IMAGE_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  TABLE_WIDGET: {\n    defaultProperties: {\n      searchText: \"defaultSearchText\",\n      selectedRowIndex: \"defaultSelectedRow\",\n      selectedRowIndices: \"defaultSelectedRow\",\n    },\n    derivedProperties: {\n      selectedRow: `{{ _.get(this.filteredTableData, this.selectedRowIndex, _.mapValues(this.filteredTableData[0], () => undefined)) }}`,\n      selectedRows: `{{ this.filteredTableData.filter((item, i) => selectedRowIndices.includes(i) }); }}`,\n    },\n    metaProperties: {\n      pageNo: 1,\n      selectedRows: [],\n    },\n  },\n  TABLE_WIDGET_V2: {\n    defaultProperties: {\n      searchText: \"defaultSearchText\",\n      selectedRowIndex: \"defaultSelectedRow\",\n      selectedRowIndices: \"defaultSelectedRow\",\n    },\n    derivedProperties: {\n      selectedRow: `{{ _.get(this.filteredTableData, this.selectedRowIndex, _.mapValues(this.filteredTableData[0], () => undefined)) }}`,\n      selectedRows: `{{ this.filteredTableData.filter((item, i) => selectedRowIndices.includes(i) }); }}`,\n    },\n    metaProperties: {\n      pageNo: 1,\n      selectedRow: {},\n      selectedRows: [],\n    },\n  },\n  VIDEO_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {\n      playState: \"NOT_STARTED\",\n    },\n  },\n  FILE_PICKER_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {\n      isValid: \"{{ this.isRequired ? this.files.length > 0 : true }}\",\n      value: \"{{this.files}}\",\n    },\n    metaProperties: {\n      files: [],\n      uploadedFileData: {},\n    },\n  },\n  DATE_PICKER_WIDGET: {\n    defaultProperties: {\n      selectedDate: \"defaultDate\",\n    },\n    derivedProperties: {\n      isValid: \"{{ this.isRequired ? !!this.selectedDate : true }}\",\n      value: \"{{ this.selectedDate }}\",\n    },\n    metaProperties: {},\n  },\n  DATE_PICKER_WIDGET2: {\n    defaultProperties: {\n      selectedDate: \"defaultDate\",\n    },\n    derivedProperties: {\n      isValid: \"{{ this.isRequired ? !!this.selectedDate : true }}\",\n      value: \"{{ this.selectedDate }}\",\n    },\n    metaProperties: {},\n  },\n  TABS_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {\n      selectedTab:\n        \"{{_.find(this.tabs, { widgetId: this.selectedTabWidgetId }).label}}\",\n    },\n    metaProperties: {},\n  },\n  MODAL_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  RICH_TEXT_EDITOR_WIDGET: {\n    defaultProperties: {\n      text: \"defaultText\",\n    },\n    derivedProperties: {\n      value: \"{{this.text}}\",\n    },\n    metaProperties: {},\n  },\n  CHART_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  FORM_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  FORM_BUTTON_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  MAP_WIDGET: {\n    defaultProperties: {\n      markers: \"defaultMarkers\",\n      center: \"mapCenter\",\n    },\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  CANVAS_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  ICON_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n  SKELETON_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {},\n    metaProperties: {},\n  },\n};\n\nexport const BASE_WIDGET = {\n  widgetId: \"randomID\",\n  widgetName: \"randomWidgetName\",\n  bottomRow: 0,\n  isLoading: false,\n  leftColumn: 0,\n  parentColumnSpace: 0,\n  parentRowSpace: 0,\n  renderMode: RenderModes.CANVAS,\n  rightColumn: 0,\n  topRow: 0,\n  type: \"SKELETON_WIDGET\",\n  parentId: \"0\",\n  version: 1,\n  ENTITY_TYPE: ENTITY_TYPE.WIDGET,\n  meta: {},\n} as unknown as WidgetEntity;\n\nexport const BASE_WIDGET_CONFIG = {\n  logBlackList: {},\n  widgetId: \"randomID\",\n  type: \"SKELETON_WIDGET\",\n  ENTITY_TYPE: ENTITY_TYPE.WIDGET,\n} as unknown as WidgetEntityConfig;\n\nexport const BASE_ACTION: ActionEntity = {\n  clear: {},\n  actionId: \"randomId\",\n  datasourceUrl: \"\",\n  config: {\n    timeoutInMillisecond: 10,\n  },\n  isLoading: false,\n  run: {},\n  data: {},\n  responseMeta: { isExecutionSuccess: false },\n  ENTITY_TYPE: ENTITY_TYPE.ACTION,\n};\nexport const BASE_ACTION_CONFIG: ActionEntityConfig = {\n  actionId: \"randomId\",\n  logBlackList: {},\n  pluginId: \"\",\n  name: \"randomActionName\",\n  dynamicBindingPathList: [],\n  pluginType: PluginType.API,\n  ENTITY_TYPE: ENTITY_TYPE.ACTION,\n  bindingPaths: {},\n  reactivePaths: {\n    isLoading: EvaluationSubstitutionType.TEMPLATE,\n    data: EvaluationSubstitutionType.TEMPLATE,\n  },\n  dependencyMap: {},\n  dynamicTriggerPathList: [],\n  runBehaviour: ActionRunBehaviour.MANUAL,\n};\n\nconst metaMock = jest.spyOn(WidgetFactory, \"getWidgetMetaPropertiesMap\");\n\nconst mockDefault = jest.spyOn(WidgetFactory, \"getWidgetDefaultPropertiesMap\");\n\nconst mockDerived = jest.spyOn(WidgetFactory, \"getWidgetDerivedPropertiesMap\");\n\nconst initialdependencies = {\n  Dropdown1: [\n    \"Dropdown1.defaultOptionValue\",\n    \"Dropdown1.filterText\",\n    \"Dropdown1.isValid\",\n    \"Dropdown1.meta\",\n    \"Dropdown1.selectedOption\",\n    \"Dropdown1.selectedOptionLabel\",\n    \"Dropdown1.selectedOptionValue\",\n  ],\n  \"Dropdown1.isValid\": [\"Dropdown1.selectedOptionValue\"],\n  \"Dropdown1.filterText\": [\"Dropdown1.meta.filterText\"],\n  \"Dropdown1.meta\": [\n    \"Dropdown1.meta.filterText\",\n    \"Dropdown1.meta.selectedOption\",\n  ],\n  \"Dropdown1.selectedOption\": [\n    \"Dropdown1.defaultOptionValue\",\n    \"Dropdown1.meta.selectedOption\",\n  ],\n  \"Dropdown1.selectedOptionLabel\": [\"Dropdown1.selectedOption\"],\n  \"Dropdown1.selectedOptionValue\": [\"Dropdown1.selectedOption\"],\n  Table1: [\n    \"Table1.defaultSearchText\",\n    \"Table1.defaultSelectedRow\",\n    \"Table1.searchText\",\n    \"Table1.selectedRow\",\n    \"Table1.selectedRowIndex\",\n    \"Table1.selectedRowIndices\",\n    \"Table1.selectedRows\",\n    \"Table1.tableData\",\n  ],\n  \"Table1.searchText\": [\"Table1.defaultSearchText\"],\n  \"Table1.selectedRow\": [\"Table1.selectedRowIndex\"],\n  \"Table1.selectedRowIndex\": [\"Table1.defaultSelectedRow\"],\n  \"Table1.selectedRowIndices\": [\"Table1.defaultSelectedRow\"],\n  \"Table1.selectedRows\": [],\n  \"Table1.tableData\": [\"Text1.text\"],\n  Text1: [\"Text1.text\", \"Text1.value\"],\n  \"Text1.value\": [\"Text1.text\"],\n  Text2: [\"Text2.text\", \"Text2.value\"],\n  \"Text2.text\": [\"Text1.text\"],\n  \"Text2.value\": [\"Text2.text\"],\n  Text3: [\"Text3.text\", \"Text3.value\"],\n  \"Text3.value\": [\"Text3.text\"],\n  \"Text3.text\": [\"Text1.text\"],\n  Text4: [\"Text4.text\", \"Text4.value\"],\n  \"Text4.text\": [\"Table1.selectedRow\"],\n  \"Text4.value\": [\"Text4.text\"],\n};\n\ndescribe(\"DataTreeEvaluator\", () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n  metaMock.mockImplementation((type) => {\n    return WIDGET_CONFIG_MAP[type].metaProperties;\n  });\n  mockDefault.mockImplementation((type) => {\n    return WIDGET_CONFIG_MAP[type].defaultProperties;\n  });\n  mockDerived.mockImplementation((type) => {\n    return WIDGET_CONFIG_MAP[type].derivedProperties;\n  });\n  //Input1\n  const { configEntity, unEvalEntity } = generateDataTreeWidget(\n    {\n      ...BASE_WIDGET,\n      text: undefined,\n      defaultText: \"Default value\",\n      widgetName: \"Input1\",\n      type: \"INPUT_WIDGET_V2\",\n      reactivePaths: {\n        defaultText: EvaluationSubstitutionType.TEMPLATE,\n        isValid: EvaluationSub",
            "cost": 0.16184
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/workers/Evaluation/evalTreeWithChanges.test.ts": {
            "output": "import type { WidgetEntityConfig } from \"ee/entities/DataTree/types\";\nimport { DataTreeDiffEvent } from \"ee/workers/Evaluation/evaluationUtils\";\nimport { RenderModes } from \"constants/WidgetConstants\";\nimport { ENTITY_TYPE } from \"ee/entities/DataTree/types\";\nimport type { ConfigTree } from \"entities/DataTree/dataTreeTypes\";\nimport { generateDataTreeWidget } from \"entities/DataTree/dataTreeWidget\";\nimport { create } from \"mutative\";\nimport { klona } from \"klona/json\";\nimport type { WidgetEntity } from \"plugins/Linting/lib/entity/WidgetEntity\";\nimport type { UpdateDataTreeMessageData } from \"sagas/types\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport * as evalTreeWithChanges from \"./evalTreeWithChanges\";\nimport { APP_MODE } from \"entities/App\";\nimport { updateEvalProps } from \"./helpers\";\nexport const BASE_WIDGET = {\n  widgetId: \"randomID\",\n  widgetName: \"randomWidgetName\",\n  bottomRow: 0,\n  isLoading: false,\n  leftColumn: 0,\n  parentColumnSpace: 0,\n  parentRowSpace: 0,\n  renderMode: RenderModes.CANVAS,\n  rightColumn: 0,\n  topRow: 0,\n  type: \"SKELETON_WIDGET\",\n  parentId: \"0\",\n  version: 1,\n  ENTITY_TYPE: ENTITY_TYPE.WIDGET,\n  meta: {},\n} as unknown as WidgetEntity;\n\nexport const BASE_WIDGET_CONFIG = {\n  logBlackList: {},\n  widgetId: \"randomID\",\n  type: \"SKELETON_WIDGET\",\n  ENTITY_TYPE: ENTITY_TYPE.WIDGET,\n} as unknown as WidgetEntityConfig;\n\nconst WIDGET_CONFIG_MAP = {\n  TEXT_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {\n      value: \"{{ this.text }}\",\n    },\n    metaProperties: {},\n  },\n};\n\nconst configTree: ConfigTree = {\n  Text1: generateDataTreeWidget(\n    {\n      ...BASE_WIDGET_CONFIG,\n      ...BASE_WIDGET,\n      widgetName: \"Text1\",\n      text: \"Label\",\n      type: \"TEXT_WIDGET\",\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    {},\n    new Set(),\n  ).configEntity,\n  Text2: generateDataTreeWidget(\n    {\n      ...BASE_WIDGET_CONFIG,\n      ...BASE_WIDGET,\n      widgetName: \"Text2\",\n      text: \"{{Text1.text}}\",\n      dynamicBindingPathList: [{ key: \"text\" }],\n      type: \"TEXT_WIDGET\",\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    {},\n    new Set(),\n  ).configEntity,\n};\n\nconst unEvalTree = {\n  Text1: generateDataTreeWidget(\n    {\n      ...BASE_WIDGET_CONFIG,\n      ...BASE_WIDGET,\n      widgetName: \"Text1\",\n      text: \"Label\",\n      type: \"TEXT_WIDGET\",\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    {},\n    new Set(),\n  ).unEvalEntity,\n  Text2: generateDataTreeWidget(\n    {\n      ...BASE_WIDGET_CONFIG,\n      ...BASE_WIDGET,\n      widgetName: \"Text2\",\n      text: \"{{Text1.text}}\",\n      dynamicBindingPathList: [{ key: \"text\" }],\n      type: \"TEXT_WIDGET\",\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    {},\n    new Set(),\n  ).unEvalEntity,\n};\n\ndescribe(\"evaluateAndPushResponse\", () => {\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let pushResponseToMainThreadMock: any;\n\n  beforeAll(() => {\n    pushResponseToMainThreadMock = jest\n      .spyOn(evalTreeWithChanges, \"pushResponseToMainThread\")\n      .mockImplementation(() => {}); // spy on foo\n  });\n  beforeAll(() => {\n    jest.clearAllMocks();\n  });\n  test(\"should call pushResponseToMainThread when we evaluate and push updates\", () => {\n    evalTreeWithChanges.evaluateAndPushResponse(\n      undefined,\n      {\n        unEvalUpdates: [],\n        evalOrder: [],\n        jsUpdates: {},\n      },\n      [],\n      [],\n      {},\n    );\n    // check if push response has been called\n    expect(pushResponseToMainThreadMock).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"getAffectedNodesInTheDataTree\", () => {\n  test(\"should merge paths from unEvalUpdates and evalOrder\", () => {\n    const result = evalTreeWithChanges.getAffectedNodesInTheDataTree(\n      [\n        {\n          event: DataTreeDiffEvent.NOOP,\n          payload: {\n            propertyPath: \"Text2.text\",\n            value: \"\",\n          },\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } as any,\n      ],\n      [\"Text1.text\"],\n    );\n\n    expect(result).toEqual([\"Text2.text\", \"Text1.text\"]);\n  });\n  test(\"should extract unique paths from unEvalUpdates and evalOrder\", () => {\n    const result = evalTreeWithChanges.getAffectedNodesInTheDataTree(\n      [\n        {\n          event: DataTreeDiffEvent.NOOP,\n          payload: {\n            propertyPath: \"Text1.text\",\n            value: \"\",\n          },\n        },\n      ],\n      [\"Text1.text\"],\n    );\n\n    expect(result).toEqual([\"Text1.text\"]);\n  });\n});\n\ndescribe(\"evaluateAndGenerateResponse\", () => {\n  let evaluator: DataTreeEvaluator;\n  const UPDATED_LABEL = \"updated Label\";\n\n  const getParsedUpdatesFromWebWorkerResp = (\n    webworkerResponse: UpdateDataTreeMessageData,\n  ) => {\n    const updates = JSON.parse(webworkerResponse.workerResponse.updates);\n\n    //scrub out all __evaluation__ patches\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return updates.filter((p: any) => !p.rhs.__evaluation__);\n  };\n\n  beforeEach(async () => {\n    // we are mimicking the first tree evaluation flow here\n    evaluator = new DataTreeEvaluator(WIDGET_CONFIG_MAP);\n    await evaluator.setupFirstTree(\n      unEvalTree,\n      configTree,\n      {},\n      {\n        appId: \"appId\",\n        pageId: \"pageId\",\n        timestamp: \"timestamp\",\n        appMode: APP_MODE.PUBLISHED,\n        instanceId: \"instanceId\",\n        dslVersion: 1,\n      },\n    );\n    evaluator.evalAndValidateFirstTree();\n    const dataTree = updateEvalProps(evaluator) || {};\n\n    // over here we are setting the prevState through a klona but in the first tree we set by parsing the serialised update which is functionally the same\n    evaluator?.setPrevState(klona(dataTree));\n  });\n\n  test(\"inital evaluation successful should be successful\", () => {\n    expect(evaluator.evalTree).toHaveProperty(\"Text2.text\", \"Label\");\n  });\n\n  test(\"should respond with default values when dataTreeEvaluator is not provided\", () => {\n    const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n      undefined,\n      {\n        unEvalUpdates: [],\n        evalOrder: [],\n        jsUpdates: {},\n      },\n      [],\n      [],\n      {},\n    );\n    const parsedUpdates = getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n    expect(parsedUpdates).toEqual([]);\n    expect(webworkerResponse).toEqual({\n      workerResponse: {\n        dependencies: {},\n        errors: [],\n        evalMetaUpdates: [],\n        evaluationOrder: [],\n        executeReactiveActions: [],\n        isCreateFirstTree: false,\n        isNewWidgetAdded: false,\n        jsUpdates: {},\n        jsVarsCreatedEvent: [],\n        logs: [],\n        removedPaths: [],\n        staleMetaIds: [],\n        unEvalUpdates: [],\n        undefinedEvalValuesMap: {},\n        updates: \"[]\",\n      },\n    });\n  });\n  test(\"should generate no updates when the updateTreeResponse is empty\", () => {\n    const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n      evaluator,\n      {\n        unEvalUpdates: [],\n        evalOrder: [],\n        jsUpdates: {},\n      },\n      [],\n      [],\n      {},\n    );\n    const parsedUpdates = getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n    expect(parsedUpdates).toEqual([]);\n  });\n\n  describe(\"updates\", () => {\n    test(\"should generate updates based on the unEvalUpdates\", () => {\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const updatedLabelUnevalTree = create(unEvalTree, (draft: any) => {\n        draft.Text1.text = UPDATED_LABEL;\n        draft.Text1.label = UPDATED_LABEL;\n      });\n      const updateTreeResponse = evaluator.setupUpdateTree(\n        updatedLabelUnevalTree,\n        configTree,\n      );\n\n      // ignore label Text1.label uneval update and just include Text1.text uneval update\n      updateTreeResponse.unEvalUpdates = [\n        {\n          event: DataTreeDiffEvent.NOOP,\n          payload: {\n            propertyPath: \"Text1.text\",\n            value: \"\",\n          },\n        },\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ] as any;\n      // the eval tree should have the uneval update but the diff should not be generated because the unEvalUpdates has been altered\n      expect(evaluator.evalTree).toHaveProperty(\"Text1.text\", UPDATED_LABEL);\n\n      const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n        evaluator,\n        updateTreeResponse,\n        [],\n        [],\n        {},\n      );\n\n      expect(webworkerResponse.workerResponse.dependencies).toEqual({\n        \"Text1.text\": [\"Text2.text\", \"Text1\"],\n        \"Text2.text\": [\"Text2\"],\n      });\n      const parsedUpdates =\n        getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n      // Text1.label update should be ignored\n      expect(parsedUpdates).not.toEqual(\n        expect.arrayContaining([\n          {\n            kind: \"N\",\n            path: [\"Text1\", \"label\"],\n            rhs: UPDATED_LABEL,\n          },\n        ]),\n      );\n    });\n    test(\"should generate updates based on the evalOrder\", () => {\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const updatedLabelUnevalTree = create(unEvalTree, (draft: any) => {\n        draft.Text1.text = UPDATED_LABEL;\n      });\n      const updateTreeResponse = evaluator.setupUpdateTree(\n        updatedLabelUnevalTree,\n        configTree,\n      );\n\n      // ignore label Text1.label uneval update and just include Text1.text uneval update\n      // expect(updateTreeResponse.evalOrder).toEqual([]);\n      updateTreeResponse.evalOrder = [];\n\n      const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n        evaluator,\n        updateTreeResponse,\n        [],\n        [],\n        {},\n      );\n      const parsedUpdates =\n        getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n      // Text1.label update should be ignored\n      expect(parsedUpdates).not.toEqual(\n        expect.arrayContaining([\n          {\n            kind: \"N\",\n            path: [\"Text2\", \"text\"],\n            rhs: \"updated Label\",\n          },\n        ]),\n      );\n    });\n    test(\"should generate the correct updates to be sent to the main thread's state when the value tied to a binding changes \", () => {\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const updatedLabelUnevalTree = create(unEvalTree, (draft: any) => {\n        if (draft.Text1?.text) {\n          draft.Text1.text = UPDATED_LABEL;\n        }\n      });\n      const updateTreeResponse = evaluator.setupUpdateTree(\n        updatedLabelUnevalTree,\n        configTree,\n      );\n\n      const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n        evaluator,\n        updateTreeResponse,\n        [],\n        [],\n        {},\n      );\n\n      const parsedUpdates =\n        getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n      expect(parsedUpdates).toEqual(\n        expect.arrayContaining([\n          {\n            kind: \"E\",\n            path: [\"Text1\", \"text\"],\n            rhs: \"updated Label\",\n          },\n          {\n            kind: \"E\",\n            path: [\"Text2\", \"text\"],\n            rhs: \"updated Label\",\n          },\n        ]),\n      );\n\n      expect(evaluator.evalTree).toHaveProperty(\"Text2.text\", UPDATED_LABEL);\n    });\n    test(\"should merge additional updates to the dataTree as well as push the updates back to the main thread's state when unEvalUpdates is ignored\", () => {\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const updatedLabelUnevalTree = create(unEvalTree, (draft: any) => {\n        if (draft.Text1?.text) {\n          draft.Text1.text = UPDATED_LABEL;\n        }\n      });\n      const updateTreeResponse = evaluator.setupUpdateTree(\n        updatedLabelUnevalTree,\n        configTree,\n      );\n\n      //set the unEvalUpdates is empty so that evaluation ignores diffing the node\n      updateTreeResponse.unEvalUpdates = [];\n\n      const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n        evaluator,\n        updateTreeResponse,\n        [],\n        [\"Text1.text\"],\n        {},\n      );\n      const parsedUpdates =\n        getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n      expect(parsedUpdates).toEqual(\n        expect.arrayContaining([\n          {\n            kind: \"N\",\n            path: [\"Text1\", \"text\"],\n            rhs: UPDATED_LABEL,\n          },\n        ]),\n      );\n\n      expect(evaluator.evalTree).toHaveProperty(\"Text1.text\", UPDATED_LABEL);\n    });\n  });\n\n  describe(\"evalMetaUpdates\", () => {\n    test(\"should add metaUpdates in the webworker's response\", () => {\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const updatedLabelUnevalTree = create(unE",
            "output_extracted": "import type { WidgetEntityConfig } from \"ee/entities/DataTree/types\";\nimport { DataTreeDiffEvent } from \"ee/workers/Evaluation/evaluationUtils\";\nimport { RenderModes } from \"constants/WidgetConstants\";\nimport { ENTITY_TYPE } from \"ee/entities/DataTree/types\";\nimport type { ConfigTree } from \"entities/DataTree/dataTreeTypes\";\nimport { generateDataTreeWidget } from \"entities/DataTree/dataTreeWidget\";\nimport { create } from \"mutative\";\nimport { klona } from \"klona/json\";\nimport type { WidgetEntity } from \"plugins/Linting/lib/entity/WidgetEntity\";\nimport type { UpdateDataTreeMessageData } from \"sagas/types\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport * as evalTreeWithChanges from \"./evalTreeWithChanges\";\nimport { APP_MODE } from \"entities/App\";\nimport { updateEvalProps } from \"./helpers\";\nexport const BASE_WIDGET = {\n  widgetId: \"randomID\",\n  widgetName: \"randomWidgetName\",\n  bottomRow: 0,\n  isLoading: false,\n  leftColumn: 0,\n  parentColumnSpace: 0,\n  parentRowSpace: 0,\n  renderMode: RenderModes.CANVAS,\n  rightColumn: 0,\n  topRow: 0,\n  type: \"SKELETON_WIDGET\",\n  parentId: \"0\",\n  version: 1,\n  ENTITY_TYPE: ENTITY_TYPE.WIDGET,\n  meta: {},\n} as unknown as WidgetEntity;\n\nexport const BASE_WIDGET_CONFIG = {\n  logBlackList: {},\n  widgetId: \"randomID\",\n  type: \"SKELETON_WIDGET\",\n  ENTITY_TYPE: ENTITY_TYPE.WIDGET,\n} as unknown as WidgetEntityConfig;\n\nconst WIDGET_CONFIG_MAP = {\n  TEXT_WIDGET: {\n    defaultProperties: {},\n    derivedProperties: {\n      value: \"{{ this.text }}\",\n    },\n    metaProperties: {},\n  },\n};\n\nconst configTree: ConfigTree = {\n  Text1: generateDataTreeWidget(\n    {\n      ...BASE_WIDGET_CONFIG,\n      ...BASE_WIDGET,\n      widgetName: \"Text1\",\n      text: \"Label\",\n      type: \"TEXT_WIDGET\",\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    {},\n    new Set(),\n  ).configEntity,\n  Text2: generateDataTreeWidget(\n    {\n      ...BASE_WIDGET_CONFIG,\n      ...BASE_WIDGET,\n      widgetName: \"Text2\",\n      text: \"{{Text1.text}}\",\n      dynamicBindingPathList: [{ key: \"text\" }],\n      type: \"TEXT_WIDGET\",\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    {},\n    new Set(),\n  ).configEntity,\n};\n\nconst unEvalTree = {\n  Text1: generateDataTreeWidget(\n    {\n      ...BASE_WIDGET_CONFIG,\n      ...BASE_WIDGET,\n      widgetName: \"Text1\",\n      text: \"Label\",\n      type: \"TEXT_WIDGET\",\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    {},\n    new Set(),\n  ).unEvalEntity,\n  Text2: generateDataTreeWidget(\n    {\n      ...BASE_WIDGET_CONFIG,\n      ...BASE_WIDGET,\n      widgetName: \"Text2\",\n      text: \"{{Text1.text}}\",\n      dynamicBindingPathList: [{ key: \"text\" }],\n      type: \"TEXT_WIDGET\",\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any,\n    {},\n    new Set(),\n  ).unEvalEntity,\n};\n\ndescribe(\"evaluateAndPushResponse\", () => {\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let pushResponseToMainThreadMock: any;\n\n  beforeAll(() => {\n    pushResponseToMainThreadMock = jest\n      .spyOn(evalTreeWithChanges, \"pushResponseToMainThread\")\n      .mockImplementation(() => {}); // spy on foo\n  });\n  beforeAll(() => {\n    jest.clearAllMocks();\n  });\n  test(\"should call pushResponseToMainThread when we evaluate and push updates\", () => {\n    evalTreeWithChanges.evaluateAndPushResponse(\n      undefined,\n      {\n        unEvalUpdates: [],\n        evalOrder: [],\n        jsUpdates: {},\n      },\n      [],\n      [],\n      {},\n    );\n    // check if push response has been called\n    expect(pushResponseToMainThreadMock).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"getAffectedNodesInTheDataTree\", () => {\n  test(\"should merge paths from unEvalUpdates and evalOrder\", () => {\n    const result = evalTreeWithChanges.getAffectedNodesInTheDataTree(\n      [\n        {\n          event: DataTreeDiffEvent.NOOP,\n          payload: {\n            propertyPath: \"Text2.text\",\n            value: \"\",\n          },\n          // TODO: Fix this the next time the file is edited\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } as any,\n      ],\n      [\"Text1.text\"],\n    );\n\n    expect(result).toEqual([\"Text2.text\", \"Text1.text\"]);\n  });\n  test(\"should extract unique paths from unEvalUpdates and evalOrder\", () => {\n    const result = evalTreeWithChanges.getAffectedNodesInTheDataTree(\n      [\n        {\n          event: DataTreeDiffEvent.NOOP,\n          payload: {\n            propertyPath: \"Text1.text\",\n            value: \"\",\n          },\n        },\n      ],\n      [\"Text1.text\"],\n    );\n\n    expect(result).toEqual([\"Text1.text\"]);\n  });\n});\n\ndescribe(\"evaluateAndGenerateResponse\", () => {\n  let evaluator: DataTreeEvaluator;\n  const UPDATED_LABEL = \"updated Label\";\n\n  const getParsedUpdatesFromWebWorkerResp = (\n    webworkerResponse: UpdateDataTreeMessageData,\n  ) => {\n    const updates = JSON.parse(webworkerResponse.workerResponse.updates);\n\n    //scrub out all __evaluation__ patches\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return updates.filter((p: any) => !p.rhs.__evaluation__);\n  };\n\n  beforeEach(async () => {\n    // we are mimicking the first tree evaluation flow here\n    evaluator = new DataTreeEvaluator(WIDGET_CONFIG_MAP);\n    await evaluator.setupFirstTree(\n      unEvalTree,\n      configTree,\n      {},\n      {\n        appId: \"appId\",\n        pageId: \"pageId\",\n        timestamp: \"timestamp\",\n        appMode: APP_MODE.PUBLISHED,\n        instanceId: \"instanceId\",\n        dslVersion: 1,\n      },\n    );\n    evaluator.evalAndValidateFirstTree();\n    const dataTree = updateEvalProps(evaluator) || {};\n\n    // over here we are setting the prevState through a klona but in the first tree we set by parsing the serialised update which is functionally the same\n    evaluator?.setPrevState(klona(dataTree));\n  });\n\n  test(\"inital evaluation successful should be successful\", () => {\n    expect(evaluator.evalTree).toHaveProperty(\"Text2.text\", \"Label\");\n  });\n\n  test(\"should respond with default values when dataTreeEvaluator is not provided\", () => {\n    const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n      undefined,\n      {\n        unEvalUpdates: [],\n        evalOrder: [],\n        jsUpdates: {},\n      },\n      [],\n      [],\n      {},\n    );\n    const parsedUpdates = getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n    expect(parsedUpdates).toEqual([]);\n    expect(webworkerResponse).toEqual({\n      workerResponse: {\n        dependencies: {},\n        errors: [],\n        evalMetaUpdates: [],\n        evaluationOrder: [],\n        executeReactiveActions: [],\n        isCreateFirstTree: false,\n        isNewWidgetAdded: false,\n        jsUpdates: {},\n        jsVarsCreatedEvent: [],\n        logs: [],\n        removedPaths: [],\n        staleMetaIds: [],\n        unEvalUpdates: [],\n        undefinedEvalValuesMap: {},\n        updates: \"[]\",\n      },\n    });\n  });\n  test(\"should generate no updates when the updateTreeResponse is empty\", () => {\n    const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n      evaluator,\n      {\n        unEvalUpdates: [],\n        evalOrder: [],\n        jsUpdates: {},\n      },\n      [],\n      [],\n      {},\n    );\n    const parsedUpdates = getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n    expect(parsedUpdates).toEqual([]);\n  });\n\n  describe(\"updates\", () => {\n    test(\"should generate updates based on the unEvalUpdates\", () => {\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const updatedLabelUnevalTree = create(unEvalTree, (draft: any) => {\n        draft.Text1.text = UPDATED_LABEL;\n        draft.Text1.label = UPDATED_LABEL;\n      });\n      const updateTreeResponse = evaluator.setupUpdateTree(\n        updatedLabelUnevalTree,\n        configTree,\n      );\n\n      // ignore label Text1.label uneval update and just include Text1.text uneval update\n      updateTreeResponse.unEvalUpdates = [\n        {\n          event: DataTreeDiffEvent.NOOP,\n          payload: {\n            propertyPath: \"Text1.text\",\n            value: \"\",\n          },\n        },\n        // TODO: Fix this the next time the file is edited\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ] as any;\n      // the eval tree should have the uneval update but the diff should not be generated because the unEvalUpdates has been altered\n      expect(evaluator.evalTree).toHaveProperty(\"Text1.text\", UPDATED_LABEL);\n\n      const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n        evaluator,\n        updateTreeResponse,\n        [],\n        [],\n        {},\n      );\n\n      expect(webworkerResponse.workerResponse.dependencies).toEqual({\n        \"Text1.text\": [\"Text2.text\", \"Text1\"],\n        \"Text2.text\": [\"Text2\"],\n      });\n      const parsedUpdates =\n        getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n      // Text1.label update should be ignored\n      expect(parsedUpdates).not.toEqual(\n        expect.arrayContaining([\n          {\n            kind: \"N\",\n            path: [\"Text1\", \"label\"],\n            rhs: UPDATED_LABEL,\n          },\n        ]),\n      );\n    });\n    test(\"should generate updates based on the evalOrder\", () => {\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const updatedLabelUnevalTree = create(unEvalTree, (draft: any) => {\n        draft.Text1.text = UPDATED_LABEL;\n      });\n      const updateTreeResponse = evaluator.setupUpdateTree(\n        updatedLabelUnevalTree,\n        configTree,\n      );\n\n      // ignore label Text1.label uneval update and just include Text1.text uneval update\n      // expect(updateTreeResponse.evalOrder).toEqual([]);\n      updateTreeResponse.evalOrder = [];\n\n      const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n        evaluator,\n        updateTreeResponse,\n        [],\n        [],\n        {},\n      );\n      const parsedUpdates =\n        getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n      // Text1.label update should be ignored\n      expect(parsedUpdates).not.toEqual(\n        expect.arrayContaining([\n          {\n            kind: \"N\",\n            path: [\"Text2\", \"text\"],\n            rhs: \"updated Label\",\n          },\n        ]),\n      );\n    });\n    test(\"should generate the correct updates to be sent to the main thread's state when the value tied to a binding changes \", () => {\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const updatedLabelUnevalTree = create(unEvalTree, (draft: any) => {\n        if (draft.Text1?.text) {\n          draft.Text1.text = UPDATED_LABEL;\n        }\n      });\n      const updateTreeResponse = evaluator.setupUpdateTree(\n        updatedLabelUnevalTree,\n        configTree,\n      );\n\n      const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n        evaluator,\n        updateTreeResponse,\n        [],\n        [],\n        {},\n      );\n\n      const parsedUpdates =\n        getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n      expect(parsedUpdates).toEqual(\n        expect.arrayContaining([\n          {\n            kind: \"E\",\n            path: [\"Text1\", \"text\"],\n            rhs: \"updated Label\",\n          },\n          {\n            kind: \"E\",\n            path: [\"Text2\", \"text\"],\n            rhs: \"updated Label\",\n          },\n        ]),\n      );\n\n      expect(evaluator.evalTree).toHaveProperty(\"Text2.text\", UPDATED_LABEL);\n    });\n    test(\"should merge additional updates to the dataTree as well as push the updates back to the main thread's state when unEvalUpdates is ignored\", () => {\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const updatedLabelUnevalTree = create(unEvalTree, (draft: any) => {\n        if (draft.Text1?.text) {\n          draft.Text1.text = UPDATED_LABEL;\n        }\n      });\n      const updateTreeResponse = evaluator.setupUpdateTree(\n        updatedLabelUnevalTree,\n        configTree,\n      );\n\n      //set the unEvalUpdates is empty so that evaluation ignores diffing the node\n      updateTreeResponse.unEvalUpdates = [];\n\n      const webworkerResponse = evalTreeWithChanges.evaluateAndGenerateResponse(\n        evaluator,\n        updateTreeResponse,\n        [],\n        [\"Text1.text\"],\n        {},\n      );\n      const parsedUpdates =\n        getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n\n      expect(parsedUpdates).toEqual(\n        expect.arrayContaining([\n          {\n            kind: \"N\",\n            path: [\"Text1\", \"text\"],\n            rhs: UPDATED_LABEL,\n          },\n        ]),\n      );\n\n      expect(evaluator.evalTree).toHaveProperty(\"Text1.text\", UPDATED_LABEL);\n    });\n  });\n\n  describe(\"evalMetaUpdates\", () => {\n    test(\"should add metaUpdates in the webworker's response\", () => {\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const updatedLabelUnevalTree = create(unE",
            "cost": 0.136855
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/workers/Evaluation/evalTreeWithChanges.ts": {
            "output": "import { dataTreeEvaluator } from \"./handlers/evalTree\";\nimport type { EvalMetaUpdates } from \"ee/workers/common/DataTreeEvaluator/types\";\nimport type {\n  EvalTreeResponseData,\n  EvalWorkerSyncRequest,\n  UpdateTreeResponse,\n} from \"./types\";\nimport { MessageType, sendMessage } from \"utils/MessageUtil\";\nimport { MAIN_THREAD_ACTION } from \"ee/workers/Evaluation/evalWorkerActions\";\nimport type { UpdateDataTreeMessageData } from \"sagas/types\";\nimport {\n  generateOptimisedUpdatesAndSetPrevState,\n  getNewDataTreeUpdates,\n  uniqueOrderUpdatePaths,\n  updateEvalProps,\n} from \"./helpers\";\nimport {\n  isDataPath,\n  type DataTreeDiff,\n} from \"ee/workers/Evaluation/evaluationUtils\";\nimport type DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport type { Diff } from \"deep-diff\";\nimport type { DataTree } from \"entities/DataTree/dataTreeTypes\";\nimport { klona as klonaJson } from \"klona/json\";\n\nconst getDefaultEvalResponse = (): EvalTreeResponseData => ({\n  updates: \"[]\",\n  dependencies: {},\n  errors: [],\n  evalMetaUpdates: [],\n  evaluationOrder: [],\n  jsUpdates: {},\n  logs: [],\n  unEvalUpdates: [],\n  isCreateFirstTree: false,\n  staleMetaIds: [],\n  removedPaths: [],\n  isNewWidgetAdded: false,\n  undefinedEvalValuesMap: {},\n  jsVarsCreatedEvent: [],\n  executeReactiveActions: [],\n});\n\nexport function evalTreeWithChanges(\n  request: EvalWorkerSyncRequest<{\n    metaUpdates?: EvalMetaUpdates;\n    updatedValuePaths: string[][];\n  }>,\n) {\n  const { data } = request;\n  const { metaUpdates = [], updatedValuePaths } = data;\n\n  const unEvalTree = dataTreeEvaluator?.getEvalTree();\n  const filteredUpdatedValuePaths = updatedValuePaths.filter((pathArr) => {\n    if (pathArr[pathArr.length - 1] !== \"data\") return true;\n\n    const fullPath = pathArr.join(\".\");\n\n    const entityName = pathArr[0];\n    const entity = unEvalTree?.[entityName];\n\n    if (entity && isDataPath(entity, fullPath)) {\n      return false; // filter out\n    }\n\n    return true; // keep for other entity types\n  });\n\n  const pathsToSkipFromEval = filteredUpdatedValuePaths.map((path) =>\n    path.join(\".\"),\n  );\n\n  let setupUpdateTreeResponse = {} as UpdateTreeResponse;\n  let oldEvalTree: DataTree = {};\n\n  if (dataTreeEvaluator) {\n    oldEvalTree = klonaJson(dataTreeEvaluator.getEvalTree());\n    setupUpdateTreeResponse = dataTreeEvaluator.setupUpdateTreeWithDifferences(\n      updatedValuePaths,\n      pathsToSkipFromEval,\n    );\n  }\n\n  evaluateAndPushResponse(\n    dataTreeEvaluator,\n    setupUpdateTreeResponse,\n    metaUpdates,\n    pathsToSkipFromEval,\n    oldEvalTree,\n  );\n}\n\nexport const getAffectedNodesInTheDataTree = (\n  unEvalUpdates: DataTreeDiff[],\n  evalOrder: string[],\n) => {\n  const allUnevalUpdates = unEvalUpdates.map(\n    (update) => update.payload.propertyPath,\n  );\n\n  // merge unevalUpdate paths and evalOrder paths\n  return uniqueOrderUpdatePaths([...allUnevalUpdates, ...evalOrder]);\n};\n\nexport const evaluateAndPushResponse = (\n  dataTreeEvaluator: DataTreeEvaluator | undefined,\n  setupUpdateTreeResponse: UpdateTreeResponse,\n  metaUpdates: EvalMetaUpdates,\n  additionalPathsAddedAsUpdates: string[],\n  oldEvalTree: DataTree,\n) => {\n  const response = evaluateAndGenerateResponse(\n    dataTreeEvaluator,\n    setupUpdateTreeResponse,\n    metaUpdates,\n    additionalPathsAddedAsUpdates,\n    oldEvalTree,\n  );\n\n  return pushResponseToMainThread(response);\n};\n\nexport const evaluateAndGenerateResponse = (\n  dataTreeEvaluator: DataTreeEvaluator | undefined,\n  setupUpdateTreeResponse: UpdateTreeResponse,\n  metaUpdates: EvalMetaUpdates,\n  additionalPathsAddedAsUpdates: string[],\n  oldEvalTree: DataTree,\n): UpdateDataTreeMessageData => {\n  // generate default response first and later add updates to it\n  const defaultResponse = getDefaultEvalResponse();\n\n  if (!dataTreeEvaluator) {\n    const updates = generateOptimisedUpdatesAndSetPrevState(\n      {},\n      dataTreeEvaluator,\n      [],\n      undefined,\n      false,\n    );\n\n    defaultResponse.updates = updates;\n    defaultResponse.evalMetaUpdates = [...(metaUpdates || [])];\n\n    return {\n      workerResponse: defaultResponse,\n    };\n  }\n\n  const { evalOrder, jsUpdates, unEvalUpdates } = setupUpdateTreeResponse;\n\n  defaultResponse.evaluationOrder = evalOrder;\n  defaultResponse.unEvalUpdates = unEvalUpdates;\n  defaultResponse.jsUpdates = jsUpdates;\n\n  const updateResponse = dataTreeEvaluator.evalAndValidateSubTree(\n    evalOrder,\n    dataTreeEvaluator.oldConfigTree,\n    unEvalUpdates,\n    [],\n    oldEvalTree,\n  );\n\n  const dataTree = updateEvalProps(dataTreeEvaluator) || {};\n\n  /** Make sure evalMetaUpdates is sanitized to prevent postMessage failure */\n  defaultResponse.evalMetaUpdates = JSON.parse(\n    JSON.stringify([...(metaUpdates || []), ...updateResponse.evalMetaUpdates]),\n  );\n\n  defaultResponse.staleMetaIds = updateResponse.staleMetaIds;\n  defaultResponse.dependencies = dataTreeEvaluator.inverseDependencies;\n  defaultResponse.executeReactiveActions =\n    updateResponse.executeReactiveActions;\n\n  // when additional paths are required to be added as updates, we extract the updates from the data tree using these paths.\n  const additionalUpdates = getNewDataTreeUpdates(\n    additionalPathsAddedAsUpdates,\n    dataTree,\n  ) as Diff<DataTree, DataTree>[];\n\n  // the affected paths is a combination of the eval order and the uneval updates\n  // we use this collection to limit the diff between the old and new data tree\n  const affectedNodePaths = getAffectedNodesInTheDataTree(\n    unEvalUpdates,\n    evalOrder,\n  );\n\n  const updates = generateOptimisedUpdatesAndSetPrevState(\n    dataTree,\n    dataTreeEvaluator,\n    affectedNodePaths,\n    additionalUpdates,\n    true,\n  );\n\n  defaultResponse.updates = updates;\n  dataTreeEvaluator.undefinedEvalValuesMap =\n    dataTreeEvaluator.undefinedEvalValuesMap || {};\n\n  return {\n    workerResponse: defaultResponse,\n  };\n};\n\nexport const pushResponseToMainThread = (data: UpdateDataTreeMessageData) => {\n  sendMessage.call(self, {\n    messageType: MessageType.DEFAULT,\n    body: {\n      data,\n      method: MAIN_THREAD_ACTION.UPDATE_DATATREE,\n    },\n  });\n};",
            "output_extracted": "import { dataTreeEvaluator } from \"./handlers/evalTree\";\nimport type { EvalMetaUpdates } from \"ee/workers/common/DataTreeEvaluator/types\";\nimport type {\n  EvalTreeResponseData,\n  EvalWorkerSyncRequest,\n  UpdateTreeResponse,\n} from \"./types\";\nimport { MessageType, sendMessage } from \"utils/MessageUtil\";\nimport { MAIN_THREAD_ACTION } from \"ee/workers/Evaluation/evalWorkerActions\";\nimport type { UpdateDataTreeMessageData } from \"sagas/types\";\nimport {\n  generateOptimisedUpdatesAndSetPrevState,\n  getNewDataTreeUpdates,\n  uniqueOrderUpdatePaths,\n  updateEvalProps,\n} from \"./helpers\";\nimport {\n  isDataPath,\n  type DataTreeDiff,\n} from \"ee/workers/Evaluation/evaluationUtils\";\nimport type DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport type { Diff } from \"deep-diff\";\nimport type { DataTree } from \"entities/DataTree/dataTreeTypes\";\nimport { klona as klonaJson } from \"klona/json\";\n\nconst getDefaultEvalResponse = (): EvalTreeResponseData => ({\n  updates: \"[]\",\n  dependencies: {},\n  errors: [],\n  evalMetaUpdates: [],\n  evaluationOrder: [],\n  jsUpdates: {},\n  logs: [],\n  unEvalUpdates: [],\n  isCreateFirstTree: false,\n  staleMetaIds: [],\n  removedPaths: [],\n  isNewWidgetAdded: false,\n  undefinedEvalValuesMap: {},\n  jsVarsCreatedEvent: [],\n  executeReactiveActions: [],\n});\n\nexport function evalTreeWithChanges(\n  request: EvalWorkerSyncRequest<{\n    metaUpdates?: EvalMetaUpdates;\n    updatedValuePaths: string[][];\n  }>,\n) {\n  const { data } = request;\n  const { metaUpdates = [], updatedValuePaths } = data;\n\n  const unEvalTree = dataTreeEvaluator?.getEvalTree();\n  const filteredUpdatedValuePaths = updatedValuePaths.filter((pathArr) => {\n    if (pathArr[pathArr.length - 1] !== \"data\") return true;\n\n    const fullPath = pathArr.join(\".\");\n\n    const entityName = pathArr[0];\n    const entity = unEvalTree?.[entityName];\n\n    if (entity && isDataPath(entity, fullPath)) {\n      return false; // filter out\n    }\n\n    return true; // keep for other entity types\n  });\n\n  const pathsToSkipFromEval = filteredUpdatedValuePaths.map((path) =>\n    path.join(\".\"),\n  );\n\n  let setupUpdateTreeResponse = {} as UpdateTreeResponse;\n  let oldEvalTree: DataTree = {};\n\n  if (dataTreeEvaluator) {\n    oldEvalTree = klonaJson(dataTreeEvaluator.getEvalTree());\n    setupUpdateTreeResponse = dataTreeEvaluator.setupUpdateTreeWithDifferences(\n      updatedValuePaths,\n      pathsToSkipFromEval,\n    );\n  }\n\n  evaluateAndPushResponse(\n    dataTreeEvaluator,\n    setupUpdateTreeResponse,\n    metaUpdates,\n    pathsToSkipFromEval,\n    oldEvalTree,\n  );\n}\n\nexport const getAffectedNodesInTheDataTree = (\n  unEvalUpdates: DataTreeDiff[],\n  evalOrder: string[],\n) => {\n  const allUnevalUpdates = unEvalUpdates.map(\n    (update) => update.payload.propertyPath,\n  );\n\n  // merge unevalUpdate paths and evalOrder paths\n  return uniqueOrderUpdatePaths([...allUnevalUpdates, ...evalOrder]);\n};\n\nexport const evaluateAndPushResponse = (\n  dataTreeEvaluator: DataTreeEvaluator | undefined,\n  setupUpdateTreeResponse: UpdateTreeResponse,\n  metaUpdates: EvalMetaUpdates,\n  additionalPathsAddedAsUpdates: string[],\n  oldEvalTree: DataTree,\n) => {\n  const response = evaluateAndGenerateResponse(\n    dataTreeEvaluator,\n    setupUpdateTreeResponse,\n    metaUpdates,\n    additionalPathsAddedAsUpdates,\n    oldEvalTree,\n  );\n\n  return pushResponseToMainThread(response);\n};\n\nexport const evaluateAndGenerateResponse = (\n  dataTreeEvaluator: DataTreeEvaluator | undefined,\n  setupUpdateTreeResponse: UpdateTreeResponse,\n  metaUpdates: EvalMetaUpdates,\n  additionalPathsAddedAsUpdates: string[],\n  oldEvalTree: DataTree,\n): UpdateDataTreeMessageData => {\n  // generate default response first and later add updates to it\n  const defaultResponse = getDefaultEvalResponse();\n\n  if (!dataTreeEvaluator) {\n    const updates = generateOptimisedUpdatesAndSetPrevState(\n      {},\n      dataTreeEvaluator,\n      [],\n      undefined,\n      false,\n    );\n\n    defaultResponse.updates = updates;\n    defaultResponse.evalMetaUpdates = [...(metaUpdates || [])];\n\n    return {\n      workerResponse: defaultResponse,\n    };\n  }\n\n  const { evalOrder, jsUpdates, unEvalUpdates } = setupUpdateTreeResponse;\n\n  defaultResponse.evaluationOrder = evalOrder;\n  defaultResponse.unEvalUpdates = unEvalUpdates;\n  defaultResponse.jsUpdates = jsUpdates;\n\n  const updateResponse = dataTreeEvaluator.evalAndValidateSubTree(\n    evalOrder,\n    dataTreeEvaluator.oldConfigTree,\n    unEvalUpdates,\n    [],\n    oldEvalTree,\n  );\n\n  const dataTree = updateEvalProps(dataTreeEvaluator) || {};\n\n  /** Make sure evalMetaUpdates is sanitized to prevent postMessage failure */\n  defaultResponse.evalMetaUpdates = JSON.parse(\n    JSON.stringify([...(metaUpdates || []), ...updateResponse.evalMetaUpdates]),\n  );\n\n  defaultResponse.staleMetaIds = updateResponse.staleMetaIds;\n  defaultResponse.dependencies = dataTreeEvaluator.inverseDependencies;\n  defaultResponse.executeReactiveActions =\n    updateResponse.executeReactiveActions;\n\n  // when additional paths are required to be added as updates, we extract the updates from the data tree using these paths.\n  const additionalUpdates = getNewDataTreeUpdates(\n    additionalPathsAddedAsUpdates,\n    dataTree,\n  ) as Diff<DataTree, DataTree>[];\n\n  // the affected paths is a combination of the eval order and the uneval updates\n  // we use this collection to limit the diff between the old and new data tree\n  const affectedNodePaths = getAffectedNodesInTheDataTree(\n    unEvalUpdates,\n    evalOrder,\n  );\n\n  const updates = generateOptimisedUpdatesAndSetPrevState(\n    dataTree,\n    dataTreeEvaluator,\n    affectedNodePaths,\n    additionalUpdates,\n    true,\n  );\n\n  defaultResponse.updates = updates;\n  dataTreeEvaluator.undefinedEvalValuesMap =\n    dataTreeEvaluator.undefinedEvalValuesMap || {};\n\n  return {\n    workerResponse: defaultResponse,\n  };\n};\n\nexport const pushResponseToMainThread = (data: UpdateDataTreeMessageData) => {\n  sendMessage.call(self, {\n    messageType: MessageType.DEFAULT,\n    body: {\n      data,\n      method: MAIN_THREAD_ACTION.UPDATE_DATATREE,\n    },\n  });\n};",
            "cost": 0.06532
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/workers/Evaluation/handlers/evalTree.ts": {
            "output": "import type { ConfigTree, DataTree } from \"entities/DataTree/dataTreeTypes\";\nimport type ReplayEntity from \"entities/Replay\";\nimport ReplayCanvas from \"entities/Replay/ReplayEntity/ReplayCanvas\";\nimport { isEmpty } from \"lodash\";\nimport type { DependencyMap, EvalError } from \"utils/DynamicBindingUtils\";\nimport { EvalErrorTypes } from \"utils/DynamicBindingUtils\";\nimport type { JSUpdate } from \"utils/JSPaneUtils\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport type { EvalMetaUpdates } from \"ee/workers/common/DataTreeEvaluator/types\";\nimport { makeEntityConfigsAsObjProperties } from \"ee/workers/Evaluation/dataTreeUtils\";\nimport type { DataTreeDiff } from \"ee/workers/Evaluation/evaluationUtils\";\nimport { serialiseToBigInt } from \"ee/workers/Evaluation/evaluationUtils\";\nimport { getSafeToRenderDataTree } from \"ee/workers/Evaluation/evaluationUtils\";\nimport type { EvalTreeRequestData, EvalWorkerASyncRequest } from \"../types\";\nimport { clearAllIntervals } from \"../fns/overrides/interval\";\nimport JSObjectCollection from \"workers/Evaluation/JSObject/Collection\";\nimport { getJSVariableCreatedEvents } from \"../JSObject/JSVariableEvents\";\nimport { errorModifier } from \"../errorModifier\";\nimport {\n  generateOptimisedUpdatesAndSetPrevState,\n  uniqueOrderUpdatePaths,\n  updateEvalProps,\n} from \"../helpers\";\nimport DataStore from \"../dataStore\";\nimport type { TransmissionErrorHandler } from \"../fns/utils/Messenger\";\nimport { MessageType, sendMessage } from \"utils/MessageUtil\";\nimport {\n  profileFn,\n  newWebWorkerSpanData,\n  profileAsyncFn,\n} from \"instrumentation/generateWebWorkerTraces\";\nimport type { CanvasWidgetsReduxState } from \"ee/reducers/entityReducers/canvasWidgetsReducer\";\nimport type { MetaWidgetsReduxState } from \"reducers/entityReducers/metaWidgetsReducer\";\nimport type { Attributes } from \"instrumentation/types\";\nimport { updateActionsToEvalTree } from \"./updateActionData\";\nimport { klona as klonaJSON } from \"klona/json\";\n\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport let replayMap: Record<string, ReplayEntity<any>> | undefined;\nexport let dataTreeEvaluator: DataTreeEvaluator | undefined;\nexport const CANVAS = \"canvas\";\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport let canvasWidgetsMeta: Record<string, any>;\nexport let metaWidgetsCache: MetaWidgetsReduxState;\nexport let canvasWidgets: CanvasWidgetsReduxState;\n\nexport async function evalTree(\n  request: EvalWorkerASyncRequest<EvalTreeRequestData>,\n) {\n  const { data, webworkerTelemetry } = request;\n\n  webworkerTelemetry[\"transferDataToWorkerThread\"].endTime = Date.now();\n\n  let evalOrder: string[] = [];\n  let jsUpdates: Record<string, JSUpdate> = {};\n  let unEvalUpdates: DataTreeDiff[] = [];\n  let isCreateFirstTree = false;\n  let dataTree: DataTree = {};\n  let errors: EvalError[] = [];\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let logs: any[] = [];\n  let dependencies: DependencyMap = {};\n  let evalMetaUpdates: EvalMetaUpdates = [];\n  let configTree: ConfigTree = {};\n  let staleMetaIds: string[] = [];\n  let removedPaths: Array<{ entityId: string; fullpath: string }> = [];\n  let isNewWidgetAdded = false;\n  let executeReactiveActions: string[] = [];\n\n  const {\n    actionDataPayloadConsolidated,\n    affectedJSObjects,\n    allActionValidationConfig,\n    appMode,\n    cacheProps,\n    forceEvaluation,\n    metaWidgets,\n    shouldReplay,\n    shouldRespondWithLogs,\n    theme,\n    unevalTree: __unevalTree__,\n    widgets,\n    widgetsMeta,\n    widgetTypeConfigMap,\n  } = data;\n\n  const unevalTree = __unevalTree__.unEvalTree;\n\n  configTree = __unevalTree__.configTree as ConfigTree;\n  canvasWidgets = widgets;\n  canvasWidgetsMeta = widgetsMeta;\n  metaWidgetsCache = metaWidgets;\n  let isNewTree = false;\n\n  try {\n    (webworkerTelemetry.__spanAttributes as Attributes)[\"firstEvaluation\"] =\n      !dataTreeEvaluator;\n\n    if (!dataTreeEvaluator) {\n      isCreateFirstTree = true;\n      replayMap = replayMap || {};\n      replayMap[CANVAS] = new ReplayCanvas({ widgets, theme });\n      errorModifier.init(appMode);\n      dataTreeEvaluator = new DataTreeEvaluator(\n        widgetTypeConfigMap,\n        allActionValidationConfig,\n      );\n\n      const setupFirstTreeResponse = await profileAsyncFn(\n        \"setupFirstTree\",\n        (dataTreeEvaluator as DataTreeEvaluator).setupFirstTree.bind(\n          dataTreeEvaluator,\n          unevalTree,\n          configTree,\n          webworkerTelemetry,\n          cacheProps,\n        ),\n        webworkerTelemetry,\n        { description: \"during initialisation\" },\n      );\n\n      evalOrder = setupFirstTreeResponse.evalOrder;\n      jsUpdates = setupFirstTreeResponse.jsUpdates;\n\n      const dataTreeResponse = profileFn(\n        \"evalAndValidateFirstTree\",\n        { description: \"during initialisation\" },\n        webworkerTelemetry,\n        (dataTreeEvaluator as DataTreeEvaluator).evalAndValidateFirstTree.bind(\n          dataTreeEvaluator,\n        ),\n      );\n\n      dataTree = updateEvalProps(dataTreeEvaluator) || {};\n\n      staleMetaIds = dataTreeResponse.staleMetaIds;\n      executeReactiveActions = dataTreeResponse.executeReactiveActions;\n      isNewTree = true;\n    } else if (dataTreeEvaluator.hasCyclicalDependency || forceEvaluation) {\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        //allActionValidationConfigs may not be set in dataTreeEvaluator. Therefore, set it explicitly via setter method\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n\n      if (shouldReplay && replayMap) {\n        replayMap[CANVAS]?.update({ widgets, theme });\n      }\n\n      dataTreeEvaluator = new DataTreeEvaluator(\n        widgetTypeConfigMap,\n        allActionValidationConfig,\n      );\n\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n\n      const setupFirstTreeResponse = await profileAsyncFn(\n        \"setupFirstTree\",\n        (dataTreeEvaluator as DataTreeEvaluator).setupFirstTree.bind(\n          dataTreeEvaluator,\n          unevalTree,\n          configTree,\n          webworkerTelemetry,\n          cacheProps,\n        ),\n        webworkerTelemetry,\n        { description: \"non-initialisation\" },\n      );\n\n      isCreateFirstTree = true;\n      evalOrder = setupFirstTreeResponse.evalOrder;\n      jsUpdates = setupFirstTreeResponse.jsUpdates;\n\n      const dataTreeResponse = profileFn(\n        \"evalAndValidateFirstTree\",\n        { description: \"non-initialisation\" },\n        webworkerTelemetry,\n        () =>\n          (dataTreeEvaluator as DataTreeEvaluator).evalAndValidateFirstTree(),\n      );\n\n      dataTree = updateEvalProps(dataTreeEvaluator) || {};\n\n      staleMetaIds = dataTreeResponse.staleMetaIds;\n      executeReactiveActions = dataTreeResponse.executeReactiveActions;\n      isNewTree = true;\n    } else {\n      const tree = dataTreeEvaluator.getEvalTree();\n      const oldDataTree = klonaJSON(tree);\n\n      // during update cycles update actions to the dataTree directly\n      // this is useful in cases where we have debounced updateActionData and a regular evaluation\n      // triggered together, in those cases we merge them both into a regular evaluation\n      updateActionsToEvalTree(tree, actionDataPayloadConsolidated);\n\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n\n      isCreateFirstTree = false;\n\n      if (shouldReplay && replayMap) {\n        replayMap[CANVAS]?.update({ widgets, theme });\n      }\n\n      const setupUpdateTreeResponse = profileFn(\n        \"setupUpdateTree\",\n        undefined,\n        webworkerTelemetry,\n        () =>\n          (dataTreeEvaluator as DataTreeEvaluator).setupUpdateTree(\n            unevalTree,\n            configTree,\n            webworkerTelemetry,\n            affectedJSObjects,\n            actionDataPayloadConsolidated,\n          ),\n      );\n\n      evalOrder = setupUpdateTreeResponse.evalOrder;\n      jsUpdates = setupUpdateTreeResponse.jsUpdates;\n      unEvalUpdates = setupUpdateTreeResponse.unEvalUpdates;\n      removedPaths = setupUpdateTreeResponse.removedPaths;\n      isNewWidgetAdded = setupUpdateTreeResponse.isNewWidgetAdded;\n\n      const updateResponse = profileFn(\n        \"evalAndValidateSubTree\",\n        undefined,\n        webworkerTelemetry,\n        () =>\n          (dataTreeEvaluator as DataTreeEvaluator).evalAndValidateSubTree(\n            evalOrder,\n            configTree,\n            unEvalUpdates,\n            Object.keys(metaWidgets),\n            oldDataTree,\n          ),\n      );\n\n      dataTree = updateEvalProps(dataTreeEvaluator) || {};\n\n      evalMetaUpdates = JSON.parse(\n        JSON.stringify(updateResponse.evalMetaUpdates),\n      );\n      staleMetaIds = updateResponse.staleMetaIds;\n      executeReactiveActions = updateResponse.executeReactiveActions;\n      isNewTree = false;\n    }\n\n    dependencies = dataTreeEvaluator.inverseDependencies;\n    errors = dataTreeEvaluator.errors;\n    dataTreeEvaluator.clearErrors();\n    logs = dataTreeEvaluator.logs;\n\n    if (shouldReplay && replayMap) {\n      if (replayMap[CANVAS]?.logs) logs = logs.concat(replayMap[CANVAS]?.logs);\n\n      replayMap[CANVAS]?.clearLogs();\n    }\n\n    dataTreeEvaluator.clearLogs();\n  } catch (error) {\n    if (dataTreeEvaluator !== undefined) {\n      errors = dataTreeEvaluator.errors;\n      logs = dataTreeEvaluator.logs;\n    }\n\n    errors.push({\n      type: EvalErrorTypes.EVAL_TREE_ERROR,\n      message: (error as Error).message,\n      stack: (error as Error).stack,\n    });\n\n    // eslint-disable-next-line\n    console.error(error);\n\n    dataTree = getSafeToRenderDataTree(\n      makeEntityConfigsAsObjProperties(unevalTree, {\n        sanitizeDataTree: false,\n        evalProps: dataTreeEvaluator?.evalProps,\n      }),\n      widgetTypeConfigMap,\n      configTree,\n    );\n    unEvalUpdates = [];\n    isNewTree = true;\n  }\n\n  const jsVarsCreatedEvent = getJSVariableCreatedEvents(jsUpdates);\n\n  const updates = profileFn(\n    \"diffAndGenerateSerializeUpdates\",\n    undefined,\n    webworkerTelemetry,\n    () => {\n      let updates;\n\n      if (isNewTree) {\n        try {\n          //for new tree send the whole thing, don't diff at all\n          updates = serialiseToBigInt([{ kind: \"newTree\", rhs: dataTree }]);\n          const parsedUpdates = JSON.parse(updates);\n\n          dataTreeEvaluator?.setPrevState(parsedUpdates[0].rhs);\n        } catch (e) {\n          updates = \"[]\";\n\n          errors.push({\n            type: EvalErrorTypes.EVAL_TREE_ERROR,\n            message: (e as Error).message,\n            stack: (e as Error).stack,\n          });\n        }\n        isNewTree = false;\n      } else {\n        const allUnevalUpdates = unEvalUpdates.map(\n          (update) => update.payload.propertyPath,\n        );\n\n        const completeEvalOrder = uniqueOrderUpdatePaths([\n          ...allUnevalUpdates,\n          ...evalOrder,\n        ]);\n\n        updates = generateOptimisedUpdatesAndSetPrevState(\n          dataTree,\n          dataTreeEvaluator,\n          completeEvalOrder,\n          undefined,\n          true,\n        );\n      }\n\n      return updates;\n    },\n  );\n\n  const evalTreeResponse = {\n    updates,\n    dependencies,\n    errors,\n    evalMetaUpdates,\n    evaluationOrder: evalOrder,\n    jsUpdates,\n    webworkerTelemetry,\n    // be weary of the payload size of logs it can be huge and contribute to transmission overhead\n    // we are only sending logs in local debug mode\n    logs: shouldRespondWithLogs ? logs : [],\n    unEvalUpdates,\n    isCreateFirstTree,\n    staleMetaIds,\n    removedPaths,\n    isNewWidgetAdded,\n    undefinedEvalValuesMap: dataTreeEvaluator?.undefinedEvalValuesMap || {},\n    jsVarsCreatedEvent,\n    executeReactiveActions,\n  };\n\n  webworkerTelemetry[\"transferDataToMainThread\"] = newWebWorkerSpanData(\n    \"transferDataToMainThread\",\n    {},\n  );\n\n  return evalTreeResponse;\n}\n\nexport const evalTreeTransmissionErrorHandler: TransmissionErrorHandler = (\n  messageId: string,\n  startTime: number,\n  endTime: number,\n  responseData: unknown,\n) => {\n  const sanitizedData = JSON.parse(JSON.stringify(responseData));\n\n  sendMessage.call(self, {\n    messageId,\n    messageType: MessageType.RESPONSE,\n    body: { data: sanitizedData, startTime, endTime },\n  });\n};\n\nexport function clearCache() {\n  dataTreeEvaluator = undefined;\n  clearAllIntervals();\n  JSObjectCollection.clear();\n  DataStore.clear();\n\n  return true;\n}",
            "output_extracted": "import type { ConfigTree, DataTree } from \"entities/DataTree/dataTreeTypes\";\nimport type ReplayEntity from \"entities/Replay\";\nimport ReplayCanvas from \"entities/Replay/ReplayEntity/ReplayCanvas\";\nimport { isEmpty } from \"lodash\";\nimport type { DependencyMap, EvalError } from \"utils/DynamicBindingUtils\";\nimport { EvalErrorTypes } from \"utils/DynamicBindingUtils\";\nimport type { JSUpdate } from \"utils/JSPaneUtils\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport type { EvalMetaUpdates } from \"ee/workers/common/DataTreeEvaluator/types\";\nimport { makeEntityConfigsAsObjProperties } from \"ee/workers/Evaluation/dataTreeUtils\";\nimport type { DataTreeDiff } from \"ee/workers/Evaluation/evaluationUtils\";\nimport { serialiseToBigInt } from \"ee/workers/Evaluation/evaluationUtils\";\nimport { getSafeToRenderDataTree } from \"ee/workers/Evaluation/evaluationUtils\";\nimport type { EvalTreeRequestData, EvalWorkerASyncRequest } from \"../types\";\nimport { clearAllIntervals } from \"../fns/overrides/interval\";\nimport JSObjectCollection from \"workers/Evaluation/JSObject/Collection\";\nimport { getJSVariableCreatedEvents } from \"../JSObject/JSVariableEvents\";\nimport { errorModifier } from \"../errorModifier\";\nimport {\n  generateOptimisedUpdatesAndSetPrevState,\n  uniqueOrderUpdatePaths,\n  updateEvalProps,\n} from \"../helpers\";\nimport DataStore from \"../dataStore\";\nimport type { TransmissionErrorHandler } from \"../fns/utils/Messenger\";\nimport { MessageType, sendMessage } from \"utils/MessageUtil\";\nimport {\n  profileFn,\n  newWebWorkerSpanData,\n  profileAsyncFn,\n} from \"instrumentation/generateWebWorkerTraces\";\nimport type { CanvasWidgetsReduxState } from \"ee/reducers/entityReducers/canvasWidgetsReducer\";\nimport type { MetaWidgetsReduxState } from \"reducers/entityReducers/metaWidgetsReducer\";\nimport type { Attributes } from \"instrumentation/types\";\nimport { updateActionsToEvalTree } from \"./updateActionData\";\nimport { klona as klonaJSON } from \"klona/json\";\n\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport let replayMap: Record<string, ReplayEntity<any>> | undefined;\nexport let dataTreeEvaluator: DataTreeEvaluator | undefined;\nexport const CANVAS = \"canvas\";\n// TODO: Fix this the next time the file is edited\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport let canvasWidgetsMeta: Record<string, any>;\nexport let metaWidgetsCache: MetaWidgetsReduxState;\nexport let canvasWidgets: CanvasWidgetsReduxState;\n\nexport async function evalTree(\n  request: EvalWorkerASyncRequest<EvalTreeRequestData>,\n) {\n  const { data, webworkerTelemetry } = request;\n\n  webworkerTelemetry[\"transferDataToWorkerThread\"].endTime = Date.now();\n\n  let evalOrder: string[] = [];\n  let jsUpdates: Record<string, JSUpdate> = {};\n  let unEvalUpdates: DataTreeDiff[] = [];\n  let isCreateFirstTree = false;\n  let dataTree: DataTree = {};\n  let errors: EvalError[] = [];\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let logs: any[] = [];\n  let dependencies: DependencyMap = {};\n  let evalMetaUpdates: EvalMetaUpdates = [];\n  let configTree: ConfigTree = {};\n  let staleMetaIds: string[] = [];\n  let removedPaths: Array<{ entityId: string; fullpath: string }> = [];\n  let isNewWidgetAdded = false;\n  let executeReactiveActions: string[] = [];\n\n  const {\n    actionDataPayloadConsolidated,\n    affectedJSObjects,\n    allActionValidationConfig,\n    appMode,\n    cacheProps,\n    forceEvaluation,\n    metaWidgets,\n    shouldReplay,\n    shouldRespondWithLogs,\n    theme,\n    unevalTree: __unevalTree__,\n    widgets,\n    widgetsMeta,\n    widgetTypeConfigMap,\n  } = data;\n\n  const unevalTree = __unevalTree__.unEvalTree;\n\n  configTree = __unevalTree__.configTree as ConfigTree;\n  canvasWidgets = widgets;\n  canvasWidgetsMeta = widgetsMeta;\n  metaWidgetsCache = metaWidgets;\n  let isNewTree = false;\n\n  try {\n    (webworkerTelemetry.__spanAttributes as Attributes)[\"firstEvaluation\"] =\n      !dataTreeEvaluator;\n\n    if (!dataTreeEvaluator) {\n      isCreateFirstTree = true;\n      replayMap = replayMap || {};\n      replayMap[CANVAS] = new ReplayCanvas({ widgets, theme });\n      errorModifier.init(appMode);\n      dataTreeEvaluator = new DataTreeEvaluator(\n        widgetTypeConfigMap,\n        allActionValidationConfig,\n      );\n\n      const setupFirstTreeResponse = await profileAsyncFn(\n        \"setupFirstTree\",\n        (dataTreeEvaluator as DataTreeEvaluator).setupFirstTree.bind(\n          dataTreeEvaluator,\n          unevalTree,\n          configTree,\n          webworkerTelemetry,\n          cacheProps,\n        ),\n        webworkerTelemetry,\n        { description: \"during initialisation\" },\n      );\n\n      evalOrder = setupFirstTreeResponse.evalOrder;\n      jsUpdates = setupFirstTreeResponse.jsUpdates;\n\n      const dataTreeResponse = profileFn(\n        \"evalAndValidateFirstTree\",\n        { description: \"during initialisation\" },\n        webworkerTelemetry,\n        (dataTreeEvaluator as DataTreeEvaluator).evalAndValidateFirstTree.bind(\n          dataTreeEvaluator,\n        ),\n      );\n\n      dataTree = updateEvalProps(dataTreeEvaluator) || {};\n\n      staleMetaIds = dataTreeResponse.staleMetaIds;\n      executeReactiveActions = dataTreeResponse.executeReactiveActions;\n      isNewTree = true;\n    } else if (dataTreeEvaluator.hasCyclicalDependency || forceEvaluation) {\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        //allActionValidationConfigs may not be set in dataTreeEvaluator. Therefore, set it explicitly via setter method\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n\n      if (shouldReplay && replayMap) {\n        replayMap[CANVAS]?.update({ widgets, theme });\n      }\n\n      dataTreeEvaluator = new DataTreeEvaluator(\n        widgetTypeConfigMap,\n        allActionValidationConfig,\n      );\n\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n\n      const setupFirstTreeResponse = await profileAsyncFn(\n        \"setupFirstTree\",\n        (dataTreeEvaluator as DataTreeEvaluator).setupFirstTree.bind(\n          dataTreeEvaluator,\n          unevalTree,\n          configTree,\n          webworkerTelemetry,\n          cacheProps,\n        ),\n        webworkerTelemetry,\n        { description: \"non-initialisation\" },\n      );\n\n      isCreateFirstTree = true;\n      evalOrder = setupFirstTreeResponse.evalOrder;\n      jsUpdates = setupFirstTreeResponse.jsUpdates;\n\n      const dataTreeResponse = profileFn(\n        \"evalAndValidateFirstTree\",\n        { description: \"non-initialisation\" },\n        webworkerTelemetry,\n        () =>\n          (dataTreeEvaluator as DataTreeEvaluator).evalAndValidateFirstTree(),\n      );\n\n      dataTree = updateEvalProps(dataTreeEvaluator) || {};\n\n      staleMetaIds = dataTreeResponse.staleMetaIds;\n      executeReactiveActions = dataTreeResponse.executeReactiveActions;\n      isNewTree = true;\n    } else {\n      const tree = dataTreeEvaluator.getEvalTree();\n      const oldDataTree = klonaJSON(tree);\n\n      // during update cycles update actions to the dataTree directly\n      // this is useful in cases where we have debounced updateActionData and a regular evaluation\n      // triggered together, in those cases we merge them both into a regular evaluation\n      updateActionsToEvalTree(tree, actionDataPayloadConsolidated);\n\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n\n      isCreateFirstTree = false;\n\n      if (shouldReplay && replayMap) {\n        replayMap[CANVAS]?.update({ widgets, theme });\n      }\n\n      const setupUpdateTreeResponse = profileFn(\n        \"setupUpdateTree\",\n        undefined,\n        webworkerTelemetry,\n        () =>\n          (dataTreeEvaluator as DataTreeEvaluator).setupUpdateTree(\n            unevalTree,\n            configTree,\n            webworkerTelemetry,\n            affectedJSObjects,\n            actionDataPayloadConsolidated,\n          ),\n      );\n\n      evalOrder = setupUpdateTreeResponse.evalOrder;\n      jsUpdates = setupUpdateTreeResponse.jsUpdates;\n      unEvalUpdates = setupUpdateTreeResponse.unEvalUpdates;\n      removedPaths = setupUpdateTreeResponse.removedPaths;\n      isNewWidgetAdded = setupUpdateTreeResponse.isNewWidgetAdded;\n\n      const updateResponse = profileFn(\n        \"evalAndValidateSubTree\",\n        undefined,\n        webworkerTelemetry,\n        () =>\n          (dataTreeEvaluator as DataTreeEvaluator).evalAndValidateSubTree(\n            evalOrder,\n            configTree,\n            unEvalUpdates,\n            Object.keys(metaWidgets),\n            oldDataTree,\n          ),\n      );\n\n      dataTree = updateEvalProps(dataTreeEvaluator) || {};\n\n      evalMetaUpdates = JSON.parse(\n        JSON.stringify(updateResponse.evalMetaUpdates),\n      );\n      staleMetaIds = updateResponse.staleMetaIds;\n      executeReactiveActions = updateResponse.executeReactiveActions;\n      isNewTree = false;\n    }\n\n    dependencies = dataTreeEvaluator.inverseDependencies;\n    errors = dataTreeEvaluator.errors;\n    dataTreeEvaluator.clearErrors();\n    logs = dataTreeEvaluator.logs;\n\n    if (shouldReplay && replayMap) {\n      if (replayMap[CANVAS]?.logs) logs = logs.concat(replayMap[CANVAS]?.logs);\n\n      replayMap[CANVAS]?.clearLogs();\n    }\n\n    dataTreeEvaluator.clearLogs();\n  } catch (error) {\n    if (dataTreeEvaluator !== undefined) {\n      errors = dataTreeEvaluator.errors;\n      logs = dataTreeEvaluator.logs;\n    }\n\n    errors.push({\n      type: EvalErrorTypes.EVAL_TREE_ERROR,\n      message: (error as Error).message,\n      stack: (error as Error).stack,\n    });\n\n    // eslint-disable-next-line\n    console.error(error);\n\n    dataTree = getSafeToRenderDataTree(\n      makeEntityConfigsAsObjProperties(unevalTree, {\n        sanitizeDataTree: false,\n        evalProps: dataTreeEvaluator?.evalProps,\n      }),\n      widgetTypeConfigMap,\n      configTree,\n    );\n    unEvalUpdates = [];\n    isNewTree = true;\n  }\n\n  const jsVarsCreatedEvent = getJSVariableCreatedEvents(jsUpdates);\n\n  const updates = profileFn(\n    \"diffAndGenerateSerializeUpdates\",\n    undefined,\n    webworkerTelemetry,\n    () => {\n      let updates;\n\n      if (isNewTree) {\n        try {\n          //for new tree send the whole thing, don't diff at all\n          updates = serialiseToBigInt([{ kind: \"newTree\", rhs: dataTree }]);\n          const parsedUpdates = JSON.parse(updates);\n\n          dataTreeEvaluator?.setPrevState(parsedUpdates[0].rhs);\n        } catch (e) {\n          updates = \"[]\";\n\n          errors.push({\n            type: EvalErrorTypes.EVAL_TREE_ERROR,\n            message: (e as Error).message,\n            stack: (e as Error).stack,\n          });\n        }\n        isNewTree = false;\n      } else {\n        const allUnevalUpdates = unEvalUpdates.map(\n          (update) => update.payload.propertyPath,\n        );\n\n        const completeEvalOrder = uniqueOrderUpdatePaths([\n          ...allUnevalUpdates,\n          ...evalOrder,\n        ]);\n\n        updates = generateOptimisedUpdatesAndSetPrevState(\n          dataTree,\n          dataTreeEvaluator,\n          completeEvalOrder,\n          undefined,\n          true,\n        );\n      }\n\n      return updates;\n    },\n  );\n\n  const evalTreeResponse = {\n    updates,\n    dependencies,\n    errors,\n    evalMetaUpdates,\n    evaluationOrder: evalOrder,\n    jsUpdates,\n    webworkerTelemetry,\n    // be weary of the payload size of logs it can be huge and contribute to transmission overhead\n    // we are only sending logs in local debug mode\n    logs: shouldRespondWithLogs ? logs : [],\n    unEvalUpdates,\n    isCreateFirstTree,\n    staleMetaIds,\n    removedPaths,\n    isNewWidgetAdded,\n    undefinedEvalValuesMap: dataTreeEvaluator?.undefinedEvalValuesMap || {},\n    jsVarsCreatedEvent,\n    executeReactiveActions,\n  };\n\n  webworkerTelemetry[\"transferDataToMainThread\"] = newWebWorkerSpanData(\n    \"transferDataToMainThread\",\n    {},\n  );\n\n  return evalTreeResponse;\n}\n\nexport const evalTreeTransmissionErrorHandler: TransmissionErrorHandler = (\n  messageId: string,\n  startTime: number,\n  endTime: number,\n  responseData: unknown,\n) => {\n  const sanitizedData = JSON.parse(JSON.stringify(responseData));\n\n  sendMessage.call(self, {\n    messageId,\n    messageType: MessageType.RESPONSE,\n    body: { data: sanitizedData, startTime, endTime },\n  });\n};\n\nexport function clearCache() {\n  dataTreeEvaluator = undefined;\n  clearAllIntervals();\n  JSObjectCollection.clear();\n  DataStore.clear();\n\n  return true;\n}",
            "cost": 0.12195500000000001
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/workers/Evaluation/handlers/evalTrigger.ts": {
            "output": "import { dataTreeEvaluator } from \"./evalTree\";\nimport type { EvalWorkerASyncRequest } from \"../types\";\nimport ExecutionMetaData from \"../fns/utils/ExecutionMetaData\";\nimport { evaluateAndPushResponse } from \"../evalTreeWithChanges\";\nimport { klona as klonaJson } from \"klona/json\";\n\nexport default async function (request: EvalWorkerASyncRequest) {\n  const { data } = request;\n  const {\n    callbackData,\n    dynamicTrigger,\n    eventType,\n    globalContext,\n    triggerMeta,\n    unEvalTree,\n  } = data;\n\n  if (!dataTreeEvaluator) {\n    return { triggers: [], errors: [] };\n  }\n\n  ExecutionMetaData.setExecutionMetaData({ triggerMeta, eventType });\n\n  const oldEvalTree = klonaJson(dataTreeEvaluator.getEvalTree());\n\n  if (!triggerMeta.onPageLoad) {\n    const { evalOrder, unEvalUpdates } = dataTreeEvaluator.setupUpdateTree(\n      unEvalTree.unEvalTree,\n      unEvalTree.configTree,\n      undefined,\n      //TODO: the evalTrigger can be optimised to not diff all JS actions\n      { isAllAffected: true, ids: [] },\n    );\n\n    evaluateAndPushResponse(\n      dataTreeEvaluator,\n      { evalOrder, unEvalUpdates, jsUpdates: {} },\n      [],\n      [],\n      oldEvalTree,\n    );\n  }\n\n  return dataTreeEvaluator.evaluateTriggers(\n    dynamicTrigger,\n    dataTreeEvaluator.getEvalTree(),\n    unEvalTree.configTree,\n    callbackData,\n    {\n      globalContext,\n      eventType,\n      triggerMeta,\n    },\n  );\n}",
            "output_extracted": "import { dataTreeEvaluator } from \"./evalTree\";\nimport type { EvalWorkerASyncRequest } from \"../types\";\nimport ExecutionMetaData from \"../fns/utils/ExecutionMetaData\";\nimport { evaluateAndPushResponse } from \"../evalTreeWithChanges\";\nimport { klona as klonaJson } from \"klona/json\";\n\nexport default async function (request: EvalWorkerASyncRequest) {\n  const { data } = request;\n  const {\n    callbackData,\n    dynamicTrigger,\n    eventType,\n    globalContext,\n    triggerMeta,\n    unEvalTree,\n  } = data;\n\n  if (!dataTreeEvaluator) {\n    return { triggers: [], errors: [] };\n  }\n\n  ExecutionMetaData.setExecutionMetaData({ triggerMeta, eventType });\n\n  const oldEvalTree = klonaJson(dataTreeEvaluator.getEvalTree());\n\n  if (!triggerMeta.onPageLoad) {\n    const { evalOrder, unEvalUpdates } = dataTreeEvaluator.setupUpdateTree(\n      unEvalTree.unEvalTree,\n      unEvalTree.configTree,\n      undefined,\n      //TODO: the evalTrigger can be optimised to not diff all JS actions\n      { isAllAffected: true, ids: [] },\n    );\n\n    evaluateAndPushResponse(\n      dataTreeEvaluator,\n      { evalOrder, unEvalUpdates, jsUpdates: {} },\n      [],\n      [],\n      oldEvalTree,\n    );\n  }\n\n  return dataTreeEvaluator.evaluateTriggers(\n    dynamicTrigger,\n    dataTreeEvaluator.getEvalTree(),\n    unEvalTree.configTree,\n    callbackData,\n    {\n      globalContext,\n      eventType,\n      triggerMeta,\n    },\n  );\n}",
            "cost": 0.019915000000000002
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/workers/common/DataTreeEvaluator/dataTreeEvaluator.test.ts": {
            "output": "import DataTreeEvaluator from \".\";\nimport { unEvalTree } from \"./mockData/mockUnEvalTree\";\nimport { configTree } from \"./mockData/mockConfigTree\";\nimport type { DataTree, ConfigTree } from \"entities/DataTree/dataTreeTypes\";\nimport type { DataTreeDiff } from \"ee/workers/Evaluation/evaluationUtils\";\nimport {\n  arrayAccessorCyclicDependency,\n  arrayAccessorCyclicDependencyConfig,\n} from \"./mockData/ArrayAccessorTree\";\nimport {\n  nestedArrayAccessorCyclicDependency,\n  nestedArrayAccessorCyclicDependencyConfig,\n} from \"./mockData/NestedArrayAccessorTree\";\nimport { updateDependencyMap } from \"workers/common/DependencyMap\";\nimport { replaceThisDotParams } from \"./utils\";\nimport { isDataField } from \"./utils\";\nimport { loadAllWidgets } from \"widgets\";\nimport type { WidgetConfiguration } from \"WidgetProvider/types\";\nimport { type WidgetEntity } from \"ee/entities/DataTree/types\";\nimport {\n  EXECUTION_PARAM_KEY,\n  EXECUTION_PARAM_REFERENCE_REGEX,\n} from \"constants/AppsmithActionConstants/ActionConstants\";\nimport generateOverrideContext from \"ee/workers/Evaluation/generateOverrideContext\";\nimport { klona } from \"klona\";\nimport { APP_MODE } from \"entities/App\";\nimport { EvaluationSubstitutionType } from \"constants/EvaluationConstants\";\n\nconst widgetConfigMap: Record<\n  string,\n  {\n    defaultProperties: WidgetConfiguration[\"properties\"][\"default\"];\n    derivedProperties: WidgetConfiguration[\"properties\"][\"derived\"];\n    metaProperties: WidgetConfiguration[\"properties\"][\"meta\"];\n  }\n> = {};\n\nbeforeAll(async () => {\n  const loadedWidgets = await loadAllWidgets();\n\n  loadedWidgets.forEach((widget) => {\n    if (widget.type) {\n      widgetConfigMap[widget.type] = {\n        defaultProperties: widget.getDefaultPropertiesMap(),\n        derivedProperties: widget.getDerivedPropertiesMap(),\n        metaProperties: widget.getMetaPropertiesMap(),\n      };\n    }\n  });\n});\n\njest.mock(\"ee/workers/Evaluation/generateOverrideContext\"); // mock the generateOverrideContext function\n\nconst dataTreeEvaluator = new DataTreeEvaluator(widgetConfigMap);\n\ndescribe(\"DataTreeEvaluator\", () => {\n  describe(\"evaluateActionBindings\", () => {\n    it(\"handles this.params.property\", () => {\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        [\n          \"(function() { return this.params.property })()\",\n          \"(() => { return this.params.property })()\",\n          'this.params.property || \"default value\"',\n          'this.params.property1 || \"default value\"',\n        ],\n        {\n          property: \"my value\",\n        },\n      );\n\n      expect(result).toStrictEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n      ]);\n    });\n\n    it(\"handles this?.params.property\", () => {\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        [\n          \"(() => { return this?.params.property })()\",\n          \"(function() { return this?.params.property })()\",\n          'this?.params.property || \"default value\"',\n          'this?.params.property1 || \"default value\"',\n        ],\n        {\n          property: \"my value\",\n        },\n      );\n\n      expect(result).toStrictEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n      ]);\n    });\n\n    it(\"handles this?.params?.property\", () => {\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        [\n          \"(() => { return this?.params?.property })()\",\n          \"(function() { return this?.params?.property })()\",\n          'this?.params?.property || \"default value\"',\n          'this?.params?.property1 || \"default value\"',\n        ],\n        {\n          property: \"my value\",\n        },\n      );\n\n      expect(result).toStrictEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n      ]);\n    });\n\n    it(\"handles executionParams.property\", () => {\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        [\n          \"(function() { return executionParams.property })()\",\n          \"(() => { return executionParams.property })()\",\n          'executionParams.property || \"default value\"',\n          'executionParams.property1 || \"default value\"',\n        ],\n        {\n          property: \"my value\",\n        },\n      );\n\n      expect(result).toStrictEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n      ]);\n    });\n\n    it(\"handles executionParams?.property\", () => {\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        [\n          \"(function() { return executionParams?.property })()\",\n          \"(() => { return executionParams?.property })()\",\n          'executionParams?.property || \"default value\"',\n          'executionParams?.property1 || \"default value\"',\n        ],\n        {\n          property: \"my value\",\n        },\n      );\n\n      expect(result).toStrictEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n      ]);\n    });\n\n    // The test should verify that generateOverrideContext is called and passed as context to getDynamicValue\n    it(\"should call generateOverrideContext and pass as context to getDynamicValue\", () => {\n      const overrideContextValue = { \"ModuleInstance1.inputs.input1\": \"200\" };\n\n      let generateOverrideContextParams;\n      // Mock generateOverrideContext only for this test\n      const originalGenerateOverrideContext = generateOverrideContext;\n\n      (generateOverrideContext as jest.Mock).mockImplementation((params) => {\n        // The dataTree gets mutated in evaluateActionBindings thus modifying the\n        // original params passed to this function. This helps preserving the params\n        // actually passed.\n        generateOverrideContextParams = klona(params);\n\n        return overrideContextValue;\n      });\n\n      const widgetConfigMap = {};\n      const dataTreeEvaluator = new DataTreeEvaluator(widgetConfigMap);\n      const dataTree = {\n        Text1: {\n          text: \"Hello\",\n        },\n        ModuleInstance1: {\n          inputs: {\n            input1: \"10\",\n          },\n        },\n      } as unknown as DataTree;\n      const bindings = [\n        \"(function() { return this.params.property })()\",\n        \"(() => { return this.params.property })()\",\n        'this.params.property || \"default value\"',\n        'this.params.property1 || \"default value\"',\n        \"ModuleInstance1.inputs.input1\",\n      ];\n      const executionParams = {\n        property: \"my value\",\n        input1: \"200\",\n      };\n\n      dataTreeEvaluator.evalTree = klona(dataTree);\n\n      const originalGetDynamicValue =\n        dataTreeEvaluator.getDynamicValue.bind(dataTreeEvaluator);\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const getDynamicValueCapturedParams: any[] = [];\n\n      jest.spyOn(dataTreeEvaluator, \"getDynamicValue\");\n      (dataTreeEvaluator.getDynamicValue as jest.Mock).mockImplementation(\n        (...args) => {\n          getDynamicValueCapturedParams.push(args);\n\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          return originalGetDynamicValue(...args);\n        },\n      );\n\n      // Call the method under test\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        bindings,\n        executionParams,\n      );\n\n      expect(generateOverrideContext).toHaveBeenCalled();\n      expect(generateOverrideContextParams).toEqual({\n        bindings,\n        executionParams,\n        dataTree,\n      });\n\n      // Check results\n      expect(result).toEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n        \"200\",\n      ]);\n\n      // Verify getDynamicValue receives the correct parameters\n      // The first call is always with executionParams\n      [`${JSON.stringify(executionParams)}`, ...bindings].forEach(\n        (binding, index) => {\n          const replacedBinding = binding.replace(\n            EXECUTION_PARAM_REFERENCE_REGEX,\n            EXECUTION_PARAM_KEY,\n          );\n\n          let defaultExpectedValue = [\n            `{{${replacedBinding}}}`,\n            klona(dataTree),\n            dataTreeEvaluator.oldConfigTree,\n            EvaluationSubstitutionType.TEMPLATE,\n          ];\n\n          if (index !== 0) {\n            defaultExpectedValue = [\n              ...defaultExpectedValue,\n              expect.objectContaining({\n                overrideContext: overrideContextValue,\n              }),\n            ];\n          }\n\n          expect(getDynamicValueCapturedParams[index]).toEqual(\n            defaultExpectedValue,\n          );\n        },\n      );\n\n      // Restore the original function after the test\n      (generateOverrideContext as jest.Mock).mockImplementation(\n        originalGenerateOverrideContext,\n      );\n    });\n  });\n\n  describe(\"test updateDependencyMap\", () => {\n    beforeEach(async () => {\n      await dataTreeEvaluator.setupFirstTree(\n        unEvalTree as unknown as DataTree,\n        configTree as unknown as ConfigTree,\n        {},\n        {\n          appId: \"appId\",\n          pageId: \"pageId\",\n          timestamp: \"timestamp\",\n          appMode: APP_MODE.PUBLISHED,\n          instanceId: \"instanceId\",\n          dslVersion: 1,\n        },\n      );\n      dataTreeEvaluator.evalAndValidateFirstTree();\n    });\n\n    it(\"initial dependencyMap computation\", () => {\n      const { evalOrder, unEvalUpdates } = dataTreeEvaluator.setupUpdateTree(\n        unEvalTree as unknown as DataTree,\n        configTree as unknown as ConfigTree,\n      );\n\n      dataTreeEvaluator.evalAndValidateSubTree(\n        evalOrder,\n        configTree as unknown as ConfigTree,\n        unEvalUpdates,\n        [],\n        dataTreeEvaluator.evalTree,\n      );\n\n      expect(dataTreeEvaluator.dependencies).toStrictEqual({\n        \"Button2.text\": [\"Button1.text\"],\n        Button2: [\"Button2.text\"],\n        Button1: [\"Button1.text\"],\n      });\n    });\n\n    it(`When empty binding is modified from {{Button1.text}} to {{\"\"}}`, () => {\n      const translatedDiffs = [\n        {\n          payload: {\n            propertyPath: \"Button2.text\",\n            value: '{{\"\"}}',\n          },\n          event: \"EDIT\",\n        },\n      ];\n      const button2 = dataTreeEvaluator.oldUnEvalTree.Button2 as WidgetEntity;\n      const newUnevalTree = {\n        ...dataTreeEvaluator.oldUnEvalTree,\n        Button2: {\n          ...button2,\n          text: '{{\"\"}}',\n        },\n      };\n      const { dependencies } = updateDependencyMap({\n        configTree: configTree as unknown as ConfigTree,\n        dataTreeEvalRef: dataTreeEvaluator,\n        translatedDiffs: translatedDiffs as Array<DataTreeDiff>,\n        unEvalDataTree: newUnevalTree,\n      });\n\n      expect(dependencies).toStrictEqual({\n        \"Button2.text\": [],\n        Button2: [\"Button2.text\"],\n        Button1: [\"Button1.text\"],\n      });\n    });\n\n    it(`When binding is removed`, () => {\n      const translatedDiffs = [\n        {\n          payload: {\n            propertyPath: \"Button2.text\",\n            value: \"abc\",\n          },\n          event: \"EDIT\",\n        },\n      ];\n      const button2 = dataTreeEvaluator.oldUnEvalTree.Button2 as WidgetEntity;\n      const newUnevalTree = {\n        ...dataTreeEvaluator.oldUnEvalTree,\n        Button2: {\n          ...button2,\n          text: \"abc\",\n        },\n      };\n      const { dependencies } = updateDependencyMap({\n        dataTreeEvalRef: dataTreeEvaluator,\n        translatedDiffs: translatedDiffs as Array<DataTreeDiff>,\n        unEvalDataTree: newUnevalTree,\n        configTree: configTree as unknown as ConfigTree,\n      });\n\n      expect(dependencies).toStrictEqual({\n        Button2: [\"Button2.text\"],\n        Button1: [\"Button1.text\"],\n        \"Button2.text\": [],\n      });\n    });\n  });\n\n  describe(\"actionsToUpdate affects setupTree\", () => {\n    beforeEach(async () => {\n      await dataTreeEvaluator.setupFirstTree(\n        unEvalTree as unknown as DataTree,\n        configTree as unknown as ConfigTree,\n        {},\n        {\n          appId: \"appId\",\n          pageId: \"pageId\",\n          timestamp: \"timestamp\",\n          appMode: APP_MODE.PUBLISHED,\n          instanceId: \"instanceId\",\n          dslVersion: 1,\n        },\n      );\n      dataTreeEvaluator.evalAndValidateFirstTree();\n    });\n    describe(\"when unevalTree is the same\", () => {\n      it(\"should not call the setupTree when there are actionsToUpdate\", () => {\n        const spy = jest.spyOn(dataTreeEvaluator, \"setupTree\");\n\n        dataTreeEvaluator.setupUpdateTree(\n          unEvalTree as unknown as DataTree,\n          configTree as unknown as ConfigTree,\n          undefined,\n          undefined,\n          [],\n        );\n\n        expect(spy).not.toHaveBeenCalled();\n      });\n      it(\"should pass in actionsToUpdate as updatedValuePaths to the setupTree\", () => {\n        const spy = jest.spyOn(dataTreeEvaluator, \"setupTree\");\n\n        dataTreeEvaluator.setupUpdateTree(\n          unEvalTree as unknown as DataTree,\n          configTree as unknown as ConfigTree,\n          undefined,\n          undefined,\n          [\n            {\n              entityName: \"JSAction1\",\n              dataPath: \"data\",\n              data: [\"Some data\"],\n            },\n          ],\n        );\n\n        expect(spy).toHaveBeenCalledWith(\n          expect.anything(),\n          [[\"JSAction1\", \"data\"]],\n          {\n            dependenciesOfRemovedPaths: [],\n            pathsToSkipFromEval: [\"JSAction1.data\"],\n            removedPaths: [],\n            translatedDiffs: [],\n          },\n        );\n      });\n    });\n  });\n\n  describe(\"array accessor dependency handling\", () => {\n    const dataTreeEvaluator = new DataTreeEvaluator(widgetConfigMap);\n\n    beforeEach(async () => {\n      await dataTreeEvaluator.setupFirstTree(\n        nestedArrayAccessorCyclicDependency.initUnEvalTree,\n        nestedArrayAccessorCyclicDependencyConfig.initConfigTree,\n        {},\n        {\n          appId: \"appId\",\n          pageId: \"pageId\",\n          timestamp: new Date().toISOString(),\n          appMode: APP_MODE.PUBLISHED,\n          instanceId: \"instanceId\",\n          dslVersion: 1,\n        },\n      );\n      dataTreeEvaluator.evalAndValidateFirstTree();\n    });\n    describe(\"array of objects\", () => {\n      // when Text1.text has a binding Api1.data[2].id\n      it(\"on consequent API failures\", () => {\n        // cyclic dependency case\n        for",
            "output_extracted": "import DataTreeEvaluator from \".\";\nimport { unEvalTree } from \"./mockData/mockUnEvalTree\";\nimport { configTree } from \"./mockData/mockConfigTree\";\nimport type { DataTree, ConfigTree } from \"entities/DataTree/dataTreeTypes\";\nimport type { DataTreeDiff } from \"ee/workers/Evaluation/evaluationUtils\";\nimport {\n  arrayAccessorCyclicDependency,\n  arrayAccessorCyclicDependencyConfig,\n} from \"./mockData/ArrayAccessorTree\";\nimport {\n  nestedArrayAccessorCyclicDependency,\n  nestedArrayAccessorCyclicDependencyConfig,\n} from \"./mockData/NestedArrayAccessorTree\";\nimport { updateDependencyMap } from \"workers/common/DependencyMap\";\nimport { replaceThisDotParams } from \"./utils\";\nimport { isDataField } from \"./utils\";\nimport { loadAllWidgets } from \"widgets\";\nimport type { WidgetConfiguration } from \"WidgetProvider/types\";\nimport { type WidgetEntity } from \"ee/entities/DataTree/types\";\nimport {\n  EXECUTION_PARAM_KEY,\n  EXECUTION_PARAM_REFERENCE_REGEX,\n} from \"constants/AppsmithActionConstants/ActionConstants\";\nimport generateOverrideContext from \"ee/workers/Evaluation/generateOverrideContext\";\nimport { klona } from \"klona\";\nimport { APP_MODE } from \"entities/App\";\nimport { EvaluationSubstitutionType } from \"constants/EvaluationConstants\";\n\nconst widgetConfigMap: Record<\n  string,\n  {\n    defaultProperties: WidgetConfiguration[\"properties\"][\"default\"];\n    derivedProperties: WidgetConfiguration[\"properties\"][\"derived\"];\n    metaProperties: WidgetConfiguration[\"properties\"][\"meta\"];\n  }\n> = {};\n\nbeforeAll(async () => {\n  const loadedWidgets = await loadAllWidgets();\n\n  loadedWidgets.forEach((widget) => {\n    if (widget.type) {\n      widgetConfigMap[widget.type] = {\n        defaultProperties: widget.getDefaultPropertiesMap(),\n        derivedProperties: widget.getDerivedPropertiesMap(),\n        metaProperties: widget.getMetaPropertiesMap(),\n      };\n    }\n  });\n});\n\njest.mock(\"ee/workers/Evaluation/generateOverrideContext\"); // mock the generateOverrideContext function\n\nconst dataTreeEvaluator = new DataTreeEvaluator(widgetConfigMap);\n\ndescribe(\"DataTreeEvaluator\", () => {\n  describe(\"evaluateActionBindings\", () => {\n    it(\"handles this.params.property\", () => {\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        [\n          \"(function() { return this.params.property })()\",\n          \"(() => { return this.params.property })()\",\n          'this.params.property || \"default value\"',\n          'this.params.property1 || \"default value\"',\n        ],\n        {\n          property: \"my value\",\n        },\n      );\n\n      expect(result).toStrictEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n      ]);\n    });\n\n    it(\"handles this?.params.property\", () => {\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        [\n          \"(() => { return this?.params.property })()\",\n          \"(function() { return this?.params.property })()\",\n          'this?.params.property || \"default value\"',\n          'this?.params.property1 || \"default value\"',\n        ],\n        {\n          property: \"my value\",\n        },\n      );\n\n      expect(result).toStrictEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n      ]);\n    });\n\n    it(\"handles this?.params?.property\", () => {\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        [\n          \"(() => { return this?.params?.property })()\",\n          \"(function() { return this?.params?.property })()\",\n          'this?.params?.property || \"default value\"',\n          'this?.params?.property1 || \"default value\"',\n        ],\n        {\n          property: \"my value\",\n        },\n      );\n\n      expect(result).toStrictEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n      ]);\n    });\n\n    it(\"handles executionParams.property\", () => {\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        [\n          \"(function() { return executionParams.property })()\",\n          \"(() => { return executionParams.property })()\",\n          'executionParams.property || \"default value\"',\n          'executionParams.property1 || \"default value\"',\n        ],\n        {\n          property: \"my value\",\n        },\n      );\n\n      expect(result).toStrictEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n      ]);\n    });\n\n    it(\"handles executionParams?.property\", () => {\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        [\n          \"(function() { return executionParams?.property })()\",\n          \"(() => { return executionParams?.property })()\",\n          'executionParams?.property || \"default value\"',\n          'executionParams?.property1 || \"default value\"',\n        ],\n        {\n          property: \"my value\",\n        },\n      );\n\n      expect(result).toStrictEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n      ]);\n    });\n\n    // The test should verify that generateOverrideContext is called and passed as context to getDynamicValue\n    it(\"should call generateOverrideContext and pass as context to getDynamicValue\", () => {\n      const overrideContextValue = { \"ModuleInstance1.inputs.input1\": \"200\" };\n\n      let generateOverrideContextParams;\n      // Mock generateOverrideContext only for this test\n      const originalGenerateOverrideContext = generateOverrideContext;\n\n      (generateOverrideContext as jest.Mock).mockImplementation((params) => {\n        // The dataTree gets mutated in evaluateActionBindings thus modifying the\n        // original params passed to this function. This helps preserving the params\n        // actually passed.\n        generateOverrideContextParams = klona(params);\n\n        return overrideContextValue;\n      });\n\n      const widgetConfigMap = {};\n      const dataTreeEvaluator = new DataTreeEvaluator(widgetConfigMap);\n      const dataTree = {\n        Text1: {\n          text: \"Hello\",\n        },\n        ModuleInstance1: {\n          inputs: {\n            input1: \"10\",\n          },\n        },\n      } as unknown as DataTree;\n      const bindings = [\n        \"(function() { return this.params.property })()\",\n        \"(() => { return this.params.property })()\",\n        'this.params.property || \"default value\"',\n        'this.params.property1 || \"default value\"',\n        \"ModuleInstance1.inputs.input1\",\n      ];\n      const executionParams = {\n        property: \"my value\",\n        input1: \"200\",\n      };\n\n      dataTreeEvaluator.evalTree = klona(dataTree);\n\n      const originalGetDynamicValue =\n        dataTreeEvaluator.getDynamicValue.bind(dataTreeEvaluator);\n      // TODO: Fix this the next time the file is edited\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const getDynamicValueCapturedParams: any[] = [];\n\n      jest.spyOn(dataTreeEvaluator, \"getDynamicValue\");\n      (dataTreeEvaluator.getDynamicValue as jest.Mock).mockImplementation(\n        (...args) => {\n          getDynamicValueCapturedParams.push(args);\n\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          return originalGetDynamicValue(...args);\n        },\n      );\n\n      // Call the method under test\n      const result = dataTreeEvaluator.evaluateActionBindings(\n        bindings,\n        executionParams,\n      );\n\n      expect(generateOverrideContext).toHaveBeenCalled();\n      expect(generateOverrideContextParams).toEqual({\n        bindings,\n        executionParams,\n        dataTree,\n      });\n\n      // Check results\n      expect(result).toEqual([\n        \"my value\",\n        \"my value\",\n        \"my value\",\n        \"default value\",\n        \"200\",\n      ]);\n\n      // Verify getDynamicValue receives the correct parameters\n      // The first call is always with executionParams\n      [`${JSON.stringify(executionParams)}`, ...bindings].forEach(\n        (binding, index) => {\n          const replacedBinding = binding.replace(\n            EXECUTION_PARAM_REFERENCE_REGEX,\n            EXECUTION_PARAM_KEY,\n          );\n\n          let defaultExpectedValue = [\n            `{{${replacedBinding}}}`,\n            klona(dataTree),\n            dataTreeEvaluator.oldConfigTree,\n            EvaluationSubstitutionType.TEMPLATE,\n          ];\n\n          if (index !== 0) {\n            defaultExpectedValue = [\n              ...defaultExpectedValue,\n              expect.objectContaining({\n                overrideContext: overrideContextValue,\n              }),\n            ];\n          }\n\n          expect(getDynamicValueCapturedParams[index]).toEqual(\n            defaultExpectedValue,\n          );\n        },\n      );\n\n      // Restore the original function after the test\n      (generateOverrideContext as jest.Mock).mockImplementation(\n        originalGenerateOverrideContext,\n      );\n    });\n  });\n\n  describe(\"test updateDependencyMap\", () => {\n    beforeEach(async () => {\n      await dataTreeEvaluator.setupFirstTree(\n        unEvalTree as unknown as DataTree,\n        configTree as unknown as ConfigTree,\n        {},\n        {\n          appId: \"appId\",\n          pageId: \"pageId\",\n          timestamp: \"timestamp\",\n          appMode: APP_MODE.PUBLISHED,\n          instanceId: \"instanceId\",\n          dslVersion: 1,\n        },\n      );\n      dataTreeEvaluator.evalAndValidateFirstTree();\n    });\n\n    it(\"initial dependencyMap computation\", () => {\n      const { evalOrder, unEvalUpdates } = dataTreeEvaluator.setupUpdateTree(\n        unEvalTree as unknown as DataTree,\n        configTree as unknown as ConfigTree,\n      );\n\n      dataTreeEvaluator.evalAndValidateSubTree(\n        evalOrder,\n        configTree as unknown as ConfigTree,\n        unEvalUpdates,\n        [],\n        dataTreeEvaluator.evalTree,\n      );\n\n      expect(dataTreeEvaluator.dependencies).toStrictEqual({\n        \"Button2.text\": [\"Button1.text\"],\n        Button2: [\"Button2.text\"],\n        Button1: [\"Button1.text\"],\n      });\n    });\n\n    it(`When empty binding is modified from {{Button1.text}} to {{\"\"}}`, () => {\n      const translatedDiffs = [\n        {\n          payload: {\n            propertyPath: \"Button2.text\",\n            value: '{{\"\"}}',\n          },\n          event: \"EDIT\",\n        },\n      ];\n      const button2 = dataTreeEvaluator.oldUnEvalTree.Button2 as WidgetEntity;\n      const newUnevalTree = {\n        ...dataTreeEvaluator.oldUnEvalTree,\n        Button2: {\n          ...button2,\n          text: '{{\"\"}}',\n        },\n      };\n      const { dependencies } = updateDependencyMap({\n        configTree: configTree as unknown as ConfigTree,\n        dataTreeEvalRef: dataTreeEvaluator,\n        translatedDiffs: translatedDiffs as Array<DataTreeDiff>,\n        unEvalDataTree: newUnevalTree,\n      });\n\n      expect(dependencies).toStrictEqual({\n        \"Button2.text\": [],\n        Button2: [\"Button2.text\"],\n        Button1: [\"Button1.text\"],\n      });\n    });\n\n    it(`When binding is removed`, () => {\n      const translatedDiffs = [\n        {\n          payload: {\n            propertyPath: \"Button2.text\",\n            value: \"abc\",\n          },\n          event: \"EDIT\",\n        },\n      ];\n      const button2 = dataTreeEvaluator.oldUnEvalTree.Button2 as WidgetEntity;\n      const newUnevalTree = {\n        ...dataTreeEvaluator.oldUnEvalTree,\n        Button2: {\n          ...button2,\n          text: \"abc\",\n        },\n      };\n      const { dependencies } = updateDependencyMap({\n        dataTreeEvalRef: dataTreeEvaluator,\n        translatedDiffs: translatedDiffs as Array<DataTreeDiff>,\n        unEvalDataTree: newUnevalTree,\n        configTree: configTree as unknown as ConfigTree,\n      });\n\n      expect(dependencies).toStrictEqual({\n        Button2: [\"Button2.text\"],\n        Button1: [\"Button1.text\"],\n        \"Button2.text\": [],\n      });\n    });\n  });\n\n  describe(\"actionsToUpdate affects setupTree\", () => {\n    beforeEach(async () => {\n      await dataTreeEvaluator.setupFirstTree(\n        unEvalTree as unknown as DataTree,\n        configTree as unknown as ConfigTree,\n        {},\n        {\n          appId: \"appId\",\n          pageId: \"pageId\",\n          timestamp: \"timestamp\",\n          appMode: APP_MODE.PUBLISHED,\n          instanceId: \"instanceId\",\n          dslVersion: 1,\n        },\n      );\n      dataTreeEvaluator.evalAndValidateFirstTree();\n    });\n    describe(\"when unevalTree is the same\", () => {\n      it(\"should not call the setupTree when there are actionsToUpdate\", () => {\n        const spy = jest.spyOn(dataTreeEvaluator, \"setupTree\");\n\n        dataTreeEvaluator.setupUpdateTree(\n          unEvalTree as unknown as DataTree,\n          configTree as unknown as ConfigTree,\n          undefined,\n          undefined,\n          [],\n        );\n\n        expect(spy).not.toHaveBeenCalled();\n      });\n      it(\"should pass in actionsToUpdate as updatedValuePaths to the setupTree\", () => {\n        const spy = jest.spyOn(dataTreeEvaluator, \"setupTree\");\n\n        dataTreeEvaluator.setupUpdateTree(\n          unEvalTree as unknown as DataTree,\n          configTree as unknown as ConfigTree,\n          undefined,\n          undefined,\n          [\n            {\n              entityName: \"JSAction1\",\n              dataPath: \"data\",\n              data: [\"Some data\"],\n            },\n          ],\n        );\n\n        expect(spy).toHaveBeenCalledWith(\n          expect.anything(),\n          [[\"JSAction1\", \"data\"]],\n          {\n            dependenciesOfRemovedPaths: [],\n            pathsToSkipFromEval: [\"JSAction1.data\"],\n            removedPaths: [],\n            translatedDiffs: [],\n          },\n        );\n      });\n    });\n  });\n\n  describe(\"array accessor dependency handling\", () => {\n    const dataTreeEvaluator = new DataTreeEvaluator(widgetConfigMap);\n\n    beforeEach(async () => {\n      await dataTreeEvaluator.setupFirstTree(\n        nestedArrayAccessorCyclicDependency.initUnEvalTree,\n        nestedArrayAccessorCyclicDependencyConfig.initConfigTree,\n        {},\n        {\n          appId: \"appId\",\n          pageId: \"pageId\",\n          timestamp: new Date().toISOString(),\n          appMode: APP_MODE.PUBLISHED,\n          instanceId: \"instanceId\",\n          dslVersion: 1,\n        },\n      );\n      dataTreeEvaluator.evalAndValidateFirstTree();\n    });\n    describe(\"array of objects\", () => {\n      // when Text1.text has a binding Api1.data[2].id\n      it(\"on consequent API failures\", () => {\n        // cyclic dependency case\n        for",
            "cost": 0.17074
        },
        "appsmithorg__appsmith.7046aeb3/app/client/src/workers/common/DataTreeEvaluator/index.ts": {
            "output": "import type {\n  DataTreeEvaluationProps,\n  EvalError as TEvalError,\n  EvaluationError,\n} from \"utils/DynamicBindingUtils\";\nimport {\n  EvalErrorTypes,\n  getDynamicBindings,\n  getEntityDynamicBindingPathList,\n  getEntityId,\n  getEntityName,\n  getEvalErrorPath,\n  getEvalValuePath,\n  isChildPropertyPath,\n  isDynamicValue,\n  isPathDynamicTrigger,\n  PropertyEvaluationErrorType,\n} from \"utils/DynamicBindingUtils\";\nimport type { WidgetTypeConfigMap } from \"WidgetProvider/factory/types\";\nimport type {\n  WidgetEntity,\n  WidgetEntityConfig,\n  ActionEntity,\n  JSActionEntityConfig,\n  PrivateWidgets,\n  ActionEntityConfig,\n  DataTreeEntityConfig,\n} from \"ee/entities/DataTree/types\";\nimport type {\n  DataTree,\n  DataTreeEntity,\n  ConfigTree,\n  UnEvalTree,\n} from \"entities/DataTree/dataTreeTypes\";\nimport { ENTITY_TYPE } from \"ee/entities/DataTree/types\";\nimport type { DataTreeDiff } from \"ee/workers/Evaluation/evaluationUtils\";\nimport {\n  convertMicroDiffToDeepDiff,\n  getAllPathsBasedOnDiffPaths,\n  isDataPath,\n  isJSModuleInstance,\n  isPropertyAnEntityAction,\n} from \"ee/workers/Evaluation/evaluationUtils\";\n\nimport {\n  addDependantsOfNestedPropertyPaths,\n  addErrorToEntityProperty,\n  convertPathToString,\n  CrashingError,\n  getEntityNameAndPropertyPath,\n  getImmediateParentsOfPropertyPaths,\n  isAction,\n  isDynamicLeaf,\n  isJSAction,\n  isWidget,\n  translateDiffEventToDataTreeDiffEvent,\n  trimDependantChangePaths,\n  overrideWidgetProperties,\n  getAllPaths,\n  isNewEntity,\n  getStaleMetaStateIds,\n  convertJSFunctionsToString,\n  DataTreeDiffEvent,\n  resetValidationErrorsForEntityProperty,\n  isAPathDynamicBindingPath,\n  isAnyJSAction,\n  isNotEntity,\n  getExternalChangedDependencies,\n} from \"ee/workers/Evaluation/evaluationUtils\";\nimport {\n  difference,\n  flatten,\n  get,\n  isArray,\n  isEmpty,\n  isEqual,\n  isFunction,\n  isObject,\n  isUndefined,\n  set,\n  unset,\n} from \"lodash\";\n\nimport type { Diff } from \"deep-diff\";\nimport { applyChange, diff } from \"deep-diff\";\nimport {\n  EXECUTION_PARAM_KEY,\n  EXECUTION_PARAM_REFERENCE_REGEX,\n  THIS_DOT_PARAMS_KEY,\n} from \"constants/AppsmithActionConstants/ActionConstants\";\nimport {\n  evaluateSync,\n  resetWorkerGlobalScope,\n  type EvalResult,\n  type EvaluateContext,\n  evaluateAsync,\n  setEvalContext,\n} from \"workers/Evaluation/evaluate\";\nimport { substituteDynamicBindingWithValues } from \"workers/Evaluation/evaluationSubstitution\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport { error as logError } from \"loglevel\";\nimport type { JSUpdate } from \"utils/JSPaneUtils\";\n\nimport type {\n  ActionValidationConfigMap,\n  ValidationConfig,\n} from \"constants/PropertyControlConstants\";\nimport { klona } from \"klona/full\";\nimport { klona as klonaJSON } from \"klona/json\";\nimport type { EvalMetaUpdates } from \"ee/workers/common/DataTreeEvaluator/types\";\nimport {\n  updateDependencyMap,\n  createDependencyMap,\n} from \"workers/common/DependencyMap\";\nimport {\n  getJSEntities,\n  getUpdatedLocalUnEvalTreeAfterJSUpdates,\n  parseJSActions,\n  updateEvalTreeWithJSCollectionState,\n} from \"workers/Evaluation/JSObject\";\nimport {\n  getFixedTimeDifference,\n  getIsNewWidgetAdded,\n  getOnlyAffectedJSObjects,\n  replaceThisDotParams,\n} from \"./utils\";\nimport { isJSObjectFunction } from \"workers/Evaluation/JSObject/utils\";\nimport {\n  validateActionProperty,\n  validateAndParseWidgetProperty,\n  validateWidgetProperty,\n} from \"./validationUtils\";\nimport { errorModifier } from \"workers/Evaluation/errorModifier\";\nimport JSObjectCollection from \"workers/Evaluation/JSObject/Collection\";\nimport userLogs from \"workers/Evaluation/fns/overrides/console\";\nimport ExecutionMetaData from \"workers/Evaluation/fns/utils/ExecutionMetaData\";\nimport DependencyMap from \"entities/DependencyMap\";\nimport { DependencyMapUtils } from \"entities/DependencyMap/DependencyMapUtils\";\nimport {\n  isWidgetActionOrJsObject,\n  isThemeUnevaluatedValue,\n} from \"ee/entities/DataTree/utils\";\nimport DataStore from \"workers/Evaluation/dataStore\";\nimport { updateTreeWithData } from \"workers/Evaluation/dataStore/utils\";\nimport microDiff from \"microdiff\";\nimport {\n  profileAsyncFn,\n  profileFn,\n} from \"instrumentation/generateWebWorkerTraces\";\nimport generateOverrideContext from \"ee/workers/Evaluation/generateOverrideContext\";\nimport appComputationCache from \"../AppComputationCache\";\nimport {\n  EComputationCacheName,\n  type ICacheProps,\n} from \"../AppComputationCache/types\";\nimport { getDataTreeContext } from \"ee/workers/Evaluation/Actions\";\nimport { WorkerEnv } from \"workers/Evaluation/handlers/workerEnv\";\nimport type { WebworkerSpanData, Attributes } from \"instrumentation/types\";\nimport type { AffectedJSObjects } from \"actions/EvaluationReduxActionTypes\";\nimport type { UpdateActionProps } from \"workers/Evaluation/handlers/types\";\nimport { EvaluationSubstitutionType } from \"constants/EvaluationConstants\";\n\ntype SortedDependencies = Array<string>;\nexport interface EvalProps {\n  [entityName: string]: DataTreeEvaluationProps;\n}\n\nexport default class DataTreeEvaluator {\n  dependencyMap: DependencyMap = new DependencyMap();\n  sortedDependencies: SortedDependencies = [];\n  dependencies: Record<string, string[]> = {};\n  inverseDependencies: Record<string, string[]> = {};\n  widgetConfigMap: WidgetTypeConfigMap = {};\n  evalTree: DataTree = {};\n  configTree: ConfigTree = {};\n\n  /**\n   * This contains raw evaluated value without any validation or parsing.\n   * This is used for revalidation as we do not store the raw validated value.\n   */\n  unParsedEvalTree: DataTree = {};\n  allKeys: Record<string, true> = {};\n  privateWidgets: PrivateWidgets = {};\n  oldUnEvalTree: UnEvalTree = {};\n  oldConfigTree: ConfigTree = {};\n  errors: TEvalError[] = [];\n  logs: unknown[] = [];\n  console = userLogs;\n  allActionValidationConfig?: {\n    [actionId: string]: ActionValidationConfigMap;\n  };\n\n  /**\n   * Sanitized eval values and errors\n   */\n  evalProps: EvalProps = {};\n  undefinedEvalValuesMap: Record<string, boolean> = {};\n\n  prevState = {};\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  setPrevState(state: any) {\n    this.prevState = state;\n  }\n  getPrevState() {\n    return this.prevState;\n  }\n  public hasCyclicalDependency = false;\n  constructor(\n    widgetConfigMap: WidgetTypeConfigMap,\n    allActionValidationConfig?: {\n      [actionId: string]: ActionValidationConfigMap;\n    },\n  ) {\n    this.allActionValidationConfig = allActionValidationConfig;\n    this.widgetConfigMap = widgetConfigMap;\n  }\n\n  getEvalTree() {\n    return this.evalTree;\n  }\n\n  getEvalProps() {\n    return this.evalProps;\n  }\n\n  setEvalTree(evalTree: DataTree) {\n    this.evalTree = evalTree;\n  }\n\n  getConfigTree() {\n    return this.configTree;\n  }\n\n  setConfigTree(configTree: ConfigTree) {\n    if (configTree) this.configTree = configTree;\n  }\n\n  getUnParsedEvalTree() {\n    return this.unParsedEvalTree;\n  }\n\n  setUnParsedEvalTree(unParsedEvalTree: DataTree) {\n    this.unParsedEvalTree = unParsedEvalTree;\n  }\n\n  getOldUnevalTree() {\n    return this.oldUnEvalTree;\n  }\n\n  setOldUnevalTree(oldUnEvalTree: UnEvalTree) {\n    this.oldUnEvalTree = oldUnEvalTree;\n  }\n  /**\n   * Method to create all data required for linting and\n   * evaluation of the first tree\n   */\n  async setupFirstTree(\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    unEvalTree: any,\n    configTree: ConfigTree,\n    webworkerTelemetry: Record<string, WebworkerSpanData | Attributes> = {},\n    cacheProps: ICacheProps,\n  ) {\n    this.setConfigTree(configTree);\n\n    const totalFirstTreeSetupStartTime = performance.now();\n    // cloneDeep will make sure not to omit key which has value as undefined.\n    const firstCloneStartTime = performance.now();\n    let localUnEvalTree = klona(unEvalTree);\n    const firstCloneEndTime = performance.now();\n\n    let jsUpdates: Record<string, JSUpdate> = {};\n    //parse js collection to get functions\n    //save current state of js collection action and variables to be added to uneval tree\n    //save functions in resolveFunctions (as functions) to be executed as functions are not allowed in evalTree\n    //and functions are saved in dataTree as strings\n    const parseJSActionsStartTime = performance.now();\n    const parsedCollections = profileFn(\n      \"SetupFirstTree.parseJSActions\",\n      undefined,\n      webworkerTelemetry,\n      () => {\n        return parseJSActions(this, localUnEvalTree);\n      },\n    );\n    const parseJSActionsEndTime = performance.now();\n\n    jsUpdates = parsedCollections.jsUpdates;\n    localUnEvalTree = getUpdatedLocalUnEvalTreeAfterJSUpdates(\n      jsUpdates,\n      localUnEvalTree,\n      configTree,\n    );\n    const localUnEvalTreeJSCollection = getJSEntities(localUnEvalTree);\n    const stringifiedLocalUnEvalTreeJSCollection = convertJSFunctionsToString(\n      localUnEvalTreeJSCollection,\n      configTree,\n    );\n    const unEvalTreeWithStrigifiedJSFunctions = Object.assign(\n      {},\n      localUnEvalTree,\n      stringifiedLocalUnEvalTreeJSCollection,\n    );\n    const allKeysGenerationStartTime = performance.now();\n\n    try {\n      this.allKeys = await appComputationCache.fetchOrCompute({\n        cacheProps,\n        cacheName: EComputationCacheName.ALL_KEYS,\n        computeFn: () => getAllPaths(unEvalTreeWithStrigifiedJSFunctions),\n      });\n    } catch (error) {\n      this.errors.push({\n        type: EvalErrorTypes.CACHE_ERROR,\n        message: (error as Error).message,\n        stack: (error as Error).stack,\n      });\n\n      this.allKeys = getAllPaths(unEvalTreeWithStrigifiedJSFunctions);\n    }\n\n    const allKeysGenerationEndTime = performance.now();\n\n    const createDependencyMapStartTime = performance.now();\n\n    const { dependencies, inverseDependencies } = await profileAsyncFn(\n      \"createDependencyMap\",\n      async () =>\n        createDependencyMap(\n          this,\n          localUnEvalTree,\n          configTree,\n          cacheProps,\n          webworkerTelemetry,\n        ),\n      webworkerTelemetry,\n    );\n\n    const createDependencyMapEndTime = performance.now();\n\n    this.dependencies = dependencies;\n    this.inverseDependencies = inverseDependencies;\n\n    const sortDependenciesStartTime = performance.now();\n\n    this.sortedDependencies = this.sortDependencies(\n      this.dependencyMap,\n      [],\n      configTree,\n    );\n    const sortDependenciesEndTime = performance.now();\n\n    const secondCloneStartTime = performance.now();\n\n    this.oldUnEvalTree = klona(localUnEvalTree);\n    this.oldConfigTree = configTree;\n    const secondCloneEndTime = performance.now();\n\n    const totalFirstTreeSetupEndTime = performance.now();\n\n    const timeTakenForSetupFirstTree = {\n      total: getFixedTimeDifference(\n        totalFirstTreeSetupEndTime,\n        totalFirstTreeSetupStartTime,\n      ),\n      clone: getFixedTimeDifference(\n        firstCloneEndTime + secondCloneEndTime,\n        firstCloneStartTime + secondCloneStartTime,\n      ),\n      allKeys: getFixedTimeDifference(\n        allKeysGenerationEndTime,\n        allKeysGenerationStartTime,\n      ),\n      createDependencyMap: getFixedTimeDifference(\n        createDependencyMapEndTime,\n        createDependencyMapStartTime,\n      ),\n      sortDependencies: getFixedTimeDifference(\n        sortDependenciesEndTime,\n        sortDependenciesStartTime,\n      ),\n      parseJSActions: getFixedTimeDifference(\n        parseJSActionsEndTime,\n        parseJSActionsStartTime,\n      ),\n    };\n\n    this.logs.push({\n      timeTakenForSetupFirstTree,\n      dependencies: this.dependencies,\n      inverseDependencies: this.inverseDependencies,\n    });\n\n    return {\n      jsUpdates,\n      evalOrder: this.sortedDependencies,\n    };\n  }\n\n  /**\n   * Mutates the dataTree.\n   * Validates all the nodes of the tree to make sure all the values are as expected according to the validation config\n   *\n   * For example :- If Button.isDisabled is set to false in propertyPane then it would be passed as \"false\" in unEvalTree and validateTree method makes sure to convert it to boolean.\n   * @param tree\n   * @param option\n   * @param configTree\n   * @returns\n   */\n  validatedTree(\n    dataTree: DataTree,\n    option: {\n      evalProps: EvalProps;\n    },\n    configTree: ConfigTree,\n  ) {\n    const unParsedEvalTree = this.getUnParsedEvalTree();\n    const { evalProps } = option;\n\n    for (const [entityName, entity] of Object.entries(dataTree)) {\n      if (!isWidget(entity)) continue;\n\n      const entityConfig = configTree[entityName] as WidgetEntityConfig;\n      const validationPathsMap = Object.entries(entityConfig.validationPaths);\n\n      for (const [propertyPath, validationConfig] of validationPathsMap) {\n        const fullPropertyPath = `${entityName}.${propertyPath}`;\n\n        const value = get(\n          unParsedEvalTree,\n          fullPropertyPath,\n          get(entity, propertyPath),\n        );\n        // Pass it through parse\n        const { isValid, messages, parsed } = validateWidgetProperty(\n          validationConfig,",
            "output_extracted": "import type {\n  DataTreeEvaluationProps,\n  EvalError as TEvalError,\n  EvaluationError,\n} from \"utils/DynamicBindingUtils\";\nimport {\n  EvalErrorTypes,\n  getDynamicBindings,\n  getEntityDynamicBindingPathList,\n  getEntityId,\n  getEntityName,\n  getEvalErrorPath,\n  getEvalValuePath,\n  isChildPropertyPath,\n  isDynamicValue,\n  isPathDynamicTrigger,\n  PropertyEvaluationErrorType,\n} from \"utils/DynamicBindingUtils\";\nimport type { WidgetTypeConfigMap } from \"WidgetProvider/factory/types\";\nimport type {\n  WidgetEntity,\n  WidgetEntityConfig,\n  ActionEntity,\n  JSActionEntityConfig,\n  PrivateWidgets,\n  ActionEntityConfig,\n  DataTreeEntityConfig,\n} from \"ee/entities/DataTree/types\";\nimport type {\n  DataTree,\n  DataTreeEntity,\n  ConfigTree,\n  UnEvalTree,\n} from \"entities/DataTree/dataTreeTypes\";\nimport { ENTITY_TYPE } from \"ee/entities/DataTree/types\";\nimport type { DataTreeDiff } from \"ee/workers/Evaluation/evaluationUtils\";\nimport {\n  convertMicroDiffToDeepDiff,\n  getAllPathsBasedOnDiffPaths,\n  isDataPath,\n  isJSModuleInstance,\n  isPropertyAnEntityAction,\n} from \"ee/workers/Evaluation/evaluationUtils\";\n\nimport {\n  addDependantsOfNestedPropertyPaths,\n  addErrorToEntityProperty,\n  convertPathToString,\n  CrashingError,\n  getEntityNameAndPropertyPath,\n  getImmediateParentsOfPropertyPaths,\n  isAction,\n  isDynamicLeaf,\n  isJSAction,\n  isWidget,\n  translateDiffEventToDataTreeDiffEvent,\n  trimDependantChangePaths,\n  overrideWidgetProperties,\n  getAllPaths,\n  isNewEntity,\n  getStaleMetaStateIds,\n  convertJSFunctionsToString,\n  DataTreeDiffEvent,\n  resetValidationErrorsForEntityProperty,\n  isAPathDynamicBindingPath,\n  isAnyJSAction,\n  isNotEntity,\n  getExternalChangedDependencies,\n} from \"ee/workers/Evaluation/evaluationUtils\";\nimport {\n  difference,\n  flatten,\n  get,\n  isArray,\n  isEmpty,\n  isEqual,\n  isFunction,\n  isObject,\n  isUndefined,\n  set,\n  unset,\n} from \"lodash\";\n\nimport type { Diff } from \"deep-diff\";\nimport { applyChange, diff } from \"deep-diff\";\nimport {\n  EXECUTION_PARAM_KEY,\n  EXECUTION_PARAM_REFERENCE_REGEX,\n  THIS_DOT_PARAMS_KEY,\n} from \"constants/AppsmithActionConstants/ActionConstants\";\nimport {\n  evaluateSync,\n  resetWorkerGlobalScope,\n  type EvalResult,\n  type EvaluateContext,\n  evaluateAsync,\n  setEvalContext,\n} from \"workers/Evaluation/evaluate\";\nimport { substituteDynamicBindingWithValues } from \"workers/Evaluation/evaluationSubstitution\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport { error as logError } from \"loglevel\";\nimport type { JSUpdate } from \"utils/JSPaneUtils\";\n\nimport type {\n  ActionValidationConfigMap,\n  ValidationConfig,\n} from \"constants/PropertyControlConstants\";\nimport { klona } from \"klona/full\";\nimport { klona as klonaJSON } from \"klona/json\";\nimport type { EvalMetaUpdates } from \"ee/workers/common/DataTreeEvaluator/types\";\nimport {\n  updateDependencyMap,\n  createDependencyMap,\n} from \"workers/common/DependencyMap\";\nimport {\n  getJSEntities,\n  getUpdatedLocalUnEvalTreeAfterJSUpdates,\n  parseJSActions,\n  updateEvalTreeWithJSCollectionState,\n} from \"workers/Evaluation/JSObject\";\nimport {\n  getFixedTimeDifference,\n  getIsNewWidgetAdded,\n  getOnlyAffectedJSObjects,\n  replaceThisDotParams,\n} from \"./utils\";\nimport { isJSObjectFunction } from \"workers/Evaluation/JSObject/utils\";\nimport {\n  validateActionProperty,\n  validateAndParseWidgetProperty,\n  validateWidgetProperty,\n} from \"./validationUtils\";\nimport { errorModifier } from \"workers/Evaluation/errorModifier\";\nimport JSObjectCollection from \"workers/Evaluation/JSObject/Collection\";\nimport userLogs from \"workers/Evaluation/fns/overrides/console\";\nimport ExecutionMetaData from \"workers/Evaluation/fns/utils/ExecutionMetaData\";\nimport DependencyMap from \"entities/DependencyMap\";\nimport { DependencyMapUtils } from \"entities/DependencyMap/DependencyMapUtils\";\nimport {\n  isWidgetActionOrJsObject,\n  isThemeUnevaluatedValue,\n} from \"ee/entities/DataTree/utils\";\nimport DataStore from \"workers/Evaluation/dataStore\";\nimport { updateTreeWithData } from \"workers/Evaluation/dataStore/utils\";\nimport microDiff from \"microdiff\";\nimport {\n  profileAsyncFn,\n  profileFn,\n} from \"instrumentation/generateWebWorkerTraces\";\nimport generateOverrideContext from \"ee/workers/Evaluation/generateOverrideContext\";\nimport appComputationCache from \"../AppComputationCache\";\nimport {\n  EComputationCacheName,\n  type ICacheProps,\n} from \"../AppComputationCache/types\";\nimport { getDataTreeContext } from \"ee/workers/Evaluation/Actions\";\nimport { WorkerEnv } from \"workers/Evaluation/handlers/workerEnv\";\nimport type { WebworkerSpanData, Attributes } from \"instrumentation/types\";\nimport type { AffectedJSObjects } from \"actions/EvaluationReduxActionTypes\";\nimport type { UpdateActionProps } from \"workers/Evaluation/handlers/types\";\nimport { EvaluationSubstitutionType } from \"constants/EvaluationConstants\";\n\ntype SortedDependencies = Array<string>;\nexport interface EvalProps {\n  [entityName: string]: DataTreeEvaluationProps;\n}\n\nexport default class DataTreeEvaluator {\n  dependencyMap: DependencyMap = new DependencyMap();\n  sortedDependencies: SortedDependencies = [];\n  dependencies: Record<string, string[]> = {};\n  inverseDependencies: Record<string, string[]> = {};\n  widgetConfigMap: WidgetTypeConfigMap = {};\n  evalTree: DataTree = {};\n  configTree: ConfigTree = {};\n\n  /**\n   * This contains raw evaluated value without any validation or parsing.\n   * This is used for revalidation as we do not store the raw validated value.\n   */\n  unParsedEvalTree: DataTree = {};\n  allKeys: Record<string, true> = {};\n  privateWidgets: PrivateWidgets = {};\n  oldUnEvalTree: UnEvalTree = {};\n  oldConfigTree: ConfigTree = {};\n  errors: TEvalError[] = [];\n  logs: unknown[] = [];\n  console = userLogs;\n  allActionValidationConfig?: {\n    [actionId: string]: ActionValidationConfigMap;\n  };\n\n  /**\n   * Sanitized eval values and errors\n   */\n  evalProps: EvalProps = {};\n  undefinedEvalValuesMap: Record<string, boolean> = {};\n\n  prevState = {};\n  // TODO: Fix this the next time the file is edited\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  setPrevState(state: any) {\n    this.prevState = state;\n  }\n  getPrevState() {\n    return this.prevState;\n  }\n  public hasCyclicalDependency = false;\n  constructor(\n    widgetConfigMap: WidgetTypeConfigMap,\n    allActionValidationConfig?: {\n      [actionId: string]: ActionValidationConfigMap;\n    },\n  ) {\n    this.allActionValidationConfig = allActionValidationConfig;\n    this.widgetConfigMap = widgetConfigMap;\n  }\n\n  getEvalTree() {\n    return this.evalTree;\n  }\n\n  getEvalProps() {\n    return this.evalProps;\n  }\n\n  setEvalTree(evalTree: DataTree) {\n    this.evalTree = evalTree;\n  }\n\n  getConfigTree() {\n    return this.configTree;\n  }\n\n  setConfigTree(configTree: ConfigTree) {\n    if (configTree) this.configTree = configTree;\n  }\n\n  getUnParsedEvalTree() {\n    return this.unParsedEvalTree;\n  }\n\n  setUnParsedEvalTree(unParsedEvalTree: DataTree) {\n    this.unParsedEvalTree = unParsedEvalTree;\n  }\n\n  getOldUnevalTree() {\n    return this.oldUnEvalTree;\n  }\n\n  setOldUnevalTree(oldUnEvalTree: UnEvalTree) {\n    this.oldUnEvalTree = oldUnEvalTree;\n  }\n  /**\n   * Method to create all data required for linting and\n   * evaluation of the first tree\n   */\n  async setupFirstTree(\n    // TODO: Fix this the next time the file is edited\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    unEvalTree: any,\n    configTree: ConfigTree,\n    webworkerTelemetry: Record<string, WebworkerSpanData | Attributes> = {},\n    cacheProps: ICacheProps,\n  ) {\n    this.setConfigTree(configTree);\n\n    const totalFirstTreeSetupStartTime = performance.now();\n    // cloneDeep will make sure not to omit key which has value as undefined.\n    const firstCloneStartTime = performance.now();\n    let localUnEvalTree = klona(unEvalTree);\n    const firstCloneEndTime = performance.now();\n\n    let jsUpdates: Record<string, JSUpdate> = {};\n    //parse js collection to get functions\n    //save current state of js collection action and variables to be added to uneval tree\n    //save functions in resolveFunctions (as functions) to be executed as functions are not allowed in evalTree\n    //and functions are saved in dataTree as strings\n    const parseJSActionsStartTime = performance.now();\n    const parsedCollections = profileFn(\n      \"SetupFirstTree.parseJSActions\",\n      undefined,\n      webworkerTelemetry,\n      () => {\n        return parseJSActions(this, localUnEvalTree);\n      },\n    );\n    const parseJSActionsEndTime = performance.now();\n\n    jsUpdates = parsedCollections.jsUpdates;\n    localUnEvalTree = getUpdatedLocalUnEvalTreeAfterJSUpdates(\n      jsUpdates,\n      localUnEvalTree,\n      configTree,\n    );\n    const localUnEvalTreeJSCollection = getJSEntities(localUnEvalTree);\n    const stringifiedLocalUnEvalTreeJSCollection = convertJSFunctionsToString(\n      localUnEvalTreeJSCollection,\n      configTree,\n    );\n    const unEvalTreeWithStrigifiedJSFunctions = Object.assign(\n      {},\n      localUnEvalTree,\n      stringifiedLocalUnEvalTreeJSCollection,\n    );\n    const allKeysGenerationStartTime = performance.now();\n\n    try {\n      this.allKeys = await appComputationCache.fetchOrCompute({\n        cacheProps,\n        cacheName: EComputationCacheName.ALL_KEYS,\n        computeFn: () => getAllPaths(unEvalTreeWithStrigifiedJSFunctions),\n      });\n    } catch (error) {\n      this.errors.push({\n        type: EvalErrorTypes.CACHE_ERROR,\n        message: (error as Error).message,\n        stack: (error as Error).stack,\n      });\n\n      this.allKeys = getAllPaths(unEvalTreeWithStrigifiedJSFunctions);\n    }\n\n    const allKeysGenerationEndTime = performance.now();\n\n    const createDependencyMapStartTime = performance.now();\n\n    const { dependencies, inverseDependencies } = await profileAsyncFn(\n      \"createDependencyMap\",\n      async () =>\n        createDependencyMap(\n          this,\n          localUnEvalTree,\n          configTree,\n          cacheProps,\n          webworkerTelemetry,\n        ),\n      webworkerTelemetry,\n    );\n\n    const createDependencyMapEndTime = performance.now();\n\n    this.dependencies = dependencies;\n    this.inverseDependencies = inverseDependencies;\n\n    const sortDependenciesStartTime = performance.now();\n\n    this.sortedDependencies = this.sortDependencies(\n      this.dependencyMap,\n      [],\n      configTree,\n    );\n    const sortDependenciesEndTime = performance.now();\n\n    const secondCloneStartTime = performance.now();\n\n    this.oldUnEvalTree = klona(localUnEvalTree);\n    this.oldConfigTree = configTree;\n    const secondCloneEndTime = performance.now();\n\n    const totalFirstTreeSetupEndTime = performance.now();\n\n    const timeTakenForSetupFirstTree = {\n      total: getFixedTimeDifference(\n        totalFirstTreeSetupEndTime,\n        totalFirstTreeSetupStartTime,\n      ),\n      clone: getFixedTimeDifference(\n        firstCloneEndTime + secondCloneEndTime,\n        firstCloneStartTime + secondCloneStartTime,\n      ),\n      allKeys: getFixedTimeDifference(\n        allKeysGenerationEndTime,\n        allKeysGenerationStartTime,\n      ),\n      createDependencyMap: getFixedTimeDifference(\n        createDependencyMapEndTime,\n        createDependencyMapStartTime,\n      ),\n      sortDependencies: getFixedTimeDifference(\n        sortDependenciesEndTime,\n        sortDependenciesStartTime,\n      ),\n      parseJSActions: getFixedTimeDifference(\n        parseJSActionsEndTime,\n        parseJSActionsStartTime,\n      ),\n    };\n\n    this.logs.push({\n      timeTakenForSetupFirstTree,\n      dependencies: this.dependencies,\n      inverseDependencies: this.inverseDependencies,\n    });\n\n    return {\n      jsUpdates,\n      evalOrder: this.sortedDependencies,\n    };\n  }\n\n  /**\n   * Mutates the dataTree.\n   * Validates all the nodes of the tree to make sure all the values are as expected according to the validation config\n   *\n   * For example :- If Button.isDisabled is set to false in propertyPane then it would be passed as \"false\" in unEvalTree and validateTree method makes sure to convert it to boolean.\n   * @param tree\n   * @param option\n   * @param configTree\n   * @returns\n   */\n  validatedTree(\n    dataTree: DataTree,\n    option: {\n      evalProps: EvalProps;\n    },\n    configTree: ConfigTree,\n  ) {\n    const unParsedEvalTree = this.getUnParsedEvalTree();\n    const { evalProps } = option;\n\n    for (const [entityName, entity] of Object.entries(dataTree)) {\n      if (!isWidget(entity)) continue;\n\n      const entityConfig = configTree[entityName] as WidgetEntityConfig;\n      const validationPathsMap = Object.entries(entityConfig.validationPaths);\n\n      for (const [propertyPath, validationConfig] of validationPathsMap) {\n        const fullPropertyPath = `${entityName}.${propertyPath}`;\n\n        const value = get(\n          unParsedEvalTree,\n          fullPropertyPath,\n          get(entity, propertyPath),\n        );\n        // Pass it through parse\n        const { isValid, messages, parsed } = validateWidgetProperty(\n          validationConfig,",
            "cost": 0.202625
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "appsmithorg__appsmith.main.41089",
        "repo": "appsmithorg/appsmith",
        "base_commit": "2af8ef31f46dd1d0b1d1d9c4c2fe3b0d8ef04912",
        "head_commit": "ac67b382f16ad4d8223caed946a8122d761e6739",
        "title": "chore: remove redundant klona used by the reactive action flow",
        "merged_at": "2025-07-07T12:00:55Z",
        "html_url": "https://github.com/appsmithorg/appsmith/pull/41089",
        "test_files": [
            "app/client/src/workers/Evaluation/__tests__/evaluation.test.ts",
            "app/client/src/workers/Evaluation/evalTreeWithChanges.test.ts",
            "app/client/src/workers/common/DataTreeEvaluator/dataTreeEvaluator.test.ts"
        ],
        "code_files": [
            "app/client/src/workers/Evaluation/evalTreeWithChanges.ts",
            "app/client/src/workers/Evaluation/handlers/evalTree.ts",
            "app/client/src/workers/Evaluation/handlers/evalTrigger.ts",
            "app/client/src/workers/common/DataTreeEvaluator/index.ts"
        ],
        "total_changes": 54,
        "num_files": 7,
        "pull_number": 41089,
        "patch": "diff --git a/app/client/src/workers/Evaluation/__tests__/evaluation.test.ts b/app/client/src/workers/Evaluation/__tests__/evaluation.test.ts\nindex bde5259b878..c6d2e3e52e4 100644\n--- a/app/client/src/workers/Evaluation/__tests__/evaluation.test.ts\n+++ b/app/client/src/workers/Evaluation/__tests__/evaluation.test.ts\n@@ -634,7 +634,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree,\n       unEvalUpdates,\n       [],\n-      evaluator.evalTree,\n     );\n     const dataTree = evaluator.evalTree;\n \n@@ -674,7 +673,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree,\n       unEvalUpdates,\n       [],\n-      evaluator.evalTree,\n     );\n \n     const dataTree = evaluator.evalTree;\n@@ -722,7 +720,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree,\n       unEvalUpdates,\n       [],\n-      evaluator.evalTree,\n     );\n     const dataTree = evaluator.evalTree;\n \n@@ -787,7 +784,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree,\n       unEvalUpdates,\n       [],\n-      evaluator.evalTree,\n     );\n     const dataTree = evaluator.evalTree;\n     const updatedDependencies = evaluator.dependencies;\n@@ -832,7 +828,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree,\n       unEvalUpdates,\n       [],\n-      evaluator.evalTree,\n     );\n     const dataTree = evaluator.evalTree;\n     const updatedDependencies = evaluator.dependencies;\n@@ -898,7 +893,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree,\n       unEvalUpdates,\n       [],\n-      evaluator.evalTree,\n     );\n     const dataTree = evaluator.evalTree;\n     const updatedDependencies = evaluator.dependencies;\n@@ -971,7 +965,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree1,\n       unEvalUpdates,\n       [],\n-      evaluator.evalTree,\n     );\n     expect(evaluator.dependencies[\"Api2.config.body\"]).toStrictEqual([\n       \"Api2.config.pluginSpecifiedTemplates[0].value\",\n@@ -1007,7 +1000,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree2,\n       unEvalUpdates2,\n       [],\n-      evaluator.evalTree,\n     );\n     const dataTree = evaluator.evalTree;\n \n@@ -1050,7 +1042,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree3,\n       unEvalUpdates3,\n       [],\n-      evaluator.evalTree,\n     );\n     const dataTree3 = evaluator.evalTree;\n \n@@ -1094,7 +1085,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree,\n       unEvalUpdates,\n       [],\n-      evaluator.evalTree,\n     );\n     const dataTree = evaluator.evalTree;\n \n@@ -1135,7 +1125,6 @@ describe(\"DataTreeEvaluator\", () => {\n       updatedConfigTree,\n       unEvalUpdates,\n       [],\n-      evaluator.evalTree,\n     );\n     // Hard check to not regress on the number of clone operations. Try to improve this number.\n     // Not a good assertion because in one piece of code im cloning multiple times, however the value im cloning is very small.\ndiff --git a/app/client/src/workers/Evaluation/evalTreeWithChanges.test.ts b/app/client/src/workers/Evaluation/evalTreeWithChanges.test.ts\nindex 791e64071b2..ceff6ba2630 100644\n--- a/app/client/src/workers/Evaluation/evalTreeWithChanges.test.ts\n+++ b/app/client/src/workers/Evaluation/evalTreeWithChanges.test.ts\n@@ -130,7 +130,6 @@ describe(\"evaluateAndPushResponse\", () => {\n       },\n       [],\n       [],\n-      {},\n     );\n     // check if push response has been called\n     expect(pushResponseToMainThreadMock).toHaveBeenCalled();\n@@ -226,7 +225,6 @@ describe(\"evaluateAndGenerateResponse\", () => {\n       },\n       [],\n       [],\n-      {},\n     );\n     const parsedUpdates = getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n \n@@ -261,7 +259,6 @@ describe(\"evaluateAndGenerateResponse\", () => {\n       },\n       [],\n       [],\n-      {},\n     );\n     const parsedUpdates = getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n \n@@ -301,7 +298,6 @@ describe(\"evaluateAndGenerateResponse\", () => {\n         updateTreeResponse,\n         [],\n         [],\n-        {},\n       );\n \n       expect(webworkerResponse.workerResponse.dependencies).toEqual({\n@@ -342,7 +338,6 @@ describe(\"evaluateAndGenerateResponse\", () => {\n         updateTreeResponse,\n         [],\n         [],\n-        {},\n       );\n       const parsedUpdates =\n         getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n@@ -376,7 +371,6 @@ describe(\"evaluateAndGenerateResponse\", () => {\n         updateTreeResponse,\n         [],\n         [],\n-        {},\n       );\n \n       const parsedUpdates =\n@@ -420,7 +414,6 @@ describe(\"evaluateAndGenerateResponse\", () => {\n         updateTreeResponse,\n         [],\n         [\"Text1.text\"],\n-        {},\n       );\n       const parsedUpdates =\n         getParsedUpdatesFromWebWorkerResp(webworkerResponse);\n@@ -466,7 +459,6 @@ describe(\"evaluateAndGenerateResponse\", () => {\n           response,\n           metaUpdates,\n           [],\n-          {},\n         );\n \n       expect(workerResponse.evalMetaUpdates).toEqual(metaUpdates);\n@@ -497,7 +489,6 @@ describe(\"evaluateAndGenerateResponse\", () => {\n           response,\n           metaUpdates,\n           [],\n-          {},\n         );\n \n       // the function properties should be stripped out\n@@ -529,7 +520,6 @@ describe(\"evaluateAndGenerateResponse\", () => {\n         updateTreeResponse,\n         [],\n         [],\n-        {},\n       );\n \n       const parsedUpdates =\n@@ -568,7 +558,6 @@ describe(\"evaluateAndGenerateResponse\", () => {\n         updateTreeResponse,\n         [],\n         [],\n-        {},\n       );\n       const parsedUpdates =\n         getParsedUpdatesFromWebWorkerResp(webworkerResponse);\ndiff --git a/app/client/src/workers/Evaluation/evalTreeWithChanges.ts b/app/client/src/workers/Evaluation/evalTreeWithChanges.ts\nindex f0a0a562612..e3feaebe177 100644\n--- a/app/client/src/workers/Evaluation/evalTreeWithChanges.ts\n+++ b/app/client/src/workers/Evaluation/evalTreeWithChanges.ts\n@@ -21,7 +21,6 @@ import {\n import type DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\n import type { Diff } from \"deep-diff\";\n import type { DataTree } from \"entities/DataTree/dataTreeTypes\";\n-import { klona as klonaJson } from \"klona/json\";\n \n const getDefaultEvalResponse = (): EvalTreeResponseData => ({\n   updates: \"[]\",\n@@ -71,10 +70,8 @@ export function evalTreeWithChanges(\n   );\n \n   let setupUpdateTreeResponse = {} as UpdateTreeResponse;\n-  let oldEvalTree: DataTree = {};\n \n   if (dataTreeEvaluator) {\n-    oldEvalTree = klonaJson(dataTreeEvaluator.getEvalTree());\n     setupUpdateTreeResponse = dataTreeEvaluator.setupUpdateTreeWithDifferences(\n       updatedValuePaths,\n       pathsToSkipFromEval,\n@@ -86,7 +83,6 @@ export function evalTreeWithChanges(\n     setupUpdateTreeResponse,\n     metaUpdates,\n     pathsToSkipFromEval,\n-    oldEvalTree,\n   );\n }\n \n@@ -107,14 +103,12 @@ export const evaluateAndPushResponse = (\n   setupUpdateTreeResponse: UpdateTreeResponse,\n   metaUpdates: EvalMetaUpdates,\n   additionalPathsAddedAsUpdates: string[],\n-  oldEvalTree: DataTree,\n ) => {\n   const response = evaluateAndGenerateResponse(\n     dataTreeEvaluator,\n     setupUpdateTreeResponse,\n     metaUpdates,\n     additionalPathsAddedAsUpdates,\n-    oldEvalTree,\n   );\n \n   return pushResponseToMainThread(response);\n@@ -125,7 +119,6 @@ export const evaluateAndGenerateResponse = (\n   setupUpdateTreeResponse: UpdateTreeResponse,\n   metaUpdates: EvalMetaUpdates,\n   additionalPathsAddedAsUpdates: string[],\n-  oldEvalTree: DataTree,\n ): UpdateDataTreeMessageData => {\n   // generate default response first and later add updates to it\n   const defaultResponse = getDefaultEvalResponse();\n@@ -158,7 +151,6 @@ export const evaluateAndGenerateResponse = (\n     dataTreeEvaluator.oldConfigTree,\n     unEvalUpdates,\n     [],\n-    oldEvalTree,\n   );\n \n   const dataTree = updateEvalProps(dataTreeEvaluator) || {};\ndiff --git a/app/client/src/workers/Evaluation/handlers/evalTree.ts b/app/client/src/workers/Evaluation/handlers/evalTree.ts\nindex 1d12dde5887..a26c7c50be4 100644\n--- a/app/client/src/workers/Evaluation/handlers/evalTree.ts\n+++ b/app/client/src/workers/Evaluation/handlers/evalTree.ts\n@@ -33,7 +33,6 @@ import type { CanvasWidgetsReduxState } from \"ee/reducers/entityReducers/canvasW\n import type { MetaWidgetsReduxState } from \"reducers/entityReducers/metaWidgetsReducer\";\n import type { Attributes } from \"instrumentation/types\";\n import { updateActionsToEvalTree } from \"./updateActionData\";\n-import { klona as klonaJSON } from \"klona/json\";\n \n // TODO: Fix this the next time the file is edited\n // eslint-disable-next-line @typescript-eslint/no-explicit-any\n@@ -194,7 +193,6 @@ export async function evalTree(\n       isNewTree = true;\n     } else {\n       const tree = dataTreeEvaluator.getEvalTree();\n-      const oldDataTree = klonaJSON(tree);\n \n       // during update cycles update actions to the dataTree directly\n       // this is useful in cases where we have debounced updateActionData and a regular evaluation\n@@ -243,7 +241,6 @@ export async function evalTree(\n             configTree,\n             unEvalUpdates,\n             Object.keys(metaWidgets),\n-            oldDataTree,\n           ),\n       );\n \ndiff --git a/app/client/src/workers/Evaluation/handlers/evalTrigger.ts b/app/client/src/workers/Evaluation/handlers/evalTrigger.ts\nindex 4da86703b39..992730da7b5 100644\n--- a/app/client/src/workers/Evaluation/handlers/evalTrigger.ts\n+++ b/app/client/src/workers/Evaluation/handlers/evalTrigger.ts\n@@ -2,7 +2,6 @@ import { dataTreeEvaluator } from \"./evalTree\";\n import type { EvalWorkerASyncRequest } from \"../types\";\n import ExecutionMetaData from \"../fns/utils/ExecutionMetaData\";\n import { evaluateAndPushResponse } from \"../evalTreeWithChanges\";\n-import { klona as klonaJson } from \"klona/json\";\n \n export default async function (request: EvalWorkerASyncRequest) {\n   const { data } = request;\n@@ -21,8 +20,6 @@ export default async function (request: EvalWorkerASyncRequest) {\n \n   ExecutionMetaData.setExecutionMetaData({ triggerMeta, eventType });\n \n-  const oldEvalTree = klonaJson(dataTreeEvaluator.getEvalTree());\n-\n   if (!triggerMeta.onPageLoad) {\n     const { evalOrder, unEvalUpdates } = dataTreeEvaluator.setupUpdateTree(\n       unEvalTree.unEvalTree,\n@@ -37,7 +34,6 @@ export default async function (request: EvalWorkerASyncRequest) {\n       { evalOrder, unEvalUpdates, jsUpdates: {} },\n       [],\n       [],\n-      oldEvalTree,\n     );\n   }\n \ndiff --git a/app/client/src/workers/common/DataTreeEvaluator/dataTreeEvaluator.test.ts b/app/client/src/workers/common/DataTreeEvaluator/dataTreeEvaluator.test.ts\nindex e0ad57986d3..f370792e0d1 100644\n--- a/app/client/src/workers/common/DataTreeEvaluator/dataTreeEvaluator.test.ts\n+++ b/app/client/src/workers/common/DataTreeEvaluator/dataTreeEvaluator.test.ts\n@@ -305,7 +305,6 @@ describe(\"DataTreeEvaluator\", () => {\n         configTree as unknown as ConfigTree,\n         unEvalUpdates,\n         [],\n-        dataTreeEvaluator.evalTree,\n       );\n \n       expect(dataTreeEvaluator.dependencies).toStrictEqual({\n@@ -478,7 +477,6 @@ describe(\"DataTreeEvaluator\", () => {\n             arrayAccessorCyclicDependencyConfig.apiSuccessConfigTree,\n             unEvalUpdates,\n             [],\n-            dataTreeEvaluator.evalTree,\n           );\n           expect(dataTreeEvaluator.dependencies[\"Api1\"]).toStrictEqual(\n             undefined,\n@@ -503,7 +501,6 @@ describe(\"DataTreeEvaluator\", () => {\n             arrayAccessorCyclicDependencyConfig.apiFailureConfigTree,\n             unEvalUpdates2,\n             [],\n-            dataTreeEvaluator.evalTree,\n           );\n \n           expect(dataTreeEvaluator.dependencies[\"Api1\"]).toStrictEqual(\n@@ -533,7 +530,6 @@ describe(\"DataTreeEvaluator\", () => {\n           arrayAccessorCyclicDependencyConfig.apiSuccessConfigTree,\n           unEvalUpdates,\n           [],\n-          dataTreeEvaluator.evalTree,\n         );\n \n         // success: response -> [{...}, {...}]\n@@ -548,7 +544,6 @@ describe(\"DataTreeEvaluator\", () => {\n           arrayAccessorCyclicDependencyConfig.apiSuccessConfigTree2,\n           unEvalUpdates2,\n           [],\n-          dataTreeEvaluator.evalTree,\n         );\n \n         expect(dataTreeEvaluator.dependencies[\"Api1\"]).toStrictEqual(undefined);\n@@ -577,7 +572,6 @@ describe(\"DataTreeEvaluator\", () => {\n             nestedArrayAccessorCyclicDependencyConfig.apiSuccessConfigTree,\n             unEvalUpdates,\n             [],\n-            dataTreeEvaluator.evalTree,\n           );\n           expect(dataTreeEvaluator.dependencies[\"Api1\"]).toStrictEqual(\n             undefined,\n@@ -605,7 +599,6 @@ describe(\"DataTreeEvaluator\", () => {\n             nestedArrayAccessorCyclicDependencyConfig.apiFailureConfigTree,\n             unEvalUpdates2,\n             [],\n-            dataTreeEvaluator.evalTree,\n           );\n           expect(dataTreeEvaluator.dependencies[\"Api1\"]).toStrictEqual(\n             undefined,\n@@ -637,7 +630,6 @@ describe(\"DataTreeEvaluator\", () => {\n           nestedArrayAccessorCyclicDependencyConfig.apiSuccessConfigTree,\n           unEvalUpdates,\n           [],\n-          dataTreeEvaluator.evalTree,\n         );\n \n         // success: response -> [ [{...}, {...}, {...}], [{...}, {...}, {...}] ]\n@@ -652,7 +644,6 @@ describe(\"DataTreeEvaluator\", () => {\n           nestedArrayAccessorCyclicDependencyConfig.apiSuccessConfigTree2,\n           unEvalUpdates2,\n           [],\n-          dataTreeEvaluator.evalTree,\n         );\n \n         expect(dataTreeEvaluator.dependencies[\"Api1\"]).toStrictEqual(undefined);\n@@ -680,7 +671,6 @@ describe(\"DataTreeEvaluator\", () => {\n           nestedArrayAccessorCyclicDependencyConfig.apiSuccessConfigTree,\n           unEvalUpdates,\n           [],\n-          dataTreeEvaluator.evalTree,\n         );\n \n         // success: response -> [ [{...}, {...}, {...}], [{...}, {...}, {...}], [] ]\n@@ -695,7 +685,6 @@ describe(\"DataTreeEvaluator\", () => {\n           nestedArrayAccessorCyclicDependencyConfig.apiSuccessConfigTree3,\n           unEvalUpdates2,\n           [],\n-          dataTreeEvaluator.evalTree,\n         );\n         expect(dataTreeEvaluator.dependencies[\"Api1\"]).toStrictEqual(undefined);\n         expect(dataTreeEvaluator.dependencies[\"Api1.data\"]).toStrictEqual([]);\ndiff --git a/app/client/src/workers/common/DataTreeEvaluator/index.ts b/app/client/src/workers/common/DataTreeEvaluator/index.ts\nindex 1df173ef3ad..4ea4f13b4bf 100644\n--- a/app/client/src/workers/common/DataTreeEvaluator/index.ts\n+++ b/app/client/src/workers/common/DataTreeEvaluator/index.ts\n@@ -490,7 +490,6 @@ export default class DataTreeEvaluator {\n       evaluationOrder,\n       undefined,\n       this.oldConfigTree,\n-      {},\n     );\n \n     /**\n@@ -960,7 +959,6 @@ export default class DataTreeEvaluator {\n     configTree: ConfigTree,\n     unevalUpdates: DataTreeDiff[],\n     metaWidgetIds: string[] = [],\n-    oldEvalTree: DataTree,\n   ): {\n     evalMetaUpdates: EvalMetaUpdates;\n     staleMetaIds: string[];\n@@ -984,7 +982,6 @@ export default class DataTreeEvaluator {\n         metaWidgets: metaWidgetIds,\n       },\n       configTree,\n-      oldEvalTree,\n     );\n     const evaluationEndTime = performance.now();\n \n@@ -1127,7 +1124,6 @@ export default class DataTreeEvaluator {\n       metaWidgets: [],\n     },\n     oldConfigTree: ConfigTree,\n-    oldEvalTree: DataTree,\n   ): {\n     evaluatedTree: DataTree;\n     evalMetaUpdates: EvalMetaUpdates;\n@@ -1323,7 +1319,7 @@ export default class DataTreeEvaluator {\n         if (!propertyPath) continue;\n \n         // Get old value from oldEvalTree for comparison\n-        const oldValue = get(oldEvalTree, fullPropertyPath);\n+        const oldValue = get(this.getPrevState(), fullPropertyPath);\n \n         switch (entityType) {\n           case ENTITY_TYPE.WIDGET: {\n",
        "pr_mirror": "appsmithorg__appsmith.7046aeb3"
    }
}