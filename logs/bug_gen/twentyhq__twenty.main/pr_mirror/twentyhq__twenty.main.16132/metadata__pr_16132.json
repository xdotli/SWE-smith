{
    "cost": 0.566715,
    "rewrites": {
        "twentyhq__twenty.main/packages/twenty-server/src/engine/api/common/common-result-getters/common-result-getters.service.ts": {
            "output": "import { Injectable, Logger } from '@nestjs/common';\n\nimport {\n  FieldMetadataType,\n  ObjectRecord,\n  RelationType,\n} from 'twenty-shared/types';\nimport { isDefined } from 'twenty-shared/utils';\n\nimport { type QueryResultFieldValue } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/interfaces/query-result-field-value';\nimport { type QueryResultGetterHandlerInterface } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/interfaces/query-result-getter-handler.interface';\n\nimport { ActivityQueryResultGetterHandler } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/handlers/activity-query-result-getter.handler';\nimport { AttachmentQueryResultGetterHandler } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/handlers/attachment-query-result-getter.handler';\nimport { PersonQueryResultGetterHandler } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/handlers/person-query-result-getter.handler';\nimport { WorkspaceMemberQueryResultGetterHandler } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/handlers/workspace-member-query-result-getter.handler';\nimport { FileService } from 'src/engine/core-modules/file/services/file.service';\nimport { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { findFlatEntityByIdInFlatEntityMapsOrThrow } from 'src/engine/metadata-modules/flat-entity/utils/find-flat-entity-by-id-in-flat-entity-maps-or-throw.util';\nimport { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\nimport { isFlatFieldMetadataOfType } from 'src/engine/metadata-modules/flat-field-metadata/utils/is-flat-field-metadata-of-type.util';\nimport { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\n\n// TODO: find a way to prevent conflict between handlers executing logic on object relations\n// And this factory that is also executing logic on object relations\n// Right now the factory will override any change made on relations by the handlers\n@Injectable()\nexport class CommonResultGettersService {\n  private readonly logger = new Logger(CommonResultGettersService.name);\n  private handlers: Map<string, QueryResultGetterHandlerInterface>;\n\n  constructor(private readonly fileService: FileService) {\n    this.initializeHandlers();\n  }\n\n  private initializeHandlers() {\n    this.handlers = new Map<string, QueryResultGetterHandlerInterface>([\n      ['attachment', new AttachmentQueryResultGetterHandler(this.fileService)],\n      ['person', new PersonQueryResultGetterHandler(this.fileService)],\n      [\n        'workspaceMember',\n        new WorkspaceMemberQueryResultGetterHandler(this.fileService),\n      ],\n      ['note', new ActivityQueryResultGetterHandler(this.fileService)],\n      ['task', new ActivityQueryResultGetterHandler(this.fileService)],\n    ]);\n  }\n\n  public async processRecordArray(\n    recordArray: ObjectRecord[],\n    flatObjectMetadata: FlatObjectMetadata,\n    flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n    flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n    workspaceId: string,\n  ) {\n    return await Promise.all(\n      recordArray.map(\n        async (record: ObjectRecord) =>\n          await this.processRecord(\n            record,\n            flatObjectMetadata,\n            flatObjectMetadataMaps,\n            flatFieldMetadataMaps,\n            workspaceId,\n          ),\n      ),\n    );\n  }\n\n  public async processRecord(\n    record: ObjectRecord,\n    flatObjectMetadata: FlatObjectMetadata,\n    flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n    flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n    workspaceId: string,\n  ): Promise<ObjectRecord> {\n    const handler = this.getHandler(flatObjectMetadata.nameSingular);\n\n    const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n      flatFieldMetadataMaps,\n      flatObjectMetadata,\n    );\n\n    const relationFields = Object.keys(record)\n      .map(\n        (recordFieldName) =>\n          flatFieldMetadataMaps.byId[fieldIdByName[recordFieldName]],\n      )\n      .filter(isDefined)\n      .filter((fieldMetadata) =>\n        isFlatFieldMetadataOfType(fieldMetadata, FieldMetadataType.RELATION),\n      );\n\n    const relationFieldsProcessedMap = {} as Record<\n      string,\n      QueryResultFieldValue\n    >;\n\n    for (const relationField of relationFields) {\n      if (!isDefined(relationField.relationTargetObjectMetadataId)) {\n        throw new Error('Relation target object metadata id is not defined');\n      }\n\n      const recordFieldValue = record[relationField.name];\n\n      if (!isDefined(recordFieldValue)) {\n        continue;\n      }\n\n      const targetFlatObjectMetadata =\n        findFlatEntityByIdInFlatEntityMapsOrThrow({\n          flatEntityId: relationField.relationTargetObjectMetadataId,\n          flatEntityMaps: flatObjectMetadataMaps,\n        });\n\n      relationFieldsProcessedMap[relationField.name] =\n        relationField.settings?.relationType === RelationType.ONE_TO_MANY\n          ? await this.processRecordArray(\n              record[relationField.name],\n              targetFlatObjectMetadata,\n              flatObjectMetadataMaps,\n              flatFieldMetadataMaps,\n              workspaceId,\n            )\n          : await this.processRecord(\n              record[relationField.name],\n              targetFlatObjectMetadata,\n              flatObjectMetadataMaps,\n              flatFieldMetadataMaps,\n              workspaceId,\n            );\n    }\n\n    const objectRecordProcessedWithoutRelationFields = await handler.handle(\n      record,\n      workspaceId,\n    );\n\n    const processedRecord = {\n      ...objectRecordProcessedWithoutRelationFields,\n      ...relationFieldsProcessedMap,\n    };\n\n    return processedRecord;\n  }\n\n  private getHandler(objectType: string): QueryResultGetterHandlerInterface {\n    return (\n      this.handlers.get(objectType) || {\n        handle: (result: ObjectRecord): Promise<ObjectRecord> =>\n          Promise.resolve(result),\n      }\n    );\n  }\n}",
            "output_extracted": "import { Injectable, Logger } from '@nestjs/common';\n\nimport {\n  FieldMetadataType,\n  ObjectRecord,\n  RelationType,\n} from 'twenty-shared/types';\nimport { isDefined } from 'twenty-shared/utils';\n\nimport { type QueryResultFieldValue } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/interfaces/query-result-field-value';\nimport { type QueryResultGetterHandlerInterface } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/interfaces/query-result-getter-handler.interface';\n\nimport { ActivityQueryResultGetterHandler } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/handlers/activity-query-result-getter.handler';\nimport { AttachmentQueryResultGetterHandler } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/handlers/attachment-query-result-getter.handler';\nimport { PersonQueryResultGetterHandler } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/handlers/person-query-result-getter.handler';\nimport { WorkspaceMemberQueryResultGetterHandler } from 'src/engine/api/graphql/workspace-query-runner/factories/query-result-getters/handlers/workspace-member-query-result-getter.handler';\nimport { FileService } from 'src/engine/core-modules/file/services/file.service';\nimport { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { findFlatEntityByIdInFlatEntityMapsOrThrow } from 'src/engine/metadata-modules/flat-entity/utils/find-flat-entity-by-id-in-flat-entity-maps-or-throw.util';\nimport { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\nimport { isFlatFieldMetadataOfType } from 'src/engine/metadata-modules/flat-field-metadata/utils/is-flat-field-metadata-of-type.util';\nimport { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\n\n// TODO: find a way to prevent conflict between handlers executing logic on object relations\n// And this factory that is also executing logic on object relations\n// Right now the factory will override any change made on relations by the handlers\n@Injectable()\nexport class CommonResultGettersService {\n  private readonly logger = new Logger(CommonResultGettersService.name);\n  private handlers: Map<string, QueryResultGetterHandlerInterface>;\n\n  constructor(private readonly fileService: FileService) {\n    this.initializeHandlers();\n  }\n\n  private initializeHandlers() {\n    this.handlers = new Map<string, QueryResultGetterHandlerInterface>([\n      ['attachment', new AttachmentQueryResultGetterHandler(this.fileService)],\n      ['person', new PersonQueryResultGetterHandler(this.fileService)],\n      [\n        'workspaceMember',\n        new WorkspaceMemberQueryResultGetterHandler(this.fileService),\n      ],\n      ['note', new ActivityQueryResultGetterHandler(this.fileService)],\n      ['task', new ActivityQueryResultGetterHandler(this.fileService)],\n    ]);\n  }\n\n  public async processRecordArray(\n    recordArray: ObjectRecord[],\n    flatObjectMetadata: FlatObjectMetadata,\n    flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n    flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n    workspaceId: string,\n  ) {\n    return await Promise.all(\n      recordArray.map(\n        async (record: ObjectRecord) =>\n          await this.processRecord(\n            record,\n            flatObjectMetadata,\n            flatObjectMetadataMaps,\n            flatFieldMetadataMaps,\n            workspaceId,\n          ),\n      ),\n    );\n  }\n\n  public async processRecord(\n    record: ObjectRecord,\n    flatObjectMetadata: FlatObjectMetadata,\n    flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n    flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n    workspaceId: string,\n  ): Promise<ObjectRecord> {\n    const handler = this.getHandler(flatObjectMetadata.nameSingular);\n\n    const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n      flatFieldMetadataMaps,\n      flatObjectMetadata,\n    );\n\n    const relationFields = Object.keys(record)\n      .map(\n        (recordFieldName) =>\n          flatFieldMetadataMaps.byId[fieldIdByName[recordFieldName]],\n      )\n      .filter(isDefined)\n      .filter((fieldMetadata) =>\n        isFlatFieldMetadataOfType(fieldMetadata, FieldMetadataType.RELATION),\n      );\n\n    const relationFieldsProcessedMap = {} as Record<\n      string,\n      QueryResultFieldValue\n    >;\n\n    for (const relationField of relationFields) {\n      if (!isDefined(relationField.relationTargetObjectMetadataId)) {\n        throw new Error('Relation target object metadata id is not defined');\n      }\n\n      const recordFieldValue = record[relationField.name];\n\n      if (!isDefined(recordFieldValue)) {\n        continue;\n      }\n\n      const targetFlatObjectMetadata =\n        findFlatEntityByIdInFlatEntityMapsOrThrow({\n          flatEntityId: relationField.relationTargetObjectMetadataId,\n          flatEntityMaps: flatObjectMetadataMaps,\n        });\n\n      relationFieldsProcessedMap[relationField.name] =\n        relationField.settings?.relationType === RelationType.ONE_TO_MANY\n          ? await this.processRecordArray(\n              record[relationField.name],\n              targetFlatObjectMetadata,\n              flatObjectMetadataMaps,\n              flatFieldMetadataMaps,\n              workspaceId,\n            )\n          : await this.processRecord(\n              record[relationField.name],\n              targetFlatObjectMetadata,\n              flatObjectMetadataMaps,\n              flatFieldMetadataMaps,\n              workspaceId,\n            );\n    }\n\n    const objectRecordProcessedWithoutRelationFields = await handler.handle(\n      record,\n      workspaceId,\n    );\n\n    const processedRecord = {\n      ...objectRecordProcessedWithoutRelationFields,\n      ...relationFieldsProcessedMap,\n    };\n\n    return processedRecord;\n  }\n\n  private getHandler(objectType: string): QueryResultGetterHandlerInterface {\n    return (\n      this.handlers.get(objectType) || {\n        handle: (result: ObjectRecord): Promise<ObjectRecord> =>\n          Promise.resolve(result),\n      }\n    );\n  }\n}",
            "cost": 0.06347
        },
        "twentyhq__twenty.main/packages/twenty-server/src/engine/api/graphql/graphql-query-runner/helpers/process-nested-relations-v2.helper.ts": {
            "output": "import { Injectable } from '@nestjs/common';\n\nimport { FieldMetadataType, type ObjectRecord } from 'twenty-shared/types';\nimport { type FindOptionsRelations, type ObjectLiteral } from 'typeorm';\n\nimport { RelationType } from 'src/engine/metadata-modules/field-metadata/interfaces/relation-type.interface';\n\nimport {\n  GraphqlQueryRunnerException,\n  GraphqlQueryRunnerExceptionCode,\n} from 'src/engine/api/graphql/graphql-query-runner/errors/graphql-query-runner.exception';\nimport { ProcessAggregateHelper } from 'src/engine/api/graphql/graphql-query-runner/helpers/process-aggregate.helper';\nimport { buildColumnsToSelect } from 'src/engine/api/graphql/graphql-query-runner/utils/build-columns-to-select';\nimport { getTargetObjectMetadataOrThrow } from 'src/engine/api/graphql/graphql-query-runner/utils/get-target-object-metadata.util';\nimport { type AggregationField } from 'src/engine/api/graphql/workspace-schema-builder/utils/get-available-aggregations-from-object-fields.util';\nimport { type AuthContext } from 'src/engine/core-modules/auth/types/auth-context.type';\nimport { FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { findFlatEntityByIdInFlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/utils/find-flat-entity-by-id-in-flat-entity-maps.util';\nimport { FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\nimport { FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\nimport { type WorkspaceDataSource } from 'src/engine/twenty-orm/datasource/workspace.datasource';\nimport { type WorkspaceSelectQueryBuilder } from 'src/engine/twenty-orm/repository/workspace-select-query-builder';\nimport { type RolePermissionConfig } from 'src/engine/twenty-orm/types/role-permission-config';\nimport { isFieldMetadataEntityOfType } from 'src/engine/utils/is-field-metadata-of-type.util';\n\n@Injectable()\nexport class ProcessNestedRelationsV2Helper {\n  constructor() {}\n\n  public async processNestedRelations<T extends ObjectRecord = ObjectRecord>({\n    flatObjectMetadataMaps,\n    flatFieldMetadataMaps,\n    parentObjectMetadataItem,\n    parentObjectRecords,\n    parentObjectRecordsAggregatedValues = {},\n    relations,\n    aggregate = {},\n    limit,\n    authContext,\n    workspaceDataSource,\n    rolePermissionConfig,\n    selectedFields,\n  }: {\n    flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>;\n    flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>;\n    parentObjectMetadataItem: FlatObjectMetadata;\n    parentObjectRecords: T[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parentObjectRecordsAggregatedValues?: Record<string, any>;\n    relations: Record<string, FindOptionsRelations<ObjectLiteral>>;\n    aggregate?: Record<string, AggregationField>;\n    limit: number;\n    authContext: AuthContext;\n    workspaceDataSource: WorkspaceDataSource;\n    rolePermissionConfig?: RolePermissionConfig;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    selectedFields: Record<string, any>;\n  }): Promise<void> {\n    const processRelationTasks = Object.entries(relations).map(\n      ([sourceFieldName, nestedRelations]) =>\n        this.processRelation({\n          flatObjectMetadataMaps,\n          flatFieldMetadataMaps,\n          parentObjectMetadataItem,\n          parentObjectRecords,\n          parentObjectRecordsAggregatedValues,\n          sourceFieldName,\n          nestedRelations,\n          aggregate,\n          limit,\n          authContext,\n          workspaceDataSource,\n          rolePermissionConfig,\n          selectedFields:\n            selectedFields[sourceFieldName] instanceof Object\n              ? selectedFields[sourceFieldName]\n              : undefined,\n        }),\n    );\n\n    await Promise.all(processRelationTasks);\n  }\n\n  private async processRelation<T extends ObjectRecord = ObjectRecord>({\n    flatObjectMetadataMaps,\n    flatFieldMetadataMaps,\n    parentObjectMetadataItem,\n    parentObjectRecords,\n    parentObjectRecordsAggregatedValues,\n    sourceFieldName,\n    nestedRelations,\n    aggregate,\n    limit,\n    authContext,\n    workspaceDataSource,\n    rolePermissionConfig,\n    selectedFields,\n  }: {\n    flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>;\n    flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>;\n    parentObjectMetadataItem: FlatObjectMetadata;\n    parentObjectRecords: T[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parentObjectRecordsAggregatedValues: Record<string, any>;\n    sourceFieldName: string;\n    nestedRelations: FindOptionsRelations<ObjectLiteral>;\n    aggregate: Record<string, AggregationField>;\n    limit: number;\n    authContext: AuthContext;\n    workspaceDataSource: WorkspaceDataSource;\n    rolePermissionConfig?: RolePermissionConfig;\n    selectedFields: Record<string, unknown>;\n  }): Promise<void> {\n    const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n      flatFieldMetadataMaps,\n      parentObjectMetadataItem,\n    );\n\n    const sourceFieldMetadata = findFlatEntityByIdInFlatEntityMaps({\n      flatEntityId: fieldIdByName[sourceFieldName],\n      flatEntityMaps: flatFieldMetadataMaps,\n    });\n\n    if (!sourceFieldMetadata) {\n      return;\n    }\n\n    if (\n      !isFieldMetadataEntityOfType(\n        sourceFieldMetadata,\n        FieldMetadataType.RELATION,\n      ) &&\n      !isFieldMetadataEntityOfType(\n        sourceFieldMetadata,\n        FieldMetadataType.MORPH_RELATION,\n      )\n    ) {\n      // TODO: Maybe we should throw an error here ?\n      return;\n    }\n\n    if (!sourceFieldMetadata.settings) {\n      throw new GraphqlQueryRunnerException(\n        `Relation settings not found for field ${sourceFieldName}`,\n        GraphqlQueryRunnerExceptionCode.RELATION_SETTINGS_NOT_FOUND,\n      );\n    }\n\n    const relationType = sourceFieldMetadata.settings?.relationType;\n    const { targetRelationName, targetObjectMetadata, targetRelation } =\n      this.getTargetObjectMetadata({\n        flatObjectMetadataMaps,\n        flatFieldMetadataMaps,\n        parentObjectMetadataItem,\n        sourceFieldName,\n      });\n\n    const targetObjectRepository = workspaceDataSource.getRepository(\n      targetObjectMetadata.nameSingular,\n      rolePermissionConfig,\n    );\n\n    const targetObjectNameSingular = targetObjectMetadata.nameSingular;\n\n    let targetObjectQueryBuilder = targetObjectRepository.createQueryBuilder(\n      targetObjectNameSingular,\n    );\n\n    const columnsToSelect = buildColumnsToSelect({\n      select: selectedFields,\n      relations: nestedRelations,\n      flatObjectMetadata: targetObjectMetadata,\n      flatObjectMetadataMaps,\n      flatFieldMetadataMaps,\n    });\n\n    targetObjectQueryBuilder = targetObjectQueryBuilder.setFindOptions({\n      select: columnsToSelect,\n    });\n\n    const relationIds = this.getUniqueIds({\n      records: parentObjectRecords,\n      idField:\n        relationType === RelationType.ONE_TO_MANY\n          ? 'id'\n          : (sourceFieldMetadata.settings.joinColumnName ??\n            `${sourceFieldName}Id`),\n    });\n\n    const fieldMetadataTargetRelationColumnName =\n      targetRelation &&\n      isFieldMetadataEntityOfType(\n        targetRelation,\n        FieldMetadataType.MORPH_RELATION,\n      )\n        ? `${targetRelation.settings?.joinColumnName}`\n        : `${targetRelationName}Id`;\n\n    const { relationResults, relationAggregatedFieldsResult } =\n      await this.findRelations({\n        referenceQueryBuilder: targetObjectQueryBuilder,\n        column:\n          relationType === RelationType.ONE_TO_MANY\n            ? `\"${fieldMetadataTargetRelationColumnName}\"`\n            : 'id',\n        ids: relationIds,\n        limit: limit * parentObjectRecords.length,\n        aggregate,\n        sourceFieldName,\n        targetObjectNameSingular,\n      });\n\n    this.assignRelationResults({\n      parentRecords: parentObjectRecords,\n      parentObjectRecordsAggregatedValues,\n      relationResults,\n      relationAggregatedFieldsResult,\n      sourceFieldName,\n      joinField:\n        relationType === RelationType.ONE_TO_MANY\n          ? `${fieldMetadataTargetRelationColumnName}`\n          : 'id',\n      relationType,\n    });\n\n    if (Object.keys(nestedRelations).length > 0) {\n      await this.processNestedRelations({\n        flatObjectMetadataMaps,\n        flatFieldMetadataMaps,\n        parentObjectMetadataItem: targetObjectMetadata,\n        parentObjectRecords: relationResults as ObjectRecord[],\n        parentObjectRecordsAggregatedValues: relationAggregatedFieldsResult,\n        relations: nestedRelations as Record<\n          string,\n          FindOptionsRelations<ObjectLiteral>\n        >,\n        aggregate,\n        limit,\n        authContext,\n        workspaceDataSource,\n        rolePermissionConfig,\n        selectedFields,\n      });\n    }\n  }\n\n  private getTargetObjectMetadata({\n    flatObjectMetadataMaps,\n    flatFieldMetadataMaps,\n    parentObjectMetadataItem,\n    sourceFieldName,\n  }: {\n    flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>;\n    flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>;\n    parentObjectMetadataItem: FlatObjectMetadata;\n    sourceFieldName: string;\n  }) {\n    const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n      flatFieldMetadataMaps,\n      parentObjectMetadataItem,\n    );\n\n    const targetFieldMetadata = findFlatEntityByIdInFlatEntityMaps({\n      flatEntityId: fieldIdByName[sourceFieldName],\n      flatEntityMaps: flatFieldMetadataMaps,\n    });\n\n    if (!targetFieldMetadata) {\n      throw new GraphqlQueryRunnerException(\n        `Field ${sourceFieldName} not found on object ${parentObjectMetadataItem.nameSingular}`,\n        GraphqlQueryRunnerExceptionCode.FIELD_NOT_FOUND,\n      );\n    }\n\n    const targetObjectMetadata = getTargetObjectMetadataOrThrow(\n      targetFieldMetadata,\n      flatObjectMetadataMaps,\n    );\n\n    if (\n      !targetFieldMetadata.relationTargetObjectMetadataId ||\n      !targetFieldMetadata.relationTargetFieldMetadataId\n    ) {\n      throw new GraphqlQueryRunnerException(\n        `Relation target object metadata id or field metadata id not found for field ${sourceFieldName}`,\n        GraphqlQueryRunnerExceptionCode.RELATION_TARGET_OBJECT_METADATA_NOT_FOUND,\n      );\n    }\n\n    const targetRelation =\n      flatFieldMetadataMaps.byId[\n        targetFieldMetadata.relationTargetFieldMetadataId\n      ];\n\n    const targetRelationName = targetRelation?.name;\n\n    return { targetRelationName, targetObjectMetadata, targetRelation };\n  }\n\n  private getUniqueIds({\n    records,\n    idField,\n  }: {\n    records: ObjectRecord[];\n    idField: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }): any[] {\n    return [...new Set(records.map((item) => item[idField]))];\n  }\n\n  private async findRelations({\n    referenceQueryBuilder,\n    column,\n    ids,\n    limit,\n    aggregate,\n    sourceFieldName,\n    targetObjectNameSingular,\n  }: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    referenceQueryBuilder: WorkspaceSelectQueryBuilder<any>;\n    column: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ids: any[];\n    limit: number;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    aggregate: Record<string, any>;\n    sourceFieldName: string;\n    targetObjectNameSingular: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }): Promise<{ relationResults: any[]; relationAggregatedFieldsResult: any }> {\n    if (ids.length === 0) {\n      return { relationResults: [], relationAggregatedFieldsResult: {} };\n    }\n\n    const aggregateForRelation = aggregate[sourceFieldName];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let relationAggregatedFieldsResult: Record<string, any> = {};\n\n    if (aggregateForRelation) {\n      const aggregateQueryBuilder = referenceQueryBuilder.clone();\n\n      ProcessAggregateHelper.addSelectedAggregatedFieldsQueriesToQueryBuilder({\n        selectedAggregatedFields: aggregateForRelation,\n        queryBuilder: aggregateQueryBuilder,\n        objectMetadataNameSingular: targetObjectNameSingular,\n      });\n\n      const aggregatedFieldsValues = await aggregateQueryBuilder\n        .addSelect(column)\n        .where(`${column} IN (:...ids)`, {\n          ids,\n        })\n        .groupBy(column)\n        .getRawMany();\n\n      relationAggregatedFieldsResult = aggregatedFieldsValues.reduce(\n        (acc, item) => {\n          const columnWithoutQuotes = column.replace(/[\"']/g, '');\n          const key = item[columnWithoutQuotes];\n          const { [column]: _, ...itemWithoutColumn } = item;\n\n          acc[key] = itemWithoutColumn;\n\n          return acc;\n        },\n        {},\n      );\n    }\n\n    const queryBuilderOptions = referenceQueryBuilder.getFindOptions();\n    const columnWithoutQuotes = column.replace(/[\"']/g, '');\n\n    const result = await referenceQueryBuilder\n      .setFindOptions({\n        ...queryBuilderOptions,\n        select: { ...queryBuilderOptions.select, [columnWithoutQuotes]: true },\n      })\n      .where(`${column} IN (:...ids)`, {\n        ids,\n      })\n      .take(limit)\n      .getMany();\n\n    return { relationResults: result, relationAggregatedFieldsResult };\n  }\n\n  private assignRelationResults({\n    parentRecords,\n    parentObjectRecordsAggregatedValues,\n    relationResults,\n    relationAggregatedFieldsResult,\n    sourceFieldName,\n    joinField,\n    relationType,\n  }: {\n    parentRecords: ObjectRecord[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parentObjectRecordsAggregatedValues: Record<string, any>;\n    // eslint-disable-next-line @typescript-eslint/no-",
            "output_extracted": "import { Injectable } from '@nestjs/common';\n\nimport { FieldMetadataType, type ObjectRecord } from 'twenty-shared/types';\nimport { type FindOptionsRelations, type ObjectLiteral } from 'typeorm';\n\nimport { RelationType } from 'src/engine/metadata-modules/field-metadata/interfaces/relation-type.interface';\n\nimport {\n  GraphqlQueryRunnerException,\n  GraphqlQueryRunnerExceptionCode,\n} from 'src/engine/api/graphql/graphql-query-runner/errors/graphql-query-runner.exception';\nimport { ProcessAggregateHelper } from 'src/engine/api/graphql/graphql-query-runner/helpers/process-aggregate.helper';\nimport { buildColumnsToSelect } from 'src/engine/api/graphql/graphql-query-runner/utils/build-columns-to-select';\nimport { getTargetObjectMetadataOrThrow } from 'src/engine/api/graphql/graphql-query-runner/utils/get-target-object-metadata.util';\nimport { type AggregationField } from 'src/engine/api/graphql/workspace-schema-builder/utils/get-available-aggregations-from-object-fields.util';\nimport { type AuthContext } from 'src/engine/core-modules/auth/types/auth-context.type';\nimport { FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { findFlatEntityByIdInFlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/utils/find-flat-entity-by-id-in-flat-entity-maps.util';\nimport { FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\nimport { FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\nimport { type WorkspaceDataSource } from 'src/engine/twenty-orm/datasource/workspace.datasource';\nimport { type WorkspaceSelectQueryBuilder } from 'src/engine/twenty-orm/repository/workspace-select-query-builder';\nimport { type RolePermissionConfig } from 'src/engine/twenty-orm/types/role-permission-config';\nimport { isFieldMetadataEntityOfType } from 'src/engine/utils/is-field-metadata-of-type.util';\n\n@Injectable()\nexport class ProcessNestedRelationsV2Helper {\n  constructor() {}\n\n  public async processNestedRelations<T extends ObjectRecord = ObjectRecord>({\n    flatObjectMetadataMaps,\n    flatFieldMetadataMaps,\n    parentObjectMetadataItem,\n    parentObjectRecords,\n    parentObjectRecordsAggregatedValues = {},\n    relations,\n    aggregate = {},\n    limit,\n    authContext,\n    workspaceDataSource,\n    rolePermissionConfig,\n    selectedFields,\n  }: {\n    flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>;\n    flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>;\n    parentObjectMetadataItem: FlatObjectMetadata;\n    parentObjectRecords: T[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parentObjectRecordsAggregatedValues?: Record<string, any>;\n    relations: Record<string, FindOptionsRelations<ObjectLiteral>>;\n    aggregate?: Record<string, AggregationField>;\n    limit: number;\n    authContext: AuthContext;\n    workspaceDataSource: WorkspaceDataSource;\n    rolePermissionConfig?: RolePermissionConfig;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    selectedFields: Record<string, any>;\n  }): Promise<void> {\n    const processRelationTasks = Object.entries(relations).map(\n      ([sourceFieldName, nestedRelations]) =>\n        this.processRelation({\n          flatObjectMetadataMaps,\n          flatFieldMetadataMaps,\n          parentObjectMetadataItem,\n          parentObjectRecords,\n          parentObjectRecordsAggregatedValues,\n          sourceFieldName,\n          nestedRelations,\n          aggregate,\n          limit,\n          authContext,\n          workspaceDataSource,\n          rolePermissionConfig,\n          selectedFields:\n            selectedFields[sourceFieldName] instanceof Object\n              ? selectedFields[sourceFieldName]\n              : undefined,\n        }),\n    );\n\n    await Promise.all(processRelationTasks);\n  }\n\n  private async processRelation<T extends ObjectRecord = ObjectRecord>({\n    flatObjectMetadataMaps,\n    flatFieldMetadataMaps,\n    parentObjectMetadataItem,\n    parentObjectRecords,\n    parentObjectRecordsAggregatedValues,\n    sourceFieldName,\n    nestedRelations,\n    aggregate,\n    limit,\n    authContext,\n    workspaceDataSource,\n    rolePermissionConfig,\n    selectedFields,\n  }: {\n    flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>;\n    flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>;\n    parentObjectMetadataItem: FlatObjectMetadata;\n    parentObjectRecords: T[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parentObjectRecordsAggregatedValues: Record<string, any>;\n    sourceFieldName: string;\n    nestedRelations: FindOptionsRelations<ObjectLiteral>;\n    aggregate: Record<string, AggregationField>;\n    limit: number;\n    authContext: AuthContext;\n    workspaceDataSource: WorkspaceDataSource;\n    rolePermissionConfig?: RolePermissionConfig;\n    selectedFields: Record<string, unknown>;\n  }): Promise<void> {\n    const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n      flatFieldMetadataMaps,\n      parentObjectMetadataItem,\n    );\n\n    const sourceFieldMetadata = findFlatEntityByIdInFlatEntityMaps({\n      flatEntityId: fieldIdByName[sourceFieldName],\n      flatEntityMaps: flatFieldMetadataMaps,\n    });\n\n    if (!sourceFieldMetadata) {\n      return;\n    }\n\n    if (\n      !isFieldMetadataEntityOfType(\n        sourceFieldMetadata,\n        FieldMetadataType.RELATION,\n      ) &&\n      !isFieldMetadataEntityOfType(\n        sourceFieldMetadata,\n        FieldMetadataType.MORPH_RELATION,\n      )\n    ) {\n      // TODO: Maybe we should throw an error here ?\n      return;\n    }\n\n    if (!sourceFieldMetadata.settings) {\n      throw new GraphqlQueryRunnerException(\n        `Relation settings not found for field ${sourceFieldName}`,\n        GraphqlQueryRunnerExceptionCode.RELATION_SETTINGS_NOT_FOUND,\n      );\n    }\n\n    const relationType = sourceFieldMetadata.settings?.relationType;\n    const { targetRelationName, targetObjectMetadata, targetRelation } =\n      this.getTargetObjectMetadata({\n        flatObjectMetadataMaps,\n        flatFieldMetadataMaps,\n        parentObjectMetadataItem,\n        sourceFieldName,\n      });\n\n    const targetObjectRepository = workspaceDataSource.getRepository(\n      targetObjectMetadata.nameSingular,\n      rolePermissionConfig,\n    );\n\n    const targetObjectNameSingular = targetObjectMetadata.nameSingular;\n\n    let targetObjectQueryBuilder = targetObjectRepository.createQueryBuilder(\n      targetObjectNameSingular,\n    );\n\n    const columnsToSelect = buildColumnsToSelect({\n      select: selectedFields,\n      relations: nestedRelations,\n      flatObjectMetadata: targetObjectMetadata,\n      flatObjectMetadataMaps,\n      flatFieldMetadataMaps,\n    });\n\n    targetObjectQueryBuilder = targetObjectQueryBuilder.setFindOptions({\n      select: columnsToSelect,\n    });\n\n    const relationIds = this.getUniqueIds({\n      records: parentObjectRecords,\n      idField:\n        relationType === RelationType.ONE_TO_MANY\n          ? 'id'\n          : (sourceFieldMetadata.settings.joinColumnName ??\n            `${sourceFieldName}Id`),\n    });\n\n    const fieldMetadataTargetRelationColumnName =\n      targetRelation &&\n      isFieldMetadataEntityOfType(\n        targetRelation,\n        FieldMetadataType.MORPH_RELATION,\n      )\n        ? `${targetRelation.settings?.joinColumnName}`\n        : `${targetRelationName}Id`;\n\n    const { relationResults, relationAggregatedFieldsResult } =\n      await this.findRelations({\n        referenceQueryBuilder: targetObjectQueryBuilder,\n        column:\n          relationType === RelationType.ONE_TO_MANY\n            ? `\"${fieldMetadataTargetRelationColumnName}\"`\n            : 'id',\n        ids: relationIds,\n        limit: limit * parentObjectRecords.length,\n        aggregate,\n        sourceFieldName,\n        targetObjectNameSingular,\n      });\n\n    this.assignRelationResults({\n      parentRecords: parentObjectRecords,\n      parentObjectRecordsAggregatedValues,\n      relationResults,\n      relationAggregatedFieldsResult,\n      sourceFieldName,\n      joinField:\n        relationType === RelationType.ONE_TO_MANY\n          ? `${fieldMetadataTargetRelationColumnName}`\n          : 'id',\n      relationType,\n    });\n\n    if (Object.keys(nestedRelations).length > 0) {\n      await this.processNestedRelations({\n        flatObjectMetadataMaps,\n        flatFieldMetadataMaps,\n        parentObjectMetadataItem: targetObjectMetadata,\n        parentObjectRecords: relationResults as ObjectRecord[],\n        parentObjectRecordsAggregatedValues: relationAggregatedFieldsResult,\n        relations: nestedRelations as Record<\n          string,\n          FindOptionsRelations<ObjectLiteral>\n        >,\n        aggregate,\n        limit,\n        authContext,\n        workspaceDataSource,\n        rolePermissionConfig,\n        selectedFields,\n      });\n    }\n  }\n\n  private getTargetObjectMetadata({\n    flatObjectMetadataMaps,\n    flatFieldMetadataMaps,\n    parentObjectMetadataItem,\n    sourceFieldName,\n  }: {\n    flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>;\n    flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>;\n    parentObjectMetadataItem: FlatObjectMetadata;\n    sourceFieldName: string;\n  }) {\n    const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n      flatFieldMetadataMaps,\n      parentObjectMetadataItem,\n    );\n\n    const targetFieldMetadata = findFlatEntityByIdInFlatEntityMaps({\n      flatEntityId: fieldIdByName[sourceFieldName],\n      flatEntityMaps: flatFieldMetadataMaps,\n    });\n\n    if (!targetFieldMetadata) {\n      throw new GraphqlQueryRunnerException(\n        `Field ${sourceFieldName} not found on object ${parentObjectMetadataItem.nameSingular}`,\n        GraphqlQueryRunnerExceptionCode.FIELD_NOT_FOUND,\n      );\n    }\n\n    const targetObjectMetadata = getTargetObjectMetadataOrThrow(\n      targetFieldMetadata,\n      flatObjectMetadataMaps,\n    );\n\n    if (\n      !targetFieldMetadata.relationTargetObjectMetadataId ||\n      !targetFieldMetadata.relationTargetFieldMetadataId\n    ) {\n      throw new GraphqlQueryRunnerException(\n        `Relation target object metadata id or field metadata id not found for field ${sourceFieldName}`,\n        GraphqlQueryRunnerExceptionCode.RELATION_TARGET_OBJECT_METADATA_NOT_FOUND,\n      );\n    }\n\n    const targetRelation =\n      flatFieldMetadataMaps.byId[\n        targetFieldMetadata.relationTargetFieldMetadataId\n      ];\n\n    const targetRelationName = targetRelation?.name;\n\n    return { targetRelationName, targetObjectMetadata, targetRelation };\n  }\n\n  private getUniqueIds({\n    records,\n    idField,\n  }: {\n    records: ObjectRecord[];\n    idField: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }): any[] {\n    return [...new Set(records.map((item) => item[idField]))];\n  }\n\n  private async findRelations({\n    referenceQueryBuilder,\n    column,\n    ids,\n    limit,\n    aggregate,\n    sourceFieldName,\n    targetObjectNameSingular,\n  }: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    referenceQueryBuilder: WorkspaceSelectQueryBuilder<any>;\n    column: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ids: any[];\n    limit: number;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    aggregate: Record<string, any>;\n    sourceFieldName: string;\n    targetObjectNameSingular: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }): Promise<{ relationResults: any[]; relationAggregatedFieldsResult: any }> {\n    if (ids.length === 0) {\n      return { relationResults: [], relationAggregatedFieldsResult: {} };\n    }\n\n    const aggregateForRelation = aggregate[sourceFieldName];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let relationAggregatedFieldsResult: Record<string, any> = {};\n\n    if (aggregateForRelation) {\n      const aggregateQueryBuilder = referenceQueryBuilder.clone();\n\n      ProcessAggregateHelper.addSelectedAggregatedFieldsQueriesToQueryBuilder({\n        selectedAggregatedFields: aggregateForRelation,\n        queryBuilder: aggregateQueryBuilder,\n        objectMetadataNameSingular: targetObjectNameSingular,\n      });\n\n      const aggregatedFieldsValues = await aggregateQueryBuilder\n        .addSelect(column)\n        .where(`${column} IN (:...ids)`, {\n          ids,\n        })\n        .groupBy(column)\n        .getRawMany();\n\n      relationAggregatedFieldsResult = aggregatedFieldsValues.reduce(\n        (acc, item) => {\n          const columnWithoutQuotes = column.replace(/[\"']/g, '');\n          const key = item[columnWithoutQuotes];\n          const { [column]: _, ...itemWithoutColumn } = item;\n\n          acc[key] = itemWithoutColumn;\n\n          return acc;\n        },\n        {},\n      );\n    }\n\n    const queryBuilderOptions = referenceQueryBuilder.getFindOptions();\n    const columnWithoutQuotes = column.replace(/[\"']/g, '');\n\n    const result = await referenceQueryBuilder\n      .setFindOptions({\n        ...queryBuilderOptions,\n        select: { ...queryBuilderOptions.select, [columnWithoutQuotes]: true },\n      })\n      .where(`${column} IN (:...ids)`, {\n        ids,\n      })\n      .take(limit)\n      .getMany();\n\n    return { relationResults: result, relationAggregatedFieldsResult };\n  }\n\n  private assignRelationResults({\n    parentRecords,\n    parentObjectRecordsAggregatedValues,\n    relationResults,\n    relationAggregatedFieldsResult,\n    sourceFieldName,\n    joinField,\n    relationType,\n  }: {\n    parentRecords: ObjectRecord[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parentObjectRecordsAggregatedValues: Record<string, any>;\n    // eslint-disable-next-line @typescript-eslint/no-",
            "cost": 0.13340000000000002
        },
        "twentyhq__twenty.main/packages/twenty-server/src/engine/twenty-orm/entity-manager/workspace-entity-manager.spec.ts": {
            "output": "import {\n  type FieldMetadataType,\n  type ObjectsPermissions,\n} from 'twenty-shared/types';\nimport { EntityManager } from 'typeorm';\nimport { EntityPersistExecutor } from 'typeorm/persistence/EntityPersistExecutor';\nimport { PlainObjectToDatabaseEntityTransformer } from 'typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer';\n\nimport { type WorkspaceInternalContext } from 'src/engine/twenty-orm/interfaces/workspace-internal-context.interface';\n\nimport { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\nimport { type WorkspaceDataSource } from 'src/engine/twenty-orm/datasource/workspace.datasource';\nimport { validateOperationIsPermittedOrThrow } from 'src/engine/twenty-orm/repository/permissions.utils';\n\nimport { WorkspaceEntityManager } from './workspace-entity-manager';\n\njest.mock('src/engine/twenty-orm/repository/permissions.utils', () => ({\n  validateOperationIsPermittedOrThrow: jest.fn(),\n}));\n\njest.mock(\n  'src/engine/twenty-orm/utils/get-object-metadata-from-entity-target.util',\n  () => ({\n    getObjectMetadataFromEntityTarget: jest.fn().mockReturnValue({}),\n  }),\n);\n\njest.mock('src/engine/twenty-orm/utils/format-data.util', () => ({\n  formatData: jest.fn().mockReturnValue([]),\n}));\n\njest.mock('src/engine/twenty-orm/utils/format-result.util', () => ({\n  formatResult: jest.fn().mockReturnValue([]),\n}));\n\njest.mock(\n  'src/engine/twenty-orm/entity-manager/workspace-entity-manager',\n  () => ({\n    ...jest.requireActual(\n      'src/engine/twenty-orm/entity-manager/workspace-entity-manager',\n    ),\n  }),\n);\n\nconst mockedWorkspaceUpdateQueryBuilder = {\n  set: jest.fn().mockImplementation(() => ({\n    where: jest.fn().mockReturnThis(),\n    whereInIds: jest.fn().mockReturnThis(),\n    execute: jest\n      .fn()\n      .mockResolvedValue({ affected: 1, raw: [], generatedMaps: [] }),\n    returning: jest.fn().mockReturnThis(),\n  })),\n  execute: jest\n    .fn()\n    .mockResolvedValue({ affected: 1, raw: [], generatedMaps: [] }),\n};\n\njest.mock('../repository/workspace-select-query-builder', () => ({\n  WorkspaceSelectQueryBuilder: jest.fn().mockImplementation(() => ({\n    where: jest.fn().mockReturnThis(),\n    getMany: jest.fn().mockResolvedValue([]),\n    getOne: jest.fn().mockResolvedValue(null),\n    getManyAndCount: jest.fn().mockResolvedValue([[], 0]),\n    execute: jest\n      .fn()\n      .mockResolvedValue({ affected: 1, raw: [], generatedMaps: [] }),\n    setFindOptions: jest.fn().mockReturnThis(),\n    returning: jest.fn().mockReturnThis(),\n    update: jest.fn().mockReturnValue(mockedWorkspaceUpdateQueryBuilder),\n    insert: jest.fn().mockReturnThis(),\n  })),\n}));\n\ndescribe('WorkspaceEntityManager', () => {\n  let entityManager: WorkspaceEntityManager;\n  let mockInternalContext: WorkspaceInternalContext;\n  let mockDataSource: WorkspaceDataSource;\n  let mockPermissionOptions: {\n    shouldBypassPermissionChecks: boolean;\n    objectRecordsPermissions?: ObjectsPermissions;\n  };\n\n  beforeEach(() => {\n    const mockFlatObjectMetadata: FlatObjectMetadata = {\n      id: 'test-entity-id',\n      nameSingular: 'test-entity',\n      namePlural: 'test-entities',\n      labelSingular: 'Test Entity',\n      labelPlural: 'Test Entities',\n      workspaceId: 'test-workspace-id',\n      icon: 'test-icon',\n      isCustom: false,\n      isRemote: false,\n      isAuditLogged: false,\n      isSearchable: false,\n      isSystem: false,\n      isActive: true,\n      targetTableName: 'test_entity',\n      fieldMetadataIds: ['field-id'],\n      indexMetadataIds: [],\n      viewIds: [],\n      universalIdentifier: 'test-entity-id',\n      description: null,\n      imageIdentifierFieldMetadataId: null,\n      labelIdentifierFieldMetadataId: null,\n      shortcut: null,\n      standardId: null,\n      standardOverrides: null,\n      applicationId: null,\n      isLabelSyncedWithName: false,\n      isUIReadOnly: false,\n      duplicateCriteria: null,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    const mockFlatFieldMetadata: FlatFieldMetadata = {\n      id: 'field-id',\n      type: 'TEXT' as FieldMetadataType,\n      name: 'fieldName',\n      label: 'Field Name',\n      objectMetadataId: 'test-entity-id',\n      isNullable: true,\n      isLabelSyncedWithName: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      universalIdentifier: 'field-id',\n      defaultValue: null,\n      description: null,\n      icon: null,\n      isActive: true,\n      isCustom: false,\n      isSystem: false,\n      isUIReadOnly: false,\n      isUnique: false,\n      options: null,\n      settings: null,\n      standardId: null,\n      standardOverrides: null,\n      workspaceId: 'test-workspace-id',\n      viewFieldIds: [],\n      viewFilterIds: [],\n      viewGroupIds: [],\n      kanbanAggregateOperationViewIds: [],\n      calendarViewIds: [],\n      mainGroupByFieldMetadataViewIds: [],\n      relationTargetFieldMetadataId: null,\n      relationTargetObjectMetadataId: null,\n      morphId: null,\n      applicationId: null,\n    };\n\n    const flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata> = {\n      byId: {\n        'test-entity-id': mockFlatObjectMetadata,\n      },\n      idByUniversalIdentifier: {\n        'test-entity-id': 'test-entity-id',\n      },\n      universalIdentifiersByApplicationId: {},\n    };\n\n    const flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata> = {\n      byId: {\n        'field-id': mockFlatFieldMetadata,\n      },\n      idByUniversalIdentifier: {\n        'field-id': 'field-id',\n      },\n      universalIdentifiersByApplicationId: {},\n    };\n\n    mockInternalContext = {\n      workspaceId: 'test-workspace-id',\n      flatObjectMetadataMaps,\n      flatFieldMetadataMaps,\n      flatIndexMaps: {\n        byId: {},\n        idByUniversalIdentifier: {},\n        universalIdentifiersByApplicationId: {},\n      },\n      objectIdByNameSingular: {\n        'test-entity': 'test-entity-id',\n      },\n      featureFlagsMap: {\n        IS_AIRTABLE_INTEGRATION_ENABLED: false,\n        IS_POSTGRESQL_INTEGRATION_ENABLED: false,\n        IS_STRIPE_INTEGRATION_ENABLED: false,\n        IS_UNIQUE_INDEXES_ENABLED: false,\n        IS_JSON_FILTER_ENABLED: false,\n        IS_AI_ENABLED: false,\n        IS_APPLICATION_ENABLED: false,\n        IS_IMAP_SMTP_CALDAV_ENABLED: false,\n        IS_MORPH_RELATION_ENABLED: false,\n        IS_PAGE_LAYOUT_ENABLED: false,\n        IS_RECORD_PAGE_LAYOUT_ENABLED: false,\n        IS_PUBLIC_DOMAIN_ENABLED: false,\n        IS_EMAILING_DOMAIN_ENABLED: false,\n        IS_WORKFLOW_RUN_STOPPAGE_ENABLED: false,\n        IS_DASHBOARD_V2_ENABLED: false,\n        IS_GLOBAL_WORKSPACE_DATASOURCE_ENABLED: false,\n      },\n      eventEmitterService: {\n        emitMutationEvent: jest.fn(),\n        emitDatabaseBatchEvent: jest.fn(),\n        emitCustomBatchEvent: jest.fn(),\n      } as any,\n    } as WorkspaceInternalContext;\n\n    mockDataSource = {\n      featureFlagMap: {\n        IS_AIRTABLE_INTEGRATION_ENABLED: false,\n        IS_POSTGRESQL_INTEGRATION_ENABLED: false,\n        IS_STRIPE_INTEGRATION_ENABLED: false,\n        IS_UNIQUE_INDEXES_ENABLED: false,\n        IS_JSON_FILTER_ENABLED: false,\n        IS_AI_ENABLED: false,\n        IS_APPLICATION_ENABLED: false,\n        IS_IMAP_SMTP_CALDAV_ENABLED: false,\n        IS_PAGE_LAYOUT_ENABLED: false,\n        IS_RECORD_PAGE_LAYOUT_ENABLED: false,\n        IS_PUBLIC_DOMAIN_ENABLED: false,\n        IS_EMAILING_DOMAIN_ENABLED: false,\n        IS_WORKFLOW_RUN_STOPPAGE_ENABLED: false,\n        IS_DASHBOARD_V2_ENABLED: false,\n        IS_GLOBAL_WORKSPACE_DATASOURCE_ENABLED: false,\n      },\n      permissionsPerRoleId: {},\n    } as WorkspaceDataSource;\n\n    mockPermissionOptions = {\n      shouldBypassPermissionChecks: false,\n      objectRecordsPermissions: {\n        'test-entity': {\n          canReadObjectRecords: true,\n          canUpdateObjectRecords: false,\n          canSoftDeleteObjectRecords: false,\n          canDestroyObjectRecords: false,\n          restrictedFields: {},\n        },\n      },\n    };\n\n    // Mock TypeORM connection methods\n    const mockWorkspaceDataSource = {\n      getMetadata: jest.fn().mockReturnValue({\n        name: 'test-entity',\n        columns: [],\n        relations: [],\n        findInheritanceMetadata: jest.fn(),\n        findColumnWithPropertyPath: jest.fn(),\n      }),\n      createQueryBuilder: jest.fn().mockReturnValue({\n        delete: jest.fn().mockReturnThis(),\n        from: jest.fn().mockReturnThis(),\n        where: jest.fn().mockReturnThis(),\n        execute: jest\n          .fn()\n          .mockResolvedValue({ affected: 1, raw: [], generatedMaps: [] }),\n        getMany: jest.fn().mockResolvedValue([]),\n        getOne: jest.fn().mockResolvedValue(null),\n        getManyAndCount: jest.fn().mockResolvedValue([[], 0]),\n        update: jest.fn().mockReturnThis(),\n        softDelete: jest.fn().mockReturnThis(),\n        restore: jest.fn().mockReturnThis(),\n      }),\n      createQueryRunner: jest.fn().mockReturnValue({\n        connect: jest.fn(),\n        startTransaction: jest.fn(),\n        commitTransaction: jest.fn(),\n        rollbackTransaction: jest.fn(),\n        release: jest.fn(),\n        clearTable: jest.fn(),\n      }),\n      createQueryRunnerForEntityPersistExecutor: jest.fn().mockReturnValue({\n        connect: jest.fn(),\n        startTransaction: jest.fn(),\n        commitTransaction: jest.fn(),\n        rollbackTransaction: jest.fn(),\n        release: jest.fn(),\n        clearTable: jest.fn(),\n      }),\n    };\n\n    entityManager = new WorkspaceEntityManager(\n      mockInternalContext,\n      mockDataSource,\n    );\n\n    Object.defineProperty(entityManager, 'connection', {\n      get: () => mockWorkspaceDataSource,\n    });\n\n    jest.spyOn(entityManager as any, 'validatePermissions');\n    jest.spyOn(entityManager as any, 'createQueryBuilder');\n    jest\n      .spyOn(entityManager as any, 'getFormattedResultWithoutNonReadableFields')\n      .mockImplementation(\n        ({ formattedResult }: { formattedResult: string[] }) => formattedResult,\n      );\n\n    jest\n      .spyOn(entityManager as any, 'extractTargetNameSingularFromEntityTarget')\n      .mockImplementation((entityName: string) => {\n        return entityName;\n      });\n\n    // Mock typeORM's EntityManager methods\n    jest\n      .spyOn(EntityManager.prototype, 'save')\n      .mockImplementation(() => Promise.resolve({}));\n    jest\n      .spyOn(EntityManager.prototype, 'update')\n      .mockImplementation(() =>\n        Promise.resolve({ affected: 1, raw: [], generatedMaps: [] }),\n      );\n    jest\n      .spyOn(EntityManager.prototype, 'restore')\n      .mockImplementation(() =>\n        Promise.resolve({ affected: 1, raw: [], generatedMaps: [] }),\n      );\n    jest\n      .spyOn(EntityManager.prototype, 'clear')\n      .mockImplementation(() => Promise.resolve());\n    jest\n      .spyOn(EntityManager.prototype, 'preload')\n      .mockImplementation(() => Promise.resolve({}));\n\n    jest\n      .spyOn(EntityPersistExecutor.prototype, 'execute')\n      .mockImplementation(() => Promise.resolve());\n\n    jest\n      .spyOn(PlainObjectToDatabaseEntityTransformer.prototype, 'transform')\n      .mockImplementation(() => Promise.resolve({}));\n\n    // Mock metadata methods\n    const mockMetadata = {\n      hasAllPrimaryKeys: jest.fn().mockReturnValue(true),\n      columns: [],\n      relations: [],\n      findInheritanceMetadata: jest.fn(),\n      findColumnWithPropertyPath: jest.fn(),\n    };\n\n    // Update mockWorkspaceDataSource to include metadata\n    mockWorkspaceDataSource.getMetadata = jest\n      .fn()\n      .mockReturnValue(mockMetadata);\n\n    // Reset the mock before each test\n    jest.clearAllMocks();\n  });\n\n  describe('Query Method', () => {\n    it('should call validatePermissions and validateOperationIsPermittedOrThrow for find', async () => {\n      await entityManager.find('test-entity', {}, mockPermissionOptions);\n\n      expect(entityManager.createQueryBuilder).toHaveBeenCalledWith(\n        'test-entity',\n        undefined,\n        undefined,\n        mockPermissionOptions,\n      );\n    });\n    it('should throw error for query', async () => {\n      expect(() => entityManager.query('SELECT * FROM test')).toThrow(\n        'Method not allowed.',\n      );\n    });\n  });\n\n  describe('Save Methods', () => {\n    it('should call validatePermissions and validateOperationIsPermittedOrThrow for save', async () => {\n      await entityManager.save(\n        'test-entity',\n        {},\n        { reload: false },\n        mockPermissionOptions,\n      );\n      expect(entityManager['validatePermissions']).toHaveBeenCalledWith({\n        target: 'test-entity',\n        operationType: 'update',\n        permissionOptions: mockPermissionOptions,\n        selectedColumns: [],\n        updatedColumns: [],\n      });\n      expect(validateOperationIsPermittedOrThrow).toHaveBeenCalledWith({\n        entityName: 'test-entity',\n        operationType: 'update',\n        flatObjectMetadataMaps: mockInternalContext.flatObjectMetadataMaps,\n        flatFieldMetadat",
            "output_extracted": "import {\n  type FieldMetadataType,\n  type ObjectsPermissions,\n} from 'twenty-shared/types';\nimport { EntityManager } from 'typeorm';\nimport { EntityPersistExecutor } from 'typeorm/persistence/EntityPersistExecutor';\nimport { PlainObjectToDatabaseEntityTransformer } from 'typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer';\n\nimport { type WorkspaceInternalContext } from 'src/engine/twenty-orm/interfaces/workspace-internal-context.interface';\n\nimport { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\nimport { type WorkspaceDataSource } from 'src/engine/twenty-orm/datasource/workspace.datasource';\nimport { validateOperationIsPermittedOrThrow } from 'src/engine/twenty-orm/repository/permissions.utils';\n\nimport { WorkspaceEntityManager } from './workspace-entity-manager';\n\njest.mock('src/engine/twenty-orm/repository/permissions.utils', () => ({\n  validateOperationIsPermittedOrThrow: jest.fn(),\n}));\n\njest.mock(\n  'src/engine/twenty-orm/utils/get-object-metadata-from-entity-target.util',\n  () => ({\n    getObjectMetadataFromEntityTarget: jest.fn().mockReturnValue({}),\n  }),\n);\n\njest.mock('src/engine/twenty-orm/utils/format-data.util', () => ({\n  formatData: jest.fn().mockReturnValue([]),\n}));\n\njest.mock('src/engine/twenty-orm/utils/format-result.util', () => ({\n  formatResult: jest.fn().mockReturnValue([]),\n}));\n\njest.mock(\n  'src/engine/twenty-orm/entity-manager/workspace-entity-manager',\n  () => ({\n    ...jest.requireActual(\n      'src/engine/twenty-orm/entity-manager/workspace-entity-manager',\n    ),\n  }),\n);\n\nconst mockedWorkspaceUpdateQueryBuilder = {\n  set: jest.fn().mockImplementation(() => ({\n    where: jest.fn().mockReturnThis(),\n    whereInIds: jest.fn().mockReturnThis(),\n    execute: jest\n      .fn()\n      .mockResolvedValue({ affected: 1, raw: [], generatedMaps: [] }),\n    returning: jest.fn().mockReturnThis(),\n  })),\n  execute: jest\n    .fn()\n    .mockResolvedValue({ affected: 1, raw: [], generatedMaps: [] }),\n};\n\njest.mock('../repository/workspace-select-query-builder', () => ({\n  WorkspaceSelectQueryBuilder: jest.fn().mockImplementation(() => ({\n    where: jest.fn().mockReturnThis(),\n    getMany: jest.fn().mockResolvedValue([]),\n    getOne: jest.fn().mockResolvedValue(null),\n    getManyAndCount: jest.fn().mockResolvedValue([[], 0]),\n    execute: jest\n      .fn()\n      .mockResolvedValue({ affected: 1, raw: [], generatedMaps: [] }),\n    setFindOptions: jest.fn().mockReturnThis(),\n    returning: jest.fn().mockReturnThis(),\n    update: jest.fn().mockReturnValue(mockedWorkspaceUpdateQueryBuilder),\n    insert: jest.fn().mockReturnThis(),\n  })),\n}));\n\ndescribe('WorkspaceEntityManager', () => {\n  let entityManager: WorkspaceEntityManager;\n  let mockInternalContext: WorkspaceInternalContext;\n  let mockDataSource: WorkspaceDataSource;\n  let mockPermissionOptions: {\n    shouldBypassPermissionChecks: boolean;\n    objectRecordsPermissions?: ObjectsPermissions;\n  };\n\n  beforeEach(() => {\n    const mockFlatObjectMetadata: FlatObjectMetadata = {\n      id: 'test-entity-id',\n      nameSingular: 'test-entity',\n      namePlural: 'test-entities',\n      labelSingular: 'Test Entity',\n      labelPlural: 'Test Entities',\n      workspaceId: 'test-workspace-id',\n      icon: 'test-icon',\n      isCustom: false,\n      isRemote: false,\n      isAuditLogged: false,\n      isSearchable: false,\n      isSystem: false,\n      isActive: true,\n      targetTableName: 'test_entity',\n      fieldMetadataIds: ['field-id'],\n      indexMetadataIds: [],\n      viewIds: [],\n      universalIdentifier: 'test-entity-id',\n      description: null,\n      imageIdentifierFieldMetadataId: null,\n      labelIdentifierFieldMetadataId: null,\n      shortcut: null,\n      standardId: null,\n      standardOverrides: null,\n      applicationId: null,\n      isLabelSyncedWithName: false,\n      isUIReadOnly: false,\n      duplicateCriteria: null,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    const mockFlatFieldMetadata: FlatFieldMetadata = {\n      id: 'field-id',\n      type: 'TEXT' as FieldMetadataType,\n      name: 'fieldName',\n      label: 'Field Name',\n      objectMetadataId: 'test-entity-id',\n      isNullable: true,\n      isLabelSyncedWithName: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      universalIdentifier: 'field-id',\n      defaultValue: null,\n      description: null,\n      icon: null,\n      isActive: true,\n      isCustom: false,\n      isSystem: false,\n      isUIReadOnly: false,\n      isUnique: false,\n      options: null,\n      settings: null,\n      standardId: null,\n      standardOverrides: null,\n      workspaceId: 'test-workspace-id',\n      viewFieldIds: [],\n      viewFilterIds: [],\n      viewGroupIds: [],\n      kanbanAggregateOperationViewIds: [],\n      calendarViewIds: [],\n      mainGroupByFieldMetadataViewIds: [],\n      relationTargetFieldMetadataId: null,\n      relationTargetObjectMetadataId: null,\n      morphId: null,\n      applicationId: null,\n    };\n\n    const flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata> = {\n      byId: {\n        'test-entity-id': mockFlatObjectMetadata,\n      },\n      idByUniversalIdentifier: {\n        'test-entity-id': 'test-entity-id',\n      },\n      universalIdentifiersByApplicationId: {},\n    };\n\n    const flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata> = {\n      byId: {\n        'field-id': mockFlatFieldMetadata,\n      },\n      idByUniversalIdentifier: {\n        'field-id': 'field-id',\n      },\n      universalIdentifiersByApplicationId: {},\n    };\n\n    mockInternalContext = {\n      workspaceId: 'test-workspace-id',\n      flatObjectMetadataMaps,\n      flatFieldMetadataMaps,\n      flatIndexMaps: {\n        byId: {},\n        idByUniversalIdentifier: {},\n        universalIdentifiersByApplicationId: {},\n      },\n      objectIdByNameSingular: {\n        'test-entity': 'test-entity-id',\n      },\n      featureFlagsMap: {\n        IS_AIRTABLE_INTEGRATION_ENABLED: false,\n        IS_POSTGRESQL_INTEGRATION_ENABLED: false,\n        IS_STRIPE_INTEGRATION_ENABLED: false,\n        IS_UNIQUE_INDEXES_ENABLED: false,\n        IS_JSON_FILTER_ENABLED: false,\n        IS_AI_ENABLED: false,\n        IS_APPLICATION_ENABLED: false,\n        IS_IMAP_SMTP_CALDAV_ENABLED: false,\n        IS_MORPH_RELATION_ENABLED: false,\n        IS_PAGE_LAYOUT_ENABLED: false,\n        IS_RECORD_PAGE_LAYOUT_ENABLED: false,\n        IS_PUBLIC_DOMAIN_ENABLED: false,\n        IS_EMAILING_DOMAIN_ENABLED: false,\n        IS_WORKFLOW_RUN_STOPPAGE_ENABLED: false,\n        IS_DASHBOARD_V2_ENABLED: false,\n        IS_GLOBAL_WORKSPACE_DATASOURCE_ENABLED: false,\n      },\n      eventEmitterService: {\n        emitMutationEvent: jest.fn(),\n        emitDatabaseBatchEvent: jest.fn(),\n        emitCustomBatchEvent: jest.fn(),\n      } as any,\n    } as WorkspaceInternalContext;\n\n    mockDataSource = {\n      featureFlagMap: {\n        IS_AIRTABLE_INTEGRATION_ENABLED: false,\n        IS_POSTGRESQL_INTEGRATION_ENABLED: false,\n        IS_STRIPE_INTEGRATION_ENABLED: false,\n        IS_UNIQUE_INDEXES_ENABLED: false,\n        IS_JSON_FILTER_ENABLED: false,\n        IS_AI_ENABLED: false,\n        IS_APPLICATION_ENABLED: false,\n        IS_IMAP_SMTP_CALDAV_ENABLED: false,\n        IS_PAGE_LAYOUT_ENABLED: false,\n        IS_RECORD_PAGE_LAYOUT_ENABLED: false,\n        IS_PUBLIC_DOMAIN_ENABLED: false,\n        IS_EMAILING_DOMAIN_ENABLED: false,\n        IS_WORKFLOW_RUN_STOPPAGE_ENABLED: false,\n        IS_DASHBOARD_V2_ENABLED: false,\n        IS_GLOBAL_WORKSPACE_DATASOURCE_ENABLED: false,\n      },\n      permissionsPerRoleId: {},\n    } as WorkspaceDataSource;\n\n    mockPermissionOptions = {\n      shouldBypassPermissionChecks: false,\n      objectRecordsPermissions: {\n        'test-entity': {\n          canReadObjectRecords: true,\n          canUpdateObjectRecords: false,\n          canSoftDeleteObjectRecords: false,\n          canDestroyObjectRecords: false,\n          restrictedFields: {},\n        },\n      },\n    };\n\n    // Mock TypeORM connection methods\n    const mockWorkspaceDataSource = {\n      getMetadata: jest.fn().mockReturnValue({\n        name: 'test-entity',\n        columns: [],\n        relations: [],\n        findInheritanceMetadata: jest.fn(),\n        findColumnWithPropertyPath: jest.fn(),\n      }),\n      createQueryBuilder: jest.fn().mockReturnValue({\n        delete: jest.fn().mockReturnThis(),\n        from: jest.fn().mockReturnThis(),\n        where: jest.fn().mockReturnThis(),\n        execute: jest\n          .fn()\n          .mockResolvedValue({ affected: 1, raw: [], generatedMaps: [] }),\n        getMany: jest.fn().mockResolvedValue([]),\n        getOne: jest.fn().mockResolvedValue(null),\n        getManyAndCount: jest.fn().mockResolvedValue([[], 0]),\n        update: jest.fn().mockReturnThis(),\n        softDelete: jest.fn().mockReturnThis(),\n        restore: jest.fn().mockReturnThis(),\n      }),\n      createQueryRunner: jest.fn().mockReturnValue({\n        connect: jest.fn(),\n        startTransaction: jest.fn(),\n        commitTransaction: jest.fn(),\n        rollbackTransaction: jest.fn(),\n        release: jest.fn(),\n        clearTable: jest.fn(),\n      }),\n      createQueryRunnerForEntityPersistExecutor: jest.fn().mockReturnValue({\n        connect: jest.fn(),\n        startTransaction: jest.fn(),\n        commitTransaction: jest.fn(),\n        rollbackTransaction: jest.fn(),\n        release: jest.fn(),\n        clearTable: jest.fn(),\n      }),\n    };\n\n    entityManager = new WorkspaceEntityManager(\n      mockInternalContext,\n      mockDataSource,\n    );\n\n    Object.defineProperty(entityManager, 'connection', {\n      get: () => mockWorkspaceDataSource,\n    });\n\n    jest.spyOn(entityManager as any, 'validatePermissions');\n    jest.spyOn(entityManager as any, 'createQueryBuilder');\n    jest\n      .spyOn(entityManager as any, 'getFormattedResultWithoutNonReadableFields')\n      .mockImplementation(\n        ({ formattedResult }: { formattedResult: string[] }) => formattedResult,\n      );\n\n    jest\n      .spyOn(entityManager as any, 'extractTargetNameSingularFromEntityTarget')\n      .mockImplementation((entityName: string) => {\n        return entityName;\n      });\n\n    // Mock typeORM's EntityManager methods\n    jest\n      .spyOn(EntityManager.prototype, 'save')\n      .mockImplementation(() => Promise.resolve({}));\n    jest\n      .spyOn(EntityManager.prototype, 'update')\n      .mockImplementation(() =>\n        Promise.resolve({ affected: 1, raw: [], generatedMaps: [] }),\n      );\n    jest\n      .spyOn(EntityManager.prototype, 'restore')\n      .mockImplementation(() =>\n        Promise.resolve({ affected: 1, raw: [], generatedMaps: [] }),\n      );\n    jest\n      .spyOn(EntityManager.prototype, 'clear')\n      .mockImplementation(() => Promise.resolve());\n    jest\n      .spyOn(EntityManager.prototype, 'preload')\n      .mockImplementation(() => Promise.resolve({}));\n\n    jest\n      .spyOn(EntityPersistExecutor.prototype, 'execute')\n      .mockImplementation(() => Promise.resolve());\n\n    jest\n      .spyOn(PlainObjectToDatabaseEntityTransformer.prototype, 'transform')\n      .mockImplementation(() => Promise.resolve({}));\n\n    // Mock metadata methods\n    const mockMetadata = {\n      hasAllPrimaryKeys: jest.fn().mockReturnValue(true),\n      columns: [],\n      relations: [],\n      findInheritanceMetadata: jest.fn(),\n      findColumnWithPropertyPath: jest.fn(),\n    };\n\n    // Update mockWorkspaceDataSource to include metadata\n    mockWorkspaceDataSource.getMetadata = jest\n      .fn()\n      .mockReturnValue(mockMetadata);\n\n    // Reset the mock before each test\n    jest.clearAllMocks();\n  });\n\n  describe('Query Method', () => {\n    it('should call validatePermissions and validateOperationIsPermittedOrThrow for find', async () => {\n      await entityManager.find('test-entity', {}, mockPermissionOptions);\n\n      expect(entityManager.createQueryBuilder).toHaveBeenCalledWith(\n        'test-entity',\n        undefined,\n        undefined,\n        mockPermissionOptions,\n      );\n    });\n    it('should throw error for query', async () => {\n      expect(() => entityManager.query('SELECT * FROM test')).toThrow(\n        'Method not allowed.',\n      );\n    });\n  });\n\n  describe('Save Methods', () => {\n    it('should call validatePermissions and validateOperationIsPermittedOrThrow for save', async () => {\n      await entityManager.save(\n        'test-entity',\n        {},\n        { reload: false },\n        mockPermissionOptions,\n      );\n      expect(entityManager['validatePermissions']).toHaveBeenCalledWith({\n        target: 'test-entity',\n        operationType: 'update',\n        permissionOptions: mockPermissionOptions,\n        selectedColumns: [],\n        updatedColumns: [],\n      });\n      expect(validateOperationIsPermittedOrThrow).toHaveBeenCalledWith({\n        entityName: 'test-entity',\n        operationType: 'update',\n        flatObjectMetadataMaps: mockInternalContext.flatObjectMetadataMaps,\n        flatFieldMetadat",
            "cost": 0.13212000000000002
        },
        "twentyhq__twenty.main/packages/twenty-server/src/engine/twenty-orm/utils/compute-relation-connect-query-configs.util.ts": {
            "output": "import { msg } from '@lingui/core/macro';\nimport deepEqual from 'deep-equal';\nimport { FieldMetadataType } from 'twenty-shared/types';\nimport { getUniqueConstraintsFields, isDefined } from 'twenty-shared/utils';\n\nimport { RelationType } from 'src/engine/metadata-modules/field-metadata/interfaces/relation-type.interface';\n\nimport { getFlatFieldsFromFlatObjectMetadata } from 'src/engine/api/graphql/workspace-schema-builder/utils/get-flat-fields-for-flat-object-metadata.util';\nimport { isCompositeFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-composite-field-metadata-type.util';\nimport { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\nimport { type FlatIndexMetadata } from 'src/engine/metadata-modules/flat-index-metadata/types/flat-index-metadata.type';\nimport { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\nimport { type ConnectObject } from 'src/engine/twenty-orm/entity-manager/types/query-deep-partial-entity-with-nested-relation-fields.type';\nimport {\n  type RelationConnectQueryConfig,\n  type UniqueConstraintCondition,\n} from 'src/engine/twenty-orm/entity-manager/types/relation-connect-query-config.type';\nimport { type RelationConnectQueryFieldsByEntityIndex } from 'src/engine/twenty-orm/entity-manager/types/relation-nested-query-fields-by-entity-index.type';\nimport {\n  TwentyORMException,\n  TwentyORMExceptionCode,\n} from 'src/engine/twenty-orm/exceptions/twenty-orm.exception';\nimport { formatCompositeField } from 'src/engine/twenty-orm/utils/format-data.util';\nimport { getAssociatedRelationFieldName } from 'src/engine/twenty-orm/utils/get-associated-relation-field-name.util';\nimport { isFieldMetadataEntityOfType } from 'src/engine/utils/is-field-metadata-of-type.util';\n\nexport const computeRelationConnectQueryConfigs = (\n  entities: Record<string, unknown>[],\n  flatObjectMetadata: FlatObjectMetadata,\n  flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n  flatIndexMaps: FlatEntityMaps<FlatIndexMetadata>,\n  relationConnectQueryFieldsByEntityIndex: RelationConnectQueryFieldsByEntityIndex,\n) => {\n  const allConnectQueryConfigs: Record<string, RelationConnectQueryConfig> = {};\n\n  for (const [entityIndex, entity] of entities.entries()) {\n    const nestedRelationConnectFields =\n      relationConnectQueryFieldsByEntityIndex[entityIndex];\n\n    if (!isDefined(nestedRelationConnectFields)) continue;\n\n    for (const [connectFieldName, connectObject] of Object.entries(\n      nestedRelationConnectFields,\n    )) {\n      const {\n        recordToConnectCondition,\n        uniqueConstraintFields,\n        targetObjectNameSingular,\n      } = computeRecordToConnectCondition(\n        connectFieldName,\n        connectObject,\n        flatObjectMetadata,\n        flatObjectMetadataMaps,\n        flatFieldMetadataMaps,\n        flatIndexMaps,\n        entity,\n      );\n\n      const connectQueryConfig = allConnectQueryConfigs[connectFieldName];\n\n      if (isDefined(connectQueryConfig)) {\n        checkUniqueConstraintsAreSameOrThrow(\n          connectQueryConfig,\n          uniqueConstraintFields,\n        );\n\n        allConnectQueryConfigs[connectFieldName] = updateConnectQueryConfigs(\n          connectQueryConfig,\n          recordToConnectCondition,\n          entityIndex,\n        );\n      } else {\n        allConnectQueryConfigs[connectFieldName] = createConnectQueryConfig(\n          connectFieldName,\n          recordToConnectCondition,\n          uniqueConstraintFields,\n          targetObjectNameSingular,\n          entityIndex,\n        );\n      }\n    }\n  }\n\n  return Object.values(allConnectQueryConfigs);\n};\n\nconst updateConnectQueryConfigs = (\n  connectQueryConfig: RelationConnectQueryConfig,\n  recordToConnectCondition: UniqueConstraintCondition,\n  entityIndex: number,\n) => {\n  return {\n    ...connectQueryConfig,\n    recordToConnectConditions: [\n      ...connectQueryConfig.recordToConnectConditions,\n      recordToConnectCondition,\n    ],\n    recordToConnectConditionByEntityIndex: {\n      ...connectQueryConfig.recordToConnectConditionByEntityIndex,\n      [entityIndex]: recordToConnectCondition,\n    },\n  };\n};\n\nconst createConnectQueryConfig = (\n  connectFieldName: string,\n  recordToConnectCondition: UniqueConstraintCondition,\n  uniqueConstraintFields: FlatFieldMetadata<FieldMetadataType>[],\n  targetObjectNameSingular: string,\n  entityIndex: number,\n) => {\n  return {\n    targetObjectName: targetObjectNameSingular,\n    recordToConnectConditions: [recordToConnectCondition],\n    relationFieldName: getAssociatedRelationFieldName(connectFieldName),\n    connectFieldName,\n    uniqueConstraintFields,\n    recordToConnectConditionByEntityIndex: {\n      [entityIndex]: recordToConnectCondition,\n    },\n  };\n};\n\nconst computeRecordToConnectCondition = (\n  connectFieldName: string,\n  connectObject: ConnectObject,\n  flatObjectMetadata: FlatObjectMetadata,\n  flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n  flatIndexMaps: FlatEntityMaps<FlatIndexMetadata>,\n  entity: Record<string, unknown>,\n): {\n  recordToConnectCondition: UniqueConstraintCondition;\n  uniqueConstraintFields: FlatFieldMetadata<FieldMetadataType>[];\n  targetObjectNameSingular: string;\n} => {\n  const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n    flatFieldMetadataMaps,\n    flatObjectMetadata,\n  );\n\n  const field = flatFieldMetadataMaps.byId[fieldIdByName[connectFieldName]];\n\n  if (\n    !isDefined(field) ||\n    (!isFieldMetadataEntityOfType(field, FieldMetadataType.RELATION) &&\n      !isFieldMetadataEntityOfType(field, FieldMetadataType.MORPH_RELATION)) ||\n    field.settings?.relationType !== RelationType.MANY_TO_ONE\n  ) {\n    const objectMetadataNameSingular = flatObjectMetadata.nameSingular;\n\n    throw new TwentyORMException(\n      `Connect is not allowed for ${connectFieldName} on ${flatObjectMetadata.nameSingular}`,\n      TwentyORMExceptionCode.CONNECT_NOT_ALLOWED,\n      {\n        userFriendlyMessage: msg`Connect is not allowed for ${connectFieldName} on ${objectMetadataNameSingular}`,\n      },\n    );\n  }\n  checkNoRelationFieldConflictOrThrow(entity, connectFieldName);\n\n  const targetObjectMetadata =\n    flatObjectMetadataMaps.byId[field.relationTargetObjectMetadataId || ''];\n\n  if (!isDefined(targetObjectMetadata)) {\n    throw new TwentyORMException(\n      `Target object metadata not found for ${connectFieldName}`,\n      TwentyORMExceptionCode.MALFORMED_METADATA,\n      {\n        userFriendlyMessage: msg`Target object metadata not found for ${connectFieldName}`,\n      },\n    );\n  }\n\n  const uniqueConstraintFields = checkUniqueConstraintFullyPopulated(\n    targetObjectMetadata,\n    flatFieldMetadataMaps,\n    flatIndexMaps,\n    connectObject,\n    connectFieldName,\n  );\n\n  return {\n    recordToConnectCondition: computeUniqueConstraintCondition(\n      uniqueConstraintFields,\n      connectObject,\n    ),\n    uniqueConstraintFields,\n    targetObjectNameSingular: targetObjectMetadata.nameSingular,\n  };\n};\n\nconst checkUniqueConstraintFullyPopulated = (\n  flatObjectMetadata: FlatObjectMetadata,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n  flatIndexMaps: FlatEntityMaps<FlatIndexMetadata>,\n  connectObject: ConnectObject,\n  connectFieldName: string,\n) => {\n  const fields = getFlatFieldsFromFlatObjectMetadata(\n    flatObjectMetadata,\n    flatFieldMetadataMaps,\n  );\n\n  const indexMetadatas = flatObjectMetadata.indexMetadataIds\n    .map((indexId) => flatIndexMaps.byId[indexId])\n    .filter(isDefined)\n    .map((index) => ({\n      id: index.id,\n      isUnique: index.isUnique,\n      indexFieldMetadatas: index.flatIndexFieldMetadatas.map(\n        (fieldMetadata) => ({\n          fieldMetadataId: fieldMetadata.fieldMetadataId,\n        }),\n      ),\n    }));\n\n  const uniqueConstraintsFields = getUniqueConstraintsFields<\n    FlatFieldMetadata,\n    {\n      id: string;\n      indexMetadatas: typeof indexMetadatas;\n      fields: FlatFieldMetadata[];\n    }\n  >({\n    id: flatObjectMetadata.id,\n    indexMetadatas,\n    fields,\n  });\n\n  const hasUniqueConstraintFieldFullyPopulated = uniqueConstraintsFields.some(\n    (uniqueConstraintFields) =>\n      uniqueConstraintFields.every((uniqueConstraintField) =>\n        isDefined(connectObject.connect.where[uniqueConstraintField.name]),\n      ),\n  );\n\n  if (!hasUniqueConstraintFieldFullyPopulated) {\n    throw new TwentyORMException(\n      `Missing required fields: at least one unique constraint have to be fully populated for '${connectFieldName}'.`,\n      TwentyORMExceptionCode.CONNECT_UNIQUE_CONSTRAINT_ERROR,\n      {\n        userFriendlyMessage: msg`Missing required fields: at least one unique constraint have to be fully populated for '${connectFieldName}'.`,\n      },\n    );\n  }\n\n  return Object.keys(connectObject.connect.where).map((key) => {\n    const field = uniqueConstraintsFields\n      .flat()\n      .find((uniqueConstraintField) => uniqueConstraintField.name === key);\n\n    if (!isDefined(field)) {\n      throw new TwentyORMException(\n        `Field ${key} is not a unique constraint field for '${connectFieldName}'.`,\n        TwentyORMExceptionCode.CONNECT_UNIQUE_CONSTRAINT_ERROR,\n      );\n    }\n\n    return field;\n  });\n};\n\nconst checkNoRelationFieldConflictOrThrow = (\n  entity: Record<string, unknown>,\n  fieldName: string,\n) => {\n  const hasRelationFieldConflict =\n    isDefined(entity[fieldName]) && isDefined(entity[`${fieldName}Id`]);\n\n  if (hasRelationFieldConflict) {\n    throw new TwentyORMException(\n      `${fieldName} and ${fieldName}Id cannot be both provided.`,\n      TwentyORMExceptionCode.CONNECT_NOT_ALLOWED,\n      {\n        userFriendlyMessage: msg`${fieldName} and ${fieldName}Id cannot be both provided.`,\n      },\n    );\n  }\n};\n\nconst computeUniqueConstraintCondition = (\n  uniqueConstraintFields: FlatFieldMetadata<FieldMetadataType>[],\n  connectObject: ConnectObject,\n): UniqueConstraintCondition => {\n  return uniqueConstraintFields.reduce((acc, uniqueConstraintField) => {\n    if (isCompositeFieldMetadataType(uniqueConstraintField.type)) {\n      return [\n        ...acc,\n        ...Object.entries(\n          formatCompositeField(\n            connectObject.connect.where[uniqueConstraintField.name],\n            uniqueConstraintField,\n          ),\n        ),\n      ];\n    }\n\n    return [\n      ...acc,\n      [\n        uniqueConstraintField.name,\n        connectObject.connect.where[uniqueConstraintField.name],\n      ],\n    ];\n  }, []);\n};\n\nconst checkUniqueConstraintsAreSameOrThrow = (\n  relationConnectQueryConfig: RelationConnectQueryConfig,\n  uniqueConstraintFields: FlatFieldMetadata<FieldMetadataType>[],\n) => {\n  if (\n    !deepEqual(\n      relationConnectQueryConfig.uniqueConstraintFields,\n      uniqueConstraintFields,\n    )\n  ) {\n    const connectFieldName = relationConnectQueryConfig.connectFieldName;\n\n    throw new TwentyORMException(\n      `Expected the same constraint fields to be used consistently across all operations for ${relationConnectQueryConfig.connectFieldName}.`,\n      TwentyORMExceptionCode.CONNECT_UNIQUE_CONSTRAINT_ERROR,\n      {\n        userFriendlyMessage: msg`Expected the same constraint fields to be used consistently across all operations for ${connectFieldName}.`,\n      },\n    );\n  }\n};",
            "output_extracted": "import { msg } from '@lingui/core/macro';\nimport deepEqual from 'deep-equal';\nimport { FieldMetadataType } from 'twenty-shared/types';\nimport { getUniqueConstraintsFields, isDefined } from 'twenty-shared/utils';\n\nimport { RelationType } from 'src/engine/metadata-modules/field-metadata/interfaces/relation-type.interface';\n\nimport { getFlatFieldsFromFlatObjectMetadata } from 'src/engine/api/graphql/workspace-schema-builder/utils/get-flat-fields-for-flat-object-metadata.util';\nimport { isCompositeFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-composite-field-metadata-type.util';\nimport { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\nimport { type FlatIndexMetadata } from 'src/engine/metadata-modules/flat-index-metadata/types/flat-index-metadata.type';\nimport { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\nimport { type ConnectObject } from 'src/engine/twenty-orm/entity-manager/types/query-deep-partial-entity-with-nested-relation-fields.type';\nimport {\n  type RelationConnectQueryConfig,\n  type UniqueConstraintCondition,\n} from 'src/engine/twenty-orm/entity-manager/types/relation-connect-query-config.type';\nimport { type RelationConnectQueryFieldsByEntityIndex } from 'src/engine/twenty-orm/entity-manager/types/relation-nested-query-fields-by-entity-index.type';\nimport {\n  TwentyORMException,\n  TwentyORMExceptionCode,\n} from 'src/engine/twenty-orm/exceptions/twenty-orm.exception';\nimport { formatCompositeField } from 'src/engine/twenty-orm/utils/format-data.util';\nimport { getAssociatedRelationFieldName } from 'src/engine/twenty-orm/utils/get-associated-relation-field-name.util';\nimport { isFieldMetadataEntityOfType } from 'src/engine/utils/is-field-metadata-of-type.util';\n\nexport const computeRelationConnectQueryConfigs = (\n  entities: Record<string, unknown>[],\n  flatObjectMetadata: FlatObjectMetadata,\n  flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n  flatIndexMaps: FlatEntityMaps<FlatIndexMetadata>,\n  relationConnectQueryFieldsByEntityIndex: RelationConnectQueryFieldsByEntityIndex,\n) => {\n  const allConnectQueryConfigs: Record<string, RelationConnectQueryConfig> = {};\n\n  for (const [entityIndex, entity] of entities.entries()) {\n    const nestedRelationConnectFields =\n      relationConnectQueryFieldsByEntityIndex[entityIndex];\n\n    if (!isDefined(nestedRelationConnectFields)) continue;\n\n    for (const [connectFieldName, connectObject] of Object.entries(\n      nestedRelationConnectFields,\n    )) {\n      const {\n        recordToConnectCondition,\n        uniqueConstraintFields,\n        targetObjectNameSingular,\n      } = computeRecordToConnectCondition(\n        connectFieldName,\n        connectObject,\n        flatObjectMetadata,\n        flatObjectMetadataMaps,\n        flatFieldMetadataMaps,\n        flatIndexMaps,\n        entity,\n      );\n\n      const connectQueryConfig = allConnectQueryConfigs[connectFieldName];\n\n      if (isDefined(connectQueryConfig)) {\n        checkUniqueConstraintsAreSameOrThrow(\n          connectQueryConfig,\n          uniqueConstraintFields,\n        );\n\n        allConnectQueryConfigs[connectFieldName] = updateConnectQueryConfigs(\n          connectQueryConfig,\n          recordToConnectCondition,\n          entityIndex,\n        );\n      } else {\n        allConnectQueryConfigs[connectFieldName] = createConnectQueryConfig(\n          connectFieldName,\n          recordToConnectCondition,\n          uniqueConstraintFields,\n          targetObjectNameSingular,\n          entityIndex,\n        );\n      }\n    }\n  }\n\n  return Object.values(allConnectQueryConfigs);\n};\n\nconst updateConnectQueryConfigs = (\n  connectQueryConfig: RelationConnectQueryConfig,\n  recordToConnectCondition: UniqueConstraintCondition,\n  entityIndex: number,\n) => {\n  return {\n    ...connectQueryConfig,\n    recordToConnectConditions: [\n      ...connectQueryConfig.recordToConnectConditions,\n      recordToConnectCondition,\n    ],\n    recordToConnectConditionByEntityIndex: {\n      ...connectQueryConfig.recordToConnectConditionByEntityIndex,\n      [entityIndex]: recordToConnectCondition,\n    },\n  };\n};\n\nconst createConnectQueryConfig = (\n  connectFieldName: string,\n  recordToConnectCondition: UniqueConstraintCondition,\n  uniqueConstraintFields: FlatFieldMetadata<FieldMetadataType>[],\n  targetObjectNameSingular: string,\n  entityIndex: number,\n) => {\n  return {\n    targetObjectName: targetObjectNameSingular,\n    recordToConnectConditions: [recordToConnectCondition],\n    relationFieldName: getAssociatedRelationFieldName(connectFieldName),\n    connectFieldName,\n    uniqueConstraintFields,\n    recordToConnectConditionByEntityIndex: {\n      [entityIndex]: recordToConnectCondition,\n    },\n  };\n};\n\nconst computeRecordToConnectCondition = (\n  connectFieldName: string,\n  connectObject: ConnectObject,\n  flatObjectMetadata: FlatObjectMetadata,\n  flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n  flatIndexMaps: FlatEntityMaps<FlatIndexMetadata>,\n  entity: Record<string, unknown>,\n): {\n  recordToConnectCondition: UniqueConstraintCondition;\n  uniqueConstraintFields: FlatFieldMetadata<FieldMetadataType>[];\n  targetObjectNameSingular: string;\n} => {\n  const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n    flatFieldMetadataMaps,\n    flatObjectMetadata,\n  );\n\n  const field = flatFieldMetadataMaps.byId[fieldIdByName[connectFieldName]];\n\n  if (\n    !isDefined(field) ||\n    (!isFieldMetadataEntityOfType(field, FieldMetadataType.RELATION) &&\n      !isFieldMetadataEntityOfType(field, FieldMetadataType.MORPH_RELATION)) ||\n    field.settings?.relationType !== RelationType.MANY_TO_ONE\n  ) {\n    const objectMetadataNameSingular = flatObjectMetadata.nameSingular;\n\n    throw new TwentyORMException(\n      `Connect is not allowed for ${connectFieldName} on ${flatObjectMetadata.nameSingular}`,\n      TwentyORMExceptionCode.CONNECT_NOT_ALLOWED,\n      {\n        userFriendlyMessage: msg`Connect is not allowed for ${connectFieldName} on ${objectMetadataNameSingular}`,\n      },\n    );\n  }\n  checkNoRelationFieldConflictOrThrow(entity, connectFieldName);\n\n  const targetObjectMetadata =\n    flatObjectMetadataMaps.byId[field.relationTargetObjectMetadataId || ''];\n\n  if (!isDefined(targetObjectMetadata)) {\n    throw new TwentyORMException(\n      `Target object metadata not found for ${connectFieldName}`,\n      TwentyORMExceptionCode.MALFORMED_METADATA,\n      {\n        userFriendlyMessage: msg`Target object metadata not found for ${connectFieldName}`,\n      },\n    );\n  }\n\n  const uniqueConstraintFields = checkUniqueConstraintFullyPopulated(\n    targetObjectMetadata,\n    flatFieldMetadataMaps,\n    flatIndexMaps,\n    connectObject,\n    connectFieldName,\n  );\n\n  return {\n    recordToConnectCondition: computeUniqueConstraintCondition(\n      uniqueConstraintFields,\n      connectObject,\n    ),\n    uniqueConstraintFields,\n    targetObjectNameSingular: targetObjectMetadata.nameSingular,\n  };\n};\n\nconst checkUniqueConstraintFullyPopulated = (\n  flatObjectMetadata: FlatObjectMetadata,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n  flatIndexMaps: FlatEntityMaps<FlatIndexMetadata>,\n  connectObject: ConnectObject,\n  connectFieldName: string,\n) => {\n  const fields = getFlatFieldsFromFlatObjectMetadata(\n    flatObjectMetadata,\n    flatFieldMetadataMaps,\n  );\n\n  const indexMetadatas = flatObjectMetadata.indexMetadataIds\n    .map((indexId) => flatIndexMaps.byId[indexId])\n    .filter(isDefined)\n    .map((index) => ({\n      id: index.id,\n      isUnique: index.isUnique,\n      indexFieldMetadatas: index.flatIndexFieldMetadatas.map(\n        (fieldMetadata) => ({\n          fieldMetadataId: fieldMetadata.fieldMetadataId,\n        }),\n      ),\n    }));\n\n  const uniqueConstraintsFields = getUniqueConstraintsFields<\n    FlatFieldMetadata,\n    {\n      id: string;\n      indexMetadatas: typeof indexMetadatas;\n      fields: FlatFieldMetadata[];\n    }\n  >({\n    id: flatObjectMetadata.id,\n    indexMetadatas,\n    fields,\n  });\n\n  const hasUniqueConstraintFieldFullyPopulated = uniqueConstraintsFields.some(\n    (uniqueConstraintFields) =>\n      uniqueConstraintFields.every((uniqueConstraintField) =>\n        isDefined(connectObject.connect.where[uniqueConstraintField.name]),\n      ),\n  );\n\n  if (!hasUniqueConstraintFieldFullyPopulated) {\n    throw new TwentyORMException(\n      `Missing required fields: at least one unique constraint have to be fully populated for '${connectFieldName}'.`,\n      TwentyORMExceptionCode.CONNECT_UNIQUE_CONSTRAINT_ERROR,\n      {\n        userFriendlyMessage: msg`Missing required fields: at least one unique constraint have to be fully populated for '${connectFieldName}'.`,\n      },\n    );\n  }\n\n  return Object.keys(connectObject.connect.where).map((key) => {\n    const field = uniqueConstraintsFields\n      .flat()\n      .find((uniqueConstraintField) => uniqueConstraintField.name === key);\n\n    if (!isDefined(field)) {\n      throw new TwentyORMException(\n        `Field ${key} is not a unique constraint field for '${connectFieldName}'.`,\n        TwentyORMExceptionCode.CONNECT_UNIQUE_CONSTRAINT_ERROR,\n      );\n    }\n\n    return field;\n  });\n};\n\nconst checkNoRelationFieldConflictOrThrow = (\n  entity: Record<string, unknown>,\n  fieldName: string,\n) => {\n  const hasRelationFieldConflict =\n    isDefined(entity[fieldName]) && isDefined(entity[`${fieldName}Id`]);\n\n  if (hasRelationFieldConflict) {\n    throw new TwentyORMException(\n      `${fieldName} and ${fieldName}Id cannot be both provided.`,\n      TwentyORMExceptionCode.CONNECT_NOT_ALLOWED,\n      {\n        userFriendlyMessage: msg`${fieldName} and ${fieldName}Id cannot be both provided.`,\n      },\n    );\n  }\n};\n\nconst computeUniqueConstraintCondition = (\n  uniqueConstraintFields: FlatFieldMetadata<FieldMetadataType>[],\n  connectObject: ConnectObject,\n): UniqueConstraintCondition => {\n  return uniqueConstraintFields.reduce((acc, uniqueConstraintField) => {\n    if (isCompositeFieldMetadataType(uniqueConstraintField.type)) {\n      return [\n        ...acc,\n        ...Object.entries(\n          formatCompositeField(\n            connectObject.connect.where[uniqueConstraintField.name],\n            uniqueConstraintField,\n          ),\n        ),\n      ];\n    }\n\n    return [\n      ...acc,\n      [\n        uniqueConstraintField.name,\n        connectObject.connect.where[uniqueConstraintField.name],\n      ],\n    ];\n  }, []);\n};\n\nconst checkUniqueConstraintsAreSameOrThrow = (\n  relationConnectQueryConfig: RelationConnectQueryConfig,\n  uniqueConstraintFields: FlatFieldMetadata<FieldMetadataType>[],\n) => {\n  if (\n    !deepEqual(\n      relationConnectQueryConfig.uniqueConstraintFields,\n      uniqueConstraintFields,\n    )\n  ) {\n    const connectFieldName = relationConnectQueryConfig.connectFieldName;\n\n    throw new TwentyORMException(\n      `Expected the same constraint fields to be used consistently across all operations for ${relationConnectQueryConfig.connectFieldName}.`,\n      TwentyORMExceptionCode.CONNECT_UNIQUE_CONSTRAINT_ERROR,\n      {\n        userFriendlyMessage: msg`Expected the same constraint fields to be used consistently across all operations for ${connectFieldName}.`,\n      },\n    );\n  }\n};",
            "cost": 0.11570000000000001
        },
        "twentyhq__twenty.main/packages/twenty-server/src/engine/twenty-orm/utils/format-data.util.ts": {
            "output": "import {\n  FieldMetadataType,\n  compositeTypeDefinitions,\n} from 'twenty-shared/types';\nimport { capitalize } from 'twenty-shared/utils';\n\nimport { isCompositeFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-composite-field-metadata-type.util';\nimport { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\nimport { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\nimport { type CompositeFieldMetadataType } from 'src/engine/metadata-modules/workspace-migration/factories/composite-column-action.factory';\n\nexport function formatData<T>(\n  data: T,\n  flatObjectMetadata: FlatObjectMetadata,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n): T {\n  if (!data) {\n    return data;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map((item) =>\n      formatData(item, flatObjectMetadata, flatFieldMetadataMaps),\n    ) as T;\n  }\n\n  const { fieldIdByName, fieldIdByJoinColumnName } =\n    buildFieldMapsFromFlatObjectMetadata(\n      flatFieldMetadataMaps,\n      flatObjectMetadata,\n    );\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const newData: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(data)) {\n    const fieldMetadataId = fieldIdByName[key] || fieldIdByJoinColumnName[key];\n\n    const fieldMetadata = flatFieldMetadataMaps.byId[fieldMetadataId];\n\n    if (!fieldMetadata) {\n      throw new Error(\n        `Field metadata for field \"${key}\" is missing in object metadata ${flatObjectMetadata.nameSingular}`,\n      );\n    }\n\n    if (isCompositeFieldMetadataType(fieldMetadata.type)) {\n      const formattedCompositeField = formatCompositeField(\n        value,\n        fieldMetadata,\n      );\n\n      Object.assign(newData, formattedCompositeField);\n    } else {\n      newData[key] = formatFieldMetadataValue(value, fieldMetadata);\n    }\n  }\n\n  return newData as T;\n}\n\nexport function formatCompositeField(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  fieldMetadata: FlatFieldMetadata,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any> {\n  const compositeType = compositeTypeDefinitions.get(\n    fieldMetadata.type as CompositeFieldMetadataType,\n  );\n\n  if (!compositeType) {\n    throw new Error(\n      `Composite type definition not found for type: ${fieldMetadata.type}`,\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const formattedCompositeField: Record<string, any> = {};\n\n  for (const property of compositeType.properties) {\n    const subFieldKey = property.name;\n    const fullFieldName = `${fieldMetadata.name}${capitalize(subFieldKey)}`;\n\n    if (value && value[subFieldKey] !== undefined) {\n      formattedCompositeField[fullFieldName] = formatFieldMetadataValue(\n        value[subFieldKey],\n        property as unknown as FlatFieldMetadata,\n      );\n    }\n  }\n\n  return formattedCompositeField;\n}\n\nfunction formatFieldMetadataValue(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  fieldMetadata: FlatFieldMetadata,\n) {\n  if (\n    fieldMetadata.type === FieldMetadataType.RAW_JSON &&\n    typeof value === 'string'\n  ) {\n    return JSON.parse(value as string);\n  }\n\n  return value;\n}",
            "output_extracted": "import {\n  FieldMetadataType,\n  compositeTypeDefinitions,\n} from 'twenty-shared/types';\nimport { capitalize } from 'twenty-shared/utils';\n\nimport { isCompositeFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-composite-field-metadata-type.util';\nimport { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\nimport { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\nimport { type CompositeFieldMetadataType } from 'src/engine/metadata-modules/workspace-migration/factories/composite-column-action.factory';\n\nexport function formatData<T>(\n  data: T,\n  flatObjectMetadata: FlatObjectMetadata,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n): T {\n  if (!data) {\n    return data;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map((item) =>\n      formatData(item, flatObjectMetadata, flatFieldMetadataMaps),\n    ) as T;\n  }\n\n  const { fieldIdByName, fieldIdByJoinColumnName } =\n    buildFieldMapsFromFlatObjectMetadata(\n      flatFieldMetadataMaps,\n      flatObjectMetadata,\n    );\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const newData: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(data)) {\n    const fieldMetadataId = fieldIdByName[key] || fieldIdByJoinColumnName[key];\n\n    const fieldMetadata = flatFieldMetadataMaps.byId[fieldMetadataId];\n\n    if (!fieldMetadata) {\n      throw new Error(\n        `Field metadata for field \"${key}\" is missing in object metadata ${flatObjectMetadata.nameSingular}`,\n      );\n    }\n\n    if (isCompositeFieldMetadataType(fieldMetadata.type)) {\n      const formattedCompositeField = formatCompositeField(\n        value,\n        fieldMetadata,\n      );\n\n      Object.assign(newData, formattedCompositeField);\n    } else {\n      newData[key] = formatFieldMetadataValue(value, fieldMetadata);\n    }\n  }\n\n  return newData as T;\n}\n\nexport function formatCompositeField(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  fieldMetadata: FlatFieldMetadata,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any> {\n  const compositeType = compositeTypeDefinitions.get(\n    fieldMetadata.type as CompositeFieldMetadataType,\n  );\n\n  if (!compositeType) {\n    throw new Error(\n      `Composite type definition not found for type: ${fieldMetadata.type}`,\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const formattedCompositeField: Record<string, any> = {};\n\n  for (const property of compositeType.properties) {\n    const subFieldKey = property.name;\n    const fullFieldName = `${fieldMetadata.name}${capitalize(subFieldKey)}`;\n\n    if (value && value[subFieldKey] !== undefined) {\n      formattedCompositeField[fullFieldName] = formatFieldMetadataValue(\n        value[subFieldKey],\n        property as unknown as FlatFieldMetadata,\n      );\n    }\n  }\n\n  return formattedCompositeField;\n}\n\nfunction formatFieldMetadataValue(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  fieldMetadata: FlatFieldMetadata,\n) {\n  if (\n    fieldMetadata.type === FieldMetadataType.RAW_JSON &&\n    typeof value === 'string'\n  ) {\n    return JSON.parse(value as string);\n  }\n\n  return value;\n}",
            "cost": 0.042550000000000004
        },
        "twentyhq__twenty.main/packages/twenty-server/src/engine/twenty-orm/utils/format-result.util.ts": {
            "output": "import { isPlainObject } from '@nestjs/common/utils/shared.utils';\n\nimport { isNull } from '@sniptt/guards';\nimport {\n  FieldMetadataType,\n  compositeTypeDefinitions,\n} from 'twenty-shared/types';\nimport { isDefined } from 'twenty-shared/utils';\n\nimport {\n  DEFAULT_ARRAY_FIELD_NULL_EQUIVALENT_VALUE,\n  DEFAULT_COMPOSITE_FIELDS_NULL_EQUIVALENT_VALUE,\n  DEFAULT_TEXT_FIELD_NULL_EQUIVALENT_VALUE,\n} from 'src/engine/api/common/common-args-processors/data-arg-processor/constants/null-equivalent-values.constant';\nimport { getFlatFieldsFromFlatObjectMetadata } from 'src/engine/api/graphql/workspace-schema-builder/utils/get-flat-fields-for-flat-object-metadata.util';\nimport { computeCompositeColumnName } from 'src/engine/metadata-modules/field-metadata/utils/compute-column-name.util';\nimport { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\nimport { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\nimport { getCompositeFieldMetadataCollection } from 'src/engine/twenty-orm/utils/get-composite-field-metadata-collection';\nimport { isFieldMetadataEntityOfType } from 'src/engine/utils/is-field-metadata-of-type.util';\n\nexport function formatResult<T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data: any,\n  flatObjectMetadata: FlatObjectMetadata | undefined,\n  flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n): T {\n  if (!isDefined(data)) {\n    return data;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map((item) =>\n      formatResult(\n        item,\n        flatObjectMetadata,\n        flatObjectMetadataMaps,\n        flatFieldMetadataMaps,\n      ),\n    ) as T;\n  }\n\n  if (!isPlainObject(data)) {\n    return data;\n  }\n\n  if (!flatObjectMetadata) {\n    throw new Error('Object metadata is missing');\n  }\n\n  const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n    flatFieldMetadataMaps,\n    flatObjectMetadata,\n  );\n\n  const compositeFieldMetadataMap = getCompositeFieldMetadataMap(\n    flatObjectMetadata,\n    flatFieldMetadataMaps,\n  );\n\n  const newData: object = {};\n\n  for (const [key, value] of Object.entries(data)) {\n    const compositePropertyArgs = compositeFieldMetadataMap.get(key);\n\n    const fieldMetadataId =\n      fieldIdByName[key] ||\n      fieldIdByName[compositePropertyArgs?.parentField ?? ''];\n\n    const fieldMetadata = flatFieldMetadataMaps.byId[fieldMetadataId] as\n      | FlatFieldMetadata<FieldMetadataType>\n      | undefined;\n\n    const isRelation = fieldMetadata\n      ? isFieldMetadataEntityOfType(fieldMetadata, FieldMetadataType.RELATION)\n      : false;\n\n    if (!compositePropertyArgs && !isRelation) {\n      if (isPlainObject(value)) {\n        // @ts-expect-error legacy noImplicitAny\n        newData[key] = formatResult(\n          value,\n          flatObjectMetadata,\n          flatObjectMetadataMaps,\n          flatFieldMetadataMaps,\n        );\n      } else if (fieldMetadata) {\n        // @ts-expect-error legacy noImplicitAny\n        newData[key] = formatFieldMetadataValue(value, fieldMetadata.type);\n      } else {\n        // @ts-expect-error legacy noImplicitAny\n        newData[key] = value;\n      }\n\n      continue;\n    }\n\n    if (isRelation) {\n      if (!isDefined(fieldMetadata?.relationTargetObjectMetadataId)) {\n        throw new Error(\n          `Relation target object metadata ID is missing for field \"${key}\"`,\n        );\n      }\n\n      const targetObjectMetadata =\n        flatObjectMetadataMaps.byId[\n          fieldMetadata.relationTargetObjectMetadataId\n        ];\n\n      if (!targetObjectMetadata) {\n        throw new Error(\n          `Object metadata for object metadataId \"${fieldMetadata.relationTargetObjectMetadataId}\" is missing`,\n        );\n      }\n\n      // @ts-expect-error legacy noImplicitAny\n      newData[key] = formatResult(\n        value,\n        targetObjectMetadata,\n        flatObjectMetadataMaps,\n        flatFieldMetadataMaps,\n      );\n    }\n\n    if (!compositePropertyArgs || !isDefined(fieldMetadata)) {\n      continue;\n    }\n\n    const { parentField, ...compositeProperty } = compositePropertyArgs;\n\n    // @ts-expect-error legacy noImplicitAny\n    if (!newData[parentField]) {\n      // @ts-expect-error legacy noImplicitAny\n      newData[parentField] = {};\n    }\n\n    // @ts-expect-error legacy noImplicitAny\n    newData[parentField][compositeProperty.name] = isNull(value)\n      ? transformCompositeFieldNullValue(\n          value,\n          compositeProperty.name,\n          fieldMetadata,\n        )\n      : value;\n  }\n\n  const fieldMetadataItemsOfTypeDateOnly = getFlatFieldsFromFlatObjectMetadata(\n    flatObjectMetadata,\n    flatFieldMetadataMaps,\n  ).filter((field) => field.type === FieldMetadataType.DATE);\n\n  for (const dateField of fieldMetadataItemsOfTypeDateOnly) {\n    // @ts-expect-error legacy noImplicitAny\n    const rawUpdatedDate = newData[dateField.name] as string | null | undefined;\n\n    if (!isDefined(rawUpdatedDate)) {\n      continue;\n    }\n\n    // @ts-expect-error legacy noImplicitAny\n    newData[dateField.name] = rawUpdatedDate;\n  }\n\n  return newData as T;\n}\n\nexport function getCompositeFieldMetadataMap(\n  flatObjectMetadata: FlatObjectMetadata,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n) {\n  const compositeFieldMetadataCollection = getCompositeFieldMetadataCollection(\n    flatObjectMetadata,\n    flatFieldMetadataMaps,\n  );\n\n  return new Map(\n    compositeFieldMetadataCollection.flatMap((fieldMetadata) => {\n      const compositeType = compositeTypeDefinitions.get(fieldMetadata.type);\n\n      if (!compositeType) return [];\n\n      // Map each composite property to a [key, value] pair\n      return compositeType.properties.map((compositeProperty) => [\n        computeCompositeColumnName(fieldMetadata.name, compositeProperty),\n        {\n          parentField: fieldMetadata.name,\n          ...compositeProperty,\n        },\n      ]);\n    }),\n  );\n}\n\nfunction formatFieldMetadataValue(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  fieldMetadataType: FieldMetadataType,\n) {\n  if (\n    typeof value === 'string' &&\n    (fieldMetadataType === FieldMetadataType.MULTI_SELECT ||\n      fieldMetadataType === FieldMetadataType.ARRAY)\n  ) {\n    const cleanedValue = value.replace(/{|}/g, '').trim();\n\n    return cleanedValue ? cleanedValue.split(',') : [];\n  }\n\n  if (isNull(value)) {\n    if (\n      fieldMetadataType === FieldMetadataType.MULTI_SELECT ||\n      fieldMetadataType === FieldMetadataType.ARRAY\n    ) {\n      return DEFAULT_ARRAY_FIELD_NULL_EQUIVALENT_VALUE;\n    }\n\n    if (fieldMetadataType === FieldMetadataType.TEXT) {\n      return DEFAULT_TEXT_FIELD_NULL_EQUIVALENT_VALUE;\n    }\n\n    return value;\n  }\n\n  return value;\n}\n\nfunction transformCompositeFieldNullValue(\n  value: unknown,\n  compositePropertyName: string,\n  fieldMetadata: FlatFieldMetadata,\n) {\n  if (!isNull(value)) return value;\n\n  return (\n    DEFAULT_COMPOSITE_FIELDS_NULL_EQUIVALENT_VALUE[fieldMetadata.type]?.[\n      compositePropertyName\n    ] ?? value\n  );\n}",
            "output_extracted": "import { isPlainObject } from '@nestjs/common/utils/shared.utils';\n\nimport { isNull } from '@sniptt/guards';\nimport {\n  FieldMetadataType,\n  compositeTypeDefinitions,\n} from 'twenty-shared/types';\nimport { isDefined } from 'twenty-shared/utils';\n\nimport {\n  DEFAULT_ARRAY_FIELD_NULL_EQUIVALENT_VALUE,\n  DEFAULT_COMPOSITE_FIELDS_NULL_EQUIVALENT_VALUE,\n  DEFAULT_TEXT_FIELD_NULL_EQUIVALENT_VALUE,\n} from 'src/engine/api/common/common-args-processors/data-arg-processor/constants/null-equivalent-values.constant';\nimport { getFlatFieldsFromFlatObjectMetadata } from 'src/engine/api/graphql/workspace-schema-builder/utils/get-flat-fields-for-flat-object-metadata.util';\nimport { computeCompositeColumnName } from 'src/engine/metadata-modules/field-metadata/utils/compute-column-name.util';\nimport { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\nimport { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\nimport { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\nimport { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\nimport { getCompositeFieldMetadataCollection } from 'src/engine/twenty-orm/utils/get-composite-field-metadata-collection';\nimport { isFieldMetadataEntityOfType } from 'src/engine/utils/is-field-metadata-of-type.util';\n\nexport function formatResult<T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data: any,\n  flatObjectMetadata: FlatObjectMetadata | undefined,\n  flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n): T {\n  if (!isDefined(data)) {\n    return data;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map((item) =>\n      formatResult(\n        item,\n        flatObjectMetadata,\n        flatObjectMetadataMaps,\n        flatFieldMetadataMaps,\n      ),\n    ) as T;\n  }\n\n  if (!isPlainObject(data)) {\n    return data;\n  }\n\n  if (!flatObjectMetadata) {\n    throw new Error('Object metadata is missing');\n  }\n\n  const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n    flatFieldMetadataMaps,\n    flatObjectMetadata,\n  );\n\n  const compositeFieldMetadataMap = getCompositeFieldMetadataMap(\n    flatObjectMetadata,\n    flatFieldMetadataMaps,\n  );\n\n  const newData: object = {};\n\n  for (const [key, value] of Object.entries(data)) {\n    const compositePropertyArgs = compositeFieldMetadataMap.get(key);\n\n    const fieldMetadataId =\n      fieldIdByName[key] ||\n      fieldIdByName[compositePropertyArgs?.parentField ?? ''];\n\n    const fieldMetadata = flatFieldMetadataMaps.byId[fieldMetadataId] as\n      | FlatFieldMetadata<FieldMetadataType>\n      | undefined;\n\n    const isRelation = fieldMetadata\n      ? isFieldMetadataEntityOfType(fieldMetadata, FieldMetadataType.RELATION)\n      : false;\n\n    if (!compositePropertyArgs && !isRelation) {\n      if (isPlainObject(value)) {\n        // @ts-expect-error legacy noImplicitAny\n        newData[key] = formatResult(\n          value,\n          flatObjectMetadata,\n          flatObjectMetadataMaps,\n          flatFieldMetadataMaps,\n        );\n      } else if (fieldMetadata) {\n        // @ts-expect-error legacy noImplicitAny\n        newData[key] = formatFieldMetadataValue(value, fieldMetadata.type);\n      } else {\n        // @ts-expect-error legacy noImplicitAny\n        newData[key] = value;\n      }\n\n      continue;\n    }\n\n    if (isRelation) {\n      if (!isDefined(fieldMetadata?.relationTargetObjectMetadataId)) {\n        throw new Error(\n          `Relation target object metadata ID is missing for field \"${key}\"`,\n        );\n      }\n\n      const targetObjectMetadata =\n        flatObjectMetadataMaps.byId[\n          fieldMetadata.relationTargetObjectMetadataId\n        ];\n\n      if (!targetObjectMetadata) {\n        throw new Error(\n          `Object metadata for object metadataId \"${fieldMetadata.relationTargetObjectMetadataId}\" is missing`,\n        );\n      }\n\n      // @ts-expect-error legacy noImplicitAny\n      newData[key] = formatResult(\n        value,\n        targetObjectMetadata,\n        flatObjectMetadataMaps,\n        flatFieldMetadataMaps,\n      );\n    }\n\n    if (!compositePropertyArgs || !isDefined(fieldMetadata)) {\n      continue;\n    }\n\n    const { parentField, ...compositeProperty } = compositePropertyArgs;\n\n    // @ts-expect-error legacy noImplicitAny\n    if (!newData[parentField]) {\n      // @ts-expect-error legacy noImplicitAny\n      newData[parentField] = {};\n    }\n\n    // @ts-expect-error legacy noImplicitAny\n    newData[parentField][compositeProperty.name] = isNull(value)\n      ? transformCompositeFieldNullValue(\n          value,\n          compositeProperty.name,\n          fieldMetadata,\n        )\n      : value;\n  }\n\n  const fieldMetadataItemsOfTypeDateOnly = getFlatFieldsFromFlatObjectMetadata(\n    flatObjectMetadata,\n    flatFieldMetadataMaps,\n  ).filter((field) => field.type === FieldMetadataType.DATE);\n\n  for (const dateField of fieldMetadataItemsOfTypeDateOnly) {\n    // @ts-expect-error legacy noImplicitAny\n    const rawUpdatedDate = newData[dateField.name] as string | null | undefined;\n\n    if (!isDefined(rawUpdatedDate)) {\n      continue;\n    }\n\n    // @ts-expect-error legacy noImplicitAny\n    newData[dateField.name] = rawUpdatedDate;\n  }\n\n  return newData as T;\n}\n\nexport function getCompositeFieldMetadataMap(\n  flatObjectMetadata: FlatObjectMetadata,\n  flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n) {\n  const compositeFieldMetadataCollection = getCompositeFieldMetadataCollection(\n    flatObjectMetadata,\n    flatFieldMetadataMaps,\n  );\n\n  return new Map(\n    compositeFieldMetadataCollection.flatMap((fieldMetadata) => {\n      const compositeType = compositeTypeDefinitions.get(fieldMetadata.type);\n\n      if (!compositeType) return [];\n\n      // Map each composite property to a [key, value] pair\n      return compositeType.properties.map((compositeProperty) => [\n        computeCompositeColumnName(fieldMetadata.name, compositeProperty),\n        {\n          parentField: fieldMetadata.name,\n          ...compositeProperty,\n        },\n      ]);\n    }),\n  );\n}\n\nfunction formatFieldMetadataValue(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  fieldMetadataType: FieldMetadataType,\n) {\n  if (\n    typeof value === 'string' &&\n    (fieldMetadataType === FieldMetadataType.MULTI_SELECT ||\n      fieldMetadataType === FieldMetadataType.ARRAY)\n  ) {\n    const cleanedValue = value.replace(/{|}/g, '').trim();\n\n    return cleanedValue ? cleanedValue.split(',') : [];\n  }\n\n  if (isNull(value)) {\n    if (\n      fieldMetadataType === FieldMetadataType.MULTI_SELECT ||\n      fieldMetadataType === FieldMetadataType.ARRAY\n    ) {\n      return DEFAULT_ARRAY_FIELD_NULL_EQUIVALENT_VALUE;\n    }\n\n    if (fieldMetadataType === FieldMetadataType.TEXT) {\n      return DEFAULT_TEXT_FIELD_NULL_EQUIVALENT_VALUE;\n    }\n\n    return value;\n  }\n\n  return value;\n}\n\nfunction transformCompositeFieldNullValue(\n  value: unknown,\n  compositePropertyName: string,\n  fieldMetadata: FlatFieldMetadata,\n) {\n  if (!isNull(value)) return value;\n\n  return (\n    DEFAULT_COMPOSITE_FIELDS_NULL_EQUIVALENT_VALUE[fieldMetadata.type]?.[\n      compositePropertyName\n    ] ?? value\n  );\n}",
            "cost": 0.079475
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "twentyhq__twenty.main.16132",
        "repo": "twentyhq/twenty",
        "base_commit": "57ae12ff7c5d1a3f2bbfaf46ca50e7bb11e8e0af",
        "head_commit": "51918abcb4401342c167fd06f25d33a02da0e147",
        "title": "optimize buildFieldMapsFromFlatObjectMetadata usages",
        "merged_at": "2025-11-27T14:01:52Z",
        "html_url": "https://github.com/twentyhq/twenty/pull/16132",
        "test_files": [
            "packages/twenty-server/src/engine/twenty-orm/entity-manager/workspace-entity-manager.spec.ts"
        ],
        "code_files": [
            "packages/twenty-server/src/engine/api/common/common-result-getters/common-result-getters.service.ts",
            "packages/twenty-server/src/engine/api/graphql/graphql-query-runner/helpers/process-nested-relations-v2.helper.ts",
            "packages/twenty-server/src/engine/twenty-orm/utils/compute-relation-connect-query-configs.util.ts",
            "packages/twenty-server/src/engine/twenty-orm/utils/format-data.util.ts",
            "packages/twenty-server/src/engine/twenty-orm/utils/format-result.util.ts"
        ],
        "total_changes": 133,
        "num_files": 6,
        "pull_number": 16132,
        "patch": "diff --git a/packages/twenty-server/src/engine/api/common/common-result-getters/common-result-getters.service.ts b/packages/twenty-server/src/engine/api/common/common-result-getters/common-result-getters.service.ts\nindex 1d5981020252f..437ede452fc31 100644\n--- a/packages/twenty-server/src/engine/api/common/common-result-getters/common-result-getters.service.ts\n+++ b/packages/twenty-server/src/engine/api/common/common-result-getters/common-result-getters.service.ts\n@@ -18,7 +18,10 @@ import { FileService } from 'src/engine/core-modules/file/services/file.service'\n import { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\n import { findFlatEntityByIdInFlatEntityMapsOrThrow } from 'src/engine/metadata-modules/flat-entity/utils/find-flat-entity-by-id-in-flat-entity-maps-or-throw.util';\n import { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\n-import { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\n+import {\n+  buildFieldMapsFromFlatObjectMetadata,\n+  type FieldMapsForObject,\n+} from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\n import { isFlatFieldMetadataOfType } from 'src/engine/metadata-modules/flat-field-metadata/utils/is-flat-field-metadata-of-type.util';\n import { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\n \n@@ -54,6 +57,11 @@ export class CommonResultGettersService {\n     flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n     workspaceId: string,\n   ) {\n+    const fieldMaps = buildFieldMapsFromFlatObjectMetadata(\n+      flatFieldMetadataMaps,\n+      flatObjectMetadata,\n+    );\n+\n     return await Promise.all(\n       recordArray.map(\n         async (record: ObjectRecord) =>\n@@ -63,6 +71,7 @@ export class CommonResultGettersService {\n             flatObjectMetadataMaps,\n             flatFieldMetadataMaps,\n             workspaceId,\n+            fieldMaps,\n           ),\n       ),\n     );\n@@ -74,13 +83,18 @@ export class CommonResultGettersService {\n     flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n     flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n     workspaceId: string,\n+    fieldMapsForObject?: FieldMapsForObject,\n   ): Promise<ObjectRecord> {\n     const handler = this.getHandler(flatObjectMetadata.nameSingular);\n \n-    const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n-      flatFieldMetadataMaps,\n-      flatObjectMetadata,\n-    );\n+    const fieldMaps =\n+      fieldMapsForObject ??\n+      buildFieldMapsFromFlatObjectMetadata(\n+        flatFieldMetadataMaps,\n+        flatObjectMetadata,\n+      );\n+\n+    const { fieldIdByName } = fieldMaps;\n \n     const relationFields = Object.keys(record)\n       .map(\ndiff --git a/packages/twenty-server/src/engine/api/graphql/graphql-query-runner/helpers/process-nested-relations-v2.helper.ts b/packages/twenty-server/src/engine/api/graphql/graphql-query-runner/helpers/process-nested-relations-v2.helper.ts\nindex 7b22692a4c90f..f4f6017ee0172 100644\n--- a/packages/twenty-server/src/engine/api/graphql/graphql-query-runner/helpers/process-nested-relations-v2.helper.ts\n+++ b/packages/twenty-server/src/engine/api/graphql/graphql-query-runner/helpers/process-nested-relations-v2.helper.ts\n@@ -17,7 +17,10 @@ import { type AuthContext } from 'src/engine/core-modules/auth/types/auth-contex\n import { FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\n import { findFlatEntityByIdInFlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/utils/find-flat-entity-by-id-in-flat-entity-maps.util';\n import { FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\n-import { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\n+import {\n+  buildFieldMapsFromFlatObjectMetadata,\n+  type FieldMapsForObject,\n+} from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\n import { FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\n import { type WorkspaceDataSource } from 'src/engine/twenty-orm/datasource/workspace.datasource';\n import { type WorkspaceSelectQueryBuilder } from 'src/engine/twenty-orm/repository/workspace-select-query-builder';\n@@ -112,13 +115,13 @@ export class ProcessNestedRelationsV2Helper {\n     rolePermissionConfig?: RolePermissionConfig;\n     selectedFields: Record<string, unknown>;\n   }): Promise<void> {\n-    const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n+    const fieldMaps = buildFieldMapsFromFlatObjectMetadata(\n       flatFieldMetadataMaps,\n       parentObjectMetadataItem,\n     );\n \n     const sourceFieldMetadata = findFlatEntityByIdInFlatEntityMaps({\n-      flatEntityId: fieldIdByName[sourceFieldName],\n+      flatEntityId: fieldMaps.fieldIdByName[sourceFieldName],\n       flatEntityMaps: flatFieldMetadataMaps,\n     });\n \n@@ -154,6 +157,7 @@ export class ProcessNestedRelationsV2Helper {\n         flatFieldMetadataMaps,\n         parentObjectMetadataItem,\n         sourceFieldName,\n+        fieldMaps,\n       });\n \n     const targetObjectRepository = workspaceDataSource.getRepository(\n@@ -250,19 +254,16 @@ export class ProcessNestedRelationsV2Helper {\n     flatFieldMetadataMaps,\n     parentObjectMetadataItem,\n     sourceFieldName,\n+    fieldMaps,\n   }: {\n     flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>;\n     flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>;\n     parentObjectMetadataItem: FlatObjectMetadata;\n     sourceFieldName: string;\n+    fieldMaps: FieldMapsForObject;\n   }) {\n-    const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n-      flatFieldMetadataMaps,\n-      parentObjectMetadataItem,\n-    );\n-\n     const targetFieldMetadata = findFlatEntityByIdInFlatEntityMaps({\n-      flatEntityId: fieldIdByName[sourceFieldName],\n+      flatEntityId: fieldMaps.fieldIdByName[sourceFieldName],\n       flatEntityMaps: flatFieldMetadataMaps,\n     });\n \ndiff --git a/packages/twenty-server/src/engine/twenty-orm/entity-manager/workspace-entity-manager.spec.ts b/packages/twenty-server/src/engine/twenty-orm/entity-manager/workspace-entity-manager.spec.ts\nindex c9a6f077e92dc..671b9c73728e8 100644\n--- a/packages/twenty-server/src/engine/twenty-orm/entity-manager/workspace-entity-manager.spec.ts\n+++ b/packages/twenty-server/src/engine/twenty-orm/entity-manager/workspace-entity-manager.spec.ts\n@@ -13,6 +13,7 @@ import { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-m\n import { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\n import { type WorkspaceDataSource } from 'src/engine/twenty-orm/datasource/workspace.datasource';\n import { validateOperationIsPermittedOrThrow } from 'src/engine/twenty-orm/repository/permissions.utils';\n+import { getObjectMetadataFromEntityTarget } from 'src/engine/twenty-orm/utils/get-object-metadata-from-entity-target.util';\n \n import { WorkspaceEntityManager } from './workspace-entity-manager';\n \n@@ -23,7 +24,7 @@ jest.mock('src/engine/twenty-orm/repository/permissions.utils', () => ({\n jest.mock(\n   'src/engine/twenty-orm/utils/get-object-metadata-from-entity-target.util',\n   () => ({\n-    getObjectMetadataFromEntityTarget: jest.fn().mockReturnValue({}),\n+    getObjectMetadataFromEntityTarget: jest.fn(),\n   }),\n );\n \n@@ -117,6 +118,10 @@ describe('WorkspaceEntityManager', () => {\n       updatedAt: new Date(),\n     };\n \n+    (getObjectMetadataFromEntityTarget as jest.Mock).mockReturnValue(\n+      mockFlatObjectMetadata,\n+    );\n+\n     const mockFlatFieldMetadata: FlatFieldMetadata = {\n       id: 'field-id',\n       type: 'TEXT' as FieldMetadataType,\ndiff --git a/packages/twenty-server/src/engine/twenty-orm/utils/compute-relation-connect-query-configs.util.ts b/packages/twenty-server/src/engine/twenty-orm/utils/compute-relation-connect-query-configs.util.ts\nindex 908e27975e1e2..b0fa4b7eec3a7 100644\n--- a/packages/twenty-server/src/engine/twenty-orm/utils/compute-relation-connect-query-configs.util.ts\n+++ b/packages/twenty-server/src/engine/twenty-orm/utils/compute-relation-connect-query-configs.util.ts\n@@ -9,7 +9,10 @@ import { getFlatFieldsFromFlatObjectMetadata } from 'src/engine/api/graphql/work\n import { isCompositeFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-composite-field-metadata-type.util';\n import { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\n import { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\n-import { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\n+import {\n+  buildFieldMapsFromFlatObjectMetadata,\n+  type FieldMapsForObject,\n+} from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\n import { type FlatIndexMetadata } from 'src/engine/metadata-modules/flat-index-metadata/types/flat-index-metadata.type';\n import { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\n import { type ConnectObject } from 'src/engine/twenty-orm/entity-manager/types/query-deep-partial-entity-with-nested-relation-fields.type';\n@@ -36,6 +39,11 @@ export const computeRelationConnectQueryConfigs = (\n ) => {\n   const allConnectQueryConfigs: Record<string, RelationConnectQueryConfig> = {};\n \n+  const fieldMaps = buildFieldMapsFromFlatObjectMetadata(\n+    flatFieldMetadataMaps,\n+    flatObjectMetadata,\n+  );\n+\n   for (const [entityIndex, entity] of entities.entries()) {\n     const nestedRelationConnectFields =\n       relationConnectQueryFieldsByEntityIndex[entityIndex];\n@@ -57,6 +65,7 @@ export const computeRelationConnectQueryConfigs = (\n         flatFieldMetadataMaps,\n         flatIndexMaps,\n         entity,\n+        fieldMaps,\n       );\n \n       const connectQueryConfig = allConnectQueryConfigs[connectFieldName];\n@@ -132,17 +141,14 @@ const computeRecordToConnectCondition = (\n   flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n   flatIndexMaps: FlatEntityMaps<FlatIndexMetadata>,\n   entity: Record<string, unknown>,\n+  fieldMaps: FieldMapsForObject,\n ): {\n   recordToConnectCondition: UniqueConstraintCondition;\n   uniqueConstraintFields: FlatFieldMetadata<FieldMetadataType>[];\n   targetObjectNameSingular: string;\n } => {\n-  const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n-    flatFieldMetadataMaps,\n-    flatObjectMetadata,\n-  );\n-\n-  const field = flatFieldMetadataMaps.byId[fieldIdByName[connectFieldName]];\n+  const field =\n+    flatFieldMetadataMaps.byId[fieldMaps.fieldIdByName[connectFieldName]];\n \n   if (\n     !isDefined(field) ||\ndiff --git a/packages/twenty-server/src/engine/twenty-orm/utils/format-data.util.ts b/packages/twenty-server/src/engine/twenty-orm/utils/format-data.util.ts\nindex fe15bc2454682..156788a126990 100644\n--- a/packages/twenty-server/src/engine/twenty-orm/utils/format-data.util.ts\n+++ b/packages/twenty-server/src/engine/twenty-orm/utils/format-data.util.ts\n@@ -7,7 +7,10 @@ import { capitalize } from 'twenty-shared/utils';\n import { isCompositeFieldMetadataType } from 'src/engine/metadata-modules/field-metadata/utils/is-composite-field-metadata-type.util';\n import { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\n import { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\n-import { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\n+import {\n+  buildFieldMapsFromFlatObjectMetadata,\n+  type FieldMapsForObject,\n+} from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\n import { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\n import { type CompositeFieldMetadataType } from 'src/engine/metadata-modules/workspace-migration/factories/composite-column-action.factory';\n \n@@ -15,22 +18,26 @@ export function formatData<T>(\n   data: T,\n   flatObjectMetadata: FlatObjectMetadata,\n   flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n+  fieldMapsForObject?: FieldMapsForObject,\n ): T {\n   if (!data) {\n     return data;\n   }\n \n+  const fieldMaps =\n+    fieldMapsForObject ??\n+    buildFieldMapsFromFlatObjectMetadata(\n+      flatFieldMetadataMaps,\n+      flatObjectMetadata,\n+    );\n+\n   if (Array.isArray(data)) {\n     return data.map((item) =>\n-      formatData(item, flatObjectMetadata, flatFieldMetadataMaps),\n+      formatData(item, flatObjectMetadata, flatFieldMetadataMaps, fieldMaps),\n     ) as T;\n   }\n \n-  const { fieldIdByName, fieldIdByJoinColumnName } =\n-    buildFieldMapsFromFlatObjectMetadata(\n-      flatFieldMetadataMaps,\n-      flatObjectMetadata,\n-    );\n+  const { fieldIdByName, fieldIdByJoinColumnName } = fieldMaps;\n \n   // eslint-disable-next-line @typescript-eslint/no-explicit-any\n   const newData: Record<string, any> = {};\ndiff --git a/packages/twenty-server/src/engine/twenty-orm/utils/format-result.util.ts b/packages/twenty-server/src/engine/twenty-orm/utils/format-result.util.ts\nindex c04f9a15316dd..210050b24c87d 100644\n--- a/packages/twenty-server/src/engine/twenty-orm/utils/format-result.util.ts\n+++ b/packages/twenty-server/src/engine/twenty-orm/utils/format-result.util.ts\n@@ -16,7 +16,10 @@ import { getFlatFieldsFromFlatObjectMetadata } from 'src/engine/api/graphql/work\n import { computeCompositeColumnName } from 'src/engine/metadata-modules/field-metadata/utils/compute-column-name.util';\n import { type FlatEntityMaps } from 'src/engine/metadata-modules/flat-entity/types/flat-entity-maps.type';\n import { type FlatFieldMetadata } from 'src/engine/metadata-modules/flat-field-metadata/types/flat-field-metadata.type';\n-import { buildFieldMapsFromFlatObjectMetadata } from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\n+import {\n+  buildFieldMapsFromFlatObjectMetadata,\n+  type FieldMapsForObject,\n+} from 'src/engine/metadata-modules/flat-field-metadata/utils/build-field-maps-from-flat-object-metadata.util';\n import { type FlatObjectMetadata } from 'src/engine/metadata-modules/flat-object-metadata/types/flat-object-metadata.type';\n import { getCompositeFieldMetadataCollection } from 'src/engine/twenty-orm/utils/get-composite-field-metadata-collection';\n import { isFieldMetadataEntityOfType } from 'src/engine/utils/is-field-metadata-of-type.util';\n@@ -27,23 +30,25 @@ export function formatResult<T>(\n   flatObjectMetadata: FlatObjectMetadata | undefined,\n   flatObjectMetadataMaps: FlatEntityMaps<FlatObjectMetadata>,\n   flatFieldMetadataMaps: FlatEntityMaps<FlatFieldMetadata>,\n+  fieldMapsForObject?: FieldMapsForObject,\n ): T {\n   if (!isDefined(data)) {\n     return data;\n   }\n \n-  if (Array.isArray(data)) {\n-    return data.map((item) =>\n-      formatResult(\n-        item,\n-        flatObjectMetadata,\n-        flatObjectMetadataMaps,\n-        flatFieldMetadataMaps,\n-      ),\n-    ) as T;\n-  }\n-\n   if (!isPlainObject(data)) {\n+    if (Array.isArray(data)) {\n+      return data.map((item) =>\n+        formatResult(\n+          item,\n+          flatObjectMetadata,\n+          flatObjectMetadataMaps,\n+          flatFieldMetadataMaps,\n+          fieldMapsForObject,\n+        ),\n+      ) as T;\n+    }\n+\n     return data;\n   }\n \n@@ -51,10 +56,14 @@ export function formatResult<T>(\n     throw new Error('Object metadata is missing');\n   }\n \n-  const { fieldIdByName } = buildFieldMapsFromFlatObjectMetadata(\n-    flatFieldMetadataMaps,\n-    flatObjectMetadata,\n-  );\n+  const fieldMaps =\n+    fieldMapsForObject ??\n+    buildFieldMapsFromFlatObjectMetadata(\n+      flatFieldMetadataMaps,\n+      flatObjectMetadata,\n+    );\n+\n+  const { fieldIdByName } = fieldMaps;\n \n   const compositeFieldMetadataMap = getCompositeFieldMetadataMap(\n     flatObjectMetadata,\n@@ -86,6 +95,7 @@ export function formatResult<T>(\n           flatObjectMetadata,\n           flatObjectMetadataMaps,\n           flatFieldMetadataMaps,\n+          fieldMaps,\n         );\n       } else if (fieldMetadata) {\n         // @ts-expect-error legacy noImplicitAny\n",
        "pr_mirror": "twentyhq__twenty.main"
    }
}