{
    "cost": 0.8396650000000001,
    "rewrites": {
        "twentyhq__twenty.main/packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts": {
            "output": "import { RecordFilterOperand } from '@/object-record/record-filter/types/RecordFilterOperand';\nimport { getRecordFilterOperands } from '@/object-record/record-filter/utils/getRecordFilterOperands';\nimport { type CompositeFieldSubFieldName } from '@/settings/data-model/types/CompositeFieldSubFieldName';\nimport { type FieldType } from '@/settings/data-model/types/FieldType';\nimport { type FilterableFieldType } from 'twenty-shared/types';\n\ndescribe('getOperandsForFilterType', () => {\n  const emptyOperands = [\n    RecordFilterOperand.IS_EMPTY,\n    RecordFilterOperand.IS_NOT_EMPTY,\n  ];\n\n  const containsOperands = [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n  ];\n\n  const numberOperands = [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n    RecordFilterOperand.LESS_THAN_OR_EQUAL,\n  ];\n\n  const currencyAmountMicrosOperands = [\n    RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n    RecordFilterOperand.LESS_THAN_OR_EQUAL,\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_NOT,\n  ];\n\n  const currencyCurrencyCodeOperands = [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_NOT,\n  ];\n\n  const actorSourceOperands = [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_NOT,\n  ];\n\n  const dateOperands = [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_RELATIVE,\n    RecordFilterOperand.IS_IN_PAST,\n    RecordFilterOperand.IS_IN_FUTURE,\n    RecordFilterOperand.IS_TODAY,\n    RecordFilterOperand.IS_BEFORE,\n    RecordFilterOperand.IS_AFTER,\n  ];\n\n  const relationOperand = [RecordFilterOperand.IS, RecordFilterOperand.IS_NOT];\n\n  const testCases = [\n    ['TEXT', [...containsOperands, ...emptyOperands]],\n    ['FULL_NAME', [...containsOperands, ...emptyOperands]],\n    ['ADDRESS', [...containsOperands, ...emptyOperands]],\n    ['LINKS', [...containsOperands, ...emptyOperands]],\n    ['LINKS', [...containsOperands, ...emptyOperands], 'primaryLinkUrl'],\n    ['LINKS', [...containsOperands, ...emptyOperands], 'primaryLinkLabel'],\n    ['LINKS', [...containsOperands, ...emptyOperands], 'secondaryLinks'],\n    ['ACTOR', [...containsOperands, ...emptyOperands], 'name'],\n    ['ACTOR', [...actorSourceOperands, ...emptyOperands], 'source'],\n    ['ACTOR', [...containsOperands, ...emptyOperands]],\n    [\n      'CURRENCY',\n      [...currencyCurrencyCodeOperands, ...emptyOperands],\n      'currencyCode',\n    ],\n    [\n      'CURRENCY',\n      [...currencyAmountMicrosOperands, ...emptyOperands],\n      'amountMicros',\n    ],\n    ['NUMBER', [...numberOperands, ...emptyOperands]],\n    ['DATE', [...dateOperands, ...emptyOperands]],\n    ['DATE_TIME', [...dateOperands, ...emptyOperands]],\n    ['RELATION', [...relationOperand, ...emptyOperands]],\n  ] satisfies (\n    | [FieldType, RecordFilterOperand[], CompositeFieldSubFieldName]\n    | [FieldType, RecordFilterOperand[]]\n  )[];\n\n  testCases.forEach(([filterType, expectedOperands, subFieldName]) => {\n    it(`should return correct operands for FilterType.${filterType}`, () => {\n      const result = getRecordFilterOperands({\n        filterType: filterType as FilterableFieldType,\n        subFieldName,\n      });\n      expect(result).toEqual(expectedOperands);\n    });\n  });\n});",
            "output_extracted": "import { RecordFilterOperand } from '@/object-record/record-filter/types/RecordFilterOperand';\nimport { getRecordFilterOperands } from '@/object-record/record-filter/utils/getRecordFilterOperands';\nimport { type CompositeFieldSubFieldName } from '@/settings/data-model/types/CompositeFieldSubFieldName';\nimport { type FieldType } from '@/settings/data-model/types/FieldType';\nimport { type FilterableFieldType } from 'twenty-shared/types';\n\ndescribe('getOperandsForFilterType', () => {\n  const emptyOperands = [\n    RecordFilterOperand.IS_EMPTY,\n    RecordFilterOperand.IS_NOT_EMPTY,\n  ];\n\n  const containsOperands = [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n  ];\n\n  const numberOperands = [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n    RecordFilterOperand.LESS_THAN_OR_EQUAL,\n  ];\n\n  const currencyAmountMicrosOperands = [\n    RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n    RecordFilterOperand.LESS_THAN_OR_EQUAL,\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_NOT,\n  ];\n\n  const currencyCurrencyCodeOperands = [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_NOT,\n  ];\n\n  const actorSourceOperands = [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_NOT,\n  ];\n\n  const dateOperands = [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_RELATIVE,\n    RecordFilterOperand.IS_IN_PAST,\n    RecordFilterOperand.IS_IN_FUTURE,\n    RecordFilterOperand.IS_TODAY,\n    RecordFilterOperand.IS_BEFORE,\n    RecordFilterOperand.IS_AFTER,\n  ];\n\n  const relationOperand = [RecordFilterOperand.IS, RecordFilterOperand.IS_NOT];\n\n  const testCases = [\n    ['TEXT', [...containsOperands, ...emptyOperands]],\n    ['FULL_NAME', [...containsOperands, ...emptyOperands]],\n    ['ADDRESS', [...containsOperands, ...emptyOperands]],\n    ['LINKS', [...containsOperands, ...emptyOperands]],\n    ['LINKS', [...containsOperands, ...emptyOperands], 'primaryLinkUrl'],\n    ['LINKS', [...containsOperands, ...emptyOperands], 'primaryLinkLabel'],\n    ['LINKS', [...containsOperands, ...emptyOperands], 'secondaryLinks'],\n    ['ACTOR', [...containsOperands, ...emptyOperands], 'name'],\n    ['ACTOR', [...actorSourceOperands, ...emptyOperands], 'source'],\n    ['ACTOR', [...containsOperands, ...emptyOperands]],\n    [\n      'CURRENCY',\n      [...currencyCurrencyCodeOperands, ...emptyOperands],\n      'currencyCode',\n    ],\n    [\n      'CURRENCY',\n      [...currencyAmountMicrosOperands, ...emptyOperands],\n      'amountMicros',\n    ],\n    ['NUMBER', [...numberOperands, ...emptyOperands]],\n    ['DATE', [...dateOperands, ...emptyOperands]],\n    ['DATE_TIME', [...dateOperands, ...emptyOperands]],\n    ['RELATION', [...relationOperand, ...emptyOperands]],\n  ] satisfies (\n    | [FieldType, RecordFilterOperand[], CompositeFieldSubFieldName]\n    | [FieldType, RecordFilterOperand[]]\n  )[];\n\n  testCases.forEach(([filterType, expectedOperands, subFieldName]) => {\n    it(`should return correct operands for FilterType.${filterType}`, () => {\n      const result = getRecordFilterOperands({\n        filterType: filterType as FilterableFieldType,\n        subFieldName,\n      });\n      expect(result).toEqual(expectedOperands);\n    });\n  });\n});",
            "cost": 0.03739
        },
        "twentyhq__twenty.main/packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts": {
            "output": "import { isFilterOnActorSourceSubField } from '@/object-record/object-filter-dropdown/utils/isFilterOnActorSourceSubField';\nimport { type CompositeFieldSubFieldName } from '@/settings/data-model/types/CompositeFieldSubFieldName';\nimport {\n  FieldMetadataType,\n  ViewFilterOperand as RecordFilterOperand,\n  type FilterableAndTSVectorFieldType,\n  type FilterableFieldType,\n} from 'twenty-shared/types';\nimport { assertUnreachable, isExpectedSubFieldName } from 'twenty-shared/utils';\n\nexport type GetRecordFilterOperandsParams = {\n  filterType: FilterableAndTSVectorFieldType;\n  subFieldName?: string | null | undefined;\n};\n\nconst emptyOperands = [\n  RecordFilterOperand.IS_EMPTY,\n  RecordFilterOperand.IS_NOT_EMPTY,\n] as const;\n\nconst relationOperands = [\n  RecordFilterOperand.IS,\n  RecordFilterOperand.IS_NOT,\n] as const;\n\ntype FilterOperandMap = {\n  [K in FilterableAndTSVectorFieldType]: readonly RecordFilterOperand[];\n};\n\n// TODO: we would need to refactor the typing of SETTINGS_COMPOSITE_FIELD_TYPE_CONFIGS first\n//   with types like FieldCurrencyValue being derived from a central constant value and not being created like that\n//   in order to narrow down the possible subfield names for each field type\ntype CompositeFieldFilterOperandMap = {\n  [K in FilterableFieldType]: Partial<{\n    [S in CompositeFieldSubFieldName]: readonly RecordFilterOperand[];\n  }>;\n};\n\nexport const FILTER_OPERANDS_MAP = {\n  TEXT: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  EMAILS: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  FULL_NAME: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  ADDRESS: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  LINKS: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  PHONES: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  CURRENCY: [\n    RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n    RecordFilterOperand.LESS_THAN_OR_EQUAL,\n    ...emptyOperands,\n  ],\n  NUMBER: [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n    RecordFilterOperand.LESS_THAN_OR_EQUAL,\n    ...emptyOperands,\n  ],\n  RAW_JSON: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  DATE_TIME: [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_RELATIVE,\n    RecordFilterOperand.IS_IN_PAST,\n    RecordFilterOperand.IS_IN_FUTURE,\n    RecordFilterOperand.IS_TODAY,\n    RecordFilterOperand.IS_BEFORE,\n    RecordFilterOperand.IS_AFTER,\n    ...emptyOperands,\n  ],\n  DATE: [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_RELATIVE,\n    RecordFilterOperand.IS_IN_PAST,\n    RecordFilterOperand.IS_IN_FUTURE,\n    RecordFilterOperand.IS_TODAY,\n    RecordFilterOperand.IS_BEFORE,\n    RecordFilterOperand.IS_AFTER,\n    ...emptyOperands,\n  ],\n  RATING: [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n    RecordFilterOperand.LESS_THAN_OR_EQUAL,\n    ...emptyOperands,\n  ],\n  RELATION: [...relationOperands, ...emptyOperands],\n  MULTI_SELECT: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  SELECT: [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_NOT,\n    ...emptyOperands,\n  ],\n  ACTOR: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  ARRAY: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  BOOLEAN: [RecordFilterOperand.IS],\n  TS_VECTOR: [RecordFilterOperand.VECTOR_SEARCH],\n  UUID: [RecordFilterOperand.IS],\n} as const satisfies FilterOperandMap;\n\nexport const COMPOSITE_FIELD_FILTER_OPERANDS_MAP = {\n  CURRENCY: {\n    currencyCode: [\n      RecordFilterOperand.IS,\n      RecordFilterOperand.IS_NOT,\n      ...emptyOperands,\n    ],\n    amountMicros: [\n      RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n      RecordFilterOperand.LESS_THAN_OR_EQUAL,\n      RecordFilterOperand.IS,\n      RecordFilterOperand.IS_NOT,\n      ...emptyOperands,\n    ],\n  },\n} as const satisfies Partial<CompositeFieldFilterOperandMap>;\n\nexport const getRecordFilterOperands = ({\n  filterType,\n  subFieldName,\n}: GetRecordFilterOperandsParams): readonly RecordFilterOperand[] => {\n  switch (filterType) {\n    case 'TEXT':\n    case 'EMAILS':\n    case 'FULL_NAME':\n    case 'ADDRESS':\n    case 'LINKS':\n    case 'PHONES':\n      return FILTER_OPERANDS_MAP.TEXT;\n    case 'CURRENCY': {\n      if (\n        isExpectedSubFieldName(\n          FieldMetadataType.CURRENCY,\n          'currencyCode',\n          subFieldName,\n        ) === true\n      ) {\n        return COMPOSITE_FIELD_FILTER_OPERANDS_MAP.CURRENCY.currencyCode;\n      } else {\n        return COMPOSITE_FIELD_FILTER_OPERANDS_MAP.CURRENCY.amountMicros;\n      }\n    }\n    case 'NUMBER':\n      return FILTER_OPERANDS_MAP.NUMBER;\n    case 'RAW_JSON':\n      return FILTER_OPERANDS_MAP.RAW_JSON;\n    case 'DATE_TIME':\n    case 'DATE':\n      return FILTER_OPERANDS_MAP.DATE_TIME;\n    case 'RATING':\n      return FILTER_OPERANDS_MAP.RATING;\n    case 'RELATION':\n      return FILTER_OPERANDS_MAP.RELATION;\n    case 'MULTI_SELECT':\n      return FILTER_OPERANDS_MAP.MULTI_SELECT;\n    case 'SELECT':\n      return FILTER_OPERANDS_MAP.SELECT;\n    case 'ACTOR': {\n      if (isFilterOnActorSourceSubField(subFieldName)) {\n        return [\n          RecordFilterOperand.IS,\n          RecordFilterOperand.IS_NOT,\n          ...emptyOperands,\n        ];\n      }\n\n      return FILTER_OPERANDS_MAP.ACTOR;\n    }\n    case 'ARRAY':\n      return FILTER_OPERANDS_MAP.ARRAY;\n    case 'BOOLEAN':\n      return FILTER_OPERANDS_MAP.BOOLEAN;\n    case 'TS_VECTOR':\n      return FILTER_OPERANDS_MAP.TS_VECTOR;\n    case 'UUID':\n      return FILTER_OPERANDS_MAP.UUID;\n    default:\n      assertUnreachable(filterType, `Unknown filter type ${filterType}`);\n  }\n};",
            "output_extracted": "import { isFilterOnActorSourceSubField } from '@/object-record/object-filter-dropdown/utils/isFilterOnActorSourceSubField';\nimport { type CompositeFieldSubFieldName } from '@/settings/data-model/types/CompositeFieldSubFieldName';\nimport {\n  FieldMetadataType,\n  ViewFilterOperand as RecordFilterOperand,\n  type FilterableAndTSVectorFieldType,\n  type FilterableFieldType,\n} from 'twenty-shared/types';\nimport { assertUnreachable, isExpectedSubFieldName } from 'twenty-shared/utils';\n\nexport type GetRecordFilterOperandsParams = {\n  filterType: FilterableAndTSVectorFieldType;\n  subFieldName?: string | null | undefined;\n};\n\nconst emptyOperands = [\n  RecordFilterOperand.IS_EMPTY,\n  RecordFilterOperand.IS_NOT_EMPTY,\n] as const;\n\nconst relationOperands = [\n  RecordFilterOperand.IS,\n  RecordFilterOperand.IS_NOT,\n] as const;\n\ntype FilterOperandMap = {\n  [K in FilterableAndTSVectorFieldType]: readonly RecordFilterOperand[];\n};\n\n// TODO: we would need to refactor the typing of SETTINGS_COMPOSITE_FIELD_TYPE_CONFIGS first\n//   with types like FieldCurrencyValue being derived from a central constant value and not being created like that\n//   in order to narrow down the possible subfield names for each field type\ntype CompositeFieldFilterOperandMap = {\n  [K in FilterableFieldType]: Partial<{\n    [S in CompositeFieldSubFieldName]: readonly RecordFilterOperand[];\n  }>;\n};\n\nexport const FILTER_OPERANDS_MAP = {\n  TEXT: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  EMAILS: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  FULL_NAME: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  ADDRESS: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  LINKS: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  PHONES: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  CURRENCY: [\n    RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n    RecordFilterOperand.LESS_THAN_OR_EQUAL,\n    ...emptyOperands,\n  ],\n  NUMBER: [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n    RecordFilterOperand.LESS_THAN_OR_EQUAL,\n    ...emptyOperands,\n  ],\n  RAW_JSON: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  DATE_TIME: [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_RELATIVE,\n    RecordFilterOperand.IS_IN_PAST,\n    RecordFilterOperand.IS_IN_FUTURE,\n    RecordFilterOperand.IS_TODAY,\n    RecordFilterOperand.IS_BEFORE,\n    RecordFilterOperand.IS_AFTER,\n    ...emptyOperands,\n  ],\n  DATE: [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_RELATIVE,\n    RecordFilterOperand.IS_IN_PAST,\n    RecordFilterOperand.IS_IN_FUTURE,\n    RecordFilterOperand.IS_TODAY,\n    RecordFilterOperand.IS_BEFORE,\n    RecordFilterOperand.IS_AFTER,\n    ...emptyOperands,\n  ],\n  RATING: [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n    RecordFilterOperand.LESS_THAN_OR_EQUAL,\n    ...emptyOperands,\n  ],\n  RELATION: [...relationOperands, ...emptyOperands],\n  MULTI_SELECT: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  SELECT: [\n    RecordFilterOperand.IS,\n    RecordFilterOperand.IS_NOT,\n    ...emptyOperands,\n  ],\n  ACTOR: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  ARRAY: [\n    RecordFilterOperand.CONTAINS,\n    RecordFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  BOOLEAN: [RecordFilterOperand.IS],\n  TS_VECTOR: [RecordFilterOperand.VECTOR_SEARCH],\n  UUID: [RecordFilterOperand.IS],\n} as const satisfies FilterOperandMap;\n\nexport const COMPOSITE_FIELD_FILTER_OPERANDS_MAP = {\n  CURRENCY: {\n    currencyCode: [\n      RecordFilterOperand.IS,\n      RecordFilterOperand.IS_NOT,\n      ...emptyOperands,\n    ],\n    amountMicros: [\n      RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n      RecordFilterOperand.LESS_THAN_OR_EQUAL,\n      RecordFilterOperand.IS,\n      RecordFilterOperand.IS_NOT,\n      ...emptyOperands,\n    ],\n  },\n} as const satisfies Partial<CompositeFieldFilterOperandMap>;\n\nexport const getRecordFilterOperands = ({\n  filterType,\n  subFieldName,\n}: GetRecordFilterOperandsParams): readonly RecordFilterOperand[] => {\n  switch (filterType) {\n    case 'TEXT':\n    case 'EMAILS':\n    case 'FULL_NAME':\n    case 'ADDRESS':\n    case 'LINKS':\n    case 'PHONES':\n      return FILTER_OPERANDS_MAP.TEXT;\n    case 'CURRENCY': {\n      if (\n        isExpectedSubFieldName(\n          FieldMetadataType.CURRENCY,\n          'currencyCode',\n          subFieldName,\n        ) === true\n      ) {\n        return COMPOSITE_FIELD_FILTER_OPERANDS_MAP.CURRENCY.currencyCode;\n      } else {\n        return COMPOSITE_FIELD_FILTER_OPERANDS_MAP.CURRENCY.amountMicros;\n      }\n    }\n    case 'NUMBER':\n      return FILTER_OPERANDS_MAP.NUMBER;\n    case 'RAW_JSON':\n      return FILTER_OPERANDS_MAP.RAW_JSON;\n    case 'DATE_TIME':\n    case 'DATE':\n      return FILTER_OPERANDS_MAP.DATE_TIME;\n    case 'RATING':\n      return FILTER_OPERANDS_MAP.RATING;\n    case 'RELATION':\n      return FILTER_OPERANDS_MAP.RELATION;\n    case 'MULTI_SELECT':\n      return FILTER_OPERANDS_MAP.MULTI_SELECT;\n    case 'SELECT':\n      return FILTER_OPERANDS_MAP.SELECT;\n    case 'ACTOR': {\n      if (isFilterOnActorSourceSubField(subFieldName)) {\n        return [\n          RecordFilterOperand.IS,\n          RecordFilterOperand.IS_NOT,\n          ...emptyOperands,\n        ];\n      }\n\n      return FILTER_OPERANDS_MAP.ACTOR;\n    }\n    case 'ARRAY':\n      return FILTER_OPERANDS_MAP.ARRAY;\n    case 'BOOLEAN':\n      return FILTER_OPERANDS_MAP.BOOLEAN;\n    case 'TS_VECTOR':\n      return FILTER_OPERANDS_MAP.TS_VECTOR;\n    case 'UUID':\n      return FILTER_OPERANDS_MAP.UUID;\n    default:\n      assertUnreachable(filterType, `Unknown filter type ${filterType}`);\n  }\n};",
            "cost": 0.07007000000000001
        },
        "twentyhq__twenty.main/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts": {
            "output": "import { type FieldMetadataItemOption } from '@/object-metadata/types/FieldMetadataItem';\nimport { type RecordFilter } from '@/object-record/record-filter/types/RecordFilter';\nimport { type ColorScheme } from '@/workspace-member/types/WorkspaceMember';\nimport {\n  type FilterableFieldType,\n  ViewFilterOperand,\n} from 'twenty-shared/types';\nimport { RelationType } from '~/generated-metadata/graphql';\nimport { buildValueFromFilter } from './buildRecordInputFromFilter';\n\n// TODO: fix the dates, and test the not supported types\nconst mockDate = new Date('2024-03-20T12:00:00Z');\n\nbeforeAll(() => {\n  jest.useFakeTimers();\n  jest.setSystemTime(mockDate);\n});\n\nafterAll(() => {\n  jest.useRealTimers();\n});\n\ndescribe('buildValueFromFilter', () => {\n  const createTestFilter = (\n    operand: ViewFilterOperand,\n    value: string,\n    type: FilterableFieldType,\n  ): RecordFilter => ({\n    id: 'test-id',\n    fieldMetadataId: 'test-field-id',\n    value,\n    displayValue: value,\n    type,\n    operand,\n    label: 'Test Label',\n  });\n\n  describe('TEXT field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.CONTAINS,\n        value: 'test',\n        expected: 'test',\n      },\n      {\n        operand: ViewFilterOperand.DOES_NOT_CONTAIN,\n        value: 'test',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT_EMPTY,\n        value: 'test',\n        expected: 'test',\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: 'test',\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'TEXT');\n        expect(buildValueFromFilter({ filter })).toBe(expected);\n      },\n    );\n  });\n\n  describe('DATE_TIME field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_AFTER,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_BEFORE,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_IN_PAST,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_IN_FUTURE,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_TODAY,\n        value: '',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_RELATIVE,\n        value: '',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: '',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT_EMPTY,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'DATE_TIME');\n        const result = buildValueFromFilter({ filter });\n        if (expected instanceof Date) {\n          expect(result).toBeInstanceOf(Date);\n          expect(result).toEqual(expected);\n        } else {\n          expect(result).toBe(expected);\n        }\n      },\n    );\n  });\n\n  describe('NUMBER field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: '5',\n        expected: 5,\n      },\n      {\n        operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n        value: '5',\n        expected: 6,\n      },\n      {\n        operand: ViewFilterOperand.LESS_THAN_OR_EQUAL,\n        value: '5',\n        expected: 4,\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT_EMPTY,\n        value: '5',\n        expected: 5,\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: '5',\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'NUMBER');\n        expect(buildValueFromFilter({ filter })).toBe(expected);\n      },\n    );\n  });\n\n  describe('BOOLEAN field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: 'true',\n        expected: true,\n      },\n      {\n        operand: ViewFilterOperand.IS,\n        value: 'false',\n        expected: false,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'BOOLEAN');\n        expect(buildValueFromFilter({ filter })).toBe(expected);\n      },\n    );\n  });\n\n  describe('ARRAY field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.CONTAINS,\n        value: 'test',\n        expected: 'test',\n      },\n      {\n        operand: ViewFilterOperand.DOES_NOT_CONTAIN,\n        value: 'test',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT_EMPTY,\n        value: 'test',\n        expected: 'test',\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: 'test',\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'ARRAY');\n        expect(buildValueFromFilter({ filter })).toBe(expected);\n      },\n    );\n  });\n\n  describe('RELATION field type', () => {\n    const mockCurrentWorkspaceMember = {\n      id: 'current-workspace-member-id',\n      name: { firstName: 'John', lastName: 'Doe' },\n      locale: 'en',\n      colorScheme: 'Light' as ColorScheme,\n      avatarUrl: '',\n      dateFormat: null,\n      timeFormat: null,\n      timeZone: null,\n      userEmail: 'userEmail',\n    };\n\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: JSON.stringify({\n          isCurrentWorkspaceMemberSelected: false,\n          selectedRecordIds: ['record-1'],\n        }),\n        relationType: RelationType.MANY_TO_ONE,\n        label: 'belongs to one',\n        expected: 'record-1',\n      },\n      {\n        operand: ViewFilterOperand.IS,\n        value: JSON.stringify({\n          isCurrentWorkspaceMemberSelected: true,\n          selectedRecordIds: ['record-1'],\n        }),\n        relationType: RelationType.MANY_TO_ONE,\n        label: 'Assignee',\n        expected: 'current-workspace-member-id',\n      },\n      {\n        operand: ViewFilterOperand.IS,\n        value: JSON.stringify({\n          isCurrentWorkspaceMemberSelected: false,\n          selectedRecordIds: ['record-1', 'record-2'],\n        }),\n        relationType: RelationType.ONE_TO_MANY,\n        label: 'hasmany',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT,\n        value: JSON.stringify({\n          isCurrentWorkspaceMemberSelected: false,\n          selectedRecordIds: ['record-1'],\n        }),\n        relationType: RelationType.MANY_TO_ONE,\n        label: 'Assignee',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: JSON.stringify({\n          isCurrentWorkspaceMemberSelected: false,\n          selectedRecordIds: ['record-1'],\n        }),\n        relationType: RelationType.MANY_TO_ONE,\n        label: 'Assignee',\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\" for $relationType relation',\n      ({ operand, value, relationType, label, expected }) => {\n        const filter = createTestFilter(operand, value, 'RELATION');\n        expect(\n          buildValueFromFilter({\n            filter,\n            relationType,\n            currentWorkspaceMember: mockCurrentWorkspaceMember,\n            label,\n          }),\n        ).toEqual(expected);\n      },\n    );\n  });\n\n  describe('Composite field types', () => {\n    const compositeTypes: FilterableFieldType[] = ['ACTOR', 'FULL_NAME'];\n\n    it.each(compositeTypes)(\n      'should return undefined for composite type %s',\n      (type) => {\n        const filter = createTestFilter(ViewFilterOperand.IS, 'test', type);\n        expect(buildValueFromFilter({ filter })).toBeUndefined();\n      },\n    );\n  });\n\n  describe('RAW_JSON field type', () => {\n    it('should return undefined', () => {\n      const filter = createTestFilter(ViewFilterOperand.IS, 'test', 'RAW_JSON');\n      expect(buildValueFromFilter({ filter })).toBeUndefined();\n    });\n  });\n\n  describe('RATING field type', () => {\n    const mockOptions = [\n      {\n        label: 'Rating 1',\n        value: 'RATING_1',\n        id: '1',\n        position: 1,\n      },\n      {\n        label: 'Rating 2',\n        value: 'RATING_2',\n        id: '2',\n        position: 2,\n      },\n      {\n        label: 'Rating 3',\n        value: 'RATING_3',\n        id: '3',\n        position: 3,\n      },\n    ];\n\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: 'Rating 1',\n        expected: 'RATING_1',\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT_EMPTY,\n        value: 'Rating 2',\n        expected: 'RATING_2',\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: 'Rating 1',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n        value: 'Rating 1',\n        expected: 'RATING_2',\n      },\n      {\n        operand: ViewFilterOperand.LESS_THAN_OR_EQUAL,\n        value: 'Rating 2',\n        expected: 'RATING_1',\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'RATING');\n        expect(\n          buildValueFromFilter({\n            filter,\n            options: mockOptions as FieldMetadataItemOption[],\n          }),\n        ).toBe(expected);\n      },\n    );\n\n    it('should return undefined when option is not found', () => {\n      const filter = createTestFilter(\n        ViewFilterOperand.IS,\n        'Rating 4',\n        'RATING',\n      );\n      expect(\n        buildValueFromFilter({\n          filter,\n          options: mockOptions as FieldMetadataItemOption[],\n        }),\n      ).toBeUndefined();\n    });\n  });\n\n  describe('SELECT field type', () => {\n    const mockOptions = [\n      {\n        label: 'Option 1',\n        value: 'OPTION_1',\n        color: 'red',\n        id: '1',\n        position: 1,\n      },\n      {\n        label: 'Option 2',\n        value: 'OPTION_2',\n        color: 'blue',\n        id: '2',\n        position: 2,\n      },\n    ];\n\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: JSON.stringify(['OPTION_1']),\n        expected: 'OPTION_1',\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT,\n        value: JSON.stringify(['OPTION_1']),\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: JSON.stringify(['OPTION_1']),\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'SELECT');\n        expect(\n          buildValueFromFilter({\n            filter,\n            options: mockOptions as FieldMetadataItemOption[],\n          }),\n        ).toBe(expected);\n      },\n    );\n\n    it('should handle invalid JSON', () => {\n      const filter = createTestFilter(\n        ViewFilterOperand.IS,\n        'invalid-json',\n        'SELECT',\n      );\n      expect(\n        buildValueFromFilter({\n          filter,\n          options: mockOptions as FieldMetadataItemOption[],\n        }),\n      ).toBeUndefined();\n    });\n  });\n\n  describe('MULTI_SELECT field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.CONTAINS,\n        value: JSON.stringify(['OPTION_1', 'OPTION_2']),\n        expected: ['OPTION_1', 'OPTION_2'],\n      },\n      {\n        operand: ViewFilterOperand.DOES_NOT_CONTAIN,\n        value: JSON.stringify(['OPTION_1']),\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: JSON.stringify(['OPTION_1']),\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'MULTI_SELECT');\n        expect(buildValueFromFilter({ filter })).toEqual(expected);\n      },\n    );\n\n    it('should handle invalid JSON', () => {\n      const filter = createTestFilter(\n        ViewFilterOperand.CONTAINS,\n        'invalid-json',\n        'MULTI_SELECT',\n      );\n      expect(buildValueFromFilter({ filter })).toBeUndefined();\n    });\n  });\n\n  describe('UUID field type', () => {\n    it('should return the value', () => {\n      const filter = createTestFilter(\n        ViewFilterOperand.IS,",
            "output_extracted": "import { type FieldMetadataItemOption } from '@/object-metadata/types/FieldMetadataItem';\nimport { type RecordFilter } from '@/object-record/record-filter/types/RecordFilter';\nimport { type ColorScheme } from '@/workspace-member/types/WorkspaceMember';\nimport {\n  type FilterableFieldType,\n  ViewFilterOperand,\n} from 'twenty-shared/types';\nimport { RelationType } from '~/generated-metadata/graphql';\nimport { buildValueFromFilter } from './buildRecordInputFromFilter';\n\n// TODO: fix the dates, and test the not supported types\nconst mockDate = new Date('2024-03-20T12:00:00Z');\n\nbeforeAll(() => {\n  jest.useFakeTimers();\n  jest.setSystemTime(mockDate);\n});\n\nafterAll(() => {\n  jest.useRealTimers();\n});\n\ndescribe('buildValueFromFilter', () => {\n  const createTestFilter = (\n    operand: ViewFilterOperand,\n    value: string,\n    type: FilterableFieldType,\n  ): RecordFilter => ({\n    id: 'test-id',\n    fieldMetadataId: 'test-field-id',\n    value,\n    displayValue: value,\n    type,\n    operand,\n    label: 'Test Label',\n  });\n\n  describe('TEXT field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.CONTAINS,\n        value: 'test',\n        expected: 'test',\n      },\n      {\n        operand: ViewFilterOperand.DOES_NOT_CONTAIN,\n        value: 'test',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT_EMPTY,\n        value: 'test',\n        expected: 'test',\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: 'test',\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'TEXT');\n        expect(buildValueFromFilter({ filter })).toBe(expected);\n      },\n    );\n  });\n\n  describe('DATE_TIME field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_AFTER,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_BEFORE,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_IN_PAST,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_IN_FUTURE,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_TODAY,\n        value: '',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_RELATIVE,\n        value: '',\n        expected: mockDate,\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: '',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT_EMPTY,\n        value: '2024-03-20T12:00:00Z',\n        expected: mockDate,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'DATE_TIME');\n        const result = buildValueFromFilter({ filter });\n        if (expected instanceof Date) {\n          expect(result).toBeInstanceOf(Date);\n          expect(result).toEqual(expected);\n        } else {\n          expect(result).toBe(expected);\n        }\n      },\n    );\n  });\n\n  describe('NUMBER field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: '5',\n        expected: 5,\n      },\n      {\n        operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n        value: '5',\n        expected: 6,\n      },\n      {\n        operand: ViewFilterOperand.LESS_THAN_OR_EQUAL,\n        value: '5',\n        expected: 4,\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT_EMPTY,\n        value: '5',\n        expected: 5,\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: '5',\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'NUMBER');\n        expect(buildValueFromFilter({ filter })).toBe(expected);\n      },\n    );\n  });\n\n  describe('BOOLEAN field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: 'true',\n        expected: true,\n      },\n      {\n        operand: ViewFilterOperand.IS,\n        value: 'false',\n        expected: false,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'BOOLEAN');\n        expect(buildValueFromFilter({ filter })).toBe(expected);\n      },\n    );\n  });\n\n  describe('ARRAY field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.CONTAINS,\n        value: 'test',\n        expected: 'test',\n      },\n      {\n        operand: ViewFilterOperand.DOES_NOT_CONTAIN,\n        value: 'test',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT_EMPTY,\n        value: 'test',\n        expected: 'test',\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: 'test',\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'ARRAY');\n        expect(buildValueFromFilter({ filter })).toBe(expected);\n      },\n    );\n  });\n\n  describe('RELATION field type', () => {\n    const mockCurrentWorkspaceMember = {\n      id: 'current-workspace-member-id',\n      name: { firstName: 'John', lastName: 'Doe' },\n      locale: 'en',\n      colorScheme: 'Light' as ColorScheme,\n      avatarUrl: '',\n      dateFormat: null,\n      timeFormat: null,\n      timeZone: null,\n      userEmail: 'userEmail',\n    };\n\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: JSON.stringify({\n          isCurrentWorkspaceMemberSelected: false,\n          selectedRecordIds: ['record-1'],\n        }),\n        relationType: RelationType.MANY_TO_ONE,\n        label: 'belongs to one',\n        expected: 'record-1',\n      },\n      {\n        operand: ViewFilterOperand.IS,\n        value: JSON.stringify({\n          isCurrentWorkspaceMemberSelected: true,\n          selectedRecordIds: ['record-1'],\n        }),\n        relationType: RelationType.MANY_TO_ONE,\n        label: 'Assignee',\n        expected: 'current-workspace-member-id',\n      },\n      {\n        operand: ViewFilterOperand.IS,\n        value: JSON.stringify({\n          isCurrentWorkspaceMemberSelected: false,\n          selectedRecordIds: ['record-1', 'record-2'],\n        }),\n        relationType: RelationType.ONE_TO_MANY,\n        label: 'hasmany',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT,\n        value: JSON.stringify({\n          isCurrentWorkspaceMemberSelected: false,\n          selectedRecordIds: ['record-1'],\n        }),\n        relationType: RelationType.MANY_TO_ONE,\n        label: 'Assignee',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: JSON.stringify({\n          isCurrentWorkspaceMemberSelected: false,\n          selectedRecordIds: ['record-1'],\n        }),\n        relationType: RelationType.MANY_TO_ONE,\n        label: 'Assignee',\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\" for $relationType relation',\n      ({ operand, value, relationType, label, expected }) => {\n        const filter = createTestFilter(operand, value, 'RELATION');\n        expect(\n          buildValueFromFilter({\n            filter,\n            relationType,\n            currentWorkspaceMember: mockCurrentWorkspaceMember,\n            label,\n          }),\n        ).toEqual(expected);\n      },\n    );\n  });\n\n  describe('Composite field types', () => {\n    const compositeTypes: FilterableFieldType[] = ['ACTOR', 'FULL_NAME'];\n\n    it.each(compositeTypes)(\n      'should return undefined for composite type %s',\n      (type) => {\n        const filter = createTestFilter(ViewFilterOperand.IS, 'test', type);\n        expect(buildValueFromFilter({ filter })).toBeUndefined();\n      },\n    );\n  });\n\n  describe('RAW_JSON field type', () => {\n    it('should return undefined', () => {\n      const filter = createTestFilter(ViewFilterOperand.IS, 'test', 'RAW_JSON');\n      expect(buildValueFromFilter({ filter })).toBeUndefined();\n    });\n  });\n\n  describe('RATING field type', () => {\n    const mockOptions = [\n      {\n        label: 'Rating 1',\n        value: 'RATING_1',\n        id: '1',\n        position: 1,\n      },\n      {\n        label: 'Rating 2',\n        value: 'RATING_2',\n        id: '2',\n        position: 2,\n      },\n      {\n        label: 'Rating 3',\n        value: 'RATING_3',\n        id: '3',\n        position: 3,\n      },\n    ];\n\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: 'Rating 1',\n        expected: 'RATING_1',\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT_EMPTY,\n        value: 'Rating 2',\n        expected: 'RATING_2',\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: 'Rating 1',\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n        value: 'Rating 1',\n        expected: 'RATING_2',\n      },\n      {\n        operand: ViewFilterOperand.LESS_THAN_OR_EQUAL,\n        value: 'Rating 2',\n        expected: 'RATING_1',\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'RATING');\n        expect(\n          buildValueFromFilter({\n            filter,\n            options: mockOptions as FieldMetadataItemOption[],\n          }),\n        ).toBe(expected);\n      },\n    );\n\n    it('should return undefined when option is not found', () => {\n      const filter = createTestFilter(\n        ViewFilterOperand.IS,\n        'Rating 4',\n        'RATING',\n      );\n      expect(\n        buildValueFromFilter({\n          filter,\n          options: mockOptions as FieldMetadataItemOption[],\n        }),\n      ).toBeUndefined();\n    });\n  });\n\n  describe('SELECT field type', () => {\n    const mockOptions = [\n      {\n        label: 'Option 1',\n        value: 'OPTION_1',\n        color: 'red',\n        id: '1',\n        position: 1,\n      },\n      {\n        label: 'Option 2',\n        value: 'OPTION_2',\n        color: 'blue',\n        id: '2',\n        position: 2,\n      },\n    ];\n\n    const testCases = [\n      {\n        operand: ViewFilterOperand.IS,\n        value: JSON.stringify(['OPTION_1']),\n        expected: 'OPTION_1',\n      },\n      {\n        operand: ViewFilterOperand.IS_NOT,\n        value: JSON.stringify(['OPTION_1']),\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: JSON.stringify(['OPTION_1']),\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'SELECT');\n        expect(\n          buildValueFromFilter({\n            filter,\n            options: mockOptions as FieldMetadataItemOption[],\n          }),\n        ).toBe(expected);\n      },\n    );\n\n    it('should handle invalid JSON', () => {\n      const filter = createTestFilter(\n        ViewFilterOperand.IS,\n        'invalid-json',\n        'SELECT',\n      );\n      expect(\n        buildValueFromFilter({\n          filter,\n          options: mockOptions as FieldMetadataItemOption[],\n        }),\n      ).toBeUndefined();\n    });\n  });\n\n  describe('MULTI_SELECT field type', () => {\n    const testCases = [\n      {\n        operand: ViewFilterOperand.CONTAINS,\n        value: JSON.stringify(['OPTION_1', 'OPTION_2']),\n        expected: ['OPTION_1', 'OPTION_2'],\n      },\n      {\n        operand: ViewFilterOperand.DOES_NOT_CONTAIN,\n        value: JSON.stringify(['OPTION_1']),\n        expected: undefined,\n      },\n      {\n        operand: ViewFilterOperand.IS_EMPTY,\n        value: JSON.stringify(['OPTION_1']),\n        expected: undefined,\n      },\n    ];\n\n    it.each(testCases)(\n      'should handle $operand with value \"$value\"',\n      ({ operand, value, expected }) => {\n        const filter = createTestFilter(operand, value, 'MULTI_SELECT');\n        expect(buildValueFromFilter({ filter })).toEqual(expected);\n      },\n    );\n\n    it('should handle invalid JSON', () => {\n      const filter = createTestFilter(\n        ViewFilterOperand.CONTAINS,\n        'invalid-json',\n        'MULTI_SELECT',\n      );\n      expect(buildValueFromFilter({ filter })).toBeUndefined();\n    });\n  });\n\n  describe('UUID field type', () => {\n    it('should return the value', () => {\n      const filter = createTestFilter(\n        ViewFilterOperand.IS,",
            "cost": 0.12818000000000002
        },
        "twentyhq__twenty.main/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts": {
            "output": "import { type CurrentWorkspaceMember } from '@/auth/states/currentWorkspaceMemberState';\nimport { type FieldMetadataItemOption } from '@/object-metadata/types/FieldMetadataItem';\nimport { isCompositeFieldType } from '@/object-record/object-filter-dropdown/utils/isCompositeFieldType';\n\nimport {\n  type RecordFilter,\n  type RecordFilterToRecordInputOperand,\n} from '@/object-record/record-filter/types/RecordFilter';\nimport { FILTER_OPERANDS_MAP } from '@/object-record/record-filter/utils/getRecordFilterOperands';\nimport { ViewFilterOperand } from 'twenty-shared/types';\nimport { assertUnreachable, parseJson } from 'twenty-shared/utils';\nimport { RelationType } from '~/generated-metadata/graphql';\n\nexport const buildValueFromFilter = ({\n  filter,\n  options,\n  relationType,\n  currentWorkspaceMember,\n  label,\n}: {\n  filter: RecordFilter;\n  options?: FieldMetadataItemOption[];\n  relationType?: RelationType;\n  currentWorkspaceMember?: CurrentWorkspaceMember;\n  label?: string;\n}) => {\n  if (isCompositeFieldType(filter.type)) {\n    return;\n  }\n\n  if (filter.type === 'RAW_JSON') {\n    return;\n  }\n\n  const operands = FILTER_OPERANDS_MAP[filter.type];\n  if (!operands.some((operand) => operand === filter.operand)) {\n    throw new Error('Operand not supported for this field type');\n  }\n\n  switch (filter.type) {\n    case 'TEXT': {\n      return computeValueFromFilterText(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['TEXT'][number],\n        filter.value,\n      );\n    }\n    case 'RATING':\n      return computeValueFromFilterRating(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['RATING'][number],\n        filter.value,\n        options,\n      );\n    case 'DATE_TIME':\n    case 'DATE':\n      return computeValueFromFilterDate(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['DATE_TIME'][number],\n        filter.value,\n      );\n    case 'NUMBER':\n      return computeValueFromFilterNumber(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['NUMBER'][number],\n        filter.value,\n      );\n    case 'BOOLEAN':\n      return computeValueFromFilterBoolean(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['BOOLEAN'][number],\n        filter.value,\n      );\n    case 'TS_VECTOR':\n      return computeValueFromFilterTSVector(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['TS_VECTOR'][number],\n        filter.value,\n      );\n    case 'ARRAY':\n      return computeValueFromFilterArray(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['ARRAY'][number],\n        filter.value,\n      );\n    case 'SELECT':\n      return computeValueFromFilterSelect(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['SELECT'][number],\n        filter.value,\n        options,\n      );\n    case 'MULTI_SELECT':\n      return computeValueFromFilterMultiSelect(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['MULTI_SELECT'][number],\n        filter.value,\n      );\n    case 'RELATION': {\n      return computeValueFromFilterRelation(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['RELATION'][number],\n        filter.value,\n        relationType,\n        currentWorkspaceMember,\n        label,\n      );\n    }\n    case 'UUID':\n      return computeValueFromFilterUUID(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['UUID'][number],\n        filter.value,\n      );\n    default:\n      assertUnreachable(filter.type);\n  }\n};\n\nconst computeValueFromFilterText = (\n  operand: RecordFilterToRecordInputOperand<'TEXT'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.CONTAINS:\n      return value;\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return value;\n    case ViewFilterOperand.IS_EMPTY:\n    case ViewFilterOperand.DOES_NOT_CONTAIN:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterDate = (\n  operand: RecordFilterToRecordInputOperand<'DATE_TIME'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.IS:\n    case ViewFilterOperand.IS_AFTER:\n    case ViewFilterOperand.IS_BEFORE:\n      return new Date(value);\n    case ViewFilterOperand.IS_TODAY:\n    case ViewFilterOperand.IS_NOT_EMPTY:\n    case ViewFilterOperand.IS_IN_PAST:\n    case ViewFilterOperand.IS_IN_FUTURE:\n    case ViewFilterOperand.IS_RELATIVE:\n      return new Date();\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterNumber = (\n  operand: RecordFilterToRecordInputOperand<'NUMBER'>,\n  value: string,\n) => {\n  switch (operand) {\n    //TODO: we shouln't create values from those filters as it makes no sense for the user\n    case ViewFilterOperand.GREATER_THAN_OR_EQUAL:\n      return Number(value) + 1;\n    case ViewFilterOperand.LESS_THAN_OR_EQUAL:\n      return Number(value) - 1;\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return Number(value);\n    case ViewFilterOperand.IS:\n      return Number(value);\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterBoolean = (\n  operand: RecordFilterToRecordInputOperand<'BOOLEAN'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.IS:\n      return value === 'true';\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterArray = (\n  operand: RecordFilterToRecordInputOperand<'ARRAY'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.CONTAINS:\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return value;\n    case ViewFilterOperand.DOES_NOT_CONTAIN:\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterRating = (\n  operand: RecordFilterToRecordInputOperand<'RATING'>,\n  value: string,\n  options?: FieldMetadataItemOption[],\n) => {\n  const option = options?.find((option) => option.label === value);\n  if (!option) {\n    return undefined;\n  }\n\n  switch (operand) {\n    case ViewFilterOperand.IS:\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return option.value;\n    case ViewFilterOperand.GREATER_THAN_OR_EQUAL: {\n      const plusOne = options?.find(\n        (opt) => opt.position === option.position + 1,\n      )?.value;\n      return plusOne ? plusOne : option.value;\n    }\n    case ViewFilterOperand.LESS_THAN_OR_EQUAL: {\n      const minusOne = options?.find(\n        (opt) => opt.position === option.position - 1,\n      )?.value;\n      return minusOne ? minusOne : option.value;\n    }\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterSelect = (\n  operand: RecordFilterToRecordInputOperand<'SELECT'>,\n  value: string,\n  options?: FieldMetadataItemOption[],\n) => {\n  switch (operand) {\n    case ViewFilterOperand.IS:\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      try {\n        const valueParsed = parseJson<string[]>(value)?.[0];\n        const option = options?.find((option) => option.value === valueParsed);\n        if (!option) {\n          return undefined;\n        }\n        return option.value;\n      } catch {\n        return undefined;\n      }\n    case ViewFilterOperand.IS_NOT:\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterMultiSelect = (\n  operand: RecordFilterToRecordInputOperand<'MULTI_SELECT'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.CONTAINS:\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      try {\n        const parsedValue = parseJson<string[]>(value);\n        return parsedValue ? parsedValue : undefined;\n      } catch {\n        return undefined;\n      }\n    case ViewFilterOperand.DOES_NOT_CONTAIN:\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterRelation = (\n  operand: RecordFilterToRecordInputOperand<'RELATION'>,\n  value: string,\n  relationType?: RelationType,\n  currentWorkspaceMember?: CurrentWorkspaceMember,\n  label?: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.IS: {\n      const parsedValue = parseJson<{\n        isCurrentWorkspaceMemberSelected: boolean;\n        selectedRecordIds: string[];\n      }>(value);\n      if (relationType === RelationType.MANY_TO_ONE) {\n        if (label === 'Assignee') {\n          return parsedValue?.isCurrentWorkspaceMemberSelected\n            ? currentWorkspaceMember?.id\n            : undefined;\n        } else {\n          return parsedValue?.selectedRecordIds?.[0];\n        }\n      }\n      return undefined; //todo\n    }\n    case ViewFilterOperand.IS_NOT:\n    case ViewFilterOperand.IS_NOT_EMPTY: // todo\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterTSVector = (\n  operand: RecordFilterToRecordInputOperand<'TS_VECTOR'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.VECTOR_SEARCH:\n      return value;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterUUID = (\n  operand: RecordFilterToRecordInputOperand<'UUID'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.IS:\n      return value;\n    default:\n      assertUnreachable(operand);\n  }\n};",
            "output_extracted": "import { type CurrentWorkspaceMember } from '@/auth/states/currentWorkspaceMemberState';\nimport { type FieldMetadataItemOption } from '@/object-metadata/types/FieldMetadataItem';\nimport { isCompositeFieldType } from '@/object-record/object-filter-dropdown/utils/isCompositeFieldType';\n\nimport {\n  type RecordFilter,\n  type RecordFilterToRecordInputOperand,\n} from '@/object-record/record-filter/types/RecordFilter';\nimport { FILTER_OPERANDS_MAP } from '@/object-record/record-filter/utils/getRecordFilterOperands';\nimport { ViewFilterOperand } from 'twenty-shared/types';\nimport { assertUnreachable, parseJson } from 'twenty-shared/utils';\nimport { RelationType } from '~/generated-metadata/graphql';\n\nexport const buildValueFromFilter = ({\n  filter,\n  options,\n  relationType,\n  currentWorkspaceMember,\n  label,\n}: {\n  filter: RecordFilter;\n  options?: FieldMetadataItemOption[];\n  relationType?: RelationType;\n  currentWorkspaceMember?: CurrentWorkspaceMember;\n  label?: string;\n}) => {\n  if (isCompositeFieldType(filter.type)) {\n    return;\n  }\n\n  if (filter.type === 'RAW_JSON') {\n    return;\n  }\n\n  const operands = FILTER_OPERANDS_MAP[filter.type];\n  if (!operands.some((operand) => operand === filter.operand)) {\n    throw new Error('Operand not supported for this field type');\n  }\n\n  switch (filter.type) {\n    case 'TEXT': {\n      return computeValueFromFilterText(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['TEXT'][number],\n        filter.value,\n      );\n    }\n    case 'RATING':\n      return computeValueFromFilterRating(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['RATING'][number],\n        filter.value,\n        options,\n      );\n    case 'DATE_TIME':\n    case 'DATE':\n      return computeValueFromFilterDate(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['DATE_TIME'][number],\n        filter.value,\n      );\n    case 'NUMBER':\n      return computeValueFromFilterNumber(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['NUMBER'][number],\n        filter.value,\n      );\n    case 'BOOLEAN':\n      return computeValueFromFilterBoolean(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['BOOLEAN'][number],\n        filter.value,\n      );\n    case 'TS_VECTOR':\n      return computeValueFromFilterTSVector(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['TS_VECTOR'][number],\n        filter.value,\n      );\n    case 'ARRAY':\n      return computeValueFromFilterArray(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['ARRAY'][number],\n        filter.value,\n      );\n    case 'SELECT':\n      return computeValueFromFilterSelect(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['SELECT'][number],\n        filter.value,\n        options,\n      );\n    case 'MULTI_SELECT':\n      return computeValueFromFilterMultiSelect(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['MULTI_SELECT'][number],\n        filter.value,\n      );\n    case 'RELATION': {\n      return computeValueFromFilterRelation(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['RELATION'][number],\n        filter.value,\n        relationType,\n        currentWorkspaceMember,\n        label,\n      );\n    }\n    case 'UUID':\n      return computeValueFromFilterUUID(\n        filter.operand as (typeof FILTER_OPERANDS_MAP)['UUID'][number],\n        filter.value,\n      );\n    default:\n      assertUnreachable(filter.type);\n  }\n};\n\nconst computeValueFromFilterText = (\n  operand: RecordFilterToRecordInputOperand<'TEXT'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.CONTAINS:\n      return value;\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return value;\n    case ViewFilterOperand.IS_EMPTY:\n    case ViewFilterOperand.DOES_NOT_CONTAIN:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterDate = (\n  operand: RecordFilterToRecordInputOperand<'DATE_TIME'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.IS:\n    case ViewFilterOperand.IS_AFTER:\n    case ViewFilterOperand.IS_BEFORE:\n      return new Date(value);\n    case ViewFilterOperand.IS_TODAY:\n    case ViewFilterOperand.IS_NOT_EMPTY:\n    case ViewFilterOperand.IS_IN_PAST:\n    case ViewFilterOperand.IS_IN_FUTURE:\n    case ViewFilterOperand.IS_RELATIVE:\n      return new Date();\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterNumber = (\n  operand: RecordFilterToRecordInputOperand<'NUMBER'>,\n  value: string,\n) => {\n  switch (operand) {\n    //TODO: we shouln't create values from those filters as it makes no sense for the user\n    case ViewFilterOperand.GREATER_THAN_OR_EQUAL:\n      return Number(value) + 1;\n    case ViewFilterOperand.LESS_THAN_OR_EQUAL:\n      return Number(value) - 1;\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return Number(value);\n    case ViewFilterOperand.IS:\n      return Number(value);\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterBoolean = (\n  operand: RecordFilterToRecordInputOperand<'BOOLEAN'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.IS:\n      return value === 'true';\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterArray = (\n  operand: RecordFilterToRecordInputOperand<'ARRAY'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.CONTAINS:\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return value;\n    case ViewFilterOperand.DOES_NOT_CONTAIN:\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterRating = (\n  operand: RecordFilterToRecordInputOperand<'RATING'>,\n  value: string,\n  options?: FieldMetadataItemOption[],\n) => {\n  const option = options?.find((option) => option.label === value);\n  if (!option) {\n    return undefined;\n  }\n\n  switch (operand) {\n    case ViewFilterOperand.IS:\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return option.value;\n    case ViewFilterOperand.GREATER_THAN_OR_EQUAL: {\n      const plusOne = options?.find(\n        (opt) => opt.position === option.position + 1,\n      )?.value;\n      return plusOne ? plusOne : option.value;\n    }\n    case ViewFilterOperand.LESS_THAN_OR_EQUAL: {\n      const minusOne = options?.find(\n        (opt) => opt.position === option.position - 1,\n      )?.value;\n      return minusOne ? minusOne : option.value;\n    }\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterSelect = (\n  operand: RecordFilterToRecordInputOperand<'SELECT'>,\n  value: string,\n  options?: FieldMetadataItemOption[],\n) => {\n  switch (operand) {\n    case ViewFilterOperand.IS:\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      try {\n        const valueParsed = parseJson<string[]>(value)?.[0];\n        const option = options?.find((option) => option.value === valueParsed);\n        if (!option) {\n          return undefined;\n        }\n        return option.value;\n      } catch {\n        return undefined;\n      }\n    case ViewFilterOperand.IS_NOT:\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterMultiSelect = (\n  operand: RecordFilterToRecordInputOperand<'MULTI_SELECT'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.CONTAINS:\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      try {\n        const parsedValue = parseJson<string[]>(value);\n        return parsedValue ? parsedValue : undefined;\n      } catch {\n        return undefined;\n      }\n    case ViewFilterOperand.DOES_NOT_CONTAIN:\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterRelation = (\n  operand: RecordFilterToRecordInputOperand<'RELATION'>,\n  value: string,\n  relationType?: RelationType,\n  currentWorkspaceMember?: CurrentWorkspaceMember,\n  label?: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.IS: {\n      const parsedValue = parseJson<{\n        isCurrentWorkspaceMemberSelected: boolean;\n        selectedRecordIds: string[];\n      }>(value);\n      if (relationType === RelationType.MANY_TO_ONE) {\n        if (label === 'Assignee') {\n          return parsedValue?.isCurrentWorkspaceMemberSelected\n            ? currentWorkspaceMember?.id\n            : undefined;\n        } else {\n          return parsedValue?.selectedRecordIds?.[0];\n        }\n      }\n      return undefined; //todo\n    }\n    case ViewFilterOperand.IS_NOT:\n    case ViewFilterOperand.IS_NOT_EMPTY: // todo\n    case ViewFilterOperand.IS_EMPTY:\n      return undefined;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterTSVector = (\n  operand: RecordFilterToRecordInputOperand<'TS_VECTOR'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.VECTOR_SEARCH:\n      return value;\n    default:\n      assertUnreachable(operand);\n  }\n};\n\nconst computeValueFromFilterUUID = (\n  operand: RecordFilterToRecordInputOperand<'UUID'>,\n  value: string,\n) => {\n  switch (operand) {\n    case ViewFilterOperand.IS:\n      return value;\n    default:\n      assertUnreachable(operand);\n  }\n};",
            "cost": 0.09439
        },
        "twentyhq__twenty.main/packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts": {
            "output": "import { ViewFilterOperand } from 'twenty-shared/types';\n\nconst emptyOperands = [\n  ViewFilterOperand.IS_EMPTY,\n  ViewFilterOperand.IS_NOT_EMPTY,\n] as const;\n\nconst relationOperands = [\n  ViewFilterOperand.IS,\n  ViewFilterOperand.IS_NOT,\n] as const;\n\nconst defaultOperands = [\n  ViewFilterOperand.IS,\n  ViewFilterOperand.IS_NOT,\n  ViewFilterOperand.CONTAINS,\n  ViewFilterOperand.DOES_NOT_CONTAIN,\n  ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n  ViewFilterOperand.LESS_THAN_OR_EQUAL,\n  ...emptyOperands,\n] as const;\n\nexport const FILTER_OPERANDS_MAP = {\n  TEXT: [\n    ViewFilterOperand.CONTAINS,\n    ViewFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  NUMBER: [\n    ViewFilterOperand.IS,\n    ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n    ViewFilterOperand.LESS_THAN_OR_EQUAL,\n    ...emptyOperands,\n  ],\n  RAW_JSON: [\n    ViewFilterOperand.CONTAINS,\n    ViewFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  DATE_TIME: [\n    ViewFilterOperand.IS,\n    ViewFilterOperand.IS_IN_PAST,\n    ViewFilterOperand.IS_IN_FUTURE,\n    ViewFilterOperand.IS_TODAY,\n    ViewFilterOperand.IS_BEFORE,\n    ViewFilterOperand.IS_AFTER,\n    ViewFilterOperand.IS_RELATIVE,\n    ...emptyOperands,\n  ],\n  RATING: [ViewFilterOperand.IS, ViewFilterOperand.IS_NOT, ...emptyOperands],\n  RELATION: [...relationOperands, ...emptyOperands],\n  MULTI_SELECT: [\n    ViewFilterOperand.CONTAINS,\n    ViewFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  SELECT: [ViewFilterOperand.IS, ViewFilterOperand.IS_NOT, ...emptyOperands],\n  ARRAY: [\n    ViewFilterOperand.CONTAINS,\n    ViewFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  BOOLEAN: [ViewFilterOperand.IS],\n  UUID: [ViewFilterOperand.IS, ViewFilterOperand.IS_NOT],\n  NUMERIC: [\n    ViewFilterOperand.IS,\n    ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n    ViewFilterOperand.LESS_THAN_OR_EQUAL,\n    ...emptyOperands,\n  ],\n};\n\nexport const COMPOSITE_FIELD_FILTER_OPERANDS_MAP = {\n  CURRENCY: {\n    currencyCode: [\n      ViewFilterOperand.IS,\n      ViewFilterOperand.IS_NOT,\n      ...emptyOperands,\n    ],\n    amountMicros: [\n      ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n      ViewFilterOperand.LESS_THAN_OR_EQUAL,\n      ViewFilterOperand.IS,\n      ViewFilterOperand.IS_NOT,\n      ...emptyOperands,\n    ],\n  },\n};\n\nexport const getStepFilterOperands = ({\n  filterType,\n  subFieldName,\n}: {\n  filterType: string | undefined;\n  subFieldName: string | undefined;\n}): readonly ViewFilterOperand[] => {\n  switch (filterType) {\n    case 'TEXT':\n    case 'EMAILS':\n    case 'FULL_NAME':\n    case 'ADDRESS':\n    case 'LINKS':\n    case 'PHONES':\n      return FILTER_OPERANDS_MAP.TEXT;\n    case 'CURRENCY': {\n      if (subFieldName === 'currencyCode') {\n        return COMPOSITE_FIELD_FILTER_OPERANDS_MAP.CURRENCY.currencyCode;\n      } else {\n        return COMPOSITE_FIELD_FILTER_OPERANDS_MAP.CURRENCY.amountMicros;\n      }\n    }\n    case 'NUMBER':\n    case 'number':\n      return FILTER_OPERANDS_MAP.NUMBER;\n    case 'RAW_JSON':\n      return FILTER_OPERANDS_MAP.RAW_JSON;\n    case 'DATE_TIME':\n    case 'DATE':\n      return FILTER_OPERANDS_MAP.DATE_TIME;\n    case 'RATING':\n      return FILTER_OPERANDS_MAP.RATING;\n    case 'RELATION':\n      return FILTER_OPERANDS_MAP.RELATION;\n    case 'MULTI_SELECT':\n      return FILTER_OPERANDS_MAP.MULTI_SELECT;\n    case 'SELECT':\n      return FILTER_OPERANDS_MAP.SELECT;\n    case 'ARRAY':\n    case 'array':\n      return FILTER_OPERANDS_MAP.ARRAY;\n    case 'BOOLEAN':\n    case 'boolean':\n      return FILTER_OPERANDS_MAP.BOOLEAN;\n    case 'UUID':\n      return FILTER_OPERANDS_MAP.UUID;\n    case 'NUMERIC':\n      return FILTER_OPERANDS_MAP.NUMERIC;\n    default:\n      return defaultOperands;\n  }\n};",
            "output_extracted": "import { ViewFilterOperand } from 'twenty-shared/types';\n\nconst emptyOperands = [\n  ViewFilterOperand.IS_EMPTY,\n  ViewFilterOperand.IS_NOT_EMPTY,\n] as const;\n\nconst relationOperands = [\n  ViewFilterOperand.IS,\n  ViewFilterOperand.IS_NOT,\n] as const;\n\nconst defaultOperands = [\n  ViewFilterOperand.IS,\n  ViewFilterOperand.IS_NOT,\n  ViewFilterOperand.CONTAINS,\n  ViewFilterOperand.DOES_NOT_CONTAIN,\n  ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n  ViewFilterOperand.LESS_THAN_OR_EQUAL,\n  ...emptyOperands,\n] as const;\n\nexport const FILTER_OPERANDS_MAP = {\n  TEXT: [\n    ViewFilterOperand.CONTAINS,\n    ViewFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  NUMBER: [\n    ViewFilterOperand.IS,\n    ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n    ViewFilterOperand.LESS_THAN_OR_EQUAL,\n    ...emptyOperands,\n  ],\n  RAW_JSON: [\n    ViewFilterOperand.CONTAINS,\n    ViewFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  DATE_TIME: [\n    ViewFilterOperand.IS,\n    ViewFilterOperand.IS_IN_PAST,\n    ViewFilterOperand.IS_IN_FUTURE,\n    ViewFilterOperand.IS_TODAY,\n    ViewFilterOperand.IS_BEFORE,\n    ViewFilterOperand.IS_AFTER,\n    ViewFilterOperand.IS_RELATIVE,\n    ...emptyOperands,\n  ],\n  RATING: [ViewFilterOperand.IS, ViewFilterOperand.IS_NOT, ...emptyOperands],\n  RELATION: [...relationOperands, ...emptyOperands],\n  MULTI_SELECT: [\n    ViewFilterOperand.CONTAINS,\n    ViewFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  SELECT: [ViewFilterOperand.IS, ViewFilterOperand.IS_NOT, ...emptyOperands],\n  ARRAY: [\n    ViewFilterOperand.CONTAINS,\n    ViewFilterOperand.DOES_NOT_CONTAIN,\n    ...emptyOperands,\n  ],\n  BOOLEAN: [ViewFilterOperand.IS],\n  UUID: [ViewFilterOperand.IS, ViewFilterOperand.IS_NOT],\n  NUMERIC: [\n    ViewFilterOperand.IS,\n    ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n    ViewFilterOperand.LESS_THAN_OR_EQUAL,\n    ...emptyOperands,\n  ],\n};\n\nexport const COMPOSITE_FIELD_FILTER_OPERANDS_MAP = {\n  CURRENCY: {\n    currencyCode: [\n      ViewFilterOperand.IS,\n      ViewFilterOperand.IS_NOT,\n      ...emptyOperands,\n    ],\n    amountMicros: [\n      ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n      ViewFilterOperand.LESS_THAN_OR_EQUAL,\n      ViewFilterOperand.IS,\n      ViewFilterOperand.IS_NOT,\n      ...emptyOperands,\n    ],\n  },\n};\n\nexport const getStepFilterOperands = ({\n  filterType,\n  subFieldName,\n}: {\n  filterType: string | undefined;\n  subFieldName: string | undefined;\n}): readonly ViewFilterOperand[] => {\n  switch (filterType) {\n    case 'TEXT':\n    case 'EMAILS':\n    case 'FULL_NAME':\n    case 'ADDRESS':\n    case 'LINKS':\n    case 'PHONES':\n      return FILTER_OPERANDS_MAP.TEXT;\n    case 'CURRENCY': {\n      if (subFieldName === 'currencyCode') {\n        return COMPOSITE_FIELD_FILTER_OPERANDS_MAP.CURRENCY.currencyCode;\n      } else {\n        return COMPOSITE_FIELD_FILTER_OPERANDS_MAP.CURRENCY.amountMicros;\n      }\n    }\n    case 'NUMBER':\n    case 'number':\n      return FILTER_OPERANDS_MAP.NUMBER;\n    case 'RAW_JSON':\n      return FILTER_OPERANDS_MAP.RAW_JSON;\n    case 'DATE_TIME':\n    case 'DATE':\n      return FILTER_OPERANDS_MAP.DATE_TIME;\n    case 'RATING':\n      return FILTER_OPERANDS_MAP.RATING;\n    case 'RELATION':\n      return FILTER_OPERANDS_MAP.RELATION;\n    case 'MULTI_SELECT':\n      return FILTER_OPERANDS_MAP.MULTI_SELECT;\n    case 'SELECT':\n      return FILTER_OPERANDS_MAP.SELECT;\n    case 'ARRAY':\n    case 'array':\n      return FILTER_OPERANDS_MAP.ARRAY;\n    case 'BOOLEAN':\n    case 'boolean':\n      return FILTER_OPERANDS_MAP.BOOLEAN;\n    case 'UUID':\n      return FILTER_OPERANDS_MAP.UUID;\n    case 'NUMERIC':\n      return FILTER_OPERANDS_MAP.NUMERIC;\n    default:\n      return defaultOperands;\n  }\n};",
            "cost": 0.046585
        },
        "twentyhq__twenty.main/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts": {
            "output": "import {\n  type StepFilter,\n  type StepFilterGroup,\n  StepLogicalOperator,\n  ViewFilterOperand,\n} from 'twenty-shared/types';\n\nimport { evaluateFilterConditions } from 'src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util';\n\ndescribe('evaluateFilterConditions', () => {\n  type ResolvedFilter = Omit<StepFilter, 'value' | 'stepOutputKey'> & {\n    rightOperand: unknown;\n    leftOperand: unknown;\n  };\n\n  const createFilter = (\n    operand: ViewFilterOperand,\n    leftOperand: unknown,\n    rightOperand: unknown,\n    type = 'TEXT',\n  ): ResolvedFilter => ({\n    id: 'filter1',\n    type: type,\n    rightOperand,\n    operand,\n    stepFilterGroupId: 'group1',\n    leftOperand,\n  });\n\n  describe('empty inputs', () => {\n    it('should return true when no filters or groups are provided', () => {\n      const result = evaluateFilterConditions({\n        filterGroups: [],\n        filters: [],\n      });\n\n      expect(result).toBe(true);\n    });\n\n    it('should return true when inputs are undefined', () => {\n      const result = evaluateFilterConditions({});\n\n      expect(result).toBe(true);\n    });\n  });\n\n  describe('single filter operands', () => {\n    describe('Relation/UUID filter operands', () => {\n      it('should return true when values are equal (RELATION)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          'John',\n          'John',\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when values are not equal (RELATION)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          'John',\n          'Jane',\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return false when values are equal (IsNot RELATION)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          'John',\n          'John',\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return true when values are not equal (IsNot RELATION)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          'John',\n          'Jane',\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      // Enhanced relation filter tests with object id extraction\n      it('should extract id from left operand object for relation comparison', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const leftObject = { id: uuid1, name: 'John Doe' };\n        const rightValue = uuid1;\n\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          leftObject,\n          rightValue,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should extract id from right operand object for relation comparison', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const leftValue = uuid1;\n        const rightObject = { id: uuid1, name: 'John Doe' };\n\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          leftValue,\n          rightObject,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should extract id from both operands when they are objects for relation comparison', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const leftObject = { id: uuid1, name: 'John Doe' };\n        const rightObject = { id: uuid1, title: 'Admin' };\n\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          leftObject,\n          rightObject,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when extracted ids do not match for relation comparison', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const uuid2 = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n        const leftObject = { id: uuid1, name: 'John Doe' };\n        const rightObject = { id: uuid2, name: 'Jane Smith' };\n\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          leftObject,\n          rightObject,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should handle IsNot with object id extraction for relation comparison', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const uuid2 = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n        const leftObject = { id: uuid1, name: 'John Doe' };\n        const rightObject = { id: uuid2, name: 'Jane Smith' };\n\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          leftObject,\n          rightObject,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should handle objects without id property for relation comparison', () => {\n        const leftObject = { name: 'John Doe' };\n        const rightObject = { name: 'John Doe' };\n\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          leftObject,\n          rightObject,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false); // Objects are different references\n      });\n\n      it('should throw error for unsupported relation filter operand', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const uuid2 = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n        const filter = createFilter(\n          ViewFilterOperand.CONTAINS,\n          uuid1,\n          uuid2,\n          'RELATION',\n        );\n\n        expect(() => evaluateFilterConditions({ filters: [filter] })).toThrow(\n          'Operand CONTAINS not supported for relation filter',\n        );\n      });\n    });\n\n    describe('UUID filter operands', () => {\n      const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n      const uuid2 = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n\n      it('should return true when UUIDs are equal (Is)', () => {\n        const filter = createFilter(ViewFilterOperand.IS, uuid1, uuid1, 'UUID');\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when UUIDs are not equal (Is)', () => {\n        const filter = createFilter(ViewFilterOperand.IS, uuid1, uuid2, 'UUID');\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return false when UUIDs are equal (IsNot)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          uuid1,\n          uuid1,\n          'UUID',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return true when UUIDs are not equal (IsNot)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          uuid1,\n          uuid2,\n          'UUID',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should handle null/undefined UUIDs with Is operand', () => {\n        const filter1 = createFilter(ViewFilterOperand.IS, null, null, 'UUID');\n        const filter2 = createFilter(\n          ViewFilterOperand.IS,\n          undefined,\n          undefined,\n          'UUID',\n        );\n        const filter3 = createFilter(ViewFilterOperand.IS, uuid1, null, 'UUID');\n\n        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n      });\n\n      it('should handle null/undefined UUIDs with IsNot operand', () => {\n        const filter1 = createFilter(\n          ViewFilterOperand.IS_NOT,\n          null,\n          null,\n          'UUID',\n        );\n        const filter2 = createFilter(\n          ViewFilterOperand.IS_NOT,\n          undefined,\n          undefined,\n          'UUID',\n        );\n        const filter3 = createFilter(\n          ViewFilterOperand.IS_NOT,\n          uuid1,\n          null,\n          'UUID',\n        );\n\n        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(false);\n        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n      });\n\n      it('should handle empty string UUIDs', () => {\n        const filter1 = createFilter(ViewFilterOperand.IS, '', '', 'UUID');\n        const filter2 = createFilter(ViewFilterOperand.IS, uuid1, '', 'UUID');\n\n        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n      });\n\n      it('should throw error for unsupported UUID filter operand', () => {\n        const filter = createFilter(\n          ViewFilterOperand.CONTAINS,\n          uuid1,\n          uuid2,\n          'UUID',\n        );\n\n        expect(() => evaluateFilterConditions({ filters: [filter] })).toThrow(\n          'Operand CONTAINS not supported for uuid filter',\n        );\n      });\n    });\n\n    describe('Select filter operands', () => {\n      it('should return true when there are common values (SELECT)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          ['John'],\n          ['John', 'Jane'],\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when there are no common values (SELECT)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          ['John'],\n          ['Jane'],\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return true when there are no common values (IsNot)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          ['John'],\n          ['Jane'],\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return true when there are no values (IsEmpty)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_EMPTY,\n          [],\n          '',\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when there is a value (IsEmpty)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_EMPTY,\n          ['John'],\n          '',\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return true when there are values (IsNotEmpty)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT_EMPTY,\n          ['John'],\n          '',\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n    });\n\n    describe('Boolean filter operands', () => {\n      it('should return true when boolean values are equal', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          true,\n          true,\n          'BOOLEAN',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when boolean values are not equal', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          true,\n          false,\n          'BOOLEAN',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should handle truthy/falsy conversion', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          'true',\n          true,\n          'BOOLEAN',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n    });\n\n    describe('numeric operands', () => {\n      it('should handle GreaterThanOrEqual operand correctly', () => {\n        const filter1 = createFilter(\n          ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n          25,\n          25,\n          'NUMBER',\n        );\n        const filter2 = createFilter(\n          ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n          30,\n          25,\n          'NUMBER',\n        );\n        const filter3 = createFilter(\n          ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n          20,\n          25,\n          'NUMBER',\n        );\n\n        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n      });\n\n      it('should handle LessThanOrEqual operand correctly', () => {\n        const filter1 = createFilter(\n          ViewFilterOperand.LESS_THAN_OR_EQUAL,\n          25,\n          25,\n          'NUMBER',\n        );\n        const filter2 = createFilter(\n          ViewFilterOperand.LESS_THAN_OR_EQUAL,\n          20,\n          25,\n          'NUMBER',\n        );\n        const filter3 = createFilter(\n          ViewFilterOperand.LESS_THAN_OR_EQUAL,\n          30,\n          25,\n          'NUMBER',\n        );\n\n        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n        expect(evaluateFilterConditions({ filters:",
            "output_extracted": "import {\n  type StepFilter,\n  type StepFilterGroup,\n  StepLogicalOperator,\n  ViewFilterOperand,\n} from 'twenty-shared/types';\n\nimport { evaluateFilterConditions } from 'src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util';\n\ndescribe('evaluateFilterConditions', () => {\n  type ResolvedFilter = Omit<StepFilter, 'value' | 'stepOutputKey'> & {\n    rightOperand: unknown;\n    leftOperand: unknown;\n  };\n\n  const createFilter = (\n    operand: ViewFilterOperand,\n    leftOperand: unknown,\n    rightOperand: unknown,\n    type = 'TEXT',\n  ): ResolvedFilter => ({\n    id: 'filter1',\n    type: type,\n    rightOperand,\n    operand,\n    stepFilterGroupId: 'group1',\n    leftOperand,\n  });\n\n  describe('empty inputs', () => {\n    it('should return true when no filters or groups are provided', () => {\n      const result = evaluateFilterConditions({\n        filterGroups: [],\n        filters: [],\n      });\n\n      expect(result).toBe(true);\n    });\n\n    it('should return true when inputs are undefined', () => {\n      const result = evaluateFilterConditions({});\n\n      expect(result).toBe(true);\n    });\n  });\n\n  describe('single filter operands', () => {\n    describe('Relation/UUID filter operands', () => {\n      it('should return true when values are equal (RELATION)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          'John',\n          'John',\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when values are not equal (RELATION)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          'John',\n          'Jane',\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return false when values are equal (IsNot RELATION)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          'John',\n          'John',\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return true when values are not equal (IsNot RELATION)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          'John',\n          'Jane',\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      // Enhanced relation filter tests with object id extraction\n      it('should extract id from left operand object for relation comparison', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const leftObject = { id: uuid1, name: 'John Doe' };\n        const rightValue = uuid1;\n\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          leftObject,\n          rightValue,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should extract id from right operand object for relation comparison', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const leftValue = uuid1;\n        const rightObject = { id: uuid1, name: 'John Doe' };\n\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          leftValue,\n          rightObject,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should extract id from both operands when they are objects for relation comparison', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const leftObject = { id: uuid1, name: 'John Doe' };\n        const rightObject = { id: uuid1, title: 'Admin' };\n\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          leftObject,\n          rightObject,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when extracted ids do not match for relation comparison', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const uuid2 = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n        const leftObject = { id: uuid1, name: 'John Doe' };\n        const rightObject = { id: uuid2, name: 'Jane Smith' };\n\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          leftObject,\n          rightObject,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should handle IsNot with object id extraction for relation comparison', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const uuid2 = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n        const leftObject = { id: uuid1, name: 'John Doe' };\n        const rightObject = { id: uuid2, name: 'Jane Smith' };\n\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          leftObject,\n          rightObject,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should handle objects without id property for relation comparison', () => {\n        const leftObject = { name: 'John Doe' };\n        const rightObject = { name: 'John Doe' };\n\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          leftObject,\n          rightObject,\n          'RELATION',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false); // Objects are different references\n      });\n\n      it('should throw error for unsupported relation filter operand', () => {\n        const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n        const uuid2 = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n        const filter = createFilter(\n          ViewFilterOperand.CONTAINS,\n          uuid1,\n          uuid2,\n          'RELATION',\n        );\n\n        expect(() => evaluateFilterConditions({ filters: [filter] })).toThrow(\n          'Operand CONTAINS not supported for relation filter',\n        );\n      });\n    });\n\n    describe('UUID filter operands', () => {\n      const uuid1 = '550e8400-e29b-41d4-a716-446655440000';\n      const uuid2 = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n\n      it('should return true when UUIDs are equal (Is)', () => {\n        const filter = createFilter(ViewFilterOperand.IS, uuid1, uuid1, 'UUID');\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when UUIDs are not equal (Is)', () => {\n        const filter = createFilter(ViewFilterOperand.IS, uuid1, uuid2, 'UUID');\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return false when UUIDs are equal (IsNot)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          uuid1,\n          uuid1,\n          'UUID',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return true when UUIDs are not equal (IsNot)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          uuid1,\n          uuid2,\n          'UUID',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should handle null/undefined UUIDs with Is operand', () => {\n        const filter1 = createFilter(ViewFilterOperand.IS, null, null, 'UUID');\n        const filter2 = createFilter(\n          ViewFilterOperand.IS,\n          undefined,\n          undefined,\n          'UUID',\n        );\n        const filter3 = createFilter(ViewFilterOperand.IS, uuid1, null, 'UUID');\n\n        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n      });\n\n      it('should handle null/undefined UUIDs with IsNot operand', () => {\n        const filter1 = createFilter(\n          ViewFilterOperand.IS_NOT,\n          null,\n          null,\n          'UUID',\n        );\n        const filter2 = createFilter(\n          ViewFilterOperand.IS_NOT,\n          undefined,\n          undefined,\n          'UUID',\n        );\n        const filter3 = createFilter(\n          ViewFilterOperand.IS_NOT,\n          uuid1,\n          null,\n          'UUID',\n        );\n\n        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(false);\n        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n      });\n\n      it('should handle empty string UUIDs', () => {\n        const filter1 = createFilter(ViewFilterOperand.IS, '', '', 'UUID');\n        const filter2 = createFilter(ViewFilterOperand.IS, uuid1, '', 'UUID');\n\n        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n      });\n\n      it('should throw error for unsupported UUID filter operand', () => {\n        const filter = createFilter(\n          ViewFilterOperand.CONTAINS,\n          uuid1,\n          uuid2,\n          'UUID',\n        );\n\n        expect(() => evaluateFilterConditions({ filters: [filter] })).toThrow(\n          'Operand CONTAINS not supported for uuid filter',\n        );\n      });\n    });\n\n    describe('Select filter operands', () => {\n      it('should return true when there are common values (SELECT)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          ['John'],\n          ['John', 'Jane'],\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when there are no common values (SELECT)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          ['John'],\n          ['Jane'],\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return true when there are no common values (IsNot)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT,\n          ['John'],\n          ['Jane'],\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return true when there are no values (IsEmpty)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_EMPTY,\n          [],\n          '',\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when there is a value (IsEmpty)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_EMPTY,\n          ['John'],\n          '',\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should return true when there are values (IsNotEmpty)', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS_NOT_EMPTY,\n          ['John'],\n          '',\n          'SELECT',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n    });\n\n    describe('Boolean filter operands', () => {\n      it('should return true when boolean values are equal', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          true,\n          true,\n          'BOOLEAN',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false when boolean values are not equal', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          true,\n          false,\n          'BOOLEAN',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(false);\n      });\n\n      it('should handle truthy/falsy conversion', () => {\n        const filter = createFilter(\n          ViewFilterOperand.IS,\n          'true',\n          true,\n          'BOOLEAN',\n        );\n        const result = evaluateFilterConditions({ filters: [filter] });\n\n        expect(result).toBe(true);\n      });\n    });\n\n    describe('numeric operands', () => {\n      it('should handle GreaterThanOrEqual operand correctly', () => {\n        const filter1 = createFilter(\n          ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n          25,\n          25,\n          'NUMBER',\n        );\n        const filter2 = createFilter(\n          ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n          30,\n          25,\n          'NUMBER',\n        );\n        const filter3 = createFilter(\n          ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n          20,\n          25,\n          'NUMBER',\n        );\n\n        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n      });\n\n      it('should handle LessThanOrEqual operand correctly', () => {\n        const filter1 = createFilter(\n          ViewFilterOperand.LESS_THAN_OR_EQUAL,\n          25,\n          25,\n          'NUMBER',\n        );\n        const filter2 = createFilter(\n          ViewFilterOperand.LESS_THAN_OR_EQUAL,\n          20,\n          25,\n          'NUMBER',\n        );\n        const filter3 = createFilter(\n          ViewFilterOperand.LESS_THAN_OR_EQUAL,\n          30,\n          25,\n          'NUMBER',\n        );\n\n        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n        expect(evaluateFilterConditions({ filters:",
            "cost": 0.17696
        },
        "twentyhq__twenty.main/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts": {
            "output": "import {\n  isNonEmptyArray,\n  isNonEmptyString,\n  isObject,\n  isString,\n} from '@sniptt/guards';\nimport {\n  type StepFilter,\n  type StepFilterGroup,\n  ViewFilterOperand,\n  type ViewFilterOperandDeprecated,\n} from 'twenty-shared/types';\nimport {\n  convertViewFilterOperandToCoreOperand as convertViewFilterOperandDeprecated,\n  isDefined,\n} from 'twenty-shared/utils';\nimport { parseBooleanFromStringValue } from 'twenty-shared/workflow';\n\nimport { findDefaultNullEquivalentValue } from 'src/modules/workflow/workflow-executor/workflow-actions/filter/utils/find-default-null-equivalent-value.util';\nimport { parseAndEvaluateRelativeDateFilter } from 'src/modules/workflow/workflow-executor/workflow-actions/filter/utils/parse-and-evaluate-relative-date-filter.util';\n\ntype ResolvedFilterWithPotentiallyDeprecatedOperand = Omit<\n  StepFilter,\n  'value' | 'stepOutputKey' | 'operand'\n> & {\n  rightOperand: unknown;\n  leftOperand: unknown;\n  operand: ViewFilterOperand | ViewFilterOperandDeprecated;\n};\n\ntype ResolvedFilter = Omit<\n  StepFilter,\n  'value' | 'stepOutputKey' | 'operand'\n> & {\n  rightOperand: unknown;\n  leftOperand: unknown;\n  operand: ViewFilterOperand;\n};\n\nfunction evaluateFilter(\n  filter: ResolvedFilterWithPotentiallyDeprecatedOperand,\n): boolean {\n  const filterWithConvertedOperand = {\n    ...filter,\n    operand: convertViewFilterOperandDeprecated(filter.operand),\n  };\n\n  switch (filter.type) {\n    case 'NUMBER':\n    case 'NUMERIC':\n    case 'number':\n      return evaluateNumberFilter(filterWithConvertedOperand);\n    case 'DATE':\n    case 'DATE_TIME':\n      return evaluateDateFilter(filterWithConvertedOperand);\n    case 'TEXT':\n    case 'MULTI_SELECT':\n    case 'FULL_NAME':\n    case 'EMAILS':\n    case 'PHONES':\n    case 'ADDRESS':\n    case 'LINKS':\n    case 'ARRAY':\n    case 'array':\n    case 'RAW_JSON':\n      return evaluateTextAndArrayFilter(\n        filterWithConvertedOperand,\n        filter.type,\n        filter.compositeFieldSubFieldName,\n      );\n    case 'SELECT':\n      return evaluateSelectFilter(filterWithConvertedOperand);\n    case 'BOOLEAN':\n    case 'boolean':\n      return evaluateBooleanFilter(filterWithConvertedOperand);\n    case 'UUID':\n      return evaluateUuidFilter(filterWithConvertedOperand);\n    case 'RELATION':\n      return evaluateRelationFilter(filterWithConvertedOperand);\n    case 'CURRENCY':\n      return evaluateCurrencyFilter(filterWithConvertedOperand);\n    default:\n      return evaluateDefaultFilter(filterWithConvertedOperand);\n  }\n}\n\nfunction evaluateFilterGroup(\n  groupId: string,\n  filterGroups: StepFilterGroup[],\n  filters: ResolvedFilter[],\n): boolean {\n  const group = filterGroups.find((g) => g.id === groupId);\n\n  if (!group) {\n    throw new Error(`Filter group with id ${groupId} not found`);\n  }\n\n  const childGroups = filterGroups\n    .filter((g) => g.parentStepFilterGroupId === groupId)\n    .sort(\n      (a, b) =>\n        (a.positionInStepFilterGroup || 0) - (b.positionInStepFilterGroup || 0),\n    );\n\n  const groupFilters = filters.filter((f) => f.stepFilterGroupId === groupId);\n\n  const filterResults = groupFilters.map((filter) => evaluateFilter(filter));\n\n  const childGroupResults = childGroups.map((childGroup) =>\n    evaluateFilterGroup(childGroup.id, filterGroups, filters),\n  );\n\n  const allResults = [...filterResults, ...childGroupResults];\n\n  if (allResults.length === 0) {\n    return true;\n  }\n\n  switch (group.logicalOperator) {\n    case 'AND':\n      return allResults.every((result) => result);\n\n    case 'OR':\n      return allResults.some((result) => result);\n\n    default:\n      throw new Error(`Unknown logical operator: ${group.logicalOperator}`);\n  }\n}\n\nfunction contains(leftValue: unknown, rightValue: unknown): boolean {\n  // if two arrays, check if any item is in the other array\n  if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n    return leftValue.some((item) => rightValue.includes(item));\n  }\n\n  if (\n    (Array.isArray(leftValue) || isString(leftValue)) &&\n    isString(rightValue)\n  ) {\n    try {\n      const parsedRightValue = JSON.parse(rightValue as string);\n\n      if (Array.isArray(parsedRightValue)) {\n        return parsedRightValue.some((item) => leftValue.includes(item));\n      } else {\n        return leftValue.includes(parsedRightValue);\n      }\n    } catch {\n      return leftValue.includes(rightValue);\n    }\n  }\n\n  return String(leftValue).includes(String(rightValue));\n}\n\nfunction evaluateTextAndArrayFilter(\n  filter: ResolvedFilter,\n  filterType: string,\n  compositeFieldSubFieldName: string | undefined,\n): boolean {\n  //TODO : nullEquivalentRightValue to remove once feature flag removed + workflow action based on common api\n  const nullEquivalentRightValue = findDefaultNullEquivalentValue({\n    value: filter.rightOperand,\n    fieldMetadataType: filterType,\n    key: compositeFieldSubFieldName,\n  });\n\n  switch (filter.operand) {\n    case ViewFilterOperand.CONTAINS:\n      return (\n        contains(filter.leftOperand, filter.rightOperand) ||\n        (isDefined(nullEquivalentRightValue) &&\n          !isNotEmptyTextOrArray(filter.leftOperand))\n      );\n    case ViewFilterOperand.DOES_NOT_CONTAIN:\n      return (\n        !contains(filter.leftOperand, filter.rightOperand) ||\n        (isDefined(nullEquivalentRightValue) &&\n          isNotEmptyTextOrArray(filter.leftOperand))\n      );\n    case ViewFilterOperand.IS_EMPTY:\n      return !isNotEmptyTextOrArray(filter.leftOperand);\n\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return isNotEmptyTextOrArray(filter.leftOperand);\n\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for this filter type`,\n      );\n  }\n}\n\nfunction isNotEmptyTextOrArray(value: unknown): boolean {\n  return isNonEmptyString(value) || isNonEmptyArray(value);\n}\n\nfunction evaluateBooleanFilter(filter: ResolvedFilter): boolean {\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return (\n        parseBooleanFromStringValue(filter.leftOperand) ===\n        parseBooleanFromStringValue(filter.rightOperand)\n      );\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for boolean filter`,\n      );\n  }\n}\n\nfunction evaluateDateFilter(filter: ResolvedFilter): boolean {\n  const dateLeftValue = new Date(String(filter.leftOperand));\n\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return (\n        dateLeftValue.getDate() ===\n        new Date(String(filter.rightOperand)).getDate()\n      );\n    case ViewFilterOperand.IS_IN_PAST:\n      return dateLeftValue.getTime() < Date.now();\n\n    case ViewFilterOperand.IS_IN_FUTURE:\n      return dateLeftValue.getTime() > Date.now();\n\n    case ViewFilterOperand.IS_TODAY:\n      return dateLeftValue.toDateString() === new Date().toDateString();\n\n    case ViewFilterOperand.IS_BEFORE:\n      return (\n        dateLeftValue.getTime() <\n        new Date(String(filter.rightOperand)).getTime()\n      );\n\n    case ViewFilterOperand.IS_AFTER:\n      return (\n        dateLeftValue.getTime() >\n        new Date(String(filter.rightOperand)).getTime()\n      );\n\n    case ViewFilterOperand.IS_EMPTY:\n      return (\n        filter.leftOperand === null ||\n        filter.leftOperand === undefined ||\n        filter.leftOperand === ''\n      );\n\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return (\n        filter.leftOperand !== null &&\n        filter.leftOperand !== undefined &&\n        filter.leftOperand !== ''\n      );\n\n    case ViewFilterOperand.IS_RELATIVE:\n      return parseAndEvaluateRelativeDateFilter({\n        dateToCheck: dateLeftValue,\n        relativeDateString: String(filter.rightOperand),\n      });\n\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for date filter`,\n      );\n  }\n}\n\nfunction evaluateUuidFilter(filter: ResolvedFilter): boolean {\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return filter.leftOperand === filter.rightOperand;\n    case ViewFilterOperand.IS_NOT:\n      return filter.leftOperand !== filter.rightOperand;\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for uuid filter`,\n      );\n  }\n}\n\nfunction evaluateRelationFilter(filter: ResolvedFilter): boolean {\n  // compare only the ids. If the left operand is the relation object, get the id\n  const leftValue =\n    isObject(filter.leftOperand) && 'id' in filter.leftOperand\n      ? filter.leftOperand.id\n      : filter.leftOperand;\n\n  const rightValue =\n    isObject(filter.rightOperand) && 'id' in filter.rightOperand\n      ? filter.rightOperand.id\n      : filter.rightOperand;\n\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return leftValue === rightValue;\n    case ViewFilterOperand.IS_NOT:\n      return leftValue !== rightValue;\n    case ViewFilterOperand.IS_EMPTY:\n      return !isNonEmptyString(leftValue);\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return isNonEmptyString(leftValue);\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for relation filter`,\n      );\n  }\n}\n\nfunction evaluateCurrencyFilter(filter: ResolvedFilter): boolean {\n  if (filter.compositeFieldSubFieldName === 'currencyCode') {\n    switch (filter.operand) {\n      case ViewFilterOperand.IS:\n        return filter.leftOperand === filter.rightOperand;\n      case ViewFilterOperand.IS_NOT:\n        return filter.leftOperand !== filter.rightOperand;\n      case ViewFilterOperand.IS_EMPTY:\n        return !isNonEmptyString(filter.leftOperand);\n      case ViewFilterOperand.IS_NOT_EMPTY:\n        return isNonEmptyString(filter.leftOperand);\n      default:\n        throw new Error(\n          `Operand ${filter.operand} not supported for currency filter`,\n        );\n    }\n  } else {\n    return evaluateNumberFilter(filter);\n  }\n}\n\nfunction evaluateNumberFilter(filter: ResolvedFilter): boolean {\n  const leftValue = filter.leftOperand;\n  const rightValue = filter.rightOperand;\n\n  switch (filter.operand) {\n    case ViewFilterOperand.GREATER_THAN_OR_EQUAL:\n      return Number(leftValue) >= Number(rightValue);\n\n    case ViewFilterOperand.LESS_THAN_OR_EQUAL:\n      return Number(leftValue) <= Number(rightValue);\n\n    case ViewFilterOperand.IS_EMPTY:\n      return !isNonEmptyString(leftValue);\n\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return isNonEmptyString(leftValue);\n\n    case ViewFilterOperand.IS:\n      return Number(leftValue) === Number(rightValue);\n\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for number filter`,\n      );\n  }\n}\n\nfunction evaluateDefaultFilter(filter: ResolvedFilter): boolean {\n  const leftValue = filter.leftOperand;\n  const rightValue = filter.rightOperand;\n\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return leftValue == rightValue;\n    case ViewFilterOperand.IS_NOT:\n      return leftValue != rightValue;\n    case ViewFilterOperand.IS_EMPTY:\n      return !isNotEmptyTextOrArray(leftValue);\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return isNotEmptyTextOrArray(leftValue);\n    case ViewFilterOperand.CONTAINS:\n      return contains(leftValue, rightValue);\n    case ViewFilterOperand.DOES_NOT_CONTAIN:\n      return !contains(leftValue, rightValue);\n    case ViewFilterOperand.GREATER_THAN_OR_EQUAL:\n      return Number(leftValue) >= Number(rightValue);\n    case ViewFilterOperand.LESS_THAN_OR_EQUAL:\n      return Number(leftValue) <= Number(rightValue);\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for ${filter.type} filter type`,\n      );\n  }\n}\n\nfunction evaluateSelectFilter(filter: ResolvedFilter): boolean {\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return contains(filter.leftOperand, filter.rightOperand);\n    case ViewFilterOperand.IS_NOT:\n      return !contains(filter.leftOperand, filter.rightOperand);\n    case ViewFilterOperand.IS_EMPTY:\n      return !isNotEmptyTextOrArray(filter.leftOperand);\n\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return isNotEmptyTextOrArray(filter.leftOperand);\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for select filter`,\n      );\n  }\n}\n\nexport function evaluateFilterConditions({\n  filterGroups = [],\n  filters = [],\n}: {\n  filterGroups?: StepFilterGroup[];\n  filters?: ResolvedFilter[];\n}): boolean {\n  if (filterGroups.length === 0 && filters.length === 0) {\n    return true;\n  }\n\n  if (filterGroups.length > 0) {\n    const groupIds = new Set(filterGroups.map((g) => g.id));\n\n    for (const filter of filters) {\n      if (!groupIds.has(filter.stepFilterGroupId)) {\n        throw new Error(\n          `Filter group with id ${filter.stepFilterGroupId} not found`,\n        );\n      }\n    }\n  }\n\n  const rootGroups = filterGroups.filter((g) => !g.parentStepFilterGroupId);\n\n  if (rootGroups.length === 0 && filters.length > 0) {\n    const filterResults = filters.map((filter) => evaluateFilter(filter));\n\n    return filterResults.every((result) => result);\n  }\n\n  const rootResults = rootGroups.map((rootGroup) =>\n    evaluateFilterGroup(rootGroup.id, filterGroups, filters),\n  );\n\n  return rootResults.every((result) => result);\n}",
            "output_extracted": "import {\n  isNonEmptyArray,\n  isNonEmptyString,\n  isObject,\n  isString,\n} from '@sniptt/guards';\nimport {\n  type StepFilter,\n  type StepFilterGroup,\n  ViewFilterOperand,\n  type ViewFilterOperandDeprecated,\n} from 'twenty-shared/types';\nimport {\n  convertViewFilterOperandToCoreOperand as convertViewFilterOperandDeprecated,\n  isDefined,\n} from 'twenty-shared/utils';\nimport { parseBooleanFromStringValue } from 'twenty-shared/workflow';\n\nimport { findDefaultNullEquivalentValue } from 'src/modules/workflow/workflow-executor/workflow-actions/filter/utils/find-default-null-equivalent-value.util';\nimport { parseAndEvaluateRelativeDateFilter } from 'src/modules/workflow/workflow-executor/workflow-actions/filter/utils/parse-and-evaluate-relative-date-filter.util';\n\ntype ResolvedFilterWithPotentiallyDeprecatedOperand = Omit<\n  StepFilter,\n  'value' | 'stepOutputKey' | 'operand'\n> & {\n  rightOperand: unknown;\n  leftOperand: unknown;\n  operand: ViewFilterOperand | ViewFilterOperandDeprecated;\n};\n\ntype ResolvedFilter = Omit<\n  StepFilter,\n  'value' | 'stepOutputKey' | 'operand'\n> & {\n  rightOperand: unknown;\n  leftOperand: unknown;\n  operand: ViewFilterOperand;\n};\n\nfunction evaluateFilter(\n  filter: ResolvedFilterWithPotentiallyDeprecatedOperand,\n): boolean {\n  const filterWithConvertedOperand = {\n    ...filter,\n    operand: convertViewFilterOperandDeprecated(filter.operand),\n  };\n\n  switch (filter.type) {\n    case 'NUMBER':\n    case 'NUMERIC':\n    case 'number':\n      return evaluateNumberFilter(filterWithConvertedOperand);\n    case 'DATE':\n    case 'DATE_TIME':\n      return evaluateDateFilter(filterWithConvertedOperand);\n    case 'TEXT':\n    case 'MULTI_SELECT':\n    case 'FULL_NAME':\n    case 'EMAILS':\n    case 'PHONES':\n    case 'ADDRESS':\n    case 'LINKS':\n    case 'ARRAY':\n    case 'array':\n    case 'RAW_JSON':\n      return evaluateTextAndArrayFilter(\n        filterWithConvertedOperand,\n        filter.type,\n        filter.compositeFieldSubFieldName,\n      );\n    case 'SELECT':\n      return evaluateSelectFilter(filterWithConvertedOperand);\n    case 'BOOLEAN':\n    case 'boolean':\n      return evaluateBooleanFilter(filterWithConvertedOperand);\n    case 'UUID':\n      return evaluateUuidFilter(filterWithConvertedOperand);\n    case 'RELATION':\n      return evaluateRelationFilter(filterWithConvertedOperand);\n    case 'CURRENCY':\n      return evaluateCurrencyFilter(filterWithConvertedOperand);\n    default:\n      return evaluateDefaultFilter(filterWithConvertedOperand);\n  }\n}\n\nfunction evaluateFilterGroup(\n  groupId: string,\n  filterGroups: StepFilterGroup[],\n  filters: ResolvedFilter[],\n): boolean {\n  const group = filterGroups.find((g) => g.id === groupId);\n\n  if (!group) {\n    throw new Error(`Filter group with id ${groupId} not found`);\n  }\n\n  const childGroups = filterGroups\n    .filter((g) => g.parentStepFilterGroupId === groupId)\n    .sort(\n      (a, b) =>\n        (a.positionInStepFilterGroup || 0) - (b.positionInStepFilterGroup || 0),\n    );\n\n  const groupFilters = filters.filter((f) => f.stepFilterGroupId === groupId);\n\n  const filterResults = groupFilters.map((filter) => evaluateFilter(filter));\n\n  const childGroupResults = childGroups.map((childGroup) =>\n    evaluateFilterGroup(childGroup.id, filterGroups, filters),\n  );\n\n  const allResults = [...filterResults, ...childGroupResults];\n\n  if (allResults.length === 0) {\n    return true;\n  }\n\n  switch (group.logicalOperator) {\n    case 'AND':\n      return allResults.every((result) => result);\n\n    case 'OR':\n      return allResults.some((result) => result);\n\n    default:\n      throw new Error(`Unknown logical operator: ${group.logicalOperator}`);\n  }\n}\n\nfunction contains(leftValue: unknown, rightValue: unknown): boolean {\n  // if two arrays, check if any item is in the other array\n  if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n    return leftValue.some((item) => rightValue.includes(item));\n  }\n\n  if (\n    (Array.isArray(leftValue) || isString(leftValue)) &&\n    isString(rightValue)\n  ) {\n    try {\n      const parsedRightValue = JSON.parse(rightValue as string);\n\n      if (Array.isArray(parsedRightValue)) {\n        return parsedRightValue.some((item) => leftValue.includes(item));\n      } else {\n        return leftValue.includes(parsedRightValue);\n      }\n    } catch {\n      return leftValue.includes(rightValue);\n    }\n  }\n\n  return String(leftValue).includes(String(rightValue));\n}\n\nfunction evaluateTextAndArrayFilter(\n  filter: ResolvedFilter,\n  filterType: string,\n  compositeFieldSubFieldName: string | undefined,\n): boolean {\n  //TODO : nullEquivalentRightValue to remove once feature flag removed + workflow action based on common api\n  const nullEquivalentRightValue = findDefaultNullEquivalentValue({\n    value: filter.rightOperand,\n    fieldMetadataType: filterType,\n    key: compositeFieldSubFieldName,\n  });\n\n  switch (filter.operand) {\n    case ViewFilterOperand.CONTAINS:\n      return (\n        contains(filter.leftOperand, filter.rightOperand) ||\n        (isDefined(nullEquivalentRightValue) &&\n          !isNotEmptyTextOrArray(filter.leftOperand))\n      );\n    case ViewFilterOperand.DOES_NOT_CONTAIN:\n      return (\n        !contains(filter.leftOperand, filter.rightOperand) ||\n        (isDefined(nullEquivalentRightValue) &&\n          isNotEmptyTextOrArray(filter.leftOperand))\n      );\n    case ViewFilterOperand.IS_EMPTY:\n      return !isNotEmptyTextOrArray(filter.leftOperand);\n\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return isNotEmptyTextOrArray(filter.leftOperand);\n\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for this filter type`,\n      );\n  }\n}\n\nfunction isNotEmptyTextOrArray(value: unknown): boolean {\n  return isNonEmptyString(value) || isNonEmptyArray(value);\n}\n\nfunction evaluateBooleanFilter(filter: ResolvedFilter): boolean {\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return (\n        parseBooleanFromStringValue(filter.leftOperand) ===\n        parseBooleanFromStringValue(filter.rightOperand)\n      );\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for boolean filter`,\n      );\n  }\n}\n\nfunction evaluateDateFilter(filter: ResolvedFilter): boolean {\n  const dateLeftValue = new Date(String(filter.leftOperand));\n\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return (\n        dateLeftValue.getDate() ===\n        new Date(String(filter.rightOperand)).getDate()\n      );\n    case ViewFilterOperand.IS_IN_PAST:\n      return dateLeftValue.getTime() < Date.now();\n\n    case ViewFilterOperand.IS_IN_FUTURE:\n      return dateLeftValue.getTime() > Date.now();\n\n    case ViewFilterOperand.IS_TODAY:\n      return dateLeftValue.toDateString() === new Date().toDateString();\n\n    case ViewFilterOperand.IS_BEFORE:\n      return (\n        dateLeftValue.getTime() <\n        new Date(String(filter.rightOperand)).getTime()\n      );\n\n    case ViewFilterOperand.IS_AFTER:\n      return (\n        dateLeftValue.getTime() >\n        new Date(String(filter.rightOperand)).getTime()\n      );\n\n    case ViewFilterOperand.IS_EMPTY:\n      return (\n        filter.leftOperand === null ||\n        filter.leftOperand === undefined ||\n        filter.leftOperand === ''\n      );\n\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return (\n        filter.leftOperand !== null &&\n        filter.leftOperand !== undefined &&\n        filter.leftOperand !== ''\n      );\n\n    case ViewFilterOperand.IS_RELATIVE:\n      return parseAndEvaluateRelativeDateFilter({\n        dateToCheck: dateLeftValue,\n        relativeDateString: String(filter.rightOperand),\n      });\n\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for date filter`,\n      );\n  }\n}\n\nfunction evaluateUuidFilter(filter: ResolvedFilter): boolean {\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return filter.leftOperand === filter.rightOperand;\n    case ViewFilterOperand.IS_NOT:\n      return filter.leftOperand !== filter.rightOperand;\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for uuid filter`,\n      );\n  }\n}\n\nfunction evaluateRelationFilter(filter: ResolvedFilter): boolean {\n  // compare only the ids. If the left operand is the relation object, get the id\n  const leftValue =\n    isObject(filter.leftOperand) && 'id' in filter.leftOperand\n      ? filter.leftOperand.id\n      : filter.leftOperand;\n\n  const rightValue =\n    isObject(filter.rightOperand) && 'id' in filter.rightOperand\n      ? filter.rightOperand.id\n      : filter.rightOperand;\n\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return leftValue === rightValue;\n    case ViewFilterOperand.IS_NOT:\n      return leftValue !== rightValue;\n    case ViewFilterOperand.IS_EMPTY:\n      return !isNonEmptyString(leftValue);\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return isNonEmptyString(leftValue);\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for relation filter`,\n      );\n  }\n}\n\nfunction evaluateCurrencyFilter(filter: ResolvedFilter): boolean {\n  if (filter.compositeFieldSubFieldName === 'currencyCode') {\n    switch (filter.operand) {\n      case ViewFilterOperand.IS:\n        return filter.leftOperand === filter.rightOperand;\n      case ViewFilterOperand.IS_NOT:\n        return filter.leftOperand !== filter.rightOperand;\n      case ViewFilterOperand.IS_EMPTY:\n        return !isNonEmptyString(filter.leftOperand);\n      case ViewFilterOperand.IS_NOT_EMPTY:\n        return isNonEmptyString(filter.leftOperand);\n      default:\n        throw new Error(\n          `Operand ${filter.operand} not supported for currency filter`,\n        );\n    }\n  } else {\n    return evaluateNumberFilter(filter);\n  }\n}\n\nfunction evaluateNumberFilter(filter: ResolvedFilter): boolean {\n  const leftValue = filter.leftOperand;\n  const rightValue = filter.rightOperand;\n\n  switch (filter.operand) {\n    case ViewFilterOperand.GREATER_THAN_OR_EQUAL:\n      return Number(leftValue) >= Number(rightValue);\n\n    case ViewFilterOperand.LESS_THAN_OR_EQUAL:\n      return Number(leftValue) <= Number(rightValue);\n\n    case ViewFilterOperand.IS_EMPTY:\n      return !isNonEmptyString(leftValue);\n\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return isNonEmptyString(leftValue);\n\n    case ViewFilterOperand.IS:\n      return Number(leftValue) === Number(rightValue);\n\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for number filter`,\n      );\n  }\n}\n\nfunction evaluateDefaultFilter(filter: ResolvedFilter): boolean {\n  const leftValue = filter.leftOperand;\n  const rightValue = filter.rightOperand;\n\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return leftValue == rightValue;\n    case ViewFilterOperand.IS_NOT:\n      return leftValue != rightValue;\n    case ViewFilterOperand.IS_EMPTY:\n      return !isNotEmptyTextOrArray(leftValue);\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return isNotEmptyTextOrArray(leftValue);\n    case ViewFilterOperand.CONTAINS:\n      return contains(leftValue, rightValue);\n    case ViewFilterOperand.DOES_NOT_CONTAIN:\n      return !contains(leftValue, rightValue);\n    case ViewFilterOperand.GREATER_THAN_OR_EQUAL:\n      return Number(leftValue) >= Number(rightValue);\n    case ViewFilterOperand.LESS_THAN_OR_EQUAL:\n      return Number(leftValue) <= Number(rightValue);\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for ${filter.type} filter type`,\n      );\n  }\n}\n\nfunction evaluateSelectFilter(filter: ResolvedFilter): boolean {\n  switch (filter.operand) {\n    case ViewFilterOperand.IS:\n      return contains(filter.leftOperand, filter.rightOperand);\n    case ViewFilterOperand.IS_NOT:\n      return !contains(filter.leftOperand, filter.rightOperand);\n    case ViewFilterOperand.IS_EMPTY:\n      return !isNotEmptyTextOrArray(filter.leftOperand);\n\n    case ViewFilterOperand.IS_NOT_EMPTY:\n      return isNotEmptyTextOrArray(filter.leftOperand);\n    default:\n      throw new Error(\n        `Operand ${filter.operand} not supported for select filter`,\n      );\n  }\n}\n\nexport function evaluateFilterConditions({\n  filterGroups = [],\n  filters = [],\n}: {\n  filterGroups?: StepFilterGroup[];\n  filters?: ResolvedFilter[];\n}): boolean {\n  if (filterGroups.length === 0 && filters.length === 0) {\n    return true;\n  }\n\n  if (filterGroups.length > 0) {\n    const groupIds = new Set(filterGroups.map((g) => g.id));\n\n    for (const filter of filters) {\n      if (!groupIds.has(filter.stepFilterGroupId)) {\n        throw new Error(\n          `Filter group with id ${filter.stepFilterGroupId} not found`,\n        );\n      }\n    }\n  }\n\n  const rootGroups = filterGroups.filter((g) => !g.parentStepFilterGroupId);\n\n  if (rootGroups.length === 0 && filters.length > 0) {\n    const filterResults = filters.map((filter) => evaluateFilter(filter));\n\n    return filterResults.every((result) => result);\n  }\n\n  const rootResults = rootGroups.map((rootGroup) =>\n    evaluateFilterGroup(rootGroup.id, filterGroups, filters),\n  );\n\n  return rootResults.every((result) => result);\n}",
            "cost": 0.12628
        },
        "twentyhq__twenty.main/packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts": {
            "output": "import { isNonEmptyString } from '@sniptt/guards';\n\nimport {\n  FieldMetadataType,\n  ViewFilterOperand as RecordFilterOperand,\n  type ActorFilter,\n  type AddressFilter,\n  type ArrayFilter,\n  type BooleanFilter,\n  type CurrencyFilter,\n  type DateFilter,\n  type FloatFilter,\n  type MultiSelectFilter,\n  type PhonesFilter,\n  type RatingFilter,\n  type RawJsonFilter,\n  type RecordFilterValueDependencies,\n  type RecordGqlOperationFilter,\n  type RelationFilter,\n  type SelectFilter,\n  type StringFilter,\n  type TSVectorFilter,\n  type UUIDFilter,\n} from '@/types';\n\nimport {\n  computeGqlOperationFilterForEmails,\n  computeGqlOperationFilterForLinks,\n  convertGreaterThanOrEqualRatingToArrayOfRatingValues,\n  convertLessThanOrEqualRatingToArrayOfRatingValues,\n  convertRatingToRatingValue,\n  generateILikeFiltersForCompositeFields,\n  getEmptyRecordGqlOperationFilter,\n  isExpectedSubFieldName,\n} from '@/utils/filter';\n\nimport {\n  endOfDay,\n  endOfMinute,\n  roundToNearestMinutes,\n  startOfDay,\n  startOfMinute,\n} from 'date-fns';\nimport { z } from 'zod';\n\nimport { type DateTimeFilter } from '@/types/RecordGqlOperationFilter';\nimport {\n  checkIfShouldComputeEmptinessFilter,\n  checkIfShouldSkipFiltering,\n  CustomError,\n  getFilterTypeFromFieldType,\n  getPlainDateFromDate,\n  isDefined,\n  resolveDateFilter,\n  resolveDateTimeFilter,\n  type RecordFilter,\n} from '@/utils';\nimport { arrayOfStringsOrVariablesSchema } from '@/utils/filter/utils/validation-schemas/arrayOfStringsOrVariablesSchema';\nimport { arrayOfUuidOrVariableSchema } from '@/utils/filter/utils/validation-schemas/arrayOfUuidsOrVariablesSchema';\nimport { jsonRelationFilterValueSchema } from '@/utils/filter/utils/validation-schemas/jsonRelationFilterValueSchema';\n\ntype FieldShared = {\n  id: string;\n  name: string;\n  type: FieldMetadataType;\n  label: string;\n};\n\ntype TurnRecordFilterIntoRecordGqlOperationFilterParams = {\n  filterValueDependencies?: RecordFilterValueDependencies;\n  recordFilter: RecordFilter;\n  fieldMetadataItems: FieldShared[];\n};\n\nexport const turnRecordFilterIntoRecordGqlOperationFilter = ({\n  recordFilter,\n  fieldMetadataItems,\n  filterValueDependencies,\n}: TurnRecordFilterIntoRecordGqlOperationFilterParams):\n  | RecordGqlOperationFilter\n  | undefined => {\n  const correspondingFieldMetadataItem = fieldMetadataItems.find(\n    (field) => field.id === recordFilter.fieldMetadataId,\n  );\n\n  if (!isDefined(correspondingFieldMetadataItem)) {\n    return;\n  }\n\n  const shouldSkipFiltering = checkIfShouldSkipFiltering({ recordFilter });\n\n  if (shouldSkipFiltering) {\n    return;\n  }\n\n  const shouldComputeEmptinessFilter = checkIfShouldComputeEmptinessFilter({\n    recordFilterOperand: recordFilter.operand,\n    correspondingFieldMetadataItem,\n  });\n\n  if (shouldComputeEmptinessFilter) {\n    const emptinessFilter = getEmptyRecordGqlOperationFilter({\n      operand: recordFilter.operand,\n      correspondingField: correspondingFieldMetadataItem,\n      recordFilter: recordFilter,\n    });\n\n    return emptinessFilter;\n  }\n\n  const subFieldName = recordFilter.subFieldName;\n\n  const isSubFieldFilter = isNonEmptyString(subFieldName);\n\n  const filterType = getFilterTypeFromFieldType(\n    correspondingFieldMetadataItem.type,\n  );\n\n  switch (filterType) {\n    case 'TEXT':\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.CONTAINS:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              ilike: `%${recordFilter.value}%`,\n            } as StringFilter,\n          };\n        case RecordFilterOperand.DOES_NOT_CONTAIN:\n          return {\n            not: {\n              [correspondingFieldMetadataItem.name]: {\n                ilike: `%${recordFilter.value}%`,\n              } as StringFilter,\n            },\n          };\n        default:\n          throw new CustomError(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n            'UNKNOWN_OPERAND_FOR_FILTER',\n          );\n      }\n    case 'TS_VECTOR':\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.VECTOR_SEARCH:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              search: recordFilter.value,\n            } as TSVectorFilter,\n          };\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    case 'RAW_JSON':\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.CONTAINS:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              like: `%${recordFilter.value}%`,\n            } as RawJsonFilter,\n          };\n        case RecordFilterOperand.DOES_NOT_CONTAIN:\n          return {\n            not: {\n              [correspondingFieldMetadataItem.name]: {\n                like: `%${recordFilter.value}%`,\n              } as RawJsonFilter,\n            },\n          };\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    case 'DATE': {\n      const resolvedFilterValue = resolveDateFilter(recordFilter);\n\n      const now = new Date();\n\n      const plainDateFilter =\n        typeof resolvedFilterValue === 'string' ? resolvedFilterValue : null;\n\n      const nowAsPlainDate = getPlainDateFromDate(now);\n\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.IS_AFTER: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              gt: plainDateFilter,\n            } as DateFilter,\n          };\n        }\n        case RecordFilterOperand.IS_BEFORE: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              lt: plainDateFilter,\n            } as DateFilter,\n          };\n        }\n        case RecordFilterOperand.IS_RELATIVE: {\n          const dateRange = z\n            .object({ start: z.string(), end: z.string() })\n            .safeParse(resolvedFilterValue).data;\n\n          const defaultDateRange = resolveDateFilter({\n            value: 'PAST_1_DAY',\n            operand: RecordFilterOperand.IS_RELATIVE,\n          });\n\n          if (!defaultDateRange) {\n            throw new Error('Failed to resolve default date range');\n          }\n\n          const { start: startPlainDate, end: endPlainDate } =\n            dateRange ?? defaultDateRange;\n\n          return {\n            and: [\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  gte: startPlainDate,\n                } as DateFilter,\n              },\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  lte: endPlainDate,\n                } as DateFilter,\n              },\n            ],\n          };\n        }\n        case RecordFilterOperand.IS: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              eq: plainDateFilter,\n            } as DateFilter,\n          };\n        }\n        case RecordFilterOperand.IS_IN_PAST:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              lte: nowAsPlainDate,\n            } as DateFilter,\n          };\n        case RecordFilterOperand.IS_IN_FUTURE:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              gte: nowAsPlainDate,\n            } as DateFilter,\n          };\n        case RecordFilterOperand.IS_TODAY: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              eq: nowAsPlainDate,\n            } as DateFilter,\n          };\n        }\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    }\n    case 'DATE_TIME': {\n      const resolvedFilterValue = resolveDateTimeFilter(recordFilter);\n      const now = roundToNearestMinutes(new Date());\n      const date =\n        resolvedFilterValue instanceof Date ? resolvedFilterValue : now;\n\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.IS_AFTER: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              gt: date.toISOString(),\n            } as DateTimeFilter,\n          };\n        }\n        case RecordFilterOperand.IS_BEFORE: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              lt: date.toISOString(),\n            } as DateTimeFilter,\n          };\n        }\n        case RecordFilterOperand.IS_RELATIVE: {\n          const dateRange = z\n            .object({ start: z.date(), end: z.date() })\n            .safeParse(resolvedFilterValue).data;\n\n          const defaultDateRange = resolveDateTimeFilter({\n            value: 'PAST_1_DAY',\n            operand: RecordFilterOperand.IS_RELATIVE,\n          });\n\n          if (!defaultDateRange) {\n            throw new Error('Failed to resolve default date range');\n          }\n\n          const { start, end } = dateRange ?? defaultDateRange;\n\n          return {\n            and: [\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  gte: start.toISOString(),\n                } as DateTimeFilter,\n              },\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  lte: end.toISOString(),\n                } as DateTimeFilter,\n              },\n            ],\n          };\n        }\n        case RecordFilterOperand.IS: {\n          const isValid = resolvedFilterValue instanceof Date;\n          const date = isValid ? resolvedFilterValue : now;\n\n          return {\n            and: [\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  lte: endOfMinute(date).toISOString(),\n                } as DateTimeFilter,\n              },\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  gte: startOfMinute(date).toISOString(),\n                } as DateTimeFilter,\n              },\n            ],\n          };\n        }\n        case RecordFilterOperand.IS_IN_PAST:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              lte: now.toISOString(),\n            } as DateTimeFilter,\n          };\n        case RecordFilterOperand.IS_IN_FUTURE:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              gte: now.toISOString(),\n            } as DateTimeFilter,\n          };\n        case RecordFilterOperand.IS_TODAY: {\n          return {\n            and: [\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  lte: endOfDay(now).toISOString(),\n                } as DateTimeFilter,\n              },\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  gte: startOfDay(now).toISOString(),\n                } as DateTimeFilter,\n              },\n            ],\n          };\n        }\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    }\n    case 'RATING':\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.IS:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              eq: convertRatingToRatingValue(parseFloat(recordFilter.value)),\n            } as RatingFilter,\n          };\n        case RecordFilterOperand.GREATER_THAN_OR_EQUAL:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              in: convertGreaterThanOrEqualRatingToArrayOfRatingValues(\n                parseFloat(recordFilter.value),\n              ),\n            } as RatingFilter,\n          };\n        case RecordFilterOperand.LESS_THAN_OR_EQUAL:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              in: convertLessThanOrEqualRatingToArrayOfRatingValues(\n                parseFloat(recordFilter.value),\n              ),\n            } as RatingFilter,\n          };\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    case 'NUMBER':\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.GREATER_THAN_OR_EQUAL:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              gte: parseFloat(recordFilter.value),\n            } as FloatFilter,\n          };\n        case RecordFilterOperand.LESS_THAN_OR_EQUAL:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              lte: parseFloat(recordFilter.value),\n            } as FloatFilter,\n          };\n        case RecordFilterOperand.IS:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              eq: parseFloat(recordFilter.value),\n            } as FloatFilter,\n          };\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    case 'RELATION': {\n      const { isCurrentWorkspaceMemberSelected, selectedRecordIds } =\n        jsonRelationFilterValueSchema\n          .catch({\n            isCurrentWorkspaceMemberSelected: false,\n            selectedRecordIds: arrayOfUuidOrVariableSchema.parse(\n              recordFilter.value,\n            ),\n          })\n          .parse(recordFilter.value);\n\n      const recordIds = isCurrentWorkspaceMemberSelected\n        ? [\n            ...selectedRecordIds,\n            filterValueDependencies?.currentWorkspaceMemberId,\n          ]\n        : selectedRecordIds;\n\n      if (!isDefined(recordIds) || recordIds.length === 0) return;\n\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.IS:\n          return {\n            [correspondingFieldMetadataItem.name + 'Id']: {\n              in: recordIds,\n            } as RelationFilter,\n          };\n        case RecordFilterOperand.IS_NOT: {\n          if (!isDefined(recordIds) || recordIds.length === 0) return;\n          return {\n            or: [\n              {\n                not: {\n                  [correspondingFieldMetadataItem.name + 'Id']: {\n                    in: recordIds,\n                  } as RelationFilter,\n                },\n              },\n              {\n                [correspondingFieldMetadataItem.name + 'Id']: {\n                  is: 'NULL',\n                } as RelationFilter,\n              },\n            ],\n          };\n        }\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    }\n    case 'CURRENCY': {\n      if (\n        isExpectedSubFieldName(\n          FieldMetadataType.CURRENCY,\n          'currencyCode',\n          subFieldName,\n        )\n      ) {\n        const parsedCurrencyCodes = arrayOfStringsOrVariablesSchema.",
            "output_extracted": "import { isNonEmptyString } from '@sniptt/guards';\n\nimport {\n  FieldMetadataType,\n  ViewFilterOperand as RecordFilterOperand,\n  type ActorFilter,\n  type AddressFilter,\n  type ArrayFilter,\n  type BooleanFilter,\n  type CurrencyFilter,\n  type DateFilter,\n  type FloatFilter,\n  type MultiSelectFilter,\n  type PhonesFilter,\n  type RatingFilter,\n  type RawJsonFilter,\n  type RecordFilterValueDependencies,\n  type RecordGqlOperationFilter,\n  type RelationFilter,\n  type SelectFilter,\n  type StringFilter,\n  type TSVectorFilter,\n  type UUIDFilter,\n} from '@/types';\n\nimport {\n  computeGqlOperationFilterForEmails,\n  computeGqlOperationFilterForLinks,\n  convertGreaterThanOrEqualRatingToArrayOfRatingValues,\n  convertLessThanOrEqualRatingToArrayOfRatingValues,\n  convertRatingToRatingValue,\n  generateILikeFiltersForCompositeFields,\n  getEmptyRecordGqlOperationFilter,\n  isExpectedSubFieldName,\n} from '@/utils/filter';\n\nimport {\n  endOfDay,\n  endOfMinute,\n  roundToNearestMinutes,\n  startOfDay,\n  startOfMinute,\n} from 'date-fns';\nimport { z } from 'zod';\n\nimport { type DateTimeFilter } from '@/types/RecordGqlOperationFilter';\nimport {\n  checkIfShouldComputeEmptinessFilter,\n  checkIfShouldSkipFiltering,\n  CustomError,\n  getFilterTypeFromFieldType,\n  getPlainDateFromDate,\n  isDefined,\n  resolveDateFilter,\n  resolveDateTimeFilter,\n  type RecordFilter,\n} from '@/utils';\nimport { arrayOfStringsOrVariablesSchema } from '@/utils/filter/utils/validation-schemas/arrayOfStringsOrVariablesSchema';\nimport { arrayOfUuidOrVariableSchema } from '@/utils/filter/utils/validation-schemas/arrayOfUuidsOrVariablesSchema';\nimport { jsonRelationFilterValueSchema } from '@/utils/filter/utils/validation-schemas/jsonRelationFilterValueSchema';\n\ntype FieldShared = {\n  id: string;\n  name: string;\n  type: FieldMetadataType;\n  label: string;\n};\n\ntype TurnRecordFilterIntoRecordGqlOperationFilterParams = {\n  filterValueDependencies?: RecordFilterValueDependencies;\n  recordFilter: RecordFilter;\n  fieldMetadataItems: FieldShared[];\n};\n\nexport const turnRecordFilterIntoRecordGqlOperationFilter = ({\n  recordFilter,\n  fieldMetadataItems,\n  filterValueDependencies,\n}: TurnRecordFilterIntoRecordGqlOperationFilterParams):\n  | RecordGqlOperationFilter\n  | undefined => {\n  const correspondingFieldMetadataItem = fieldMetadataItems.find(\n    (field) => field.id === recordFilter.fieldMetadataId,\n  );\n\n  if (!isDefined(correspondingFieldMetadataItem)) {\n    return;\n  }\n\n  const shouldSkipFiltering = checkIfShouldSkipFiltering({ recordFilter });\n\n  if (shouldSkipFiltering) {\n    return;\n  }\n\n  const shouldComputeEmptinessFilter = checkIfShouldComputeEmptinessFilter({\n    recordFilterOperand: recordFilter.operand,\n    correspondingFieldMetadataItem,\n  });\n\n  if (shouldComputeEmptinessFilter) {\n    const emptinessFilter = getEmptyRecordGqlOperationFilter({\n      operand: recordFilter.operand,\n      correspondingField: correspondingFieldMetadataItem,\n      recordFilter: recordFilter,\n    });\n\n    return emptinessFilter;\n  }\n\n  const subFieldName = recordFilter.subFieldName;\n\n  const isSubFieldFilter = isNonEmptyString(subFieldName);\n\n  const filterType = getFilterTypeFromFieldType(\n    correspondingFieldMetadataItem.type,\n  );\n\n  switch (filterType) {\n    case 'TEXT':\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.CONTAINS:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              ilike: `%${recordFilter.value}%`,\n            } as StringFilter,\n          };\n        case RecordFilterOperand.DOES_NOT_CONTAIN:\n          return {\n            not: {\n              [correspondingFieldMetadataItem.name]: {\n                ilike: `%${recordFilter.value}%`,\n              } as StringFilter,\n            },\n          };\n        default:\n          throw new CustomError(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n            'UNKNOWN_OPERAND_FOR_FILTER',\n          );\n      }\n    case 'TS_VECTOR':\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.VECTOR_SEARCH:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              search: recordFilter.value,\n            } as TSVectorFilter,\n          };\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    case 'RAW_JSON':\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.CONTAINS:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              like: `%${recordFilter.value}%`,\n            } as RawJsonFilter,\n          };\n        case RecordFilterOperand.DOES_NOT_CONTAIN:\n          return {\n            not: {\n              [correspondingFieldMetadataItem.name]: {\n                like: `%${recordFilter.value}%`,\n              } as RawJsonFilter,\n            },\n          };\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    case 'DATE': {\n      const resolvedFilterValue = resolveDateFilter(recordFilter);\n\n      const now = new Date();\n\n      const plainDateFilter =\n        typeof resolvedFilterValue === 'string' ? resolvedFilterValue : null;\n\n      const nowAsPlainDate = getPlainDateFromDate(now);\n\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.IS_AFTER: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              gt: plainDateFilter,\n            } as DateFilter,\n          };\n        }\n        case RecordFilterOperand.IS_BEFORE: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              lt: plainDateFilter,\n            } as DateFilter,\n          };\n        }\n        case RecordFilterOperand.IS_RELATIVE: {\n          const dateRange = z\n            .object({ start: z.string(), end: z.string() })\n            .safeParse(resolvedFilterValue).data;\n\n          const defaultDateRange = resolveDateFilter({\n            value: 'PAST_1_DAY',\n            operand: RecordFilterOperand.IS_RELATIVE,\n          });\n\n          if (!defaultDateRange) {\n            throw new Error('Failed to resolve default date range');\n          }\n\n          const { start: startPlainDate, end: endPlainDate } =\n            dateRange ?? defaultDateRange;\n\n          return {\n            and: [\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  gte: startPlainDate,\n                } as DateFilter,\n              },\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  lte: endPlainDate,\n                } as DateFilter,\n              },\n            ],\n          };\n        }\n        case RecordFilterOperand.IS: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              eq: plainDateFilter,\n            } as DateFilter,\n          };\n        }\n        case RecordFilterOperand.IS_IN_PAST:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              lte: nowAsPlainDate,\n            } as DateFilter,\n          };\n        case RecordFilterOperand.IS_IN_FUTURE:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              gte: nowAsPlainDate,\n            } as DateFilter,\n          };\n        case RecordFilterOperand.IS_TODAY: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              eq: nowAsPlainDate,\n            } as DateFilter,\n          };\n        }\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    }\n    case 'DATE_TIME': {\n      const resolvedFilterValue = resolveDateTimeFilter(recordFilter);\n      const now = roundToNearestMinutes(new Date());\n      const date =\n        resolvedFilterValue instanceof Date ? resolvedFilterValue : now;\n\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.IS_AFTER: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              gt: date.toISOString(),\n            } as DateTimeFilter,\n          };\n        }\n        case RecordFilterOperand.IS_BEFORE: {\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              lt: date.toISOString(),\n            } as DateTimeFilter,\n          };\n        }\n        case RecordFilterOperand.IS_RELATIVE: {\n          const dateRange = z\n            .object({ start: z.date(), end: z.date() })\n            .safeParse(resolvedFilterValue).data;\n\n          const defaultDateRange = resolveDateTimeFilter({\n            value: 'PAST_1_DAY',\n            operand: RecordFilterOperand.IS_RELATIVE,\n          });\n\n          if (!defaultDateRange) {\n            throw new Error('Failed to resolve default date range');\n          }\n\n          const { start, end } = dateRange ?? defaultDateRange;\n\n          return {\n            and: [\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  gte: start.toISOString(),\n                } as DateTimeFilter,\n              },\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  lte: end.toISOString(),\n                } as DateTimeFilter,\n              },\n            ],\n          };\n        }\n        case RecordFilterOperand.IS: {\n          const isValid = resolvedFilterValue instanceof Date;\n          const date = isValid ? resolvedFilterValue : now;\n\n          return {\n            and: [\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  lte: endOfMinute(date).toISOString(),\n                } as DateTimeFilter,\n              },\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  gte: startOfMinute(date).toISOString(),\n                } as DateTimeFilter,\n              },\n            ],\n          };\n        }\n        case RecordFilterOperand.IS_IN_PAST:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              lte: now.toISOString(),\n            } as DateTimeFilter,\n          };\n        case RecordFilterOperand.IS_IN_FUTURE:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              gte: now.toISOString(),\n            } as DateTimeFilter,\n          };\n        case RecordFilterOperand.IS_TODAY: {\n          return {\n            and: [\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  lte: endOfDay(now).toISOString(),\n                } as DateTimeFilter,\n              },\n              {\n                [correspondingFieldMetadataItem.name]: {\n                  gte: startOfDay(now).toISOString(),\n                } as DateTimeFilter,\n              },\n            ],\n          };\n        }\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    }\n    case 'RATING':\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.IS:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              eq: convertRatingToRatingValue(parseFloat(recordFilter.value)),\n            } as RatingFilter,\n          };\n        case RecordFilterOperand.GREATER_THAN_OR_EQUAL:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              in: convertGreaterThanOrEqualRatingToArrayOfRatingValues(\n                parseFloat(recordFilter.value),\n              ),\n            } as RatingFilter,\n          };\n        case RecordFilterOperand.LESS_THAN_OR_EQUAL:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              in: convertLessThanOrEqualRatingToArrayOfRatingValues(\n                parseFloat(recordFilter.value),\n              ),\n            } as RatingFilter,\n          };\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    case 'NUMBER':\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.GREATER_THAN_OR_EQUAL:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              gte: parseFloat(recordFilter.value),\n            } as FloatFilter,\n          };\n        case RecordFilterOperand.LESS_THAN_OR_EQUAL:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              lte: parseFloat(recordFilter.value),\n            } as FloatFilter,\n          };\n        case RecordFilterOperand.IS:\n          return {\n            [correspondingFieldMetadataItem.name]: {\n              eq: parseFloat(recordFilter.value),\n            } as FloatFilter,\n          };\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    case 'RELATION': {\n      const { isCurrentWorkspaceMemberSelected, selectedRecordIds } =\n        jsonRelationFilterValueSchema\n          .catch({\n            isCurrentWorkspaceMemberSelected: false,\n            selectedRecordIds: arrayOfUuidOrVariableSchema.parse(\n              recordFilter.value,\n            ),\n          })\n          .parse(recordFilter.value);\n\n      const recordIds = isCurrentWorkspaceMemberSelected\n        ? [\n            ...selectedRecordIds,\n            filterValueDependencies?.currentWorkspaceMemberId,\n          ]\n        : selectedRecordIds;\n\n      if (!isDefined(recordIds) || recordIds.length === 0) return;\n\n      switch (recordFilter.operand) {\n        case RecordFilterOperand.IS:\n          return {\n            [correspondingFieldMetadataItem.name + 'Id']: {\n              in: recordIds,\n            } as RelationFilter,\n          };\n        case RecordFilterOperand.IS_NOT: {\n          if (!isDefined(recordIds) || recordIds.length === 0) return;\n          return {\n            or: [\n              {\n                not: {\n                  [correspondingFieldMetadataItem.name + 'Id']: {\n                    in: recordIds,\n                  } as RelationFilter,\n                },\n              },\n              {\n                [correspondingFieldMetadataItem.name + 'Id']: {\n                  is: 'NULL',\n                } as RelationFilter,\n              },\n            ],\n          };\n        }\n        default:\n          throw new Error(\n            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n          );\n      }\n    }\n    case 'CURRENCY': {\n      if (\n        isExpectedSubFieldName(\n          FieldMetadataType.CURRENCY,\n          'currencyCode',\n          subFieldName,\n        )\n      ) {\n        const parsedCurrencyCodes = arrayOfStringsOrVariablesSchema.",
            "cost": 0.15981
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "twentyhq__twenty.main.16299",
        "repo": "twentyhq/twenty",
        "base_commit": "3a14fe8a76b6678c5de02ec0733eae6b0903753d",
        "head_commit": "caddb3b01ac30e69015a92fb098d96dee01b648f",
        "title": "add `is not` operand on numeric fields",
        "merged_at": "2025-12-04T13:25:24Z",
        "html_url": "https://github.com/twentyhq/twenty/pull/16299",
        "test_files": [
            "packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts",
            "packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts",
            "packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts"
        ],
        "code_files": [
            "packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts",
            "packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts",
            "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts",
            "packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts",
            "packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts"
        ],
        "total_changes": 47,
        "num_files": 8,
        "pull_number": 16299,
        "patch": "diff --git a/packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts b/packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts\nindex ced4abf738f0a..ecc0b47c9d777 100644\n--- a/packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts\n+++ b/packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts\n@@ -17,6 +17,7 @@ describe('getOperandsForFilterType', () => {\n \n   const numberOperands = [\n     RecordFilterOperand.IS,\n+    RecordFilterOperand.IS_NOT,\n     RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n     RecordFilterOperand.LESS_THAN_OR_EQUAL,\n   ];\ndiff --git a/packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts b/packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts\nindex d11443cc97c2b..791f78357f556 100644\n--- a/packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts\n+++ b/packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts\n@@ -74,6 +74,7 @@ export const FILTER_OPERANDS_MAP = {\n   ],\n   NUMBER: [\n     RecordFilterOperand.IS,\n+    RecordFilterOperand.IS_NOT,\n     RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n     RecordFilterOperand.LESS_THAN_OR_EQUAL,\n     ...emptyOperands,\ndiff --git a/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts b/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts\nindex 36d013ceca576..9a23800934905 100644\n--- a/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts\n+++ b/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts\n@@ -139,6 +139,11 @@ describe('buildValueFromFilter', () => {\n         value: '5',\n         expected: 5,\n       },\n+      {\n+        operand: ViewFilterOperand.IS_NOT,\n+        value: '5',\n+        expected: undefined,\n+      },\n       {\n         operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n         value: '5',\ndiff --git a/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts b/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts\nindex 898e3e6201182..c5ad711e0b403 100644\n--- a/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts\n+++ b/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts\n@@ -159,6 +159,8 @@ const computeValueFromFilterNumber = (\n       return Number(value);\n     case ViewFilterOperand.IS:\n       return Number(value);\n+    case ViewFilterOperand.IS_NOT:\n+      return undefined;\n     case ViewFilterOperand.IS_EMPTY:\n       return undefined;\n     default:\ndiff --git a/packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts b/packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts\nindex 74b8ceabb998f..96d95db4525b2 100644\n--- a/packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts\n+++ b/packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts\n@@ -28,6 +28,7 @@ export const FILTER_OPERANDS_MAP = {\n   ],\n   NUMBER: [\n     ViewFilterOperand.IS,\n+    ViewFilterOperand.IS_NOT,\n     ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n     ViewFilterOperand.LESS_THAN_OR_EQUAL,\n     ...emptyOperands,\n@@ -64,6 +65,7 @@ export const FILTER_OPERANDS_MAP = {\n   UUID: [ViewFilterOperand.IS, ViewFilterOperand.IS_NOT],\n   NUMERIC: [\n     ViewFilterOperand.IS,\n+    ViewFilterOperand.IS_NOT,\n     ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n     ViewFilterOperand.LESS_THAN_OR_EQUAL,\n     ...emptyOperands,\ndiff --git a/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts b/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts\nindex 01b408956e545..7fbb7efcedb63 100644\n--- a/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts\n+++ b/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts\n@@ -484,6 +484,31 @@ describe('evaluateFilterConditions', () => {\n         expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n         expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n       });\n+\n+      it('should handle IsNot operand correctly', () => {\n+        const filter1 = createFilter(\n+          ViewFilterOperand.IS_NOT,\n+          25,\n+          25,\n+          'NUMBER',\n+        );\n+        const filter2 = createFilter(\n+          ViewFilterOperand.IS_NOT,\n+          20,\n+          25,\n+          'NUMBER',\n+        );\n+        const filter3 = createFilter(\n+          ViewFilterOperand.IS_NOT,\n+          30,\n+          25,\n+          'NUMBER',\n+        );\n+\n+        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(false);\n+        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n+        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n+      });\n     });\n \n     describe('string and array operands', () => {\ndiff --git a/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts b/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts\nindex 743a659ec0b66..efebf74c3134c 100644\n--- a/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts\n+++ b/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts\n@@ -349,6 +349,9 @@ function evaluateNumberFilter(filter: ResolvedFilter): boolean {\n     case ViewFilterOperand.IS:\n       return Number(leftValue) === Number(rightValue);\n \n+    case ViewFilterOperand.IS_NOT:\n+      return Number(leftValue) !== Number(rightValue);\n+\n     default:\n       throw new Error(\n         `Operand ${filter.operand} not supported for number filter`,\ndiff --git a/packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts b/packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts\nindex b2baffea11c40..dc517c6cd6178 100644\n--- a/packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts\n+++ b/packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts\n@@ -416,6 +416,14 @@ export const turnRecordFilterIntoRecordGqlOperationFilter = ({\n               eq: parseFloat(recordFilter.value),\n             } as FloatFilter,\n           };\n+        case RecordFilterOperand.IS_NOT:\n+          return {\n+            not: {\n+              [correspondingFieldMetadataItem.name]: {\n+                eq: parseFloat(recordFilter.value),\n+              } as FloatFilter,\n+            },\n+          };\n         default:\n           throw new Error(\n             `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n",
        "pr_mirror": "twentyhq__twenty.main"
    }
}