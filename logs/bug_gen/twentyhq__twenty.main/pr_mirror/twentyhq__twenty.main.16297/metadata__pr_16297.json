{
    "cost": 0.45408000000000004,
    "rewrites": {
        "twentyhq__twenty.main/packages/twenty-front/src/pages/settings/accounts/SettingsAccountsConfiguration.tsx": {
            "output": "import { useLingui } from '@lingui/react/macro';\nimport { useState } from 'react';\nimport { useNavigate, useParams } from 'react-router-dom';\nimport { useSetRecoilState } from 'recoil';\n\nimport { type CalendarChannel } from '@/accounts/types/CalendarChannel';\nimport { type MessageChannel } from '@/accounts/types/MessageChannel';\nimport { CoreObjectNameSingular } from '@/object-metadata/types/CoreObjectNameSingular';\nimport { useGenerateDepthRecordGqlFieldsFromObject } from '@/object-record/graphql/record-gql-fields/hooks/useGenerateDepthRecordGqlFieldsFromObject';\nimport { useFindManyRecords } from '@/object-record/hooks/useFindManyRecords';\nimport { settingsAccountsSelectedMessageChannelState } from '@/settings/accounts/states/settingsAccountsSelectedMessageChannelState';\nimport { useSnackBar } from '@/ui/feedback/snack-bar-manager/hooks/useSnackBar';\nimport { SettingsPath } from 'twenty-shared/types';\nimport { getSettingsPath, isDefined } from 'twenty-shared/utils';\nimport { useStartChannelSyncMutation } from '~/generated-metadata/graphql';\nimport { SettingsAccountsConfigurationStepCalendar } from '~/pages/settings/accounts/SettingsAccountsConfigurationStepCalendar';\nimport { SettingsAccountsConfigurationStepEmail } from '~/pages/settings/accounts/SettingsAccountsConfigurationStepEmail';\n\nenum SettingsAccountsConfigurationStep {\n  Email = 'email',\n  Calendar = 'calendar',\n}\n\nexport const SettingsAccountsConfiguration = () => {\n  const { t } = useLingui();\n  const { connectedAccountId } = useParams<{\n    connectedAccountId: string;\n  }>();\n  const navigate = useNavigate();\n  const { enqueueSuccessSnackBar, enqueueErrorSnackBar } = useSnackBar();\n  const [startChannelSyncMutation, { loading: isSubmitting }] =\n    useStartChannelSyncMutation();\n  const setSelectedMessageChannel = useSetRecoilState(\n    settingsAccountsSelectedMessageChannelState,\n  );\n\n  const [currentStep, setCurrentStep] =\n    useState<SettingsAccountsConfigurationStep>(\n      SettingsAccountsConfigurationStep.Email,\n    );\n\n  const { recordGqlFields } = useGenerateDepthRecordGqlFieldsFromObject({\n    objectNameSingular: CoreObjectNameSingular.MessageChannel,\n    depth: 1,\n    shouldOnlyLoadRelationIdentifiers: false,\n  });\n\n  const { records: messageChannels } = useFindManyRecords<MessageChannel>({\n    objectNameSingular: CoreObjectNameSingular.MessageChannel,\n    filter: {\n      connectedAccountId: {\n        eq: connectedAccountId,\n      },\n    },\n    recordGqlFields,\n    onCompleted: (data) => {\n      if (isDefined(data[0])) {\n        setSelectedMessageChannel(data[0]);\n      }\n    },\n    skip: !connectedAccountId,\n  });\n\n  const { records: calendarChannels } = useFindManyRecords<CalendarChannel>({\n    objectNameSingular: CoreObjectNameSingular.CalendarChannel,\n    filter: {\n      connectedAccountId: {\n        eq: connectedAccountId,\n      },\n    },\n    skip: !connectedAccountId,\n  });\n\n  const messageChannel = messageChannels[0];\n  const calendarChannel = calendarChannels[0];\n\n  const handleNext = () => {\n    setCurrentStep(SettingsAccountsConfigurationStep.Calendar);\n  };\n\n  const handleAddAccount = async () => {\n    if (!connectedAccountId) return;\n\n    await startChannelSyncMutation({\n      variables: {\n        connectedAccountId,\n      },\n      onCompleted: () => {\n        enqueueSuccessSnackBar({\n          message: t`Account added successfully. Sync started.`,\n        });\n        navigate(getSettingsPath(SettingsPath.Accounts));\n      },\n      onError: (error) => {\n        enqueueErrorSnackBar({\n          apolloError: error,\n        });\n      },\n    });\n  };\n\n  switch (currentStep) {\n    case SettingsAccountsConfigurationStep.Email:\n      if (!isDefined(messageChannel)) {\n        return null;\n      }\n      return (\n        <SettingsAccountsConfigurationStepEmail\n          messageChannel={messageChannel}\n          hasNextStep={isDefined(calendarChannel)}\n          isSubmitting={isSubmitting}\n          onNext={handleNext}\n          onAddAccount={handleAddAccount}\n        />\n      );\n    case SettingsAccountsConfigurationStep.Calendar:\n      if (!isDefined(calendarChannel)) {\n        return null;\n      }\n      return (\n        <SettingsAccountsConfigurationStepCalendar\n          calendarChannel={calendarChannel}\n          messageChannel={messageChannel}\n          isSubmitting={isSubmitting}\n          onAddAccount={handleAddAccount}\n        />\n      );\n  }\n};",
            "output_extracted": "import { useLingui } from '@lingui/react/macro';\nimport { useState } from 'react';\nimport { useNavigate, useParams } from 'react-router-dom';\nimport { useSetRecoilState } from 'recoil';\n\nimport { type CalendarChannel } from '@/accounts/types/CalendarChannel';\nimport { type MessageChannel } from '@/accounts/types/MessageChannel';\nimport { CoreObjectNameSingular } from '@/object-metadata/types/CoreObjectNameSingular';\nimport { useGenerateDepthRecordGqlFieldsFromObject } from '@/object-record/graphql/record-gql-fields/hooks/useGenerateDepthRecordGqlFieldsFromObject';\nimport { useFindManyRecords } from '@/object-record/hooks/useFindManyRecords';\nimport { settingsAccountsSelectedMessageChannelState } from '@/settings/accounts/states/settingsAccountsSelectedMessageChannelState';\nimport { useSnackBar } from '@/ui/feedback/snack-bar-manager/hooks/useSnackBar';\nimport { SettingsPath } from 'twenty-shared/types';\nimport { getSettingsPath, isDefined } from 'twenty-shared/utils';\nimport { useStartChannelSyncMutation } from '~/generated-metadata/graphql';\nimport { SettingsAccountsConfigurationStepCalendar } from '~/pages/settings/accounts/SettingsAccountsConfigurationStepCalendar';\nimport { SettingsAccountsConfigurationStepEmail } from '~/pages/settings/accounts/SettingsAccountsConfigurationStepEmail';\n\nenum SettingsAccountsConfigurationStep {\n  Email = 'email',\n  Calendar = 'calendar',\n}\n\nexport const SettingsAccountsConfiguration = () => {\n  const { t } = useLingui();\n  const { connectedAccountId } = useParams<{\n    connectedAccountId: string;\n  }>();\n  const navigate = useNavigate();\n  const { enqueueSuccessSnackBar, enqueueErrorSnackBar } = useSnackBar();\n  const [startChannelSyncMutation, { loading: isSubmitting }] =\n    useStartChannelSyncMutation();\n  const setSelectedMessageChannel = useSetRecoilState(\n    settingsAccountsSelectedMessageChannelState,\n  );\n\n  const [currentStep, setCurrentStep] =\n    useState<SettingsAccountsConfigurationStep>(\n      SettingsAccountsConfigurationStep.Email,\n    );\n\n  const { recordGqlFields } = useGenerateDepthRecordGqlFieldsFromObject({\n    objectNameSingular: CoreObjectNameSingular.MessageChannel,\n    depth: 1,\n    shouldOnlyLoadRelationIdentifiers: false,\n  });\n\n  const { records: messageChannels } = useFindManyRecords<MessageChannel>({\n    objectNameSingular: CoreObjectNameSingular.MessageChannel,\n    filter: {\n      connectedAccountId: {\n        eq: connectedAccountId,\n      },\n    },\n    recordGqlFields,\n    onCompleted: (data) => {\n      if (isDefined(data[0])) {\n        setSelectedMessageChannel(data[0]);\n      }\n    },\n    skip: !connectedAccountId,\n  });\n\n  const { records: calendarChannels } = useFindManyRecords<CalendarChannel>({\n    objectNameSingular: CoreObjectNameSingular.CalendarChannel,\n    filter: {\n      connectedAccountId: {\n        eq: connectedAccountId,\n      },\n    },\n    skip: !connectedAccountId,\n  });\n\n  const messageChannel = messageChannels[0];\n  const calendarChannel = calendarChannels[0];\n\n  const handleNext = () => {\n    setCurrentStep(SettingsAccountsConfigurationStep.Calendar);\n  };\n\n  const handleAddAccount = async () => {\n    if (!connectedAccountId) return;\n\n    await startChannelSyncMutation({\n      variables: {\n        connectedAccountId,\n      },\n      onCompleted: () => {\n        enqueueSuccessSnackBar({\n          message: t`Account added successfully. Sync started.`,\n        });\n        navigate(getSettingsPath(SettingsPath.Accounts));\n      },\n      onError: (error) => {\n        enqueueErrorSnackBar({\n          apolloError: error,\n        });\n      },\n    });\n  };\n\n  switch (currentStep) {\n    case SettingsAccountsConfigurationStep.Email:\n      if (!isDefined(messageChannel)) {\n        return null;\n      }\n      return (\n        <SettingsAccountsConfigurationStepEmail\n          messageChannel={messageChannel}\n          hasNextStep={isDefined(calendarChannel)}\n          isSubmitting={isSubmitting}\n          onNext={handleNext}\n          onAddAccount={handleAddAccount}\n        />\n      );\n    case SettingsAccountsConfigurationStep.Calendar:\n      if (!isDefined(calendarChannel)) {\n        return null;\n      }\n      return (\n        <SettingsAccountsConfigurationStepCalendar\n          calendarChannel={calendarChannel}\n          messageChannel={messageChannel}\n          isSubmitting={isSubmitting}\n          onAddAccount={handleAddAccount}\n        />\n      );\n  }\n};",
            "cost": 0.04604
        },
        "twentyhq__twenty.main/packages/twenty-server/src/engine/core-modules/imap-smtp-caldav-connection/services/imap-smtp-caldav-connection.service.ts": {
            "output": "import { Injectable, Logger } from '@nestjs/common';\n\nimport { msg } from '@lingui/core/macro';\nimport { ImapFlow } from 'imapflow';\nimport { createTransport } from 'nodemailer';\nimport { ConnectedAccountProvider } from 'twenty-shared/types';\n\nimport { UserInputError } from 'src/engine/core-modules/graphql/utils/graphql-errors.util';\nimport {\n  type AccountType,\n  type ConnectionParameters,\n} from 'src/engine/core-modules/imap-smtp-caldav-connection/types/imap-smtp-caldav-connection.type';\nimport { TwentyORMGlobalManager } from 'src/engine/twenty-orm/twenty-orm-global.manager';\nimport { CalDAVClient } from 'src/modules/calendar/calendar-event-import-manager/drivers/caldav/lib/caldav.client';\nimport { type ConnectedAccountWorkspaceEntity } from 'src/modules/connected-account/standard-objects/connected-account.workspace-entity';\n\n@Injectable()\nexport class ImapSmtpCaldavService {\n  private readonly logger = new Logger(ImapSmtpCaldavService.name);\n\n  constructor(\n    private readonly twentyORMGlobalManager: TwentyORMGlobalManager,\n  ) {}\n\n  async testImapConnection(\n    handle: string,\n    params: ConnectionParameters,\n  ): Promise<boolean> {\n    const client = new ImapFlow({\n      host: params.host,\n      port: params.port,\n      secure: params.secure ?? true,\n      auth: {\n        user: params.username ?? handle,\n        pass: params.password,\n      },\n      logger: false,\n      tls: {\n        rejectUnauthorized: false,\n      },\n    });\n\n    try {\n      await client.connect();\n\n      const mailboxes = await client.list();\n\n      this.logger.log(\n        `IMAP connection successful. Found ${mailboxes.length} mailboxes.`,\n      );\n\n      return true;\n    } catch (error) {\n      this.logger.error(\n        `IMAP connection failed: ${error.message}`,\n        error.stack,\n      );\n\n      if (error.authenticationFailed) {\n        throw new UserInputError(\n          'IMAP authentication failed. Please check your credentials.',\n          {\n            userFriendlyMessage: msg`We couldn't log in to your email account. Please check your email address and password, then try again.`,\n          },\n        );\n      }\n\n      if (error.code === 'ECONNREFUSED') {\n        throw new UserInputError(\n          `IMAP connection refused. Please verify server and port.`,\n          {\n            userFriendlyMessage: msg`We couldn't connect to your email server. Please check your server settings and try again.`,\n          },\n        );\n      }\n\n      throw new UserInputError(`IMAP connection failed: ${error.message}`, {\n        userFriendlyMessage: msg`We encountered an issue connecting to your email account. Please check your settings and try again.`,\n      });\n    } finally {\n      if (client.authenticated) {\n        await client.logout();\n      }\n    }\n  }\n\n  async testSmtpConnection(\n    handle: string,\n    params: ConnectionParameters,\n  ): Promise<boolean> {\n    const transport = createTransport({\n      host: params.host,\n      port: params.port,\n      auth: {\n        user: params.username ?? handle,\n        pass: params.password,\n      },\n      tls: {\n        rejectUnauthorized: false,\n      },\n    });\n\n    try {\n      await transport.verify();\n    } catch (error) {\n      this.logger.error(\n        `SMTP connection failed: ${error.message}`,\n        error.stack,\n      );\n      throw new UserInputError(`SMTP connection failed: ${error.message}`, {\n        userFriendlyMessage: msg`We couldn't connect to your outgoing email server. Please check your SMTP settings and try again.`,\n      });\n    }\n\n    return true;\n  }\n\n  async testCaldavConnection(\n    handle: string,\n    params: ConnectionParameters,\n  ): Promise<boolean> {\n    const client = new CalDAVClient({\n      serverUrl: params.host,\n      username: params.username ?? handle,\n      password: params.password,\n    });\n\n    try {\n      await client.listCalendars();\n    } catch (error) {\n      this.logger.error(\n        `CALDAV connection failed: ${error.message}`,\n        error.stack,\n      );\n      if (error.code === 'FailedToOpenSocket') {\n        throw new UserInputError(`CALDAV connection failed: ${error.message}`, {\n          userFriendlyMessage: msg`We couldn't connect to your CalDAV server. Please check your server settings and try again.`,\n        });\n      }\n\n      throw new UserInputError(`CALDAV connection failed: ${error.message}`, {\n        userFriendlyMessage: msg`Invalid credentials. Please check your username and password.`,\n      });\n    }\n\n    return true;\n  }\n\n  async testImapSmtpCaldav(\n    handle: string,\n    params: ConnectionParameters,\n    accountType: AccountType,\n  ): Promise<boolean> {\n    if (accountType === 'IMAP') {\n      return this.testImapConnection(handle, params);\n    }\n\n    if (accountType === 'SMTP') {\n      return this.testSmtpConnection(handle, params);\n    }\n\n    if (accountType === 'CALDAV') {\n      return this.testCaldavConnection(handle, params);\n    }\n\n    throw new UserInputError(\n      'Invalid account type. Must be one of: IMAP, SMTP, CALDAV',\n      {\n        userFriendlyMessage: msg`Please select a valid connection type (IMAP, SMTP, or CalDAV) and try again.`,\n      },\n    );\n  }\n\n  async getImapSmtpCaldav(\n    workspaceId: string,\n    connectionId: string,\n  ): Promise<ConnectedAccountWorkspaceEntity | null> {\n    const connectedAccountRepository =\n      await this.twentyORMGlobalManager.getRepositoryForWorkspace<ConnectedAccountWorkspaceEntity>(\n        workspaceId,\n        'connectedAccount',\n      );\n\n    const connectedAccount = await connectedAccountRepository.findOne({\n      where: {\n        id: connectionId,\n        provider: ConnectedAccountProvider.IMAP_SMTP_CALDAV,\n      },\n    });\n\n    return connectedAccount;\n  }\n}",
            "output_extracted": "import { Injectable, Logger } from '@nestjs/common';\n\nimport { msg } from '@lingui/core/macro';\nimport { ImapFlow } from 'imapflow';\nimport { createTransport } from 'nodemailer';\nimport { ConnectedAccountProvider } from 'twenty-shared/types';\n\nimport { UserInputError } from 'src/engine/core-modules/graphql/utils/graphql-errors.util';\nimport {\n  type AccountType,\n  type ConnectionParameters,\n} from 'src/engine/core-modules/imap-smtp-caldav-connection/types/imap-smtp-caldav-connection.type';\nimport { TwentyORMGlobalManager } from 'src/engine/twenty-orm/twenty-orm-global.manager';\nimport { CalDAVClient } from 'src/modules/calendar/calendar-event-import-manager/drivers/caldav/lib/caldav.client';\nimport { type ConnectedAccountWorkspaceEntity } from 'src/modules/connected-account/standard-objects/connected-account.workspace-entity';\n\n@Injectable()\nexport class ImapSmtpCaldavService {\n  private readonly logger = new Logger(ImapSmtpCaldavService.name);\n\n  constructor(\n    private readonly twentyORMGlobalManager: TwentyORMGlobalManager,\n  ) {}\n\n  async testImapConnection(\n    handle: string,\n    params: ConnectionParameters,\n  ): Promise<boolean> {\n    const client = new ImapFlow({\n      host: params.host,\n      port: params.port,\n      secure: params.secure ?? true,\n      auth: {\n        user: params.username ?? handle,\n        pass: params.password,\n      },\n      logger: false,\n      tls: {\n        rejectUnauthorized: false,\n      },\n    });\n\n    try {\n      await client.connect();\n\n      const mailboxes = await client.list();\n\n      this.logger.log(\n        `IMAP connection successful. Found ${mailboxes.length} mailboxes.`,\n      );\n\n      return true;\n    } catch (error) {\n      this.logger.error(\n        `IMAP connection failed: ${error.message}`,\n        error.stack,\n      );\n\n      if (error.authenticationFailed) {\n        throw new UserInputError(\n          'IMAP authentication failed. Please check your credentials.',\n          {\n            userFriendlyMessage: msg`We couldn't log in to your email account. Please check your email address and password, then try again.`,\n          },\n        );\n      }\n\n      if (error.code === 'ECONNREFUSED') {\n        throw new UserInputError(\n          `IMAP connection refused. Please verify server and port.`,\n          {\n            userFriendlyMessage: msg`We couldn't connect to your email server. Please check your server settings and try again.`,\n          },\n        );\n      }\n\n      throw new UserInputError(`IMAP connection failed: ${error.message}`, {\n        userFriendlyMessage: msg`We encountered an issue connecting to your email account. Please check your settings and try again.`,\n      });\n    } finally {\n      if (client.authenticated) {\n        await client.logout();\n      }\n    }\n  }\n\n  async testSmtpConnection(\n    handle: string,\n    params: ConnectionParameters,\n  ): Promise<boolean> {\n    const transport = createTransport({\n      host: params.host,\n      port: params.port,\n      auth: {\n        user: params.username ?? handle,\n        pass: params.password,\n      },\n      tls: {\n        rejectUnauthorized: false,\n      },\n    });\n\n    try {\n      await transport.verify();\n    } catch (error) {\n      this.logger.error(\n        `SMTP connection failed: ${error.message}`,\n        error.stack,\n      );\n      throw new UserInputError(`SMTP connection failed: ${error.message}`, {\n        userFriendlyMessage: msg`We couldn't connect to your outgoing email server. Please check your SMTP settings and try again.`,\n      });\n    }\n\n    return true;\n  }\n\n  async testCaldavConnection(\n    handle: string,\n    params: ConnectionParameters,\n  ): Promise<boolean> {\n    const client = new CalDAVClient({\n      serverUrl: params.host,\n      username: params.username ?? handle,\n      password: params.password,\n    });\n\n    try {\n      await client.listCalendars();\n    } catch (error) {\n      this.logger.error(\n        `CALDAV connection failed: ${error.message}`,\n        error.stack,\n      );\n      if (error.code === 'FailedToOpenSocket') {\n        throw new UserInputError(`CALDAV connection failed: ${error.message}`, {\n          userFriendlyMessage: msg`We couldn't connect to your CalDAV server. Please check your server settings and try again.`,\n        });\n      }\n\n      throw new UserInputError(`CALDAV connection failed: ${error.message}`, {\n        userFriendlyMessage: msg`Invalid credentials. Please check your username and password.`,\n      });\n    }\n\n    return true;\n  }\n\n  async testImapSmtpCaldav(\n    handle: string,\n    params: ConnectionParameters,\n    accountType: AccountType,\n  ): Promise<boolean> {\n    if (accountType === 'IMAP') {\n      return this.testImapConnection(handle, params);\n    }\n\n    if (accountType === 'SMTP') {\n      return this.testSmtpConnection(handle, params);\n    }\n\n    if (accountType === 'CALDAV') {\n      return this.testCaldavConnection(handle, params);\n    }\n\n    throw new UserInputError(\n      'Invalid account type. Must be one of: IMAP, SMTP, CALDAV',\n      {\n        userFriendlyMessage: msg`Please select a valid connection type (IMAP, SMTP, or CalDAV) and try again.`,\n      },\n    );\n  }\n\n  async getImapSmtpCaldav(\n    workspaceId: string,\n    connectionId: string,\n  ): Promise<ConnectedAccountWorkspaceEntity | null> {\n    const connectedAccountRepository =\n      await this.twentyORMGlobalManager.getRepositoryForWorkspace<ConnectedAccountWorkspaceEntity>(\n        workspaceId,\n        'connectedAccount',\n      );\n\n    const connectedAccount = await connectedAccountRepository.findOne({\n      where: {\n        id: connectionId,\n        provider: ConnectedAccountProvider.IMAP_SMTP_CALDAV,\n      },\n    });\n\n    return connectedAccount;\n  }\n}",
            "cost": 0.054885
        },
        "twentyhq__twenty.main/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/drivers/caldav/lib/caldav.client.ts": {
            "output": "import { Injectable, Logger } from '@nestjs/common';\n\nimport * as ical from 'node-ical';\nimport {\n  calendarMultiGet,\n  createAccount,\n  type DAVAccount,\n  type DAVCalendar,\n  DAVNamespaceShort,\n  type DAVObject,\n  fetchCalendars,\n  getBasicAuthHeaders,\n  syncCollection,\n} from 'tsdav';\n\nimport { CalDavGetEventsService } from 'src/modules/calendar/calendar-event-import-manager/drivers/caldav/services/caldav-get-events.service';\nimport { CalendarEventParticipantResponseStatus } from 'src/modules/calendar/common/standard-objects/calendar-event-participant.workspace-entity';\nimport {\n  type FetchedCalendarEvent,\n  type FetchedCalendarEventParticipant,\n} from 'src/modules/calendar/common/types/fetched-calendar-event';\n\nconst DEFAULT_CALENDAR_TYPE = 'caldav';\n\ntype CalendarCredentials = {\n  username: string;\n  password: string;\n  serverUrl: string;\n};\n\ntype SimpleCalendar = {\n  id: string;\n  name: string;\n  url: string;\n  isPrimary?: boolean;\n  syncToken?: string | number;\n};\n\ntype FetchEventsOptions = {\n  startDate: Date;\n  endDate: Date;\n  syncCursor?: CalDAVSyncCursor;\n};\n\ntype CalDAVSyncResult = {\n  events: FetchedCalendarEvent[];\n  newSyncToken?: string;\n};\n\ntype CalDAVSyncCursor = {\n  syncTokens: Record<string, string>;\n};\n\ntype CalDAVGetEventsResponse = {\n  events: FetchedCalendarEvent[];\n  syncCursor: CalDAVSyncCursor;\n};\n\n@Injectable()\nexport class CalDAVClient {\n  private credentials: CalendarCredentials;\n  private logger: Logger;\n  private headers: Record<string, string>;\n\n  constructor(credentials: CalendarCredentials) {\n    this.credentials = credentials;\n    this.logger = new Logger(CalDAVClient.name);\n    this.headers = getBasicAuthHeaders({\n      username: credentials.username,\n      password: credentials.password,\n    });\n  }\n\n  private hasFileExtension(url: string): boolean {\n    const fileName = url.substring(url.lastIndexOf('/') + 1);\n\n    return (\n      fileName.includes('.') &&\n      !fileName.substring(fileName.lastIndexOf('.')).includes('/')\n    );\n  }\n\n  private getFileExtension(url: string): string {\n    if (!this.hasFileExtension(url)) return 'ics';\n    const fileName = url.substring(url.lastIndexOf('/') + 1);\n\n    return fileName.substring(fileName.lastIndexOf('.') + 1);\n  }\n\n  private isValidFormat(url: string): boolean {\n    const allowedExtensions = ['eml', 'ics'];\n\n    return allowedExtensions.includes(this.getFileExtension(url));\n  }\n\n  private async getAccount(): Promise<DAVAccount> {\n    return createAccount({\n      account: {\n        serverUrl: this.credentials.serverUrl,\n        accountType: DEFAULT_CALENDAR_TYPE,\n        credentials: {\n          username: this.credentials.username,\n          password: this.credentials.password,\n        },\n      },\n      headers: this.headers,\n    });\n  }\n\n  async listCalendars(): Promise<SimpleCalendar[]> {\n    try {\n      const account = await this.getAccount();\n\n      const calendars = (await fetchCalendars({\n        account,\n        headers: this.headers,\n      })) as (Omit<DAVCalendar, 'displayName'> & {\n        displayName?: string | Record<string, unknown>;\n      })[];\n\n      return calendars.reduce<SimpleCalendar[]>((result, calendar) => {\n        if (!calendar.components?.includes('VEVENT')) return result;\n\n        result.push({\n          id: calendar.url,\n          url: calendar.url,\n          name:\n            typeof calendar.displayName === 'string'\n              ? calendar.displayName\n              : 'Unnamed Calendar',\n          isPrimary: false,\n        });\n\n        return result;\n      }, []);\n    } catch (error) {\n      this.logger.error(\n        `Error in ${CalDavGetEventsService.name} - getCalendarEvents`,\n        error.code,\n        error,\n      );\n\n      throw error;\n    }\n  }\n\n  /**\n   * Determines if an event is a full-day event by checking the raw iCal data.\n   * Full-day events use VALUE=DATE parameter in DTSTART/DTEND properties.\n   * Since node-ical converts all dates to JavaScript Date objects, we must check the raw data.\n   * @see https://tools.ietf.org/html/rfc5545#section-3.3.4 (DATE Value Type)\n   * @see https://tools.ietf.org/html/rfc5545#section-3.3.5 (DATE-TIME Value Type)\n   * @see https://tools.ietf.org/html/rfc5545#section-3.2.20 (VALUE Parameter)\n   */\n  private isFullDayEvent(rawICalData: string): boolean {\n    const lines = rawICalData.split(/\\r?\\n/);\n\n    for (const line of lines) {\n      const trimmedLine = line.trim();\n\n      if (\n        trimmedLine.startsWith('DTSTART') &&\n        trimmedLine.includes('VALUE=DATE')\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private extractOrganizerFromEvent(\n    event: ical.VEvent,\n  ): FetchedCalendarEventParticipant | null {\n    if (!event.organizer) {\n      return null;\n    }\n\n    const organizerEmail =\n      // @ts-expect-error - limitation of node-ical typing\n      event.organizer.val?.replace(/^mailto:/i, '') || '';\n\n    return {\n      displayName:\n        // @ts-expect-error - limitation of node-ical typing\n        event.organizer.params?.CN || organizerEmail || 'Unknown',\n      responseStatus: CalendarEventParticipantResponseStatus.ACCEPTED,\n      handle: organizerEmail,\n      isOrganizer: true,\n    };\n  }\n\n  private mapPartStatToResponseStatus(\n    partStat: ical.AttendeePartStat,\n  ): CalendarEventParticipantResponseStatus {\n    switch (partStat) {\n      case 'ACCEPTED':\n        return CalendarEventParticipantResponseStatus.ACCEPTED;\n      case 'DECLINED':\n        return CalendarEventParticipantResponseStatus.DECLINED;\n      case 'TENTATIVE':\n        return CalendarEventParticipantResponseStatus.TENTATIVE;\n      case 'NEEDS-ACTION':\n      default:\n        return CalendarEventParticipantResponseStatus.NEEDS_ACTION;\n    }\n  }\n\n  private extractAttendeesFromEvent(\n    event: ical.VEvent,\n  ): FetchedCalendarEventParticipant[] {\n    if (!event.attendee) {\n      return [];\n    }\n\n    const attendees = Array.isArray(event.attendee)\n      ? event.attendee\n      : [event.attendee];\n\n    return attendees.map((attendee: ical.Attendee) => {\n      // @ts-expect-error - limitation of node-ical typing\n      const handle = attendee.val?.replace(/^mailto:/i, '') || '';\n      // @ts-expect-error - limitation of node-ical typing\n      const displayName = attendee.params?.CN || handle || 'Unknown';\n      // @ts-expect-error - limitation of node-ical typing\n      const partStat = attendee.params?.PARTSTAT || 'NEEDS_ACTION';\n\n      return {\n        displayName,\n        responseStatus: this.mapPartStatToResponseStatus(partStat),\n        handle,\n        isOrganizer: false,\n      };\n    });\n  }\n\n  private extractParticipantsFromEvent(\n    event: ical.VEvent,\n  ): FetchedCalendarEventParticipant[] {\n    const participants: FetchedCalendarEventParticipant[] = [];\n\n    const organizer = this.extractOrganizerFromEvent(event);\n\n    if (organizer) {\n      participants.push(organizer);\n    }\n\n    const attendees = this.extractAttendeesFromEvent(event);\n\n    participants.push(...attendees);\n\n    return participants;\n  }\n\n  private parseICalData(\n    rawData: string,\n    objectUrl: string,\n  ): FetchedCalendarEvent | null {\n    try {\n      const parsed = ical.parseICS(rawData);\n      const events = Object.values(parsed).filter(\n        (item) => item.type === 'VEVENT',\n      );\n\n      if (events.length === 0) {\n        return null;\n      }\n\n      const event = events[0] as ical.VEvent;\n      const participants = this.extractParticipantsFromEvent(event);\n\n      return {\n        id: objectUrl,\n        title: event.summary || 'Untitled Event',\n        iCalUID: event.uid || '',\n        description: event.description || '',\n        startsAt: event.start.toISOString(),\n        endsAt: event.end.toISOString(),\n        location: event.location || '',\n        isFullDay: this.isFullDayEvent(rawData),\n        isCanceled: event.status === 'CANCELLED',\n        conferenceLinkLabel: '',\n        conferenceLinkUrl: event.url,\n        externalCreatedAt:\n          event.created?.toISOString() || new Date().toISOString(),\n        externalUpdatedAt:\n          event.lastmodified?.toISOString() ||\n          event.created?.toISOString() ||\n          new Date().toISOString(),\n        conferenceSolution: '',\n        recurringEventExternalId: event.recurrenceid\n          ? String(event.recurrenceid)\n          : undefined,\n        participants,\n        status: event.status || 'CONFIRMED',\n      };\n    } catch (error) {\n      this.logger.error(\n        `Error in ${CalDavGetEventsService.name} - parseICalData`,\n        error,\n      );\n\n      return null;\n    }\n  }\n\n  async getEvents(\n    options: FetchEventsOptions,\n  ): Promise<CalDAVGetEventsResponse> {\n    const calendars = await this.listCalendars();\n    const results = new Map<string, CalDAVSyncResult>();\n\n    const syncPromises = calendars.map(async (calendar) => {\n      try {\n        const syncToken =\n          options.syncCursor?.syncTokens[calendar.url] ||\n          calendar.syncToken?.toString();\n\n        const syncResult = await syncCollection({\n          url: calendar.url,\n          props: {\n            [`${DAVNamespaceShort.DAV}:getetag`]: {},\n            [`${DAVNamespaceShort.CALDAV}:calendar-data`]: {},\n          },\n          syncLevel: 1,\n          ...(syncToken ? { syncToken } : {}),\n          headers: this.headers,\n        });\n\n        const allEvents: FetchedCalendarEvent[] = [];\n\n        const objectUrls = syncResult\n          .map((event) => event.href)\n          .filter((href): href is string => !!href && this.isValidFormat(href));\n\n        if (objectUrls.length > 0) {\n          try {\n            const calendarObjects = await calendarMultiGet({\n              url: calendar.url,\n              props: {\n                [`${DAVNamespaceShort.DAV}:getetag`]: {},\n                [`${DAVNamespaceShort.CALDAV}:calendar-data`]: {},\n              },\n              objectUrls: objectUrls,\n              depth: '1',\n              headers: this.headers,\n            });\n\n            for (const calendarObject of calendarObjects) {\n              if (calendarObject.props?.calendarData) {\n                const iCalData = this.extractICalData(\n                  calendarObject.props?.calendarData,\n                );\n\n                if (!iCalData) {\n                  continue;\n                }\n\n                const event = this.parseICalData(\n                  iCalData,\n                  calendarObject.href || '',\n                );\n\n                if (\n                  event &&\n                  this.isEventInTimeRange(\n                    {\n                      url: calendarObject.href || '',\n                      data: calendarObject.props.calendarData,\n                      etag: calendarObject.props.getetag,\n                    },\n                    options.startDate,\n                    options.endDate,\n                  )\n                ) {\n                  allEvents.push(event);\n                }\n              }\n            }\n          } catch (fetchError) {\n            this.logger.error(\n              `Error in ${CalDavGetEventsService.name} - getEvents`,\n              fetchError,\n            );\n          }\n        }\n\n        let newSyncToken = syncToken;\n\n        try {\n          const account = await this.getAccount();\n          const updatedCalendars = await fetchCalendars({\n            account,\n            headers: this.headers,\n          });\n          const updatedCalendar = updatedCalendars.find(\n            (cal) => cal.url === calendar.url,\n          );\n\n          if (updatedCalendar?.syncToken) {\n            newSyncToken = updatedCalendar.syncToken.toString();\n          }\n        } catch (syncTokenError) {\n          this.logger.error(\n            `Error in ${CalDavGetEventsService.name} - getEvents`,\n            syncTokenError,\n          );\n        }\n\n        results.set(calendar.url, {\n          events: allEvents,\n          newSyncToken,\n        });\n      } catch {\n        results.set(calendar.url, {\n          events: [],\n          newSyncToken: options.syncCursor?.syncTokens[calendar.url],\n        });\n      }\n    });\n\n    await Promise.all(syncPromises);\n\n    const allEvents = Array.from(results.values())\n      .map((result) => result.events)\n      .flat();\n\n    const syncTokens: Record<string, string> = {};\n\n    for (const [calendarUrl, result] of results) {\n      if (result.newSyncToken) {\n        syncTokens[calendarUrl] = result.newSyncToken;\n      }\n    }\n\n    return {\n      events: allEvents,\n      syncCursor: { syncTokens },\n    };\n  }\n\n  /**\n   * Extracts iCal data from various CalDAV server response formats.\n   * Some servers return data directly as a string, others nest it under _cdata or some other properties.\n   */\n  private extractICalData(\n    calendarData: string | Record<string, unknown>,\n  ): string | null {\n    if (!calendarData) return null;\n\n    if (\n      typeof calendarData === 'string' &&\n      calendarData.includes('VCALENDAR')\n    ) {\n      return calendarData;\n    }\n\n    if (typeof calendarData === 'object' && calendarData !== null) {\n      for (const key in calendarData) {\n        const result = this.extractICalData(\n          calendarData[key] as string | Record<string, unknown>,\n        );\n\n        if (result) return result;\n      }\n    }\n\n    return null;\n  }\n\n  private isEventInTimeRange(\n    davObject: DAVObject,\n    startDate: Date,\n    endDate: Date,\n  ): boolean {\n    try {\n      if (!davObject.data) return false;\n\n      const parsed = ical.parseICS(davObject.data);\n      const events = Object.values(parsed).filter(\n        (item) => item.type === 'VEVENT',\n      );\n\n      if (events.length === 0) return false;\n\n      const event = events[0] as ical.VEvent;\n\n      return event.start < endDate && event.end > startDate;\n    } catch {\n      return true;\n    }\n  }\n}",
            "output_extracted": "import { Injectable, Logger } from '@nestjs/common';\n\nimport * as ical from 'node-ical';\nimport {\n  calendarMultiGet,\n  createAccount,\n  type DAVAccount,\n  type DAVCalendar,\n  DAVNamespaceShort,\n  type DAVObject,\n  fetchCalendars,\n  getBasicAuthHeaders,\n  syncCollection,\n} from 'tsdav';\n\nimport { CalDavGetEventsService } from 'src/modules/calendar/calendar-event-import-manager/drivers/caldav/services/caldav-get-events.service';\nimport { CalendarEventParticipantResponseStatus } from 'src/modules/calendar/common/standard-objects/calendar-event-participant.workspace-entity';\nimport {\n  type FetchedCalendarEvent,\n  type FetchedCalendarEventParticipant,\n} from 'src/modules/calendar/common/types/fetched-calendar-event';\n\nconst DEFAULT_CALENDAR_TYPE = 'caldav';\n\ntype CalendarCredentials = {\n  username: string;\n  password: string;\n  serverUrl: string;\n};\n\ntype SimpleCalendar = {\n  id: string;\n  name: string;\n  url: string;\n  isPrimary?: boolean;\n  syncToken?: string | number;\n};\n\ntype FetchEventsOptions = {\n  startDate: Date;\n  endDate: Date;\n  syncCursor?: CalDAVSyncCursor;\n};\n\ntype CalDAVSyncResult = {\n  events: FetchedCalendarEvent[];\n  newSyncToken?: string;\n};\n\ntype CalDAVSyncCursor = {\n  syncTokens: Record<string, string>;\n};\n\ntype CalDAVGetEventsResponse = {\n  events: FetchedCalendarEvent[];\n  syncCursor: CalDAVSyncCursor;\n};\n\n@Injectable()\nexport class CalDAVClient {\n  private credentials: CalendarCredentials;\n  private logger: Logger;\n  private headers: Record<string, string>;\n\n  constructor(credentials: CalendarCredentials) {\n    this.credentials = credentials;\n    this.logger = new Logger(CalDAVClient.name);\n    this.headers = getBasicAuthHeaders({\n      username: credentials.username,\n      password: credentials.password,\n    });\n  }\n\n  private hasFileExtension(url: string): boolean {\n    const fileName = url.substring(url.lastIndexOf('/') + 1);\n\n    return (\n      fileName.includes('.') &&\n      !fileName.substring(fileName.lastIndexOf('.')).includes('/')\n    );\n  }\n\n  private getFileExtension(url: string): string {\n    if (!this.hasFileExtension(url)) return 'ics';\n    const fileName = url.substring(url.lastIndexOf('/') + 1);\n\n    return fileName.substring(fileName.lastIndexOf('.') + 1);\n  }\n\n  private isValidFormat(url: string): boolean {\n    const allowedExtensions = ['eml', 'ics'];\n\n    return allowedExtensions.includes(this.getFileExtension(url));\n  }\n\n  private async getAccount(): Promise<DAVAccount> {\n    return createAccount({\n      account: {\n        serverUrl: this.credentials.serverUrl,\n        accountType: DEFAULT_CALENDAR_TYPE,\n        credentials: {\n          username: this.credentials.username,\n          password: this.credentials.password,\n        },\n      },\n      headers: this.headers,\n    });\n  }\n\n  async listCalendars(): Promise<SimpleCalendar[]> {\n    try {\n      const account = await this.getAccount();\n\n      const calendars = (await fetchCalendars({\n        account,\n        headers: this.headers,\n      })) as (Omit<DAVCalendar, 'displayName'> & {\n        displayName?: string | Record<string, unknown>;\n      })[];\n\n      return calendars.reduce<SimpleCalendar[]>((result, calendar) => {\n        if (!calendar.components?.includes('VEVENT')) return result;\n\n        result.push({\n          id: calendar.url,\n          url: calendar.url,\n          name:\n            typeof calendar.displayName === 'string'\n              ? calendar.displayName\n              : 'Unnamed Calendar',\n          isPrimary: false,\n        });\n\n        return result;\n      }, []);\n    } catch (error) {\n      this.logger.error(\n        `Error in ${CalDavGetEventsService.name} - getCalendarEvents`,\n        error.code,\n        error,\n      );\n\n      throw error;\n    }\n  }\n\n  /**\n   * Determines if an event is a full-day event by checking the raw iCal data.\n   * Full-day events use VALUE=DATE parameter in DTSTART/DTEND properties.\n   * Since node-ical converts all dates to JavaScript Date objects, we must check the raw data.\n   * @see https://tools.ietf.org/html/rfc5545#section-3.3.4 (DATE Value Type)\n   * @see https://tools.ietf.org/html/rfc5545#section-3.3.5 (DATE-TIME Value Type)\n   * @see https://tools.ietf.org/html/rfc5545#section-3.2.20 (VALUE Parameter)\n   */\n  private isFullDayEvent(rawICalData: string): boolean {\n    const lines = rawICalData.split(/\\r?\\n/);\n\n    for (const line of lines) {\n      const trimmedLine = line.trim();\n\n      if (\n        trimmedLine.startsWith('DTSTART') &&\n        trimmedLine.includes('VALUE=DATE')\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private extractOrganizerFromEvent(\n    event: ical.VEvent,\n  ): FetchedCalendarEventParticipant | null {\n    if (!event.organizer) {\n      return null;\n    }\n\n    const organizerEmail =\n      // @ts-expect-error - limitation of node-ical typing\n      event.organizer.val?.replace(/^mailto:/i, '') || '';\n\n    return {\n      displayName:\n        // @ts-expect-error - limitation of node-ical typing\n        event.organizer.params?.CN || organizerEmail || 'Unknown',\n      responseStatus: CalendarEventParticipantResponseStatus.ACCEPTED,\n      handle: organizerEmail,\n      isOrganizer: true,\n    };\n  }\n\n  private mapPartStatToResponseStatus(\n    partStat: ical.AttendeePartStat,\n  ): CalendarEventParticipantResponseStatus {\n    switch (partStat) {\n      case 'ACCEPTED':\n        return CalendarEventParticipantResponseStatus.ACCEPTED;\n      case 'DECLINED':\n        return CalendarEventParticipantResponseStatus.DECLINED;\n      case 'TENTATIVE':\n        return CalendarEventParticipantResponseStatus.TENTATIVE;\n      case 'NEEDS-ACTION':\n      default:\n        return CalendarEventParticipantResponseStatus.NEEDS_ACTION;\n    }\n  }\n\n  private extractAttendeesFromEvent(\n    event: ical.VEvent,\n  ): FetchedCalendarEventParticipant[] {\n    if (!event.attendee) {\n      return [];\n    }\n\n    const attendees = Array.isArray(event.attendee)\n      ? event.attendee\n      : [event.attendee];\n\n    return attendees.map((attendee: ical.Attendee) => {\n      // @ts-expect-error - limitation of node-ical typing\n      const handle = attendee.val?.replace(/^mailto:/i, '') || '';\n      // @ts-expect-error - limitation of node-ical typing\n      const displayName = attendee.params?.CN || handle || 'Unknown';\n      // @ts-expect-error - limitation of node-ical typing\n      const partStat = attendee.params?.PARTSTAT || 'NEEDS_ACTION';\n\n      return {\n        displayName,\n        responseStatus: this.mapPartStatToResponseStatus(partStat),\n        handle,\n        isOrganizer: false,\n      };\n    });\n  }\n\n  private extractParticipantsFromEvent(\n    event: ical.VEvent,\n  ): FetchedCalendarEventParticipant[] {\n    const participants: FetchedCalendarEventParticipant[] = [];\n\n    const organizer = this.extractOrganizerFromEvent(event);\n\n    if (organizer) {\n      participants.push(organizer);\n    }\n\n    const attendees = this.extractAttendeesFromEvent(event);\n\n    participants.push(...attendees);\n\n    return participants;\n  }\n\n  private parseICalData(\n    rawData: string,\n    objectUrl: string,\n  ): FetchedCalendarEvent | null {\n    try {\n      const parsed = ical.parseICS(rawData);\n      const events = Object.values(parsed).filter(\n        (item) => item.type === 'VEVENT',\n      );\n\n      if (events.length === 0) {\n        return null;\n      }\n\n      const event = events[0] as ical.VEvent;\n      const participants = this.extractParticipantsFromEvent(event);\n\n      return {\n        id: objectUrl,\n        title: event.summary || 'Untitled Event',\n        iCalUID: event.uid || '',\n        description: event.description || '',\n        startsAt: event.start.toISOString(),\n        endsAt: event.end.toISOString(),\n        location: event.location || '',\n        isFullDay: this.isFullDayEvent(rawData),\n        isCanceled: event.status === 'CANCELLED',\n        conferenceLinkLabel: '',\n        conferenceLinkUrl: event.url,\n        externalCreatedAt:\n          event.created?.toISOString() || new Date().toISOString(),\n        externalUpdatedAt:\n          event.lastmodified?.toISOString() ||\n          event.created?.toISOString() ||\n          new Date().toISOString(),\n        conferenceSolution: '',\n        recurringEventExternalId: event.recurrenceid\n          ? String(event.recurrenceid)\n          : undefined,\n        participants,\n        status: event.status || 'CONFIRMED',\n      };\n    } catch (error) {\n      this.logger.error(\n        `Error in ${CalDavGetEventsService.name} - parseICalData`,\n        error,\n      );\n\n      return null;\n    }\n  }\n\n  async getEvents(\n    options: FetchEventsOptions,\n  ): Promise<CalDAVGetEventsResponse> {\n    const calendars = await this.listCalendars();\n    const results = new Map<string, CalDAVSyncResult>();\n\n    const syncPromises = calendars.map(async (calendar) => {\n      try {\n        const syncToken =\n          options.syncCursor?.syncTokens[calendar.url] ||\n          calendar.syncToken?.toString();\n\n        const syncResult = await syncCollection({\n          url: calendar.url,\n          props: {\n            [`${DAVNamespaceShort.DAV}:getetag`]: {},\n            [`${DAVNamespaceShort.CALDAV}:calendar-data`]: {},\n          },\n          syncLevel: 1,\n          ...(syncToken ? { syncToken } : {}),\n          headers: this.headers,\n        });\n\n        const allEvents: FetchedCalendarEvent[] = [];\n\n        const objectUrls = syncResult\n          .map((event) => event.href)\n          .filter((href): href is string => !!href && this.isValidFormat(href));\n\n        if (objectUrls.length > 0) {\n          try {\n            const calendarObjects = await calendarMultiGet({\n              url: calendar.url,\n              props: {\n                [`${DAVNamespaceShort.DAV}:getetag`]: {},\n                [`${DAVNamespaceShort.CALDAV}:calendar-data`]: {},\n              },\n              objectUrls: objectUrls,\n              depth: '1',\n              headers: this.headers,\n            });\n\n            for (const calendarObject of calendarObjects) {\n              if (calendarObject.props?.calendarData) {\n                const iCalData = this.extractICalData(\n                  calendarObject.props?.calendarData,\n                );\n\n                if (!iCalData) {\n                  continue;\n                }\n\n                const event = this.parseICalData(\n                  iCalData,\n                  calendarObject.href || '',\n                );\n\n                if (\n                  event &&\n                  this.isEventInTimeRange(\n                    {\n                      url: calendarObject.href || '',\n                      data: calendarObject.props.calendarData,\n                      etag: calendarObject.props.getetag,\n                    },\n                    options.startDate,\n                    options.endDate,\n                  )\n                ) {\n                  allEvents.push(event);\n                }\n              }\n            }\n          } catch (fetchError) {\n            this.logger.error(\n              `Error in ${CalDavGetEventsService.name} - getEvents`,\n              fetchError,\n            );\n          }\n        }\n\n        let newSyncToken = syncToken;\n\n        try {\n          const account = await this.getAccount();\n          const updatedCalendars = await fetchCalendars({\n            account,\n            headers: this.headers,\n          });\n          const updatedCalendar = updatedCalendars.find(\n            (cal) => cal.url === calendar.url,\n          );\n\n          if (updatedCalendar?.syncToken) {\n            newSyncToken = updatedCalendar.syncToken.toString();\n          }\n        } catch (syncTokenError) {\n          this.logger.error(\n            `Error in ${CalDavGetEventsService.name} - getEvents`,\n            syncTokenError,\n          );\n        }\n\n        results.set(calendar.url, {\n          events: allEvents,\n          newSyncToken,\n        });\n      } catch {\n        results.set(calendar.url, {\n          events: [],\n          newSyncToken: options.syncCursor?.syncTokens[calendar.url],\n        });\n      }\n    });\n\n    await Promise.all(syncPromises);\n\n    const allEvents = Array.from(results.values())\n      .map((result) => result.events)\n      .flat();\n\n    const syncTokens: Record<string, string> = {};\n\n    for (const [calendarUrl, result] of results) {\n      if (result.newSyncToken) {\n        syncTokens[calendarUrl] = result.newSyncToken;\n      }\n    }\n\n    return {\n      events: allEvents,\n      syncCursor: { syncTokens },\n    };\n  }\n\n  /**\n   * Extracts iCal data from various CalDAV server response formats.\n   * Some servers return data directly as a string, others nest it under _cdata or some other properties.\n   */\n  private extractICalData(\n    calendarData: string | Record<string, unknown>,\n  ): string | null {\n    if (!calendarData) return null;\n\n    if (\n      typeof calendarData === 'string' &&\n      calendarData.includes('VCALENDAR')\n    ) {\n      return calendarData;\n    }\n\n    if (typeof calendarData === 'object' && calendarData !== null) {\n      for (const key in calendarData) {\n        const result = this.extractICalData(\n          calendarData[key] as string | Record<string, unknown>,\n        );\n\n        if (result) return result;\n      }\n    }\n\n    return null;\n  }\n\n  private isEventInTimeRange(\n    davObject: DAVObject,\n    startDate: Date,\n    endDate: Date,\n  ): boolean {\n    try {\n      if (!davObject.data) return false;\n\n      const parsed = ical.parseICS(davObject.data);\n      const events = Object.values(parsed).filter(\n        (item) => item.type === 'VEVENT',\n      );\n\n      if (events.length === 0) return false;\n\n      const event = events[0] as ical.VEvent;\n\n      return event.start < endDate && event.end > startDate;\n    } catch {\n      return true;\n    }\n  }\n}",
            "cost": 0.12769
        },
        "twentyhq__twenty.main/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/services/calendar-account-authentication.service.ts": {
            "output": "import { Injectable } from '@nestjs/common';\n\nimport { isDefined } from 'class-validator';\nimport { ConnectedAccountProvider } from 'twenty-shared/types';\n\nimport {\n  CalendarEventImportDriverException,\n  CalendarEventImportDriverExceptionCode,\n} from 'src/modules/calendar/calendar-event-import-manager/drivers/exceptions/calendar-event-import-driver.exception';\nimport { ConnectedAccountRefreshAccessTokenExceptionCode } from 'src/modules/connected-account/refresh-tokens-manager/exceptions/connected-account-refresh-tokens.exception';\nimport {\n  ConnectedAccountRefreshTokensService,\n  type ConnectedAccountTokens,\n} from 'src/modules/connected-account/refresh-tokens-manager/services/connected-account-refresh-tokens.service';\nimport { type ConnectedAccountWorkspaceEntity } from 'src/modules/connected-account/standard-objects/connected-account.workspace-entity';\n\ninterface ValidateAndRefreshConnectedAccountAuthenticationParams {\n  connectedAccount: ConnectedAccountWorkspaceEntity;\n  workspaceId: string;\n  calendarChannelId: string;\n}\n\n@Injectable()\nexport class CalendarAccountAuthenticationService {\n  constructor(\n    private readonly connectedAccountRefreshTokensService: ConnectedAccountRefreshTokensService,\n  ) {}\n\n  async validateAndRefreshConnectedAccountAuthentication({\n    connectedAccount,\n    workspaceId,\n    calendarChannelId: messageChannelId,\n  }: ValidateAndRefreshConnectedAccountAuthenticationParams): Promise<ConnectedAccountTokens> {\n    if (\n      connectedAccount.provider === ConnectedAccountProvider.IMAP_SMTP_CALDAV &&\n      isDefined(connectedAccount.connectionParameters?.SMTP)\n    ) {\n      await this.validateCalDavCredentialsForConnectedAccount({\n        connectedAccount,\n        workspaceId,\n        calendarChannelId: messageChannelId,\n      });\n\n      return {\n        accessToken: '',\n        refreshToken: '',\n      };\n    }\n\n    return await this.refreshAccessTokenForOAuthProvider({\n      connectedAccount,\n      workspaceId,\n      calendarChannelId: messageChannelId,\n    });\n  }\n\n  private async validateCalDavCredentialsForConnectedAccount({\n    connectedAccount,\n  }: ValidateAndRefreshConnectedAccountAuthenticationParams): Promise<void> {\n    if (\n      !isDefined(connectedAccount.connectionParameters) ||\n      !isDefined(connectedAccount.connectionParameters?.CALDAV)\n    ) {\n      throw {\n        code: CalendarEventImportDriverExceptionCode.INSUFFICIENT_PERMISSIONS,\n        message: 'Missing CALDAV credentials in connectionParameters',\n      };\n    }\n  }\n\n  private async refreshAccessTokenForOAuthProvider({\n    connectedAccount,\n    workspaceId,\n  }: ValidateAndRefreshConnectedAccountAuthenticationParams): Promise<ConnectedAccountTokens> {\n    try {\n      return await this.connectedAccountRefreshTokensService.refreshAndSaveTokens(\n        connectedAccount,\n        workspaceId,\n      );\n    } catch (error) {\n      switch (error.code) {\n        case ConnectedAccountRefreshAccessTokenExceptionCode.TEMPORARY_NETWORK_ERROR:\n          throw new CalendarEventImportDriverException(\n            error.message,\n            CalendarEventImportDriverExceptionCode.TEMPORARY_ERROR,\n          );\n        case ConnectedAccountRefreshAccessTokenExceptionCode.REFRESH_TOKEN_NOT_FOUND:\n        case ConnectedAccountRefreshAccessTokenExceptionCode.INVALID_REFRESH_TOKEN:\n          throw new CalendarEventImportDriverException(\n            error.message,\n            CalendarEventImportDriverExceptionCode.INSUFFICIENT_PERMISSIONS,\n          );\n        default:\n          throw error;\n      }\n    }\n  }\n}",
            "output_extracted": "import { Injectable } from '@nestjs/common';\n\nimport { isDefined } from 'class-validator';\nimport { ConnectedAccountProvider } from 'twenty-shared/types';\n\nimport {\n  CalendarEventImportDriverException,\n  CalendarEventImportDriverExceptionCode,\n} from 'src/modules/calendar/calendar-event-import-manager/drivers/exceptions/calendar-event-import-driver.exception';\nimport { ConnectedAccountRefreshAccessTokenExceptionCode } from 'src/modules/connected-account/refresh-tokens-manager/exceptions/connected-account-refresh-tokens.exception';\nimport {\n  ConnectedAccountRefreshTokensService,\n  type ConnectedAccountTokens,\n} from 'src/modules/connected-account/refresh-tokens-manager/services/connected-account-refresh-tokens.service';\nimport { type ConnectedAccountWorkspaceEntity } from 'src/modules/connected-account/standard-objects/connected-account.workspace-entity';\n\ninterface ValidateAndRefreshConnectedAccountAuthenticationParams {\n  connectedAccount: ConnectedAccountWorkspaceEntity;\n  workspaceId: string;\n  calendarChannelId: string;\n}\n\n@Injectable()\nexport class CalendarAccountAuthenticationService {\n  constructor(\n    private readonly connectedAccountRefreshTokensService: ConnectedAccountRefreshTokensService,\n  ) {}\n\n  async validateAndRefreshConnectedAccountAuthentication({\n    connectedAccount,\n    workspaceId,\n    calendarChannelId: messageChannelId,\n  }: ValidateAndRefreshConnectedAccountAuthenticationParams): Promise<ConnectedAccountTokens> {\n    if (\n      connectedAccount.provider === ConnectedAccountProvider.IMAP_SMTP_CALDAV &&\n      isDefined(connectedAccount.connectionParameters?.SMTP)\n    ) {\n      await this.validateCalDavCredentialsForConnectedAccount({\n        connectedAccount,\n        workspaceId,\n        calendarChannelId: messageChannelId,\n      });\n\n      return {\n        accessToken: '',\n        refreshToken: '',\n      };\n    }\n\n    return await this.refreshAccessTokenForOAuthProvider({\n      connectedAccount,\n      workspaceId,\n      calendarChannelId: messageChannelId,\n    });\n  }\n\n  private async validateCalDavCredentialsForConnectedAccount({\n    connectedAccount,\n  }: ValidateAndRefreshConnectedAccountAuthenticationParams): Promise<void> {\n    if (\n      !isDefined(connectedAccount.connectionParameters) ||\n      !isDefined(connectedAccount.connectionParameters?.CALDAV)\n    ) {\n      throw {\n        code: CalendarEventImportDriverExceptionCode.INSUFFICIENT_PERMISSIONS,\n        message: 'Missing CALDAV credentials in connectionParameters',\n      };\n    }\n  }\n\n  private async refreshAccessTokenForOAuthProvider({\n    connectedAccount,\n    workspaceId,\n  }: ValidateAndRefreshConnectedAccountAuthenticationParams): Promise<ConnectedAccountTokens> {\n    try {\n      return await this.connectedAccountRefreshTokensService.refreshAndSaveTokens(\n        connectedAccount,\n        workspaceId,\n      );\n    } catch (error) {\n      switch (error.code) {\n        case ConnectedAccountRefreshAccessTokenExceptionCode.TEMPORARY_NETWORK_ERROR:\n          throw new CalendarEventImportDriverException(\n            error.message,\n            CalendarEventImportDriverExceptionCode.TEMPORARY_ERROR,\n          );\n        case ConnectedAccountRefreshAccessTokenExceptionCode.REFRESH_TOKEN_NOT_FOUND:\n        case ConnectedAccountRefreshAccessTokenExceptionCode.INVALID_REFRESH_TOKEN:\n          throw new CalendarEventImportDriverException(\n            error.message,\n            CalendarEventImportDriverExceptionCode.INSUFFICIENT_PERMISSIONS,\n          );\n        default:\n          throw error;\n      }\n    }\n  }\n}",
            "cost": 0.03377
        },
        "twentyhq__twenty.main/packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.spec.ts": {
            "output": "import { Test, type TestingModule } from '@nestjs/testing';\n\nimport { ConnectedAccountProvider } from 'twenty-shared/types';\n\nimport { type EmailAccountConnectionParameters } from 'src/engine/core-modules/imap-smtp-caldav-connection/dtos/imap-smtp-caldav-connection.dto';\nimport { MessageQueue } from 'src/engine/core-modules/message-queue/message-queue.constants';\nimport { getQueueToken } from 'src/engine/core-modules/message-queue/utils/get-queue-token.util';\nimport { TwentyORMGlobalManager } from 'src/engine/twenty-orm/twenty-orm-global.manager';\nimport { type CalendarChannelWorkspaceEntity } from 'src/modules/calendar/common/standard-objects/calendar-channel.workspace-entity';\nimport { ImapSmtpCalDavAPIService } from 'src/modules/connected-account/services/imap-smtp-caldav-apis.service';\nimport { type ConnectedAccountWorkspaceEntity } from 'src/modules/connected-account/standard-objects/connected-account.workspace-entity';\nimport {\n  MessageChannelPendingGroupEmailsAction,\n  MessageChannelSyncStage,\n  MessageChannelSyncStatus,\n  MessageChannelType,\n  type MessageChannelWorkspaceEntity,\n} from 'src/modules/messaging/common/standard-objects/message-channel.workspace-entity';\n\njest.mock('uuid', () => ({\n  v4: jest.fn(() => 'mocked-uuid'),\n}));\n\ndescribe('ImapSmtpCalDavAPIService', () => {\n  let service: ImapSmtpCalDavAPIService;\n\n  const mockConnectedAccountRepository = {\n    findOne: jest.fn(),\n    save: jest.fn(),\n  };\n\n  const mockMessageChannelRepository = {\n    findOne: jest.fn(),\n    save: jest.fn(),\n  };\n\n  const mockCalendarChannelRepository = {\n    findOne: jest.fn(),\n    save: jest.fn(),\n  };\n\n  const mockWorkspaceDataSource = {\n    transaction: jest.fn((callback) => callback({})),\n  };\n\n  const mockMessageQueueService = {\n    add: jest.fn(),\n  };\n\n  const mockCalendarQueueService = {\n    add: jest.fn(),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        ImapSmtpCalDavAPIService,\n        {\n          provide: TwentyORMGlobalManager,\n          useValue: {\n            getRepositoryForWorkspace: jest\n              .fn()\n              .mockImplementation((_workspaceId, entity) => {\n                if (entity === 'connectedAccount')\n                  return mockConnectedAccountRepository;\n                if (entity === 'messageChannel')\n                  return mockMessageChannelRepository;\n                if (entity === 'calendarChannel')\n                  return mockCalendarChannelRepository;\n\n                return {};\n              }),\n            getDataSourceForWorkspace: jest\n              .fn()\n              .mockImplementation(() => mockWorkspaceDataSource),\n          },\n        },\n        {\n          provide: getQueueToken(MessageQueue.messagingQueue),\n          useValue: mockMessageQueueService,\n        },\n        {\n          provide: getQueueToken(MessageQueue.calendarQueue),\n          useValue: mockCalendarQueueService,\n        },\n      ],\n    }).compile();\n\n    service = module.get<ImapSmtpCalDavAPIService>(ImapSmtpCalDavAPIService);\n\n    jest.clearAllMocks();\n  });\n\n  describe('processAccount', () => {\n    const baseInput = {\n      handle: 'test@example.com',\n      workspaceMemberId: 'workspace-member-id',\n      workspaceId: 'workspace-id',\n      connectionParameters: {\n        IMAP: {\n          host: 'imap.example.com',\n          port: 993,\n          secure: true,\n          password: 'password',\n        },\n        SMTP: {\n          host: 'smtp.example.com',\n          port: 587,\n          secure: true,\n          username: 'test@example.com',\n          password: 'password',\n        },\n      } as EmailAccountConnectionParameters,\n    };\n\n    it('should create new account with message and calendar channels when account does not exist', async () => {\n      mockConnectedAccountRepository.findOne.mockResolvedValue(null);\n      mockMessageChannelRepository.findOne.mockResolvedValue(null);\n      mockCalendarChannelRepository.findOne.mockResolvedValue(null);\n\n      const expectedMessageChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n        type: MessageChannelType.EMAIL,\n        handle: 'test@example.com',\n        isSyncEnabled: true,\n        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n        pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n        syncCursor: '',\n        syncStageStartedAt: null,\n      };\n\n      mockMessageChannelRepository.save.mockResolvedValue(\n        expectedMessageChannel,\n      );\n\n      await service.processAccount(baseInput);\n\n      expect(mockConnectedAccountRepository.save).toHaveBeenCalledWith(\n        {\n          id: 'mocked-uuid',\n          handle: 'test@example.com',\n          provider: ConnectedAccountProvider.IMAP_SMTP_CALDAV,\n          connectionParameters: baseInput.connectionParameters,\n          accountOwnerId: 'workspace-member-id',\n        },\n        {},\n      );\n\n      expect(mockMessageChannelRepository.save).toHaveBeenCalledWith(\n        {\n          id: 'mocked-uuid',\n          connectedAccountId: 'mocked-uuid',\n          type: MessageChannelType.EMAIL,\n          handle: 'test@example.com',\n          isSyncEnabled: true,\n          syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n          syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n          pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n          syncCursor: '',\n          syncStageStartedAt: null,\n        },\n        {},\n      );\n\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n    });\n\n    it('should preserve existing channels when updating account credentials', async () => {\n      const existingAccount = {\n        id: 'existing-account-id',\n        handle: 'test@example.com',\n        accountOwnerId: 'workspace-member-id',\n        provider: ConnectedAccountProvider.IMAP_SMTP_CALDAV,\n      } as ConnectedAccountWorkspaceEntity;\n\n      const existingMessageChannel = {\n        id: 'existing-message-channel-id',\n        connectedAccountId: 'existing-account-id',\n        type: MessageChannelType.EMAIL,\n        handle: 'test@example.com',\n        isSyncEnabled: true,\n        syncStatus: MessageChannelSyncStatus.ONGOING,\n      } as MessageChannelWorkspaceEntity;\n\n      const existingCalendarChannel = {\n        id: 'existing-calendar-channel-id',\n        connectedAccountId: 'existing-account-id',\n      } as CalendarChannelWorkspaceEntity;\n\n      mockConnectedAccountRepository.findOne.mockResolvedValue(existingAccount);\n      mockMessageChannelRepository.findOne.mockResolvedValue(\n        existingMessageChannel,\n      );\n      mockCalendarChannelRepository.findOne.mockResolvedValue(\n        existingCalendarChannel,\n      );\n\n      const inputWithConnectedAccountId = {\n        ...baseInput,\n        connectedAccountId: 'existing-account-id',\n      };\n\n      await service.processAccount(inputWithConnectedAccountId);\n\n      expect(mockConnectedAccountRepository.save).toHaveBeenCalledWith(\n        {\n          id: 'existing-account-id',\n          handle: 'test@example.com',\n          provider: ConnectedAccountProvider.IMAP_SMTP_CALDAV,\n          connectionParameters: baseInput.connectionParameters,\n          accountOwnerId: 'workspace-member-id',\n        },\n        {},\n      );\n\n      expect(mockMessageChannelRepository.save).not.toHaveBeenCalled();\n      expect(mockCalendarChannelRepository.save).not.toHaveBeenCalled();\n\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n    });\n\n    it('should only create message channel when only IMAP is configured', async () => {\n      const imapOnlyInput = {\n        ...baseInput,\n        connectionParameters: {\n          IMAP: {\n            host: 'imap.example.com',\n            port: 993,\n            secure: true,\n            password: 'password',\n          },\n        } as EmailAccountConnectionParameters,\n      };\n\n      mockConnectedAccountRepository.findOne.mockResolvedValue(null);\n      mockMessageChannelRepository.findOne.mockResolvedValue(null);\n      mockCalendarChannelRepository.findOne.mockResolvedValue(null);\n\n      const expectedMessageChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n        type: MessageChannelType.EMAIL,\n        handle: 'test@example.com',\n        isSyncEnabled: true,\n        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n      };\n\n      mockMessageChannelRepository.save.mockResolvedValue(\n        expectedMessageChannel,\n      );\n\n      await service.processAccount(imapOnlyInput);\n\n      expect(mockMessageChannelRepository.save).toHaveBeenCalled();\n      expect(mockCalendarChannelRepository.save).not.toHaveBeenCalled();\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n\n      expect(mockCalendarQueueService.add).not.toHaveBeenCalled();\n    });\n\n    it('should create both channels when only CALDAV is configured but disable message sync', async () => {\n      const caldavOnlyInput = {\n        ...baseInput,\n        connectionParameters: {\n          CALDAV: {\n            host: 'caldav.example.com',\n            port: 443,\n            secure: true,\n            username: 'test@example.com',\n            password: 'password',\n          },\n        } as EmailAccountConnectionParameters,\n      };\n\n      mockConnectedAccountRepository.findOne.mockResolvedValue(null);\n      mockMessageChannelRepository.findOne.mockResolvedValue(null);\n      mockCalendarChannelRepository.findOne.mockResolvedValue(null);\n\n      const expectedCalendarChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n\n        handle: 'test@example.com',\n      };\n\n      mockCalendarChannelRepository.save.mockResolvedValue(\n        expectedCalendarChannel,\n      );\n\n      await service.processAccount(caldavOnlyInput);\n\n      expect(mockMessageChannelRepository.save).toHaveBeenCalledWith(\n        {\n          id: 'mocked-uuid',\n          connectedAccountId: 'mocked-uuid',\n          type: MessageChannelType.EMAIL,\n          handle: 'test@example.com',\n          isSyncEnabled: false,\n          syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n          syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n          pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n          syncCursor: '',\n          syncStageStartedAt: null,\n        },\n        {},\n      );\n      expect(mockCalendarChannelRepository.save).toHaveBeenCalled();\n\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n      expect(mockCalendarQueueService.add).not.toHaveBeenCalled();\n    });\n\n    it('should handle IMAP + SMTP configuration without CALDAV', async () => {\n      const imapSmtpInput = {\n        ...baseInput,\n        connectionParameters: {\n          IMAP: {\n            host: 'imap.example.com',\n            port: 993,\n            secure: true,\n            password: 'password',\n          },\n          SMTP: {\n            host: 'smtp.example.com',\n            port: 587,\n            secure: true,\n            username: 'test@example.com',\n            password: 'password',\n          },\n        } as EmailAccountConnectionParameters,\n      };\n\n      mockConnectedAccountRepository.findOne.mockResolvedValue(null);\n      mockMessageChannelRepository.findOne.mockResolvedValue(null);\n      mockCalendarChannelRepository.findOne.mockResolvedValue(null);\n\n      const expectedMessageChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n        type: MessageChannelType.EMAIL,\n        handle: 'test@example.com',\n        isSyncEnabled: true,\n        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n      };\n\n      mockMessageChannelRepository.save.mockResolvedValue(\n        expectedMessageChannel,\n      );\n\n      await service.processAccount(imapSmtpInput);\n\n      expect(mockMessageChannelRepository.save).toHaveBeenCalled();\n      expect(mockCalendarChannelRepository.save).not.toHaveBeenCalled();\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n      expect(mockCalendarQueueService.add).not.toHaveBeenCalled();\n    });\n\n    it('should handle full IMAP + SMTP + CALDAV configuration', async () => {\n      const fullConfigInput = {\n        ...baseInput,\n        connectionParameters: {\n          IMAP: {\n            host: 'imap.example.com',\n            port: 993,\n            secure: true,\n            password: 'password',\n          },\n          SMTP: {\n            host: 'smtp.example.com',\n            port: 587,\n            secure: true,\n            username: 'test@example.com',\n            password: 'password',\n          },\n          CALDAV: {\n            host: 'caldav.example.com',\n            port: 443,\n            secure: true,\n            username: 'test@example.com',\n            password: 'password',\n          },\n        } as EmailAccountConnectionParameters,\n      };\n\n      mockConnectedAccountRepository.findOne.mockResolvedValue(null);\n      mockMessageChannelRepository.findOne.mockResolvedValue(null);\n      mockCalendarChannelRepository.findOne.mockResolvedValue(null);\n\n      const expectedMessageChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n        type: MessageChannelType.EMAIL,\n        handle: 'test@example.com',\n        isSyncEnabled: true,\n        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n      };\n\n      const expectedCalendarChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n        handle: 'test@example.com',\n      };\n\n      mockMessageChannelRepository.save.mockResolvedValue(\n        expectedMessageChannel,\n      );\n      mockCalendarChannelRepository.save.mockResolvedValue(\n        expectedCalendarChannel,\n      );\n\n      await service.processAccount(fullConfigInput);\n\n      expect(mockMessageChannelRepository.save).toHaveBeenCalled();\n      expect(mockCalendarChannelRepository.save).toHaveBeenCalled();\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n      expect(mockCalendarQueueService.add).not.",
            "output_extracted": "import { Test, type TestingModule } from '@nestjs/testing';\n\nimport { ConnectedAccountProvider } from 'twenty-shared/types';\n\nimport { type EmailAccountConnectionParameters } from 'src/engine/core-modules/imap-smtp-caldav-connection/dtos/imap-smtp-caldav-connection.dto';\nimport { MessageQueue } from 'src/engine/core-modules/message-queue/message-queue.constants';\nimport { getQueueToken } from 'src/engine/core-modules/message-queue/utils/get-queue-token.util';\nimport { TwentyORMGlobalManager } from 'src/engine/twenty-orm/twenty-orm-global.manager';\nimport { type CalendarChannelWorkspaceEntity } from 'src/modules/calendar/common/standard-objects/calendar-channel.workspace-entity';\nimport { ImapSmtpCalDavAPIService } from 'src/modules/connected-account/services/imap-smtp-caldav-apis.service';\nimport { type ConnectedAccountWorkspaceEntity } from 'src/modules/connected-account/standard-objects/connected-account.workspace-entity';\nimport {\n  MessageChannelPendingGroupEmailsAction,\n  MessageChannelSyncStage,\n  MessageChannelSyncStatus,\n  MessageChannelType,\n  type MessageChannelWorkspaceEntity,\n} from 'src/modules/messaging/common/standard-objects/message-channel.workspace-entity';\n\njest.mock('uuid', () => ({\n  v4: jest.fn(() => 'mocked-uuid'),\n}));\n\ndescribe('ImapSmtpCalDavAPIService', () => {\n  let service: ImapSmtpCalDavAPIService;\n\n  const mockConnectedAccountRepository = {\n    findOne: jest.fn(),\n    save: jest.fn(),\n  };\n\n  const mockMessageChannelRepository = {\n    findOne: jest.fn(),\n    save: jest.fn(),\n  };\n\n  const mockCalendarChannelRepository = {\n    findOne: jest.fn(),\n    save: jest.fn(),\n  };\n\n  const mockWorkspaceDataSource = {\n    transaction: jest.fn((callback) => callback({})),\n  };\n\n  const mockMessageQueueService = {\n    add: jest.fn(),\n  };\n\n  const mockCalendarQueueService = {\n    add: jest.fn(),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        ImapSmtpCalDavAPIService,\n        {\n          provide: TwentyORMGlobalManager,\n          useValue: {\n            getRepositoryForWorkspace: jest\n              .fn()\n              .mockImplementation((_workspaceId, entity) => {\n                if (entity === 'connectedAccount')\n                  return mockConnectedAccountRepository;\n                if (entity === 'messageChannel')\n                  return mockMessageChannelRepository;\n                if (entity === 'calendarChannel')\n                  return mockCalendarChannelRepository;\n\n                return {};\n              }),\n            getDataSourceForWorkspace: jest\n              .fn()\n              .mockImplementation(() => mockWorkspaceDataSource),\n          },\n        },\n        {\n          provide: getQueueToken(MessageQueue.messagingQueue),\n          useValue: mockMessageQueueService,\n        },\n        {\n          provide: getQueueToken(MessageQueue.calendarQueue),\n          useValue: mockCalendarQueueService,\n        },\n      ],\n    }).compile();\n\n    service = module.get<ImapSmtpCalDavAPIService>(ImapSmtpCalDavAPIService);\n\n    jest.clearAllMocks();\n  });\n\n  describe('processAccount', () => {\n    const baseInput = {\n      handle: 'test@example.com',\n      workspaceMemberId: 'workspace-member-id',\n      workspaceId: 'workspace-id',\n      connectionParameters: {\n        IMAP: {\n          host: 'imap.example.com',\n          port: 993,\n          secure: true,\n          password: 'password',\n        },\n        SMTP: {\n          host: 'smtp.example.com',\n          port: 587,\n          secure: true,\n          username: 'test@example.com',\n          password: 'password',\n        },\n      } as EmailAccountConnectionParameters,\n    };\n\n    it('should create new account with message and calendar channels when account does not exist', async () => {\n      mockConnectedAccountRepository.findOne.mockResolvedValue(null);\n      mockMessageChannelRepository.findOne.mockResolvedValue(null);\n      mockCalendarChannelRepository.findOne.mockResolvedValue(null);\n\n      const expectedMessageChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n        type: MessageChannelType.EMAIL,\n        handle: 'test@example.com',\n        isSyncEnabled: true,\n        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n        pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n        syncCursor: '',\n        syncStageStartedAt: null,\n      };\n\n      mockMessageChannelRepository.save.mockResolvedValue(\n        expectedMessageChannel,\n      );\n\n      await service.processAccount(baseInput);\n\n      expect(mockConnectedAccountRepository.save).toHaveBeenCalledWith(\n        {\n          id: 'mocked-uuid',\n          handle: 'test@example.com',\n          provider: ConnectedAccountProvider.IMAP_SMTP_CALDAV,\n          connectionParameters: baseInput.connectionParameters,\n          accountOwnerId: 'workspace-member-id',\n        },\n        {},\n      );\n\n      expect(mockMessageChannelRepository.save).toHaveBeenCalledWith(\n        {\n          id: 'mocked-uuid',\n          connectedAccountId: 'mocked-uuid',\n          type: MessageChannelType.EMAIL,\n          handle: 'test@example.com',\n          isSyncEnabled: true,\n          syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n          syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n          pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n          syncCursor: '',\n          syncStageStartedAt: null,\n        },\n        {},\n      );\n\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n    });\n\n    it('should preserve existing channels when updating account credentials', async () => {\n      const existingAccount = {\n        id: 'existing-account-id',\n        handle: 'test@example.com',\n        accountOwnerId: 'workspace-member-id',\n        provider: ConnectedAccountProvider.IMAP_SMTP_CALDAV,\n      } as ConnectedAccountWorkspaceEntity;\n\n      const existingMessageChannel = {\n        id: 'existing-message-channel-id',\n        connectedAccountId: 'existing-account-id',\n        type: MessageChannelType.EMAIL,\n        handle: 'test@example.com',\n        isSyncEnabled: true,\n        syncStatus: MessageChannelSyncStatus.ONGOING,\n      } as MessageChannelWorkspaceEntity;\n\n      const existingCalendarChannel = {\n        id: 'existing-calendar-channel-id',\n        connectedAccountId: 'existing-account-id',\n      } as CalendarChannelWorkspaceEntity;\n\n      mockConnectedAccountRepository.findOne.mockResolvedValue(existingAccount);\n      mockMessageChannelRepository.findOne.mockResolvedValue(\n        existingMessageChannel,\n      );\n      mockCalendarChannelRepository.findOne.mockResolvedValue(\n        existingCalendarChannel,\n      );\n\n      const inputWithConnectedAccountId = {\n        ...baseInput,\n        connectedAccountId: 'existing-account-id',\n      };\n\n      await service.processAccount(inputWithConnectedAccountId);\n\n      expect(mockConnectedAccountRepository.save).toHaveBeenCalledWith(\n        {\n          id: 'existing-account-id',\n          handle: 'test@example.com',\n          provider: ConnectedAccountProvider.IMAP_SMTP_CALDAV,\n          connectionParameters: baseInput.connectionParameters,\n          accountOwnerId: 'workspace-member-id',\n        },\n        {},\n      );\n\n      expect(mockMessageChannelRepository.save).not.toHaveBeenCalled();\n      expect(mockCalendarChannelRepository.save).not.toHaveBeenCalled();\n\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n    });\n\n    it('should only create message channel when only IMAP is configured', async () => {\n      const imapOnlyInput = {\n        ...baseInput,\n        connectionParameters: {\n          IMAP: {\n            host: 'imap.example.com',\n            port: 993,\n            secure: true,\n            password: 'password',\n          },\n        } as EmailAccountConnectionParameters,\n      };\n\n      mockConnectedAccountRepository.findOne.mockResolvedValue(null);\n      mockMessageChannelRepository.findOne.mockResolvedValue(null);\n      mockCalendarChannelRepository.findOne.mockResolvedValue(null);\n\n      const expectedMessageChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n        type: MessageChannelType.EMAIL,\n        handle: 'test@example.com',\n        isSyncEnabled: true,\n        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n      };\n\n      mockMessageChannelRepository.save.mockResolvedValue(\n        expectedMessageChannel,\n      );\n\n      await service.processAccount(imapOnlyInput);\n\n      expect(mockMessageChannelRepository.save).toHaveBeenCalled();\n      expect(mockCalendarChannelRepository.save).not.toHaveBeenCalled();\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n\n      expect(mockCalendarQueueService.add).not.toHaveBeenCalled();\n    });\n\n    it('should create both channels when only CALDAV is configured but disable message sync', async () => {\n      const caldavOnlyInput = {\n        ...baseInput,\n        connectionParameters: {\n          CALDAV: {\n            host: 'caldav.example.com',\n            port: 443,\n            secure: true,\n            username: 'test@example.com',\n            password: 'password',\n          },\n        } as EmailAccountConnectionParameters,\n      };\n\n      mockConnectedAccountRepository.findOne.mockResolvedValue(null);\n      mockMessageChannelRepository.findOne.mockResolvedValue(null);\n      mockCalendarChannelRepository.findOne.mockResolvedValue(null);\n\n      const expectedCalendarChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n\n        handle: 'test@example.com',\n      };\n\n      mockCalendarChannelRepository.save.mockResolvedValue(\n        expectedCalendarChannel,\n      );\n\n      await service.processAccount(caldavOnlyInput);\n\n      expect(mockMessageChannelRepository.save).toHaveBeenCalledWith(\n        {\n          id: 'mocked-uuid',\n          connectedAccountId: 'mocked-uuid',\n          type: MessageChannelType.EMAIL,\n          handle: 'test@example.com',\n          isSyncEnabled: false,\n          syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n          syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n          pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n          syncCursor: '',\n          syncStageStartedAt: null,\n        },\n        {},\n      );\n      expect(mockCalendarChannelRepository.save).toHaveBeenCalled();\n\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n      expect(mockCalendarQueueService.add).not.toHaveBeenCalled();\n    });\n\n    it('should handle IMAP + SMTP configuration without CALDAV', async () => {\n      const imapSmtpInput = {\n        ...baseInput,\n        connectionParameters: {\n          IMAP: {\n            host: 'imap.example.com',\n            port: 993,\n            secure: true,\n            password: 'password',\n          },\n          SMTP: {\n            host: 'smtp.example.com',\n            port: 587,\n            secure: true,\n            username: 'test@example.com',\n            password: 'password',\n          },\n        } as EmailAccountConnectionParameters,\n      };\n\n      mockConnectedAccountRepository.findOne.mockResolvedValue(null);\n      mockMessageChannelRepository.findOne.mockResolvedValue(null);\n      mockCalendarChannelRepository.findOne.mockResolvedValue(null);\n\n      const expectedMessageChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n        type: MessageChannelType.EMAIL,\n        handle: 'test@example.com',\n        isSyncEnabled: true,\n        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n      };\n\n      mockMessageChannelRepository.save.mockResolvedValue(\n        expectedMessageChannel,\n      );\n\n      await service.processAccount(imapSmtpInput);\n\n      expect(mockMessageChannelRepository.save).toHaveBeenCalled();\n      expect(mockCalendarChannelRepository.save).not.toHaveBeenCalled();\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n      expect(mockCalendarQueueService.add).not.toHaveBeenCalled();\n    });\n\n    it('should handle full IMAP + SMTP + CALDAV configuration', async () => {\n      const fullConfigInput = {\n        ...baseInput,\n        connectionParameters: {\n          IMAP: {\n            host: 'imap.example.com',\n            port: 993,\n            secure: true,\n            password: 'password',\n          },\n          SMTP: {\n            host: 'smtp.example.com',\n            port: 587,\n            secure: true,\n            username: 'test@example.com',\n            password: 'password',\n          },\n          CALDAV: {\n            host: 'caldav.example.com',\n            port: 443,\n            secure: true,\n            username: 'test@example.com',\n            password: 'password',\n          },\n        } as EmailAccountConnectionParameters,\n      };\n\n      mockConnectedAccountRepository.findOne.mockResolvedValue(null);\n      mockMessageChannelRepository.findOne.mockResolvedValue(null);\n      mockCalendarChannelRepository.findOne.mockResolvedValue(null);\n\n      const expectedMessageChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n        type: MessageChannelType.EMAIL,\n        handle: 'test@example.com',\n        isSyncEnabled: true,\n        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n      };\n\n      const expectedCalendarChannel = {\n        id: 'mocked-uuid',\n        connectedAccountId: 'mocked-uuid',\n        handle: 'test@example.com',\n      };\n\n      mockMessageChannelRepository.save.mockResolvedValue(\n        expectedMessageChannel,\n      );\n      mockCalendarChannelRepository.save.mockResolvedValue(\n        expectedCalendarChannel,\n      );\n\n      await service.processAccount(fullConfigInput);\n\n      expect(mockMessageChannelRepository.save).toHaveBeenCalled();\n      expect(mockCalendarChannelRepository.save).toHaveBeenCalled();\n      expect(mockMessageQueueService.add).not.toHaveBeenCalled();\n      expect(mockCalendarQueueService.add).not.",
            "cost": 0.13286
        },
        "twentyhq__twenty.main/packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.ts": {
            "output": "import { Injectable } from '@nestjs/common';\n\nimport { ConnectedAccountProvider } from 'twenty-shared/types';\nimport { v4 } from 'uuid';\n\nimport { type EmailAccountConnectionParameters } from 'src/engine/core-modules/imap-smtp-caldav-connection/dtos/imap-smtp-caldav-connection.dto';\nimport { type WorkspaceRepository } from 'src/engine/twenty-orm/repository/workspace.repository';\nimport { TwentyORMGlobalManager } from 'src/engine/twenty-orm/twenty-orm-global.manager';\nimport {\n  CalendarChannelSyncStage,\n  CalendarChannelSyncStatus,\n  type CalendarChannelWorkspaceEntity,\n} from 'src/modules/calendar/common/standard-objects/calendar-channel.workspace-entity';\nimport { type ConnectedAccountWorkspaceEntity } from 'src/modules/connected-account/standard-objects/connected-account.workspace-entity';\nimport {\n  MessageChannelPendingGroupEmailsAction,\n  MessageChannelSyncStage,\n  MessageChannelSyncStatus,\n  MessageChannelType,\n  type MessageChannelWorkspaceEntity,\n} from 'src/modules/messaging/common/standard-objects/message-channel.workspace-entity';\n\n@Injectable()\nexport class ImapSmtpCalDavAPIService {\n  constructor(\n    private readonly twentyORMGlobalManager: TwentyORMGlobalManager,\n  ) {}\n\n  async processAccount(input: {\n    handle: string;\n    workspaceMemberId: string;\n    workspaceId: string;\n    connectionParameters: EmailAccountConnectionParameters;\n    connectedAccountId?: string;\n  }): Promise<string> {\n    const { handle, workspaceId, workspaceMemberId, connectedAccountId } =\n      input;\n\n    const connectedAccountRepository =\n      await this.twentyORMGlobalManager.getRepositoryForWorkspace<ConnectedAccountWorkspaceEntity>(\n        workspaceId,\n        'connectedAccount',\n      );\n\n    const messageChannelRepository =\n      await this.twentyORMGlobalManager.getRepositoryForWorkspace<MessageChannelWorkspaceEntity>(\n        workspaceId,\n        'messageChannel',\n      );\n\n    const calendarChannelRepository =\n      await this.twentyORMGlobalManager.getRepositoryForWorkspace<CalendarChannelWorkspaceEntity>(\n        workspaceId,\n        'calendarChannel',\n      );\n\n    const existingAccount = connectedAccountId\n      ? await connectedAccountRepository.findOne({\n          where: { id: connectedAccountId },\n        })\n      : await connectedAccountRepository.findOne({\n          where: { handle, accountOwnerId: workspaceMemberId },\n        });\n\n    const accountId = existingAccount?.id ?? connectedAccountId ?? v4();\n\n    const workspaceDataSource =\n      await this.twentyORMGlobalManager.getDataSourceForWorkspace({\n        workspaceId,\n      });\n\n    let messageChannel: MessageChannelWorkspaceEntity | null = existingAccount\n      ? await messageChannelRepository.findOne({\n          where: { connectedAccountId: existingAccount.id },\n        })\n      : null;\n\n    let calendarChannel: CalendarChannelWorkspaceEntity | null = existingAccount\n      ? await calendarChannelRepository.findOne({\n          where: { connectedAccountId: existingAccount.id },\n        })\n      : null;\n\n    await workspaceDataSource.transaction(async () => {\n      await this.upsertConnectedAccount(\n        input,\n        accountId,\n        connectedAccountRepository,\n      );\n\n      if (!messageChannel) {\n        messageChannel = await this.setupMessageChannels(\n          input,\n          accountId,\n          messageChannelRepository,\n        );\n      }\n\n      if (!calendarChannel) {\n        calendarChannel = await this.setupCalendarChannels(\n          input,\n          accountId,\n          calendarChannelRepository,\n        );\n      }\n    });\n\n    return accountId;\n  }\n\n  private async upsertConnectedAccount(\n    input: {\n      handle: string;\n      workspaceMemberId: string;\n      workspaceId: string;\n      connectionParameters: EmailAccountConnectionParameters;\n    },\n    accountId: string,\n    connectedAccountRepository: WorkspaceRepository<ConnectedAccountWorkspaceEntity>,\n  ) {\n    const accountData = {\n      id: accountId,\n      handle: input.handle,\n      provider: ConnectedAccountProvider.IMAP_SMTP_CALDAV,\n      connectionParameters: input.connectionParameters,\n      accountOwnerId: input.workspaceMemberId,\n    };\n\n    await connectedAccountRepository.save(accountData, {});\n  }\n\n  private async setupMessageChannels(\n    input: {\n      handle: string;\n      workspaceId: string;\n      connectionParameters: EmailAccountConnectionParameters;\n    },\n    accountId: string,\n    messageChannelRepository: WorkspaceRepository<MessageChannelWorkspaceEntity>,\n  ): Promise<MessageChannelWorkspaceEntity | null> {\n    const shouldEnableSync = Boolean(input.connectionParameters.IMAP);\n\n    const newMessageChannel = await messageChannelRepository.save(\n      {\n        id: v4(),\n        connectedAccountId: accountId,\n        type: MessageChannelType.EMAIL,\n        handle: input.handle,\n        isSyncEnabled: shouldEnableSync,\n        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n        pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n        syncCursor: '',\n        syncStageStartedAt: null,\n      },\n      {},\n    );\n\n    return shouldEnableSync ? newMessageChannel : null;\n  }\n\n  private async setupCalendarChannels(\n    input: {\n      handle: string;\n      workspaceId: string;\n      connectionParameters: EmailAccountConnectionParameters;\n    },\n    accountId: string,\n    calendarChannelRepository: WorkspaceRepository<CalendarChannelWorkspaceEntity>,\n  ): Promise<CalendarChannelWorkspaceEntity | null> {\n    const shouldCreateCalendarChannel = Boolean(\n      input.connectionParameters.CALDAV,\n    );\n\n    if (shouldCreateCalendarChannel) {\n      const newCalendarChannel = await calendarChannelRepository.save(\n        {\n          id: v4(),\n          connectedAccountId: accountId,\n          handle: input.handle,\n          isSyncEnabled: shouldCreateCalendarChannel,\n          syncStatus: CalendarChannelSyncStatus.NOT_SYNCED,\n          syncStage: CalendarChannelSyncStage.PENDING_CONFIGURATION,\n          syncCursor: '',\n          syncStageStartedAt: null,\n        },\n        {},\n      );\n\n      return newCalendarChannel;\n    }\n\n    return null;\n  }\n}",
            "output_extracted": "import { Injectable } from '@nestjs/common';\n\nimport { ConnectedAccountProvider } from 'twenty-shared/types';\nimport { v4 } from 'uuid';\n\nimport { type EmailAccountConnectionParameters } from 'src/engine/core-modules/imap-smtp-caldav-connection/dtos/imap-smtp-caldav-connection.dto';\nimport { type WorkspaceRepository } from 'src/engine/twenty-orm/repository/workspace.repository';\nimport { TwentyORMGlobalManager } from 'src/engine/twenty-orm/twenty-orm-global.manager';\nimport {\n  CalendarChannelSyncStage,\n  CalendarChannelSyncStatus,\n  type CalendarChannelWorkspaceEntity,\n} from 'src/modules/calendar/common/standard-objects/calendar-channel.workspace-entity';\nimport { type ConnectedAccountWorkspaceEntity } from 'src/modules/connected-account/standard-objects/connected-account.workspace-entity';\nimport {\n  MessageChannelPendingGroupEmailsAction,\n  MessageChannelSyncStage,\n  MessageChannelSyncStatus,\n  MessageChannelType,\n  type MessageChannelWorkspaceEntity,\n} from 'src/modules/messaging/common/standard-objects/message-channel.workspace-entity';\n\n@Injectable()\nexport class ImapSmtpCalDavAPIService {\n  constructor(\n    private readonly twentyORMGlobalManager: TwentyORMGlobalManager,\n  ) {}\n\n  async processAccount(input: {\n    handle: string;\n    workspaceMemberId: string;\n    workspaceId: string;\n    connectionParameters: EmailAccountConnectionParameters;\n    connectedAccountId?: string;\n  }): Promise<string> {\n    const { handle, workspaceId, workspaceMemberId, connectedAccountId } =\n      input;\n\n    const connectedAccountRepository =\n      await this.twentyORMGlobalManager.getRepositoryForWorkspace<ConnectedAccountWorkspaceEntity>(\n        workspaceId,\n        'connectedAccount',\n      );\n\n    const messageChannelRepository =\n      await this.twentyORMGlobalManager.getRepositoryForWorkspace<MessageChannelWorkspaceEntity>(\n        workspaceId,\n        'messageChannel',\n      );\n\n    const calendarChannelRepository =\n      await this.twentyORMGlobalManager.getRepositoryForWorkspace<CalendarChannelWorkspaceEntity>(\n        workspaceId,\n        'calendarChannel',\n      );\n\n    const existingAccount = connectedAccountId\n      ? await connectedAccountRepository.findOne({\n          where: { id: connectedAccountId },\n        })\n      : await connectedAccountRepository.findOne({\n          where: { handle, accountOwnerId: workspaceMemberId },\n        });\n\n    const accountId = existingAccount?.id ?? connectedAccountId ?? v4();\n\n    const workspaceDataSource =\n      await this.twentyORMGlobalManager.getDataSourceForWorkspace({\n        workspaceId,\n      });\n\n    let messageChannel: MessageChannelWorkspaceEntity | null = existingAccount\n      ? await messageChannelRepository.findOne({\n          where: { connectedAccountId: existingAccount.id },\n        })\n      : null;\n\n    let calendarChannel: CalendarChannelWorkspaceEntity | null = existingAccount\n      ? await calendarChannelRepository.findOne({\n          where: { connectedAccountId: existingAccount.id },\n        })\n      : null;\n\n    await workspaceDataSource.transaction(async () => {\n      await this.upsertConnectedAccount(\n        input,\n        accountId,\n        connectedAccountRepository,\n      );\n\n      if (!messageChannel) {\n        messageChannel = await this.setupMessageChannels(\n          input,\n          accountId,\n          messageChannelRepository,\n        );\n      }\n\n      if (!calendarChannel) {\n        calendarChannel = await this.setupCalendarChannels(\n          input,\n          accountId,\n          calendarChannelRepository,\n        );\n      }\n    });\n\n    return accountId;\n  }\n\n  private async upsertConnectedAccount(\n    input: {\n      handle: string;\n      workspaceMemberId: string;\n      workspaceId: string;\n      connectionParameters: EmailAccountConnectionParameters;\n    },\n    accountId: string,\n    connectedAccountRepository: WorkspaceRepository<ConnectedAccountWorkspaceEntity>,\n  ) {\n    const accountData = {\n      id: accountId,\n      handle: input.handle,\n      provider: ConnectedAccountProvider.IMAP_SMTP_CALDAV,\n      connectionParameters: input.connectionParameters,\n      accountOwnerId: input.workspaceMemberId,\n    };\n\n    await connectedAccountRepository.save(accountData, {});\n  }\n\n  private async setupMessageChannels(\n    input: {\n      handle: string;\n      workspaceId: string;\n      connectionParameters: EmailAccountConnectionParameters;\n    },\n    accountId: string,\n    messageChannelRepository: WorkspaceRepository<MessageChannelWorkspaceEntity>,\n  ): Promise<MessageChannelWorkspaceEntity | null> {\n    const shouldEnableSync = Boolean(input.connectionParameters.IMAP);\n\n    const newMessageChannel = await messageChannelRepository.save(\n      {\n        id: v4(),\n        connectedAccountId: accountId,\n        type: MessageChannelType.EMAIL,\n        handle: input.handle,\n        isSyncEnabled: shouldEnableSync,\n        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n        pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n        syncCursor: '',\n        syncStageStartedAt: null,\n      },\n      {},\n    );\n\n    return shouldEnableSync ? newMessageChannel : null;\n  }\n\n  private async setupCalendarChannels(\n    input: {\n      handle: string;\n      workspaceId: string;\n      connectionParameters: EmailAccountConnectionParameters;\n    },\n    accountId: string,\n    calendarChannelRepository: WorkspaceRepository<CalendarChannelWorkspaceEntity>,\n  ): Promise<CalendarChannelWorkspaceEntity | null> {\n    const shouldCreateCalendarChannel = Boolean(\n      input.connectionParameters.CALDAV,\n    );\n\n    if (shouldCreateCalendarChannel) {\n      const newCalendarChannel = await calendarChannelRepository.save(\n        {\n          id: v4(),\n          connectedAccountId: accountId,\n          handle: input.handle,\n          isSyncEnabled: shouldCreateCalendarChannel,\n          syncStatus: CalendarChannelSyncStatus.NOT_SYNCED,\n          syncStage: CalendarChannelSyncStage.PENDING_CONFIGURATION,\n          syncCursor: '',\n          syncStageStartedAt: null,\n        },\n        {},\n      );\n\n      return newCalendarChannel;\n    }\n\n    return null;\n  }\n}",
            "cost": 0.058835
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "twentyhq__twenty.main.16297",
        "repo": "twentyhq/twenty",
        "base_commit": "35319ee13f308d19ee58b79081e405e41aa04956",
        "head_commit": "4970c745e07b05e77e58b0dcffef66d6871107b2",
        "title": "Fix caldav issues",
        "merged_at": "2025-12-04T13:34:21Z",
        "html_url": "https://github.com/twentyhq/twenty/pull/16297",
        "test_files": [
            "packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.spec.ts"
        ],
        "code_files": [
            "packages/twenty-front/src/pages/settings/accounts/SettingsAccountsConfiguration.tsx",
            "packages/twenty-server/src/engine/core-modules/imap-smtp-caldav-connection/services/imap-smtp-caldav-connection.service.ts",
            "packages/twenty-server/src/modules/calendar/calendar-event-import-manager/drivers/caldav/lib/caldav.client.ts",
            "packages/twenty-server/src/modules/calendar/calendar-event-import-manager/services/calendar-account-authentication.service.ts",
            "packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.ts"
        ],
        "total_changes": 118,
        "num_files": 6,
        "pull_number": 16297,
        "patch": "diff --git a/packages/twenty-front/src/pages/settings/accounts/SettingsAccountsConfiguration.tsx b/packages/twenty-front/src/pages/settings/accounts/SettingsAccountsConfiguration.tsx\nindex e2fc73c918cd1..e6126b8702909 100644\n--- a/packages/twenty-front/src/pages/settings/accounts/SettingsAccountsConfiguration.tsx\n+++ b/packages/twenty-front/src/pages/settings/accounts/SettingsAccountsConfiguration.tsx\n@@ -99,31 +99,32 @@ export const SettingsAccountsConfiguration = () => {\n     });\n   };\n \n-  switch (currentStep) {\n-    case SettingsAccountsConfigurationStep.Email:\n-      if (!isDefined(messageChannel)) {\n-        return null;\n-      }\n-      return (\n-        <SettingsAccountsConfigurationStepEmail\n-          messageChannel={messageChannel}\n-          hasNextStep={isDefined(calendarChannel)}\n-          isSubmitting={isSubmitting}\n-          onNext={handleNext}\n-          onAddAccount={handleAddAccount}\n-        />\n-      );\n-    case SettingsAccountsConfigurationStep.Calendar:\n-      if (!isDefined(calendarChannel)) {\n-        return null;\n-      }\n-      return (\n-        <SettingsAccountsConfigurationStepCalendar\n-          calendarChannel={calendarChannel}\n-          messageChannel={messageChannel}\n-          isSubmitting={isSubmitting}\n-          onAddAccount={handleAddAccount}\n-        />\n-      );\n+  const showEmailStep =\n+    currentStep === SettingsAccountsConfigurationStep.Email &&\n+    isDefined(messageChannel);\n+\n+  if (showEmailStep) {\n+    return (\n+      <SettingsAccountsConfigurationStepEmail\n+        messageChannel={messageChannel}\n+        hasNextStep={isDefined(calendarChannel)}\n+        isSubmitting={isSubmitting}\n+        onNext={handleNext}\n+        onAddAccount={handleAddAccount}\n+      />\n+    );\n   }\n+\n+  if (!isDefined(calendarChannel)) {\n+    return null;\n+  }\n+\n+  return (\n+    <SettingsAccountsConfigurationStepCalendar\n+      calendarChannel={calendarChannel}\n+      messageChannel={messageChannel}\n+      isSubmitting={isSubmitting}\n+      onAddAccount={handleAddAccount}\n+    />\n+  );\n };\ndiff --git a/packages/twenty-server/src/engine/core-modules/imap-smtp-caldav-connection/services/imap-smtp-caldav-connection.service.ts b/packages/twenty-server/src/engine/core-modules/imap-smtp-caldav-connection/services/imap-smtp-caldav-connection.service.ts\nindex 05f11b46d0dbd..a71b9d68a8ed7 100644\n--- a/packages/twenty-server/src/engine/core-modules/imap-smtp-caldav-connection/services/imap-smtp-caldav-connection.service.ts\n+++ b/packages/twenty-server/src/engine/core-modules/imap-smtp-caldav-connection/services/imap-smtp-caldav-connection.service.ts\n@@ -139,7 +139,7 @@ export class ImapSmtpCaldavService {\n       }\n \n       throw new UserInputError(`CALDAV connection failed: ${error.message}`, {\n-        userFriendlyMessage: msg`Invalid credentials. Please check your username and password.`,\n+        userFriendlyMessage: msg`Invalid CALDAV credentials. Please check your username and password.`,\n       });\n     }\n \ndiff --git a/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/drivers/caldav/lib/caldav.client.ts b/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/drivers/caldav/lib/caldav.client.ts\nindex 882bf065e6fd0..6299f85743fa2 100644\n--- a/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/drivers/caldav/lib/caldav.client.ts\n+++ b/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/drivers/caldav/lib/caldav.client.ts\n@@ -84,7 +84,7 @@ export class CalDAVClient {\n     if (!this.hasFileExtension(url)) return 'ics';\n     const fileName = url.substring(url.lastIndexOf('/') + 1);\n \n-    return fileName.substring(fileName.lastIndexOf('.') + 1);\n+    return fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n   }\n \n   private isValidFormat(url: string): boolean {\ndiff --git a/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/services/calendar-account-authentication.service.ts b/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/services/calendar-account-authentication.service.ts\nindex 6b058f07d5865..b941469f779f4 100644\n--- a/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/services/calendar-account-authentication.service.ts\n+++ b/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/services/calendar-account-authentication.service.ts\n@@ -33,7 +33,7 @@ export class CalendarAccountAuthenticationService {\n   }: ValidateAndRefreshConnectedAccountAuthenticationParams): Promise<ConnectedAccountTokens> {\n     if (\n       connectedAccount.provider === ConnectedAccountProvider.IMAP_SMTP_CALDAV &&\n-      isDefined(connectedAccount.connectionParameters?.SMTP)\n+      isDefined(connectedAccount.connectionParameters?.CALDAV)\n     ) {\n       await this.validateCalDavCredentialsForConnectedAccount({\n         connectedAccount,\ndiff --git a/packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.spec.ts b/packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.spec.ts\nindex 15ee83933f9b9..f4cdc512412e2 100644\n--- a/packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.spec.ts\n+++ b/packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.spec.ts\n@@ -261,7 +261,7 @@ describe('ImapSmtpCalDavAPIService', () => {\n       expect(mockCalendarQueueService.add).not.toHaveBeenCalled();\n     });\n \n-    it('should create both channels when only CALDAV is configured but disable message sync', async () => {\n+    it('should only create calendar channel when only CALDAV is configured', async () => {\n       const caldavOnlyInput = {\n         ...baseInput,\n         connectionParameters: {\n@@ -282,7 +282,6 @@ describe('ImapSmtpCalDavAPIService', () => {\n       const expectedCalendarChannel = {\n         id: 'mocked-uuid',\n         connectedAccountId: 'mocked-uuid',\n-\n         handle: 'test@example.com',\n       };\n \n@@ -292,21 +291,7 @@ describe('ImapSmtpCalDavAPIService', () => {\n \n       await service.processAccount(caldavOnlyInput);\n \n-      expect(mockMessageChannelRepository.save).toHaveBeenCalledWith(\n-        {\n-          id: 'mocked-uuid',\n-          connectedAccountId: 'mocked-uuid',\n-          type: MessageChannelType.EMAIL,\n-          handle: 'test@example.com',\n-          isSyncEnabled: false,\n-          syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n-          syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n-          pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n-          syncCursor: '',\n-          syncStageStartedAt: null,\n-        },\n-        {},\n-      );\n+      expect(mockMessageChannelRepository.save).not.toHaveBeenCalled();\n       expect(mockCalendarChannelRepository.save).toHaveBeenCalled();\n \n       expect(mockMessageQueueService.add).not.toHaveBeenCalled();\ndiff --git a/packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.ts b/packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.ts\nindex 74640cf84db03..b726bf96b6a96 100644\n--- a/packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.ts\n+++ b/packages/twenty-server/src/modules/connected-account/services/imap-smtp-caldav-apis.service.ts\n@@ -138,25 +138,29 @@ export class ImapSmtpCalDavAPIService {\n     accountId: string,\n     messageChannelRepository: WorkspaceRepository<MessageChannelWorkspaceEntity>,\n   ): Promise<MessageChannelWorkspaceEntity | null> {\n-    const shouldEnableSync = Boolean(input.connectionParameters.IMAP);\n-\n-    const newMessageChannel = await messageChannelRepository.save(\n-      {\n-        id: v4(),\n-        connectedAccountId: accountId,\n-        type: MessageChannelType.EMAIL,\n-        handle: input.handle,\n-        isSyncEnabled: shouldEnableSync,\n-        syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n-        syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n-        pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n-        syncCursor: '',\n-        syncStageStartedAt: null,\n-      },\n-      {},\n-    );\n+    const shouldCreateMessageChannel = Boolean(input.connectionParameters.IMAP);\n+\n+    if (shouldCreateMessageChannel) {\n+      const newMessageChannel = await messageChannelRepository.save(\n+        {\n+          id: v4(),\n+          connectedAccountId: accountId,\n+          type: MessageChannelType.EMAIL,\n+          handle: input.handle,\n+          isSyncEnabled: true,\n+          syncStatus: MessageChannelSyncStatus.NOT_SYNCED,\n+          syncStage: MessageChannelSyncStage.PENDING_CONFIGURATION,\n+          pendingGroupEmailsAction: MessageChannelPendingGroupEmailsAction.NONE,\n+          syncCursor: '',\n+          syncStageStartedAt: null,\n+        },\n+        {},\n+      );\n \n-    return shouldEnableSync ? newMessageChannel : null;\n+      return newMessageChannel;\n+    }\n+\n+    return null;\n   }\n \n   private async setupCalendarChannels(\n",
        "pr_mirror": "twentyhq__twenty.main"
    }
}