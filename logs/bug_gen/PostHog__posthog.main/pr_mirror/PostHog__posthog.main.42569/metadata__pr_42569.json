{
    "cost": 0.28895499999999996,
    "rewrites": {
        "PostHog__posthog.main/frontend/src/lib/components/DateFilter/DateFilter.test.tsx": {
            "output": "import '@testing-library/jest-dom'\nimport { cleanup, render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { Provider } from 'kea'\n\nimport { dateMapping } from 'lib/utils'\n\nimport { initKeaTests } from '~/test/init'\n\nimport { DateFilter } from './DateFilter'\n\ndescribe('DateFilter', () => {\n    let onChange = jest.fn()\n    beforeEach(() => {\n        initKeaTests()\n        onChange = jest.fn()\n        render(\n            <Provider>\n                <DateFilter onChange={onChange} dateOptions={dateMapping} />\n            </Provider>\n        )\n    })\n\n    afterEach(() => {\n        cleanup()\n    })\n\n    it('Can set the date filter and show the right grouping interval', async () => {\n        const dateFilter = screen.getByTestId('date-filter')\n        userEvent.click(dateFilter)\n\n        const yesterdayButton = screen.getByText('Yesterday')\n        userEvent.click(yesterdayButton)\n\n        expect(onChange).toHaveBeenCalledWith('-1dStart', '-1dEnd', false)\n    })\n\n    it('can set a custom rolling date range', async () => {\n        const dateFilter = screen.getByTestId('date-filter')\n        userEvent.click(dateFilter)\n\n        const rollingInput = screen.getByTestId('rolling-date-range-input')\n        userEvent.clear(rollingInput)\n        userEvent.type(rollingInput, '5')\n        userEvent.keyboard('{Enter}')\n\n        const dateOptionsSelector = screen.getByTestId('rolling-date-range-date-options-selector')\n        userEvent.click(dateOptionsSelector)\n\n        const rollingLabel = screen.getByTestId('rolling-date-range-filter')\n        expect(rollingLabel).toHaveTextContent('In the last')\n        userEvent.click(rollingLabel)\n\n        await waitFor(() => expect(onChange).toHaveBeenCalledWith('-5d', '', false))\n    })\n})",
            "output_extracted": "import '@testing-library/jest-dom'\nimport { cleanup, render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { Provider } from 'kea'\n\nimport { dateMapping } from 'lib/utils'\n\nimport { initKeaTests } from '~/test/init'\n\nimport { DateFilter } from './DateFilter'\n\ndescribe('DateFilter', () => {\n    let onChange = jest.fn()\n    beforeEach(() => {\n        initKeaTests()\n        onChange = jest.fn()\n        render(\n            <Provider>\n                <DateFilter onChange={onChange} dateOptions={dateMapping} />\n            </Provider>\n        )\n    })\n\n    afterEach(() => {\n        cleanup()\n    })\n\n    it('Can set the date filter and show the right grouping interval', async () => {\n        const dateFilter = screen.getByTestId('date-filter')\n        userEvent.click(dateFilter)\n\n        const yesterdayButton = screen.getByText('Yesterday')\n        userEvent.click(yesterdayButton)\n\n        expect(onChange).toHaveBeenCalledWith('-1dStart', '-1dEnd', false)\n    })\n\n    it('can set a custom rolling date range', async () => {\n        const dateFilter = screen.getByTestId('date-filter')\n        userEvent.click(dateFilter)\n\n        const rollingInput = screen.getByTestId('rolling-date-range-input')\n        userEvent.clear(rollingInput)\n        userEvent.type(rollingInput, '5')\n        userEvent.keyboard('{Enter}')\n\n        const dateOptionsSelector = screen.getByTestId('rolling-date-range-date-options-selector')\n        userEvent.click(dateOptionsSelector)\n\n        const rollingLabel = screen.getByTestId('rolling-date-range-filter')\n        expect(rollingLabel).toHaveTextContent('In the last')\n        userEvent.click(rollingLabel)\n\n        await waitFor(() => expect(onChange).toHaveBeenCalledWith('-5d', '', false))\n    })\n})",
            "cost": 0.02338
        },
        "PostHog__posthog.main/frontend/src/lib/components/DateFilter/DateFilter.tsx": {
            "output": "import { Placement } from '@floating-ui/react'\nimport clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { useRef, useState } from 'react'\n\nimport { IconCalendar, IconInfo } from '@posthog/icons'\nimport { LemonButton, LemonButtonProps, LemonDivider, LemonSwitch, Popover } from '@posthog/lemon-ui'\n\nimport {\n    CUSTOM_OPTION_DESCRIPTION,\n    CUSTOM_OPTION_KEY,\n    DateFilterLogicProps,\n    DateFilterView,\n    NO_OVERRIDE_RANGE_PLACEHOLDER,\n} from 'lib/components/DateFilter/types'\nimport { dayjs } from 'lib/dayjs'\nimport { LemonCalendarSelect, LemonCalendarSelectProps } from 'lib/lemon-ui/LemonCalendar/LemonCalendarSelect'\nimport { LemonCalendarRange } from 'lib/lemon-ui/LemonCalendarRange/LemonCalendarRange'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport { dateFilterToText, dateMapping, uuid } from 'lib/utils'\nimport { formatResolvedDateRange } from 'lib/utils/dateTimeUtils'\n\nimport { ResolvedDateRangeResponse } from '~/queries/schema/schema-general'\nimport { DateMappingOption, PropertyOperator } from '~/types'\n\nimport { PropertyFilterDatePicker } from '../PropertyFilters/components/PropertyFilterDatePicker'\nimport { RollingDateRangeFilter } from './RollingDateRangeFilter'\nimport { dateFilterLogic } from './dateFilterLogic'\nimport { DateOption } from './rollingDateRangeFilterLogic'\n\nexport interface DateFilterProps {\n    showCustom?: boolean\n    showRollingRangePicker?: boolean\n    makeLabel?: (key: React.ReactNode, startOfRange?: React.ReactNode) => React.ReactNode\n    className?: string\n    onChange?: (fromDate: string | null, toDate: string | null, explicitDate?: boolean) => void\n    disabled?: boolean\n    disabledReason?: string | null\n    dateOptions?: DateMappingOption[]\n    isDateFormatted?: boolean\n    size?: LemonButtonProps['size']\n    type?: LemonButtonProps['type']\n    dropdownPlacement?: Placement\n    /* True when we're not dealing with ranges, but a single date / relative date */\n    isFixedDateMode?: boolean\n    placeholder?: string\n    fullWidth?: boolean\n    resolvedDateRange?: ResolvedDateRangeResponse\n}\n\ninterface RawDateFilterProps extends DateFilterProps {\n    dateFrom?: string | null | dayjs.Dayjs\n    dateTo?: string | null | dayjs.Dayjs\n    max?: number | null\n    allowedRollingDateOptions?: DateOption[]\n    allowTimePrecision?: boolean\n    /**\n     * Granularity is picked based on the dateFrom value\n     * but can be overridden to force a specific granularity.\n     * For example, set to 'day' to never show the time picker.\n     */\n    forceGranularity?: LemonCalendarSelectProps['granularity']\n    explicitDate?: boolean\n    showExplicitDateToggle?: boolean\n}\n\nexport function DateFilter({\n    showCustom,\n    showRollingRangePicker = true,\n    className,\n    disabledReason,\n    makeLabel,\n    onChange,\n    dateFrom,\n    dateTo,\n    dateOptions = dateMapping,\n    isDateFormatted = true,\n    size,\n    type,\n    dropdownPlacement = 'bottom-start',\n    max,\n    isFixedDateMode = false,\n    allowedRollingDateOptions,\n    allowTimePrecision = false,\n    placeholder,\n    fullWidth = false,\n    forceGranularity,\n    explicitDate,\n    showExplicitDateToggle = false,\n    resolvedDateRange,\n}: RawDateFilterProps): JSX.Element {\n    const key = useRef(uuid()).current\n    const logicProps: DateFilterLogicProps = {\n        key,\n        dateFrom,\n        dateTo,\n        onChange,\n        dateOptions,\n        isDateFormatted,\n        isFixedDateMode,\n        placeholder,\n        allowTimePrecision,\n        explicitDate,\n    }\n    const {\n        open,\n        openFixedRange,\n        openDateToNow,\n        openFixedDate,\n        close,\n        setRangeDateFrom,\n        setExplicitDate,\n        setRangeDateTo,\n        setDate,\n        applyRange,\n    } = useActions(dateFilterLogic(logicProps))\n    const {\n        isVisible,\n        view,\n        rangeDateFrom,\n        rangeDateTo,\n        label,\n        isFixedRange,\n        isDateToNow,\n        isFixedDate,\n        isRollingDateRange,\n        dateFromHasTimePrecision,\n    } = useValues(dateFilterLogic(logicProps))\n\n    const optionsRef = useRef<HTMLDivElement | null>(null)\n    const rollingDateRangeRef = useRef<HTMLDivElement | null>(null)\n    const [granularity, setGranularity] = useState<LemonCalendarSelectProps['granularity']>(\n        forceGranularity ?? (dateFromHasTimePrecision ? 'minute' : 'day')\n    )\n\n    const popoverOverlay =\n        view === DateFilterView.FixedRange ? (\n            <LemonCalendarRange\n                value={[rangeDateFrom ?? dayjs(), rangeDateTo ?? dayjs()]}\n                onChange={([from, to]) => {\n                    setRangeDateFrom(from)\n                    setRangeDateTo(to)\n                    setExplicitDate(false)\n                    applyRange()\n                }}\n                onClose={open}\n                months={2}\n            />\n        ) : view === DateFilterView.DateToNow ? (\n            <LemonCalendarSelect\n                value={rangeDateFrom ?? dayjs()}\n                onChange={(date) => {\n                    setRangeDateFrom(date)\n                    setRangeDateTo(null)\n                    setExplicitDate(granularity === 'minute')\n                    applyRange()\n                }}\n                onClose={open}\n                granularity={forceGranularity ?? granularity}\n                showTimeToggle={forceGranularity ? false : allowTimePrecision}\n                onToggleTime={\n                    forceGranularity ? undefined : () => setGranularity(granularity === 'minute' ? 'day' : 'minute')\n                }\n            />\n        ) : view === DateFilterView.FixedDate ? (\n            <PropertyFilterDatePicker\n                autoFocus\n                operator={PropertyOperator.Exact}\n                value={rangeDateFrom ? rangeDateFrom.toString() : dayjs().toString()}\n                setValue={(date) => {\n                    setDate(String(date), '')\n                }}\n            />\n        ) : (\n            <div className=\"deprecated-space-y-px\" ref={optionsRef} onClick={(e) => e.stopPropagation()}>\n                {dateOptions.map(({ key, values, inactive }) => {\n                    if (key === CUSTOM_OPTION_KEY && !showCustom) {\n                        return null\n                    }\n\n                    if (inactive && label !== key) {\n                        return null\n                    }\n\n                    const isActive =\n                        (dateFrom ?? null) === (values[0] ?? null) && (dateTo ?? null) === (values[1] ?? null)\n                    const dateValue = dateFilterToText(\n                        values[0],\n                        values[1],\n                        CUSTOM_OPTION_DESCRIPTION,\n                        dateOptions,\n                        isDateFormatted\n                    )\n                    const startOfRangeDateValue = dateFilterToText(\n                        values[0],\n                        undefined,\n                        '',\n                        [],\n                        false,\n                        'MMMM D, YYYY',\n                        true\n                    )\n\n                    return (\n                        <Tooltip key={key} title={makeLabel ? makeLabel(dateValue, startOfRangeDateValue) : undefined}>\n                            <LemonButton\n                                key={key}\n                                onClick={() => setDate(values[0] || null, values[1] || null, false, explicitDate)}\n                                active={isActive}\n                                fullWidth\n                            >\n                                {key === CUSTOM_OPTION_KEY ? NO_OVERRIDE_RANGE_PLACEHOLDER : key}\n                            </LemonButton>\n                        </Tooltip>\n                    )\n                })}\n                {showRollingRangePicker && (\n                    <RollingDateRangeFilter\n                        pageKey={key}\n                        dateFrom={dateFrom}\n                        dateRangeFilterLabel={isFixedDateMode ? 'Last' : undefined}\n                        selected={isRollingDateRange}\n                        onChange={(fromDate) => {\n                            setDate(fromDate, '', true, explicitDate)\n                        }}\n                        makeLabel={makeLabel}\n                        popover={{\n                            ref: rollingDateRangeRef,\n                        }}\n                        max={max}\n                        allowedDateOptions={\n                            isFixedDateMode && !allowedRollingDateOptions\n                                ? ['hours', 'days', 'weeks', 'months', 'years']\n                                : allowedRollingDateOptions\n                        }\n                        fullWidth\n                    />\n                )}\n                <LemonDivider />\n                {isFixedDateMode ? (\n                    <LemonButton onClick={openFixedDate} active={isFixedDate} fullWidth>\n                        Custom date...\n                    </LemonButton>\n                ) : (\n                    <>\n                        <LemonButton onClick={openDateToNow} active={isDateToNow} fullWidth>\n                            From custom date until now\u2026\n                        </LemonButton>\n                        <LemonButton onClick={openFixedRange} active={isFixedRange} fullWidth>\n                            Custom fixed date range\u2026\n                        </LemonButton>\n                    </>\n                )}\n                {showExplicitDateToggle && (\n                    <>\n                        <LemonDivider />\n                        <div className=\"LemonSwitch pb-2 pt-2 LemonSwitch--medium LemonSwitch--full-width\">\n                            <label className=\"flex items-center gap-1\">\n                                <span>Exact time range</span>\n                                <Tooltip\n                                    title={\n                                        <>\n                                            <div className=\"font-semibold mb-1\">When enabled:</div>\n                                            <div className=\"mb-2\">\n                                                Uses the current time for period boundaries instead of full days.\n                                            </div>\n                                            <div className=\"font-semibold mb-1\">When disabled:</div>\n                                            <div>Dates are rounded to full day periods (start and end of day).</div>\n                                        </>\n                                    }\n                                >\n                                    <IconInfo className=\"text-muted-alt w-4 h-4\" />\n                                </Tooltip>\n                            </label>\n                            <LemonSwitch\n                                checked={explicitDate ?? false}\n                                onChange={(checked) => {\n                                    setExplicitDate(checked)\n                                }}\n                            />\n                        </div>\n                    </>\n                )}\n            </div>\n        )\n\n    return (\n        <Popover\n            visible={isVisible}\n            overlay={popoverOverlay}\n            placement={dropdownPlacement}\n            actionable\n            additionalRefs={[rollingDateRangeRef]}\n            onClickOutside={close}\n            closeParentPopoverOnClickInside={false}\n        >\n            <LemonButton\n                id=\"daterange_selector\"\n                size={size ?? 'small'}\n                type={type ?? 'secondary'}\n                disabledReason={disabledReason}\n                data-attr=\"date-filter\"\n                icon={<IconCalendar />}\n                onClick={isVisible ? close : open}\n                fullWidth={fullWidth}\n                tooltip={formatResolvedDateRange(resolvedDateRange)}\n            >\n                <span className={clsx('text-nowrap', className)}>{label}</span>\n            </LemonButton>\n        </Popover>\n    )\n}",
            "output_extracted": "import { Placement } from '@floating-ui/react'\nimport clsx from 'clsx'\nimport { useActions, useValues } from 'kea'\nimport { useRef, useState } from 'react'\n\nimport { IconCalendar, IconInfo } from '@posthog/icons'\nimport { LemonButton, LemonButtonProps, LemonDivider, LemonSwitch, Popover } from '@posthog/lemon-ui'\n\nimport {\n    CUSTOM_OPTION_DESCRIPTION,\n    CUSTOM_OPTION_KEY,\n    DateFilterLogicProps,\n    DateFilterView,\n    NO_OVERRIDE_RANGE_PLACEHOLDER,\n} from 'lib/components/DateFilter/types'\nimport { dayjs } from 'lib/dayjs'\nimport { LemonCalendarSelect, LemonCalendarSelectProps } from 'lib/lemon-ui/LemonCalendar/LemonCalendarSelect'\nimport { LemonCalendarRange } from 'lib/lemon-ui/LemonCalendarRange/LemonCalendarRange'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport { dateFilterToText, dateMapping, uuid } from 'lib/utils'\nimport { formatResolvedDateRange } from 'lib/utils/dateTimeUtils'\n\nimport { ResolvedDateRangeResponse } from '~/queries/schema/schema-general'\nimport { DateMappingOption, PropertyOperator } from '~/types'\n\nimport { PropertyFilterDatePicker } from '../PropertyFilters/components/PropertyFilterDatePicker'\nimport { RollingDateRangeFilter } from './RollingDateRangeFilter'\nimport { dateFilterLogic } from './dateFilterLogic'\nimport { DateOption } from './rollingDateRangeFilterLogic'\n\nexport interface DateFilterProps {\n    showCustom?: boolean\n    showRollingRangePicker?: boolean\n    makeLabel?: (key: React.ReactNode, startOfRange?: React.ReactNode) => React.ReactNode\n    className?: string\n    onChange?: (fromDate: string | null, toDate: string | null, explicitDate?: boolean) => void\n    disabled?: boolean\n    disabledReason?: string | null\n    dateOptions?: DateMappingOption[]\n    isDateFormatted?: boolean\n    size?: LemonButtonProps['size']\n    type?: LemonButtonProps['type']\n    dropdownPlacement?: Placement\n    /* True when we're not dealing with ranges, but a single date / relative date */\n    isFixedDateMode?: boolean\n    placeholder?: string\n    fullWidth?: boolean\n    resolvedDateRange?: ResolvedDateRangeResponse\n}\n\ninterface RawDateFilterProps extends DateFilterProps {\n    dateFrom?: string | null | dayjs.Dayjs\n    dateTo?: string | null | dayjs.Dayjs\n    max?: number | null\n    allowedRollingDateOptions?: DateOption[]\n    allowTimePrecision?: boolean\n    /**\n     * Granularity is picked based on the dateFrom value\n     * but can be overridden to force a specific granularity.\n     * For example, set to 'day' to never show the time picker.\n     */\n    forceGranularity?: LemonCalendarSelectProps['granularity']\n    explicitDate?: boolean\n    showExplicitDateToggle?: boolean\n}\n\nexport function DateFilter({\n    showCustom,\n    showRollingRangePicker = true,\n    className,\n    disabledReason,\n    makeLabel,\n    onChange,\n    dateFrom,\n    dateTo,\n    dateOptions = dateMapping,\n    isDateFormatted = true,\n    size,\n    type,\n    dropdownPlacement = 'bottom-start',\n    max,\n    isFixedDateMode = false,\n    allowedRollingDateOptions,\n    allowTimePrecision = false,\n    placeholder,\n    fullWidth = false,\n    forceGranularity,\n    explicitDate,\n    showExplicitDateToggle = false,\n    resolvedDateRange,\n}: RawDateFilterProps): JSX.Element {\n    const key = useRef(uuid()).current\n    const logicProps: DateFilterLogicProps = {\n        key,\n        dateFrom,\n        dateTo,\n        onChange,\n        dateOptions,\n        isDateFormatted,\n        isFixedDateMode,\n        placeholder,\n        allowTimePrecision,\n        explicitDate,\n    }\n    const {\n        open,\n        openFixedRange,\n        openDateToNow,\n        openFixedDate,\n        close,\n        setRangeDateFrom,\n        setExplicitDate,\n        setRangeDateTo,\n        setDate,\n        applyRange,\n    } = useActions(dateFilterLogic(logicProps))\n    const {\n        isVisible,\n        view,\n        rangeDateFrom,\n        rangeDateTo,\n        label,\n        isFixedRange,\n        isDateToNow,\n        isFixedDate,\n        isRollingDateRange,\n        dateFromHasTimePrecision,\n    } = useValues(dateFilterLogic(logicProps))\n\n    const optionsRef = useRef<HTMLDivElement | null>(null)\n    const rollingDateRangeRef = useRef<HTMLDivElement | null>(null)\n    const [granularity, setGranularity] = useState<LemonCalendarSelectProps['granularity']>(\n        forceGranularity ?? (dateFromHasTimePrecision ? 'minute' : 'day')\n    )\n\n    const popoverOverlay =\n        view === DateFilterView.FixedRange ? (\n            <LemonCalendarRange\n                value={[rangeDateFrom ?? dayjs(), rangeDateTo ?? dayjs()]}\n                onChange={([from, to]) => {\n                    setRangeDateFrom(from)\n                    setRangeDateTo(to)\n                    setExplicitDate(false)\n                    applyRange()\n                }}\n                onClose={open}\n                months={2}\n            />\n        ) : view === DateFilterView.DateToNow ? (\n            <LemonCalendarSelect\n                value={rangeDateFrom ?? dayjs()}\n                onChange={(date) => {\n                    setRangeDateFrom(date)\n                    setRangeDateTo(null)\n                    setExplicitDate(granularity === 'minute')\n                    applyRange()\n                }}\n                onClose={open}\n                granularity={forceGranularity ?? granularity}\n                showTimeToggle={forceGranularity ? false : allowTimePrecision}\n                onToggleTime={\n                    forceGranularity ? undefined : () => setGranularity(granularity === 'minute' ? 'day' : 'minute')\n                }\n            />\n        ) : view === DateFilterView.FixedDate ? (\n            <PropertyFilterDatePicker\n                autoFocus\n                operator={PropertyOperator.Exact}\n                value={rangeDateFrom ? rangeDateFrom.toString() : dayjs().toString()}\n                setValue={(date) => {\n                    setDate(String(date), '')\n                }}\n            />\n        ) : (\n            <div className=\"deprecated-space-y-px\" ref={optionsRef} onClick={(e) => e.stopPropagation()}>\n                {dateOptions.map(({ key, values, inactive }) => {\n                    if (key === CUSTOM_OPTION_KEY && !showCustom) {\n                        return null\n                    }\n\n                    if (inactive && label !== key) {\n                        return null\n                    }\n\n                    const isActive =\n                        (dateFrom ?? null) === (values[0] ?? null) && (dateTo ?? null) === (values[1] ?? null)\n                    const dateValue = dateFilterToText(\n                        values[0],\n                        values[1],\n                        CUSTOM_OPTION_DESCRIPTION,\n                        dateOptions,\n                        isDateFormatted\n                    )\n                    const startOfRangeDateValue = dateFilterToText(\n                        values[0],\n                        undefined,\n                        '',\n                        [],\n                        false,\n                        'MMMM D, YYYY',\n                        true\n                    )\n\n                    return (\n                        <Tooltip key={key} title={makeLabel ? makeLabel(dateValue, startOfRangeDateValue) : undefined}>\n                            <LemonButton\n                                key={key}\n                                onClick={() => setDate(values[0] || null, values[1] || null, false, explicitDate)}\n                                active={isActive}\n                                fullWidth\n                            >\n                                {key === CUSTOM_OPTION_KEY ? NO_OVERRIDE_RANGE_PLACEHOLDER : key}\n                            </LemonButton>\n                        </Tooltip>\n                    )\n                })}\n                {showRollingRangePicker && (\n                    <RollingDateRangeFilter\n                        pageKey={key}\n                        dateFrom={dateFrom}\n                        dateRangeFilterLabel={isFixedDateMode ? 'Last' : undefined}\n                        selected={isRollingDateRange}\n                        onChange={(fromDate) => {\n                            setDate(fromDate, '', true, explicitDate)\n                        }}\n                        makeLabel={makeLabel}\n                        popover={{\n                            ref: rollingDateRangeRef,\n                        }}\n                        max={max}\n                        allowedDateOptions={\n                            isFixedDateMode && !allowedRollingDateOptions\n                                ? ['hours', 'days', 'weeks', 'months', 'years']\n                                : allowedRollingDateOptions\n                        }\n                        fullWidth\n                    />\n                )}\n                <LemonDivider />\n                {isFixedDateMode ? (\n                    <LemonButton onClick={openFixedDate} active={isFixedDate} fullWidth>\n                        Custom date...\n                    </LemonButton>\n                ) : (\n                    <>\n                        <LemonButton onClick={openDateToNow} active={isDateToNow} fullWidth>\n                            From custom date until now\u2026\n                        </LemonButton>\n                        <LemonButton onClick={openFixedRange} active={isFixedRange} fullWidth>\n                            Custom fixed date range\u2026\n                        </LemonButton>\n                    </>\n                )}\n                {showExplicitDateToggle && (\n                    <>\n                        <LemonDivider />\n                        <div className=\"LemonSwitch pb-2 pt-2 LemonSwitch--medium LemonSwitch--full-width\">\n                            <label className=\"flex items-center gap-1\">\n                                <span>Exact time range</span>\n                                <Tooltip\n                                    title={\n                                        <>\n                                            <div className=\"font-semibold mb-1\">When enabled:</div>\n                                            <div className=\"mb-2\">\n                                                Uses the current time for period boundaries instead of full days.\n                                            </div>\n                                            <div className=\"font-semibold mb-1\">When disabled:</div>\n                                            <div>Dates are rounded to full day periods (start and end of day).</div>\n                                        </>\n                                    }\n                                >\n                                    <IconInfo className=\"text-muted-alt w-4 h-4\" />\n                                </Tooltip>\n                            </label>\n                            <LemonSwitch\n                                checked={explicitDate ?? false}\n                                onChange={(checked) => {\n                                    setExplicitDate(checked)\n                                }}\n                            />\n                        </div>\n                    </>\n                )}\n            </div>\n        )\n\n    return (\n        <Popover\n            visible={isVisible}\n            overlay={popoverOverlay}\n            placement={dropdownPlacement}\n            actionable\n            additionalRefs={[rollingDateRangeRef]}\n            onClickOutside={close}\n            closeParentPopoverOnClickInside={false}\n        >\n            <LemonButton\n                id=\"daterange_selector\"\n                size={size ?? 'small'}\n                type={type ?? 'secondary'}\n                disabledReason={disabledReason}\n                data-attr=\"date-filter\"\n                icon={<IconCalendar />}\n                onClick={isVisible ? close : open}\n                fullWidth={fullWidth}\n                tooltip={formatResolvedDateRange(resolvedDateRange)}\n            >\n                <span className={clsx('text-nowrap', className)}>{label}</span>\n            </LemonButton>\n        </Popover>\n    )\n}",
            "cost": 0.10278
        },
        "PostHog__posthog.main/frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts": {
            "output": "import { expectLogic } from 'kea-test-utils'\n\nimport { DateFilterLogicProps, DateFilterView } from 'lib/components/DateFilter/types'\nimport { dayjs } from 'lib/dayjs'\nimport { dateMapping } from 'lib/utils'\n\nimport { dateFilterLogic } from './dateFilterLogic'\n\ndescribe('dateFilterLogic', () => {\n    let props: DateFilterLogicProps\n    const onChange = jest.fn()\n    let logic: ReturnType<typeof dateFilterLogic.build>\n\n    beforeEach(async () => {\n        dayjs.tz.setDefault('America/New_York')\n\n        props = {\n            key: 'test',\n            onChange,\n            dateFrom: null,\n            dateTo: null,\n            dateOptions: dateMapping,\n            isDateFormatted: false,\n        }\n        logic = dateFilterLogic(props)\n        logic.mount()\n    })\n\n    it('should only open one type of date filter', async () => {\n        await expectLogic(logic).toMatchValues({\n            isVisible: false,\n            view: DateFilterView.QuickList,\n        })\n        logic.actions.open()\n        await expectLogic(logic).toMatchValues({\n            isVisible: true,\n            view: DateFilterView.QuickList,\n        })\n        logic.actions.openFixedRange()\n        await expectLogic(logic).toMatchValues({\n            isVisible: true,\n            view: DateFilterView.FixedRange,\n        })\n        logic.actions.openDateToNow()\n        await expectLogic(logic).toMatchValues({\n            isVisible: true,\n            view: DateFilterView.DateToNow,\n        })\n        logic.actions.close()\n        await expectLogic(logic).toMatchValues({\n            isVisible: false,\n            view: DateFilterView.DateToNow,\n        })\n    })\n\n    it('can set the date range', async () => {\n        props = {\n            key: 'test',\n            onChange,\n            dateFrom: '-1dStart',\n            dateTo: '-1dEnd',\n            dateOptions: dateMapping,\n            isDateFormatted: false,\n        }\n        const withDateFrom = dateFilterLogic(props)\n        withDateFrom.mount()\n\n        await expectLogic(withDateFrom).toMatchValues({ dateFrom: '-1dStart', dateTo: '-1dEnd', label: 'Yesterday' })\n        expect(onChange).not.toHaveBeenCalled()\n    })\n\n    it('can clear the date range', async () => {\n        props = {\n            key: 'test',\n            onChange,\n            dateFrom: '-1d',\n            dateTo: null,\n            dateOptions: dateMapping,\n            isDateFormatted: false,\n        }\n        const withDateFrom = dateFilterLogic(props)\n        withDateFrom.mount()\n\n        await expectLogic(withDateFrom, () => {\n            withDateFrom.actions.setDate(null, null)\n        })\n        expect(onChange).toHaveBeenCalledWith(null, null, false)\n    })\n\n    it('can receive Custom as date props', async () => {\n        props = {\n            key: 'test',\n            onChange,\n            dateFrom: null,\n            dateTo: null,\n            dateOptions: dateMapping,\n            isDateFormatted: false,\n        }\n        const withoutDateFrom = dateFilterLogic(props)\n        withoutDateFrom.mount()\n\n        await expectLogic(withoutDateFrom).toMatchValues({\n            dateFrom: null,\n            dateTo: null,\n            label: 'No date range override',\n        })\n        expect(onChange).not.toHaveBeenCalled()\n    })\n})",
            "output_extracted": "import { expectLogic } from 'kea-test-utils'\n\nimport { DateFilterLogicProps, DateFilterView } from 'lib/components/DateFilter/types'\nimport { dayjs } from 'lib/dayjs'\nimport { dateMapping } from 'lib/utils'\n\nimport { dateFilterLogic } from './dateFilterLogic'\n\ndescribe('dateFilterLogic', () => {\n    let props: DateFilterLogicProps\n    const onChange = jest.fn()\n    let logic: ReturnType<typeof dateFilterLogic.build>\n\n    beforeEach(async () => {\n        dayjs.tz.setDefault('America/New_York')\n\n        props = {\n            key: 'test',\n            onChange,\n            dateFrom: null,\n            dateTo: null,\n            dateOptions: dateMapping,\n            isDateFormatted: false,\n        }\n        logic = dateFilterLogic(props)\n        logic.mount()\n    })\n\n    it('should only open one type of date filter', async () => {\n        await expectLogic(logic).toMatchValues({\n            isVisible: false,\n            view: DateFilterView.QuickList,\n        })\n        logic.actions.open()\n        await expectLogic(logic).toMatchValues({\n            isVisible: true,\n            view: DateFilterView.QuickList,\n        })\n        logic.actions.openFixedRange()\n        await expectLogic(logic).toMatchValues({\n            isVisible: true,\n            view: DateFilterView.FixedRange,\n        })\n        logic.actions.openDateToNow()\n        await expectLogic(logic).toMatchValues({\n            isVisible: true,\n            view: DateFilterView.DateToNow,\n        })\n        logic.actions.close()\n        await expectLogic(logic).toMatchValues({\n            isVisible: false,\n            view: DateFilterView.DateToNow,\n        })\n    })\n\n    it('can set the date range', async () => {\n        props = {\n            key: 'test',\n            onChange,\n            dateFrom: '-1dStart',\n            dateTo: '-1dEnd',\n            dateOptions: dateMapping,\n            isDateFormatted: false,\n        }\n        const withDateFrom = dateFilterLogic(props)\n        withDateFrom.mount()\n\n        await expectLogic(withDateFrom).toMatchValues({ dateFrom: '-1dStart', dateTo: '-1dEnd', label: 'Yesterday' })\n        expect(onChange).not.toHaveBeenCalled()\n    })\n\n    it('can clear the date range', async () => {\n        props = {\n            key: 'test',\n            onChange,\n            dateFrom: '-1d',\n            dateTo: null,\n            dateOptions: dateMapping,\n            isDateFormatted: false,\n        }\n        const withDateFrom = dateFilterLogic(props)\n        withDateFrom.mount()\n\n        await expectLogic(withDateFrom, () => {\n            withDateFrom.actions.setDate(null, null)\n        })\n        expect(onChange).toHaveBeenCalledWith(null, null, false)\n    })\n\n    it('can receive Custom as date props', async () => {\n        props = {\n            key: 'test',\n            onChange,\n            dateFrom: null,\n            dateTo: null,\n            dateOptions: dateMapping,\n            isDateFormatted: false,\n        }\n        const withoutDateFrom = dateFilterLogic(props)\n        withoutDateFrom.mount()\n\n        await expectLogic(withoutDateFrom).toMatchValues({\n            dateFrom: null,\n            dateTo: null,\n            label: 'No date range override',\n        })\n        expect(onChange).not.toHaveBeenCalled()\n    })\n})",
            "cost": 0.041535
        },
        "PostHog__posthog.main/frontend/src/lib/components/DateFilter/dateFilterLogic.ts": {
            "output": "import { actions, kea, key, listeners, path, props, reducers, selectors } from 'kea'\n\nimport {\n    DateFilterLogicProps,\n    DateFilterView,\n    NO_OVERRIDE_RANGE_PLACEHOLDER,\n    SELECT_FIXED_VALUE_PLACEHOLDER,\n} from 'lib/components/DateFilter/types'\nimport { Dayjs, dayjs } from 'lib/dayjs'\nimport {\n    dateFilterToText,\n    dateStringToDayJs,\n    formatDate,\n    formatDateRange,\n    formatDateTime,\n    formatDateTimeRange,\n    isDate,\n} from 'lib/utils'\n\nimport { DateMappingOption } from '~/types'\n\nimport type { dateFilterLogicType } from './dateFilterLogicType'\n\nexport const dateFilterLogic = kea<dateFilterLogicType>([\n    path(['lib', 'components', 'DateFilter', 'DateFilterLogic']),\n    props({} as DateFilterLogicProps),\n    key(({ key }) => key),\n    actions({\n        open: true,\n        openFixedRange: true,\n        openDateToNow: true,\n        openFixedDate: true,\n        close: true,\n        applyRange: true,\n        setDate: (\n            dateFrom: string | null,\n            dateTo: string | null,\n            keepPopoverOpen = false,\n            explicitDate: boolean = false\n        ) => ({\n            dateFrom,\n            dateTo,\n            keepPopoverOpen,\n            explicitDate,\n        }),\n        setRangeDateFrom: (range: Dayjs | null) => ({ range }),\n        setRangeDateTo: (range: Dayjs | null) => ({ range }),\n        setExplicitDate: (explicitDate: boolean) => ({ explicitDate }),\n    }),\n    reducers(({ props }) => ({\n        view: [\n            DateFilterView.QuickList as DateFilterView,\n            {\n                open: () => DateFilterView.QuickList,\n                openFixedRange: () => DateFilterView.FixedRange,\n                openDateToNow: () => DateFilterView.DateToNow,\n                openFixedDate: () => DateFilterView.FixedDate,\n            },\n        ],\n        isVisible: [\n            false,\n            {\n                open: () => true,\n                openFixedRange: () => true,\n                openDateToNow: () => true,\n                openFixedDate: () => true,\n                setDate: (_, { keepPopoverOpen }) => keepPopoverOpen,\n                close: () => false,\n            },\n        ],\n        rangeDateFrom: [\n            (props.dateFrom && (dayjs.isDayjs(props.dateFrom) || isDate.test(props.dateFrom))\n                ? dayjs(props.dateFrom)\n                : null) as Dayjs | null,\n            {\n                setRangeDateFrom: (_, { range }) => (range ? dayjs(range) : null),\n                setDate: (_, { dateFrom }) => dateStringToDayJs(dateFrom),\n            },\n        ],\n        rangeDateTo: [\n            (props.dateTo && (dayjs.isDayjs(props.dateTo) || isDate.test(props.dateTo))\n                ? dayjs(props.dateTo)\n                : dayjs()) as Dayjs | null,\n            {\n                setRangeDateTo: (_, { range }) => (range ? dayjs(range) : null),\n                setDate: (_, { dateTo }) => (dateTo ? dateStringToDayJs(dateTo) : null),\n            },\n        ],\n        explicitDate: [\n            props.explicitDate ??\n                !!(\n                    props.dateFrom &&\n                    (dayjs.isDayjs(props.dateFrom) || dayjs(props.dateFrom).format('HH:mm:ss') !== '00:00:00')\n                ),\n            {\n                setExplicitDate: (_, { explicitDate }) => explicitDate,\n                setDate: (_, { explicitDate }) => explicitDate,\n            },\n        ],\n    })),\n    selectors({\n        dateFrom: [() => [(_, props) => props.dateFrom], (dateFrom) => dateFrom ?? null],\n        dateTo: [() => [(_, props) => props.dateTo], (dateTo) => dateTo ?? null],\n        dateOptions: [\n            () => [(_, props) => props.dateOptions],\n            (dateOptions): DateMappingOption[] | undefined => dateOptions,\n        ],\n        isFixedRange: [\n            (s) => [s.dateFrom, s.dateTo],\n            (dateFrom, dateTo) => !!(dateFrom && dateTo && dayjs(dateFrom).isValid() && dayjs(dateTo).isValid()),\n        ],\n        isDateToNow: [\n            (s) => [s.dateFrom, s.dateTo, (_, p) => p.isFixedDateMode],\n            (dateFrom, dateTo, isFixedDateMode) =>\n                !!dateFrom && !dateTo && dayjs(dateFrom).isValid() && !isFixedDateMode,\n        ],\n        isFixedDate: [\n            (s) => [s.dateFrom, s.dateTo, (_, p) => p.isFixedDateMode],\n            (dateFrom, dateTo, isFixedDateMode) => dateFrom && dayjs(dateFrom).isValid() && !dateTo && isFixedDateMode,\n        ],\n        isRollingDateRange: [\n            (s) => [s.isFixedRange, s.isDateToNow, s.isFixedDate, s.dateOptions, s.dateFrom, s.dateTo],\n            (isFixedRange, isDateToNow, isFixedDate, dateOptions, dateFrom, dateTo): boolean =>\n                !isFixedRange &&\n                !isDateToNow &&\n                !isFixedDate &&\n                !dateOptions?.find(\n                    (option) =>\n                        (option.values[0] ?? null) === (dateFrom ?? null) &&\n                        (option.values[1] ?? null) === (dateTo ?? null)\n                ),\n        ],\n        dateFromHasTimePrecision: [\n            (s) => [s.dateFrom],\n            (dateFrom) => {\n                if (dateFrom) {\n                    return dayjs(dateFrom).format('HH:mm:ss') !== '00:00:00'\n                }\n                return false\n            },\n        ],\n        dateToHasTimePrecision: [\n            (s) => [s.dateTo],\n            (dateTo) => {\n                if (dateTo) {\n                    return dayjs(dateTo).format('HH:mm:ss') !== '00:00:00'\n                }\n                return false\n            },\n        ],\n        label: [\n            (s) => [\n                s.dateFrom,\n                s.dateTo,\n                s.isFixedRange,\n                s.isDateToNow,\n                s.isFixedDate,\n                s.dateOptions,\n                (_, p) => p.isFixedDateMode,\n                (_, p) => p.placeholder,\n                s.dateFromHasTimePrecision,\n                s.dateToHasTimePrecision,\n            ],\n            (\n                dateFrom,\n                dateTo,\n                isFixedRange,\n                isDateToNow,\n                isFixedDate,\n                dateOptions,\n                isFixedDateMode,\n                placeholder,\n                dateFromHasTimePrecision,\n                dateToHasTimePrecision\n            ) =>\n                isFixedRange\n                    ? dateFromHasTimePrecision || dateToHasTimePrecision\n                        ? formatDateTimeRange(dayjs(dateFrom), dayjs(dateTo))\n                        : formatDateRange(dayjs(dateFrom), dayjs(dateTo))\n                    : isDateToNow\n                      ? `${\n                            dateFromHasTimePrecision ? formatDateTime(dayjs(dateFrom)) : formatDate(dayjs(dateFrom))\n                        } to now`\n                      : isFixedDate\n                        ? formatDate(dateStringToDayJs(dateFrom) ?? dayjs(dateFrom))\n                        : dateFilterToText(\n                              dateFrom,\n                              dateTo,\n                              isFixedDateMode\n                                  ? (placeholder ?? SELECT_FIXED_VALUE_PLACEHOLDER)\n                                  : NO_OVERRIDE_RANGE_PLACEHOLDER,\n                              dateOptions,\n                              false\n                          ),\n        ],\n    }),\n    listeners(({ actions, values, props }) => ({\n        applyRange: () => {\n            if (values.rangeDateFrom) {\n                actions.setDate(\n                    dayjs(values.rangeDateFrom).format(props.allowTimePrecision ? 'YYYY-MM-DDTHH:mm:ss' : 'YYYY-MM-DD'),\n                    // Treat as naive time. Project timezone will be applied on backend.\n                    values.rangeDateTo ? dayjs(values.rangeDateTo).format('YYYY-MM-DDTHH:mm:ss') : null,\n                    false,\n                    values.explicitDate || false\n                )\n            }\n        },\n        setDate: ({ dateFrom, dateTo, explicitDate }) => {\n            props.onChange?.(dateFrom, dateTo, explicitDate)\n        },\n        setExplicitDate: ({ explicitDate }) => {\n            props.onChange?.(values.dateFrom, values.dateTo, explicitDate)\n        },\n    })),\n])",
            "output_extracted": "import { actions, kea, key, listeners, path, props, reducers, selectors } from 'kea'\n\nimport {\n    DateFilterLogicProps,\n    DateFilterView,\n    NO_OVERRIDE_RANGE_PLACEHOLDER,\n    SELECT_FIXED_VALUE_PLACEHOLDER,\n} from 'lib/components/DateFilter/types'\nimport { Dayjs, dayjs } from 'lib/dayjs'\nimport {\n    dateFilterToText,\n    dateStringToDayJs,\n    formatDate,\n    formatDateRange,\n    formatDateTime,\n    formatDateTimeRange,\n    isDate,\n} from 'lib/utils'\n\nimport { DateMappingOption } from '~/types'\n\nimport type { dateFilterLogicType } from './dateFilterLogicType'\n\nexport const dateFilterLogic = kea<dateFilterLogicType>([\n    path(['lib', 'components', 'DateFilter', 'DateFilterLogic']),\n    props({} as DateFilterLogicProps),\n    key(({ key }) => key),\n    actions({\n        open: true,\n        openFixedRange: true,\n        openDateToNow: true,\n        openFixedDate: true,\n        close: true,\n        applyRange: true,\n        setDate: (\n            dateFrom: string | null,\n            dateTo: string | null,\n            keepPopoverOpen = false,\n            explicitDate: boolean = false\n        ) => ({\n            dateFrom,\n            dateTo,\n            keepPopoverOpen,\n            explicitDate,\n        }),\n        setRangeDateFrom: (range: Dayjs | null) => ({ range }),\n        setRangeDateTo: (range: Dayjs | null) => ({ range }),\n        setExplicitDate: (explicitDate: boolean) => ({ explicitDate }),\n    }),\n    reducers(({ props }) => ({\n        view: [\n            DateFilterView.QuickList as DateFilterView,\n            {\n                open: () => DateFilterView.QuickList,\n                openFixedRange: () => DateFilterView.FixedRange,\n                openDateToNow: () => DateFilterView.DateToNow,\n                openFixedDate: () => DateFilterView.FixedDate,\n            },\n        ],\n        isVisible: [\n            false,\n            {\n                open: () => true,\n                openFixedRange: () => true,\n                openDateToNow: () => true,\n                openFixedDate: () => true,\n                setDate: (_, { keepPopoverOpen }) => keepPopoverOpen,\n                close: () => false,\n            },\n        ],\n        rangeDateFrom: [\n            (props.dateFrom && (dayjs.isDayjs(props.dateFrom) || isDate.test(props.dateFrom))\n                ? dayjs(props.dateFrom)\n                : null) as Dayjs | null,\n            {\n                setRangeDateFrom: (_, { range }) => (range ? dayjs(range) : null),\n                setDate: (_, { dateFrom }) => dateStringToDayJs(dateFrom),\n            },\n        ],\n        rangeDateTo: [\n            (props.dateTo && (dayjs.isDayjs(props.dateTo) || isDate.test(props.dateTo))\n                ? dayjs(props.dateTo)\n                : dayjs()) as Dayjs | null,\n            {\n                setRangeDateTo: (_, { range }) => (range ? dayjs(range) : null),\n                setDate: (_, { dateTo }) => (dateTo ? dateStringToDayJs(dateTo) : null),\n            },\n        ],\n        explicitDate: [\n            props.explicitDate ??\n                !!(\n                    props.dateFrom &&\n                    (dayjs.isDayjs(props.dateFrom) || dayjs(props.dateFrom).format('HH:mm:ss') !== '00:00:00')\n                ),\n            {\n                setExplicitDate: (_, { explicitDate }) => explicitDate,\n                setDate: (_, { explicitDate }) => explicitDate,\n            },\n        ],\n    })),\n    selectors({\n        dateFrom: [() => [(_, props) => props.dateFrom], (dateFrom) => dateFrom ?? null],\n        dateTo: [() => [(_, props) => props.dateTo], (dateTo) => dateTo ?? null],\n        dateOptions: [\n            () => [(_, props) => props.dateOptions],\n            (dateOptions): DateMappingOption[] | undefined => dateOptions,\n        ],\n        isFixedRange: [\n            (s) => [s.dateFrom, s.dateTo],\n            (dateFrom, dateTo) => !!(dateFrom && dateTo && dayjs(dateFrom).isValid() && dayjs(dateTo).isValid()),\n        ],\n        isDateToNow: [\n            (s) => [s.dateFrom, s.dateTo, (_, p) => p.isFixedDateMode],\n            (dateFrom, dateTo, isFixedDateMode) =>\n                !!dateFrom && !dateTo && dayjs(dateFrom).isValid() && !isFixedDateMode,\n        ],\n        isFixedDate: [\n            (s) => [s.dateFrom, s.dateTo, (_, p) => p.isFixedDateMode],\n            (dateFrom, dateTo, isFixedDateMode) => dateFrom && dayjs(dateFrom).isValid() && !dateTo && isFixedDateMode,\n        ],\n        isRollingDateRange: [\n            (s) => [s.isFixedRange, s.isDateToNow, s.isFixedDate, s.dateOptions, s.dateFrom, s.dateTo],\n            (isFixedRange, isDateToNow, isFixedDate, dateOptions, dateFrom, dateTo): boolean =>\n                !isFixedRange &&\n                !isDateToNow &&\n                !isFixedDate &&\n                !dateOptions?.find(\n                    (option) =>\n                        (option.values[0] ?? null) === (dateFrom ?? null) &&\n                        (option.values[1] ?? null) === (dateTo ?? null)\n                ),\n        ],\n        dateFromHasTimePrecision: [\n            (s) => [s.dateFrom],\n            (dateFrom) => {\n                if (dateFrom) {\n                    return dayjs(dateFrom).format('HH:mm:ss') !== '00:00:00'\n                }\n                return false\n            },\n        ],\n        dateToHasTimePrecision: [\n            (s) => [s.dateTo],\n            (dateTo) => {\n                if (dateTo) {\n                    return dayjs(dateTo).format('HH:mm:ss') !== '00:00:00'\n                }\n                return false\n            },\n        ],\n        label: [\n            (s) => [\n                s.dateFrom,\n                s.dateTo,\n                s.isFixedRange,\n                s.isDateToNow,\n                s.isFixedDate,\n                s.dateOptions,\n                (_, p) => p.isFixedDateMode,\n                (_, p) => p.placeholder,\n                s.dateFromHasTimePrecision,\n                s.dateToHasTimePrecision,\n            ],\n            (\n                dateFrom,\n                dateTo,\n                isFixedRange,\n                isDateToNow,\n                isFixedDate,\n                dateOptions,\n                isFixedDateMode,\n                placeholder,\n                dateFromHasTimePrecision,\n                dateToHasTimePrecision\n            ) =>\n                isFixedRange\n                    ? dateFromHasTimePrecision || dateToHasTimePrecision\n                        ? formatDateTimeRange(dayjs(dateFrom), dayjs(dateTo))\n                        : formatDateRange(dayjs(dateFrom), dayjs(dateTo))\n                    : isDateToNow\n                      ? `${\n                            dateFromHasTimePrecision ? formatDateTime(dayjs(dateFrom)) : formatDate(dayjs(dateFrom))\n                        } to now`\n                      : isFixedDate\n                        ? formatDate(dateStringToDayJs(dateFrom) ?? dayjs(dateFrom))\n                        : dateFilterToText(\n                              dateFrom,\n                              dateTo,\n                              isFixedDateMode\n                                  ? (placeholder ?? SELECT_FIXED_VALUE_PLACEHOLDER)\n                                  : NO_OVERRIDE_RANGE_PLACEHOLDER,\n                              dateOptions,\n                              false\n                          ),\n        ],\n    }),\n    listeners(({ actions, values, props }) => ({\n        applyRange: () => {\n            if (values.rangeDateFrom) {\n                actions.setDate(\n                    dayjs(values.rangeDateFrom).format(props.allowTimePrecision ? 'YYYY-MM-DDTHH:mm:ss' : 'YYYY-MM-DD'),\n                    // Treat as naive time. Project timezone will be applied on backend.\n                    values.rangeDateTo ? dayjs(values.rangeDateTo).format('YYYY-MM-DDTHH:mm:ss') : null,\n                    false,\n                    values.explicitDate || false\n                )\n            }\n        },\n        setDate: ({ dateFrom, dateTo, explicitDate }) => {\n            props.onChange?.(dateFrom, dateTo, explicitDate)\n        },\n        setExplicitDate: ({ explicitDate }) => {\n            props.onChange?.(values.dateFrom, values.dateTo, explicitDate)\n        },\n    })),\n])",
            "cost": 0.07842
        },
        "PostHog__posthog.main/frontend/src/lib/components/DateFilter/types.ts": {
            "output": "import { Dayjs } from 'lib/dayjs'\n\nimport { DateMappingOption } from '~/types'\n\nexport enum DateFilterView {\n    QuickList = 'QuickList',\n    DateToNow = 'DateToNow',\n    FixedRange = 'FixedRange',\n    FixedDate = 'FixedDate',\n}\n\nexport type DateFilterLogicProps = {\n    key: string\n    onChange?: (fromDate: string | null, toDate: string | null, explicitDate?: boolean) => void\n    dateFrom?: Dayjs | string | null\n    dateTo?: Dayjs | string | null\n    dateOptions?: DateMappingOption[]\n    isDateFormatted?: boolean\n    isFixedDateMode?: boolean\n    placeholder?: string\n    allowTimePrecision?: boolean\n    explicitDate?: boolean\n}\n\nexport const CUSTOM_OPTION_KEY = 'Custom'\nexport const SELECT_FIXED_VALUE_PLACEHOLDER = 'Select a value'\nexport const NO_OVERRIDE_RANGE_PLACEHOLDER = 'No date range override'\nexport const CUSTOM_OPTION_DESCRIPTION = 'Use the original date ranges of insights'",
            "output_extracted": "import { Dayjs } from 'lib/dayjs'\n\nimport { DateMappingOption } from '~/types'\n\nexport enum DateFilterView {\n    QuickList = 'QuickList',\n    DateToNow = 'DateToNow',\n    FixedRange = 'FixedRange',\n    FixedDate = 'FixedDate',\n}\n\nexport type DateFilterLogicProps = {\n    key: string\n    onChange?: (fromDate: string | null, toDate: string | null, explicitDate?: boolean) => void\n    dateFrom?: Dayjs | string | null\n    dateTo?: Dayjs | string | null\n    dateOptions?: DateMappingOption[]\n    isDateFormatted?: boolean\n    isFixedDateMode?: boolean\n    placeholder?: string\n    allowTimePrecision?: boolean\n    explicitDate?: boolean\n}\n\nexport const CUSTOM_OPTION_KEY = 'Custom'\nexport const SELECT_FIXED_VALUE_PLACEHOLDER = 'Select a value'\nexport const NO_OVERRIDE_RANGE_PLACEHOLDER = 'No date range override'\nexport const CUSTOM_OPTION_DESCRIPTION = 'Use the original date ranges of insights'",
            "cost": 0.013785000000000002
        },
        "PostHog__posthog.main/products/logs/frontend/filters/DateRangeFilter.tsx": {
            "output": "import { useActions, useValues } from 'kea'\n\nimport { DateFilter } from 'lib/components/DateFilter/DateFilter'\nimport { CUSTOM_OPTION_KEY } from 'lib/components/DateFilter/types'\nimport { dayjs } from 'lib/dayjs'\nimport { DATE_TIME_FORMAT, formatDateRange } from 'lib/utils'\n\nimport { DateMappingOption } from '~/types'\n\nimport { logsLogic } from '../logsLogic'\n\nconst dateMapping: DateMappingOption[] = [\n    { key: CUSTOM_OPTION_KEY, values: [] },\n    {\n        key: 'Last 5 minutes',\n        values: ['-5M'],\n        getFormattedDate: (date: dayjs.Dayjs): string => {\n            return date.subtract(5, 'minute').format(DATE_TIME_FORMAT)\n        },\n        defaultInterval: 'minute',\n    },\n    {\n        key: 'Last 30 minutes',\n        values: ['-30M'],\n        getFormattedDate: (date: dayjs.Dayjs): string => {\n            return date.subtract(30, 'minute').format(DATE_TIME_FORMAT)\n        },\n        defaultInterval: 'minute',\n    },\n    {\n        key: 'Last 1 hours',\n        values: ['-1h'],\n        getFormattedDate: (date: dayjs.Dayjs): string => formatDateRange(date.subtract(1, 'h'), date.endOf('d')),\n        defaultInterval: 'hour',\n    },\n    {\n        key: 'Last 4 hours',\n        values: ['-4h'],\n        getFormattedDate: (date: dayjs.Dayjs): string => formatDateRange(date.subtract(4, 'h'), date.endOf('d')),\n        defaultInterval: 'hour',\n    },\n    {\n        key: 'Last 24 hours',\n        values: ['-24h'],\n        getFormattedDate: (date: dayjs.Dayjs): string => formatDateRange(date.subtract(24, 'h'), date.endOf('d')),\n        defaultInterval: 'hour',\n    },\n    {\n        key: 'Last 7 days',\n        values: ['-7d'],\n        getFormattedDate: (date: dayjs.Dayjs): string => formatDateRange(date.subtract(7, 'd'), date.endOf('d')),\n        defaultInterval: 'day',\n    },\n]\n\nexport const DateRangeFilter = (): JSX.Element => {\n    const { dateRange } = useValues(logsLogic)\n    const { setDateRange } = useActions(logsLogic)\n\n    return (\n        <DateFilter\n            size=\"small\"\n            dateFrom={dateRange.date_from}\n            dateTo={dateRange.date_to}\n            dateOptions={dateMapping}\n            onChange={(changedDateFrom, changedDateTo) => {\n                setDateRange({ date_from: changedDateFrom, date_to: changedDateTo })\n            }}\n            allowTimePrecision\n            allowedRollingDateOptions={['minutes', 'hours', 'days', 'weeks', 'months']}\n        />\n    )\n}",
            "output_extracted": "import { useActions, useValues } from 'kea'\n\nimport { DateFilter } from 'lib/components/DateFilter/DateFilter'\nimport { CUSTOM_OPTION_KEY } from 'lib/components/DateFilter/types'\nimport { dayjs } from 'lib/dayjs'\nimport { DATE_TIME_FORMAT, formatDateRange } from 'lib/utils'\n\nimport { DateMappingOption } from '~/types'\n\nimport { logsLogic } from '../logsLogic'\n\nconst dateMapping: DateMappingOption[] = [\n    { key: CUSTOM_OPTION_KEY, values: [] },\n    {\n        key: 'Last 5 minutes',\n        values: ['-5M'],\n        getFormattedDate: (date: dayjs.Dayjs): string => {\n            return date.subtract(5, 'minute').format(DATE_TIME_FORMAT)\n        },\n        defaultInterval: 'minute',\n    },\n    {\n        key: 'Last 30 minutes',\n        values: ['-30M'],\n        getFormattedDate: (date: dayjs.Dayjs): string => {\n            return date.subtract(30, 'minute').format(DATE_TIME_FORMAT)\n        },\n        defaultInterval: 'minute',\n    },\n    {\n        key: 'Last 1 hours',\n        values: ['-1h'],\n        getFormattedDate: (date: dayjs.Dayjs): string => formatDateRange(date.subtract(1, 'h'), date.endOf('d')),\n        defaultInterval: 'hour',\n    },\n    {\n        key: 'Last 4 hours',\n        values: ['-4h'],\n        getFormattedDate: (date: dayjs.Dayjs): string => formatDateRange(date.subtract(4, 'h'), date.endOf('d')),\n        defaultInterval: 'hour',\n    },\n    {\n        key: 'Last 24 hours',\n        values: ['-24h'],\n        getFormattedDate: (date: dayjs.Dayjs): string => formatDateRange(date.subtract(24, 'h'), date.endOf('d')),\n        defaultInterval: 'hour',\n    },\n    {\n        key: 'Last 7 days',\n        values: ['-7d'],\n        getFormattedDate: (date: dayjs.Dayjs): string => formatDateRange(date.subtract(7, 'd'), date.endOf('d')),\n        defaultInterval: 'day',\n    },\n]\n\nexport const DateRangeFilter = (): JSX.Element => {\n    const { dateRange } = useValues(logsLogic)\n    const { setDateRange } = useActions(logsLogic)\n\n    return (\n        <DateFilter\n            size=\"small\"\n            dateFrom={dateRange.date_from}\n            dateTo={dateRange.date_to}\n            dateOptions={dateMapping}\n            onChange={(changedDateFrom, changedDateTo) => {\n                setDateRange({ date_from: changedDateFrom, date_to: changedDateTo })\n            }}\n            allowTimePrecision\n            allowedRollingDateOptions={['minutes', 'hours', 'days', 'weeks', 'months']}\n        />\n    )\n}",
            "cost": 0.029055000000000004
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "PostHog__posthog.main.42569",
        "repo": "PostHog/posthog",
        "base_commit": "ecae84a58c3a843ff35a4c105beec5b78f8ff5d9",
        "head_commit": "6e8d3bfa86633fd85c8ecc7bce72ca81bf879322",
        "title": "feat(DateFilter): add fixed date range with time picker",
        "merged_at": "2025-12-03T12:56:00Z",
        "html_url": "https://github.com/PostHog/posthog/pull/42569",
        "test_files": [
            "frontend/src/lib/components/DateFilter/DateFilter.test.tsx",
            "frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.test.tsx",
            "frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts"
        ],
        "code_files": [
            "frontend/src/lib/components/DateFilter/DateFilter.tsx",
            "frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.tsx",
            "frontend/src/lib/components/DateFilter/dateFilterLogic.ts",
            "frontend/src/lib/components/DateFilter/types.ts",
            "products/logs/frontend/filters/DateRangeFilter.tsx"
        ],
        "total_changes": 426,
        "num_files": 8,
        "pull_number": 42569,
        "patch": "diff --git a/frontend/src/lib/components/DateFilter/DateFilter.test.tsx b/frontend/src/lib/components/DateFilter/DateFilter.test.tsx\nindex 0884e1c9243f5..b05a8b62a3e5d 100644\n--- a/frontend/src/lib/components/DateFilter/DateFilter.test.tsx\n+++ b/frontend/src/lib/components/DateFilter/DateFilter.test.tsx\n@@ -54,3 +54,40 @@ describe('DateFilter', () => {\n         await waitFor(() => expect(onChange).toHaveBeenCalledWith('-5d', '', false))\n     })\n })\n+\n+describe('DateFilter with allowFixedRangeWithTime', () => {\n+    let onChange = jest.fn()\n+    beforeEach(() => {\n+        initKeaTests()\n+        onChange = jest.fn()\n+        render(\n+            <Provider>\n+                <DateFilter onChange={onChange} dateOptions={dateMapping} allowFixedRangeWithTime />\n+            </Provider>\n+        )\n+    })\n+\n+    afterEach(() => {\n+        cleanup()\n+    })\n+\n+    it('shows custom fixed date range with time option', async () => {\n+        const dateFilter = screen.getByTestId('date-filter')\n+        userEvent.click(dateFilter)\n+\n+        expect(screen.getByText(/custom fixed date range with time/i)).toBeInTheDocument()\n+        expect(screen.getByText(/custom fixed date range\u2026$/i)).toBeInTheDocument()\n+    })\n+\n+    it('opens the time range picker when clicking custom fixed date range with time', async () => {\n+        const dateFilter = screen.getByTestId('date-filter')\n+        userEvent.click(dateFilter)\n+\n+        const timeRangeOption = screen.getByText(/custom fixed date range with time/i)\n+        userEvent.click(timeRangeOption)\n+\n+        await waitFor(() => {\n+            expect(screen.getByText(/select a date and time range/i)).toBeInTheDocument()\n+        })\n+    })\n+})\ndiff --git a/frontend/src/lib/components/DateFilter/DateFilter.tsx b/frontend/src/lib/components/DateFilter/DateFilter.tsx\nindex a9501746a48b4..5ec8dfaa2f725 100644\n--- a/frontend/src/lib/components/DateFilter/DateFilter.tsx\n+++ b/frontend/src/lib/components/DateFilter/DateFilter.tsx\n@@ -24,6 +24,7 @@ import { ResolvedDateRangeResponse } from '~/queries/schema/schema-general'\n import { DateMappingOption, PropertyOperator } from '~/types'\n \n import { PropertyFilterDatePicker } from '../PropertyFilters/components/PropertyFilterDatePicker'\n+import { FixedRangeWithTimePicker } from './FixedRangeWithTimePicker'\n import { RollingDateRangeFilter } from './RollingDateRangeFilter'\n import { dateFilterLogic } from './dateFilterLogic'\n import { DateOption } from './rollingDateRangeFilterLogic'\n@@ -54,6 +55,7 @@ interface RawDateFilterProps extends DateFilterProps {\n     max?: number | null\n     allowedRollingDateOptions?: DateOption[]\n     allowTimePrecision?: boolean\n+    allowFixedRangeWithTime?: boolean\n     /**\n      * Granularity is picked based on the dateFrom value\n      * but can be overridden to force a specific granularity.\n@@ -82,6 +84,7 @@ export function DateFilter({\n     isFixedDateMode = false,\n     allowedRollingDateOptions,\n     allowTimePrecision = false,\n+    allowFixedRangeWithTime = false,\n     placeholder,\n     fullWidth = false,\n     forceGranularity,\n@@ -105,6 +108,7 @@ export function DateFilter({\n     const {\n         open,\n         openFixedRange,\n+        openFixedRangeWithTime,\n         openDateToNow,\n         openFixedDate,\n         close,\n@@ -121,6 +125,7 @@ export function DateFilter({\n         rangeDateTo,\n         label,\n         isFixedRange,\n+        isFixedRangeWithTime,\n         isDateToNow,\n         isFixedDate,\n         isRollingDateRange,\n@@ -146,6 +151,13 @@ export function DateFilter({\n                 onClose={open}\n                 months={2}\n             />\n+        ) : view === DateFilterView.FixedRangeWithTime ? (\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={rangeDateFrom}\n+                rangeDateTo={rangeDateTo}\n+                setDate={setDate}\n+                onClose={open}\n+            />\n         ) : view === DateFilterView.DateToNow ? (\n             <LemonCalendarSelect\n                 value={rangeDateFrom ?? dayjs()}\n@@ -246,9 +258,14 @@ export function DateFilter({\n                         <LemonButton onClick={openDateToNow} active={isDateToNow} fullWidth>\n                             From custom date until now\u2026\n                         </LemonButton>\n-                        <LemonButton onClick={openFixedRange} active={isFixedRange} fullWidth>\n+                        <LemonButton onClick={openFixedRange} active={isFixedRange && !isFixedRangeWithTime} fullWidth>\n                             Custom fixed date range\u2026\n                         </LemonButton>\n+                        {allowFixedRangeWithTime && (\n+                            <LemonButton onClick={openFixedRangeWithTime} active={isFixedRangeWithTime} fullWidth>\n+                                Custom fixed date range with time\u2026\n+                            </LemonButton>\n+                        )}\n                     </>\n                 )}\n                 {showExplicitDateToggle && (\ndiff --git a/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.test.tsx b/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.test.tsx\nnew file mode 100644\nindex 0000000000000..891363886c69e\n--- /dev/null\n+++ b/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.test.tsx\n@@ -0,0 +1,127 @@\n+import '@testing-library/jest-dom'\n+import { render, screen, within } from '@testing-library/react'\n+import userEvent from '@testing-library/user-event'\n+\n+import { dayjs } from 'lib/dayjs'\n+\n+import { FixedRangeWithTimePicker } from './FixedRangeWithTimePicker'\n+\n+describe('FixedRangeWithTimePicker', () => {\n+    const setDate = jest.fn()\n+    const onClose = jest.fn()\n+\n+    beforeEach(() => {\n+        jest.clearAllMocks()\n+    })\n+\n+    it('renders header', () => {\n+        render(<FixedRangeWithTimePicker rangeDateFrom={null} rangeDateTo={null} setDate={setDate} onClose={onClose} />)\n+\n+        expect(screen.getByText(/select a date and time range/i)).toBeInTheDocument()\n+    })\n+\n+    it('renders Start and End buttons', () => {\n+        render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T10:00:00')}\n+                rangeDateTo={dayjs('2024-01-15T11:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        expect(screen.getAllByText(/start:/i).length).toBeGreaterThan(0)\n+        expect(screen.getAllByText(/end:/i).length).toBeGreaterThan(0)\n+    })\n+\n+    it('calls onClose when close button is clicked', () => {\n+        const { container } = render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T10:00:00')}\n+                rangeDateTo={dayjs('2024-01-15T11:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        const closeButton = container.querySelector('[aria-label=\"close\"]') as HTMLElement\n+        expect(closeButton).toBeTruthy()\n+        userEvent.click(closeButton)\n+        expect(onClose).toHaveBeenCalled()\n+    })\n+\n+    it('calls setDate with ISO format when Apply is clicked', () => {\n+        const { container } = render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T10:00:00')}\n+                rangeDateTo={dayjs('2024-01-15T11:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        const footer = container.querySelector('[data-attr=\"lemon-calendar-range-with-time-footer\"]') as HTMLElement\n+        userEvent.click(within(footer).getByText(/apply/i))\n+        expect(setDate).toHaveBeenCalledWith('2024-01-15T10:00:00', '2024-01-15T11:00:00', false, true)\n+    })\n+\n+    it('swaps dates on Apply if start is after end', () => {\n+        const { container } = render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T14:00:00')}\n+                rangeDateTo={dayjs('2024-01-15T10:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        const footer = container.querySelector('[data-attr=\"lemon-calendar-range-with-time-footer\"]') as HTMLElement\n+        userEvent.click(within(footer).getByText(/apply/i))\n+        expect(setDate).toHaveBeenCalledWith('2024-01-15T10:00:00', '2024-01-15T14:00:00', false, true)\n+    })\n+\n+    it('preserves PM time when initialized with PM', () => {\n+        const { container } = render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T14:30:00')}\n+                rangeDateTo={dayjs('2024-01-15T16:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        const footer = container.querySelector('[data-attr=\"lemon-calendar-range-with-time-footer\"]') as HTMLElement\n+        userEvent.click(within(footer).getByText(/apply/i))\n+        expect(setDate).toHaveBeenCalledWith('2024-01-15T14:30:00', '2024-01-15T16:00:00', false, true)\n+    })\n+\n+    it('adjusts end time when start hour is changed to be after end', () => {\n+        const { container } = render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T10:00:00')}\n+                rangeDateTo={dayjs('2024-01-15T11:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        // Click on hour 12 (PM) - this should be after the end time of 11:00 AM\n+        const hourButton = container.querySelector('[data-attr=\"12-h\"]') as HTMLElement\n+        expect(hourButton).toBeTruthy()\n+        userEvent.click(hourButton)\n+\n+        // Click PM to make it 12 PM (noon)\n+        const pmButton = container.querySelector('[data-attr=\"pm-a\"]') as HTMLElement\n+        expect(pmButton).toBeTruthy()\n+        userEvent.click(pmButton)\n+\n+        // Apply and verify end was adjusted (start 12:00 PM, end should be 1:00 PM)\n+        const footer = container.querySelector('[data-attr=\"lemon-calendar-range-with-time-footer\"]') as HTMLElement\n+        userEvent.click(within(footer).getByText(/apply/i))\n+\n+        // The handleApply swaps if needed, so result should be valid\n+        expect(setDate).toHaveBeenCalled()\n+        const [from, to] = setDate.mock.calls[0]\n+        expect(dayjs(from).isBefore(dayjs(to))).toBe(true)\n+    })\n+})\ndiff --git a/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.tsx b/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.tsx\nnew file mode 100644\nindex 0000000000000..bb8af28af6517\n--- /dev/null\n+++ b/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.tsx\n@@ -0,0 +1,147 @@\n+import { useState } from 'react'\n+\n+import { IconX } from '@posthog/icons'\n+import { LemonButton } from '@posthog/lemon-ui'\n+\n+import { dayjs } from 'lib/dayjs'\n+import { LemonCalendar } from 'lib/lemon-ui/LemonCalendar/LemonCalendar'\n+\n+export interface FixedRangeWithTimePickerProps {\n+    rangeDateFrom: dayjs.Dayjs | null\n+    rangeDateTo: dayjs.Dayjs | null\n+    setDate: (dateFrom: string | null, dateTo: string | null, keepPopoverOpen: boolean, explicitDate: boolean) => void\n+    onClose: () => void\n+}\n+\n+export function FixedRangeWithTimePicker({\n+    rangeDateFrom,\n+    rangeDateTo,\n+    setDate,\n+    onClose,\n+}: FixedRangeWithTimePickerProps): JSX.Element {\n+    const [selectingStart, setSelectingStart] = useState(true)\n+    const [localFrom, setLocalFrom] = useState<dayjs.Dayjs | null>(rangeDateFrom)\n+    const [localTo, setLocalTo] = useState<dayjs.Dayjs | null>(rangeDateTo)\n+\n+    const handleApply = (): void => {\n+        if (localFrom && localTo) {\n+            const [from, to] = localFrom.isBefore(localTo) ? [localFrom, localTo] : [localTo, localFrom]\n+            setDate(from.format('YYYY-MM-DDTHH:mm:ss'), to.format('YYYY-MM-DDTHH:mm:ss'), false, true)\n+        }\n+    }\n+\n+    return (\n+        <div className=\"LemonCalendarRangeWithTime\" data-attr=\"lemon-calendar-range-with-time\">\n+            <div className=\"flex justify-between border-b p-2 pb-4\">\n+                <h3 className=\"text-base mb-0\">Select a date and time range</h3>\n+                <LemonButton icon={<IconX />} size=\"small\" noPadding onClick={onClose} aria-label=\"close\" />\n+            </div>\n+            <div className=\"flex gap-2 p-2 border-b\">\n+                <LemonButton\n+                    type={selectingStart ? 'primary' : 'secondary'}\n+                    size=\"small\"\n+                    onClick={() => setSelectingStart(true)}\n+                >\n+                    Start: {localFrom ? localFrom.format('MMM D, YYYY h:mm A') : 'Not set'}\n+                </LemonButton>\n+                <LemonButton\n+                    type={!selectingStart ? 'primary' : 'secondary'}\n+                    size=\"small\"\n+                    onClick={() => setSelectingStart(false)}\n+                >\n+                    End: {localTo ? localTo.format('MMM D, YYYY h:mm A') : 'Not set'}\n+                </LemonButton>\n+            </div>\n+            <div className=\"p-2\">\n+                <LemonCalendar\n+                    onDateClick={(date) => {\n+                        if (date) {\n+                            const currentValue = selectingStart ? localFrom : localTo\n+                            const newDate = date\n+                                .hour(currentValue?.hour() ?? dayjs().hour())\n+                                .minute(currentValue?.minute() ?? dayjs().minute())\n+\n+                            if (selectingStart) {\n+                                setLocalFrom(newDate)\n+                                // Auto-set end to 1 hour later if not set or if new start is after current end\n+                                if (!localTo || newDate.isAfter(localTo)) {\n+                                    setLocalTo(newDate.add(1, 'hour'))\n+                                }\n+                            } else {\n+                                // If end date is before start, swap them\n+                                if (localFrom && newDate.isBefore(localFrom)) {\n+                                    setLocalTo(localFrom)\n+                                    setLocalFrom(newDate)\n+                                } else {\n+                                    setLocalTo(newDate)\n+                                }\n+                            }\n+                        }\n+                    }}\n+                    leftmostMonth={(selectingStart ? localFrom : localTo)?.startOf('month')}\n+                    getLemonButtonProps={({ date, props }) => {\n+                        const currentValue = selectingStart ? localFrom : localTo\n+                        if (date.isSame(currentValue, 'd')) {\n+                            return { ...props, status: 'default', type: 'primary' }\n+                        }\n+                        return props\n+                    }}\n+                    getLemonButtonTimeProps={(timeProps) => {\n+                        const currentValue = selectingStart ? localFrom : localTo\n+                        const selected = currentValue ? currentValue.format(timeProps.unit) : null\n+\n+                        return {\n+                            active: selected === String(timeProps.value),\n+                            className: 'rounded-none',\n+                            'data-attr': `${timeProps.value}-${timeProps.unit}`,\n+                            onClick: () => {\n+                                if (currentValue) {\n+                                    let newDate = currentValue\n+                                    if (timeProps.unit === 'h') {\n+                                        const isPM = currentValue.format('a') === 'pm'\n+                                        newDate = currentValue.hour(\n+                                            isPM && timeProps.value !== 12\n+                                                ? Number(timeProps.value) + 12\n+                                                : !isPM && timeProps.value === 12\n+                                                  ? 0\n+                                                  : Number(timeProps.value)\n+                                        )\n+                                    } else if (timeProps.unit === 'm') {\n+                                        newDate = currentValue.minute(Number(timeProps.value))\n+                                    } else if (timeProps.unit === 'a') {\n+                                        const currentHour = currentValue.hour()\n+                                        if (timeProps.value === 'am' && currentHour >= 12) {\n+                                            newDate = currentValue.subtract(12, 'hour')\n+                                        } else if (timeProps.value === 'pm' && currentHour < 12) {\n+                                            newDate = currentValue.add(12, 'hour')\n+                                        }\n+                                    }\n+                                    if (selectingStart) {\n+                                        setLocalFrom(newDate)\n+                                        if (localTo && newDate.isAfter(localTo)) {\n+                                            setLocalTo(newDate.add(1, 'hour'))\n+                                        }\n+                                    } else {\n+                                        setLocalTo(newDate)\n+                                        if (localFrom && newDate.isBefore(localFrom)) {\n+                                            setLocalFrom(newDate.subtract(1, 'hour'))\n+                                        }\n+                                    }\n+                                }\n+                            },\n+                        }\n+                    }}\n+                    granularity=\"minute\"\n+                />\n+            </div>\n+            <div className=\"flex justify-end gap-2 border-t p-2 pt-4\" data-attr=\"lemon-calendar-range-with-time-footer\">\n+                <LemonButton type=\"secondary\" onClick={onClose}>\n+                    Cancel\n+                </LemonButton>\n+                <LemonButton type=\"primary\" disabled={!localFrom || !localTo} onClick={handleApply}>\n+                    Apply\n+                </LemonButton>\n+            </div>\n+        </div>\n+    )\n+}\ndiff --git a/frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts b/frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts\nindex 97341a08aaeaa..dd811b8985856 100644\n--- a/frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts\n+++ b/frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts\n@@ -41,6 +41,11 @@ describe('dateFilterLogic', () => {\n             isVisible: true,\n             view: DateFilterView.FixedRange,\n         })\n+        logic.actions.openFixedRangeWithTime()\n+        await expectLogic(logic).toMatchValues({\n+            isVisible: true,\n+            view: DateFilterView.FixedRangeWithTime,\n+        })\n         logic.actions.openDateToNow()\n         await expectLogic(logic).toMatchValues({\n             isVisible: true,\n@@ -53,6 +58,86 @@ describe('dateFilterLogic', () => {\n         })\n     })\n \n+    it('isFixedRangeWithTime is true when both dates have time precision', async () => {\n+        props = {\n+            key: 'test-time-precision',\n+            onChange,\n+            dateFrom: '2024-01-15T10:30:00',\n+            dateTo: '2024-01-16T14:45:00',\n+            dateOptions: dateMapping,\n+            isDateFormatted: false,\n+        }\n+        const withTimePrecision = dateFilterLogic(props)\n+        withTimePrecision.mount()\n+\n+        await expectLogic(withTimePrecision).toMatchValues({\n+            isFixedRange: true,\n+            isFixedRangeWithTime: true,\n+            dateFromHasTimePrecision: true,\n+            dateToHasTimePrecision: true,\n+        })\n+    })\n+\n+    it('isFixedRangeWithTime is false when dates have no time precision', async () => {\n+        props = {\n+            key: 'test-no-time-precision',\n+            onChange,\n+            dateFrom: '2024-01-15',\n+            dateTo: '2024-01-16',\n+            dateOptions: dateMapping,\n+            isDateFormatted: false,\n+        }\n+        const withoutTimePrecision = dateFilterLogic(props)\n+        withoutTimePrecision.mount()\n+\n+        await expectLogic(withoutTimePrecision).toMatchValues({\n+            isFixedRange: true,\n+            isFixedRangeWithTime: false,\n+            dateFromHasTimePrecision: false,\n+            dateToHasTimePrecision: false,\n+        })\n+    })\n+\n+    it('isFixedRangeWithTime is true when only dateFrom has time precision', async () => {\n+        props = {\n+            key: 'test-from-time-precision',\n+            onChange,\n+            dateFrom: '2024-01-15T10:30:00',\n+            dateTo: '2024-01-16',\n+            dateOptions: dateMapping,\n+            isDateFormatted: false,\n+        }\n+        const withFromTimePrecision = dateFilterLogic(props)\n+        withFromTimePrecision.mount()\n+\n+        await expectLogic(withFromTimePrecision).toMatchValues({\n+            isFixedRange: true,\n+            isFixedRangeWithTime: true,\n+            dateFromHasTimePrecision: true,\n+            dateToHasTimePrecision: false,\n+        })\n+    })\n+\n+    it('isFixedRangeWithTime is true when only dateTo has time precision', async () => {\n+        props = {\n+            key: 'test-to-time-precision',\n+            onChange,\n+            dateFrom: '2024-01-15',\n+            dateTo: '2024-01-16T14:45:00',\n+            dateOptions: dateMapping,\n+            isDateFormatted: false,\n+        }\n+        const withToTimePrecision = dateFilterLogic(props)\n+        withToTimePrecision.mount()\n+\n+        await expectLogic(withToTimePrecision).toMatchValues({\n+            isFixedRange: true,\n+            isFixedRangeWithTime: true,\n+            dateFromHasTimePrecision: false,\n+            dateToHasTimePrecision: true,\n+        })\n+    })\n+\n     it('can set the date range', async () => {\n         props = {\n             key: 'test',\ndiff --git a/frontend/src/lib/components/DateFilter/dateFilterLogic.ts b/frontend/src/lib/components/DateFilter/dateFilterLogic.ts\nindex f42779f2cfaeb..a669ec454bf13 100644\n--- a/frontend/src/lib/components/DateFilter/dateFilterLogic.ts\n+++ b/frontend/src/lib/components/DateFilter/dateFilterLogic.ts\n@@ -28,6 +28,7 @@ export const dateFilterLogic = kea<dateFilterLogicType>([\n     actions({\n         open: true,\n         openFixedRange: true,\n+        openFixedRangeWithTime: true,\n         openDateToNow: true,\n         openFixedDate: true,\n         close: true,\n@@ -53,6 +54,7 @@ export const dateFilterLogic = kea<dateFilterLogicType>([\n             {\n                 open: () => DateFilterView.QuickList,\n                 openFixedRange: () => DateFilterView.FixedRange,\n+                openFixedRangeWithTime: () => DateFilterView.FixedRangeWithTime,\n                 openDateToNow: () => DateFilterView.DateToNow,\n                 openFixedDate: () => DateFilterView.FixedDate,\n             },\n@@ -62,6 +64,7 @@ export const dateFilterLogic = kea<dateFilterLogicType>([\n             {\n                 open: () => true,\n                 openFixedRange: () => true,\n+                openFixedRangeWithTime: () => true,\n                 openDateToNow: () => true,\n                 openFixedDate: () => true,\n                 setDate: (_, { keepPopoverOpen }) => keepPopoverOpen,\n@@ -109,6 +112,11 @@ export const dateFilterLogic = kea<dateFilterLogicType>([\n             (s) => [s.dateFrom, s.dateTo],\n             (dateFrom, dateTo) => !!(dateFrom && dateTo && dayjs(dateFrom).isValid() && dayjs(dateTo).isValid()),\n         ],\n+        isFixedRangeWithTime: [\n+            (s) => [s.isFixedRange, s.dateFromHasTimePrecision, s.dateToHasTimePrecision],\n+            (isFixedRange, dateFromHasTimePrecision, dateToHasTimePrecision) =>\n+                isFixedRange && (dateFromHasTimePrecision || dateToHasTimePrecision),\n+        ],\n         isDateToNow: [\n             (s) => [s.dateFrom, s.dateTo, (_, p) => p.isFixedDateMode],\n             (dateFrom, dateTo, isFixedDateMode) =>\ndiff --git a/frontend/src/lib/components/DateFilter/types.ts b/frontend/src/lib/components/DateFilter/types.ts\nindex 665c34713bef3..8ae0f75a8e28f 100644\n--- a/frontend/src/lib/components/DateFilter/types.ts\n+++ b/frontend/src/lib/components/DateFilter/types.ts\n@@ -6,6 +6,7 @@ export enum DateFilterView {\n     QuickList = 'QuickList',\n     DateToNow = 'DateToNow',\n     FixedRange = 'FixedRange',\n+    FixedRangeWithTime = 'FixedRangeWithTime',\n     FixedDate = 'FixedDate',\n }\n \n@@ -19,6 +20,7 @@ export type DateFilterLogicProps = {\n     isFixedDateMode?: boolean\n     placeholder?: string\n     allowTimePrecision?: boolean\n+    allowFixedRangeWithTime?: boolean\n     explicitDate?: boolean\n }\n \ndiff --git a/products/logs/frontend/filters/DateRangeFilter.tsx b/products/logs/frontend/filters/DateRangeFilter.tsx\nindex 3967f03a6a010..fe263d35f376b 100644\n--- a/products/logs/frontend/filters/DateRangeFilter.tsx\n+++ b/products/logs/frontend/filters/DateRangeFilter.tsx\n@@ -67,6 +67,7 @@ export const DateRangeFilter = (): JSX.Element => {\n                 setDateRange({ date_from: changedDateFrom, date_to: changedDateTo })\n             }}\n             allowTimePrecision\n+            allowFixedRangeWithTime\n             allowedRollingDateOptions={['minutes', 'hours', 'days', 'weeks', 'months']}\n         />\n     )\n",
        "pr_mirror": "PostHog__posthog.main"
    }
}