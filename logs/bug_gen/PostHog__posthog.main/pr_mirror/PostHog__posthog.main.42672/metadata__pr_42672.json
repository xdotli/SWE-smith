{
    "cost": 0.08930000000000002,
    "rewrites": {
        "PostHog__posthog.main/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts": {
            "output": "import { resetContext } from 'kea'\nimport { expectLogic, partial, testUtilsPlugin } from 'kea-test-utils'\n\nimport { uuid } from 'lib/utils'\n\nimport { initKeaTests } from '~/test/init'\n\nimport { workflowLogic } from '../../workflowLogic'\nimport { HogFlowAction } from '../types'\nimport { getWaitUntilTimeWindowDescription, stepWaitUntilTimeWindowLogic } from './stepWaitUntilTimeWindowLogic'\n\ndescribe('stepWaitUntilTimeWindowLogic', () => {\n    let logic: ReturnType<typeof stepWaitUntilTimeWindowLogic.build>\n\n    beforeEach(() => {\n        initKeaTests()\n\n        resetContext({\n            plugins: [testUtilsPlugin],\n        })\n\n        workflowLogic.mount()\n\n        logic = stepWaitUntilTimeWindowLogic({ workflowLogicProps: workflowLogic.props })\n        logic.mount()\n    })\n\n    const setupInitialAction = async (initialDescription: string): Promise<HogFlowAction> => {\n        const action = {\n            id: `wait_action_${uuid()}`,\n            type: 'wait_until_time_window',\n            name: 'Wait until time window',\n            description: initialDescription,\n            config: { day: 'weekday', time: ['09:00', '17:00'], timezone: 'UTC' },\n            created_at: Date.now(),\n            updated_at: Date.now(),\n        } as HogFlowAction\n\n        await expectLogic(workflowLogic, () => {\n            workflowLogic.actions.setWorkflowInfo({\n                actions: [...workflowLogic.values.workflow.actions, action],\n            })\n        }).toDispatchActions(['setWorkflowInfo'])\n\n        await expectLogic(workflowLogic).toMatchValues({\n            workflow: partial({\n                actions: expect.arrayContaining([expect.objectContaining({ description: initialDescription })]),\n            }),\n        })\n\n        return action\n    }\n    it('should update the description when day is changed', async () => {\n        const initialDesc = getWaitUntilTimeWindowDescription('weekday', ['09:00', '17:00'], 'UTC')\n        const action = await setupInitialAction(initialDesc)\n\n        await expectLogic(logic, () => {\n            logic.actions.partialSetWaitUntilTimeWindowConfig(action.id, { day: 'weekend' })\n        })\n            .toDispatchActions(['partialSetWorkflowActionConfig'])\n            .toFinishListeners()\n\n        await expectLogic(logic).toMatchValues({\n            workflow: partial({\n                actions: expect.arrayContaining([\n                    expect.objectContaining({\n                        description: 'Wait until weekends at between 09:00 and 17:00 (UTC).',\n                    }),\n                ]),\n            }),\n        })\n    })\n\n    it('should update the description when time is changed', async () => {\n        const initialDesc = getWaitUntilTimeWindowDescription('weekday', ['09:00', '17:00'], 'UTC')\n        const action = await setupInitialAction(initialDesc)\n\n        await expectLogic(logic, () => {\n            logic.actions.partialSetWaitUntilTimeWindowConfig(action.id, { time: ['10:00', '18:00'] })\n        })\n            .toDispatchActions(['partialSetWorkflowActionConfig'])\n            .toFinishListeners()\n\n        await expectLogic(logic).toMatchValues({\n            workflow: partial({\n                actions: expect.arrayContaining([\n                    expect.objectContaining({\n                        description: 'Wait until weekdays at between 10:00 and 18:00 (UTC).',\n                    }),\n                ]),\n            }),\n        })\n    })\n\n    it('should update the description when timezone is changed', async () => {\n        const initialDesc = getWaitUntilTimeWindowDescription('weekday', ['09:00', '17:00'], 'UTC')\n        const action = await setupInitialAction(initialDesc)\n\n        await expectLogic(logic, () => {\n            logic.actions.partialSetWaitUntilTimeWindowConfig(action.id, { timezone: 'America/New_York' })\n        })\n            .toDispatchActions(['partialSetWorkflowActionConfig'])\n            .toFinishListeners()\n\n        await expectLogic(logic).toMatchValues({\n            workflow: partial({\n                actions: expect.arrayContaining([\n                    expect.objectContaining({\n                        description: 'Wait until weekdays at between 09:00 and 17:00 (America/New_York).',\n                    }),\n                ]),\n            }),\n        })\n    })\n\n    it('should not update the description when the description is customized', async () => {\n        const customDescription = 'Custom description, dont delete me pls :('\n        const action = await setupInitialAction(customDescription)\n\n        await expectLogic(logic, () => {\n            logic.actions.partialSetWaitUntilTimeWindowConfig(action.id, { day: 'weekend' })\n        })\n            .toDispatchActions(['partialSetWorkflowActionConfig'])\n            .toFinishListeners()\n\n        await expectLogic(logic).toMatchValues({\n            workflow: partial({\n                actions: expect.arrayContaining([expect.objectContaining({ description: customDescription })]),\n            }),\n        })\n    })\n})",
            "output_extracted": "import { resetContext } from 'kea'\nimport { expectLogic, partial, testUtilsPlugin } from 'kea-test-utils'\n\nimport { uuid } from 'lib/utils'\n\nimport { initKeaTests } from '~/test/init'\n\nimport { workflowLogic } from '../../workflowLogic'\nimport { HogFlowAction } from '../types'\nimport { getWaitUntilTimeWindowDescription, stepWaitUntilTimeWindowLogic } from './stepWaitUntilTimeWindowLogic'\n\ndescribe('stepWaitUntilTimeWindowLogic', () => {\n    let logic: ReturnType<typeof stepWaitUntilTimeWindowLogic.build>\n\n    beforeEach(() => {\n        initKeaTests()\n\n        resetContext({\n            plugins: [testUtilsPlugin],\n        })\n\n        workflowLogic.mount()\n\n        logic = stepWaitUntilTimeWindowLogic({ workflowLogicProps: workflowLogic.props })\n        logic.mount()\n    })\n\n    const setupInitialAction = async (initialDescription: string): Promise<HogFlowAction> => {\n        const action = {\n            id: `wait_action_${uuid()}`,\n            type: 'wait_until_time_window',\n            name: 'Wait until time window',\n            description: initialDescription,\n            config: { day: 'weekday', time: ['09:00', '17:00'], timezone: 'UTC' },\n            created_at: Date.now(),\n            updated_at: Date.now(),\n        } as HogFlowAction\n\n        await expectLogic(workflowLogic, () => {\n            workflowLogic.actions.setWorkflowInfo({\n                actions: [...workflowLogic.values.workflow.actions, action],\n            })\n        }).toDispatchActions(['setWorkflowInfo'])\n\n        await expectLogic(workflowLogic).toMatchValues({\n            workflow: partial({\n                actions: expect.arrayContaining([expect.objectContaining({ description: initialDescription })]),\n            }),\n        })\n\n        return action\n    }\n    it('should update the description when day is changed', async () => {\n        const initialDesc = getWaitUntilTimeWindowDescription('weekday', ['09:00', '17:00'], 'UTC')\n        const action = await setupInitialAction(initialDesc)\n\n        await expectLogic(logic, () => {\n            logic.actions.partialSetWaitUntilTimeWindowConfig(action.id, { day: 'weekend' })\n        })\n            .toDispatchActions(['partialSetWorkflowActionConfig'])\n            .toFinishListeners()\n\n        await expectLogic(logic).toMatchValues({\n            workflow: partial({\n                actions: expect.arrayContaining([\n                    expect.objectContaining({\n                        description: 'Wait until weekends at between 09:00 and 17:00 (UTC).',\n                    }),\n                ]),\n            }),\n        })\n    })\n\n    it('should update the description when time is changed', async () => {\n        const initialDesc = getWaitUntilTimeWindowDescription('weekday', ['09:00', '17:00'], 'UTC')\n        const action = await setupInitialAction(initialDesc)\n\n        await expectLogic(logic, () => {\n            logic.actions.partialSetWaitUntilTimeWindowConfig(action.id, { time: ['10:00', '18:00'] })\n        })\n            .toDispatchActions(['partialSetWorkflowActionConfig'])\n            .toFinishListeners()\n\n        await expectLogic(logic).toMatchValues({\n            workflow: partial({\n                actions: expect.arrayContaining([\n                    expect.objectContaining({\n                        description: 'Wait until weekdays at between 10:00 and 18:00 (UTC).',\n                    }),\n                ]),\n            }),\n        })\n    })\n\n    it('should update the description when timezone is changed', async () => {\n        const initialDesc = getWaitUntilTimeWindowDescription('weekday', ['09:00', '17:00'], 'UTC')\n        const action = await setupInitialAction(initialDesc)\n\n        await expectLogic(logic, () => {\n            logic.actions.partialSetWaitUntilTimeWindowConfig(action.id, { timezone: 'America/New_York' })\n        })\n            .toDispatchActions(['partialSetWorkflowActionConfig'])\n            .toFinishListeners()\n\n        await expectLogic(logic).toMatchValues({\n            workflow: partial({\n                actions: expect.arrayContaining([\n                    expect.objectContaining({\n                        description: 'Wait until weekdays at between 09:00 and 17:00 (America/New_York).',\n                    }),\n                ]),\n            }),\n        })\n    })\n\n    it('should not update the description when the description is customized', async () => {\n        const customDescription = 'Custom description, dont delete me pls :('\n        const action = await setupInitialAction(customDescription)\n\n        await expectLogic(logic, () => {\n            logic.actions.partialSetWaitUntilTimeWindowConfig(action.id, { day: 'weekend' })\n        })\n            .toDispatchActions(['partialSetWorkflowActionConfig'])\n            .toFinishListeners()\n\n        await expectLogic(logic).toMatchValues({\n            workflow: partial({\n                actions: expect.arrayContaining([expect.objectContaining({ description: customDescription })]),\n            }),\n        })\n    })\n})",
            "cost": 0.047110000000000006
        },
        "PostHog__posthog.main/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts": {
            "output": "import { actions, connect, kea, key, listeners, path, props } from 'kea'\n\nimport { WeekdayType } from '~/types'\n\nimport { WorkflowLogicProps, workflowLogic } from '../../workflowLogic'\nimport type { stepWaitUntilTimeWindowLogicType } from './stepWaitUntilTimeWindowLogicType'\n\ntype DayConfig = 'any' | 'weekday' | 'weekend' | WeekdayType[]\ntype TimeConfig = 'any' | [string, string]\n\nexport type WaitUntilTimeWindowConfig = {\n    timezone?: string | null\n    day?: DayConfig\n    time?: TimeConfig\n}\n\nconst AUTO_DESCRIPTION_REGEX = /^Wait until .+ at .+ \\(.+\\)\\.$/\nconst LEGACY_DEFAULT_DESCRIPTION = 'Wait until a specified time window.'\n\nfunction capitalize(str: string): string {\n    return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nfunction getDayDescription(day: DayConfig): string {\n    if (day === 'any') {\n        return 'any day'\n    }\n    if (day === 'weekday') {\n        return 'weekdays'\n    }\n    if (day === 'weekend') {\n        return 'weekends'\n    }\n    if (Array.isArray(day)) {\n        if (day.length === 0) {\n            return 'no days'\n        }\n        return day.map(capitalize).join(', ')\n    }\n    return 'any day'\n}\n\nfunction getTimeDescription(time: TimeConfig): string {\n    if (time === 'any') {\n        return 'any time'\n    }\n    if (Array.isArray(time)) {\n        return `between ${time[0]} and ${time[1]}`\n    }\n    return 'any time'\n}\n\nexport function getWaitUntilTimeWindowDescription(day: DayConfig, time: TimeConfig, timezone: string | null): string {\n    const dayDesc = getDayDescription(day)\n    const timeDesc = getTimeDescription(time)\n    const tz = timezone || 'UTC'\n    return `Wait until ${dayDesc} at ${timeDesc} (${tz}).`\n}\n\nexport function shouldAutoUpdateDescription(description: string): boolean {\n    return (\n        description.trim() === '' ||\n        AUTO_DESCRIPTION_REGEX.test(description) ||\n        description === LEGACY_DEFAULT_DESCRIPTION\n    )\n}\n\nexport type StepWaitUntilTimeWindowLogicProps = {\n    workflowLogicProps: WorkflowLogicProps\n}\n\nexport const stepWaitUntilTimeWindowLogic = kea<stepWaitUntilTimeWindowLogicType>([\n    path((key) => [\n        'products',\n        'workflows',\n        'frontend',\n        'Workflows',\n        'hogflows',\n        'steps',\n        'stepWaitUntilTimeWindowLogic',\n        key,\n    ]),\n    props({} as StepWaitUntilTimeWindowLogicProps),\n    key(({ workflowLogicProps }: StepWaitUntilTimeWindowLogicProps) => workflowLogicProps.id || 'new'),\n    connect(({ workflowLogicProps }: StepWaitUntilTimeWindowLogicProps) => ({\n        values: [workflowLogic(workflowLogicProps), ['workflow']],\n        actions: [workflowLogic(workflowLogicProps), ['partialSetWorkflowActionConfig', 'setWorkflowAction']],\n    })),\n    actions({\n        partialSetWaitUntilTimeWindowConfig: (actionId: string, config: WaitUntilTimeWindowConfig) => ({\n            actionId,\n            config,\n        }),\n    }),\n    listeners(({ values, actions }) => ({\n        partialSetWaitUntilTimeWindowConfig: ({ actionId, config }) => {\n            actions.partialSetWorkflowActionConfig(actionId, config)\n\n            const action = values.workflow.actions.find((a) => a.id === actionId)\n            if (!action || action.type !== 'wait_until_time_window') {\n                return\n            }\n\n            const currentConfig = action.config as { day: DayConfig; time: TimeConfig; timezone: string | null }\n            const newDay = config.day ?? currentConfig.day\n            const newTime = config.time ?? currentConfig.time\n            const newTimezone = config.timezone !== undefined ? config.timezone : currentConfig.timezone\n\n            if (shouldAutoUpdateDescription(action.description)) {\n                actions.setWorkflowAction(actionId, {\n                    ...action,\n                    description: getWaitUntilTimeWindowDescription(newDay, newTime, newTimezone),\n                })\n            }\n        },\n    })),\n])",
            "output_extracted": "import { actions, connect, kea, key, listeners, path, props } from 'kea'\n\nimport { WeekdayType } from '~/types'\n\nimport { WorkflowLogicProps, workflowLogic } from '../../workflowLogic'\nimport type { stepWaitUntilTimeWindowLogicType } from './stepWaitUntilTimeWindowLogicType'\n\ntype DayConfig = 'any' | 'weekday' | 'weekend' | WeekdayType[]\ntype TimeConfig = 'any' | [string, string]\n\nexport type WaitUntilTimeWindowConfig = {\n    timezone?: string | null\n    day?: DayConfig\n    time?: TimeConfig\n}\n\nconst AUTO_DESCRIPTION_REGEX = /^Wait until .+ at .+ \\(.+\\)\\.$/\nconst LEGACY_DEFAULT_DESCRIPTION = 'Wait until a specified time window.'\n\nfunction capitalize(str: string): string {\n    return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nfunction getDayDescription(day: DayConfig): string {\n    if (day === 'any') {\n        return 'any day'\n    }\n    if (day === 'weekday') {\n        return 'weekdays'\n    }\n    if (day === 'weekend') {\n        return 'weekends'\n    }\n    if (Array.isArray(day)) {\n        if (day.length === 0) {\n            return 'no days'\n        }\n        return day.map(capitalize).join(', ')\n    }\n    return 'any day'\n}\n\nfunction getTimeDescription(time: TimeConfig): string {\n    if (time === 'any') {\n        return 'any time'\n    }\n    if (Array.isArray(time)) {\n        return `between ${time[0]} and ${time[1]}`\n    }\n    return 'any time'\n}\n\nexport function getWaitUntilTimeWindowDescription(day: DayConfig, time: TimeConfig, timezone: string | null): string {\n    const dayDesc = getDayDescription(day)\n    const timeDesc = getTimeDescription(time)\n    const tz = timezone || 'UTC'\n    return `Wait until ${dayDesc} at ${timeDesc} (${tz}).`\n}\n\nexport function shouldAutoUpdateDescription(description: string): boolean {\n    return (\n        description.trim() === '' ||\n        AUTO_DESCRIPTION_REGEX.test(description) ||\n        description === LEGACY_DEFAULT_DESCRIPTION\n    )\n}\n\nexport type StepWaitUntilTimeWindowLogicProps = {\n    workflowLogicProps: WorkflowLogicProps\n}\n\nexport const stepWaitUntilTimeWindowLogic = kea<stepWaitUntilTimeWindowLogicType>([\n    path((key) => [\n        'products',\n        'workflows',\n        'frontend',\n        'Workflows',\n        'hogflows',\n        'steps',\n        'stepWaitUntilTimeWindowLogic',\n        key,\n    ]),\n    props({} as StepWaitUntilTimeWindowLogicProps),\n    key(({ workflowLogicProps }: StepWaitUntilTimeWindowLogicProps) => workflowLogicProps.id || 'new'),\n    connect(({ workflowLogicProps }: StepWaitUntilTimeWindowLogicProps) => ({\n        values: [workflowLogic(workflowLogicProps), ['workflow']],\n        actions: [workflowLogic(workflowLogicProps), ['partialSetWorkflowActionConfig', 'setWorkflowAction']],\n    })),\n    actions({\n        partialSetWaitUntilTimeWindowConfig: (actionId: string, config: WaitUntilTimeWindowConfig) => ({\n            actionId,\n            config,\n        }),\n    }),\n    listeners(({ values, actions }) => ({\n        partialSetWaitUntilTimeWindowConfig: ({ actionId, config }) => {\n            actions.partialSetWorkflowActionConfig(actionId, config)\n\n            const action = values.workflow.actions.find((a) => a.id === actionId)\n            if (!action || action.type !== 'wait_until_time_window') {\n                return\n            }\n\n            const currentConfig = action.config as { day: DayConfig; time: TimeConfig; timezone: string | null }\n            const newDay = config.day ?? currentConfig.day\n            const newTime = config.time ?? currentConfig.time\n            const newTimezone = config.timezone !== undefined ? config.timezone : currentConfig.timezone\n\n            if (shouldAutoUpdateDescription(action.description)) {\n                actions.setWorkflowAction(actionId, {\n                    ...action,\n                    description: getWaitUntilTimeWindowDescription(newDay, newTime, newTimezone),\n                })\n            }\n        },\n    })),\n])",
            "cost": 0.042190000000000005
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "PostHog__posthog.main.42672",
        "repo": "PostHog/posthog",
        "base_commit": "3f92060317c7f47ed200f8300af0752c657769cb",
        "head_commit": "1aff155621ed5e993a0504d23c16a605db0ec9c8",
        "title": "chore: Fix phrasing (\"at between time and time\" to \"between time and time\")",
        "merged_at": "2025-12-04T12:09:22Z",
        "html_url": "https://github.com/PostHog/posthog/pull/42672",
        "test_files": [
            "products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts"
        ],
        "code_files": [
            "products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts"
        ],
        "total_changes": 12,
        "num_files": 2,
        "pull_number": 42672,
        "patch": "diff --git a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts\nindex d978403e2e384..5ef12bf3fa00d 100644\n--- a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts\n+++ b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts\n@@ -64,7 +64,7 @@ describe('stepWaitUntilTimeWindowLogic', () => {\n             workflow: partial({\n                 actions: expect.arrayContaining([\n                     expect.objectContaining({\n-                        description: 'Wait until weekends at between 09:00 and 17:00 (UTC).',\n+                        description: 'Wait until weekends between 09:00 and 17:00 (UTC).',\n                     }),\n                 ]),\n             }),\n@@ -85,7 +85,7 @@ describe('stepWaitUntilTimeWindowLogic', () => {\n             workflow: partial({\n                 actions: expect.arrayContaining([\n                     expect.objectContaining({\n-                        description: 'Wait until weekdays at between 10:00 and 18:00 (UTC).',\n+                        description: 'Wait until weekdays between 10:00 and 18:00 (UTC).',\n                     }),\n                 ]),\n             }),\n@@ -106,7 +106,7 @@ describe('stepWaitUntilTimeWindowLogic', () => {\n             workflow: partial({\n                 actions: expect.arrayContaining([\n                     expect.objectContaining({\n-                        description: 'Wait until weekdays at between 09:00 and 17:00 (America/New_York).',\n+                        description: 'Wait until weekdays between 09:00 and 17:00 (America/New_York).',\n                     }),\n                 ]),\n             }),\ndiff --git a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts\nindex 4ac804559ca2e..db4b641f45681 100644\n--- a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts\n+++ b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts\n@@ -14,7 +14,7 @@ export type WaitUntilTimeWindowConfig = {\n     time?: TimeConfig\n }\n \n-const AUTO_DESCRIPTION_REGEX = /^Wait until .+ at .+ \\(.+\\)\\.$/\n+const AUTO_DESCRIPTION_REGEX = /^Wait until .+ (at any time|between .+ and .+) \\(.+\\)\\.$/\n const LEGACY_DEFAULT_DESCRIPTION = 'Wait until a specified time window.'\n \n function capitalize(str: string): string {\n@@ -54,7 +54,9 @@ export function getWaitUntilTimeWindowDescription(day: DayConfig, time: TimeConf\n     const dayDesc = getDayDescription(day)\n     const timeDesc = getTimeDescription(time)\n     const tz = timezone || 'UTC'\n-    return `Wait until ${dayDesc} at ${timeDesc} (${tz}).`\n+    // Use \"at\" only for \"any time\", otherwise use the time description directly (e.g., \"between X and Y\")\n+    const timeClause = time === 'any' ? `at ${timeDesc}` : timeDesc\n+    return `Wait until ${dayDesc} ${timeClause} (${tz}).`\n }\n \n export function shouldAutoUpdateDescription(description: string): boolean {\n",
        "pr_mirror": "PostHog__posthog.main"
    }
}