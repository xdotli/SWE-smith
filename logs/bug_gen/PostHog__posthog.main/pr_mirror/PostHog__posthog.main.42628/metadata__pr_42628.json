{
    "cost": 0.582755,
    "rewrites": {
        "PostHog__posthog.main/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts": {
            "output": "import { router } from 'kea-router'\nimport { expectLogic } from 'kea-test-utils'\n\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { sceneLogic } from 'scenes/sceneLogic'\nimport { urls } from 'scenes/urls'\n\nimport { Scene } from '~/scenes/sceneTypes'\nimport { initKeaTests } from '~/test/init'\n\nimport { topBarSettingsButtonLogic } from './topBarSettingsButtonLogic'\n\nconst groupsScene = (): any => ({\n    scene: { component: () => null, logic: null, settingSectionId: 'environment-customer-analytics' },\n})\nconst personsScene = (): any => ({\n    scene: { component: () => null, logic: null, settingSectionId: 'environment-product-analytics' },\n})\n\nconst scenes: Record<string, () => any> = {\n    [Scene.Groups]: groupsScene,\n    [Scene.Persons]: personsScene,\n}\n\ndescribe('topBarSettingsButtonLogic', () => {\n    describe('loadedSceneSettingsSectionId selector for environment-customer-analytics', () => {\n        let logic: ReturnType<typeof topBarSettingsButtonLogic.build>\n        let sceneLogicInstance: ReturnType<typeof sceneLogic.build>\n\n        beforeEach(() => {\n            initKeaTests()\n            router.actions.push(urls.groups(0))\n            sceneLogicInstance = sceneLogic({ scenes })\n            sceneLogicInstance.mount()\n\n            logic = topBarSettingsButtonLogic()\n            logic.mount()\n        })\n\n        afterEach(() => {\n            logic?.unmount()\n            sceneLogicInstance?.unmount()\n        })\n\n        it('returns environment-customer-analytics when customer-analytics feature flag is enabled', async () => {\n            featureFlagLogic.actions.setFeatureFlags([], {\n                [FEATURE_FLAGS.CUSTOMER_ANALYTICS]: true,\n            })\n\n            await expectLogic(logic).toMatchValues({\n                loadedSceneSettingsSectionId: 'environment-customer-analytics',\n            })\n        })\n\n        it('returns undefined when customer-analytics feature flag is disabled for environment-customer-analytics', async () => {\n            featureFlagLogic.actions.setFeatureFlags([], {\n                [FEATURE_FLAGS.CUSTOMER_ANALYTICS]: false,\n            })\n\n            await expectLogic(logic).toMatchValues({\n                loadedSceneSettingsSectionId: undefined,\n            })\n        })\n    })\n\n    describe('loadedSceneSettingsSectionId selector for all settingSectionIds', () => {\n        let logic: ReturnType<typeof topBarSettingsButtonLogic.build>\n        let sceneLogicInstance: ReturnType<typeof sceneLogic.build>\n\n        beforeEach(() => {\n            initKeaTests()\n            router.actions.push(urls.persons())\n            sceneLogicInstance = sceneLogic({ scenes })\n            sceneLogicInstance.mount()\n\n            logic = topBarSettingsButtonLogic()\n            logic.mount()\n        })\n\n        afterEach(() => {\n            logic?.unmount()\n            sceneLogicInstance?.unmount()\n        })\n\n        it('returns other setting section IDs regardless of CRM feature flag state', async () => {\n            router.actions.push(urls.persons())\n            featureFlagLogic.actions.setFeatureFlags([], {\n                [FEATURE_FLAGS.CRM_ITERATION_ONE]: false,\n            })\n\n            await expectLogic(logic).toMatchValues({\n                loadedSceneSettingsSectionId: 'environment-product-analytics',\n            })\n\n            featureFlagLogic.actions.setFeatureFlags([], {\n                [FEATURE_FLAGS.CRM_ITERATION_ONE]: true,\n            })\n\n            await expectLogic(logic).toMatchValues({\n                loadedSceneSettingsSectionId: 'environment-product-analytics',\n            })\n        })\n    })\n})",
            "output_extracted": "import { router } from 'kea-router'\nimport { expectLogic } from 'kea-test-utils'\n\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { sceneLogic } from 'scenes/sceneLogic'\nimport { urls } from 'scenes/urls'\n\nimport { Scene } from '~/scenes/sceneTypes'\nimport { initKeaTests } from '~/test/init'\n\nimport { topBarSettingsButtonLogic } from './topBarSettingsButtonLogic'\n\nconst groupsScene = (): any => ({\n    scene: { component: () => null, logic: null, settingSectionId: 'environment-customer-analytics' },\n})\nconst personsScene = (): any => ({\n    scene: { component: () => null, logic: null, settingSectionId: 'environment-product-analytics' },\n})\n\nconst scenes: Record<string, () => any> = {\n    [Scene.Groups]: groupsScene,\n    [Scene.Persons]: personsScene,\n}\n\ndescribe('topBarSettingsButtonLogic', () => {\n    describe('loadedSceneSettingsSectionId selector for environment-customer-analytics', () => {\n        let logic: ReturnType<typeof topBarSettingsButtonLogic.build>\n        let sceneLogicInstance: ReturnType<typeof sceneLogic.build>\n\n        beforeEach(() => {\n            initKeaTests()\n            router.actions.push(urls.groups(0))\n            sceneLogicInstance = sceneLogic({ scenes })\n            sceneLogicInstance.mount()\n\n            logic = topBarSettingsButtonLogic()\n            logic.mount()\n        })\n\n        afterEach(() => {\n            logic?.unmount()\n            sceneLogicInstance?.unmount()\n        })\n\n        it('returns environment-customer-analytics when customer-analytics feature flag is enabled', async () => {\n            featureFlagLogic.actions.setFeatureFlags([], {\n                [FEATURE_FLAGS.CUSTOMER_ANALYTICS]: true,\n            })\n\n            await expectLogic(logic).toMatchValues({\n                loadedSceneSettingsSectionId: 'environment-customer-analytics',\n            })\n        })\n\n        it('returns undefined when customer-analytics feature flag is disabled for environment-customer-analytics', async () => {\n            featureFlagLogic.actions.setFeatureFlags([], {\n                [FEATURE_FLAGS.CUSTOMER_ANALYTICS]: false,\n            })\n\n            await expectLogic(logic).toMatchValues({\n                loadedSceneSettingsSectionId: undefined,\n            })\n        })\n    })\n\n    describe('loadedSceneSettingsSectionId selector for all settingSectionIds', () => {\n        let logic: ReturnType<typeof topBarSettingsButtonLogic.build>\n        let sceneLogicInstance: ReturnType<typeof sceneLogic.build>\n\n        beforeEach(() => {\n            initKeaTests()\n            router.actions.push(urls.persons())\n            sceneLogicInstance = sceneLogic({ scenes })\n            sceneLogicInstance.mount()\n\n            logic = topBarSettingsButtonLogic()\n            logic.mount()\n        })\n\n        afterEach(() => {\n            logic?.unmount()\n            sceneLogicInstance?.unmount()\n        })\n\n        it('returns other setting section IDs regardless of CRM feature flag state', async () => {\n            router.actions.push(urls.persons())\n            featureFlagLogic.actions.setFeatureFlags([], {\n                [FEATURE_FLAGS.CRM_ITERATION_ONE]: false,\n            })\n\n            await expectLogic(logic).toMatchValues({\n                loadedSceneSettingsSectionId: 'environment-product-analytics',\n            })\n\n            featureFlagLogic.actions.setFeatureFlags([], {\n                [FEATURE_FLAGS.CRM_ITERATION_ONE]: true,\n            })\n\n            await expectLogic(logic).toMatchValues({\n                loadedSceneSettingsSectionId: 'environment-product-analytics',\n            })\n        })\n    })\n})",
            "cost": 0.035855
        },
        "PostHog__posthog.main/frontend/src/lib/constants.tsx": {
            "output": "import { LemonSelectOptions } from '@posthog/lemon-ui'\n\nimport { ChartDisplayCategory, ChartDisplayType, Region, SSOProvider } from '../types'\n\n// Sync with backend DISPLAY_TYPES_TO_CATEGORIES\nexport const DISPLAY_TYPES_TO_CATEGORIES: Record<ChartDisplayType, ChartDisplayCategory> = {\n    [ChartDisplayType.ActionsLineGraph]: ChartDisplayCategory.TimeSeries,\n    [ChartDisplayType.ActionsBar]: ChartDisplayCategory.TimeSeries,\n    [ChartDisplayType.ActionsUnstackedBar]: ChartDisplayCategory.TimeSeries,\n    [ChartDisplayType.ActionsStackedBar]: ChartDisplayCategory.TimeSeries,\n    [ChartDisplayType.ActionsAreaGraph]: ChartDisplayCategory.TimeSeries,\n    [ChartDisplayType.ActionsLineGraphCumulative]: ChartDisplayCategory.CumulativeTimeSeries,\n    [ChartDisplayType.BoldNumber]: ChartDisplayCategory.TotalValue,\n    [ChartDisplayType.ActionsPie]: ChartDisplayCategory.TotalValue,\n    [ChartDisplayType.ActionsBarValue]: ChartDisplayCategory.TotalValue,\n    [ChartDisplayType.ActionsTable]: ChartDisplayCategory.TotalValue,\n    [ChartDisplayType.WorldMap]: ChartDisplayCategory.TotalValue,\n    [ChartDisplayType.CalendarHeatmap]: ChartDisplayCategory.TotalValue,\n}\nexport const NON_TIME_SERIES_DISPLAY_TYPES = Object.entries(DISPLAY_TYPES_TO_CATEGORIES)\n    .filter(([, category]) => category === ChartDisplayCategory.TotalValue)\n    .map(([displayType]) => displayType as ChartDisplayType)\n\n/** Display types for which `breakdown` is hidden and ignored. Sync with backend NON_BREAKDOWN_DISPLAY_TYPES. */\nexport const NON_BREAKDOWN_DISPLAY_TYPES = [ChartDisplayType.BoldNumber, ChartDisplayType.CalendarHeatmap]\n/** Display types which only work with a single series. */\nexport const SINGLE_SERIES_DISPLAY_TYPES = [\n    ChartDisplayType.WorldMap,\n    ChartDisplayType.BoldNumber,\n    ChartDisplayType.CalendarHeatmap,\n]\n\nexport const NON_VALUES_ON_SERIES_DISPLAY_TYPES = [\n    ChartDisplayType.ActionsTable,\n    ChartDisplayType.WorldMap,\n    ChartDisplayType.BoldNumber,\n    ChartDisplayType.CalendarHeatmap,\n]\n\n/** Display types for which a percent stack view is available. */\nexport const PERCENT_STACK_VIEW_DISPLAY_TYPE = [\n    ChartDisplayType.ActionsBar,\n    ChartDisplayType.ActionsAreaGraph,\n    ChartDisplayType.ActionsPie,\n]\n\nexport enum OrganizationMembershipLevel {\n    Member = 1,\n    Admin = 8,\n    Owner = 15,\n}\n\nexport enum TeamMembershipLevel {\n    Member = 1,\n    Admin = 8,\n}\n\nexport type EitherMembershipLevel = OrganizationMembershipLevel | TeamMembershipLevel\n\n/** See posthog/api/organization.py for details. */\nexport enum PluginsAccessLevel {\n    None = 0,\n    Config = 3,\n    Install = 6,\n    Root = 9,\n}\n\n/** Collaboration restriction level (which is a dashboard setting). Sync with DashboardPrivilegeLevel. */\nexport enum DashboardRestrictionLevel {\n    EveryoneInProjectCanEdit = 21,\n    OnlyCollaboratorsCanEdit = 37,\n}\n\n/** Collaboration privilege level (which is a user property). Sync with DashboardRestrictionLevel. */\nexport enum DashboardPrivilegeLevel {\n    CanView = 21,\n    CanEdit = 37,\n    /** This is not a value that can be set in the DB \u2013 it's inferred. */\n    _ProjectAdmin = 888,\n    /** This is not a value that can be set in the DB \u2013 it's inferred. */\n    _Owner = 999,\n}\n\nexport const privilegeLevelToName: Record<DashboardPrivilegeLevel, string> = {\n    [DashboardPrivilegeLevel.CanView]: 'can view',\n    [DashboardPrivilegeLevel.CanEdit]: 'can edit',\n    [DashboardPrivilegeLevel._Owner]: 'owner',\n    [DashboardPrivilegeLevel._ProjectAdmin]: 'can edit',\n}\n\n// Persons\nexport const PERSON_DISTINCT_ID_MAX_SIZE = 3\nexport const PERSON_DISPLAY_NAME_COLUMN_NAME = 'person_display_name -- Person'\n\n// Sync with .../api/person.py and .../ingestion/webhook-formatter.ts\nexport const PERSON_DEFAULT_DISPLAY_NAME_PROPERTIES = [\n    'email',\n    'Email',\n    '$email',\n    'name',\n    'Name',\n    'username',\n    'Username',\n    'UserName',\n]\n\n// Feature Flags & Experiments\nexport const INSTANTLY_AVAILABLE_PROPERTIES = [\n    '$geoip_city_name',\n    '$geoip_country_name',\n    '$geoip_country_code',\n    '$geoip_continent_name',\n    '$geoip_continent_code',\n    '$geoip_postal_code',\n    '$geoip_time_zone',\n    // Person and group identifiers\n    '$group_key',\n    'distinct_id',\n]\nexport const MAX_EXPERIMENT_VARIANTS = 20\nexport const EXPERIMENT_DEFAULT_DURATION = 14 // days\n\n// Event constants\nexport const ACTION_TYPE = 'action_type'\nexport const EVENT_TYPE = 'event_type'\nexport const STALE_EVENT_SECONDS = 30 * 24 * 60 * 60 // 30 days\n\n/**\n * @deprecated should be removed once backend is updated\n */\nexport enum ShownAsValue {\n    VOLUME = 'Volume',\n    STICKINESS = 'Stickiness',\n    LIFECYCLE = 'Lifecycle',\n}\n\n// Retention constants\nexport const RETENTION_RECURRING = 'retention_recurring'\n// hasn't been renamed to 'retention_first_occurrence_matching_filters' until schema migration\nexport const RETENTION_FIRST_OCCURRENCE_MATCHING_FILTERS = 'retention_first_time'\nexport const RETENTION_FIRST_EVER_OCCURRENCE = 'retention_first_ever_occurrence'\n\nexport const WEBHOOK_SERVICES: Record<string, string> = {\n    Slack: 'slack.com',\n    Discord: 'discord.com',\n    Teams: 'office.com',\n}\n\n// NOTE: Run `dev:sync-flags` locally to sync these flags into your local project\n// or if you're running flox + mprocs you can also run the `sync-feature-flags` process\nexport const FEATURE_FLAGS = {\n    // Eternal feature flags, shouldn't be removed, helpful for debugging/maintenance reasons\n    BILLING_FORECASTING_ISSUES: 'billing-forecasting-issues', // owner: #team-billing, see `Billing.tsx`, used to raise a warning when billing is having problems\n    DEBUG_REACT_RENDERS: 'debug-react-renders', // owner: @benjackwhite, usage: see `useWhyDidIRender.ts`\n    HOG: 'hog', // owner: #team-data-stack, see `DebugScene.tsx` and also insights\n    QUERY_TIMINGS: 'query-timings', // owner: #team-analytics-platform, usage: see `dataTableLogic.ts`\n    REDIRECT_SIGNUPS_TO_INSTANCE: 'redirect-signups-to-instance', // owner: @raquelmsmith, see `signupLogic.ts`\n    SESSION_RESET_ON_LOAD: 'session-reset-on-load', // owner: @benjackwhite, usage: see `loadPosthogJS.tsx`\n    SETTINGS_PERSONS_ON_EVENTS_HIDDEN: 'settings-persons-on-events-hidden', // owner: #team-platform-features, see `SettingsMap.tsx`\n    SUPPORT_MESSAGE_OVERRIDE: 'support-message-override', // owner: #team-support, see `SidePanelSupport.tsx`\n    THEME_OVERRIDE: 'theme', // owner: @aprilfools, see `themeLogic.ts`\n    USAGE_SPEND_DASHBOARDS: 'usage-spend-dashboards', // owner: #team-billing, see `Billing.tsx`, needed to exclude orgs with more than 100 teams\n\n    // Feature flags used to control opt-in for different behaviors, should not be removed\n    AUDIT_LOGS_ACCESS: 'audit-logs-access', // owner: #team-platform-features, used to control access to audit logs\n    GAME_CENTER: 'game-center', // owner: everybody, this is just internal for now\n    HEDGEHOG_SKIN_SPIDERHOG: 'hedgehog-skin-spiderhog', // owner: #team-web-analytics, used to reward beta users for web analytics\n    HIGH_FREQUENCY_BATCH_EXPORTS: 'high-frequency-batch-exports', // owner: #team-batch-exports, allow batch exports to be run every 5min\n    METALYTICS: 'metalytics', // owner: #team-platform-features, used to allow companies to see (meta) analytics on access to a specific page\n    REPLAY_EXCLUDE_FROM_HIDE_RECORDINGS_MENU: 'replay-exclude-from-hide-recordings-menu', // owner: #team-replay, used to exclude what other people are seeing in Replay\n    SELF_SERVE_CREDIT_OVERRIDE: 'self-serve-credit-override', // owner: #team-platform-features, used to allow users to self-serve credits even when they don't qualify\n    SHOW_UPGRADE_TO_MANAGED_ACCOUNT: 'show-upgrade-to-managed-account', // owner: #team-billing, used to give free accounts a way to force upgrade to managed account\n    WEBHOOKS_DENYLIST: 'webhooks-denylist', // owner: #team-ingestion, used to disable webhooks for certain companies\n\n    // Legacy flags, TBD if they need to be removed\n    AUTO_ROLLBACK_FEATURE_FLAGS: 'auto-rollback-feature-flags', // owner: #team-feature-flags\n    BATCH_EXPORTS_POSTHOG_HTTP: 'posthog-http-batch-exports', // owner: #team-batch-exports\n    BILLING_SKIP_FORECASTING: 'billing-skip-forecasting', // owner: @zach\n    CALENDAR_HEATMAP_INSIGHT: 'calendar-heatmap-insight', // owner: @jabahamondes #team-web-analytics\n    COOKIELESS_SERVER_HASH_MODE_SETTING: 'cookieless-server-hash-mode-setting', // owner: #team-web-analytics\n    CSP_REPORTING: 'mexicspo', // owner @pauldambra @lricoy @robbiec\n    CUSTOM_CSS_THEMES: 'custom-css-themes', // owner: #team-growth\n    DASHBOARD_COLORS: 'dashboard-colors', // owner: @thmsobrmlr #team-product-analytics\n    ENVIRONMENTS_ROLLBACK: 'environments-rollback', // owner: @yasen-posthog #team-platform-features\n    ENVIRONMENTS: 'environments', // owner: #team-platform-features\n    ERROR_TRACKING_ALERT_ROUTING: 'error-tracking-alert-routing', // owner: #team-error-tracking\n    EXPERIMENT_INTERVAL_TIMESERIES: 'experiments-interval-timeseries', // owner: @jurajmajerik #team-experiments\n    FEATURE_FLAG_COHORT_CREATION: 'feature-flag-cohort-creation', // owner: #team-feature-flags\n    FF_DASHBOARD_TEMPLATES: 'ff-dashboard-templates', // owner: #team-feature-flags\n    IMPROVED_COOKIELESS_MODE: 'improved-cookieless-mode', // owner: #team-web-analytics\n    INSIGHT_HORIZONTAL_CONTROLS: 'insight-horizontal-controls', // owner: #team-product-analytics\n    LINEAGE_DEPENDENCY_VIEW: 'lineage-dependency-view', // owner: #team-data-stack\n    MEMBERS_CAN_USE_PERSONAL_API_KEYS: 'members-can-use-personal-api-keys', // owner: @yasen-posthog #team-platform-features\n    ONBOARDING_DATA_WAREHOUSE_FOR_PRODUCT_ANALYTICS: 'onboarding-data-warehouse-for-product-analytics', // owner: #team-growth\n    PERSONLESS_EVENTS_NOT_SUPPORTED: 'personless-events-not-supported', // owner: #team-analytics-platform\n    QUERY_RUNNING_TIME: 'query_running_time', // owner: #team-analytics-platform\n    REPLAY_HOGQL_FILTERS: 'replay-hogql-filters', // owner: @pauldambra #team-replay\n    REPLAY_SETTINGS_HELP: 'replay-settings-help', // owner: @veryayskiy #team-replay\n    REPLAY_TRIGGER_TYPE_CHOICE: 'replay-trigger-type-choice', // owner: @pauldambra #team-replay\n    SAVE_INSIGHT_TASK: 'save-insight-task', // owner: #team-growth\n    SESSION_REPLAY_DOCTOR: 'session-replay-doctor', // owner: #team-replay\n    SETTINGS_BOUNCE_RATE_PAGE_VIEW_MODE: 'settings-bounce-rate-page-view-mode', // owner: #team-web-analytics\n    SETTINGS_PERSONS_JOIN_MODE: 'settings-persons-join-mode', // owner: #team-analytics-platform\n    SETTINGS_SESSION_TABLE_VERSION: 'settings-session-table-version', // owner: #team-analytics-platform\n    SETTINGS_SESSIONS_V2_JOIN: 'settings-sessions-v2-join', // owner: @robbie-c #team-product-analytics\n    SETTINGS_WEB_ANALYTICS_PRE_AGGREGATED_TABLES: 'web-analytics-pre-aggregated-tables', // owner: @lricoy #team-web-analytics\n    STARTUP_PROGRAM_INTENT: 'startup-program-intent', // owner: @pawel-cebula #team-billing\n    SURVEYS_ACTIONS: 'surveys-actions', // owner: #team-surveys\n    SURVEYS_ADAPTIVE_LIMITS: 'surveys-adaptive-limits', // owner: #team-surveys\n    TRACK_MEMORY_USAGE: 'track-memory-usage', // owner: @pauldambra #team-replay\n    WEB_ANALYTICS_API: 'web-analytics-api', // owner: #team-web-analytics\n    WEB_ANALYTICS_FOR_MOBILE: 'web-analytics-for-mobile', // owner: #team-web-analytics\n    WEB_EXPERIMENTS: 'web-experiments', // owner: #team-experiments\n\n    // Temporary feature flags, still WIP, should be removed eventually\n    AA_TEST_BAYESIAN_LEGACY: 'aa-test-bayesian-legacy', // owner: #team-experiments\n    AA_TEST_BAYESIAN_NEW: 'aa-test-bayesian-new', // owner: #team-experiments\n    ADVANCE_MARKETING_ANALYTICS_SETTINGS: 'advance-marketing-analytics-settings', // owner: @jabahamondes  #team-web-analytics\n    AGENT_MODES: 'phai-agent-modes', // owner: @skoob13 #team-posthog-ai\n    AI_ONLY_MODE: 'ai-only-mode', // owner: #team-posthog-ai\n    AI_SESSION_SUMMARY: 'ai-session-summary', // owner: #team-replay\n    AMPLITUDE_BATCH_IMPORT_OPTIONS: 'amplitude-batch-import-options', // owner: #team-ingestion\n    BATCH_EXPORT_NEW_LOGS: 'batch-export-new-logs', // owner: #team-batch-exports\n    BATCH_EXPORTS_DATABRICKS: 'databricks-batch-exports', // owner: @rossgray #team-batch-exports\n    BING_ADS_SOURCE: 'bing-ads-source', // owner: @jabahamondes #team-web-analytics\n    CDP_",
            "output_extracted": "import { LemonSelectOptions } from '@posthog/lemon-ui'\n\nimport { ChartDisplayCategory, ChartDisplayType, Region, SSOProvider } from '../types'\n\n// Sync with backend DISPLAY_TYPES_TO_CATEGORIES\nexport const DISPLAY_TYPES_TO_CATEGORIES: Record<ChartDisplayType, ChartDisplayCategory> = {\n    [ChartDisplayType.ActionsLineGraph]: ChartDisplayCategory.TimeSeries,\n    [ChartDisplayType.ActionsBar]: ChartDisplayCategory.TimeSeries,\n    [ChartDisplayType.ActionsUnstackedBar]: ChartDisplayCategory.TimeSeries,\n    [ChartDisplayType.ActionsStackedBar]: ChartDisplayCategory.TimeSeries,\n    [ChartDisplayType.ActionsAreaGraph]: ChartDisplayCategory.TimeSeries,\n    [ChartDisplayType.ActionsLineGraphCumulative]: ChartDisplayCategory.CumulativeTimeSeries,\n    [ChartDisplayType.BoldNumber]: ChartDisplayCategory.TotalValue,\n    [ChartDisplayType.ActionsPie]: ChartDisplayCategory.TotalValue,\n    [ChartDisplayType.ActionsBarValue]: ChartDisplayCategory.TotalValue,\n    [ChartDisplayType.ActionsTable]: ChartDisplayCategory.TotalValue,\n    [ChartDisplayType.WorldMap]: ChartDisplayCategory.TotalValue,\n    [ChartDisplayType.CalendarHeatmap]: ChartDisplayCategory.TotalValue,\n}\nexport const NON_TIME_SERIES_DISPLAY_TYPES = Object.entries(DISPLAY_TYPES_TO_CATEGORIES)\n    .filter(([, category]) => category === ChartDisplayCategory.TotalValue)\n    .map(([displayType]) => displayType as ChartDisplayType)\n\n/** Display types for which `breakdown` is hidden and ignored. Sync with backend NON_BREAKDOWN_DISPLAY_TYPES. */\nexport const NON_BREAKDOWN_DISPLAY_TYPES = [ChartDisplayType.BoldNumber, ChartDisplayType.CalendarHeatmap]\n/** Display types which only work with a single series. */\nexport const SINGLE_SERIES_DISPLAY_TYPES = [\n    ChartDisplayType.WorldMap,\n    ChartDisplayType.BoldNumber,\n    ChartDisplayType.CalendarHeatmap,\n]\n\nexport const NON_VALUES_ON_SERIES_DISPLAY_TYPES = [\n    ChartDisplayType.ActionsTable,\n    ChartDisplayType.WorldMap,\n    ChartDisplayType.BoldNumber,\n    ChartDisplayType.CalendarHeatmap,\n]\n\n/** Display types for which a percent stack view is available. */\nexport const PERCENT_STACK_VIEW_DISPLAY_TYPE = [\n    ChartDisplayType.ActionsBar,\n    ChartDisplayType.ActionsAreaGraph,\n    ChartDisplayType.ActionsPie,\n]\n\nexport enum OrganizationMembershipLevel {\n    Member = 1,\n    Admin = 8,\n    Owner = 15,\n}\n\nexport enum TeamMembershipLevel {\n    Member = 1,\n    Admin = 8,\n}\n\nexport type EitherMembershipLevel = OrganizationMembershipLevel | TeamMembershipLevel\n\n/** See posthog/api/organization.py for details. */\nexport enum PluginsAccessLevel {\n    None = 0,\n    Config = 3,\n    Install = 6,\n    Root = 9,\n}\n\n/** Collaboration restriction level (which is a dashboard setting). Sync with DashboardPrivilegeLevel. */\nexport enum DashboardRestrictionLevel {\n    EveryoneInProjectCanEdit = 21,\n    OnlyCollaboratorsCanEdit = 37,\n}\n\n/** Collaboration privilege level (which is a user property). Sync with DashboardRestrictionLevel. */\nexport enum DashboardPrivilegeLevel {\n    CanView = 21,\n    CanEdit = 37,\n    /** This is not a value that can be set in the DB \u2013 it's inferred. */\n    _ProjectAdmin = 888,\n    /** This is not a value that can be set in the DB \u2013 it's inferred. */\n    _Owner = 999,\n}\n\nexport const privilegeLevelToName: Record<DashboardPrivilegeLevel, string> = {\n    [DashboardPrivilegeLevel.CanView]: 'can view',\n    [DashboardPrivilegeLevel.CanEdit]: 'can edit',\n    [DashboardPrivilegeLevel._Owner]: 'owner',\n    [DashboardPrivilegeLevel._ProjectAdmin]: 'can edit',\n}\n\n// Persons\nexport const PERSON_DISTINCT_ID_MAX_SIZE = 3\nexport const PERSON_DISPLAY_NAME_COLUMN_NAME = 'person_display_name -- Person'\n\n// Sync with .../api/person.py and .../ingestion/webhook-formatter.ts\nexport const PERSON_DEFAULT_DISPLAY_NAME_PROPERTIES = [\n    'email',\n    'Email',\n    '$email',\n    'name',\n    'Name',\n    'username',\n    'Username',\n    'UserName',\n]\n\n// Feature Flags & Experiments\nexport const INSTANTLY_AVAILABLE_PROPERTIES = [\n    '$geoip_city_name',\n    '$geoip_country_name',\n    '$geoip_country_code',\n    '$geoip_continent_name',\n    '$geoip_continent_code',\n    '$geoip_postal_code',\n    '$geoip_time_zone',\n    // Person and group identifiers\n    '$group_key',\n    'distinct_id',\n]\nexport const MAX_EXPERIMENT_VARIANTS = 20\nexport const EXPERIMENT_DEFAULT_DURATION = 14 // days\n\n// Event constants\nexport const ACTION_TYPE = 'action_type'\nexport const EVENT_TYPE = 'event_type'\nexport const STALE_EVENT_SECONDS = 30 * 24 * 60 * 60 // 30 days\n\n/**\n * @deprecated should be removed once backend is updated\n */\nexport enum ShownAsValue {\n    VOLUME = 'Volume',\n    STICKINESS = 'Stickiness',\n    LIFECYCLE = 'Lifecycle',\n}\n\n// Retention constants\nexport const RETENTION_RECURRING = 'retention_recurring'\n// hasn't been renamed to 'retention_first_occurrence_matching_filters' until schema migration\nexport const RETENTION_FIRST_OCCURRENCE_MATCHING_FILTERS = 'retention_first_time'\nexport const RETENTION_FIRST_EVER_OCCURRENCE = 'retention_first_ever_occurrence'\n\nexport const WEBHOOK_SERVICES: Record<string, string> = {\n    Slack: 'slack.com',\n    Discord: 'discord.com',\n    Teams: 'office.com',\n}\n\n// NOTE: Run `dev:sync-flags` locally to sync these flags into your local project\n// or if you're running flox + mprocs you can also run the `sync-feature-flags` process\nexport const FEATURE_FLAGS = {\n    // Eternal feature flags, shouldn't be removed, helpful for debugging/maintenance reasons\n    BILLING_FORECASTING_ISSUES: 'billing-forecasting-issues', // owner: #team-billing, see `Billing.tsx`, used to raise a warning when billing is having problems\n    DEBUG_REACT_RENDERS: 'debug-react-renders', // owner: @benjackwhite, usage: see `useWhyDidIRender.ts`\n    HOG: 'hog', // owner: #team-data-stack, see `DebugScene.tsx` and also insights\n    QUERY_TIMINGS: 'query-timings', // owner: #team-analytics-platform, usage: see `dataTableLogic.ts`\n    REDIRECT_SIGNUPS_TO_INSTANCE: 'redirect-signups-to-instance', // owner: @raquelmsmith, see `signupLogic.ts`\n    SESSION_RESET_ON_LOAD: 'session-reset-on-load', // owner: @benjackwhite, usage: see `loadPosthogJS.tsx`\n    SETTINGS_PERSONS_ON_EVENTS_HIDDEN: 'settings-persons-on-events-hidden', // owner: #team-platform-features, see `SettingsMap.tsx`\n    SUPPORT_MESSAGE_OVERRIDE: 'support-message-override', // owner: #team-support, see `SidePanelSupport.tsx`\n    THEME_OVERRIDE: 'theme', // owner: @aprilfools, see `themeLogic.ts`\n    USAGE_SPEND_DASHBOARDS: 'usage-spend-dashboards', // owner: #team-billing, see `Billing.tsx`, needed to exclude orgs with more than 100 teams\n\n    // Feature flags used to control opt-in for different behaviors, should not be removed\n    AUDIT_LOGS_ACCESS: 'audit-logs-access', // owner: #team-platform-features, used to control access to audit logs\n    GAME_CENTER: 'game-center', // owner: everybody, this is just internal for now\n    HEDGEHOG_SKIN_SPIDERHOG: 'hedgehog-skin-spiderhog', // owner: #team-web-analytics, used to reward beta users for web analytics\n    HIGH_FREQUENCY_BATCH_EXPORTS: 'high-frequency-batch-exports', // owner: #team-batch-exports, allow batch exports to be run every 5min\n    METALYTICS: 'metalytics', // owner: #team-platform-features, used to allow companies to see (meta) analytics on access to a specific page\n    REPLAY_EXCLUDE_FROM_HIDE_RECORDINGS_MENU: 'replay-exclude-from-hide-recordings-menu', // owner: #team-replay, used to exclude what other people are seeing in Replay\n    SELF_SERVE_CREDIT_OVERRIDE: 'self-serve-credit-override', // owner: #team-platform-features, used to allow users to self-serve credits even when they don't qualify\n    SHOW_UPGRADE_TO_MANAGED_ACCOUNT: 'show-upgrade-to-managed-account', // owner: #team-billing, used to give free accounts a way to force upgrade to managed account\n    WEBHOOKS_DENYLIST: 'webhooks-denylist', // owner: #team-ingestion, used to disable webhooks for certain companies\n\n    // Legacy flags, TBD if they need to be removed\n    AUTO_ROLLBACK_FEATURE_FLAGS: 'auto-rollback-feature-flags', // owner: #team-feature-flags\n    BATCH_EXPORTS_POSTHOG_HTTP: 'posthog-http-batch-exports', // owner: #team-batch-exports\n    BILLING_SKIP_FORECASTING: 'billing-skip-forecasting', // owner: @zach\n    CALENDAR_HEATMAP_INSIGHT: 'calendar-heatmap-insight', // owner: @jabahamondes #team-web-analytics\n    COOKIELESS_SERVER_HASH_MODE_SETTING: 'cookieless-server-hash-mode-setting', // owner: #team-web-analytics\n    CSP_REPORTING: 'mexicspo', // owner @pauldambra @lricoy @robbiec\n    CUSTOM_CSS_THEMES: 'custom-css-themes', // owner: #team-growth\n    DASHBOARD_COLORS: 'dashboard-colors', // owner: @thmsobrmlr #team-product-analytics\n    ENVIRONMENTS_ROLLBACK: 'environments-rollback', // owner: @yasen-posthog #team-platform-features\n    ENVIRONMENTS: 'environments', // owner: #team-platform-features\n    ERROR_TRACKING_ALERT_ROUTING: 'error-tracking-alert-routing', // owner: #team-error-tracking\n    EXPERIMENT_INTERVAL_TIMESERIES: 'experiments-interval-timeseries', // owner: @jurajmajerik #team-experiments\n    FEATURE_FLAG_COHORT_CREATION: 'feature-flag-cohort-creation', // owner: #team-feature-flags\n    FF_DASHBOARD_TEMPLATES: 'ff-dashboard-templates', // owner: #team-feature-flags\n    IMPROVED_COOKIELESS_MODE: 'improved-cookieless-mode', // owner: #team-web-analytics\n    INSIGHT_HORIZONTAL_CONTROLS: 'insight-horizontal-controls', // owner: #team-product-analytics\n    LINEAGE_DEPENDENCY_VIEW: 'lineage-dependency-view', // owner: #team-data-stack\n    MEMBERS_CAN_USE_PERSONAL_API_KEYS: 'members-can-use-personal-api-keys', // owner: @yasen-posthog #team-platform-features\n    ONBOARDING_DATA_WAREHOUSE_FOR_PRODUCT_ANALYTICS: 'onboarding-data-warehouse-for-product-analytics', // owner: #team-growth\n    PERSONLESS_EVENTS_NOT_SUPPORTED: 'personless-events-not-supported', // owner: #team-analytics-platform\n    QUERY_RUNNING_TIME: 'query_running_time', // owner: #team-analytics-platform\n    REPLAY_HOGQL_FILTERS: 'replay-hogql-filters', // owner: @pauldambra #team-replay\n    REPLAY_SETTINGS_HELP: 'replay-settings-help', // owner: @veryayskiy #team-replay\n    REPLAY_TRIGGER_TYPE_CHOICE: 'replay-trigger-type-choice', // owner: @pauldambra #team-replay\n    SAVE_INSIGHT_TASK: 'save-insight-task', // owner: #team-growth\n    SESSION_REPLAY_DOCTOR: 'session-replay-doctor', // owner: #team-replay\n    SETTINGS_BOUNCE_RATE_PAGE_VIEW_MODE: 'settings-bounce-rate-page-view-mode', // owner: #team-web-analytics\n    SETTINGS_PERSONS_JOIN_MODE: 'settings-persons-join-mode', // owner: #team-analytics-platform\n    SETTINGS_SESSION_TABLE_VERSION: 'settings-session-table-version', // owner: #team-analytics-platform\n    SETTINGS_SESSIONS_V2_JOIN: 'settings-sessions-v2-join', // owner: @robbie-c #team-product-analytics\n    SETTINGS_WEB_ANALYTICS_PRE_AGGREGATED_TABLES: 'web-analytics-pre-aggregated-tables', // owner: @lricoy #team-web-analytics\n    STARTUP_PROGRAM_INTENT: 'startup-program-intent', // owner: @pawel-cebula #team-billing\n    SURVEYS_ACTIONS: 'surveys-actions', // owner: #team-surveys\n    SURVEYS_ADAPTIVE_LIMITS: 'surveys-adaptive-limits', // owner: #team-surveys\n    TRACK_MEMORY_USAGE: 'track-memory-usage', // owner: @pauldambra #team-replay\n    WEB_ANALYTICS_API: 'web-analytics-api', // owner: #team-web-analytics\n    WEB_ANALYTICS_FOR_MOBILE: 'web-analytics-for-mobile', // owner: #team-web-analytics\n    WEB_EXPERIMENTS: 'web-experiments', // owner: #team-experiments\n\n    // Temporary feature flags, still WIP, should be removed eventually\n    AA_TEST_BAYESIAN_LEGACY: 'aa-test-bayesian-legacy', // owner: #team-experiments\n    AA_TEST_BAYESIAN_NEW: 'aa-test-bayesian-new', // owner: #team-experiments\n    ADVANCE_MARKETING_ANALYTICS_SETTINGS: 'advance-marketing-analytics-settings', // owner: @jabahamondes  #team-web-analytics\n    AGENT_MODES: 'phai-agent-modes', // owner: @skoob13 #team-posthog-ai\n    AI_ONLY_MODE: 'ai-only-mode', // owner: #team-posthog-ai\n    AI_SESSION_SUMMARY: 'ai-session-summary', // owner: #team-replay\n    AMPLITUDE_BATCH_IMPORT_OPTIONS: 'amplitude-batch-import-options', // owner: #team-ingestion\n    BATCH_EXPORT_NEW_LOGS: 'batch-export-new-logs', // owner: #team-batch-exports\n    BATCH_EXPORTS_DATABRICKS: 'databricks-batch-exports', // owner: @rossgray #team-batch-exports\n    BING_ADS_SOURCE: 'bing-ads-source', // owner: @jabahamondes #team-web-analytics\n    CDP_",
            "cost": 0.15234
        },
        "PostHog__posthog.main/frontend/src/queries/nodes/DataTable/DataTable.tsx": {
            "output": "import './DataTable.scss'\n\nimport clsx from 'clsx'\nimport { BindLogic, BuiltLogic, LogicWrapper, useActions, useValues } from 'kea'\nimport { useCallback, useState } from 'react'\n\nimport { PreAggregatedBadge } from 'lib/components/PreAggregatedBadge'\nimport { TaxonomicFilterGroupType } from 'lib/components/TaxonomicFilter/types'\nimport { TaxonomicPopover } from 'lib/components/TaxonomicPopover/TaxonomicPopover'\nimport ViewRecordingButton from 'lib/components/ViewRecordingButton/ViewRecordingButton'\nimport { useFeatureFlag } from 'lib/hooks/useFeatureFlag'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonDivider } from 'lib/lemon-ui/LemonDivider'\nimport { LemonTable, LemonTableColumn } from 'lib/lemon-ui/LemonTable'\nimport { useAttachedLogic } from 'lib/logic/scenes/useAttachedLogic'\nimport { EventDetails } from 'scenes/activity/explore/EventDetails'\nimport { ViewLinkButton } from 'scenes/data-warehouse/ViewLinkModal'\nimport { groupViewLogic } from 'scenes/groups/groupViewLogic'\nimport { InsightEmptyState, InsightErrorState } from 'scenes/insights/EmptyStates'\nimport { PersonDeleteModal } from 'scenes/persons/PersonDeleteModal'\nimport { createMarketingAnalyticsOrderBy } from 'scenes/web-analytics/tabs/marketing-analytics/frontend/logic/utils'\n\nimport { DateRange } from '~/queries/nodes/DataNode/DateRange'\nimport { ElapsedTime } from '~/queries/nodes/DataNode/ElapsedTime'\nimport { LoadNext } from '~/queries/nodes/DataNode/LoadNext'\nimport { Reload } from '~/queries/nodes/DataNode/Reload'\nimport { TestAccountFilters } from '~/queries/nodes/DataNode/TestAccountFilters'\nimport { DataNodeLogicProps, dataNodeLogic } from '~/queries/nodes/DataNode/dataNodeLogic'\nimport { BackToSource } from '~/queries/nodes/DataTable/BackToSource'\nimport { ColumnConfigurator } from '~/queries/nodes/DataTable/ColumnConfigurator/ColumnConfigurator'\nimport { DataTableExport } from '~/queries/nodes/DataTable/DataTableExport'\nimport { DataTableSavedFilters } from '~/queries/nodes/DataTable/DataTableSavedFilters'\nimport { DataTableSavedFiltersButton } from '~/queries/nodes/DataTable/DataTableSavedFiltersButton'\nimport { eventRowActionsContent } from '~/queries/nodes/DataTable/EventRowActions'\nimport { InsightActorsQueryOptions } from '~/queries/nodes/DataTable/InsightActorsQueryOptions'\nimport { SavedQueries } from '~/queries/nodes/DataTable/SavedQueries'\nimport { DataTableLogicProps, DataTableRow, dataTableLogic } from '~/queries/nodes/DataTable/dataTableLogic'\nimport { QueryFeature } from '~/queries/nodes/DataTable/queryFeatures'\nimport { getContextColumn, renderColumn } from '~/queries/nodes/DataTable/renderColumn'\nimport { renderColumnMeta } from '~/queries/nodes/DataTable/renderColumnMeta'\nimport {\n    extractExpressionComment,\n    getDataNodeDefaultColumns,\n    removeExpressionComment,\n} from '~/queries/nodes/DataTable/utils'\nimport { EventName } from '~/queries/nodes/EventsNode/EventName'\nimport { EventPropertyFilters } from '~/queries/nodes/EventsNode/EventPropertyFilters'\nimport { HogQLQueryEditor } from '~/queries/nodes/HogQLQuery/HogQLQueryEditor'\nimport { insightVizDataNodeKey } from '~/queries/nodes/InsightViz/InsightViz'\nimport { EditHogQLButton } from '~/queries/nodes/Node/EditHogQLButton'\nimport { OpenEditorButton } from '~/queries/nodes/Node/OpenEditorButton'\nimport { PersonPropertyFilters } from '~/queries/nodes/PersonsNode/PersonPropertyFilters'\nimport { PersonsSearch } from '~/queries/nodes/PersonsNode/PersonsSearch'\nimport { SessionPropertyFilters } from '~/queries/nodes/SessionsNode/SessionPropertyFilters'\nimport {\n    ActorsQuery,\n    AnyResponseType,\n    DataTableNode,\n    EventsNode,\n    EventsQuery,\n    GroupsQuery,\n    HogQLQuery,\n    MarketingAnalyticsTableQuery,\n    NodeKind,\n    PersonsNode,\n    SessionAttributionExplorerQuery,\n    SessionsQuery,\n    TracesQuery,\n} from '~/queries/schema/schema-general'\nimport { QueryContext } from '~/queries/types'\nimport {\n    isActorsQuery,\n    isEventsQuery,\n    isGroupsQuery,\n    isHogQLAggregation,\n    isHogQLQuery,\n    isInsightActorsQuery,\n    isMarketingAnalyticsTableQuery,\n    isRevenueExampleEventsQuery,\n    isSessionsQuery,\n    taxonomicEventFilterToHogQL,\n    taxonomicGroupFilterToHogQL,\n    taxonomicPersonFilterToHogQL,\n} from '~/queries/utils'\nimport { EventType, InsightLogicProps } from '~/types'\n\nimport { GroupPropertyFilters } from '../GroupsQuery/GroupPropertyFilters'\nimport { GroupsSearch } from '../GroupsQuery/GroupsSearch'\nimport { DataTableOpenEditor } from './DataTableOpenEditor'\nimport { DataTableViewReplays } from './DataTableViewReplays'\n\nexport enum ColumnFeature {\n    canSort = 'canSort',\n    canEdit = 'canEdit',\n    canAddColumns = 'canAddColumns',\n    canRemove = 'canRemove',\n    canPin = 'canPin',\n}\n\ninterface DataTableProps {\n    uniqueKey?: string | number\n    query: DataTableNode\n    setQuery: (query: DataTableNode) => void\n    /** Custom table columns and export configuration */\n    context?: QueryContext<DataTableNode>\n    /* Cached Results are provided when shared or exported,\n    the data node logic becomes read only implicitly */\n    cachedResults?: AnyResponseType\n    // Override the data logic node key if needed\n    dataNodeLogicKey?: string\n    readOnly?: boolean\n    /*\n     Set a data-attr on the LemonTable component\n    */\n    dataAttr?: string\n    /** Attach ourselves to another logic, such as the scene logic */\n    attachTo?: BuiltLogic | LogicWrapper\n}\n\nconst eventGroupTypes = [\n    TaxonomicFilterGroupType.HogQLExpression,\n    TaxonomicFilterGroupType.EventProperties,\n    TaxonomicFilterGroupType.PersonProperties,\n    TaxonomicFilterGroupType.EventFeatureFlags,\n]\nconst personGroupTypes = [TaxonomicFilterGroupType.HogQLExpression, TaxonomicFilterGroupType.PersonProperties]\n\nlet uniqueNode = 0\n\nexport function DataTable({\n    uniqueKey,\n    query,\n    setQuery,\n    context,\n    cachedResults,\n    readOnly,\n    dataAttr,\n    attachTo,\n}: DataTableProps): JSX.Element {\n    const [uniqueNodeKey] = useState(() => uniqueNode++)\n    const [dataKey] = useState(() => `DataNode.${uniqueKey || uniqueNodeKey}`)\n    const insightProps: InsightLogicProps<DataTableNode> = context?.insightProps || {\n        dashboardItemId: `new-AdHoc.${dataKey}`,\n        dataNodeCollectionId: dataKey,\n    }\n\n    // support for existing column features by default\n    const columnFeatures = context?.columnFeatures || [\n        ColumnFeature.canSort,\n        ColumnFeature.canEdit,\n        ColumnFeature.canAddColumns,\n        ColumnFeature.canRemove,\n    ]\n    const vizKey = insightVizDataNodeKey(insightProps)\n    const dataNodeLogicProps: DataNodeLogicProps = {\n        query: query.source,\n        key: context?.dataNodeLogicKey ?? vizKey,\n        cachedResults: cachedResults,\n        dataNodeCollectionId: context?.insightProps?.dataNodeCollectionId || dataKey,\n        refresh: context?.refresh,\n        maxPaginationLimit: context?.dataTableMaxPaginationLimit,\n    }\n    const {\n        response,\n        responseLoading,\n        responseError,\n        queryCancelled,\n        nextDataLoading,\n        newDataLoading,\n        highlightedRows,\n        backToSourceQuery,\n    } = useValues(dataNodeLogic(dataNodeLogicProps))\n    const { setSaveGroupViewModalOpen } = useActions(groupViewLogic)\n\n    const canUseWebAnalyticsPreAggregatedTables = useFeatureFlag('SETTINGS_WEB_ANALYTICS_PRE_AGGREGATED_TABLES')\n    const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n    const usedWebAnalyticsPreAggregatedTables =\n        canUseWebAnalyticsPreAggregatedTables &&\n        response &&\n        'usedPreAggregatedTables' in response &&\n        response.usedPreAggregatedTables &&\n        response?.hogql\n\n    const dataTableLogicProps: DataTableLogicProps = {\n        query,\n        vizKey,\n        dataKey,\n        dataNodeLogicKey: dataNodeLogicProps.key,\n        context,\n    }\n    const { dataTableRows, columnsInQuery, columnsInResponse, queryWithDefaults, canSort, sourceFeatures } = useValues(\n        dataTableLogic(dataTableLogicProps)\n    )\n\n    useAttachedLogic(dataNodeLogic(dataNodeLogicProps), attachTo)\n    useAttachedLogic(dataTableLogic(dataTableLogicProps), attachTo)\n\n    const {\n        showActions,\n        showRecordingColumn,\n        showDateRange,\n        showTestAccountFilters,\n        showSearch,\n        showEventFilter,\n        showPropertyFilter,\n        showHogQLEditor,\n        showReload,\n        showExport,\n        showElapsedTime,\n        showColumnConfigurator,\n        showPersistentColumnConfigurator,\n        showSavedQueries,\n        showSavedFilters,\n        expandable,\n        embedded,\n        showOpenEditorButton,\n        showResultsTable,\n        showTimings,\n        showSourceQueryOptions,\n    } = queryWithDefaults\n\n    const isReadOnly = !!readOnly\n\n    const eventActionsColumnShown =\n        showActions && sourceFeatures.has(QueryFeature.eventActionsColumn) && columnsInResponse?.includes('*')\n    const recordingColumnShown =\n        showRecordingColumn && sourceFeatures.has(QueryFeature.eventActionsColumn) && columnsInResponse?.includes('*')\n\n    const allColumns = sourceFeatures.has(QueryFeature.columnsInResponse)\n        ? (columnsInResponse ?? columnsInQuery)\n        : columnsInQuery\n    const columnsInLemonTable = allColumns.filter((colName) => {\n        const col = getContextColumn(colName, context?.columns)\n        return !col?.queryContextColumn?.hidden\n    })\n    const rowFillFractionIndex = allColumns.findIndex((colName) => {\n        const col = getContextColumn(colName, context?.columns)\n        return col?.queryContextColumn?.isRowFillFraction\n    })\n\n    const contextRowPropsFn = context?.rowProps\n    const onRow = useCallback(\n        (record) => {\n            const rowProps = contextRowPropsFn?.(record)\n            const rowFillFraction =\n                rowFillFractionIndex >= 0 && Array.isArray(record.result)\n                    ? record.result[rowFillFractionIndex]\n                    : undefined\n            if (\n                typeof rowFillFraction === 'number' &&\n                !Number.isNaN(rowFillFraction) &&\n                rowFillFraction >= 0 &&\n                rowFillFraction <= 1\n            ) {\n                return {\n                    ...rowProps,\n                    style: {\n                        ...rowProps?.style,\n                        '--data-table-fraction-fill': `${Math.round(rowFillFraction * 100)}%`,\n                    },\n                }\n            }\n            return rowProps ?? {}\n        },\n        [contextRowPropsFn, rowFillFractionIndex]\n    )\n\n    const groupTypes = isActorsQuery(query.source) ? personGroupTypes : eventGroupTypes\n\n    const lemonColumns: LemonTableColumn<DataTableRow, any>[] = [\n        ...columnsInLemonTable.map((key, index) => {\n            return {\n                dataIndex: key as any,\n                ...renderColumnMeta(key, query, context),\n                render: function RenderDataTableColumn(\n                    _: any,\n                    { result, label }: DataTableRow,\n                    recordIndex: number,\n                    rowCount: number\n                ) {\n                    if (label) {\n                        if (index === (expandable ? 1 : 0)) {\n                            return {\n                                children: label,\n                                props: { colSpan: columnsInLemonTable.length + (recordingColumnShown ? 1 : 0) },\n                            }\n                        }\n                        return { props: { colSpan: 0 } }\n                    } else if (result) {\n                        const value = sourceFeatures.has(QueryFeature.resultIsArrayOfArrays)\n                            ? result[index]\n                            : result[key]\n                        return renderColumn(key, value, result, recordIndex, rowCount, query, setQuery, context)\n                    }\n                },\n                sorter: undefined, // using custom sorting code\n                more:\n                    !isReadOnly && showActions && sourceFeatures.has(QueryFeature.selectAndOrderByColumns) ? (\n                        <>\n                            <div className=\"px-2 py-1 max-w-md\">\n                                <div className=\"font-mono font-bold truncate\">{extractExpressionComment(key)}</div>\n                                {extractExpressionComment(key) !== removeExpressionComment(key) && (\n                                    <div className=\"font-mono truncate\">{removeExpressionComment(key)}</div>\n                                )}\n                            </div>\n                            {columnFeatures.includes(ColumnFeature.canEdit) && (\n                                <>\n                                    <LemonDivider />\n                                    <TaxonomicPopover\n                                        groupType={TaxonomicFilterGroupType.HogQLExpression}\n                                        value={key}\n                                        groupTypes={groupTypes}\n                                        metadataSource={query.source}\n                                        renderValue={() => <>Edit column</>}\n                                        type=\"tertiary\"\n                                        fullWidth\n                                        onChange={(v, g) => {\n                                            const hogQl = isActorsQuery(query.source)\n                                                ? taxonomicPersonFilterToHogQL(g, v)\n                                                : taxonomicEventFilterToHogQL(g, v)\n                                            if (\n                                                setQuery &&\n                                                hogQl &&\n                                                sourceFeatures.has(QueryFeature.selectAndOrderByColumns)\n                                            ) {\n                                                // Typecasting to a query type with select and order_by fields.\n                                                // The actual query may or may not be an events query.\n                                                const source = query.source as EventsQuery\n                                                const columns = columnsInLemonTable ?? getDataNodeDefaultColumns(source)\n                                                const isAggregation = isHogQLAggregation(hogQl)\n                                                const isOrderBy = source.orderBy?.[0] === key\n                                                const isDescOrderBy = source.orderBy?.[0] === `${key} DESC`\n                                                setQuery({\n                                                    ...query,\n                                                    source: {\n                                                        ...source,\n                                                        select: columns\n                                                            .map((s, i) => (i === index",
            "output_extracted": "import './DataTable.scss'\n\nimport clsx from 'clsx'\nimport { BindLogic, BuiltLogic, LogicWrapper, useActions, useValues } from 'kea'\nimport { useCallback, useState } from 'react'\n\nimport { PreAggregatedBadge } from 'lib/components/PreAggregatedBadge'\nimport { TaxonomicFilterGroupType } from 'lib/components/TaxonomicFilter/types'\nimport { TaxonomicPopover } from 'lib/components/TaxonomicPopover/TaxonomicPopover'\nimport ViewRecordingButton from 'lib/components/ViewRecordingButton/ViewRecordingButton'\nimport { useFeatureFlag } from 'lib/hooks/useFeatureFlag'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonDivider } from 'lib/lemon-ui/LemonDivider'\nimport { LemonTable, LemonTableColumn } from 'lib/lemon-ui/LemonTable'\nimport { useAttachedLogic } from 'lib/logic/scenes/useAttachedLogic'\nimport { EventDetails } from 'scenes/activity/explore/EventDetails'\nimport { ViewLinkButton } from 'scenes/data-warehouse/ViewLinkModal'\nimport { groupViewLogic } from 'scenes/groups/groupViewLogic'\nimport { InsightEmptyState, InsightErrorState } from 'scenes/insights/EmptyStates'\nimport { PersonDeleteModal } from 'scenes/persons/PersonDeleteModal'\nimport { createMarketingAnalyticsOrderBy } from 'scenes/web-analytics/tabs/marketing-analytics/frontend/logic/utils'\n\nimport { DateRange } from '~/queries/nodes/DataNode/DateRange'\nimport { ElapsedTime } from '~/queries/nodes/DataNode/ElapsedTime'\nimport { LoadNext } from '~/queries/nodes/DataNode/LoadNext'\nimport { Reload } from '~/queries/nodes/DataNode/Reload'\nimport { TestAccountFilters } from '~/queries/nodes/DataNode/TestAccountFilters'\nimport { DataNodeLogicProps, dataNodeLogic } from '~/queries/nodes/DataNode/dataNodeLogic'\nimport { BackToSource } from '~/queries/nodes/DataTable/BackToSource'\nimport { ColumnConfigurator } from '~/queries/nodes/DataTable/ColumnConfigurator/ColumnConfigurator'\nimport { DataTableExport } from '~/queries/nodes/DataTable/DataTableExport'\nimport { DataTableSavedFilters } from '~/queries/nodes/DataTable/DataTableSavedFilters'\nimport { DataTableSavedFiltersButton } from '~/queries/nodes/DataTable/DataTableSavedFiltersButton'\nimport { eventRowActionsContent } from '~/queries/nodes/DataTable/EventRowActions'\nimport { InsightActorsQueryOptions } from '~/queries/nodes/DataTable/InsightActorsQueryOptions'\nimport { SavedQueries } from '~/queries/nodes/DataTable/SavedQueries'\nimport { DataTableLogicProps, DataTableRow, dataTableLogic } from '~/queries/nodes/DataTable/dataTableLogic'\nimport { QueryFeature } from '~/queries/nodes/DataTable/queryFeatures'\nimport { getContextColumn, renderColumn } from '~/queries/nodes/DataTable/renderColumn'\nimport { renderColumnMeta } from '~/queries/nodes/DataTable/renderColumnMeta'\nimport {\n    extractExpressionComment,\n    getDataNodeDefaultColumns,\n    removeExpressionComment,\n} from '~/queries/nodes/DataTable/utils'\nimport { EventName } from '~/queries/nodes/EventsNode/EventName'\nimport { EventPropertyFilters } from '~/queries/nodes/EventsNode/EventPropertyFilters'\nimport { HogQLQueryEditor } from '~/queries/nodes/HogQLQuery/HogQLQueryEditor'\nimport { insightVizDataNodeKey } from '~/queries/nodes/InsightViz/InsightViz'\nimport { EditHogQLButton } from '~/queries/nodes/Node/EditHogQLButton'\nimport { OpenEditorButton } from '~/queries/nodes/Node/OpenEditorButton'\nimport { PersonPropertyFilters } from '~/queries/nodes/PersonsNode/PersonPropertyFilters'\nimport { PersonsSearch } from '~/queries/nodes/PersonsNode/PersonsSearch'\nimport { SessionPropertyFilters } from '~/queries/nodes/SessionsNode/SessionPropertyFilters'\nimport {\n    ActorsQuery,\n    AnyResponseType,\n    DataTableNode,\n    EventsNode,\n    EventsQuery,\n    GroupsQuery,\n    HogQLQuery,\n    MarketingAnalyticsTableQuery,\n    NodeKind,\n    PersonsNode,\n    SessionAttributionExplorerQuery,\n    SessionsQuery,\n    TracesQuery,\n} from '~/queries/schema/schema-general'\nimport { QueryContext } from '~/queries/types'\nimport {\n    isActorsQuery,\n    isEventsQuery,\n    isGroupsQuery,\n    isHogQLAggregation,\n    isHogQLQuery,\n    isInsightActorsQuery,\n    isMarketingAnalyticsTableQuery,\n    isRevenueExampleEventsQuery,\n    isSessionsQuery,\n    taxonomicEventFilterToHogQL,\n    taxonomicGroupFilterToHogQL,\n    taxonomicPersonFilterToHogQL,\n} from '~/queries/utils'\nimport { EventType, InsightLogicProps } from '~/types'\n\nimport { GroupPropertyFilters } from '../GroupsQuery/GroupPropertyFilters'\nimport { GroupsSearch } from '../GroupsQuery/GroupsSearch'\nimport { DataTableOpenEditor } from './DataTableOpenEditor'\nimport { DataTableViewReplays } from './DataTableViewReplays'\n\nexport enum ColumnFeature {\n    canSort = 'canSort',\n    canEdit = 'canEdit',\n    canAddColumns = 'canAddColumns',\n    canRemove = 'canRemove',\n    canPin = 'canPin',\n}\n\ninterface DataTableProps {\n    uniqueKey?: string | number\n    query: DataTableNode\n    setQuery: (query: DataTableNode) => void\n    /** Custom table columns and export configuration */\n    context?: QueryContext<DataTableNode>\n    /* Cached Results are provided when shared or exported,\n    the data node logic becomes read only implicitly */\n    cachedResults?: AnyResponseType\n    // Override the data logic node key if needed\n    dataNodeLogicKey?: string\n    readOnly?: boolean\n    /*\n     Set a data-attr on the LemonTable component\n    */\n    dataAttr?: string\n    /** Attach ourselves to another logic, such as the scene logic */\n    attachTo?: BuiltLogic | LogicWrapper\n}\n\nconst eventGroupTypes = [\n    TaxonomicFilterGroupType.HogQLExpression,\n    TaxonomicFilterGroupType.EventProperties,\n    TaxonomicFilterGroupType.PersonProperties,\n    TaxonomicFilterGroupType.EventFeatureFlags,\n]\nconst personGroupTypes = [TaxonomicFilterGroupType.HogQLExpression, TaxonomicFilterGroupType.PersonProperties]\n\nlet uniqueNode = 0\n\nexport function DataTable({\n    uniqueKey,\n    query,\n    setQuery,\n    context,\n    cachedResults,\n    readOnly,\n    dataAttr,\n    attachTo,\n}: DataTableProps): JSX.Element {\n    const [uniqueNodeKey] = useState(() => uniqueNode++)\n    const [dataKey] = useState(() => `DataNode.${uniqueKey || uniqueNodeKey}`)\n    const insightProps: InsightLogicProps<DataTableNode> = context?.insightProps || {\n        dashboardItemId: `new-AdHoc.${dataKey}`,\n        dataNodeCollectionId: dataKey,\n    }\n\n    // support for existing column features by default\n    const columnFeatures = context?.columnFeatures || [\n        ColumnFeature.canSort,\n        ColumnFeature.canEdit,\n        ColumnFeature.canAddColumns,\n        ColumnFeature.canRemove,\n    ]\n    const vizKey = insightVizDataNodeKey(insightProps)\n    const dataNodeLogicProps: DataNodeLogicProps = {\n        query: query.source,\n        key: context?.dataNodeLogicKey ?? vizKey,\n        cachedResults: cachedResults,\n        dataNodeCollectionId: context?.insightProps?.dataNodeCollectionId || dataKey,\n        refresh: context?.refresh,\n        maxPaginationLimit: context?.dataTableMaxPaginationLimit,\n    }\n    const {\n        response,\n        responseLoading,\n        responseError,\n        queryCancelled,\n        nextDataLoading,\n        newDataLoading,\n        highlightedRows,\n        backToSourceQuery,\n    } = useValues(dataNodeLogic(dataNodeLogicProps))\n    const { setSaveGroupViewModalOpen } = useActions(groupViewLogic)\n\n    const canUseWebAnalyticsPreAggregatedTables = useFeatureFlag('SETTINGS_WEB_ANALYTICS_PRE_AGGREGATED_TABLES')\n    const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n    const usedWebAnalyticsPreAggregatedTables =\n        canUseWebAnalyticsPreAggregatedTables &&\n        response &&\n        'usedPreAggregatedTables' in response &&\n        response.usedPreAggregatedTables &&\n        response?.hogql\n\n    const dataTableLogicProps: DataTableLogicProps = {\n        query,\n        vizKey,\n        dataKey,\n        dataNodeLogicKey: dataNodeLogicProps.key,\n        context,\n    }\n    const { dataTableRows, columnsInQuery, columnsInResponse, queryWithDefaults, canSort, sourceFeatures } = useValues(\n        dataTableLogic(dataTableLogicProps)\n    )\n\n    useAttachedLogic(dataNodeLogic(dataNodeLogicProps), attachTo)\n    useAttachedLogic(dataTableLogic(dataTableLogicProps), attachTo)\n\n    const {\n        showActions,\n        showRecordingColumn,\n        showDateRange,\n        showTestAccountFilters,\n        showSearch,\n        showEventFilter,\n        showPropertyFilter,\n        showHogQLEditor,\n        showReload,\n        showExport,\n        showElapsedTime,\n        showColumnConfigurator,\n        showPersistentColumnConfigurator,\n        showSavedQueries,\n        showSavedFilters,\n        expandable,\n        embedded,\n        showOpenEditorButton,\n        showResultsTable,\n        showTimings,\n        showSourceQueryOptions,\n    } = queryWithDefaults\n\n    const isReadOnly = !!readOnly\n\n    const eventActionsColumnShown =\n        showActions && sourceFeatures.has(QueryFeature.eventActionsColumn) && columnsInResponse?.includes('*')\n    const recordingColumnShown =\n        showRecordingColumn && sourceFeatures.has(QueryFeature.eventActionsColumn) && columnsInResponse?.includes('*')\n\n    const allColumns = sourceFeatures.has(QueryFeature.columnsInResponse)\n        ? (columnsInResponse ?? columnsInQuery)\n        : columnsInQuery\n    const columnsInLemonTable = allColumns.filter((colName) => {\n        const col = getContextColumn(colName, context?.columns)\n        return !col?.queryContextColumn?.hidden\n    })\n    const rowFillFractionIndex = allColumns.findIndex((colName) => {\n        const col = getContextColumn(colName, context?.columns)\n        return col?.queryContextColumn?.isRowFillFraction\n    })\n\n    const contextRowPropsFn = context?.rowProps\n    const onRow = useCallback(\n        (record) => {\n            const rowProps = contextRowPropsFn?.(record)\n            const rowFillFraction =\n                rowFillFractionIndex >= 0 && Array.isArray(record.result)\n                    ? record.result[rowFillFractionIndex]\n                    : undefined\n            if (\n                typeof rowFillFraction === 'number' &&\n                !Number.isNaN(rowFillFraction) &&\n                rowFillFraction >= 0 &&\n                rowFillFraction <= 1\n            ) {\n                return {\n                    ...rowProps,\n                    style: {\n                        ...rowProps?.style,\n                        '--data-table-fraction-fill': `${Math.round(rowFillFraction * 100)}%`,\n                    },\n                }\n            }\n            return rowProps ?? {}\n        },\n        [contextRowPropsFn, rowFillFractionIndex]\n    )\n\n    const groupTypes = isActorsQuery(query.source) ? personGroupTypes : eventGroupTypes\n\n    const lemonColumns: LemonTableColumn<DataTableRow, any>[] = [\n        ...columnsInLemonTable.map((key, index) => {\n            return {\n                dataIndex: key as any,\n                ...renderColumnMeta(key, query, context),\n                render: function RenderDataTableColumn(\n                    _: any,\n                    { result, label }: DataTableRow,\n                    recordIndex: number,\n                    rowCount: number\n                ) {\n                    if (label) {\n                        if (index === (expandable ? 1 : 0)) {\n                            return {\n                                children: label,\n                                props: { colSpan: columnsInLemonTable.length + (recordingColumnShown ? 1 : 0) },\n                            }\n                        }\n                        return { props: { colSpan: 0 } }\n                    } else if (result) {\n                        const value = sourceFeatures.has(QueryFeature.resultIsArrayOfArrays)\n                            ? result[index]\n                            : result[key]\n                        return renderColumn(key, value, result, recordIndex, rowCount, query, setQuery, context)\n                    }\n                },\n                sorter: undefined, // using custom sorting code\n                more:\n                    !isReadOnly && showActions && sourceFeatures.has(QueryFeature.selectAndOrderByColumns) ? (\n                        <>\n                            <div className=\"px-2 py-1 max-w-md\">\n                                <div className=\"font-mono font-bold truncate\">{extractExpressionComment(key)}</div>\n                                {extractExpressionComment(key) !== removeExpressionComment(key) && (\n                                    <div className=\"font-mono truncate\">{removeExpressionComment(key)}</div>\n                                )}\n                            </div>\n                            {columnFeatures.includes(ColumnFeature.canEdit) && (\n                                <>\n                                    <LemonDivider />\n                                    <TaxonomicPopover\n                                        groupType={TaxonomicFilterGroupType.HogQLExpression}\n                                        value={key}\n                                        groupTypes={groupTypes}\n                                        metadataSource={query.source}\n                                        renderValue={() => <>Edit column</>}\n                                        type=\"tertiary\"\n                                        fullWidth\n                                        onChange={(v, g) => {\n                                            const hogQl = isActorsQuery(query.source)\n                                                ? taxonomicPersonFilterToHogQL(g, v)\n                                                : taxonomicEventFilterToHogQL(g, v)\n                                            if (\n                                                setQuery &&\n                                                hogQl &&\n                                                sourceFeatures.has(QueryFeature.selectAndOrderByColumns)\n                                            ) {\n                                                // Typecasting to a query type with select and order_by fields.\n                                                // The actual query may or may not be an events query.\n                                                const source = query.source as EventsQuery\n                                                const columns = columnsInLemonTable ?? getDataNodeDefaultColumns(source)\n                                                const isAggregation = isHogQLAggregation(hogQl)\n                                                const isOrderBy = source.orderBy?.[0] === key\n                                                const isDescOrderBy = source.orderBy?.[0] === `${key} DESC`\n                                                setQuery({\n                                                    ...query,\n                                                    source: {\n                                                        ...source,\n                                                        select: columns\n                                                            .map((s, i) => (i === index",
            "cost": 0.159955
        },
        "PostHog__posthog.main/frontend/src/scenes/groups/Group.tsx": {
            "output": "import { useActions, useValues } from 'kea'\nimport { router } from 'kea-router'\n\nimport { ActivityLog } from 'lib/components/ActivityLog/ActivityLog'\nimport { NotFound } from 'lib/components/NotFound'\nimport { PropertiesTable } from 'lib/components/PropertiesTable'\nimport { isEventFilter } from 'lib/components/UniversalFilters/utils'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { LemonBanner } from 'lib/lemon-ui/LemonBanner'\nimport { LemonTabs } from 'lib/lemon-ui/LemonTabs'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { Link } from 'lib/lemon-ui/Link'\nimport { Spinner, SpinnerOverlay } from 'lib/lemon-ui/Spinner/Spinner'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { capitalizeFirstLetter } from 'lib/utils'\nimport { GroupLogicProps, groupLogic } from 'scenes/groups/groupLogic'\nimport { NotebookSelectButton } from 'scenes/notebooks/NotebookSelectButton/NotebookSelectButton'\nimport { NotebookNodeType } from 'scenes/notebooks/types'\nimport { groupDisplayId } from 'scenes/persons/GroupActorDisplay'\nimport { RelatedFeatureFlags } from 'scenes/persons/RelatedFeatureFlags'\nimport { SceneExport } from 'scenes/sceneTypes'\nimport { SessionRecordingsPlaylist } from 'scenes/session-recordings/playlist/SessionRecordingsPlaylist'\nimport { filtersFromUniversalFilterGroups } from 'scenes/session-recordings/utils'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { SceneContent } from '~/layout/scenes/components/SceneContent'\nimport { SceneDivider } from '~/layout/scenes/components/SceneDivider'\nimport { SceneTitleSection } from '~/layout/scenes/components/SceneTitleSection'\nimport { groupsModel } from '~/models/groupsModel'\nimport { Query } from '~/queries/Query/Query'\nimport type { ActionFilter } from '~/types'\nimport {\n    ActivityScope,\n    FilterLogicalOperator,\n    GroupsTabType,\n    PersonsTabType,\n    PropertyDefinitionType,\n    PropertyFilterType,\n    PropertyOperator,\n} from '~/types'\n\nimport { GroupFeedCanvas } from 'products/customer_analytics/frontend/components/GroupFeedCanvas/GroupFeedCanvas'\n\nimport { GroupOverview } from './GroupOverview'\nimport { RelatedGroups } from './RelatedGroups'\nimport { GroupNotebookCard } from './cards/GroupNotebookCard'\nimport { GroupCaption } from './components/GroupCaption'\n\nexport const scene: SceneExport<GroupLogicProps> = {\n    component: Group,\n    logic: groupLogic,\n    paramsToProps: ({ params: { groupTypeIndex, groupKey } }) => ({\n        groupTypeIndex: parseInt(groupTypeIndex ?? '0'),\n        groupKey: decodeURIComponent(groupKey ?? ''),\n    }),\n}\n\nexport function Group({ tabId }: { tabId?: string }): JSX.Element {\n    if (!tabId) {\n        throw new Error('GroupScene rendered with no tabId')\n    }\n\n    const { logicProps, groupData, groupDataLoading, groupTypeName, groupType, groupTab, groupEventsQuery } =\n        useValues(groupLogic)\n    const { groupKey, groupTypeIndex } = logicProps\n    const { setGroupEventsQuery, editProperty, deleteProperty } = useActions(groupLogic)\n    const { currentTeam } = useValues(teamLogic)\n    const { featureFlags } = useValues(featureFlagLogic)\n    const { aggregationLabel } = useValues(groupsModel)\n\n    if (!groupData || !groupType) {\n        return groupDataLoading ? <SpinnerOverlay sceneLevel /> : <NotFound object=\"group\" />\n    }\n\n    const settingLevel = featureFlags[FEATURE_FLAGS.ENVIRONMENTS] ? 'environment' : 'project'\n    const activeTab = groupTab ?? (featureFlags[FEATURE_FLAGS.CUSTOMER_ANALYTICS] ? 'feed' : 'overview')\n\n    return (\n        <SceneContent>\n            <SceneTitleSection\n                name={groupDisplayId(groupData.group_key, groupData.group_properties)}\n                resourceType={{ type: 'group' }}\n                forceBackTo={{\n                    name: capitalizeFirstLetter(aggregationLabel(groupTypeIndex).plural),\n                    key: 'groups',\n                    path: urls.groups(groupTypeIndex),\n                }}\n                actions={\n                    <NotebookSelectButton\n                        size=\"small\"\n                        type=\"secondary\"\n                        resource={{\n                            type: NotebookNodeType.Group,\n                            attrs: {\n                                id: groupKey,\n                                groupTypeIndex: groupTypeIndex,\n                            },\n                        }}\n                    />\n                }\n            />\n            <GroupCaption groupData={groupData} groupTypeName={groupTypeName} />\n            <SceneDivider />\n            <LemonTabs\n                sceneInset\n                activeKey={activeTab}\n                onChange={(tab) => router.actions.push(urls.group(String(groupTypeIndex), groupKey, true, tab))}\n                tabs={[\n                    ...(featureFlags[FEATURE_FLAGS.CUSTOMER_ANALYTICS]\n                        ? [\n                              {\n                                  key: GroupsTabType.FEED,\n                                  label: <span data-attr=\"groups-feed-tab\">Feed</span>,\n                                  content: <GroupFeedCanvas group={groupData} tabId={tabId} />,\n                              },\n                          ]\n                        : []),\n                    {\n                        key: GroupsTabType.OVERVIEW,\n                        label: <span data-attr=\"groups-overview-tab\">Overview</span>,\n                        content: <GroupOverview groupData={groupData} />,\n                    },\n                    ...(featureFlags[FEATURE_FLAGS.CRM_ITERATION_ONE] && groupData.notebook\n                        ? [\n                              {\n                                  key: GroupsTabType.NOTES,\n                                  label: <span data-attr=\"groups-notes-tab\">Notes</span>,\n                                  content: <GroupNotebookCard shortId={groupData.notebook} />,\n                              },\n                          ]\n                        : []),\n                    {\n                        key: PersonsTabType.PROPERTIES,\n                        label: <span data-attr=\"groups-properties-tab\">Properties</span>,\n                        content: (\n                            <PropertiesTable\n                                type={PropertyDefinitionType.Group}\n                                properties={groupData.group_properties || {}}\n                                embedded={false}\n                                onEdit={editProperty}\n                                onDelete={deleteProperty}\n                                searchable\n                            />\n                        ),\n                    },\n                    {\n                        key: PersonsTabType.EVENTS,\n                        label: <span data-attr=\"groups-events-tab\">Events</span>,\n                        content: groupEventsQuery ? (\n                            <Query\n                                query={groupEventsQuery}\n                                setQuery={setGroupEventsQuery}\n                                context={{ refresh: 'force_blocking' }}\n                            />\n                        ) : (\n                            <Spinner />\n                        ),\n                    },\n                    {\n                        key: PersonsTabType.SESSION_RECORDINGS,\n                        label: <span data-attr=\"group-session-recordings-tab\">Recordings</span>,\n                        content: (\n                            <>\n                                {!currentTeam?.session_recording_opt_in ? (\n                                    <div className=\"mb-4\">\n                                        <LemonBanner type=\"info\">\n                                            Session recordings are currently disabled for this {settingLevel}. To use\n                                            this feature, please go to your{' '}\n                                            <Link to={`${urls.settings('project')}#recordings`}>project settings</Link>{' '}\n                                            and enable it.\n                                        </LemonBanner>\n                                    </div>\n                                ) : (\n                                    <div className=\"SessionRecordingPlaylistHeightWrapper\">\n                                        <SessionRecordingsPlaylist\n                                            logicKey={`groups-recordings-${groupKey}-${groupTypeIndex}`}\n                                            updateSearchParams\n                                            filters={{\n                                                duration: [\n                                                    {\n                                                        type: PropertyFilterType.Recording,\n                                                        key: 'duration',\n                                                        value: 1,\n                                                        operator: PropertyOperator.GreaterThan,\n                                                    },\n                                                ],\n                                                filter_group: {\n                                                    type: FilterLogicalOperator.And,\n                                                    values: [\n                                                        {\n                                                            type: FilterLogicalOperator.And,\n                                                            values: [\n                                                                {\n                                                                    type: 'events',\n                                                                    name: 'All events',\n                                                                    properties: [\n                                                                        {\n                                                                            key: `$group_${groupTypeIndex} = '${groupKey}'`,\n                                                                            type: 'hogql',\n                                                                        },\n                                                                    ],\n                                                                } as ActionFilter,\n                                                            ],\n                                                        },\n                                                    ],\n                                                },\n                                            }}\n                                            onFiltersChange={(filters) => {\n                                                const eventFilters =\n                                                    filtersFromUniversalFilterGroups(filters).filter(isEventFilter)\n\n                                                const stillHasGroupFilter = eventFilters?.some((event) => {\n                                                    return event.properties?.some(\n                                                        (prop: Record<string, any>) =>\n                                                            prop.key === `$group_${groupTypeIndex} = '${groupKey}'`\n                                                    )\n                                                })\n                                                if (!stillHasGroupFilter) {\n                                                    lemonToast.warning(\n                                                        'Group filter removed. Please add it back to see recordings for this group.'\n                                                    )\n                                                }\n                                            }}\n                                        />\n                                    </div>\n                                )}\n                            </>\n                        ),\n                    },\n                    {\n                        key: PersonsTabType.RELATED,\n                        label: (\n                            <div className=\"flex items-center\" data-attr=\"group-related-tab\">\n                                Related people & groups\n                            </div>\n                        ),\n                        tooltip: `People and groups that have shared events with this ${groupTypeName} in the last 90 days.`,\n                        content: <RelatedGroups id={groupKey} groupTypeIndex={groupTypeIndex} />,\n                    },\n                    {\n                        key: PersonsTabType.FEATURE_FLAGS,\n                        label: <span data-attr=\"groups-related-flags-tab\">Feature flags</span>,\n                        tooltip: `Only shows feature flags with targeting conditions based on ${groupTypeName} properties.`,\n                        content: (\n                            <RelatedFeatureFlags\n                                distinctId={groupData.group_key}\n                                groupTypeIndex={groupTypeIndex}\n                                groups={{ [groupType]: groupKey }}\n                            />\n                        ),\n                    },\n                    {\n                        key: PersonsTabType.HISTORY,\n                        label: 'History',\n                        content: (\n                            <ActivityLog\n                                scope={ActivityScope.GROUP}\n                                id={`${groupTypeIndex}-${groupKey}`}\n                                caption={\n                                    <LemonBanner type=\"info\">\n                                        This page only shows changes made by users in the PostHog site. Automatic\n                                        changes from the API aren't shown here.\n                                    </LemonBanner>\n                                }\n                            />\n                        ),\n                    },\n                ]}\n            />\n        </SceneContent>\n    )\n}",
            "output_extracted": "import { useActions, useValues } from 'kea'\nimport { router } from 'kea-router'\n\nimport { ActivityLog } from 'lib/components/ActivityLog/ActivityLog'\nimport { NotFound } from 'lib/components/NotFound'\nimport { PropertiesTable } from 'lib/components/PropertiesTable'\nimport { isEventFilter } from 'lib/components/UniversalFilters/utils'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { LemonBanner } from 'lib/lemon-ui/LemonBanner'\nimport { LemonTabs } from 'lib/lemon-ui/LemonTabs'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { Link } from 'lib/lemon-ui/Link'\nimport { Spinner, SpinnerOverlay } from 'lib/lemon-ui/Spinner/Spinner'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { capitalizeFirstLetter } from 'lib/utils'\nimport { GroupLogicProps, groupLogic } from 'scenes/groups/groupLogic'\nimport { NotebookSelectButton } from 'scenes/notebooks/NotebookSelectButton/NotebookSelectButton'\nimport { NotebookNodeType } from 'scenes/notebooks/types'\nimport { groupDisplayId } from 'scenes/persons/GroupActorDisplay'\nimport { RelatedFeatureFlags } from 'scenes/persons/RelatedFeatureFlags'\nimport { SceneExport } from 'scenes/sceneTypes'\nimport { SessionRecordingsPlaylist } from 'scenes/session-recordings/playlist/SessionRecordingsPlaylist'\nimport { filtersFromUniversalFilterGroups } from 'scenes/session-recordings/utils'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { SceneContent } from '~/layout/scenes/components/SceneContent'\nimport { SceneDivider } from '~/layout/scenes/components/SceneDivider'\nimport { SceneTitleSection } from '~/layout/scenes/components/SceneTitleSection'\nimport { groupsModel } from '~/models/groupsModel'\nimport { Query } from '~/queries/Query/Query'\nimport type { ActionFilter } from '~/types'\nimport {\n    ActivityScope,\n    FilterLogicalOperator,\n    GroupsTabType,\n    PersonsTabType,\n    PropertyDefinitionType,\n    PropertyFilterType,\n    PropertyOperator,\n} from '~/types'\n\nimport { GroupFeedCanvas } from 'products/customer_analytics/frontend/components/GroupFeedCanvas/GroupFeedCanvas'\n\nimport { GroupOverview } from './GroupOverview'\nimport { RelatedGroups } from './RelatedGroups'\nimport { GroupNotebookCard } from './cards/GroupNotebookCard'\nimport { GroupCaption } from './components/GroupCaption'\n\nexport const scene: SceneExport<GroupLogicProps> = {\n    component: Group,\n    logic: groupLogic,\n    paramsToProps: ({ params: { groupTypeIndex, groupKey } }) => ({\n        groupTypeIndex: parseInt(groupTypeIndex ?? '0'),\n        groupKey: decodeURIComponent(groupKey ?? ''),\n    }),\n}\n\nexport function Group({ tabId }: { tabId?: string }): JSX.Element {\n    if (!tabId) {\n        throw new Error('GroupScene rendered with no tabId')\n    }\n\n    const { logicProps, groupData, groupDataLoading, groupTypeName, groupType, groupTab, groupEventsQuery } =\n        useValues(groupLogic)\n    const { groupKey, groupTypeIndex } = logicProps\n    const { setGroupEventsQuery, editProperty, deleteProperty } = useActions(groupLogic)\n    const { currentTeam } = useValues(teamLogic)\n    const { featureFlags } = useValues(featureFlagLogic)\n    const { aggregationLabel } = useValues(groupsModel)\n\n    if (!groupData || !groupType) {\n        return groupDataLoading ? <SpinnerOverlay sceneLevel /> : <NotFound object=\"group\" />\n    }\n\n    const settingLevel = featureFlags[FEATURE_FLAGS.ENVIRONMENTS] ? 'environment' : 'project'\n    const activeTab = groupTab ?? (featureFlags[FEATURE_FLAGS.CUSTOMER_ANALYTICS] ? 'feed' : 'overview')\n\n    return (\n        <SceneContent>\n            <SceneTitleSection\n                name={groupDisplayId(groupData.group_key, groupData.group_properties)}\n                resourceType={{ type: 'group' }}\n                forceBackTo={{\n                    name: capitalizeFirstLetter(aggregationLabel(groupTypeIndex).plural),\n                    key: 'groups',\n                    path: urls.groups(groupTypeIndex),\n                }}\n                actions={\n                    <NotebookSelectButton\n                        size=\"small\"\n                        type=\"secondary\"\n                        resource={{\n                            type: NotebookNodeType.Group,\n                            attrs: {\n                                id: groupKey,\n                                groupTypeIndex: groupTypeIndex,\n                            },\n                        }}\n                    />\n                }\n            />\n            <GroupCaption groupData={groupData} groupTypeName={groupTypeName} />\n            <SceneDivider />\n            <LemonTabs\n                sceneInset\n                activeKey={activeTab}\n                onChange={(tab) => router.actions.push(urls.group(String(groupTypeIndex), groupKey, true, tab))}\n                tabs={[\n                    ...(featureFlags[FEATURE_FLAGS.CUSTOMER_ANALYTICS]\n                        ? [\n                              {\n                                  key: GroupsTabType.FEED,\n                                  label: <span data-attr=\"groups-feed-tab\">Feed</span>,\n                                  content: <GroupFeedCanvas group={groupData} tabId={tabId} />,\n                              },\n                          ]\n                        : []),\n                    {\n                        key: GroupsTabType.OVERVIEW,\n                        label: <span data-attr=\"groups-overview-tab\">Overview</span>,\n                        content: <GroupOverview groupData={groupData} />,\n                    },\n                    ...(featureFlags[FEATURE_FLAGS.CRM_ITERATION_ONE] && groupData.notebook\n                        ? [\n                              {\n                                  key: GroupsTabType.NOTES,\n                                  label: <span data-attr=\"groups-notes-tab\">Notes</span>,\n                                  content: <GroupNotebookCard shortId={groupData.notebook} />,\n                              },\n                          ]\n                        : []),\n                    {\n                        key: PersonsTabType.PROPERTIES,\n                        label: <span data-attr=\"groups-properties-tab\">Properties</span>,\n                        content: (\n                            <PropertiesTable\n                                type={PropertyDefinitionType.Group}\n                                properties={groupData.group_properties || {}}\n                                embedded={false}\n                                onEdit={editProperty}\n                                onDelete={deleteProperty}\n                                searchable\n                            />\n                        ),\n                    },\n                    {\n                        key: PersonsTabType.EVENTS,\n                        label: <span data-attr=\"groups-events-tab\">Events</span>,\n                        content: groupEventsQuery ? (\n                            <Query\n                                query={groupEventsQuery}\n                                setQuery={setGroupEventsQuery}\n                                context={{ refresh: 'force_blocking' }}\n                            />\n                        ) : (\n                            <Spinner />\n                        ),\n                    },\n                    {\n                        key: PersonsTabType.SESSION_RECORDINGS,\n                        label: <span data-attr=\"group-session-recordings-tab\">Recordings</span>,\n                        content: (\n                            <>\n                                {!currentTeam?.session_recording_opt_in ? (\n                                    <div className=\"mb-4\">\n                                        <LemonBanner type=\"info\">\n                                            Session recordings are currently disabled for this {settingLevel}. To use\n                                            this feature, please go to your{' '}\n                                            <Link to={`${urls.settings('project')}#recordings`}>project settings</Link>{' '}\n                                            and enable it.\n                                        </LemonBanner>\n                                    </div>\n                                ) : (\n                                    <div className=\"SessionRecordingPlaylistHeightWrapper\">\n                                        <SessionRecordingsPlaylist\n                                            logicKey={`groups-recordings-${groupKey}-${groupTypeIndex}`}\n                                            updateSearchParams\n                                            filters={{\n                                                duration: [\n                                                    {\n                                                        type: PropertyFilterType.Recording,\n                                                        key: 'duration',\n                                                        value: 1,\n                                                        operator: PropertyOperator.GreaterThan,\n                                                    },\n                                                ],\n                                                filter_group: {\n                                                    type: FilterLogicalOperator.And,\n                                                    values: [\n                                                        {\n                                                            type: FilterLogicalOperator.And,\n                                                            values: [\n                                                                {\n                                                                    type: 'events',\n                                                                    name: 'All events',\n                                                                    properties: [\n                                                                        {\n                                                                            key: `$group_${groupTypeIndex} = '${groupKey}'`,\n                                                                            type: 'hogql',\n                                                                        },\n                                                                    ],\n                                                                } as ActionFilter,\n                                                            ],\n                                                        },\n                                                    ],\n                                                },\n                                            }}\n                                            onFiltersChange={(filters) => {\n                                                const eventFilters =\n                                                    filtersFromUniversalFilterGroups(filters).filter(isEventFilter)\n\n                                                const stillHasGroupFilter = eventFilters?.some((event) => {\n                                                    return event.properties?.some(\n                                                        (prop: Record<string, any>) =>\n                                                            prop.key === `$group_${groupTypeIndex} = '${groupKey}'`\n                                                    )\n                                                })\n                                                if (!stillHasGroupFilter) {\n                                                    lemonToast.warning(\n                                                        'Group filter removed. Please add it back to see recordings for this group.'\n                                                    )\n                                                }\n                                            }}\n                                        />\n                                    </div>\n                                )}\n                            </>\n                        ),\n                    },\n                    {\n                        key: PersonsTabType.RELATED,\n                        label: (\n                            <div className=\"flex items-center\" data-attr=\"group-related-tab\">\n                                Related people & groups\n                            </div>\n                        ),\n                        tooltip: `People and groups that have shared events with this ${groupTypeName} in the last 90 days.`,\n                        content: <RelatedGroups id={groupKey} groupTypeIndex={groupTypeIndex} />,\n                    },\n                    {\n                        key: PersonsTabType.FEATURE_FLAGS,\n                        label: <span data-attr=\"groups-related-flags-tab\">Feature flags</span>,\n                        tooltip: `Only shows feature flags with targeting conditions based on ${groupTypeName} properties.`,\n                        content: (\n                            <RelatedFeatureFlags\n                                distinctId={groupData.group_key}\n                                groupTypeIndex={groupTypeIndex}\n                                groups={{ [groupType]: groupKey }}\n                            />\n                        ),\n                    },\n                    {\n                        key: PersonsTabType.HISTORY,\n                        label: 'History',\n                        content: (\n                            <ActivityLog\n                                scope={ActivityScope.GROUP}\n                                id={`${groupTypeIndex}-${groupKey}`}\n                                caption={\n                                    <LemonBanner type=\"info\">\n                                        This page only shows changes made by users in the PostHog site. Automatic\n                                        changes from the API aren't shown here.\n                                    </LemonBanner>\n                                }\n                            />\n                        ),\n                    },\n                ]}\n            />\n        </SceneContent>\n    )\n}",
            "cost": 0.09644000000000001
        },
        "PostHog__posthog.main/frontend/src/scenes/groups/Groups.tsx": {
            "output": "import { useActions, useValues } from 'kea'\nimport { router } from 'kea-router'\n\nimport { IconPeople } from '@posthog/icons'\n\nimport { useFeatureFlag } from 'lib/hooks/useFeatureFlag'\nimport { GroupsAccessStatus, groupsAccessLogic } from 'lib/introductions/groupsAccessLogic'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonInput } from 'lib/lemon-ui/LemonInput'\nimport { LemonModal } from 'lib/lemon-ui/LemonModal'\nimport { Link } from 'lib/lemon-ui/Link'\nimport { capitalizeFirstLetter } from 'lib/utils'\nimport { GroupsIntroduction } from 'scenes/groups/GroupsIntroduction'\nimport { PersonsManagementSceneTabs } from 'scenes/persons-management/PersonsManagementSceneTabs'\nimport { SceneExport } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport { SceneContent } from '~/layout/scenes/components/SceneContent'\nimport { SceneTitleSection } from '~/layout/scenes/components/SceneTitleSection'\nimport { groupsModel } from '~/models/groupsModel'\nimport { Query } from '~/queries/Query/Query'\nimport { QueryContext } from '~/queries/types'\n\nimport { getCRMColumns } from './crm/utils'\nimport { groupViewLogic } from './groupViewLogic'\nimport { groupsListLogic } from './groupsListLogic'\nimport { groupsSceneLogic } from './groupsSceneLogic'\n\nexport const scene: SceneExport = {\n    component: GroupsScene,\n    logic: groupsSceneLogic,\n}\n\nexport function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n    if (!tabId) {\n        throw new Error('GroupsScene rendered with no tabId')\n    }\n    const { groupTypeIndex, groupTypeName, groupTypeNamePlural } = useValues(groupsSceneLogic)\n\n    const mountedGroupsListLogic = groupsListLogic({ groupTypeIndex })\n    const { query, queryWasModified } = useValues(mountedGroupsListLogic)\n    const { setQuery } = useActions(mountedGroupsListLogic)\n\n    const { saveGroupViewModalOpen, groupViewName } = useValues(groupViewLogic)\n    const { setSaveGroupViewModalOpen, setGroupViewName, saveGroupView } = useActions(groupViewLogic)\n\n    const { groupsAccessStatus } = useValues(groupsAccessLogic)\n    const { aggregationLabel } = useValues(groupsModel)\n    const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n\n    if (groupTypeIndex === undefined) {\n        throw new Error('groupTypeIndex is undefined')\n    }\n\n    if (\n        groupsAccessStatus == GroupsAccessStatus.HasAccess ||\n        groupsAccessStatus == GroupsAccessStatus.HasGroupTypes ||\n        groupsAccessStatus == GroupsAccessStatus.NoAccess\n    ) {\n        return (\n            <SceneContent>\n                <PersonsManagementSceneTabs tabKey={`groups-${groupTypeIndex}`} />\n                <SceneTitleSection\n                    name=\"Groups\"\n                    description=\"Associate events with a group or entity - such as a company, community, or project. Analyze these events as if they were sent by that entity itself. Great for B2B, marketplaces, and more.\"\n                    resourceType={{\n                        type: groupTypeName,\n                        forceIcon: <IconPeople />,\n                    }}\n                />\n                <GroupsIntroduction />\n            </SceneContent>\n        )\n    }\n\n    let columns = {\n        group_name: {\n            title: groupTypeName,\n        },\n    } as QueryContext['columns']\n    let hiddenColumns = [] as string[]\n    if (hasCrmIterationOneEnabled) {\n        columns = getCRMColumns(groupTypeName, groupTypeIndex)\n        hiddenColumns.push('key')\n    }\n\n    return (\n        <SceneContent>\n            <PersonsManagementSceneTabs tabKey={`groups-${groupTypeIndex}`} />\n\n            <SceneTitleSection\n                name={capitalizeFirstLetter(groupTypeNamePlural)}\n                description={`A catalog of all ${groupTypeNamePlural} for this project`}\n                resourceType={{\n                    type: 'cohort',\n                }}\n                actions={\n                    hasCrmIterationOneEnabled ? (\n                        <LemonButton\n                            type=\"primary\"\n                            size=\"small\"\n                            data-attr={`new-group-${groupTypeIndex}`}\n                            onClick={() => router.actions.push(urls.group(groupTypeIndex, 'new', false))}\n                        >\n                            New {aggregationLabel(groupTypeIndex).singular}\n                        </LemonButton>\n                    ) : undefined\n                }\n            />\n\n            <Query\n                uniqueKey={`groups-query-${tabId}`}\n                attachTo={groupsSceneLogic({ tabId })}\n                query={{ ...query, hiddenColumns }}\n                setQuery={setQuery}\n                context={{\n                    refresh: 'blocking',\n                    emptyStateHeading: queryWasModified\n                        ? `No ${groupTypeNamePlural} found`\n                        : `No ${groupTypeNamePlural} exist because none have been identified`,\n                    emptyStateDetail: queryWasModified ? (\n                        'Try changing the date range or property filters.'\n                    ) : (\n                        <>\n                            Go to the{' '}\n                            <Link to=\"https://posthog.com/docs/product-analytics/group-analytics#how-to-create-groups\">\n                                group analytics docs\n                            </Link>{' '}\n                            to learn what needs to be done\n                        </>\n                    ),\n                    columns,\n                    groupTypeLabel: groupTypeNamePlural,\n                }}\n                dataAttr=\"groups-table\"\n            />\n\n            {hasCrmIterationOneEnabled && (\n                <LemonModal\n                    isOpen={saveGroupViewModalOpen}\n                    onClose={() => setSaveGroupViewModalOpen(false)}\n                    title=\"Save filtered groups view\"\n                    footer={\n                        <>\n                            <LemonButton onClick={() => setSaveGroupViewModalOpen(false)}>Cancel</LemonButton>\n                            <LemonButton\n                                type=\"primary\"\n                                onClick={() => saveGroupView(window.location.href, groupTypeIndex)}\n                                disabledReason={!groupViewName.trim() ? 'Name is required' : undefined}\n                            >\n                                Save\n                            </LemonButton>\n                        </>\n                    }\n                >\n                    <div className=\"space-y-4\">\n                        <p>Save this filtered view as a shortcut in the People panel.</p>\n                        <LemonInput\n                            placeholder=\"Enter view name\"\n                            value={groupViewName}\n                            onChange={setGroupViewName}\n                            onKeyDown={(e) => {\n                                if (e.key === 'Enter' && groupViewName.trim()) {\n                                    saveGroupView(window.location.href, groupTypeIndex)\n                                }\n                            }}\n                            autoFocus\n                        />\n                    </div>\n                </LemonModal>\n            )}\n        </SceneContent>\n    )\n}",
            "output_extracted": "import { useActions, useValues } from 'kea'\nimport { router } from 'kea-router'\n\nimport { IconPeople } from '@posthog/icons'\n\nimport { useFeatureFlag } from 'lib/hooks/useFeatureFlag'\nimport { GroupsAccessStatus, groupsAccessLogic } from 'lib/introductions/groupsAccessLogic'\nimport { LemonButton } from 'lib/lemon-ui/LemonButton'\nimport { LemonInput } from 'lib/lemon-ui/LemonInput'\nimport { LemonModal } from 'lib/lemon-ui/LemonModal'\nimport { Link } from 'lib/lemon-ui/Link'\nimport { capitalizeFirstLetter } from 'lib/utils'\nimport { GroupsIntroduction } from 'scenes/groups/GroupsIntroduction'\nimport { PersonsManagementSceneTabs } from 'scenes/persons-management/PersonsManagementSceneTabs'\nimport { SceneExport } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport { SceneContent } from '~/layout/scenes/components/SceneContent'\nimport { SceneTitleSection } from '~/layout/scenes/components/SceneTitleSection'\nimport { groupsModel } from '~/models/groupsModel'\nimport { Query } from '~/queries/Query/Query'\nimport { QueryContext } from '~/queries/types'\n\nimport { getCRMColumns } from './crm/utils'\nimport { groupViewLogic } from './groupViewLogic'\nimport { groupsListLogic } from './groupsListLogic'\nimport { groupsSceneLogic } from './groupsSceneLogic'\n\nexport const scene: SceneExport = {\n    component: GroupsScene,\n    logic: groupsSceneLogic,\n}\n\nexport function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n    if (!tabId) {\n        throw new Error('GroupsScene rendered with no tabId')\n    }\n    const { groupTypeIndex, groupTypeName, groupTypeNamePlural } = useValues(groupsSceneLogic)\n\n    const mountedGroupsListLogic = groupsListLogic({ groupTypeIndex })\n    const { query, queryWasModified } = useValues(mountedGroupsListLogic)\n    const { setQuery } = useActions(mountedGroupsListLogic)\n\n    const { saveGroupViewModalOpen, groupViewName } = useValues(groupViewLogic)\n    const { setSaveGroupViewModalOpen, setGroupViewName, saveGroupView } = useActions(groupViewLogic)\n\n    const { groupsAccessStatus } = useValues(groupsAccessLogic)\n    const { aggregationLabel } = useValues(groupsModel)\n    const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n\n    if (groupTypeIndex === undefined) {\n        throw new Error('groupTypeIndex is undefined')\n    }\n\n    if (\n        groupsAccessStatus == GroupsAccessStatus.HasAccess ||\n        groupsAccessStatus == GroupsAccessStatus.HasGroupTypes ||\n        groupsAccessStatus == GroupsAccessStatus.NoAccess\n    ) {\n        return (\n            <SceneContent>\n                <PersonsManagementSceneTabs tabKey={`groups-${groupTypeIndex}`} />\n                <SceneTitleSection\n                    name=\"Groups\"\n                    description=\"Associate events with a group or entity - such as a company, community, or project. Analyze these events as if they were sent by that entity itself. Great for B2B, marketplaces, and more.\"\n                    resourceType={{\n                        type: groupTypeName,\n                        forceIcon: <IconPeople />,\n                    }}\n                />\n                <GroupsIntroduction />\n            </SceneContent>\n        )\n    }\n\n    let columns = {\n        group_name: {\n            title: groupTypeName,\n        },\n    } as QueryContext['columns']\n    let hiddenColumns = [] as string[]\n    if (hasCrmIterationOneEnabled) {\n        columns = getCRMColumns(groupTypeName, groupTypeIndex)\n        hiddenColumns.push('key')\n    }\n\n    return (\n        <SceneContent>\n            <PersonsManagementSceneTabs tabKey={`groups-${groupTypeIndex}`} />\n\n            <SceneTitleSection\n                name={capitalizeFirstLetter(groupTypeNamePlural)}\n                description={`A catalog of all ${groupTypeNamePlural} for this project`}\n                resourceType={{\n                    type: 'cohort',\n                }}\n                actions={\n                    hasCrmIterationOneEnabled ? (\n                        <LemonButton\n                            type=\"primary\"\n                            size=\"small\"\n                            data-attr={`new-group-${groupTypeIndex}`}\n                            onClick={() => router.actions.push(urls.group(groupTypeIndex, 'new', false))}\n                        >\n                            New {aggregationLabel(groupTypeIndex).singular}\n                        </LemonButton>\n                    ) : undefined\n                }\n            />\n\n            <Query\n                uniqueKey={`groups-query-${tabId}`}\n                attachTo={groupsSceneLogic({ tabId })}\n                query={{ ...query, hiddenColumns }}\n                setQuery={setQuery}\n                context={{\n                    refresh: 'blocking',\n                    emptyStateHeading: queryWasModified\n                        ? `No ${groupTypeNamePlural} found`\n                        : `No ${groupTypeNamePlural} exist because none have been identified`,\n                    emptyStateDetail: queryWasModified ? (\n                        'Try changing the date range or property filters.'\n                    ) : (\n                        <>\n                            Go to the{' '}\n                            <Link to=\"https://posthog.com/docs/product-analytics/group-analytics#how-to-create-groups\">\n                                group analytics docs\n                            </Link>{' '}\n                            to learn what needs to be done\n                        </>\n                    ),\n                    columns,\n                    groupTypeLabel: groupTypeNamePlural,\n                }}\n                dataAttr=\"groups-table\"\n            />\n\n            {hasCrmIterationOneEnabled && (\n                <LemonModal\n                    isOpen={saveGroupViewModalOpen}\n                    onClose={() => setSaveGroupViewModalOpen(false)}\n                    title=\"Save filtered groups view\"\n                    footer={\n                        <>\n                            <LemonButton onClick={() => setSaveGroupViewModalOpen(false)}>Cancel</LemonButton>\n                            <LemonButton\n                                type=\"primary\"\n                                onClick={() => saveGroupView(window.location.href, groupTypeIndex)}\n                                disabledReason={!groupViewName.trim() ? 'Name is required' : undefined}\n                            >\n                                Save\n                            </LemonButton>\n                        </>\n                    }\n                >\n                    <div className=\"space-y-4\">\n                        <p>Save this filtered view as a shortcut in the People panel.</p>\n                        <LemonInput\n                            placeholder=\"Enter view name\"\n                            value={groupViewName}\n                            onChange={setGroupViewName}\n                            onKeyDown={(e) => {\n                                if (e.key === 'Enter' && groupViewName.trim()) {\n                                    saveGroupView(window.location.href, groupTypeIndex)\n                                }\n                            }}\n                            autoFocus\n                        />\n                    </div>\n                </LemonModal>\n            )}\n        </SceneContent>\n    )\n}",
            "cost": 0.06249500000000001
        },
        "PostHog__posthog.main/frontend/src/scenes/groups/groupsNewLogic.ts": {
            "output": "import { actions, afterMount, beforeUnmount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl } from 'kea-router'\nimport { router } from 'kea-router'\n\nimport api from 'lib/api'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { capitalizeFirstLetter } from 'lib/utils'\nimport { Scene } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { Breadcrumb, CreateGroupParams, Group, GroupTypeIndex } from '~/types'\n\nimport type { groupsNewLogicType } from './groupsNewLogicType'\n\nexport type GroupsNewLogicProps = {\n    groupTypeIndex: number\n}\n\nexport interface NewGroupFormData {\n    name: string\n    group_key: string\n    group_type_index: number\n    customProperties: GroupProperty[]\n}\n\nexport interface GroupProperty {\n    name: string\n    type: 'string' | 'boolean'\n    value: string\n}\n\nconst NEW_GROUP = {} as NewGroupFormData\n\nexport const groupsNewLogic = kea<groupsNewLogicType>([\n    props({} as GroupsNewLogicProps),\n    key((props) => `${props.groupTypeIndex}-new`),\n    path((key) => ['scenes', 'groupsNew', 'groupsNewLogic', key]),\n\n    connect(() => ({\n        values: [groupsModel, ['aggregationLabel'], featureFlagLogic, ['featureFlags']],\n    })),\n\n    selectors({\n        logicProps: [() => [(_, props) => props], (props): GroupsNewLogicProps => props],\n        groupTypeName: [\n            (s) => [s.aggregationLabel, s.logicProps],\n            (aggregationLabel, logicProps): string => {\n                return aggregationLabel(logicProps.groupTypeIndex).singular\n            },\n        ],\n        groupTypeNamePlural: [\n            (s) => [s.aggregationLabel, s.logicProps],\n            (aggregationLabel, logicProps): string => {\n                return aggregationLabel(logicProps.groupTypeIndex).plural\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.logicProps, s.groupTypeName],\n            (logicProps, groupTypeName): Breadcrumb[] => {\n                return [\n                    {\n                        key: Scene.Groups,\n                        name: capitalizeFirstLetter(groupTypeName),\n                        path: urls.groups(logicProps.groupTypeIndex),\n                        iconType: 'group',\n                    },\n                    {\n                        key: Scene.GroupsNew,\n                        name: `Create ${groupTypeName}`,\n                        iconType: 'group',\n                    },\n                ]\n            },\n        ],\n    }),\n\n    actions({\n        saveGroup: (groupParams: CreateGroupParams) => ({ groupParams }),\n        addFormProperty: () => ({}),\n        removeFormProperty: (index: number) => ({ index }),\n    }),\n\n    reducers({\n        createdGroup: [\n            null as Group | null,\n            {\n                saveGroupSuccess: (_, { createdGroup }) => createdGroup,\n                resetGroup: () => null,\n            },\n        ],\n        customProperties: [\n            [] as GroupProperty[],\n            {\n                addProperty: (state) => [...state, { name: '', type: 'string' as const, value: '' }],\n                removeProperty: (state, { index }) => state.filter((_, i) => i !== index),\n                updateProperty: (state, { index, field, value }) =>\n                    state.map((prop, i) => (i === index ? { ...prop, [field]: value } : prop)),\n                resetGroup: () => [],\n            },\n        ],\n    }),\n\n    forms(({ actions, props }) => ({\n        group: {\n            defaults: NEW_GROUP,\n            errors: ({ group_key, name, customProperties }: NewGroupFormData) => {\n                const errors: Record<string, string | object | undefined> = {\n                    name: !name?.trim() ? 'Group name cannot be empty' : undefined,\n                    group_key: !group_key?.trim() ? 'Group key cannot be empty' : undefined,\n                }\n\n                if (customProperties && customProperties.length > 0) {\n                    const customPropertyErrors: any[] = []\n                    let hasCustomPropertyErrors = false\n\n                    customProperties.forEach((prop, index) => {\n                        const propertyErrors: any = {}\n\n                        if (!prop?.name?.trim()) {\n                            propertyErrors.name = 'Property name cannot be empty'\n                            hasCustomPropertyErrors = true\n                        }\n\n                        const duplicateIndex = customProperties.findIndex(\n                            (p, i) => i !== index && p?.name?.trim() === prop?.name?.trim()\n                        )\n                        if (duplicateIndex !== -1 && prop?.name?.trim()) {\n                            propertyErrors.name = 'Property name must be unique'\n                            hasCustomPropertyErrors = true\n                        }\n\n                        // Check for reserved property name 'name'\n                        if (prop?.name?.trim().toLowerCase() === 'name') {\n                            propertyErrors.name = 'Property name \"name\" is reserved'\n                            hasCustomPropertyErrors = true\n                        }\n\n                        customPropertyErrors[index] = propertyErrors\n                    })\n\n                    if (hasCustomPropertyErrors) {\n                        errors.customProperties = customPropertyErrors\n                    }\n                }\n\n                return errors\n            },\n            submit: (formData: NewGroupFormData) => {\n                const flattenedCustomProperties = flattenProperties(formData.customProperties || [])\n                const group_properties = {\n                    name: formData.name,\n                    ...flattenedCustomProperties,\n                }\n\n                const groupData: CreateGroupParams = {\n                    group_key: formData.group_key,\n                    group_type_index: props.groupTypeIndex as GroupTypeIndex,\n                    group_properties,\n                }\n                actions.saveGroup(groupData)\n            },\n        },\n    })),\n\n    loaders(() => ({\n        createdGroup: [\n            null as Group | null,\n            {\n                saveGroup: async ({ groupParams }): Promise<Group> => {\n                    try {\n                        const newGroup = await api.groups.create(groupParams)\n                        lemonToast.success('Group saved')\n                        return newGroup\n                    } catch (error) {\n                        lemonToast.error('Failed to save group')\n                        throw error\n                    }\n                },\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        submitGroup: () => {\n            if (values.groupHasErrors) {\n                lemonToast.error('There was an error submitting this group. Make sure all fields are filled correctly.')\n            }\n        },\n        saveGroupSuccess: () => actions.resetGroup(),\n        addFormProperty: () => {\n            const currentProperties = values.group.customProperties || []\n            actions.setGroupValue('customProperties', [\n                ...currentProperties,\n                { name: '', type: 'string' as const, value: '' },\n            ])\n        },\n        removeFormProperty: ({ index }) => {\n            const currentProperties = values.group.customProperties || []\n            actions.setGroupValue(\n                'customProperties',\n                currentProperties.filter((_, i) => i !== index)\n            )\n        },\n    })),\n\n    actionToUrl(({ values }) => ({\n        saveGroupSuccess: () => urls.groups(values.logicProps.groupTypeIndex),\n    })),\n\n    afterMount(({ props, values }) => {\n        // Redirect if the CRM feature flag is not enabled\n        if (!values.featureFlags[FEATURE_FLAGS.CRM_ITERATION_ONE]) {\n            router.actions.push(urls.groups(props.groupTypeIndex))\n        }\n    }),\n\n    beforeUnmount(({ actions }) => actions.resetGroup()),\n])\n\nexport function flattenProperties(properties: GroupProperty[]): Record<string, any> {\n    return properties\n        .filter((prop) => prop.name.trim() && prop.value.trim())\n        .reduce(\n            (acc, prop) => {\n                const key = prop.name.trim()\n                let value: any = prop.value\n\n                // Convert boolean type values to proper types\n                if (prop.type === 'boolean') {\n                    if (value === 'true') {\n                        value = true\n                    } else if (value === 'false') {\n                        value = false\n                    } else if (value === 'null') {\n                        value = null\n                    }\n                } else if (prop.type === 'string') {\n                    // Convert numeric strings to numbers\n                    const numericValue = Number(value)\n                    if (!isNaN(numericValue) && isFinite(numericValue) && value.trim() !== '') {\n                        value = numericValue\n                    }\n                }\n\n                acc[key] = value\n                return acc\n            },\n            {} as Record<string, any>\n        )\n}",
            "output_extracted": "import { actions, afterMount, beforeUnmount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl } from 'kea-router'\nimport { router } from 'kea-router'\n\nimport api from 'lib/api'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast/LemonToast'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { capitalizeFirstLetter } from 'lib/utils'\nimport { Scene } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { Breadcrumb, CreateGroupParams, Group, GroupTypeIndex } from '~/types'\n\nimport type { groupsNewLogicType } from './groupsNewLogicType'\n\nexport type GroupsNewLogicProps = {\n    groupTypeIndex: number\n}\n\nexport interface NewGroupFormData {\n    name: string\n    group_key: string\n    group_type_index: number\n    customProperties: GroupProperty[]\n}\n\nexport interface GroupProperty {\n    name: string\n    type: 'string' | 'boolean'\n    value: string\n}\n\nconst NEW_GROUP = {} as NewGroupFormData\n\nexport const groupsNewLogic = kea<groupsNewLogicType>([\n    props({} as GroupsNewLogicProps),\n    key((props) => `${props.groupTypeIndex}-new`),\n    path((key) => ['scenes', 'groupsNew', 'groupsNewLogic', key]),\n\n    connect(() => ({\n        values: [groupsModel, ['aggregationLabel'], featureFlagLogic, ['featureFlags']],\n    })),\n\n    selectors({\n        logicProps: [() => [(_, props) => props], (props): GroupsNewLogicProps => props],\n        groupTypeName: [\n            (s) => [s.aggregationLabel, s.logicProps],\n            (aggregationLabel, logicProps): string => {\n                return aggregationLabel(logicProps.groupTypeIndex).singular\n            },\n        ],\n        groupTypeNamePlural: [\n            (s) => [s.aggregationLabel, s.logicProps],\n            (aggregationLabel, logicProps): string => {\n                return aggregationLabel(logicProps.groupTypeIndex).plural\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.logicProps, s.groupTypeName],\n            (logicProps, groupTypeName): Breadcrumb[] => {\n                return [\n                    {\n                        key: Scene.Groups,\n                        name: capitalizeFirstLetter(groupTypeName),\n                        path: urls.groups(logicProps.groupTypeIndex),\n                        iconType: 'group',\n                    },\n                    {\n                        key: Scene.GroupsNew,\n                        name: `Create ${groupTypeName}`,\n                        iconType: 'group',\n                    },\n                ]\n            },\n        ],\n    }),\n\n    actions({\n        saveGroup: (groupParams: CreateGroupParams) => ({ groupParams }),\n        addFormProperty: () => ({}),\n        removeFormProperty: (index: number) => ({ index }),\n    }),\n\n    reducers({\n        createdGroup: [\n            null as Group | null,\n            {\n                saveGroupSuccess: (_, { createdGroup }) => createdGroup,\n                resetGroup: () => null,\n            },\n        ],\n        customProperties: [\n            [] as GroupProperty[],\n            {\n                addProperty: (state) => [...state, { name: '', type: 'string' as const, value: '' }],\n                removeProperty: (state, { index }) => state.filter((_, i) => i !== index),\n                updateProperty: (state, { index, field, value }) =>\n                    state.map((prop, i) => (i === index ? { ...prop, [field]: value } : prop)),\n                resetGroup: () => [],\n            },\n        ],\n    }),\n\n    forms(({ actions, props }) => ({\n        group: {\n            defaults: NEW_GROUP,\n            errors: ({ group_key, name, customProperties }: NewGroupFormData) => {\n                const errors: Record<string, string | object | undefined> = {\n                    name: !name?.trim() ? 'Group name cannot be empty' : undefined,\n                    group_key: !group_key?.trim() ? 'Group key cannot be empty' : undefined,\n                }\n\n                if (customProperties && customProperties.length > 0) {\n                    const customPropertyErrors: any[] = []\n                    let hasCustomPropertyErrors = false\n\n                    customProperties.forEach((prop, index) => {\n                        const propertyErrors: any = {}\n\n                        if (!prop?.name?.trim()) {\n                            propertyErrors.name = 'Property name cannot be empty'\n                            hasCustomPropertyErrors = true\n                        }\n\n                        const duplicateIndex = customProperties.findIndex(\n                            (p, i) => i !== index && p?.name?.trim() === prop?.name?.trim()\n                        )\n                        if (duplicateIndex !== -1 && prop?.name?.trim()) {\n                            propertyErrors.name = 'Property name must be unique'\n                            hasCustomPropertyErrors = true\n                        }\n\n                        // Check for reserved property name 'name'\n                        if (prop?.name?.trim().toLowerCase() === 'name') {\n                            propertyErrors.name = 'Property name \"name\" is reserved'\n                            hasCustomPropertyErrors = true\n                        }\n\n                        customPropertyErrors[index] = propertyErrors\n                    })\n\n                    if (hasCustomPropertyErrors) {\n                        errors.customProperties = customPropertyErrors\n                    }\n                }\n\n                return errors\n            },\n            submit: (formData: NewGroupFormData) => {\n                const flattenedCustomProperties = flattenProperties(formData.customProperties || [])\n                const group_properties = {\n                    name: formData.name,\n                    ...flattenedCustomProperties,\n                }\n\n                const groupData: CreateGroupParams = {\n                    group_key: formData.group_key,\n                    group_type_index: props.groupTypeIndex as GroupTypeIndex,\n                    group_properties,\n                }\n                actions.saveGroup(groupData)\n            },\n        },\n    })),\n\n    loaders(() => ({\n        createdGroup: [\n            null as Group | null,\n            {\n                saveGroup: async ({ groupParams }): Promise<Group> => {\n                    try {\n                        const newGroup = await api.groups.create(groupParams)\n                        lemonToast.success('Group saved')\n                        return newGroup\n                    } catch (error) {\n                        lemonToast.error('Failed to save group')\n                        throw error\n                    }\n                },\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        submitGroup: () => {\n            if (values.groupHasErrors) {\n                lemonToast.error('There was an error submitting this group. Make sure all fields are filled correctly.')\n            }\n        },\n        saveGroupSuccess: () => actions.resetGroup(),\n        addFormProperty: () => {\n            const currentProperties = values.group.customProperties || []\n            actions.setGroupValue('customProperties', [\n                ...currentProperties,\n                { name: '', type: 'string' as const, value: '' },\n            ])\n        },\n        removeFormProperty: ({ index }) => {\n            const currentProperties = values.group.customProperties || []\n            actions.setGroupValue(\n                'customProperties',\n                currentProperties.filter((_, i) => i !== index)\n            )\n        },\n    })),\n\n    actionToUrl(({ values }) => ({\n        saveGroupSuccess: () => urls.groups(values.logicProps.groupTypeIndex),\n    })),\n\n    afterMount(({ props, values }) => {\n        // Redirect if the CRM feature flag is not enabled\n        if (!values.featureFlags[FEATURE_FLAGS.CRM_ITERATION_ONE]) {\n            router.actions.push(urls.groups(props.groupTypeIndex))\n        }\n    }),\n\n    beforeUnmount(({ actions }) => actions.resetGroup()),\n])\n\nexport function flattenProperties(properties: GroupProperty[]): Record<string, any> {\n    return properties\n        .filter((prop) => prop.name.trim() && prop.value.trim())\n        .reduce(\n            (acc, prop) => {\n                const key = prop.name.trim()\n                let value: any = prop.value\n\n                // Convert boolean type values to proper types\n                if (prop.type === 'boolean') {\n                    if (value === 'true') {\n                        value = true\n                    } else if (value === 'false') {\n                        value = false\n                    } else if (value === 'null') {\n                        value = null\n                    }\n                } else if (prop.type === 'string') {\n                    // Convert numeric strings to numbers\n                    const numericValue = Number(value)\n                    if (!isNaN(numericValue) && isFinite(numericValue) && value.trim() !== '') {\n                        value = numericValue\n                    }\n                }\n\n                acc[key] = value\n                return acc\n            },\n            {} as Record<string, any>\n        )\n}",
            "cost": 0.07567000000000002
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "PostHog__posthog.main.42628",
        "repo": "PostHog/posthog",
        "base_commit": "e0fc7f7a8bd41e0e75e494b9ac2356c6e4543a14",
        "head_commit": "6be2364067e542770350f818bf0f5428a5c223d2",
        "title": "chore(customers): Gate customer analytics behind early access feature flag",
        "merged_at": "2025-12-03T22:09:47Z",
        "html_url": "https://github.com/PostHog/posthog/pull/42628",
        "test_files": [
            "frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts"
        ],
        "code_files": [
            "frontend/src/lib/constants.tsx",
            "frontend/src/queries/nodes/DataTable/DataTable.tsx",
            "frontend/src/scenes/groups/Group.tsx",
            "frontend/src/scenes/groups/Groups.tsx",
            "frontend/src/scenes/groups/groupsNewLogic.ts"
        ],
        "total_changes": 25,
        "num_files": 6,
        "pull_number": 42628,
        "patch": "diff --git a/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts b/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts\nindex 9004f8dfa1763..757be6c1b91f1 100644\n--- a/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts\n+++ b/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts\n@@ -86,7 +86,7 @@ describe('topBarSettingsButtonLogic', () => {\n         it('returns other setting section IDs regardless of CRM feature flag state', async () => {\n             router.actions.push(urls.persons())\n             featureFlagLogic.actions.setFeatureFlags([], {\n-                [FEATURE_FLAGS.CRM_ITERATION_ONE]: false,\n+                [FEATURE_FLAGS.CUSTOMER_ANALYTICS]: false,\n             })\n \n             await expectLogic(logic).toMatchValues({\n@@ -94,7 +94,7 @@ describe('topBarSettingsButtonLogic', () => {\n             })\n \n             featureFlagLogic.actions.setFeatureFlags([], {\n-                [FEATURE_FLAGS.CRM_ITERATION_ONE]: true,\n+                [FEATURE_FLAGS.CUSTOMER_ANALYTICS]: true,\n             })\n \n             await expectLogic(logic).toMatchValues({\ndiff --git a/frontend/src/lib/constants.tsx b/frontend/src/lib/constants.tsx\nindex b459816585d09..c4433c567dc8c 100644\n--- a/frontend/src/lib/constants.tsx\n+++ b/frontend/src/lib/constants.tsx\n@@ -237,10 +237,9 @@ export const FEATURE_FLAGS = {\n     ENDPOINTS: 'embedded-analytics', // owner: @sakce #team-clickhouse\n     SUPPORT_FORM_IN_ONBOARDING: 'support-form-in-onboarding', // owner: @joshsny\n     CRM_ITERATION_ONE: 'crm-iteration-one', // owner: @arthurdedeus #team-customer-analytics\n-    CRM_USAGE_METRICS: 'crm-usage-metrics', // owner: @arthurdedeus #team-customer-analytics\n     TOGGLE_PROPERTY_ARRAYS: 'toggle-property-arrays', // owner: @arthurdedeus #team-customer-analytics\n     DWH_JOIN_TABLE_PREVIEW: 'dwh-join-table-preview', // owner: @arthurdedeus #team-customer-analytics\n-    CUSTOMER_ANALYTICS: 'customer-analytics', // owner: @arthurdedeus #team-customer-analytics\n+    CUSTOMER_ANALYTICS: 'customer-analytics-roadmap', // owner: @arthurdedeus #team-customer-analytics\n     SETTINGS_SESSIONS_V2_JOIN: 'settings-sessions-v2-join', // owner: @robbie-c #team-web-analytics\n     SESSIONS_EXPLORER: 'sessions-explorer', // owner: @jabahamondes #team-web-analytics\n     SAVE_INSIGHT_TASK: 'save-insight-task', // owner: @joshsny\ndiff --git a/frontend/src/queries/nodes/DataTable/DataTable.tsx b/frontend/src/queries/nodes/DataTable/DataTable.tsx\nindex 013cc86d5bf95..2f99a9ad1faf5 100644\n--- a/frontend/src/queries/nodes/DataTable/DataTable.tsx\n+++ b/frontend/src/queries/nodes/DataTable/DataTable.tsx\n@@ -174,6 +174,7 @@ export function DataTable({\n \n     const canUseWebAnalyticsPreAggregatedTables = useFeatureFlag('SETTINGS_WEB_ANALYTICS_PRE_AGGREGATED_TABLES')\n     const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n+    const hasCustomerAnalyticsEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n     const usedWebAnalyticsPreAggregatedTables =\n         canUseWebAnalyticsPreAggregatedTables &&\n         response &&\n@@ -734,7 +735,8 @@ export function DataTable({\n     ].filter((x) => !!x)\n \n     const secondRowRight = [\n-        sourceFeatures.has(QueryFeature.linkDataButton) && hasCrmIterationOneEnabled ? (\n+        sourceFeatures.has(QueryFeature.linkDataButton) &&\n+        (hasCrmIterationOneEnabled || hasCustomerAnalyticsEnabled) ? (\n             <ViewLinkButton tableName=\"groups\" />\n         ) : null,\n         (showColumnConfigurator || showPersistentColumnConfigurator) &&\ndiff --git a/frontend/src/scenes/groups/Group.tsx b/frontend/src/scenes/groups/Group.tsx\nindex 92be4f42acd96..148c29e54ceab 100644\n--- a/frontend/src/scenes/groups/Group.tsx\n+++ b/frontend/src/scenes/groups/Group.tsx\n@@ -121,7 +121,7 @@ export function Group({ tabId }: { tabId?: string }): JSX.Element {\n                         label: <span data-attr=\"groups-overview-tab\">Overview</span>,\n                         content: <GroupOverview groupData={groupData} />,\n                     },\n-                    ...(featureFlags[FEATURE_FLAGS.CRM_ITERATION_ONE] && groupData.notebook\n+                    ...(featureFlags[FEATURE_FLAGS.CUSTOMER_ANALYTICS] && groupData.notebook\n                         ? [\n                               {\n                                   key: GroupsTabType.NOTES,\ndiff --git a/frontend/src/scenes/groups/Groups.tsx b/frontend/src/scenes/groups/Groups.tsx\nindex c4a4b5370c8a9..a83a6343156c6 100644\n--- a/frontend/src/scenes/groups/Groups.tsx\n+++ b/frontend/src/scenes/groups/Groups.tsx\n@@ -46,7 +46,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n \n     const { groupsAccessStatus } = useValues(groupsAccessLogic)\n     const { aggregationLabel } = useValues(groupsModel)\n-    const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n+    const hasCustomerAnalyticsEnabled = useFeatureFlag('CUSTOMER_ANALYTICS')\n \n     if (groupTypeIndex === undefined) {\n         throw new Error('groupTypeIndex is undefined')\n@@ -79,7 +79,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n         },\n     } as QueryContext['columns']\n     let hiddenColumns = [] as string[]\n-    if (hasCrmIterationOneEnabled) {\n+    if (hasCustomerAnalyticsEnabled) {\n         columns = getCRMColumns(groupTypeName, groupTypeIndex)\n         hiddenColumns.push('key')\n     }\n@@ -95,7 +95,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n                     type: 'cohort',\n                 }}\n                 actions={\n-                    hasCrmIterationOneEnabled ? (\n+                    hasCustomerAnalyticsEnabled ? (\n                         <LemonButton\n                             type=\"primary\"\n                             size=\"small\"\n@@ -135,7 +135,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n                 dataAttr=\"groups-table\"\n             />\n \n-            {hasCrmIterationOneEnabled && (\n+            {hasCustomerAnalyticsEnabled && (\n                 <LemonModal\n                     isOpen={saveGroupViewModalOpen}\n                     onClose={() => setSaveGroupViewModalOpen(false)}\ndiff --git a/frontend/src/scenes/groups/groupsNewLogic.ts b/frontend/src/scenes/groups/groupsNewLogic.ts\nindex 035f7a3134995..15cf699b4d92a 100644\n--- a/frontend/src/scenes/groups/groupsNewLogic.ts\n+++ b/frontend/src/scenes/groups/groupsNewLogic.ts\n@@ -213,8 +213,8 @@ export const groupsNewLogic = kea<groupsNewLogicType>([\n     })),\n \n     afterMount(({ props, values }) => {\n-        // Redirect if the CRM feature flag is not enabled\n-        if (!values.featureFlags[FEATURE_FLAGS.CRM_ITERATION_ONE]) {\n+        // Redirect if customer analytics is not enabled\n+        if (!values.featureFlags[FEATURE_FLAGS.CUSTOMER_ANALYTICS]) {\n             router.actions.push(urls.groups(props.groupTypeIndex))\n         }\n     }),\n",
        "pr_mirror": "PostHog__posthog.main"
    }
}