{
    "cost": 0.7105699999999999,
    "rewrites": {
        "PostHog__posthog.main/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts": {
            "output": "import { DateTime } from 'luxon'\n\nimport { InternalPerson, TeamId } from '~/types'\nimport { DB } from '~/utils/db/db'\nimport { MessageSizeTooLarge } from '~/utils/db/error'\n\nimport { captureIngestionWarning } from '../utils'\nimport { BatchWritingPersonsStore, BatchWritingPersonsStoreForBatch } from './batch-writing-person-store'\nimport {\n    personProfileBatchIgnoredPropertiesCounter,\n    personProfileBatchUpdateOutcomeCounter,\n    personPropertyKeyUpdateCounter,\n} from './metrics'\nimport { fromInternalPerson } from './person-update-batch'\n\n// Mock the utils module\njest.mock('../utils', () => ({\n    captureIngestionWarning: jest.fn().mockResolvedValue(undefined),\n}))\n\n// Mock metrics\njest.mock('./metrics', () => ({\n    observeLatencyByVersion: jest.fn(),\n    personCacheOperationsCounter: { inc: jest.fn() },\n    personCacheSizeHistogram: { observe: jest.fn() },\n    personDatabaseOperationsPerBatchHistogram: { observe: jest.fn() },\n    personFallbackOperationsCounter: { inc: jest.fn() },\n    personFetchForCheckingCacheOperationsCounter: { inc: jest.fn() },\n    personFetchForUpdateCacheOperationsCounter: { inc: jest.fn() },\n    personFlushBatchSizeHistogram: { observe: jest.fn() },\n    personFlushLatencyHistogram: { observe: jest.fn() },\n    personFlushOperationsCounter: { inc: jest.fn() },\n    personMethodCallsPerBatchHistogram: { observe: jest.fn() },\n    personOptimisticUpdateConflictsPerBatchCounter: { inc: jest.fn() },\n    personProfileBatchIgnoredPropertiesCounter: { labels: jest.fn().mockReturnValue({ inc: jest.fn() }) },\n    personProfileBatchUpdateOutcomeCounter: { labels: jest.fn().mockReturnValue({ inc: jest.fn() }) },\n    personPropertyKeyUpdateCounter: { labels: jest.fn().mockReturnValue({ inc: jest.fn() }) },\n    personRetryAttemptsHistogram: { observe: jest.fn() },\n    personWriteMethodAttemptCounter: { inc: jest.fn() },\n    personWriteMethodLatencyHistogram: { observe: jest.fn() },\n    totalPersonUpdateLatencyPerBatchHistogram: { observe: jest.fn() },\n}))\n\ndescribe('BatchWritingPersonStore', () => {\n    let db: DB\n    let personStore: BatchWritingPersonsStore\n    let mockRepo: any\n    let teamId: TeamId\n    let person: InternalPerson\n\n    beforeEach(() => {\n        teamId = 1\n        person = {\n            id: '1',\n            team_id: teamId,\n            properties: {\n                test: 'test',\n            },\n            created_at: DateTime.now(),\n            version: 1,\n            properties_last_updated_at: {},\n            properties_last_operation: {},\n            is_user_id: null,\n            is_identified: false,\n            uuid: '1',\n        }\n\n        let dbCounter = 0\n        db = {\n            postgres: {\n                transaction: jest.fn().mockImplementation(async (_usage, _tag, transaction) => {\n                    return await transaction(transaction)\n                }),\n            },\n            updatePerson: jest.fn().mockImplementation(() => {\n                dbCounter++\n                const personCopy = { ...person, version: dbCounter }\n                return Promise.resolve([personCopy, []])\n            }),\n            moveDistinctIds: jest.fn().mockImplementation(() => {\n                return Promise.resolve([])\n            }),\n        } as unknown as DB\n\n        mockRepo = createMockRepository()\n        personStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n    })\n\n    afterEach(() => {\n        jest.clearAllMocks()\n    })\n\n    const getBatchStoreForBatch = () => personStore.forBatch() as BatchWritingPersonsStoreForBatch\n\n    const createMockRepository = () => {\n        const mockRepo = {\n            fetchPerson: jest.fn().mockResolvedValue(person),\n            fetchPersonDistinctIds: jest.fn().mockResolvedValue([]),\n            fetchPersonsByDistinctIds: jest.fn().mockResolvedValue([]),\n            createPerson: jest.fn().mockResolvedValue([person, []]),\n            updatePerson: jest.fn().mockResolvedValue([person, [], false]),\n            updatePersonAssertVersion: jest.fn().mockResolvedValue([person.version + 1, []]),\n            deletePerson: jest.fn().mockResolvedValue([]),\n            addDistinctId: jest.fn().mockResolvedValue([]),\n            moveDistinctIds: jest.fn().mockResolvedValue({ success: true, messages: [], distinctIdsMoved: [] }),\n            addPersonlessDistinctId: jest.fn().mockResolvedValue(true),\n            addPersonlessDistinctIdForMerge: jest.fn().mockResolvedValue(true),\n            personPropertiesSize: jest.fn().mockResolvedValue(1024),\n            updateCohortsAndFeatureFlagsForMerge: jest.fn().mockResolvedValue(undefined),\n            inTransaction: jest.fn().mockImplementation(async (description, transaction) => {\n                return await transaction(transaction)\n            }),\n        }\n        return mockRepo\n    }\n\n    const createMockTransaction = () => {\n        const mockTransaction = {\n            fetchPersonDistinctIds: jest.fn().mockResolvedValue([]),\n            createPerson: jest.fn().mockResolvedValue([person, []]),\n            updatePerson: jest.fn().mockResolvedValue([person, [], false]),\n            deletePerson: jest.fn().mockResolvedValue([]),\n            addDistinctId: jest.fn().mockResolvedValue([]),\n            moveDistinctIds: jest.fn().mockResolvedValue({ success: true, messages: [], distinctIdsMoved: [] }),\n            addPersonlessDistinctIdForMerge: jest.fn().mockResolvedValue(true),\n            updateCohortsAndFeatureFlagsForMerge: jest.fn().mockResolvedValue(undefined),\n        }\n        return mockTransaction\n    }\n\n    it('should update person in cache', async () => {\n        const personStoreForBatch = getBatchStoreForBatch()\n        const response = await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            { new_value: 'new_value' },\n            [],\n            {},\n            'test'\n        )\n        expect(response).toEqual([\n            { ...person, version: 1, properties: { test: 'test', new_value: 'new_value' } },\n            [],\n            false,\n        ])\n\n        // Validate cache - should contain a PersonUpdate object\n        const cache = (personStoreForBatch as any)['personUpdateCache']\n        const cachedUpdate = cache.get(`${teamId}:${person.id}`)\n        expect(cachedUpdate).toBeDefined()\n        expect(cachedUpdate.distinct_id).toBe('test')\n        expect(cachedUpdate.needs_write).toBe(true)\n        expect(cachedUpdate.properties).toEqual({ test: 'test' }) // Original properties from database\n        expect(cachedUpdate.properties_to_set).toEqual({ new_value: 'new_value' }) // New properties to set\n        expect(cachedUpdate.properties_to_unset).toEqual([]) // No properties to unset\n        expect(cachedUpdate.team_id).toBe(1)\n        expect(cachedUpdate.id).toBe('1')\n    })\n\n    it('should handle unsetting properties', async () => {\n        const personStoreForBatch = getBatchStoreForBatch()\n        const response = await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            {\n                value_to_unset: 'value_to_unset',\n            },\n            [],\n            {},\n            'test'\n        )\n        expect(response).toEqual([\n            { ...person, version: 1, properties: { test: 'test', value_to_unset: 'value_to_unset' } },\n            [],\n            false,\n        ])\n\n        const response2 = await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            {},\n            ['value_to_unset'],\n            {},\n            'test'\n        )\n        expect(response2).toEqual([{ ...person, version: 1, properties: { test: 'test' } }, [], false])\n\n        // Check cache contains merged updates with conflict resolution\n        // When unsetting a property that was previously set, it should be removed from properties_to_set\n        const cache = personStoreForBatch.getUpdateCache()\n        const cachedUpdate = cache.get(`${teamId}:${person.id}`)!\n        expect(cachedUpdate.properties).toEqual({ test: 'test' })\n        expect(cachedUpdate.properties_to_set).toEqual({ test: 'test' })\n        expect(cachedUpdate.properties_to_unset).toEqual(['value_to_unset'])\n        expect(cachedUpdate.needs_write).toBe(true)\n\n        await personStoreForBatch.flush()\n\n        expect(mockRepo.updatePerson).toHaveBeenCalledWith(\n            expect.objectContaining({\n                properties: { test: 'test' },\n            }),\n            expect.anything(),\n            'updatePersonNoAssert'\n        )\n    })\n\n    it('should handle setting a property after unsetting it (re-setting)', async () => {\n        const personStoreForBatch = getBatchStoreForBatch()\n\n        // First, unset a property\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(person, {}, ['prop_to_toggle'], {}, 'test')\n\n        // Then, set the same property again\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            { prop_to_toggle: 'new_value' },\n            [],\n            {},\n            'test'\n        )\n\n        // Check cache - property should be in properties_to_set and NOT in properties_to_unset\n        const cache = personStoreForBatch.getUpdateCache()\n        const cachedUpdate = cache.get(`${teamId}:${person.id}`)!\n        expect(cachedUpdate.properties_to_set).toEqual({ test: 'test', prop_to_toggle: 'new_value' })\n        expect(cachedUpdate.properties_to_unset).toEqual([])\n\n        await personStoreForBatch.flush()\n\n        expect(mockRepo.updatePerson).toHaveBeenCalledWith(\n            expect.objectContaining({\n                properties: { test: 'test', prop_to_toggle: 'new_value' },\n            }),\n            expect.anything(),\n            'updatePersonNoAssert'\n        )\n    })\n\n    it('should handle unsetting a property after setting it', async () => {\n        const personStoreForBatch = getBatchStoreForBatch()\n\n        // First, set a property\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            { prop_to_toggle: 'some_value' },\n            [],\n            {},\n            'test'\n        )\n\n        // Then, unset the same property\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(person, {}, ['prop_to_toggle'], {}, 'test')\n\n        // Check cache - property should be in properties_to_unset and NOT in properties_to_set\n        const cache = personStoreForBatch.getUpdateCache()\n        const cachedUpdate = cache.get(`${teamId}:${person.id}`)!\n        expect(cachedUpdate.properties_to_set).toEqual({ test: 'test' })\n        expect(cachedUpdate.properties_to_unset).toEqual(['prop_to_toggle'])\n\n        await personStoreForBatch.flush()\n\n        expect(mockRepo.updatePerson).toHaveBeenCalledWith(\n            expect.objectContaining({\n                properties: { test: 'test' },\n            }),\n            expect.anything(),\n            'updatePersonNoAssert'\n        )\n    })\n\n    it('should remove person from caches when deleted', async () => {\n        const mockRepo = createMockRepository()\n        const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n        const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n\n        // Add person to cache using the proper PersonUpdate structure\n        let updateCache = personStoreForBatch.getUpdateCache()\n        const personUpdate = fromInternalPerson(person, 'test')\n        personUpdate.properties = { new_value: 'new_value' }\n        personUpdate.needs_write = false\n        updateCache.set(`${teamId}:${person.id}`, personUpdate)\n\n        let checkCache = personStoreForBatch.getCheckCache()\n        checkCache.set(`${teamId}:test`, person)\n\n        personStoreForBatch.setDistinctIdToPersonId(teamId, 'test', person.id)\n\n        const response = await personStoreForBatch.deletePerson(person, 'test')\n        expect(response).toEqual([])\n        // The cached person update should be passed to deletePerson\n        expect(mockRepo.deletePerson).toHaveBeenCalledWith(\n            expect.objectContaining({\n                ...person,\n                properties: { new_value: 'new_value' },\n            })\n        )\n\n        // Validate cache\n        updateCache = personStoreForBatch.getUpdateCache()\n        checkCache = personStoreForBatch.getCheckCache()\n        expect(updateCache.get(`${teamId}:${person.id}`)).toBeUndefined()\n        expect(checkCache.get(`${teamId}:${person.id}`)).toBeUndefined()\n    })\n\n    it('should flush person updates with default NO_ASSERT mode', async () => {\n        const personStoreForBatch = personStore.forBatch()\n\n        // Add a person update to cache\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            { new_value: 'new_value' },\n            [],\n            {},\n            'test'\n        )\n\n        // Flush should call updatePerson (NO_ASSERT default mode)\n        await personStoreForBatch.flush()\n\n        expect(mockRepo.updatePerson).toHaveBeenCalledTimes(1)\n        expect(mockRepo.updatePersonAssertVersion).not.toHaveBeenCalled()\n    })\n\n    it('should fallback to direct update when optimistic update fails', async () => {\n        // Use ASSERT_VERSION mode for this test since it tests optimistic behavior\n        const assertVersionStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer, {\n            dbWriteMode: 'ASSERT_VERSION',\n        })\n        const personStoreForBatch = assertVersionStore.forBatch()\n\n        // Mock optimistic update to fail (version mismatch)\n        mockRepo.updatePersonAssertVersion = jest.fn().mockResolvedValue([undefined, []])\n\n        // Add a person update to cache\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            { new_value: 'new_value' },\n            [],\n            {},\n            'test'\n        )\n\n        // Flush should retry optimistically then fallback to direct update\n        await personStoreForBatch.flush()\n\n        expect(mockRepo.updatePersonAssertVersion).toHaveBeenCalled()\n        expect(mockRepo.fetchPerson).toHaveBeenCalled() // Called during conflict resolution\n        expect(mockRepo.updatePerson).toHaveBeenCalled() // Fallback\n    })\n\n    it('should merge multiple updates for same person', async () => {\n        const personStoreForBatch = getBatchStoreForBatch()\n\n        // First update\n        await personStoreForBatch.updatePersonWithPropertiesDiffFor",
            "output_extracted": "import { DateTime } from 'luxon'\n\nimport { InternalPerson, TeamId } from '~/types'\nimport { DB } from '~/utils/db/db'\nimport { MessageSizeTooLarge } from '~/utils/db/error'\n\nimport { captureIngestionWarning } from '../utils'\nimport { BatchWritingPersonsStore, BatchWritingPersonsStoreForBatch } from './batch-writing-person-store'\nimport {\n    personProfileBatchIgnoredPropertiesCounter,\n    personProfileBatchUpdateOutcomeCounter,\n    personPropertyKeyUpdateCounter,\n} from './metrics'\nimport { fromInternalPerson } from './person-update-batch'\n\n// Mock the utils module\njest.mock('../utils', () => ({\n    captureIngestionWarning: jest.fn().mockResolvedValue(undefined),\n}))\n\n// Mock metrics\njest.mock('./metrics', () => ({\n    observeLatencyByVersion: jest.fn(),\n    personCacheOperationsCounter: { inc: jest.fn() },\n    personCacheSizeHistogram: { observe: jest.fn() },\n    personDatabaseOperationsPerBatchHistogram: { observe: jest.fn() },\n    personFallbackOperationsCounter: { inc: jest.fn() },\n    personFetchForCheckingCacheOperationsCounter: { inc: jest.fn() },\n    personFetchForUpdateCacheOperationsCounter: { inc: jest.fn() },\n    personFlushBatchSizeHistogram: { observe: jest.fn() },\n    personFlushLatencyHistogram: { observe: jest.fn() },\n    personFlushOperationsCounter: { inc: jest.fn() },\n    personMethodCallsPerBatchHistogram: { observe: jest.fn() },\n    personOptimisticUpdateConflictsPerBatchCounter: { inc: jest.fn() },\n    personProfileBatchIgnoredPropertiesCounter: { labels: jest.fn().mockReturnValue({ inc: jest.fn() }) },\n    personProfileBatchUpdateOutcomeCounter: { labels: jest.fn().mockReturnValue({ inc: jest.fn() }) },\n    personPropertyKeyUpdateCounter: { labels: jest.fn().mockReturnValue({ inc: jest.fn() }) },\n    personRetryAttemptsHistogram: { observe: jest.fn() },\n    personWriteMethodAttemptCounter: { inc: jest.fn() },\n    personWriteMethodLatencyHistogram: { observe: jest.fn() },\n    totalPersonUpdateLatencyPerBatchHistogram: { observe: jest.fn() },\n}))\n\ndescribe('BatchWritingPersonStore', () => {\n    let db: DB\n    let personStore: BatchWritingPersonsStore\n    let mockRepo: any\n    let teamId: TeamId\n    let person: InternalPerson\n\n    beforeEach(() => {\n        teamId = 1\n        person = {\n            id: '1',\n            team_id: teamId,\n            properties: {\n                test: 'test',\n            },\n            created_at: DateTime.now(),\n            version: 1,\n            properties_last_updated_at: {},\n            properties_last_operation: {},\n            is_user_id: null,\n            is_identified: false,\n            uuid: '1',\n        }\n\n        let dbCounter = 0\n        db = {\n            postgres: {\n                transaction: jest.fn().mockImplementation(async (_usage, _tag, transaction) => {\n                    return await transaction(transaction)\n                }),\n            },\n            updatePerson: jest.fn().mockImplementation(() => {\n                dbCounter++\n                const personCopy = { ...person, version: dbCounter }\n                return Promise.resolve([personCopy, []])\n            }),\n            moveDistinctIds: jest.fn().mockImplementation(() => {\n                return Promise.resolve([])\n            }),\n        } as unknown as DB\n\n        mockRepo = createMockRepository()\n        personStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n    })\n\n    afterEach(() => {\n        jest.clearAllMocks()\n    })\n\n    const getBatchStoreForBatch = () => personStore.forBatch() as BatchWritingPersonsStoreForBatch\n\n    const createMockRepository = () => {\n        const mockRepo = {\n            fetchPerson: jest.fn().mockResolvedValue(person),\n            fetchPersonDistinctIds: jest.fn().mockResolvedValue([]),\n            fetchPersonsByDistinctIds: jest.fn().mockResolvedValue([]),\n            createPerson: jest.fn().mockResolvedValue([person, []]),\n            updatePerson: jest.fn().mockResolvedValue([person, [], false]),\n            updatePersonAssertVersion: jest.fn().mockResolvedValue([person.version + 1, []]),\n            deletePerson: jest.fn().mockResolvedValue([]),\n            addDistinctId: jest.fn().mockResolvedValue([]),\n            moveDistinctIds: jest.fn().mockResolvedValue({ success: true, messages: [], distinctIdsMoved: [] }),\n            addPersonlessDistinctId: jest.fn().mockResolvedValue(true),\n            addPersonlessDistinctIdForMerge: jest.fn().mockResolvedValue(true),\n            personPropertiesSize: jest.fn().mockResolvedValue(1024),\n            updateCohortsAndFeatureFlagsForMerge: jest.fn().mockResolvedValue(undefined),\n            inTransaction: jest.fn().mockImplementation(async (description, transaction) => {\n                return await transaction(transaction)\n            }),\n        }\n        return mockRepo\n    }\n\n    const createMockTransaction = () => {\n        const mockTransaction = {\n            fetchPersonDistinctIds: jest.fn().mockResolvedValue([]),\n            createPerson: jest.fn().mockResolvedValue([person, []]),\n            updatePerson: jest.fn().mockResolvedValue([person, [], false]),\n            deletePerson: jest.fn().mockResolvedValue([]),\n            addDistinctId: jest.fn().mockResolvedValue([]),\n            moveDistinctIds: jest.fn().mockResolvedValue({ success: true, messages: [], distinctIdsMoved: [] }),\n            addPersonlessDistinctIdForMerge: jest.fn().mockResolvedValue(true),\n            updateCohortsAndFeatureFlagsForMerge: jest.fn().mockResolvedValue(undefined),\n        }\n        return mockTransaction\n    }\n\n    it('should update person in cache', async () => {\n        const personStoreForBatch = getBatchStoreForBatch()\n        const response = await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            { new_value: 'new_value' },\n            [],\n            {},\n            'test'\n        )\n        expect(response).toEqual([\n            { ...person, version: 1, properties: { test: 'test', new_value: 'new_value' } },\n            [],\n            false,\n        ])\n\n        // Validate cache - should contain a PersonUpdate object\n        const cache = (personStoreForBatch as any)['personUpdateCache']\n        const cachedUpdate = cache.get(`${teamId}:${person.id}`)\n        expect(cachedUpdate).toBeDefined()\n        expect(cachedUpdate.distinct_id).toBe('test')\n        expect(cachedUpdate.needs_write).toBe(true)\n        expect(cachedUpdate.properties).toEqual({ test: 'test' }) // Original properties from database\n        expect(cachedUpdate.properties_to_set).toEqual({ new_value: 'new_value' }) // New properties to set\n        expect(cachedUpdate.properties_to_unset).toEqual([]) // No properties to unset\n        expect(cachedUpdate.team_id).toBe(1)\n        expect(cachedUpdate.id).toBe('1')\n    })\n\n    it('should handle unsetting properties', async () => {\n        const personStoreForBatch = getBatchStoreForBatch()\n        const response = await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            {\n                value_to_unset: 'value_to_unset',\n            },\n            [],\n            {},\n            'test'\n        )\n        expect(response).toEqual([\n            { ...person, version: 1, properties: { test: 'test', value_to_unset: 'value_to_unset' } },\n            [],\n            false,\n        ])\n\n        const response2 = await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            {},\n            ['value_to_unset'],\n            {},\n            'test'\n        )\n        expect(response2).toEqual([{ ...person, version: 1, properties: { test: 'test' } }, [], false])\n\n        // Check cache contains merged updates with conflict resolution\n        // When unsetting a property that was previously set, it should be removed from properties_to_set\n        const cache = personStoreForBatch.getUpdateCache()\n        const cachedUpdate = cache.get(`${teamId}:${person.id}`)!\n        expect(cachedUpdate.properties).toEqual({ test: 'test' })\n        expect(cachedUpdate.properties_to_set).toEqual({ test: 'test' })\n        expect(cachedUpdate.properties_to_unset).toEqual(['value_to_unset'])\n        expect(cachedUpdate.needs_write).toBe(true)\n\n        await personStoreForBatch.flush()\n\n        expect(mockRepo.updatePerson).toHaveBeenCalledWith(\n            expect.objectContaining({\n                properties: { test: 'test' },\n            }),\n            expect.anything(),\n            'updatePersonNoAssert'\n        )\n    })\n\n    it('should handle setting a property after unsetting it (re-setting)', async () => {\n        const personStoreForBatch = getBatchStoreForBatch()\n\n        // First, unset a property\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(person, {}, ['prop_to_toggle'], {}, 'test')\n\n        // Then, set the same property again\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            { prop_to_toggle: 'new_value' },\n            [],\n            {},\n            'test'\n        )\n\n        // Check cache - property should be in properties_to_set and NOT in properties_to_unset\n        const cache = personStoreForBatch.getUpdateCache()\n        const cachedUpdate = cache.get(`${teamId}:${person.id}`)!\n        expect(cachedUpdate.properties_to_set).toEqual({ test: 'test', prop_to_toggle: 'new_value' })\n        expect(cachedUpdate.properties_to_unset).toEqual([])\n\n        await personStoreForBatch.flush()\n\n        expect(mockRepo.updatePerson).toHaveBeenCalledWith(\n            expect.objectContaining({\n                properties: { test: 'test', prop_to_toggle: 'new_value' },\n            }),\n            expect.anything(),\n            'updatePersonNoAssert'\n        )\n    })\n\n    it('should handle unsetting a property after setting it', async () => {\n        const personStoreForBatch = getBatchStoreForBatch()\n\n        // First, set a property\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            { prop_to_toggle: 'some_value' },\n            [],\n            {},\n            'test'\n        )\n\n        // Then, unset the same property\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(person, {}, ['prop_to_toggle'], {}, 'test')\n\n        // Check cache - property should be in properties_to_unset and NOT in properties_to_set\n        const cache = personStoreForBatch.getUpdateCache()\n        const cachedUpdate = cache.get(`${teamId}:${person.id}`)!\n        expect(cachedUpdate.properties_to_set).toEqual({ test: 'test' })\n        expect(cachedUpdate.properties_to_unset).toEqual(['prop_to_toggle'])\n\n        await personStoreForBatch.flush()\n\n        expect(mockRepo.updatePerson).toHaveBeenCalledWith(\n            expect.objectContaining({\n                properties: { test: 'test' },\n            }),\n            expect.anything(),\n            'updatePersonNoAssert'\n        )\n    })\n\n    it('should remove person from caches when deleted', async () => {\n        const mockRepo = createMockRepository()\n        const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n        const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n\n        // Add person to cache using the proper PersonUpdate structure\n        let updateCache = personStoreForBatch.getUpdateCache()\n        const personUpdate = fromInternalPerson(person, 'test')\n        personUpdate.properties = { new_value: 'new_value' }\n        personUpdate.needs_write = false\n        updateCache.set(`${teamId}:${person.id}`, personUpdate)\n\n        let checkCache = personStoreForBatch.getCheckCache()\n        checkCache.set(`${teamId}:test`, person)\n\n        personStoreForBatch.setDistinctIdToPersonId(teamId, 'test', person.id)\n\n        const response = await personStoreForBatch.deletePerson(person, 'test')\n        expect(response).toEqual([])\n        // The cached person update should be passed to deletePerson\n        expect(mockRepo.deletePerson).toHaveBeenCalledWith(\n            expect.objectContaining({\n                ...person,\n                properties: { new_value: 'new_value' },\n            })\n        )\n\n        // Validate cache\n        updateCache = personStoreForBatch.getUpdateCache()\n        checkCache = personStoreForBatch.getCheckCache()\n        expect(updateCache.get(`${teamId}:${person.id}`)).toBeUndefined()\n        expect(checkCache.get(`${teamId}:${person.id}`)).toBeUndefined()\n    })\n\n    it('should flush person updates with default NO_ASSERT mode', async () => {\n        const personStoreForBatch = personStore.forBatch()\n\n        // Add a person update to cache\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            { new_value: 'new_value' },\n            [],\n            {},\n            'test'\n        )\n\n        // Flush should call updatePerson (NO_ASSERT default mode)\n        await personStoreForBatch.flush()\n\n        expect(mockRepo.updatePerson).toHaveBeenCalledTimes(1)\n        expect(mockRepo.updatePersonAssertVersion).not.toHaveBeenCalled()\n    })\n\n    it('should fallback to direct update when optimistic update fails', async () => {\n        // Use ASSERT_VERSION mode for this test since it tests optimistic behavior\n        const assertVersionStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer, {\n            dbWriteMode: 'ASSERT_VERSION',\n        })\n        const personStoreForBatch = assertVersionStore.forBatch()\n\n        // Mock optimistic update to fail (version mismatch)\n        mockRepo.updatePersonAssertVersion = jest.fn().mockResolvedValue([undefined, []])\n\n        // Add a person update to cache\n        await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n            person,\n            { new_value: 'new_value' },\n            [],\n            {},\n            'test'\n        )\n\n        // Flush should retry optimistically then fallback to direct update\n        await personStoreForBatch.flush()\n\n        expect(mockRepo.updatePersonAssertVersion).toHaveBeenCalled()\n        expect(mockRepo.fetchPerson).toHaveBeenCalled() // Called during conflict resolution\n        expect(mockRepo.updatePerson).toHaveBeenCalled() // Fallback\n    })\n\n    it('should merge multiple updates for same person', async () => {\n        const personStoreForBatch = getBatchStoreForBatch()\n\n        // First update\n        await personStoreForBatch.updatePersonWithPropertiesDiffFor",
            "cost": 0.24549000000000004
        },
        "PostHog__posthog.main/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts": {
            "output": "import { DateTime } from 'luxon'\nimport pLimit from 'p-limit'\n\nimport { Properties } from '@posthog/plugin-scaffold'\n\nimport { NoRowsUpdatedError } from '~/utils/utils'\n\nimport { KafkaProducerWrapper, TopicMessage } from '../../../kafka/producer'\nimport {\n    InternalPerson,\n    PersonBatchWritingDbWriteMode,\n    PropertiesLastOperation,\n    PropertiesLastUpdatedAt,\n    Team,\n} from '../../../types'\nimport { CreatePersonResult, MoveDistinctIdsResult } from '../../../utils/db/db'\nimport { MessageSizeTooLarge } from '../../../utils/db/error'\nimport { logger } from '../../../utils/logger'\nimport { BatchWritingStore } from '../stores/batch-writing-store'\nimport { captureIngestionWarning } from '../utils'\nimport {\n    observeLatencyByVersion,\n    personCacheOperationsCounter,\n    personDatabaseOperationsPerBatchHistogram,\n    personFallbackOperationsCounter,\n    personFetchForCheckingCacheOperationsCounter,\n    personFetchForUpdateCacheOperationsCounter,\n    personFlushBatchSizeHistogram,\n    personFlushLatencyHistogram,\n    personFlushOperationsCounter,\n    personMethodCallsPerBatchHistogram,\n    personOptimisticUpdateConflictsPerBatchCounter,\n    personProfileBatchIgnoredPropertiesCounter,\n    personProfileBatchUpdateOutcomeCounter,\n    personPropertyKeyUpdateCounter,\n    personWriteMethodAttemptCounter,\n    totalPersonUpdateLatencyPerBatchHistogram,\n} from './metrics'\nimport { getMetricKey, isFilteredPersonPropertyKey } from './person-update'\nimport { PersonUpdate, fromInternalPerson, toInternalPerson } from './person-update-batch'\nimport { PersonsStore } from './persons-store'\nimport { FlushResult, PersonsStoreForBatch } from './persons-store-for-batch'\nimport { PersonsStoreTransaction } from './persons-store-transaction'\nimport { PersonPropertiesSizeViolationError, PersonRepository } from './repositories/person-repository'\nimport { PersonRepositoryTransaction } from './repositories/person-repository-transaction'\n\ntype MethodName =\n    | 'fetchForChecking'\n    | 'fetchForUpdate'\n    | 'fetchPerson'\n    | 'updatePersonAssertVersion'\n    | 'updatePersonNoAssert'\n    | 'createPerson'\n    | 'updatePersonWithPropertiesDiffForUpdate'\n    | 'updatePersonForMerge'\n    | 'deletePerson'\n    | 'addDistinctId'\n    | 'moveDistinctIds'\n    | 'fetchPersonDistinctIds'\n    | 'updateCohortsAndFeatureFlagsForMerge'\n    | 'addPersonlessDistinctId'\n    | 'addPersonlessDistinctIdForMerge'\n    | 'addPersonUpdateToBatch'\n\ntype UpdateType = 'updatePersonAssertVersion' | 'updatePersonNoAssert'\n\ninterface PersonUpdateResult {\n    success: boolean\n    messages: TopicMessage[]\n    // If there's a updated person update, it will be returned here.\n    // This is useful for the optimistic update case, where we need to update the cache with the latest version.\n    personUpdate?: PersonUpdate\n}\n\nclass MaxRetriesError extends Error {\n    constructor(\n        message: string,\n        public latestPersonUpdate: PersonUpdate\n    ) {\n        super(message)\n        this.name = 'MaxRetriesError'\n    }\n}\n\nexport interface BatchWritingPersonsStoreOptions {\n    maxConcurrentUpdates: number\n    dbWriteMode: PersonBatchWritingDbWriteMode\n    maxOptimisticUpdateRetries: number\n    optimisticUpdateRetryInterval: number\n}\n\nconst DEFAULT_OPTIONS: BatchWritingPersonsStoreOptions = {\n    dbWriteMode: 'NO_ASSERT',\n    maxConcurrentUpdates: 10,\n    maxOptimisticUpdateRetries: 5,\n    optimisticUpdateRetryInterval: 50,\n}\n\ninterface CacheMetrics {\n    updateCacheHits: number\n    updateCacheMisses: number\n    checkCacheHits: number\n    checkCacheMisses: number\n}\n\nexport class BatchWritingPersonsStore implements PersonsStore {\n    private options: BatchWritingPersonsStoreOptions\n\n    constructor(\n        private personRepository: PersonRepository,\n        private kafkaProducer: KafkaProducerWrapper,\n        options?: Partial<BatchWritingPersonsStoreOptions>\n    ) {\n        this.options = { ...DEFAULT_OPTIONS, ...options }\n    }\n\n    forBatch(): PersonsStoreForBatch {\n        return new BatchWritingPersonsStoreForBatch(this.personRepository, this.kafkaProducer, this.options)\n    }\n}\n\n/**\n * This class is used to write persons to the database in batches.\n * It will use a cache to avoid reading the same person from the database multiple times.\n * And will accumulate all changes for the same person in a single batch. At the\n * end of the batch processing, it flushes all changes to the database.\n */\nexport class BatchWritingPersonsStoreForBatch implements PersonsStoreForBatch, BatchWritingStore {\n    private personCheckCache: Map<string, InternalPerson | null>\n    private distinctIdToPersonId: Map<string, string>\n    private personUpdateCache: Map<string, PersonUpdate | null>\n    private fetchPromisesForUpdate: Map<string, Promise<InternalPerson | null>>\n    private fetchPromisesForChecking: Map<string, Promise<InternalPerson | null>>\n    private methodCountsPerDistinctId: Map<string, Map<MethodName, number>>\n    private databaseOperationCountsPerDistinctId: Map<string, Map<MethodName, number>>\n    private updateLatencyPerDistinctIdSeconds: Map<string, Map<UpdateType, number>>\n    private cacheMetrics: CacheMetrics\n    private options: BatchWritingPersonsStoreOptions\n\n    constructor(\n        private personRepository: PersonRepository,\n        private kafkaProducer: KafkaProducerWrapper,\n        options?: Partial<BatchWritingPersonsStoreOptions>\n    ) {\n        this.options = { ...DEFAULT_OPTIONS, ...options }\n        this.distinctIdToPersonId = new Map()\n        this.personUpdateCache = new Map()\n        this.personCheckCache = new Map()\n        this.fetchPromisesForUpdate = new Map()\n        this.fetchPromisesForChecking = new Map()\n        this.methodCountsPerDistinctId = new Map()\n        this.databaseOperationCountsPerDistinctId = new Map()\n        this.updateLatencyPerDistinctIdSeconds = new Map()\n        this.cacheMetrics = {\n            updateCacheHits: 0,\n            updateCacheMisses: 0,\n            checkCacheHits: 0,\n            checkCacheMisses: 0,\n        }\n    }\n\n    /**\n     * Check if a person update should trigger a database write.\n     * Returns the outcome: 'changed' (should write), 'ignored' (filtered properties only), or 'no_change' (no properties changed)\n     *\n     * Also tracks metrics for ignored properties at the batch level.\n     */\n    private getPersonUpdateOutcome(update: PersonUpdate): 'changed' | 'ignored' | 'no_change' {\n        const hasNonPropertyChanges =\n            update.is_identified !== update.original_is_identified ||\n            !update.created_at.equals(update.original_created_at)\n\n        if (hasNonPropertyChanges) {\n            return 'changed'\n        }\n\n        const hasPropertyChanges =\n            Object.keys(update.properties_to_set).length > 0 || update.properties_to_unset.length > 0\n\n        if (!hasPropertyChanges) {\n            return 'no_change'\n        }\n\n        // If force_update is set (from $identify, $set events), bypass filtering and always write\n        if (update.force_update) {\n            return 'changed'\n        }\n\n        // If there are properties to unset, always write\n        if (update.properties_to_unset.length > 0) {\n            return 'changed'\n        }\n\n        // Check if there are any properties_to_set that should trigger an update\n        const ignoredProperties: string[] = []\n        const hasPropertyTriggeringUpdate = Object.keys(update.properties_to_set).some((key) => {\n            // Check if this is a new property (not in current properties)\n            const isNewProperty = !(key in update.properties)\n            const valueChanged = update.properties[key] !== update.properties_to_set[key]\n\n            if (!valueChanged) {\n                return false\n            }\n\n            if (isNewProperty) {\n                return true\n            }\n\n            const isFiltered = isFilteredPersonPropertyKey(key)\n            if (isFiltered) {\n                ignoredProperties.push(key)\n                return false\n            }\n            return true\n        })\n\n        if (!hasPropertyTriggeringUpdate) {\n            // Only track as ignored if ALL properties are filtered\n            ignoredProperties.forEach((property) => {\n                personProfileBatchIgnoredPropertiesCounter.labels({ property }).inc()\n            })\n            return 'ignored'\n        }\n\n        return 'changed'\n    }\n\n    async flush(): Promise<FlushResult[]> {\n        const flushStartTime = performance.now()\n\n        // Track outcomes for all person updates that were actually modified and filter to only those that should write\n        const updateEntries = Array.from(this.personUpdateCache.entries()).filter(\n            (entry): entry is [string, PersonUpdate] => {\n                const [_, update] = entry\n\n                // Skip null entries - these are deleted persons or cleared cache entries\n                if (!update) {\n                    return false\n                }\n\n                // Skip entries not marked for write - these are read-only cache entries from fetchForUpdate\n                // that were cached but never modified (no events tried to update their properties)\n                if (!update.needs_write) {\n                    return false\n                }\n\n                // Determine outcome and track metrics for this person update\n                const outcome = this.getPersonUpdateOutcome(update)\n                personProfileBatchUpdateOutcomeCounter.labels({ outcome }).inc()\n\n                // Track which property keys caused person updates (only for 'changed' outcomes)\n                if (outcome === 'changed') {\n                    const metricsKeys = new Set<string>()\n                    Object.keys(update.properties_to_set).forEach((key) => {\n                        metricsKeys.add(getMetricKey(key))\n                    })\n                    update.properties_to_unset.forEach((key) => {\n                        metricsKeys.add(getMetricKey(key))\n                    })\n                    metricsKeys.forEach((key) => personPropertyKeyUpdateCounter.labels({ key: key }).inc())\n                }\n\n                // Only write to database if outcome is 'changed'\n                return outcome === 'changed'\n            }\n        )\n\n        const batchSize = updateEntries.length\n        personFlushBatchSizeHistogram.observe({ db_write_mode: this.options.dbWriteMode }, batchSize)\n\n        if (batchSize === 0) {\n            personFlushLatencyHistogram.observe({ db_write_mode: this.options.dbWriteMode }, 0)\n            personFlushOperationsCounter.inc({ db_write_mode: this.options.dbWriteMode, outcome: 'success' })\n            return []\n        }\n\n        const limit = pLimit(this.options.maxConcurrentUpdates)\n\n        try {\n            const results = await Promise.all(\n                updateEntries.map(([cacheKey, update]) =>\n                    limit(async (): Promise<FlushResult[]> => {\n                        try {\n                            personWriteMethodAttemptCounter.inc({\n                                db_write_mode: this.options.dbWriteMode,\n                                method: this.options.dbWriteMode,\n                                outcome: 'attempt',\n                            })\n\n                            let kafkaMessages: FlushResult[] = []\n                            switch (this.options.dbWriteMode) {\n                                case 'NO_ASSERT': {\n                                    const result = await this.withMergeRetry(\n                                        update,\n                                        this.updatePersonNoAssert.bind(this),\n                                        'updatePersonNoAssert',\n                                        this.options.maxOptimisticUpdateRetries,\n                                        this.options.optimisticUpdateRetryInterval\n                                    )\n                                    kafkaMessages = result.messages.map((message) => ({\n                                        topicMessage: message,\n                                        teamId: update.team_id,\n                                        uuid: update.uuid,\n                                        distinctId: update.distinct_id,\n                                    }))\n                                    break\n                                }\n                                case 'ASSERT_VERSION': {\n                                    const result = await this.withMergeRetry(\n                                        update,\n                                        this.updatePersonAssertVersion.bind(this),\n                                        'updatePersonAssertVersion',\n                                        this.options.maxOptimisticUpdateRetries,\n                                        this.options.optimisticUpdateRetryInterval\n                                    )\n                                    kafkaMessages = result.messages.map((message) => ({\n                                        topicMessage: message,\n                                        teamId: update.team_id,\n                                        uuid: update.uuid,\n                                        distinctId: update.distinct_id,\n                                    }))\n                                    break\n                                }\n                            }\n\n                            personWriteMethodAttemptCounter.inc({\n                                db_write_mode: this.options.dbWriteMode,\n                                method: this.options.dbWriteMode,\n                                outcome: 'success',\n                            })\n\n                            return kafkaMessages\n                        } catch (error) {\n                            // If the Kafka message is too large, we can't retry, so we need to capture a warning and stop retrying\n                            if (error instanceof MessageSizeTooLarge) {\n                                await captureIngestionWarning(\n                                    this.kafkaProducer,\n                                    update.team_id,\n                                    'person_upsert_message_size_too_large',\n                                    {\n                                        personId: update.id,\n                                        distinctId: update.distinct_id,\n                                    }\n                                )\n                                personWriteMethodAttemptCounter.inc({\n                                    db_write_mode: this.options.dbWriteMode,\n                                    method: this.options.dbWriteMode,\n                                    outcome: 'error',\n                                })\n                                return []\n                            }\n\n                            if (error instanceof PersonPropertiesSizeViolationError) {\n                                await captureIngestionWarning(\n                                    this.kafkaProducer,\n                                    update.team_id,\n                                    'person_properties_size_violation',\n                                    {\n                                        personId: update.id,\n                                        distinctId: update.distinct_id,\n                                        teamId: update.team_id,\n                                        message: 'Person properties exceeds size limit and was rejected',\n                                    }\n                                )\n                                personWriteMethodAttemptCounter.inc({\n                                    db_write_mode: this.options.dbWriteMode,\n                                    method: this.options.dbWriteMode,\n                                    outcome: 'properties_size_violation',\n                                })\n                                return []\n                            }\n\n                            // Handle max retries error with the latest person update\n                            if (error instanceof MaxRetriesError) {\n                                logger.warn('\u26a0\ufe0f', 'Falling back to direct update after max retries', {\n                                    teamId: error.latestPersonUpdate.team_id,\n                                    personId: error.latestPersonUpdate.id,\n                                    distinctId: error.latestPersonUpdate.distinct_id,\n                                })\n\n                                personFallbackOperationsCounter.inc({\n                                    db_write_mode: this.options.dbWriteMode,\n                                    fallback_reason: 'max_retries',\n                                })\n\n                                const fallbackResult = await this.updatePersonNoAssert(error",
            "output_extracted": "import { DateTime } from 'luxon'\nimport pLimit from 'p-limit'\n\nimport { Properties } from '@posthog/plugin-scaffold'\n\nimport { NoRowsUpdatedError } from '~/utils/utils'\n\nimport { KafkaProducerWrapper, TopicMessage } from '../../../kafka/producer'\nimport {\n    InternalPerson,\n    PersonBatchWritingDbWriteMode,\n    PropertiesLastOperation,\n    PropertiesLastUpdatedAt,\n    Team,\n} from '../../../types'\nimport { CreatePersonResult, MoveDistinctIdsResult } from '../../../utils/db/db'\nimport { MessageSizeTooLarge } from '../../../utils/db/error'\nimport { logger } from '../../../utils/logger'\nimport { BatchWritingStore } from '../stores/batch-writing-store'\nimport { captureIngestionWarning } from '../utils'\nimport {\n    observeLatencyByVersion,\n    personCacheOperationsCounter,\n    personDatabaseOperationsPerBatchHistogram,\n    personFallbackOperationsCounter,\n    personFetchForCheckingCacheOperationsCounter,\n    personFetchForUpdateCacheOperationsCounter,\n    personFlushBatchSizeHistogram,\n    personFlushLatencyHistogram,\n    personFlushOperationsCounter,\n    personMethodCallsPerBatchHistogram,\n    personOptimisticUpdateConflictsPerBatchCounter,\n    personProfileBatchIgnoredPropertiesCounter,\n    personProfileBatchUpdateOutcomeCounter,\n    personPropertyKeyUpdateCounter,\n    personWriteMethodAttemptCounter,\n    totalPersonUpdateLatencyPerBatchHistogram,\n} from './metrics'\nimport { getMetricKey, isFilteredPersonPropertyKey } from './person-update'\nimport { PersonUpdate, fromInternalPerson, toInternalPerson } from './person-update-batch'\nimport { PersonsStore } from './persons-store'\nimport { FlushResult, PersonsStoreForBatch } from './persons-store-for-batch'\nimport { PersonsStoreTransaction } from './persons-store-transaction'\nimport { PersonPropertiesSizeViolationError, PersonRepository } from './repositories/person-repository'\nimport { PersonRepositoryTransaction } from './repositories/person-repository-transaction'\n\ntype MethodName =\n    | 'fetchForChecking'\n    | 'fetchForUpdate'\n    | 'fetchPerson'\n    | 'updatePersonAssertVersion'\n    | 'updatePersonNoAssert'\n    | 'createPerson'\n    | 'updatePersonWithPropertiesDiffForUpdate'\n    | 'updatePersonForMerge'\n    | 'deletePerson'\n    | 'addDistinctId'\n    | 'moveDistinctIds'\n    | 'fetchPersonDistinctIds'\n    | 'updateCohortsAndFeatureFlagsForMerge'\n    | 'addPersonlessDistinctId'\n    | 'addPersonlessDistinctIdForMerge'\n    | 'addPersonUpdateToBatch'\n\ntype UpdateType = 'updatePersonAssertVersion' | 'updatePersonNoAssert'\n\ninterface PersonUpdateResult {\n    success: boolean\n    messages: TopicMessage[]\n    // If there's a updated person update, it will be returned here.\n    // This is useful for the optimistic update case, where we need to update the cache with the latest version.\n    personUpdate?: PersonUpdate\n}\n\nclass MaxRetriesError extends Error {\n    constructor(\n        message: string,\n        public latestPersonUpdate: PersonUpdate\n    ) {\n        super(message)\n        this.name = 'MaxRetriesError'\n    }\n}\n\nexport interface BatchWritingPersonsStoreOptions {\n    maxConcurrentUpdates: number\n    dbWriteMode: PersonBatchWritingDbWriteMode\n    maxOptimisticUpdateRetries: number\n    optimisticUpdateRetryInterval: number\n}\n\nconst DEFAULT_OPTIONS: BatchWritingPersonsStoreOptions = {\n    dbWriteMode: 'NO_ASSERT',\n    maxConcurrentUpdates: 10,\n    maxOptimisticUpdateRetries: 5,\n    optimisticUpdateRetryInterval: 50,\n}\n\ninterface CacheMetrics {\n    updateCacheHits: number\n    updateCacheMisses: number\n    checkCacheHits: number\n    checkCacheMisses: number\n}\n\nexport class BatchWritingPersonsStore implements PersonsStore {\n    private options: BatchWritingPersonsStoreOptions\n\n    constructor(\n        private personRepository: PersonRepository,\n        private kafkaProducer: KafkaProducerWrapper,\n        options?: Partial<BatchWritingPersonsStoreOptions>\n    ) {\n        this.options = { ...DEFAULT_OPTIONS, ...options }\n    }\n\n    forBatch(): PersonsStoreForBatch {\n        return new BatchWritingPersonsStoreForBatch(this.personRepository, this.kafkaProducer, this.options)\n    }\n}\n\n/**\n * This class is used to write persons to the database in batches.\n * It will use a cache to avoid reading the same person from the database multiple times.\n * And will accumulate all changes for the same person in a single batch. At the\n * end of the batch processing, it flushes all changes to the database.\n */\nexport class BatchWritingPersonsStoreForBatch implements PersonsStoreForBatch, BatchWritingStore {\n    private personCheckCache: Map<string, InternalPerson | null>\n    private distinctIdToPersonId: Map<string, string>\n    private personUpdateCache: Map<string, PersonUpdate | null>\n    private fetchPromisesForUpdate: Map<string, Promise<InternalPerson | null>>\n    private fetchPromisesForChecking: Map<string, Promise<InternalPerson | null>>\n    private methodCountsPerDistinctId: Map<string, Map<MethodName, number>>\n    private databaseOperationCountsPerDistinctId: Map<string, Map<MethodName, number>>\n    private updateLatencyPerDistinctIdSeconds: Map<string, Map<UpdateType, number>>\n    private cacheMetrics: CacheMetrics\n    private options: BatchWritingPersonsStoreOptions\n\n    constructor(\n        private personRepository: PersonRepository,\n        private kafkaProducer: KafkaProducerWrapper,\n        options?: Partial<BatchWritingPersonsStoreOptions>\n    ) {\n        this.options = { ...DEFAULT_OPTIONS, ...options }\n        this.distinctIdToPersonId = new Map()\n        this.personUpdateCache = new Map()\n        this.personCheckCache = new Map()\n        this.fetchPromisesForUpdate = new Map()\n        this.fetchPromisesForChecking = new Map()\n        this.methodCountsPerDistinctId = new Map()\n        this.databaseOperationCountsPerDistinctId = new Map()\n        this.updateLatencyPerDistinctIdSeconds = new Map()\n        this.cacheMetrics = {\n            updateCacheHits: 0,\n            updateCacheMisses: 0,\n            checkCacheHits: 0,\n            checkCacheMisses: 0,\n        }\n    }\n\n    /**\n     * Check if a person update should trigger a database write.\n     * Returns the outcome: 'changed' (should write), 'ignored' (filtered properties only), or 'no_change' (no properties changed)\n     *\n     * Also tracks metrics for ignored properties at the batch level.\n     */\n    private getPersonUpdateOutcome(update: PersonUpdate): 'changed' | 'ignored' | 'no_change' {\n        const hasNonPropertyChanges =\n            update.is_identified !== update.original_is_identified ||\n            !update.created_at.equals(update.original_created_at)\n\n        if (hasNonPropertyChanges) {\n            return 'changed'\n        }\n\n        const hasPropertyChanges =\n            Object.keys(update.properties_to_set).length > 0 || update.properties_to_unset.length > 0\n\n        if (!hasPropertyChanges) {\n            return 'no_change'\n        }\n\n        // If force_update is set (from $identify, $set events), bypass filtering and always write\n        if (update.force_update) {\n            return 'changed'\n        }\n\n        // If there are properties to unset, always write\n        if (update.properties_to_unset.length > 0) {\n            return 'changed'\n        }\n\n        // Check if there are any properties_to_set that should trigger an update\n        const ignoredProperties: string[] = []\n        const hasPropertyTriggeringUpdate = Object.keys(update.properties_to_set).some((key) => {\n            // Check if this is a new property (not in current properties)\n            const isNewProperty = !(key in update.properties)\n            const valueChanged = update.properties[key] !== update.properties_to_set[key]\n\n            if (!valueChanged) {\n                return false\n            }\n\n            if (isNewProperty) {\n                return true\n            }\n\n            const isFiltered = isFilteredPersonPropertyKey(key)\n            if (isFiltered) {\n                ignoredProperties.push(key)\n                return false\n            }\n            return true\n        })\n\n        if (!hasPropertyTriggeringUpdate) {\n            // Only track as ignored if ALL properties are filtered\n            ignoredProperties.forEach((property) => {\n                personProfileBatchIgnoredPropertiesCounter.labels({ property }).inc()\n            })\n            return 'ignored'\n        }\n\n        return 'changed'\n    }\n\n    async flush(): Promise<FlushResult[]> {\n        const flushStartTime = performance.now()\n\n        // Track outcomes for all person updates that were actually modified and filter to only those that should write\n        const updateEntries = Array.from(this.personUpdateCache.entries()).filter(\n            (entry): entry is [string, PersonUpdate] => {\n                const [_, update] = entry\n\n                // Skip null entries - these are deleted persons or cleared cache entries\n                if (!update) {\n                    return false\n                }\n\n                // Skip entries not marked for write - these are read-only cache entries from fetchForUpdate\n                // that were cached but never modified (no events tried to update their properties)\n                if (!update.needs_write) {\n                    return false\n                }\n\n                // Determine outcome and track metrics for this person update\n                const outcome = this.getPersonUpdateOutcome(update)\n                personProfileBatchUpdateOutcomeCounter.labels({ outcome }).inc()\n\n                // Track which property keys caused person updates (only for 'changed' outcomes)\n                if (outcome === 'changed') {\n                    const metricsKeys = new Set<string>()\n                    Object.keys(update.properties_to_set).forEach((key) => {\n                        metricsKeys.add(getMetricKey(key))\n                    })\n                    update.properties_to_unset.forEach((key) => {\n                        metricsKeys.add(getMetricKey(key))\n                    })\n                    metricsKeys.forEach((key) => personPropertyKeyUpdateCounter.labels({ key: key }).inc())\n                }\n\n                // Only write to database if outcome is 'changed'\n                return outcome === 'changed'\n            }\n        )\n\n        const batchSize = updateEntries.length\n        personFlushBatchSizeHistogram.observe({ db_write_mode: this.options.dbWriteMode }, batchSize)\n\n        if (batchSize === 0) {\n            personFlushLatencyHistogram.observe({ db_write_mode: this.options.dbWriteMode }, 0)\n            personFlushOperationsCounter.inc({ db_write_mode: this.options.dbWriteMode, outcome: 'success' })\n            return []\n        }\n\n        const limit = pLimit(this.options.maxConcurrentUpdates)\n\n        try {\n            const results = await Promise.all(\n                updateEntries.map(([cacheKey, update]) =>\n                    limit(async (): Promise<FlushResult[]> => {\n                        try {\n                            personWriteMethodAttemptCounter.inc({\n                                db_write_mode: this.options.dbWriteMode,\n                                method: this.options.dbWriteMode,\n                                outcome: 'attempt',\n                            })\n\n                            let kafkaMessages: FlushResult[] = []\n                            switch (this.options.dbWriteMode) {\n                                case 'NO_ASSERT': {\n                                    const result = await this.withMergeRetry(\n                                        update,\n                                        this.updatePersonNoAssert.bind(this),\n                                        'updatePersonNoAssert',\n                                        this.options.maxOptimisticUpdateRetries,\n                                        this.options.optimisticUpdateRetryInterval\n                                    )\n                                    kafkaMessages = result.messages.map((message) => ({\n                                        topicMessage: message,\n                                        teamId: update.team_id,\n                                        uuid: update.uuid,\n                                        distinctId: update.distinct_id,\n                                    }))\n                                    break\n                                }\n                                case 'ASSERT_VERSION': {\n                                    const result = await this.withMergeRetry(\n                                        update,\n                                        this.updatePersonAssertVersion.bind(this),\n                                        'updatePersonAssertVersion',\n                                        this.options.maxOptimisticUpdateRetries,\n                                        this.options.optimisticUpdateRetryInterval\n                                    )\n                                    kafkaMessages = result.messages.map((message) => ({\n                                        topicMessage: message,\n                                        teamId: update.team_id,\n                                        uuid: update.uuid,\n                                        distinctId: update.distinct_id,\n                                    }))\n                                    break\n                                }\n                            }\n\n                            personWriteMethodAttemptCounter.inc({\n                                db_write_mode: this.options.dbWriteMode,\n                                method: this.options.dbWriteMode,\n                                outcome: 'success',\n                            })\n\n                            return kafkaMessages\n                        } catch (error) {\n                            // If the Kafka message is too large, we can't retry, so we need to capture a warning and stop retrying\n                            if (error instanceof MessageSizeTooLarge) {\n                                await captureIngestionWarning(\n                                    this.kafkaProducer,\n                                    update.team_id,\n                                    'person_upsert_message_size_too_large',\n                                    {\n                                        personId: update.id,\n                                        distinctId: update.distinct_id,\n                                    }\n                                )\n                                personWriteMethodAttemptCounter.inc({\n                                    db_write_mode: this.options.dbWriteMode,\n                                    method: this.options.dbWriteMode,\n                                    outcome: 'error',\n                                })\n                                return []\n                            }\n\n                            if (error instanceof PersonPropertiesSizeViolationError) {\n                                await captureIngestionWarning(\n                                    this.kafkaProducer,\n                                    update.team_id,\n                                    'person_properties_size_violation',\n                                    {\n                                        personId: update.id,\n                                        distinctId: update.distinct_id,\n                                        teamId: update.team_id,\n                                        message: 'Person properties exceeds size limit and was rejected',\n                                    }\n                                )\n                                personWriteMethodAttemptCounter.inc({\n                                    db_write_mode: this.options.dbWriteMode,\n                                    method: this.options.dbWriteMode,\n                                    outcome: 'properties_size_violation',\n                                })\n                                return []\n                            }\n\n                            // Handle max retries error with the latest person update\n                            if (error instanceof MaxRetriesError) {\n                                logger.warn('\u26a0\ufe0f', 'Falling back to direct update after max retries', {\n                                    teamId: error.latestPersonUpdate.team_id,\n                                    personId: error.latestPersonUpdate.id,\n                                    distinctId: error.latestPersonUpdate.distinct_id,\n                                })\n\n                                personFallbackOperationsCounter.inc({\n                                    db_write_mode: this.options.dbWriteMode,\n                                    fallback_reason: 'max_retries',\n                                })\n\n                                const fallbackResult = await this.updatePersonNoAssert(error",
            "cost": 0.181455
        },
        "PostHog__posthog.main/plugin-server/src/worker/ingestion/persons/person-property-utils.ts": {
            "output": "// Core person properties that should be preserved during trimming\nconst CORE_PERSON_PROPERTIES = new Set(['email', 'name'])\n\n// Properties automatically mapped from events to persons\nconst EVENT_TO_PERSON_PROPERTIES = new Set([\n    // mobile params\n    '$app_build',\n    '$app_name',\n    '$app_namespace',\n    '$app_version',\n    // web params\n    '$browser',\n    '$browser_version',\n    '$device_type',\n    '$current_url',\n    '$pathname',\n    '$os',\n    '$os_name', // $os_name is a special case, it's treated as an alias of $os!\n    '$os_version',\n    '$referring_domain',\n    '$referrer',\n    '$screen_height',\n    '$screen_width',\n    '$viewport_height',\n    '$viewport_width',\n    '$raw_user_agent',\n])\n\n// UTM and campaign tracking properties\n// Keep in sync with:\n// - taxonomy.tsx (CAMPAIGN_PROPERTIES)\n// - posthog-js event-utils.ts (CAMPAIGN_PARAMS)\nconst CAMPAIGN_PROPERTIES = new Set([\n    'utm_source',\n    'utm_medium',\n    'utm_campaign',\n    'utm_content',\n    'utm_name',\n    'utm_term',\n    'gclid', // google ads\n    'gad_source', // google ads\n    'gclsrc', // google ads 360\n    'dclid', // google display ads\n    'gbraid', // google ads, web to app\n    'wbraid', // google ads, app to web\n    'fbclid', // facebook\n    'msclkid', // microsoft\n    'twclid', // twitter\n    'li_fat_id', // linkedin\n    'mc_cid', // mailchimp campaign id\n    'igshid', // instagram\n    'ttclid', // tiktok\n    'rdt_cid', // reddit\n    'irclid', // impact\n    '_kx', // klaviyo\n    // Additional campaign params specific to person properties\n    'epik',\n    'qclid',\n    'sccid',\n])\n\n// Session and page tracking properties\nconst SESSION_PROPERTIES = new Set(['$session_id', '$window_id', '$pageview_id', '$host'])\n\n// Identity and device tracking properties\nconst IDENTITY_PROPERTIES = new Set(['$user_id', '$device_id', '$anon_distinct_id'])\n\n// Initial/first-touch properties\nconst INITIAL_PROPERTIES = new Set([\n    '$initial_referrer',\n    '$initial_referring_domain',\n    '$initial_utm_source',\n    '$initial_utm_medium',\n    '$initial_utm_campaign',\n    '$initial_utm_content',\n    '$initial_utm_term',\n])\n\n// Combined set of all properties that should be protected from trimming\nconst ALL_PROTECTED_PROPERTIES = new Set([\n    ...CORE_PERSON_PROPERTIES,\n    ...EVENT_TO_PERSON_PROPERTIES,\n    ...CAMPAIGN_PROPERTIES,\n    ...SESSION_PROPERTIES,\n    ...IDENTITY_PROPERTIES,\n    ...INITIAL_PROPERTIES,\n])\n\n/**\n * Determines if a property can be trimmed during person property size remediation.\n * Protected properties (core, campaign, event-mapped, etc.) should not be trimmed.\n */\nexport function canTrimProperty(propertyName: string): boolean {\n    return !ALL_PROTECTED_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is a core person property (email, name).\n */\nexport function isCorePersonProperty(propertyName: string): boolean {\n    return CORE_PERSON_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is automatically mapped from events to persons.\n */\nexport function isEventToPersonProperty(propertyName: string): boolean {\n    return EVENT_TO_PERSON_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is a campaign/UTM tracking property.\n */\nexport function isCampaignProperty(propertyName: string): boolean {\n    return CAMPAIGN_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is a session tracking property.\n */\nexport function isSessionProperty(propertyName: string): boolean {\n    return SESSION_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is an identity tracking property.\n */\nexport function isIdentityProperty(propertyName: string): boolean {\n    return IDENTITY_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is an initial/first-touch property.\n */\nexport function isInitialProperty(propertyName: string): boolean {\n    return INITIAL_PROPERTIES.has(propertyName)\n}\n\nexport const eventToPersonProperties = new Set([...EVENT_TO_PERSON_PROPERTIES])\nexport const initialCampaignParams = new Set(\n    Array.from(CAMPAIGN_PROPERTIES, (key) => `$initial_${key.replace('$', '')}`)\n)\nexport const initialEventToPersonProperties = new Set(\n    Array.from(eventToPersonProperties, (key) => `$initial_${key.replace('$', '')}`)\n)",
            "output_extracted": "// Core person properties that should be preserved during trimming\nconst CORE_PERSON_PROPERTIES = new Set(['email', 'name'])\n\n// Properties automatically mapped from events to persons\nconst EVENT_TO_PERSON_PROPERTIES = new Set([\n    // mobile params\n    '$app_build',\n    '$app_name',\n    '$app_namespace',\n    '$app_version',\n    // web params\n    '$browser',\n    '$browser_version',\n    '$device_type',\n    '$current_url',\n    '$pathname',\n    '$os',\n    '$os_name', // $os_name is a special case, it's treated as an alias of $os!\n    '$os_version',\n    '$referring_domain',\n    '$referrer',\n    '$screen_height',\n    '$screen_width',\n    '$viewport_height',\n    '$viewport_width',\n    '$raw_user_agent',\n])\n\n// UTM and campaign tracking properties\n// Keep in sync with:\n// - taxonomy.tsx (CAMPAIGN_PROPERTIES)\n// - posthog-js event-utils.ts (CAMPAIGN_PARAMS)\nconst CAMPAIGN_PROPERTIES = new Set([\n    'utm_source',\n    'utm_medium',\n    'utm_campaign',\n    'utm_content',\n    'utm_name',\n    'utm_term',\n    'gclid', // google ads\n    'gad_source', // google ads\n    'gclsrc', // google ads 360\n    'dclid', // google display ads\n    'gbraid', // google ads, web to app\n    'wbraid', // google ads, app to web\n    'fbclid', // facebook\n    'msclkid', // microsoft\n    'twclid', // twitter\n    'li_fat_id', // linkedin\n    'mc_cid', // mailchimp campaign id\n    'igshid', // instagram\n    'ttclid', // tiktok\n    'rdt_cid', // reddit\n    'irclid', // impact\n    '_kx', // klaviyo\n    // Additional campaign params specific to person properties\n    'epik',\n    'qclid',\n    'sccid',\n])\n\n// Session and page tracking properties\nconst SESSION_PROPERTIES = new Set(['$session_id', '$window_id', '$pageview_id', '$host'])\n\n// Identity and device tracking properties\nconst IDENTITY_PROPERTIES = new Set(['$user_id', '$device_id', '$anon_distinct_id'])\n\n// Initial/first-touch properties\nconst INITIAL_PROPERTIES = new Set([\n    '$initial_referrer',\n    '$initial_referring_domain',\n    '$initial_utm_source',\n    '$initial_utm_medium',\n    '$initial_utm_campaign',\n    '$initial_utm_content',\n    '$initial_utm_term',\n])\n\n// Combined set of all properties that should be protected from trimming\nconst ALL_PROTECTED_PROPERTIES = new Set([\n    ...CORE_PERSON_PROPERTIES,\n    ...EVENT_TO_PERSON_PROPERTIES,\n    ...CAMPAIGN_PROPERTIES,\n    ...SESSION_PROPERTIES,\n    ...IDENTITY_PROPERTIES,\n    ...INITIAL_PROPERTIES,\n])\n\n/**\n * Determines if a property can be trimmed during person property size remediation.\n * Protected properties (core, campaign, event-mapped, etc.) should not be trimmed.\n */\nexport function canTrimProperty(propertyName: string): boolean {\n    return !ALL_PROTECTED_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is a core person property (email, name).\n */\nexport function isCorePersonProperty(propertyName: string): boolean {\n    return CORE_PERSON_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is automatically mapped from events to persons.\n */\nexport function isEventToPersonProperty(propertyName: string): boolean {\n    return EVENT_TO_PERSON_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is a campaign/UTM tracking property.\n */\nexport function isCampaignProperty(propertyName: string): boolean {\n    return CAMPAIGN_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is a session tracking property.\n */\nexport function isSessionProperty(propertyName: string): boolean {\n    return SESSION_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is an identity tracking property.\n */\nexport function isIdentityProperty(propertyName: string): boolean {\n    return IDENTITY_PROPERTIES.has(propertyName)\n}\n\n/**\n * Determines if a property is an initial/first-touch property.\n */\nexport function isInitialProperty(propertyName: string): boolean {\n    return INITIAL_PROPERTIES.has(propertyName)\n}\n\nexport const eventToPersonProperties = new Set([...EVENT_TO_PERSON_PROPERTIES])\nexport const initialCampaignParams = new Set(\n    Array.from(CAMPAIGN_PROPERTIES, (key) => `$initial_${key.replace('$', '')}`)\n)\nexport const initialEventToPersonProperties = new Set(\n    Array.from(eventToPersonProperties, (key) => `$initial_${key.replace('$', '')}`)\n)",
            "cost": 0.05038
        },
        "PostHog__posthog.main/plugin-server/src/worker/ingestion/persons/person-update.test.ts": {
            "output": "import { PluginEvent } from '@posthog/plugin-scaffold'\n\nimport { personProfileIgnoredPropertiesCounter, personProfileUpdateOutcomeCounter } from './metrics'\nimport { eventToPersonProperties } from './person-property-utils'\nimport { applyEventPropertyUpdates, computeEventPropertyUpdates } from './person-update'\n\njest.mock('./metrics', () => ({\n    personProfileUpdateOutcomeCounter: {\n        labels: jest.fn().mockReturnValue({\n            inc: jest.fn(),\n        }),\n    },\n    personProfileIgnoredPropertiesCounter: {\n        labels: jest.fn().mockReturnValue({\n            inc: jest.fn(),\n        }),\n    },\n}))\n\nconst mockPersonProfileUpdateOutcomeCounter = personProfileUpdateOutcomeCounter as jest.Mocked<\n    typeof personProfileUpdateOutcomeCounter\n>\nconst mockPersonProfileIgnoredPropertiesCounter = personProfileIgnoredPropertiesCounter as jest.Mocked<\n    typeof personProfileIgnoredPropertiesCounter\n>\n\ndescribe('person-update', () => {\n    beforeEach(() => {\n        jest.clearAllMocks()\n    })\n    describe('computeEventPropertyUpdates', () => {\n        describe('property changes', () => {\n            it('should compute updates when custom properties are updated', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { custom_prop: 'new_value' },\n                    },\n                } as any\n\n                const personProperties = { custom_prop: 'old_value' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ custom_prop: 'new_value' })\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n                expect(mockPersonProfileUpdateOutcomeCounter.labels({ outcome: 'changed' }).inc).toHaveBeenCalled()\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n            })\n\n            it('should compute updates when properties are unset', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $unset: ['prop_to_remove'],\n                    },\n                } as any\n\n                const personProperties = { prop_to_remove: 'value', other_prop: 'keep' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toUnset).toEqual(['prop_to_remove'])\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n            })\n\n            it('should compute updates when setting a new property', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { new_prop: 'value' },\n                    },\n                } as any\n\n                const personProperties = {}\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ new_prop: 'value' })\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n            })\n\n            it('should compute updates when $set_once sets a property that does not exist', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set_once: { first_seen: '2024-01-01' },\n                    },\n                } as any\n\n                const personProperties = {}\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ first_seen: '2024-01-01' })\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n            })\n\n            it('should compute updates when a new eventToPersonProperty is set (not just updated)', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { $browser: 'Chrome' },\n                    },\n                } as any\n\n                const personProperties = {}\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ $browser: 'Chrome' })\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n            })\n        })\n\n        describe('eventToPersonProperties accepted at event level', () => {\n            it.each(Array.from(eventToPersonProperties))(\n                'should accept \"%s\" updates at event level (filtering happens at batch level)',\n                (propertyName) => {\n                    const event: PluginEvent = {\n                        event: 'pageview',\n                        properties: {\n                            $set: { [propertyName]: 'new_value' },\n                        },\n                    } as any\n\n                    const personProperties = { [propertyName]: 'old_value' }\n\n                    const result = computeEventPropertyUpdates(event, personProperties)\n\n                    expect(result.hasChanges).toBe(true)\n                    expect(result.toSet).toEqual({ [propertyName]: 'new_value' })\n                    expect(result.shouldForceUpdate).toBe(false)\n                    // At event level, this property would be marked as ignored (outcome: 'ignored')\n                    // but it's still included in toSet for batch-level filtering\n                    expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                    expect(mockPersonProfileUpdateOutcomeCounter.labels({ outcome: 'ignored' }).inc).toHaveBeenCalled()\n                    expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n                        property: propertyName,\n                    })\n                    expect(\n                        mockPersonProfileIgnoredPropertiesCounter.labels({ property: propertyName }).inc\n                    ).toHaveBeenCalled()\n                }\n            )\n\n            it('should accept blocked $geoip_* property updates at event level (filtering happens at batch level)', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { $geoip_latitude: 37.7749 },\n                    },\n                } as any\n\n                const personProperties = { $geoip_latitude: 40.7128 }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ $geoip_latitude: 37.7749 })\n                expect(result.shouldForceUpdate).toBe(false)\n                // At event level, blocked geoip properties would be marked as ignored\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n                    property: '$geoip_latitude',\n                })\n            })\n\n            it('should trigger update when $geoip_country_name changes (allowed geoip property)', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { $geoip_country_name: 'United States' },\n                    },\n                } as any\n\n                const personProperties = { $geoip_country_name: 'Canada' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ $geoip_country_name: 'United States' })\n                expect(result.shouldForceUpdate).toBe(false)\n                // $geoip_country_name is allowed so should be marked as changed\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n            })\n\n            it('should trigger update when $geoip_city_name changes (allowed geoip property)', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { $geoip_city_name: 'San Francisco' },\n                    },\n                } as any\n\n                const personProperties = { $geoip_city_name: 'New York' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ $geoip_city_name: 'San Francisco' })\n                expect(result.shouldForceUpdate).toBe(false)\n                // $geoip_city_name is allowed so should be marked as changed\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n            })\n\n            it('should update all geoip properties when allowed property ($geoip_country_name) changes alongside blocked ones', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: {\n                            $geoip_country_name: 'United States',\n                            $geoip_latitude: 37.7749,\n                            $geoip_longitude: -122.4194,\n                            $geoip_postal_code: '94102',\n                        },\n                    },\n                } as any\n\n                const personProperties = {\n                    $geoip_country_name: 'Canada',\n                    $geoip_latitude: 43.6532,\n                    $geoip_longitude: -79.3832,\n                    $geoip_postal_code: 'M5V',\n                }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({\n                    $geoip_country_name: 'United States',\n                    $geoip_latitude: 37.7749,\n                    $geoip_longitude: -122.4194,\n                    $geoip_postal_code: '94102',\n                })\n                expect(result.shouldForceUpdate).toBe(false)\n                // Since $geoip_country_name is allowed, the update is marked as changed (not ignored)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n            })\n\n            it('should accept eventToPersonProperties even when mixed with unchanged custom properties', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { $browser: 'Chrome', custom_prop: 'same_value' },\n                    },\n                } as any\n\n                const personProperties = { $browser: 'Firefox', custom_prop: 'same_value' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ $browser: 'Chrome' })\n                expect(result.shouldForceUpdate).toBe(false)\n                // At event level, $browser would be marked as ignored\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n                    property: '$browser',\n                })\n            })\n\n            it('should accept multiple eventToPersonProperties at event level', () => {\n                // Note: Campaign properties (utm_source, utm_campaign) are no longer in eventToPersonProperties\n                // and will trigger updates like custom properties\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: {\n                            $browser: 'Chrome',\n                            $os: 'macOS',\n                        },\n                    },\n                } as any\n\n                const personProperties = {\n                    $browser: 'Firefox',\n                    $os: 'Windows',\n                }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.shouldForceUpdate).toBe(false)\n                // At event level, eventToPersonProperties would be marked as ignored\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$browser' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$os' })\n            })\n        })\n\n        describe('no changes', () => {\n            it('should return no changes when no properties are provided', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {},\n                } as any\n\n                const personProperties = { existing_prop: 'value' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(false)\n                expect(result.toSet).toEqual({})\n                expect(result.toUnset).toEqual([])\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'no_change' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n            })\n\n            it('should return no changes when all properties have the same value', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { custom_prop: 'same_value' },\n                    },\n                } as any\n\n                const personProperties = { custom_prop: 'same_value' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(false)\n                expect(result.toSet).toEqual({})\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'no_change' })\n            })\n\n            it('should return no changes when $set_once property already exists', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set_once: { first_seen: '2024-01-01' },\n                    },\n                } as any\n\n                const personProperties = { first_seen: '2023-01-01' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(false)\n                expect(result.toSet).toEqual({})\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'no_change' })\n            })\n\n            it('should return no changes when trying",
            "output_extracted": "import { PluginEvent } from '@posthog/plugin-scaffold'\n\nimport { personProfileIgnoredPropertiesCounter, personProfileUpdateOutcomeCounter } from './metrics'\nimport { eventToPersonProperties } from './person-property-utils'\nimport { applyEventPropertyUpdates, computeEventPropertyUpdates } from './person-update'\n\njest.mock('./metrics', () => ({\n    personProfileUpdateOutcomeCounter: {\n        labels: jest.fn().mockReturnValue({\n            inc: jest.fn(),\n        }),\n    },\n    personProfileIgnoredPropertiesCounter: {\n        labels: jest.fn().mockReturnValue({\n            inc: jest.fn(),\n        }),\n    },\n}))\n\nconst mockPersonProfileUpdateOutcomeCounter = personProfileUpdateOutcomeCounter as jest.Mocked<\n    typeof personProfileUpdateOutcomeCounter\n>\nconst mockPersonProfileIgnoredPropertiesCounter = personProfileIgnoredPropertiesCounter as jest.Mocked<\n    typeof personProfileIgnoredPropertiesCounter\n>\n\ndescribe('person-update', () => {\n    beforeEach(() => {\n        jest.clearAllMocks()\n    })\n    describe('computeEventPropertyUpdates', () => {\n        describe('property changes', () => {\n            it('should compute updates when custom properties are updated', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { custom_prop: 'new_value' },\n                    },\n                } as any\n\n                const personProperties = { custom_prop: 'old_value' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ custom_prop: 'new_value' })\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n                expect(mockPersonProfileUpdateOutcomeCounter.labels({ outcome: 'changed' }).inc).toHaveBeenCalled()\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n            })\n\n            it('should compute updates when properties are unset', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $unset: ['prop_to_remove'],\n                    },\n                } as any\n\n                const personProperties = { prop_to_remove: 'value', other_prop: 'keep' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toUnset).toEqual(['prop_to_remove'])\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n            })\n\n            it('should compute updates when setting a new property', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { new_prop: 'value' },\n                    },\n                } as any\n\n                const personProperties = {}\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ new_prop: 'value' })\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n            })\n\n            it('should compute updates when $set_once sets a property that does not exist', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set_once: { first_seen: '2024-01-01' },\n                    },\n                } as any\n\n                const personProperties = {}\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ first_seen: '2024-01-01' })\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n            })\n\n            it('should compute updates when a new eventToPersonProperty is set (not just updated)', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { $browser: 'Chrome' },\n                    },\n                } as any\n\n                const personProperties = {}\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ $browser: 'Chrome' })\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n            })\n        })\n\n        describe('eventToPersonProperties accepted at event level', () => {\n            it.each(Array.from(eventToPersonProperties))(\n                'should accept \"%s\" updates at event level (filtering happens at batch level)',\n                (propertyName) => {\n                    const event: PluginEvent = {\n                        event: 'pageview',\n                        properties: {\n                            $set: { [propertyName]: 'new_value' },\n                        },\n                    } as any\n\n                    const personProperties = { [propertyName]: 'old_value' }\n\n                    const result = computeEventPropertyUpdates(event, personProperties)\n\n                    expect(result.hasChanges).toBe(true)\n                    expect(result.toSet).toEqual({ [propertyName]: 'new_value' })\n                    expect(result.shouldForceUpdate).toBe(false)\n                    // At event level, this property would be marked as ignored (outcome: 'ignored')\n                    // but it's still included in toSet for batch-level filtering\n                    expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                    expect(mockPersonProfileUpdateOutcomeCounter.labels({ outcome: 'ignored' }).inc).toHaveBeenCalled()\n                    expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n                        property: propertyName,\n                    })\n                    expect(\n                        mockPersonProfileIgnoredPropertiesCounter.labels({ property: propertyName }).inc\n                    ).toHaveBeenCalled()\n                }\n            )\n\n            it('should accept blocked $geoip_* property updates at event level (filtering happens at batch level)', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { $geoip_latitude: 37.7749 },\n                    },\n                } as any\n\n                const personProperties = { $geoip_latitude: 40.7128 }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ $geoip_latitude: 37.7749 })\n                expect(result.shouldForceUpdate).toBe(false)\n                // At event level, blocked geoip properties would be marked as ignored\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n                    property: '$geoip_latitude',\n                })\n            })\n\n            it('should trigger update when $geoip_country_name changes (allowed geoip property)', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { $geoip_country_name: 'United States' },\n                    },\n                } as any\n\n                const personProperties = { $geoip_country_name: 'Canada' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ $geoip_country_name: 'United States' })\n                expect(result.shouldForceUpdate).toBe(false)\n                // $geoip_country_name is allowed so should be marked as changed\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n            })\n\n            it('should trigger update when $geoip_city_name changes (allowed geoip property)', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { $geoip_city_name: 'San Francisco' },\n                    },\n                } as any\n\n                const personProperties = { $geoip_city_name: 'New York' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ $geoip_city_name: 'San Francisco' })\n                expect(result.shouldForceUpdate).toBe(false)\n                // $geoip_city_name is allowed so should be marked as changed\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n            })\n\n            it('should update all geoip properties when allowed property ($geoip_country_name) changes alongside blocked ones', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: {\n                            $geoip_country_name: 'United States',\n                            $geoip_latitude: 37.7749,\n                            $geoip_longitude: -122.4194,\n                            $geoip_postal_code: '94102',\n                        },\n                    },\n                } as any\n\n                const personProperties = {\n                    $geoip_country_name: 'Canada',\n                    $geoip_latitude: 43.6532,\n                    $geoip_longitude: -79.3832,\n                    $geoip_postal_code: 'M5V',\n                }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({\n                    $geoip_country_name: 'United States',\n                    $geoip_latitude: 37.7749,\n                    $geoip_longitude: -122.4194,\n                    $geoip_postal_code: '94102',\n                })\n                expect(result.shouldForceUpdate).toBe(false)\n                // Since $geoip_country_name is allowed, the update is marked as changed (not ignored)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n            })\n\n            it('should accept eventToPersonProperties even when mixed with unchanged custom properties', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { $browser: 'Chrome', custom_prop: 'same_value' },\n                    },\n                } as any\n\n                const personProperties = { $browser: 'Firefox', custom_prop: 'same_value' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.toSet).toEqual({ $browser: 'Chrome' })\n                expect(result.shouldForceUpdate).toBe(false)\n                // At event level, $browser would be marked as ignored\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n                    property: '$browser',\n                })\n            })\n\n            it('should accept multiple eventToPersonProperties at event level', () => {\n                // Note: Campaign properties (utm_source, utm_campaign) are no longer in eventToPersonProperties\n                // and will trigger updates like custom properties\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: {\n                            $browser: 'Chrome',\n                            $os: 'macOS',\n                        },\n                    },\n                } as any\n\n                const personProperties = {\n                    $browser: 'Firefox',\n                    $os: 'Windows',\n                }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(true)\n                expect(result.shouldForceUpdate).toBe(false)\n                // At event level, eventToPersonProperties would be marked as ignored\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$browser' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$os' })\n            })\n        })\n\n        describe('no changes', () => {\n            it('should return no changes when no properties are provided', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {},\n                } as any\n\n                const personProperties = { existing_prop: 'value' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(false)\n                expect(result.toSet).toEqual({})\n                expect(result.toUnset).toEqual([])\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'no_change' })\n                expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n            })\n\n            it('should return no changes when all properties have the same value', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set: { custom_prop: 'same_value' },\n                    },\n                } as any\n\n                const personProperties = { custom_prop: 'same_value' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(false)\n                expect(result.toSet).toEqual({})\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'no_change' })\n            })\n\n            it('should return no changes when $set_once property already exists', () => {\n                const event: PluginEvent = {\n                    event: 'pageview',\n                    properties: {\n                        $set_once: { first_seen: '2024-01-01' },\n                    },\n                } as any\n\n                const personProperties = { first_seen: '2023-01-01' }\n\n                const result = computeEventPropertyUpdates(event, personProperties)\n\n                expect(result.hasChanges).toBe(false)\n                expect(result.toSet).toEqual({})\n                expect(result.shouldForceUpdate).toBe(false)\n                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'no_change' })\n            })\n\n            it('should return no changes when trying",
            "cost": 0.157225
        },
        "PostHog__posthog.main/plugin-server/src/worker/ingestion/persons/person-update.ts": {
            "output": "import { PluginEvent, Properties } from '@posthog/plugin-scaffold'\n\nimport { cloneObject } from '~/utils/utils'\n\nimport { InternalPerson } from '../../../types'\nimport { logger } from '../../../utils/logger'\nimport { personProfileIgnoredPropertiesCounter, personProfileUpdateOutcomeCounter } from './metrics'\nimport { eventToPersonProperties, initialEventToPersonProperties } from './person-property-utils'\n\nexport interface PropertyUpdates {\n    toSet: Properties\n    toUnset: string[]\n    hasChanges: boolean\n    shouldForceUpdate: boolean // True for PERSON_EVENTS ($identify, $set, etc.) to bypass batch-level filtering\n}\n\n// These events are processed in a separate pipeline, so we don't allow person property updates\n// because there is no ordering guaranteed across them with other person updates\nconst NO_PERSON_UPDATE_EVENTS = new Set(['$exception', '$$heatmap'])\nconst PERSON_EVENTS = new Set(['$identify', '$create_alias', '$merge_dangerously', '$set'])\n\n// GeoIP properties that should still trigger person updates even when other geoip properties are blocked\n// These are commonly used for segmentation and are worth keeping up-to-date\nconst ALLOWED_GEOIP_PROPERTIES = new Set(['$geoip_country_name', '$geoip_city_name'])\n\n// For tracking what property keys cause us to update persons\n// tracking all properties we add from the event, 'geoip' for '$geoip_*' or '$initial_geoip_*' and 'other' for anything outside of those\nexport function getMetricKey(key: string): string {\n    if (key.startsWith('$geoip_') || key.startsWith('$initial_geoip_')) {\n        return 'geoIP'\n    }\n    if (eventToPersonProperties.has(key)) {\n        return key\n    }\n    if (initialEventToPersonProperties.has(key)) {\n        return key\n    }\n    return 'other'\n}\n\n/**\n * Computes property changes from an event without modifying personProperties\n * @param event The event to extract property changes from\n * @param personProperties Current person properties (not modified)\n * @param updateAllProperties When true, all property changes trigger updates (no filtering)\n * @returns Object with properties to set, unset, and whether there are changes\n */\nexport function computeEventPropertyUpdates(\n    event: PluginEvent,\n    personProperties: Properties,\n    updateAllProperties: boolean = false\n): PropertyUpdates {\n    if (NO_PERSON_UPDATE_EVENTS.has(event.event)) {\n        personProfileUpdateOutcomeCounter.labels({ outcome: 'unsupported' }).inc()\n        return { hasChanges: false, toSet: {}, toUnset: [], shouldForceUpdate: false }\n    }\n\n    // Check if this is a PERSON_EVENT that should bypass batch-level filtering\n    // Also force update when updateAllProperties is enabled\n    const shouldForceUpdate = PERSON_EVENTS.has(event.event) || updateAllProperties\n\n    const properties: Properties = event.properties!['$set'] || {}\n    const propertiesOnce: Properties = event.properties!['$set_once'] || {}\n    const unsetProps = event.properties!['$unset']\n    const unsetProperties: Array<string> = Array.isArray(unsetProps) ? unsetProps : Object.keys(unsetProps || {}) || []\n\n    let hasChanges = false\n    let hasNonFilteredChanges = false\n    const toSet: Properties = {}\n    const toUnset: string[] = []\n    const ignoredProperties: string[] = []\n\n    Object.entries(propertiesOnce).forEach(([key, value]) => {\n        if (typeof personProperties[key] === 'undefined') {\n            hasChanges = true\n            toSet[key] = value\n            if (shouldUpdatePersonIfOnlyChange(event, key, updateAllProperties)) {\n                hasNonFilteredChanges = true\n            }\n        }\n    })\n\n    // First pass: detect if any property would trigger an update\n    // If so, all changed properties in this $set should be updated together\n    let anyPropertyTriggersUpdate = false\n    const changedProperties: Array<[string, unknown]> = []\n\n    Object.entries(properties).forEach(([key, value]) => {\n        if (personProperties[key] !== value) {\n            changedProperties.push([key, value])\n            const isNewProperty = typeof personProperties[key] === 'undefined'\n            if (isNewProperty || shouldUpdatePersonIfOnlyChange(event, key, updateAllProperties)) {\n                anyPropertyTriggersUpdate = true\n            }\n        }\n    })\n\n    // Second pass: apply changes - if any property triggers update, all do\n    changedProperties.forEach(([key, value]) => {\n        hasChanges = true\n        if (anyPropertyTriggersUpdate) {\n            hasNonFilteredChanges = true\n        } else {\n            ignoredProperties.push(key)\n        }\n        toSet[key] = value\n    })\n\n    unsetProperties.forEach((propertyKey) => {\n        if (propertyKey in personProperties) {\n            if (typeof propertyKey === 'string') {\n                hasChanges = true\n                hasNonFilteredChanges = true\n                toUnset.push(propertyKey)\n            }\n        }\n    })\n\n    // Track person profile update outcomes at event level (skip when updateAllProperties is enabled)\n    if (!updateAllProperties) {\n        const hasPropertyChanges = Object.keys(toSet).length > 0 || toUnset.length > 0\n        if (hasPropertyChanges) {\n            if (hasNonFilteredChanges) {\n                personProfileUpdateOutcomeCounter.labels({ outcome: 'changed' }).inc()\n            } else {\n                personProfileUpdateOutcomeCounter.labels({ outcome: 'ignored' }).inc()\n                ignoredProperties.forEach((property) => {\n                    personProfileIgnoredPropertiesCounter.labels({ property }).inc()\n                })\n            }\n        } else {\n            personProfileUpdateOutcomeCounter.labels({ outcome: 'no_change' }).inc()\n        }\n    }\n\n    return { hasChanges, toSet, toUnset, shouldForceUpdate }\n}\n\n/**\n * @param propertyUpdates The computed property updates to apply\n * @param person The person to apply updates to - a new person object is returned with updated properties\n * @returns [updatedPerson, wasUpdated] - new person object and boolean indicating if changes were made\n */\nexport function applyEventPropertyUpdates(\n    propertyUpdates: PropertyUpdates,\n    person: InternalPerson\n): [InternalPerson, boolean] {\n    let updated = false\n\n    // Create a copy of the person with copied properties\n    const updatedPerson = cloneObject(person)\n\n    // Apply properties to set\n    Object.entries(propertyUpdates.toSet).forEach(([key, value]) => {\n        if (updatedPerson.properties[key] !== value) {\n            updated = true\n        }\n        updatedPerson.properties[key] = value\n    })\n\n    // Apply properties to unset\n    propertyUpdates.toUnset.forEach((propertyKey) => {\n        if (propertyKey in updatedPerson.properties) {\n            if (typeof propertyKey !== 'string') {\n                logger.warn('\ud83d\udd14', 'unset_property_key_not_string', { propertyKey, toUnset: propertyUpdates.toUnset })\n                return\n            }\n            updated = true\n            delete updatedPerson.properties[propertyKey]\n        }\n    })\n\n    return [updatedPerson, updated]\n}\n\n/**\n * Determines if a property key should be filtered out from triggering person updates.\n * These are properties that change frequently but aren't valuable enough to update the person record for.\n *\n * This is the single source of truth for property filtering logic, used by both:\n * - Event-level processing (computeEventPropertyUpdates)\n * - Batch-level processing (getPersonUpdateOutcome in batch-writing-person-store)\n */\nexport function isFilteredPersonPropertyKey(key: string): boolean {\n    // These are properties we add from the event and some change often, it's useless to update person always\n    if (eventToPersonProperties.has(key)) {\n        return true\n    }\n    // same as above, coming from GeoIP plugin\n    // but allow country and city updates as they're commonly used for segmentation\n    if (key.startsWith('$geoip_')) {\n        return !ALLOWED_GEOIP_PROPERTIES.has(key)\n    }\n    return false\n}\n\n// Minimize useless person updates by not overriding properties if it's not a person event and we added from the event\n// They will still show up for PoE as it's not removed from the event, we just don't update the person in PG anymore\nfunction shouldUpdatePersonIfOnlyChange(event: PluginEvent, key: string, updateAllProperties: boolean): boolean {\n    if (updateAllProperties) {\n        // When flag is enabled, all property changes trigger updates\n        return true\n    }\n    if (PERSON_EVENTS.has(event.event)) {\n        // for person events always update everything\n        return true\n    }\n    return !isFilteredPersonPropertyKey(key)\n}",
            "output_extracted": "import { PluginEvent, Properties } from '@posthog/plugin-scaffold'\n\nimport { cloneObject } from '~/utils/utils'\n\nimport { InternalPerson } from '../../../types'\nimport { logger } from '../../../utils/logger'\nimport { personProfileIgnoredPropertiesCounter, personProfileUpdateOutcomeCounter } from './metrics'\nimport { eventToPersonProperties, initialEventToPersonProperties } from './person-property-utils'\n\nexport interface PropertyUpdates {\n    toSet: Properties\n    toUnset: string[]\n    hasChanges: boolean\n    shouldForceUpdate: boolean // True for PERSON_EVENTS ($identify, $set, etc.) to bypass batch-level filtering\n}\n\n// These events are processed in a separate pipeline, so we don't allow person property updates\n// because there is no ordering guaranteed across them with other person updates\nconst NO_PERSON_UPDATE_EVENTS = new Set(['$exception', '$$heatmap'])\nconst PERSON_EVENTS = new Set(['$identify', '$create_alias', '$merge_dangerously', '$set'])\n\n// GeoIP properties that should still trigger person updates even when other geoip properties are blocked\n// These are commonly used for segmentation and are worth keeping up-to-date\nconst ALLOWED_GEOIP_PROPERTIES = new Set(['$geoip_country_name', '$geoip_city_name'])\n\n// For tracking what property keys cause us to update persons\n// tracking all properties we add from the event, 'geoip' for '$geoip_*' or '$initial_geoip_*' and 'other' for anything outside of those\nexport function getMetricKey(key: string): string {\n    if (key.startsWith('$geoip_') || key.startsWith('$initial_geoip_')) {\n        return 'geoIP'\n    }\n    if (eventToPersonProperties.has(key)) {\n        return key\n    }\n    if (initialEventToPersonProperties.has(key)) {\n        return key\n    }\n    return 'other'\n}\n\n/**\n * Computes property changes from an event without modifying personProperties\n * @param event The event to extract property changes from\n * @param personProperties Current person properties (not modified)\n * @param updateAllProperties When true, all property changes trigger updates (no filtering)\n * @returns Object with properties to set, unset, and whether there are changes\n */\nexport function computeEventPropertyUpdates(\n    event: PluginEvent,\n    personProperties: Properties,\n    updateAllProperties: boolean = false\n): PropertyUpdates {\n    if (NO_PERSON_UPDATE_EVENTS.has(event.event)) {\n        personProfileUpdateOutcomeCounter.labels({ outcome: 'unsupported' }).inc()\n        return { hasChanges: false, toSet: {}, toUnset: [], shouldForceUpdate: false }\n    }\n\n    // Check if this is a PERSON_EVENT that should bypass batch-level filtering\n    // Also force update when updateAllProperties is enabled\n    const shouldForceUpdate = PERSON_EVENTS.has(event.event) || updateAllProperties\n\n    const properties: Properties = event.properties!['$set'] || {}\n    const propertiesOnce: Properties = event.properties!['$set_once'] || {}\n    const unsetProps = event.properties!['$unset']\n    const unsetProperties: Array<string> = Array.isArray(unsetProps) ? unsetProps : Object.keys(unsetProps || {}) || []\n\n    let hasChanges = false\n    let hasNonFilteredChanges = false\n    const toSet: Properties = {}\n    const toUnset: string[] = []\n    const ignoredProperties: string[] = []\n\n    Object.entries(propertiesOnce).forEach(([key, value]) => {\n        if (typeof personProperties[key] === 'undefined') {\n            hasChanges = true\n            toSet[key] = value\n            if (shouldUpdatePersonIfOnlyChange(event, key, updateAllProperties)) {\n                hasNonFilteredChanges = true\n            }\n        }\n    })\n\n    // First pass: detect if any property would trigger an update\n    // If so, all changed properties in this $set should be updated together\n    let anyPropertyTriggersUpdate = false\n    const changedProperties: Array<[string, unknown]> = []\n\n    Object.entries(properties).forEach(([key, value]) => {\n        if (personProperties[key] !== value) {\n            changedProperties.push([key, value])\n            const isNewProperty = typeof personProperties[key] === 'undefined'\n            if (isNewProperty || shouldUpdatePersonIfOnlyChange(event, key, updateAllProperties)) {\n                anyPropertyTriggersUpdate = true\n            }\n        }\n    })\n\n    // Second pass: apply changes - if any property triggers update, all do\n    changedProperties.forEach(([key, value]) => {\n        hasChanges = true\n        if (anyPropertyTriggersUpdate) {\n            hasNonFilteredChanges = true\n        } else {\n            ignoredProperties.push(key)\n        }\n        toSet[key] = value\n    })\n\n    unsetProperties.forEach((propertyKey) => {\n        if (propertyKey in personProperties) {\n            if (typeof propertyKey === 'string') {\n                hasChanges = true\n                hasNonFilteredChanges = true\n                toUnset.push(propertyKey)\n            }\n        }\n    })\n\n    // Track person profile update outcomes at event level (skip when updateAllProperties is enabled)\n    if (!updateAllProperties) {\n        const hasPropertyChanges = Object.keys(toSet).length > 0 || toUnset.length > 0\n        if (hasPropertyChanges) {\n            if (hasNonFilteredChanges) {\n                personProfileUpdateOutcomeCounter.labels({ outcome: 'changed' }).inc()\n            } else {\n                personProfileUpdateOutcomeCounter.labels({ outcome: 'ignored' }).inc()\n                ignoredProperties.forEach((property) => {\n                    personProfileIgnoredPropertiesCounter.labels({ property }).inc()\n                })\n            }\n        } else {\n            personProfileUpdateOutcomeCounter.labels({ outcome: 'no_change' }).inc()\n        }\n    }\n\n    return { hasChanges, toSet, toUnset, shouldForceUpdate }\n}\n\n/**\n * @param propertyUpdates The computed property updates to apply\n * @param person The person to apply updates to - a new person object is returned with updated properties\n * @returns [updatedPerson, wasUpdated] - new person object and boolean indicating if changes were made\n */\nexport function applyEventPropertyUpdates(\n    propertyUpdates: PropertyUpdates,\n    person: InternalPerson\n): [InternalPerson, boolean] {\n    let updated = false\n\n    // Create a copy of the person with copied properties\n    const updatedPerson = cloneObject(person)\n\n    // Apply properties to set\n    Object.entries(propertyUpdates.toSet).forEach(([key, value]) => {\n        if (updatedPerson.properties[key] !== value) {\n            updated = true\n        }\n        updatedPerson.properties[key] = value\n    })\n\n    // Apply properties to unset\n    propertyUpdates.toUnset.forEach((propertyKey) => {\n        if (propertyKey in updatedPerson.properties) {\n            if (typeof propertyKey !== 'string') {\n                logger.warn('\ud83d\udd14', 'unset_property_key_not_string', { propertyKey, toUnset: propertyUpdates.toUnset })\n                return\n            }\n            updated = true\n            delete updatedPerson.properties[propertyKey]\n        }\n    })\n\n    return [updatedPerson, updated]\n}\n\n/**\n * Determines if a property key should be filtered out from triggering person updates.\n * These are properties that change frequently but aren't valuable enough to update the person record for.\n *\n * This is the single source of truth for property filtering logic, used by both:\n * - Event-level processing (computeEventPropertyUpdates)\n * - Batch-level processing (getPersonUpdateOutcome in batch-writing-person-store)\n */\nexport function isFilteredPersonPropertyKey(key: string): boolean {\n    // These are properties we add from the event and some change often, it's useless to update person always\n    if (eventToPersonProperties.has(key)) {\n        return true\n    }\n    // same as above, coming from GeoIP plugin\n    // but allow country and city updates as they're commonly used for segmentation\n    if (key.startsWith('$geoip_')) {\n        return !ALLOWED_GEOIP_PROPERTIES.has(key)\n    }\n    return false\n}\n\n// Minimize useless person updates by not overriding properties if it's not a person event and we added from the event\n// They will still show up for PoE as it's not removed from the event, we just don't update the person in PG anymore\nfunction shouldUpdatePersonIfOnlyChange(event: PluginEvent, key: string, updateAllProperties: boolean): boolean {\n    if (updateAllProperties) {\n        // When flag is enabled, all property changes trigger updates\n        return true\n    }\n    if (PERSON_EVENTS.has(event.event)) {\n        // for person events always update everything\n        return true\n    }\n    return !isFilteredPersonPropertyKey(key)\n}",
            "cost": 0.07602
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "PostHog__posthog.main.42570",
        "repo": "PostHog/posthog",
        "base_commit": "1eef58d5b1a249b5cb594431065fa5590cbff5b0",
        "head_commit": "122f638320d8fc3e71e3094b1cee90002c247098",
        "title": "feat(persons): Update app* attributes",
        "merged_at": "2025-12-04T08:34:20Z",
        "html_url": "https://github.com/PostHog/posthog/pull/42570",
        "test_files": [
            "plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts",
            "plugin-server/src/worker/ingestion/persons/person-update.test.ts"
        ],
        "code_files": [
            "plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts",
            "plugin-server/src/worker/ingestion/persons/person-property-utils.ts",
            "plugin-server/src/worker/ingestion/persons/person-update.ts"
        ],
        "total_changes": 214,
        "num_files": 5,
        "pull_number": 42570,
        "patch": "diff --git a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts\nindex c4e46a8913bff..8d7f96b85fdd0 100644\n--- a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts\n+++ b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts\n@@ -1557,15 +1557,16 @@ describe('BatchWritingPersonStore', () => {\n             typeof personPropertyKeyUpdateCounter\n         >\n \n-        it('should skip database write when only eventToPersonProperties are updated', async () => {\n+        it('should skip database write when only filtered properties are updated', async () => {\n             const mockRepo = createMockRepository()\n             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n \n             // Update person with only filtered properties (existing properties being updated)\n+            // Using $current_url and $pathname which are in FILTERED_PERSON_UPDATE_PROPERTIES\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n-                { ...person, properties: { $browser: 'Firefox', $app_build: '100' } },\n-                { $browser: 'Chrome', $app_build: '200' },\n+                { ...person, properties: { $current_url: 'https://old.com', $pathname: '/old' } },\n+                { $current_url: 'https://new.com', $pathname: '/new' },\n                 [],\n                 {},\n                 'test'\n@@ -1585,10 +1586,10 @@ describe('BatchWritingPersonStore', () => {\n             )\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledTimes(2)\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$browser',\n+                property: '$current_url',\n             })\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$app_build',\n+                property: '$pathname',\n             })\n             // personPropertyKeyUpdateCounter should NOT be called for 'ignored' outcomes\n             expect(mockPersonPropertyKeyUpdateCounter.labels).not.toHaveBeenCalled()\n@@ -1744,9 +1745,10 @@ describe('BatchWritingPersonStore', () => {\n             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n \n             // Update person with only filtered properties but with force_update=true (simulating $identify/$set events)\n+            // Using $current_url and $pathname which are in FILTERED_PERSON_UPDATE_PROPERTIES\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n-                { ...person, properties: { $browser: 'Firefox', $app_build: '100' } },\n-                { $browser: 'Chrome', $app_build: '200' },\n+                { ...person, properties: { $current_url: 'https://old.com', $pathname: '/old' } },\n+                { $current_url: 'https://new.com', $pathname: '/new' },\n                 [],\n                 {},\n                 'test',\n@@ -1768,8 +1770,8 @@ describe('BatchWritingPersonStore', () => {\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n             // personPropertyKeyUpdateCounter should be called for the updated properties\n             expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledTimes(2)\n-            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$browser' })\n-            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$app_build' })\n+            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$current_url' })\n+            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$pathname' })\n         })\n \n         it('integration: multiple events with only filtered properties should not trigger database write', async () => {\n@@ -1777,28 +1779,29 @@ describe('BatchWritingPersonStore', () => {\n             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n \n+            // Using properties that are in FILTERED_PERSON_UPDATE_PROPERTIES\n             const personWithFiltered = {\n                 ...person,\n                 properties: {\n-                    $browser: 'Firefox',\n-                    $app_build: '100',\n+                    $current_url: 'https://old.com',\n+                    $pathname: '/old',\n                     $geoip_latitude: 40.7128,\n                 },\n             }\n \n-            // Event 1: Update browser\n+            // Event 1: Update current_url (filtered)\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $browser: 'Chrome' },\n+                { $current_url: 'https://new.com' },\n                 [],\n                 {},\n                 'test'\n             )\n \n-            // Event 2: Update app build\n+            // Event 2: Update pathname (filtered)\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $app_build: '200' },\n+                { $pathname: '/new' },\n                 [],\n                 {},\n                 'test'\n@@ -1827,10 +1830,10 @@ describe('BatchWritingPersonStore', () => {\n             )\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledTimes(3)\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$browser',\n+                property: '$current_url',\n             })\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$app_build',\n+                property: '$pathname',\n             })\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n                 property: '$geoip_latitude',\n@@ -2098,18 +2101,19 @@ describe('BatchWritingPersonStore', () => {\n             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n \n+            // Using properties that are in FILTERED_PERSON_UPDATE_PROPERTIES\n             const personWithFiltered = {\n                 ...person,\n                 properties: {\n-                    $browser: 'Firefox',\n-                    $app_build: '100',\n+                    $current_url: 'https://old.com',\n+                    $pathname: '/old',\n                 },\n             }\n \n             // Event 1: Normal event with filtered properties\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $browser: 'Chrome' },\n+                { $current_url: 'https://new.com' },\n                 [],\n                 {},\n                 'test'\n@@ -2119,7 +2123,7 @@ describe('BatchWritingPersonStore', () => {\n             // Event 2: Another normal event with filtered properties\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $app_build: '200' },\n+                { $pathname: '/new' },\n                 [],\n                 {},\n                 'test'\n@@ -2129,7 +2133,7 @@ describe('BatchWritingPersonStore', () => {\n             // Event 3: Yet another normal event with filtered properties\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $browser: 'Safari' },\n+                { $current_url: 'https://another.com' },\n                 [],\n                 {},\n                 'test'\n@@ -2151,10 +2155,10 @@ describe('BatchWritingPersonStore', () => {\n             // Properties should be marked as ignored\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledTimes(2)\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$browser',\n+                property: '$current_url',\n             })\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$app_build',\n+                property: '$pathname',\n             })\n             // personPropertyKeyUpdateCounter should NOT be called for 'ignored' outcomes\n             expect(mockPersonPropertyKeyUpdateCounter.labels).not.toHaveBeenCalled()\ndiff --git a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts\nindex 950dcc22aee0a..958f258fff405 100644\n--- a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts\n+++ b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts\n@@ -36,7 +36,8 @@ import {\n     personWriteMethodAttemptCounter,\n     totalPersonUpdateLatencyPerBatchHistogram,\n } from './metrics'\n-import { getMetricKey, isFilteredPersonPropertyKey } from './person-update'\n+import { isFilteredPersonUpdateProperty } from './person-property-utils'\n+import { getMetricKey } from './person-update'\n import { PersonUpdate, fromInternalPerson, toInternalPerson } from './person-update-batch'\n import { PersonsStore } from './persons-store'\n import { FlushResult, PersonsStoreForBatch } from './persons-store-for-batch'\n@@ -206,7 +207,7 @@ export class BatchWritingPersonsStoreForBatch implements PersonsStoreForBatch, B\n                 return true\n             }\n \n-            const isFiltered = isFilteredPersonPropertyKey(key)\n+            const isFiltered = isFilteredPersonUpdateProperty(key)\n             if (isFiltered) {\n                 ignoredProperties.push(key)\n                 return false\ndiff --git a/plugin-server/src/worker/ingestion/persons/person-property-utils.ts b/plugin-server/src/worker/ingestion/persons/person-property-utils.ts\nindex dfbdf3f1cf54c..b576133eeeed5 100644\n--- a/plugin-server/src/worker/ingestion/persons/person-property-utils.ts\n+++ b/plugin-server/src/worker/ingestion/persons/person-property-utils.ts\n@@ -143,3 +143,68 @@ export const initialCampaignParams = new Set(\n export const initialEventToPersonProperties = new Set(\n     Array.from(eventToPersonProperties, (key) => `$initial_${key.replace('$', '')}`)\n )\n+\n+/**\n+ * Properties that should NOT trigger a person update on their own.\n+ * These change frequently but aren't valuable enough to update the person record for.\n+ * They will still be included in the person properties when an update happens for other reasons.\n+ *\n+ * This is the single source of truth for person update filtering logic.\n+ *\n+ * Note: Properties NOT in this list will trigger updates by default.\n+ *\n+ * GeoIP properties source: posthog/geoip.py and posthog/taxonomy/taxonomy.py\n+ * GeoIP properties that DO trigger updates (not listed here): $geoip_country_name, $geoip_city_name\n+ */\n+export const FILTERED_PERSON_UPDATE_PROPERTIES = new Set([\n+    // URL/navigation properties - change on every page view\n+    '$current_url',\n+    '$pathname',\n+    '$referring_domain',\n+    '$referrer',\n+\n+    // Screen/viewport dimensions - can change on window resize\n+    '$screen_height',\n+    '$screen_width',\n+    '$viewport_height',\n+    '$viewport_width',\n+\n+    // Browser/device properties - change less frequently but still filtered\n+    '$browser',\n+    '$browser_version',\n+    '$device_type',\n+    '$raw_user_agent',\n+    '$os',\n+    '$os_name',\n+    '$os_version',\n+\n+    // GeoIP properties - filtered because they change frequently\n+    '$geoip_postal_code',\n+    '$geoip_time_zone',\n+    '$geoip_latitude',\n+    '$geoip_longitude',\n+    '$geoip_accuracy_radius',\n+    '$geoip_subdivision_1_code',\n+    '$geoip_subdivision_1_name',\n+    '$geoip_subdivision_2_code',\n+    '$geoip_subdivision_2_name',\n+    '$geoip_subdivision_3_code',\n+    '$geoip_subdivision_3_name',\n+    '$geoip_city_confidence',\n+    '$geoip_country_confidence',\n+    '$geoip_postal_code_confidence',\n+    '$geoip_subdivision_1_confidence',\n+    '$geoip_subdivision_2_confidence',\n+])\n+\n+/**\n+ * Determines if a property key should be filtered out from triggering person updates.\n+ * These are properties that change frequently but aren't valuable enough to update the person record for.\n+ *\n+ * This is the single source of truth for property filtering logic, used by both:\n+ * - Event-level processing (computeEventPropertyUpdates in person-update.ts)\n+ * - Batch-level processing (getPersonUpdateOutcome in batch-writing-person-store.ts)\n+ */\n+export function isFilteredPersonUpdateProperty(key: string): boolean {\n+    return FILTERED_PERSON_UPDATE_PROPERTIES.has(key)\n+}\ndiff --git a/plugin-server/src/worker/ingestion/persons/person-update.test.ts b/plugin-server/src/worker/ingestion/persons/person-update.test.ts\nindex c55c6e1cd95e3..9790636a47bf7 100644\n--- a/plugin-server/src/worker/ingestion/persons/person-update.test.ts\n+++ b/plugin-server/src/worker/ingestion/persons/person-update.test.ts\n@@ -1,7 +1,7 @@\n import { PluginEvent } from '@posthog/plugin-scaffold'\n \n import { personProfileIgnoredPropertiesCounter, personProfileUpdateOutcomeCounter } from './metrics'\n-import { eventToPersonProperties } from './person-property-utils'\n+import { FILTERED_PERSON_UPDATE_PROPERTIES } from './person-property-utils'\n import { applyEventPropertyUpdates, computeEventPropertyUpdates } from './person-update'\n \n jest.mock('./metrics', () => ({\n@@ -123,9 +123,9 @@ describe('person-update', () => {\n             })\n         })\n \n-        describe('eventToPersonProperties accepted at event level', () => {\n-            it.each(Array.from(eventToPersonProperties))(\n-                'should accept \"%s\" updates at event level (filtering happens at batch level)',\n+        describe('filtered properties behavior', () => {\n+            it.each(Array.from(FILTERED_PERSON_UPDATE_PROPERTIES))(\n+                'should mark \"%s\" as ignored when updated',\n                 (propertyName) => {\n                     const event: PluginEvent = {\n                         event: 'pageview',\n@@ -141,8 +141,7 @@ describe('person-update', () => {\n                     expect(result.hasChanges).toBe(true)\n                     expect(result.toSet).toEqual({ [propertyName]: 'new_value' })\n                     expect(result.shouldForceUpdate).toBe(false)\n-                    // At event level, this property would be marked as ignored (outcome: 'ignored')\n-                    // but it's still included in toSet for batch-level filtering\n+                    // Filtered properties are marked as ignored\n                     expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                     expect(mockPersonProfileUpdateOutcomeCounter.labels({ outcome: 'ignored' }).inc).toHaveBeenCalled()\n                     expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n@@ -250,54 +249,54 @@ describe('person-update', () => {\n                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n             })\n \n-            it('should accept eventToPersonProperties even when mixed with unchanged custom properties', () => {\n+            it('should accept filtered properties even when mixed with unchanged custom properties', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n-                        $set: { $browser: 'Chrome', custom_prop: 'same_value' },\n+                        $set: { $current_url: 'https://example.com/new', custom_prop: 'same_value' },\n                     },\n                 } as any\n \n-                const personProperties = { $browser: 'Firefox', custom_prop: 'same_value' }\n+                const personProperties = { $current_url: 'https://example.com/old', custom_prop: 'same_value' }\n \n                 const result = computeEventPropertyUpdates(event, personProperties)\n \n                 expect(result.hasChanges).toBe(true)\n-                expect(result.toSet).toEqual({ $browser: 'Chrome' })\n+                expect(result.toSet).toEqual({ $current_url: 'https://example.com/new' })\n                 expect(result.shouldForceUpdate).toBe(false)\n-                // At event level, $browser would be marked as ignored\n+                // $current_url is filtered, so it should be marked as ignored\n                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                    property: '$browser',\n+                    property: '$current_url',\n                 })\n             })\n \n-            it('should accept multiple eventToPersonProperties at event level', () => {\n-                // Note: Campaign properties (utm_source, utm_campaign) are no longer in eventToPersonProperties\n-                // and will trigger updates like custom properties\n+            it('should accept multiple filtered properties at event level', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n                         $set: {\n-                            $browser: 'Chrome',\n-                            $os: 'macOS',\n+                            $current_url: 'https://example.com/new',\n+                            $pathname: '/new-path',\n                         },\n                     },\n                 } as any\n \n                 const personProperties = {\n-                    $browser: 'Firefox',\n-                    $os: 'Windows',\n+                    $current_url: 'https://example.com/old',\n+                    $pathname: '/old-path',\n                 }\n \n                 const result = computeEventPropertyUpdates(event, personProperties)\n \n                 expect(result.hasChanges).toBe(true)\n                 expect(result.shouldForceUpdate).toBe(false)\n-                // At event level, eventToPersonProperties would be marked as ignored\n+                // Filtered properties should be marked as ignored\n                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n-                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$browser' })\n-                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$os' })\n+                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n+                    property: '$current_url',\n+                })\n+                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$pathname' })\n             })\n         })\n \n@@ -376,7 +375,7 @@ describe('person-update', () => {\n         })\n \n         describe('person events behavior', () => {\n-            it('should compute updates for eventToPersonProperties on $identify events', () => {\n+            it('should compute updates for any property on $identify events', () => {\n                 const event: PluginEvent = {\n                     event: '$identify',\n                     properties: {\n@@ -394,7 +393,7 @@ describe('person-update', () => {\n                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n             })\n \n-            it('should compute updates for eventToPersonProperties on $set events', () => {\n+            it('should compute updates for any property on $set events', () => {\n                 const event: PluginEvent = {\n                     event: '$set',\n                     properties: {\n@@ -466,7 +465,7 @@ describe('person-update', () => {\n         })\n \n         describe('mixed scenarios', () => {\n-            it('should compute updates when both custom and eventToPersonProperties change', () => {\n+            it('should compute updates when both custom and allowed properties change', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n@@ -486,8 +485,8 @@ describe('person-update', () => {\n         })\n \n         describe('updateAllProperties flag enabled', () => {\n-            it.each(Array.from(eventToPersonProperties))(\n-                'should trigger update for \"%s\" when updateAllProperties is true',\n+            it.each(Array.from(FILTERED_PERSON_UPDATE_PROPERTIES))(\n+                'should trigger update for filtered property \"%s\" when updateAllProperties is true',\n                 (propertyName) => {\n                     const event: PluginEvent = {\n                         event: 'pageview',\n@@ -529,7 +528,7 @@ describe('person-update', () => {\n                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n             })\n \n-            it('should trigger update for multiple eventToPersonProperties when updateAllProperties is true', () => {\n+            it('should trigger update for multiple allowed properties when updateAllProperties is true', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n@@ -555,7 +554,7 @@ describe('person-update', () => {\n                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n             })\n \n-            it('should trigger update for mixed eventToPersonProperties and custom properties when updateAllProperties is true', () => {\n+            it('should trigger update for mixed allowed and custom properties when updateAllProperties is true', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n@@ -575,7 +574,7 @@ describe('person-update', () => {\n                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n             })\n \n-            it('should trigger update for mixed $geoip_* and eventToPersonProperties when updateAllProperties is true', () => {\n+            it('should trigger update for mixed $geoip_* and allowed properties when updateAllProperties is true', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\ndiff --git a/plugin-server/src/worker/ingestion/persons/person-update.ts b/plugin-server/src/worker/ingestion/persons/person-update.ts\nindex 9b40787ff1928..1b2ebca4071e2 100644\n--- a/plugin-server/src/worker/ingestion/persons/person-update.ts\n+++ b/plugin-server/src/worker/ingestion/persons/person-update.ts\n@@ -5,7 +5,11 @@ import { cloneObject } from '~/utils/utils'\n import { InternalPerson } from '../../../types'\n import { logger } from '../../../utils/logger'\n import { personProfileIgnoredPropertiesCounter, personProfileUpdateOutcomeCounter } from './metrics'\n-import { eventToPersonProperties, initialEventToPersonProperties } from './person-property-utils'\n+import {\n+    eventToPersonProperties,\n+    initialEventToPersonProperties,\n+    isFilteredPersonUpdateProperty,\n+} from './person-property-utils'\n \n export interface PropertyUpdates {\n     toSet: Properties\n@@ -19,10 +23,6 @@ export interface PropertyUpdates {\n const NO_PERSON_UPDATE_EVENTS = new Set(['$exception', '$$heatmap'])\n const PERSON_EVENTS = new Set(['$identify', '$create_alias', '$merge_dangerously', '$set'])\n \n-// GeoIP properties that should still trigger person updates even when other geoip properties are blocked\n-// These are commonly used for segmentation and are worth keeping up-to-date\n-const ALLOWED_GEOIP_PROPERTIES = new Set(['$geoip_country_name', '$geoip_city_name'])\n-\n // For tracking what property keys cause us to update persons\n // tracking all properties we add from the event, 'geoip' for '$geoip_*' or '$initial_geoip_*' and 'other' for anything outside of those\n export function getMetricKey(key: string): string {\n@@ -173,27 +173,6 @@ export function applyEventPropertyUpdates(\n     return [updatedPerson, updated]\n }\n \n-/**\n- * Determines if a property key should be filtered out from triggering person updates.\n- * These are properties that change frequently but aren't valuable enough to update the person record for.\n- *\n- * This is the single source of truth for property filtering logic, used by both:\n- * - Event-level processing (computeEventPropertyUpdates)\n- * - Batch-level processing (getPersonUpdateOutcome in batch-writing-person-store)\n- */\n-export function isFilteredPersonPropertyKey(key: string): boolean {\n-    // These are properties we add from the event and some change often, it's useless to update person always\n-    if (eventToPersonProperties.has(key)) {\n-        return true\n-    }\n-    // same as above, coming from GeoIP plugin\n-    // but allow country and city updates as they're commonly used for segmentation\n-    if (key.startsWith('$geoip_')) {\n-        return !ALLOWED_GEOIP_PROPERTIES.has(key)\n-    }\n-    return false\n-}\n-\n // Minimize useless person updates by not overriding properties if it's not a person event and we added from the event\n // They will still show up for PoE as it's not removed from the event, we just don't update the person in PG anymore\n function shouldUpdatePersonIfOnlyChange(event: PluginEvent, key: string, updateAllProperties: boolean): boolean {\n@@ -205,5 +184,5 @@ function shouldUpdatePersonIfOnlyChange(event: PluginEvent, key: string, updateA\n         // for person events always update everything\n         return true\n     }\n-    return !isFilteredPersonPropertyKey(key)\n+    return !isFilteredPersonUpdateProperty(key)\n }\n",
        "pr_mirror": "PostHog__posthog.main"
    }
}