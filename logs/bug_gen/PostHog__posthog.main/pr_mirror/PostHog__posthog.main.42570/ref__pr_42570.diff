diff --git a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts
index c4e46a8913bff..8d7f96b85fdd0 100644
--- a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts
+++ b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts
@@ -1557,15 +1557,16 @@ describe('BatchWritingPersonStore', () => {
             typeof personPropertyKeyUpdateCounter
         >
 
-        it('should skip database write when only eventToPersonProperties are updated', async () => {
+        it('should skip database write when only filtered properties are updated', async () => {
             const mockRepo = createMockRepository()
             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)
             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch
 
             // Update person with only filtered properties (existing properties being updated)
+            // Using $current_url and $pathname which are in FILTERED_PERSON_UPDATE_PROPERTIES
             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(
-                { ...person, properties: { $browser: 'Firefox', $app_build: '100' } },
-                { $browser: 'Chrome', $app_build: '200' },
+                { ...person, properties: { $current_url: 'https://old.com', $pathname: '/old' } },
+                { $current_url: 'https://new.com', $pathname: '/new' },
                 [],
                 {},
                 'test'
@@ -1585,10 +1586,10 @@ describe('BatchWritingPersonStore', () => {
             )
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledTimes(2)
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({
-                property: '$browser',
+                property: '$current_url',
             })
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({
-                property: '$app_build',
+                property: '$pathname',
             })
             // personPropertyKeyUpdateCounter should NOT be called for 'ignored' outcomes
             expect(mockPersonPropertyKeyUpdateCounter.labels).not.toHaveBeenCalled()
@@ -1744,9 +1745,10 @@ describe('BatchWritingPersonStore', () => {
             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch
 
             // Update person with only filtered properties but with force_update=true (simulating $identify/$set events)
+            // Using $current_url and $pathname which are in FILTERED_PERSON_UPDATE_PROPERTIES
             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(
-                { ...person, properties: { $browser: 'Firefox', $app_build: '100' } },
-                { $browser: 'Chrome', $app_build: '200' },
+                { ...person, properties: { $current_url: 'https://old.com', $pathname: '/old' } },
+                { $current_url: 'https://new.com', $pathname: '/new' },
                 [],
                 {},
                 'test',
@@ -1768,8 +1770,8 @@ describe('BatchWritingPersonStore', () => {
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()
             // personPropertyKeyUpdateCounter should be called for the updated properties
             expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledTimes(2)
-            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$browser' })
-            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$app_build' })
+            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$current_url' })
+            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$pathname' })
         })
 
         it('integration: multiple events with only filtered properties should not trigger database write', async () => {
@@ -1777,28 +1779,29 @@ describe('BatchWritingPersonStore', () => {
             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)
             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch
 
+            // Using properties that are in FILTERED_PERSON_UPDATE_PROPERTIES
             const personWithFiltered = {
                 ...person,
                 properties: {
-                    $browser: 'Firefox',
-                    $app_build: '100',
+                    $current_url: 'https://old.com',
+                    $pathname: '/old',
                     $geoip_latitude: 40.7128,
                 },
             }
 
-            // Event 1: Update browser
+            // Event 1: Update current_url (filtered)
             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(
                 personWithFiltered,
-                { $browser: 'Chrome' },
+                { $current_url: 'https://new.com' },
                 [],
                 {},
                 'test'
             )
 
-            // Event 2: Update app build
+            // Event 2: Update pathname (filtered)
             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(
                 personWithFiltered,
-                { $app_build: '200' },
+                { $pathname: '/new' },
                 [],
                 {},
                 'test'
@@ -1827,10 +1830,10 @@ describe('BatchWritingPersonStore', () => {
             )
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledTimes(3)
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({
-                property: '$browser',
+                property: '$current_url',
             })
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({
-                property: '$app_build',
+                property: '$pathname',
             })
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({
                 property: '$geoip_latitude',
@@ -2098,18 +2101,19 @@ describe('BatchWritingPersonStore', () => {
             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)
             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch
 
+            // Using properties that are in FILTERED_PERSON_UPDATE_PROPERTIES
             const personWithFiltered = {
                 ...person,
                 properties: {
-                    $browser: 'Firefox',
-                    $app_build: '100',
+                    $current_url: 'https://old.com',
+                    $pathname: '/old',
                 },
             }
 
             // Event 1: Normal event with filtered properties
             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(
                 personWithFiltered,
-                { $browser: 'Chrome' },
+                { $current_url: 'https://new.com' },
                 [],
                 {},
                 'test'
@@ -2119,7 +2123,7 @@ describe('BatchWritingPersonStore', () => {
             // Event 2: Another normal event with filtered properties
             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(
                 personWithFiltered,
-                { $app_build: '200' },
+                { $pathname: '/new' },
                 [],
                 {},
                 'test'
@@ -2129,7 +2133,7 @@ describe('BatchWritingPersonStore', () => {
             // Event 3: Yet another normal event with filtered properties
             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(
                 personWithFiltered,
-                { $browser: 'Safari' },
+                { $current_url: 'https://another.com' },
                 [],
                 {},
                 'test'
@@ -2151,10 +2155,10 @@ describe('BatchWritingPersonStore', () => {
             // Properties should be marked as ignored
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledTimes(2)
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({
-                property: '$browser',
+                property: '$current_url',
             })
             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({
-                property: '$app_build',
+                property: '$pathname',
             })
             // personPropertyKeyUpdateCounter should NOT be called for 'ignored' outcomes
             expect(mockPersonPropertyKeyUpdateCounter.labels).not.toHaveBeenCalled()
diff --git a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts
index 950dcc22aee0a..958f258fff405 100644
--- a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts
+++ b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts
@@ -36,7 +36,8 @@ import {
     personWriteMethodAttemptCounter,
     totalPersonUpdateLatencyPerBatchHistogram,
 } from './metrics'
-import { getMetricKey, isFilteredPersonPropertyKey } from './person-update'
+import { isFilteredPersonUpdateProperty } from './person-property-utils'
+import { getMetricKey } from './person-update'
 import { PersonUpdate, fromInternalPerson, toInternalPerson } from './person-update-batch'
 import { PersonsStore } from './persons-store'
 import { FlushResult, PersonsStoreForBatch } from './persons-store-for-batch'
@@ -206,7 +207,7 @@ export class BatchWritingPersonsStoreForBatch implements PersonsStoreForBatch, B
                 return true
             }
 
-            const isFiltered = isFilteredPersonPropertyKey(key)
+            const isFiltered = isFilteredPersonUpdateProperty(key)
             if (isFiltered) {
                 ignoredProperties.push(key)
                 return false
diff --git a/plugin-server/src/worker/ingestion/persons/person-property-utils.ts b/plugin-server/src/worker/ingestion/persons/person-property-utils.ts
index dfbdf3f1cf54c..b576133eeeed5 100644
--- a/plugin-server/src/worker/ingestion/persons/person-property-utils.ts
+++ b/plugin-server/src/worker/ingestion/persons/person-property-utils.ts
@@ -143,3 +143,68 @@ export const initialCampaignParams = new Set(
 export const initialEventToPersonProperties = new Set(
     Array.from(eventToPersonProperties, (key) => `$initial_${key.replace('$', '')}`)
 )
+
+/**
+ * Properties that should NOT trigger a person update on their own.
+ * These change frequently but aren't valuable enough to update the person record for.
+ * They will still be included in the person properties when an update happens for other reasons.
+ *
+ * This is the single source of truth for person update filtering logic.
+ *
+ * Note: Properties NOT in this list will trigger updates by default.
+ *
+ * GeoIP properties source: posthog/geoip.py and posthog/taxonomy/taxonomy.py
+ * GeoIP properties that DO trigger updates (not listed here): $geoip_country_name, $geoip_city_name
+ */
+export const FILTERED_PERSON_UPDATE_PROPERTIES = new Set([
+    // URL/navigation properties - change on every page view
+    '$current_url',
+    '$pathname',
+    '$referring_domain',
+    '$referrer',
+
+    // Screen/viewport dimensions - can change on window resize
+    '$screen_height',
+    '$screen_width',
+    '$viewport_height',
+    '$viewport_width',
+
+    // Browser/device properties - change less frequently but still filtered
+    '$browser',
+    '$browser_version',
+    '$device_type',
+    '$raw_user_agent',
+    '$os',
+    '$os_name',
+    '$os_version',
+
+    // GeoIP properties - filtered because they change frequently
+    '$geoip_postal_code',
+    '$geoip_time_zone',
+    '$geoip_latitude',
+    '$geoip_longitude',
+    '$geoip_accuracy_radius',
+    '$geoip_subdivision_1_code',
+    '$geoip_subdivision_1_name',
+    '$geoip_subdivision_2_code',
+    '$geoip_subdivision_2_name',
+    '$geoip_subdivision_3_code',
+    '$geoip_subdivision_3_name',
+    '$geoip_city_confidence',
+    '$geoip_country_confidence',
+    '$geoip_postal_code_confidence',
+    '$geoip_subdivision_1_confidence',
+    '$geoip_subdivision_2_confidence',
+])
+
+/**
+ * Determines if a property key should be filtered out from triggering person updates.
+ * These are properties that change frequently but aren't valuable enough to update the person record for.
+ *
+ * This is the single source of truth for property filtering logic, used by both:
+ * - Event-level processing (computeEventPropertyUpdates in person-update.ts)
+ * - Batch-level processing (getPersonUpdateOutcome in batch-writing-person-store.ts)
+ */
+export function isFilteredPersonUpdateProperty(key: string): boolean {
+    return FILTERED_PERSON_UPDATE_PROPERTIES.has(key)
+}
diff --git a/plugin-server/src/worker/ingestion/persons/person-update.test.ts b/plugin-server/src/worker/ingestion/persons/person-update.test.ts
index c55c6e1cd95e3..9790636a47bf7 100644
--- a/plugin-server/src/worker/ingestion/persons/person-update.test.ts
+++ b/plugin-server/src/worker/ingestion/persons/person-update.test.ts
@@ -1,7 +1,7 @@
 import { PluginEvent } from '@posthog/plugin-scaffold'
 
 import { personProfileIgnoredPropertiesCounter, personProfileUpdateOutcomeCounter } from './metrics'
-import { eventToPersonProperties } from './person-property-utils'
+import { FILTERED_PERSON_UPDATE_PROPERTIES } from './person-property-utils'
 import { applyEventPropertyUpdates, computeEventPropertyUpdates } from './person-update'
 
 jest.mock('./metrics', () => ({
@@ -123,9 +123,9 @@ describe('person-update', () => {
             })
         })
 
-        describe('eventToPersonProperties accepted at event level', () => {
-            it.each(Array.from(eventToPersonProperties))(
-                'should accept "%s" updates at event level (filtering happens at batch level)',
+        describe('filtered properties behavior', () => {
+            it.each(Array.from(FILTERED_PERSON_UPDATE_PROPERTIES))(
+                'should mark "%s" as ignored when updated',
                 (propertyName) => {
                     const event: PluginEvent = {
                         event: 'pageview',
@@ -141,8 +141,7 @@ describe('person-update', () => {
                     expect(result.hasChanges).toBe(true)
                     expect(result.toSet).toEqual({ [propertyName]: 'new_value' })
                     expect(result.shouldForceUpdate).toBe(false)
-                    // At event level, this property would be marked as ignored (outcome: 'ignored')
-                    // but it's still included in toSet for batch-level filtering
+                    // Filtered properties are marked as ignored
                     expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })
                     expect(mockPersonProfileUpdateOutcomeCounter.labels({ outcome: 'ignored' }).inc).toHaveBeenCalled()
                     expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({
@@ -250,54 +249,54 @@ describe('person-update', () => {
                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })
             })
 
-            it('should accept eventToPersonProperties even when mixed with unchanged custom properties', () => {
+            it('should accept filtered properties even when mixed with unchanged custom properties', () => {
                 const event: PluginEvent = {
                     event: 'pageview',
                     properties: {
-                        $set: { $browser: 'Chrome', custom_prop: 'same_value' },
+                        $set: { $current_url: 'https://example.com/new', custom_prop: 'same_value' },
                     },
                 } as any
 
-                const personProperties = { $browser: 'Firefox', custom_prop: 'same_value' }
+                const personProperties = { $current_url: 'https://example.com/old', custom_prop: 'same_value' }
 
                 const result = computeEventPropertyUpdates(event, personProperties)
 
                 expect(result.hasChanges).toBe(true)
-                expect(result.toSet).toEqual({ $browser: 'Chrome' })
+                expect(result.toSet).toEqual({ $current_url: 'https://example.com/new' })
                 expect(result.shouldForceUpdate).toBe(false)
-                // At event level, $browser would be marked as ignored
+                // $current_url is filtered, so it should be marked as ignored
                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })
                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({
-                    property: '$browser',
+                    property: '$current_url',
                 })
             })
 
-            it('should accept multiple eventToPersonProperties at event level', () => {
-                // Note: Campaign properties (utm_source, utm_campaign) are no longer in eventToPersonProperties
-                // and will trigger updates like custom properties
+            it('should accept multiple filtered properties at event level', () => {
                 const event: PluginEvent = {
                     event: 'pageview',
                     properties: {
                         $set: {
-                            $browser: 'Chrome',
-                            $os: 'macOS',
+                            $current_url: 'https://example.com/new',
+                            $pathname: '/new-path',
                         },
                     },
                 } as any
 
                 const personProperties = {
-                    $browser: 'Firefox',
-                    $os: 'Windows',
+                    $current_url: 'https://example.com/old',
+                    $pathname: '/old-path',
                 }
 
                 const result = computeEventPropertyUpdates(event, personProperties)
 
                 expect(result.hasChanges).toBe(true)
                 expect(result.shouldForceUpdate).toBe(false)
-                // At event level, eventToPersonProperties would be marked as ignored
+                // Filtered properties should be marked as ignored
                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })
-                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$browser' })
-                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$os' })
+                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({
+                    property: '$current_url',
+                })
+                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$pathname' })
             })
         })
 
@@ -376,7 +375,7 @@ describe('person-update', () => {
         })
 
         describe('person events behavior', () => {
-            it('should compute updates for eventToPersonProperties on $identify events', () => {
+            it('should compute updates for any property on $identify events', () => {
                 const event: PluginEvent = {
                     event: '$identify',
                     properties: {
@@ -394,7 +393,7 @@ describe('person-update', () => {
                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })
             })
 
-            it('should compute updates for eventToPersonProperties on $set events', () => {
+            it('should compute updates for any property on $set events', () => {
                 const event: PluginEvent = {
                     event: '$set',
                     properties: {
@@ -466,7 +465,7 @@ describe('person-update', () => {
         })
 
         describe('mixed scenarios', () => {
-            it('should compute updates when both custom and eventToPersonProperties change', () => {
+            it('should compute updates when both custom and allowed properties change', () => {
                 const event: PluginEvent = {
                     event: 'pageview',
                     properties: {
@@ -486,8 +485,8 @@ describe('person-update', () => {
         })
 
         describe('updateAllProperties flag enabled', () => {
-            it.each(Array.from(eventToPersonProperties))(
-                'should trigger update for "%s" when updateAllProperties is true',
+            it.each(Array.from(FILTERED_PERSON_UPDATE_PROPERTIES))(
+                'should trigger update for filtered property "%s" when updateAllProperties is true',
                 (propertyName) => {
                     const event: PluginEvent = {
                         event: 'pageview',
@@ -529,7 +528,7 @@ describe('person-update', () => {
                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()
             })
 
-            it('should trigger update for multiple eventToPersonProperties when updateAllProperties is true', () => {
+            it('should trigger update for multiple allowed properties when updateAllProperties is true', () => {
                 const event: PluginEvent = {
                     event: 'pageview',
                     properties: {
@@ -555,7 +554,7 @@ describe('person-update', () => {
                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()
             })
 
-            it('should trigger update for mixed eventToPersonProperties and custom properties when updateAllProperties is true', () => {
+            it('should trigger update for mixed allowed and custom properties when updateAllProperties is true', () => {
                 const event: PluginEvent = {
                     event: 'pageview',
                     properties: {
@@ -575,7 +574,7 @@ describe('person-update', () => {
                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()
             })
 
-            it('should trigger update for mixed $geoip_* and eventToPersonProperties when updateAllProperties is true', () => {
+            it('should trigger update for mixed $geoip_* and allowed properties when updateAllProperties is true', () => {
                 const event: PluginEvent = {
                     event: 'pageview',
                     properties: {
diff --git a/plugin-server/src/worker/ingestion/persons/person-update.ts b/plugin-server/src/worker/ingestion/persons/person-update.ts
index 9b40787ff1928..1b2ebca4071e2 100644
--- a/plugin-server/src/worker/ingestion/persons/person-update.ts
+++ b/plugin-server/src/worker/ingestion/persons/person-update.ts
@@ -5,7 +5,11 @@ import { cloneObject } from '~/utils/utils'
 import { InternalPerson } from '../../../types'
 import { logger } from '../../../utils/logger'
 import { personProfileIgnoredPropertiesCounter, personProfileUpdateOutcomeCounter } from './metrics'
-import { eventToPersonProperties, initialEventToPersonProperties } from './person-property-utils'
+import {
+    eventToPersonProperties,
+    initialEventToPersonProperties,
+    isFilteredPersonUpdateProperty,
+} from './person-property-utils'
 
 export interface PropertyUpdates {
     toSet: Properties
@@ -19,10 +23,6 @@ export interface PropertyUpdates {
 const NO_PERSON_UPDATE_EVENTS = new Set(['$exception', '$$heatmap'])
 const PERSON_EVENTS = new Set(['$identify', '$create_alias', '$merge_dangerously', '$set'])
 
-// GeoIP properties that should still trigger person updates even when other geoip properties are blocked
-// These are commonly used for segmentation and are worth keeping up-to-date
-const ALLOWED_GEOIP_PROPERTIES = new Set(['$geoip_country_name', '$geoip_city_name'])
-
 // For tracking what property keys cause us to update persons
 // tracking all properties we add from the event, 'geoip' for '$geoip_*' or '$initial_geoip_*' and 'other' for anything outside of those
 export function getMetricKey(key: string): string {
@@ -173,27 +173,6 @@ export function applyEventPropertyUpdates(
     return [updatedPerson, updated]
 }
 
-/**
- * Determines if a property key should be filtered out from triggering person updates.
- * These are properties that change frequently but aren't valuable enough to update the person record for.
- *
- * This is the single source of truth for property filtering logic, used by both:
- * - Event-level processing (computeEventPropertyUpdates)
- * - Batch-level processing (getPersonUpdateOutcome in batch-writing-person-store)
- */
-export function isFilteredPersonPropertyKey(key: string): boolean {
-    // These are properties we add from the event and some change often, it's useless to update person always
-    if (eventToPersonProperties.has(key)) {
-        return true
-    }
-    // same as above, coming from GeoIP plugin
-    // but allow country and city updates as they're commonly used for segmentation
-    if (key.startsWith('$geoip_')) {
-        return !ALLOWED_GEOIP_PROPERTIES.has(key)
-    }
-    return false
-}
-
 // Minimize useless person updates by not overriding properties if it's not a person event and we added from the event
 // They will still show up for PoE as it's not removed from the event, we just don't update the person in PG anymore
 function shouldUpdatePersonIfOnlyChange(event: PluginEvent, key: string, updateAllProperties: boolean): boolean {
@@ -205,5 +184,5 @@ function shouldUpdatePersonIfOnlyChange(event: PluginEvent, key: string, updateA
         // for person events always update everything
         return true
     }
-    return !isFilteredPersonPropertyKey(key)
+    return !isFilteredPersonUpdateProperty(key)
 }
