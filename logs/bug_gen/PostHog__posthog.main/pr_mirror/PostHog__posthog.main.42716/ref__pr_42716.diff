diff --git a/products/logs/frontend/LogsScene.tsx b/products/logs/frontend/LogsScene.tsx
index 62d6a84b3fcb2..d48921c51a1f0 100644
--- a/products/logs/frontend/LogsScene.tsx
+++ b/products/logs/frontend/LogsScene.tsx
@@ -9,13 +9,11 @@ import {
     LemonSegmentedButton,
     LemonSelect,
     LemonTable,
-    SpinnerOverlay,
     Tooltip,
 } from '@posthog/lemon-ui'
 
 import { CopyToClipboardInline } from 'lib/components/CopyToClipboard'
 import { ProductIntroduction } from 'lib/components/ProductIntroduction/ProductIntroduction'
-import { Sparkline } from 'lib/components/Sparkline'
 import { TZLabel, TZLabelProps } from 'lib/components/TZLabel'
 import { ListHog } from 'lib/components/hedgehogs'
 import { FEATURE_FLAGS } from 'lib/constants'
@@ -36,6 +34,7 @@ import { LogMessage, ProductKey } from '~/queries/schema/schema-general'
 import { PropertyOperator } from '~/types'
 
 import { LogTag } from 'products/logs/frontend/components/LogTag'
+import { LogsSparkline } from 'products/logs/frontend/components/LogsSparkline'
 import { LogsTableRowActions } from 'products/logs/frontend/components/LogsTable/LogsTableRowActions'
 import { VirtualizedLogsList } from 'products/logs/frontend/components/VirtualizedLogsList'
 import { LogsFilterGroup } from 'products/logs/frontend/components/filters/LogsFilters/FilterGroup'
@@ -54,9 +53,8 @@ export const scene: SceneExport = {
 }
 
 export function LogsScene(): JSX.Element {
-    const { sparklineData, sparklineLoading, logsLoading } = useValues(logsLogic)
-    const { runQuery, setDateRangeFromSparkline, highlightNextLog, highlightPreviousLog, toggleExpandLog } =
-        useActions(logsLogic)
+    const { logsLoading } = useValues(logsLogic)
+    const { runQuery, highlightNextLog, highlightPreviousLog, toggleExpandLog } = useActions(logsLogic)
     const { highlightedLogId: sceneHighlightedLogId } = useValues(logsLogic)
 
     useEffect(() => {
@@ -81,10 +79,6 @@ export function LogsScene(): JSX.Element {
         [sceneHighlightedLogId, logsLoading, runQuery]
     )
 
-    const onSelectionChange = (selection: { startIndex: number; endIndex: number }): void => {
-        setDateRangeFromSparkline(selection.startIndex, selection.endIndex)
-    }
-
     return (
         <SceneContent>
             <SceneTitleSection
@@ -115,21 +109,7 @@ export function LogsScene(): JSX.Element {
                 isEmpty={false}
             />
             <Filters />
-            <div className="relative h-40 flex flex-col">
-                {sparklineData.data.length > 0 ? (
-                    <Sparkline
-                        labels={sparklineData.labels}
-                        data={sparklineData.data}
-                        className="w-full flex-1"
-                        onSelectionChange={onSelectionChange}
-                    />
-                ) : !sparklineLoading ? (
-                    <div className="flex-1 text-muted flex items-center justify-center">
-                        No results matching filters
-                    </div>
-                ) : null}
-                {sparklineLoading && <SpinnerOverlay />}
-            </div>
+            <LogsSparkline />
             <SceneDivider />
             <LogsListContainer />
         </SceneContent>
diff --git a/products/logs/frontend/components/LogsSparkline.tsx b/products/logs/frontend/components/LogsSparkline.tsx
new file mode 100644
index 0000000000000..0a75f25457f92
--- /dev/null
+++ b/products/logs/frontend/components/LogsSparkline.tsx
@@ -0,0 +1,142 @@
+import { useActions, useValues } from 'kea'
+import { useCallback, useMemo } from 'react'
+
+import { LemonSelect, SpinnerOverlay } from '@posthog/lemon-ui'
+
+import { AnyScaleOptions, Sparkline } from 'lib/components/Sparkline'
+import { dayjs } from 'lib/dayjs'
+import { shortTimeZone } from 'lib/utils'
+import { teamLogic } from 'scenes/teamLogic'
+
+import { SparklineTimezone, logsLogic } from '../logsLogic'
+
+export function LogsSparkline(): JSX.Element {
+    const { sparklineData, sparklineLoading, sparklineTimezone } = useValues(logsLogic)
+    const { setDateRangeFromSparkline, setSparklineTimezone } = useActions(logsLogic)
+    const { timezone: projectTimezone } = useValues(teamLogic)
+
+    const deviceTimezone = shortTimeZone()
+
+    // Determine which timezone string to use for formatting
+    const activeTimezone = useMemo(() => {
+        switch (sparklineTimezone) {
+            case SparklineTimezone.UTC:
+                return 'UTC'
+            case SparklineTimezone.Project:
+                return projectTimezone
+            case SparklineTimezone.Device:
+            default:
+                return undefined // undefined means local
+        }
+    }, [sparklineTimezone, projectTimezone])
+
+    // Build timezone options, deduplicating if any match
+    const timezoneOptions = useMemo(() => {
+        const options: { value: SparklineTimezone; label: string }[] = [{ value: SparklineTimezone.UTC, label: 'UTC' }]
+
+        const projectTzLabel = shortTimeZone(projectTimezone) ?? projectTimezone
+        if (projectTimezone !== 'UTC') {
+            options.push({ value: SparklineTimezone.Project, label: `Project (${projectTzLabel})` })
+        }
+
+        if (deviceTimezone && deviceTimezone !== 'UTC' && deviceTimezone !== projectTzLabel) {
+            options.push({ value: SparklineTimezone.Device, label: `Device (${deviceTimezone})` })
+        }
+
+        return options
+    }, [projectTimezone, deviceTimezone])
+
+    const showTimezoneSelector = timezoneOptions.length > 1
+
+    const { timeUnit, tickFormat } = useMemo(() => {
+        if (!sparklineData.dates.length) {
+            return { timeUnit: 'hour' as const, tickFormat: 'HH:mm:ss' }
+        }
+        const firstDate = dayjs(sparklineData.dates[0])
+        const lastDate = dayjs(sparklineData.dates[sparklineData.dates.length - 1])
+        const hoursDiff = lastDate.diff(firstDate, 'hours')
+
+        if (hoursDiff <= 1) {
+            return { timeUnit: 'second' as const, tickFormat: 'HH:mm:ss' }
+        } else if (hoursDiff <= 6) {
+            return { timeUnit: 'minute' as const, tickFormat: 'HH:mm:ss' }
+        } else if (hoursDiff <= 48) {
+            return { timeUnit: 'hour' as const, tickFormat: 'HH:mm' }
+        }
+        return { timeUnit: 'day' as const, tickFormat: 'D MMM HH:mm' }
+    }, [sparklineData.dates])
+
+    const withXScale = useCallback(
+        (scale: AnyScaleOptions): AnyScaleOptions => {
+            return {
+                ...scale,
+                type: 'timeseries',
+                ticks: {
+                    display: true,
+                    maxRotation: 0,
+                    maxTicksLimit: 6,
+                    font: {
+                        size: 10,
+                        lineHeight: 1,
+                    },
+                    callback: function (value: string | number) {
+                        const d = activeTimezone ? dayjs(value).tz(activeTimezone) : dayjs(value)
+                        return d.format(tickFormat)
+                    },
+                },
+                time: {
+                    unit: timeUnit,
+                },
+            } as AnyScaleOptions
+        },
+        [timeUnit, tickFormat, activeTimezone]
+    )
+
+    const renderLabel = useCallback(
+        (label: string): string => {
+            const d = activeTimezone ? dayjs(label).tz(activeTimezone) : dayjs(label)
+            const tz = activeTimezone === 'UTC' ? 'UTC' : (shortTimeZone(activeTimezone, d.toDate()) ?? 'Local')
+            return `${d.format('D MMM YYYY HH:mm:ss')} ${tz}`
+        },
+        [activeTimezone]
+    )
+
+    const sparklineLabels = useMemo(() => {
+        return sparklineData.dates.map((date) => dayjs(date).toISOString())
+    }, [sparklineData.dates])
+
+    const onSelectionChange = useCallback(
+        (selection: { startIndex: number; endIndex: number }): void => {
+            setDateRangeFromSparkline(selection.startIndex, selection.endIndex)
+        },
+        [setDateRangeFromSparkline]
+    )
+
+    return (
+        <div className="relative h-40 flex flex-col">
+            {showTimezoneSelector && (
+                <div className="absolute top-1 right-1 z-10">
+                    <LemonSelect
+                        size="xsmall"
+                        value={sparklineTimezone}
+                        onChange={(value) => value && setSparklineTimezone(value)}
+                        options={timezoneOptions}
+                    />
+                </div>
+            )}
+            {sparklineData.data.length > 0 ? (
+                <Sparkline
+                    labels={sparklineLabels}
+                    data={sparklineData.data}
+                    className="w-full flex-1"
+                    onSelectionChange={onSelectionChange}
+                    withXScale={withXScale}
+                    renderLabel={renderLabel}
+                />
+            ) : !sparklineLoading ? (
+                <div className="flex-1 text-muted flex items-center justify-center">No results matching filters</div>
+            ) : null}
+            {sparklineLoading && <SpinnerOverlay />}
+        </div>
+    )
+}
diff --git a/products/logs/frontend/logsLogic.test.ts b/products/logs/frontend/logsLogic.test.ts
index ff3d7aa8c9747..d8a6a00251a4a 100644
--- a/products/logs/frontend/logsLogic.test.ts
+++ b/products/logs/frontend/logsLogic.test.ts
@@ -3,7 +3,7 @@ import { expectLogic } from 'kea-test-utils'
 import { LogMessage } from '~/queries/schema/schema-general'
 import { initKeaTests } from '~/test/init'
 
-import { logsLogic } from './logsLogic'
+import { SparklineTimezone, logsLogic } from './logsLogic'
 
 const createMockLog = (uuid: string): LogMessage => ({
     uuid,
@@ -194,4 +194,24 @@ describe('logsLogic', () => {
             })
         })
     })
+
+    describe('sparklineTimezone', () => {
+        it('updates when setSparklineTimezone is called', async () => {
+            await expectLogic(logic, () => {
+                logic.actions.setSparklineTimezone(SparklineTimezone.Device)
+            })
+                .toDispatchActions(['setSparklineTimezone'])
+                .toMatchValues({
+                    sparklineTimezone: SparklineTimezone.Device,
+                })
+
+            await expectLogic(logic, () => {
+                logic.actions.setSparklineTimezone(SparklineTimezone.UTC)
+            })
+                .toDispatchActions(['setSparklineTimezone'])
+                .toMatchValues({
+                    sparklineTimezone: SparklineTimezone.UTC,
+                })
+        })
+    })
 })
diff --git a/products/logs/frontend/logsLogic.tsx b/products/logs/frontend/logsLogic.tsx
index 3260c948007fe..a0b377414b930 100644
--- a/products/logs/frontend/logsLogic.tsx
+++ b/products/logs/frontend/logsLogic.tsx
@@ -38,6 +38,12 @@ const NEW_QUERY_STARTED_ERROR_MESSAGE = 'new query started' as const
 const DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS = 1000
 const DEFAULT_LIVE_TAIL_POLL_INTERVAL_MAX_MS = 5000
 
+export enum SparklineTimezone {
+    UTC = 'utc',
+    Project = 'project',
+    Device = 'device',
+}
+
 const parseLogAttributes = (logs: LogMessage[]): void => {
     logs.forEach((row) => {
         Object.keys(row.attributes).forEach((key) => {
@@ -257,6 +263,7 @@ export const logsLogic = kea<logsLogicType>([
         expireLiveTail: () => true,
         setLiveTailExpired: (liveTailExpired: boolean) => ({ liveTailExpired }),
         addLogsToSparkline: (logs: LogMessage[]) => logs,
+        setSparklineTimezone: (sparklineTimezone: SparklineTimezone) => ({ sparklineTimezone }),
     }),
 
     reducers({
@@ -408,6 +415,13 @@ export const logsLogic = kea<logsLogicType>([
                 runQuery: () => false,
             },
         ],
+        sparklineTimezone: [
+            SparklineTimezone.UTC as SparklineTimezone,
+            { persist: true },
+            {
+                setSparklineTimezone: (_, { sparklineTimezone }) => sparklineTimezone,
+            },
+        ],
         liveTailPollInterval: [
             DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS as number,
             {
