{
    "cost": 0.37995500000000004,
    "rewrites": {
        "PostHog__posthog.main/products/logs/frontend/LogsScene.tsx": {
            "output": "import { useActions, useValues } from 'kea'\nimport { useEffect, useRef } from 'react'\n\nimport { IconFilter, IconMinusSquare, IconPin, IconPinFilled, IconPlusSquare, IconRefresh } from '@posthog/icons'\nimport {\n    LemonBanner,\n    LemonButton,\n    LemonCheckbox,\n    LemonSegmentedButton,\n    LemonSelect,\n    LemonTable,\n    SpinnerOverlay,\n    Tooltip,\n} from '@posthog/lemon-ui'\n\nimport { CopyToClipboardInline } from 'lib/components/CopyToClipboard'\nimport { ProductIntroduction } from 'lib/components/ProductIntroduction/ProductIntroduction'\nimport { Sparkline } from 'lib/components/Sparkline'\nimport { TZLabel, TZLabelProps } from 'lib/components/TZLabel'\nimport { ListHog } from 'lib/components/hedgehogs'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { useKeyboardHotkeys } from 'lib/hooks/useKeyboardHotkeys'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { IconPauseCircle, IconPlayCircle } from 'lib/lemon-ui/icons'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { humanFriendlyNumber } from 'lib/utils'\nimport { cn } from 'lib/utils/css-classes'\nimport { Scene, SceneExport } from 'scenes/sceneTypes'\nimport { sceneConfigurations } from 'scenes/scenes'\n\nimport { KeyboardShortcut } from '~/layout/navigation-3000/components/KeyboardShortcut'\nimport { SceneContent } from '~/layout/scenes/components/SceneContent'\nimport { SceneDivider } from '~/layout/scenes/components/SceneDivider'\nimport { SceneTitleSection } from '~/layout/scenes/components/SceneTitleSection'\nimport { LogMessage, ProductKey } from '~/queries/schema/schema-general'\nimport { PropertyOperator } from '~/types'\n\nimport { LogTag } from 'products/logs/frontend/components/LogTag'\nimport { LogsTableRowActions } from 'products/logs/frontend/components/LogsTable/LogsTableRowActions'\nimport { VirtualizedLogsList } from 'products/logs/frontend/components/VirtualizedLogsList'\nimport { LogsFilterGroup } from 'products/logs/frontend/components/filters/LogsFilters/FilterGroup'\n\nimport { AttributeBreakdowns } from './AttributeBreakdowns'\nimport { DateRangeFilter } from './filters/DateRangeFilter'\nimport { ServiceFilter } from './filters/ServiceFilter'\nimport { SeverityLevelsFilter } from './filters/SeverityLevelsFilter'\nimport { logsLogic } from './logsLogic'\nimport { ParsedLogMessage } from './types'\n\nexport const scene: SceneExport = {\n    component: LogsScene,\n    logic: logsLogic,\n    settingSectionId: 'product-logs',\n}\n\nexport function LogsScene(): JSX.Element {\n    const { sparklineData, sparklineLoading, logsLoading } = useValues(logsLogic)\n    const { runQuery, setDateRangeFromSparkline, highlightNextLog, highlightPreviousLog, toggleExpandLog } =\n        useActions(logsLogic)\n    const { highlightedLogId: sceneHighlightedLogId } = useValues(logsLogic)\n\n    useEffect(() => {\n        runQuery()\n    }, [runQuery])\n\n    useKeyboardHotkeys(\n        {\n            arrowdown: { action: highlightNextLog },\n            j: { action: highlightNextLog },\n            arrowup: { action: highlightPreviousLog },\n            k: { action: highlightPreviousLog },\n            enter: {\n                action: () => {\n                    if (sceneHighlightedLogId) {\n                        toggleExpandLog(sceneHighlightedLogId)\n                    }\n                },\n            },\n            r: { action: () => !logsLoading && runQuery() },\n        },\n        [sceneHighlightedLogId, logsLoading, runQuery]\n    )\n\n    const onSelectionChange = (selection: { startIndex: number; endIndex: number }): void => {\n        setDateRangeFromSparkline(selection.startIndex, selection.endIndex)\n    }\n\n    return (\n        <SceneContent>\n            <SceneTitleSection\n                name={sceneConfigurations[Scene.Logs].name}\n                description={sceneConfigurations[Scene.Logs].description}\n                resourceType={{\n                    type: sceneConfigurations[Scene.Logs].iconType || 'default_icon_type',\n                }}\n            />\n            <LemonBanner\n                type=\"warning\"\n                dismissKey=\"logs-beta-banner\"\n                action={{ children: 'Send feedback', id: 'logs-feedback-button' }}\n            >\n                <p>\n                    Logs is in beta and things will change as we figure out what works. Right now you have 7-day\n                    retention with ingestion rate limits. Tell us what you need, what's broken, or if you're hitting\n                    limits, we want to hear from you.\n                </p>\n            </LemonBanner>\n            <ProductIntroduction\n                productName=\"logs\"\n                productKey={ProductKey.LOGS}\n                thingName=\"log\"\n                description={sceneConfigurations[Scene.Logs].description ?? ''}\n                docsURL=\"https://posthog.com/docs/logs\"\n                customHog={ListHog}\n                isEmpty={false}\n            />\n            <Filters />\n            <div className=\"relative h-40 flex flex-col\">\n                {sparklineData.data.length > 0 ? (\n                    <Sparkline\n                        labels={sparklineData.labels}\n                        data={sparklineData.data}\n                        className=\"w-full flex-1\"\n                        onSelectionChange={onSelectionChange}\n                    />\n                ) : !sparklineLoading ? (\n                    <div className=\"flex-1 text-muted flex items-center justify-center\">\n                        No results matching filters\n                    </div>\n                ) : null}\n                {sparklineLoading && <SpinnerOverlay />}\n            </div>\n            <SceneDivider />\n            <LogsListContainer />\n        </SceneContent>\n    )\n}\n\nconst LogsListContainer = (): JSX.Element => {\n    const { featureFlags } = useValues(featureFlagLogic)\n    const useVirtualizedList = !!featureFlags[FEATURE_FLAGS.LOGS_VIRTUALIZED_LIST]\n    return useVirtualizedList ? <VirtualizedLogsListLogs /> : <LemonTableLogs />\n}\n\nconst LemonTableLogs = (): JSX.Element => {\n    const {\n        wrapBody,\n        prettifyJson,\n        pinnedParsedLogs,\n        parsedLogs,\n        logsLoading,\n        isPinned,\n        hasMoreLogsToLoad,\n        logsPageSize,\n        logsRemainingToLoad,\n    } = useValues(logsLogic)\n\n    const { fetchNextLogsPage } = useActions(logsLogic)\n\n    const tzLabelFormat: Pick<TZLabelProps, 'formatDate' | 'formatTime'> = {\n        formatDate: 'YYYY-MM-DD',\n        formatTime: 'HH:mm:ss.SSS',\n    }\n\n    return (\n        <div>\n            <div className=\"sticky top-[calc(var(--breadcrumbs-height-compact)+var(--scene-title-section-height)-3px)] z-20 bg-primary pt-2\">\n                <div className=\"pb-2\">\n                    <DisplayOptions />\n                </div>\n                {pinnedParsedLogs.length > 0 && (\n                    <div className=\"border rounded-t bg-bg-light shadow-sm\">\n                        <LogsTable\n                            dataSource={pinnedParsedLogs}\n                            loading={false}\n                            isPinned={isPinned}\n                            wrapBody={wrapBody}\n                            prettifyJson={prettifyJson}\n                            tzLabelFormat={tzLabelFormat}\n                        />\n                    </div>\n                )}\n            </div>\n            <div className={cn('flex-1 border bg-bg-light', pinnedParsedLogs.length > 0 ? 'rounded-b' : 'rounded')}>\n                <LogsTable\n                    showHeader={!pinnedParsedLogs.length}\n                    dataSource={parsedLogs}\n                    loading={logsLoading}\n                    isPinned={isPinned}\n                    wrapBody={wrapBody}\n                    prettifyJson={prettifyJson}\n                    tzLabelFormat={tzLabelFormat}\n                    showPinnedWithOpacity\n                />\n                {parsedLogs.length > 0 && (\n                    <div className=\"m-2 flex items-center\">\n                        <LemonButton\n                            onClick={() => fetchNextLogsPage()}\n                            loading={logsLoading}\n                            fullWidth\n                            center\n                            disabled={!hasMoreLogsToLoad || logsLoading}\n                        >\n                            {logsLoading\n                                ? 'Loading more logs...'\n                                : hasMoreLogsToLoad\n                                  ? `Click to load ${humanFriendlyNumber(Math.min(logsPageSize, logsRemainingToLoad))} more`\n                                  : `Showing all ${humanFriendlyNumber(parsedLogs.length)} logs`}\n                        </LemonButton>\n                    </div>\n                )}\n            </div>\n        </div>\n    )\n}\n\nconst VirtualizedLogsListLogs = (): JSX.Element => {\n    const { wrapBody, prettifyJson, pinnedParsedLogs, parsedLogs, logsLoading, isPinned } = useValues(logsLogic)\n\n    const tzLabelFormat: Pick<TZLabelProps, 'formatDate' | 'formatTime'> = {\n        formatDate: 'YYYY-MM-DD',\n        formatTime: 'HH:mm:ss.SSS',\n    }\n\n    return (\n        <div className=\"flex flex-col gap-2 py-2 h-[calc(100vh_-_var(--breadcrumbs-height-compact,_0px)_-_var(--scene-title-section-height,_0px)_-_5px)]\">\n            <div className=\"sticky top-0 z-20 py-2\">\n                <VirtualizedLogsListDisplayOptions />\n            </div>\n            {pinnedParsedLogs.length > 0 && (\n                <div className=\"border rounded-t bg-bg-light shadow-sm\">\n                    <VirtualizedLogsList\n                        dataSource={pinnedParsedLogs}\n                        loading={false}\n                        isPinned={isPinned}\n                        wrapBody={wrapBody}\n                        prettifyJson={prettifyJson}\n                        tzLabelFormat={tzLabelFormat}\n                        showPinnedWithOpacity\n                        fixedHeight={250}\n                        disableInfiniteScroll\n                    />\n                </div>\n            )}\n            <div\n                className={cn(\n                    'border bg-bg-light flex-1 min-h-0',\n                    pinnedParsedLogs.length > 0 ? 'rounded-b' : 'rounded'\n                )}\n            >\n                <VirtualizedLogsList\n                    dataSource={parsedLogs}\n                    loading={logsLoading}\n                    isPinned={isPinned}\n                    wrapBody={wrapBody}\n                    prettifyJson={prettifyJson}\n                    tzLabelFormat={tzLabelFormat}\n                    showPinnedWithOpacity\n                />\n            </div>\n        </div>\n    )\n}\n\ninterface LogsTableProps {\n    dataSource: ParsedLogMessage[]\n    loading: boolean\n    isPinned: (uuid: string) => boolean\n    wrapBody: boolean\n    prettifyJson: boolean\n    tzLabelFormat: Pick<TZLabelProps, 'formatDate' | 'formatTime'>\n    showPinnedWithOpacity?: boolean\n    showHeader?: boolean\n}\n\nfunction LogsTable({\n    dataSource,\n    loading,\n    isPinned,\n    wrapBody,\n    prettifyJson,\n    tzLabelFormat,\n    showPinnedWithOpacity = false,\n    showHeader = true,\n}: LogsTableProps): JSX.Element {\n    const { togglePinLog, setHighlightedLogId, toggleExpandLog } = useActions(logsLogic)\n    const { highlightedLogId, expandedLogIds } = useValues(logsLogic)\n    const tableRef = useRef<HTMLDivElement>(null)\n\n    useEffect(() => {\n        if (!loading && highlightedLogId && tableRef.current) {\n            requestAnimationFrame(() => {\n                const highlightedRow = tableRef.current?.querySelector(`[data-row-key=\"${highlightedLogId}\"]`)\n                if (highlightedRow) {\n                    highlightedRow.scrollIntoView({ behavior: 'smooth', block: 'center' })\n                }\n            })\n        }\n    }, [loading, highlightedLogId])\n\n    return (\n        <div ref={tableRef}>\n            <LemonTable\n                hideScrollbar\n                showHeader={showHeader}\n                dataSource={dataSource}\n                loading={loading}\n                size=\"small\"\n                embedded\n                rowKey=\"uuid\"\n                rowStatus={(record) =>\n                    record.uuid === highlightedLogId ? 'highlighted' : record.new ? 'highlight-new' : null\n                }\n                rowClassName={(record) =>\n                    isPinned(record.uuid) ? cn('bg-primary-highlight', showPinnedWithOpacity && 'opacity-50') : 'group'\n                }\n                columns={[\n                    {\n                        title: '#',\n                        key: 'row_number',\n                        width: 0,\n                        className: 'relative',\n                        render: (_, record, index) => {\n                            const isHighlighted = record.uuid === highlightedLogId\n                            return (\n                                <Tooltip title=\"Click to highlight (\u2191\u2193 or j/k to navigate, Enter to expand)\">\n                                    <button\n                                        type=\"button\"\n                                        onClick={() => setHighlightedLogId(isHighlighted ? null : record.uuid)}\n                                        className=\"absolute inset-0 cursor-pointer\"\n                                    />\n                                    <span\n                                        className={cn(\n                                            'font-mono text-xs pointer-events-none transition-colors',\n                                            isPinned(record.uuid) ? 'opacity-0' : '',\n                                            isHighlighted ? 'text-primary font-semibold' : 'text-muted'\n                                        )}\n                                    >\n                                        {index + 1}\n                                    </span>\n                                </Tooltip>\n                            )\n                        },\n                    },\n                    {\n                        title: '',\n                        key: 'actions',\n                        width: 0,\n                        render: (_, record) => {\n                            const pinned = isPinned(record.uuid)\n                            return (\n                                <div className=\"flex items-center gap-1\">\n                                    <LemonButton\n                                        size=\"xsmall\"\n                                        noPadding\n                                        icon={pinned ? <IconPinFilled /> : <IconPin />}\n                                        onClick={() => togglePinLog(record.uuid)}\n                                        tooltip={pinned ? 'Unpin log' : 'Pin log'}\n                                        className={cn(\n                                            'transition-opacity',\n                                            pinned\n                                                ? 'text-primary opacity-100'\n                                                : 'text-muted opacity-0 group-hover:opacity-100'\n                                        )}",
            "output_extracted": "import { useActions, useValues } from 'kea'\nimport { useEffect, useRef } from 'react'\n\nimport { IconFilter, IconMinusSquare, IconPin, IconPinFilled, IconPlusSquare, IconRefresh } from '@posthog/icons'\nimport {\n    LemonBanner,\n    LemonButton,\n    LemonCheckbox,\n    LemonSegmentedButton,\n    LemonSelect,\n    LemonTable,\n    SpinnerOverlay,\n    Tooltip,\n} from '@posthog/lemon-ui'\n\nimport { CopyToClipboardInline } from 'lib/components/CopyToClipboard'\nimport { ProductIntroduction } from 'lib/components/ProductIntroduction/ProductIntroduction'\nimport { Sparkline } from 'lib/components/Sparkline'\nimport { TZLabel, TZLabelProps } from 'lib/components/TZLabel'\nimport { ListHog } from 'lib/components/hedgehogs'\nimport { FEATURE_FLAGS } from 'lib/constants'\nimport { useKeyboardHotkeys } from 'lib/hooks/useKeyboardHotkeys'\nimport { LemonField } from 'lib/lemon-ui/LemonField'\nimport { IconPauseCircle, IconPlayCircle } from 'lib/lemon-ui/icons'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { humanFriendlyNumber } from 'lib/utils'\nimport { cn } from 'lib/utils/css-classes'\nimport { Scene, SceneExport } from 'scenes/sceneTypes'\nimport { sceneConfigurations } from 'scenes/scenes'\n\nimport { KeyboardShortcut } from '~/layout/navigation-3000/components/KeyboardShortcut'\nimport { SceneContent } from '~/layout/scenes/components/SceneContent'\nimport { SceneDivider } from '~/layout/scenes/components/SceneDivider'\nimport { SceneTitleSection } from '~/layout/scenes/components/SceneTitleSection'\nimport { LogMessage, ProductKey } from '~/queries/schema/schema-general'\nimport { PropertyOperator } from '~/types'\n\nimport { LogTag } from 'products/logs/frontend/components/LogTag'\nimport { LogsTableRowActions } from 'products/logs/frontend/components/LogsTable/LogsTableRowActions'\nimport { VirtualizedLogsList } from 'products/logs/frontend/components/VirtualizedLogsList'\nimport { LogsFilterGroup } from 'products/logs/frontend/components/filters/LogsFilters/FilterGroup'\n\nimport { AttributeBreakdowns } from './AttributeBreakdowns'\nimport { DateRangeFilter } from './filters/DateRangeFilter'\nimport { ServiceFilter } from './filters/ServiceFilter'\nimport { SeverityLevelsFilter } from './filters/SeverityLevelsFilter'\nimport { logsLogic } from './logsLogic'\nimport { ParsedLogMessage } from './types'\n\nexport const scene: SceneExport = {\n    component: LogsScene,\n    logic: logsLogic,\n    settingSectionId: 'product-logs',\n}\n\nexport function LogsScene(): JSX.Element {\n    const { sparklineData, sparklineLoading, logsLoading } = useValues(logsLogic)\n    const { runQuery, setDateRangeFromSparkline, highlightNextLog, highlightPreviousLog, toggleExpandLog } =\n        useActions(logsLogic)\n    const { highlightedLogId: sceneHighlightedLogId } = useValues(logsLogic)\n\n    useEffect(() => {\n        runQuery()\n    }, [runQuery])\n\n    useKeyboardHotkeys(\n        {\n            arrowdown: { action: highlightNextLog },\n            j: { action: highlightNextLog },\n            arrowup: { action: highlightPreviousLog },\n            k: { action: highlightPreviousLog },\n            enter: {\n                action: () => {\n                    if (sceneHighlightedLogId) {\n                        toggleExpandLog(sceneHighlightedLogId)\n                    }\n                },\n            },\n            r: { action: () => !logsLoading && runQuery() },\n        },\n        [sceneHighlightedLogId, logsLoading, runQuery]\n    )\n\n    const onSelectionChange = (selection: { startIndex: number; endIndex: number }): void => {\n        setDateRangeFromSparkline(selection.startIndex, selection.endIndex)\n    }\n\n    return (\n        <SceneContent>\n            <SceneTitleSection\n                name={sceneConfigurations[Scene.Logs].name}\n                description={sceneConfigurations[Scene.Logs].description}\n                resourceType={{\n                    type: sceneConfigurations[Scene.Logs].iconType || 'default_icon_type',\n                }}\n            />\n            <LemonBanner\n                type=\"warning\"\n                dismissKey=\"logs-beta-banner\"\n                action={{ children: 'Send feedback', id: 'logs-feedback-button' }}\n            >\n                <p>\n                    Logs is in beta and things will change as we figure out what works. Right now you have 7-day\n                    retention with ingestion rate limits. Tell us what you need, what's broken, or if you're hitting\n                    limits, we want to hear from you.\n                </p>\n            </LemonBanner>\n            <ProductIntroduction\n                productName=\"logs\"\n                productKey={ProductKey.LOGS}\n                thingName=\"log\"\n                description={sceneConfigurations[Scene.Logs].description ?? ''}\n                docsURL=\"https://posthog.com/docs/logs\"\n                customHog={ListHog}\n                isEmpty={false}\n            />\n            <Filters />\n            <div className=\"relative h-40 flex flex-col\">\n                {sparklineData.data.length > 0 ? (\n                    <Sparkline\n                        labels={sparklineData.labels}\n                        data={sparklineData.data}\n                        className=\"w-full flex-1\"\n                        onSelectionChange={onSelectionChange}\n                    />\n                ) : !sparklineLoading ? (\n                    <div className=\"flex-1 text-muted flex items-center justify-center\">\n                        No results matching filters\n                    </div>\n                ) : null}\n                {sparklineLoading && <SpinnerOverlay />}\n            </div>\n            <SceneDivider />\n            <LogsListContainer />\n        </SceneContent>\n    )\n}\n\nconst LogsListContainer = (): JSX.Element => {\n    const { featureFlags } = useValues(featureFlagLogic)\n    const useVirtualizedList = !!featureFlags[FEATURE_FLAGS.LOGS_VIRTUALIZED_LIST]\n    return useVirtualizedList ? <VirtualizedLogsListLogs /> : <LemonTableLogs />\n}\n\nconst LemonTableLogs = (): JSX.Element => {\n    const {\n        wrapBody,\n        prettifyJson,\n        pinnedParsedLogs,\n        parsedLogs,\n        logsLoading,\n        isPinned,\n        hasMoreLogsToLoad,\n        logsPageSize,\n        logsRemainingToLoad,\n    } = useValues(logsLogic)\n\n    const { fetchNextLogsPage } = useActions(logsLogic)\n\n    const tzLabelFormat: Pick<TZLabelProps, 'formatDate' | 'formatTime'> = {\n        formatDate: 'YYYY-MM-DD',\n        formatTime: 'HH:mm:ss.SSS',\n    }\n\n    return (\n        <div>\n            <div className=\"sticky top-[calc(var(--breadcrumbs-height-compact)+var(--scene-title-section-height)-3px)] z-20 bg-primary pt-2\">\n                <div className=\"pb-2\">\n                    <DisplayOptions />\n                </div>\n                {pinnedParsedLogs.length > 0 && (\n                    <div className=\"border rounded-t bg-bg-light shadow-sm\">\n                        <LogsTable\n                            dataSource={pinnedParsedLogs}\n                            loading={false}\n                            isPinned={isPinned}\n                            wrapBody={wrapBody}\n                            prettifyJson={prettifyJson}\n                            tzLabelFormat={tzLabelFormat}\n                        />\n                    </div>\n                )}\n            </div>\n            <div className={cn('flex-1 border bg-bg-light', pinnedParsedLogs.length > 0 ? 'rounded-b' : 'rounded')}>\n                <LogsTable\n                    showHeader={!pinnedParsedLogs.length}\n                    dataSource={parsedLogs}\n                    loading={logsLoading}\n                    isPinned={isPinned}\n                    wrapBody={wrapBody}\n                    prettifyJson={prettifyJson}\n                    tzLabelFormat={tzLabelFormat}\n                    showPinnedWithOpacity\n                />\n                {parsedLogs.length > 0 && (\n                    <div className=\"m-2 flex items-center\">\n                        <LemonButton\n                            onClick={() => fetchNextLogsPage()}\n                            loading={logsLoading}\n                            fullWidth\n                            center\n                            disabled={!hasMoreLogsToLoad || logsLoading}\n                        >\n                            {logsLoading\n                                ? 'Loading more logs...'\n                                : hasMoreLogsToLoad\n                                  ? `Click to load ${humanFriendlyNumber(Math.min(logsPageSize, logsRemainingToLoad))} more`\n                                  : `Showing all ${humanFriendlyNumber(parsedLogs.length)} logs`}\n                        </LemonButton>\n                    </div>\n                )}\n            </div>\n        </div>\n    )\n}\n\nconst VirtualizedLogsListLogs = (): JSX.Element => {\n    const { wrapBody, prettifyJson, pinnedParsedLogs, parsedLogs, logsLoading, isPinned } = useValues(logsLogic)\n\n    const tzLabelFormat: Pick<TZLabelProps, 'formatDate' | 'formatTime'> = {\n        formatDate: 'YYYY-MM-DD',\n        formatTime: 'HH:mm:ss.SSS',\n    }\n\n    return (\n        <div className=\"flex flex-col gap-2 py-2 h-[calc(100vh_-_var(--breadcrumbs-height-compact,_0px)_-_var(--scene-title-section-height,_0px)_-_5px)]\">\n            <div className=\"sticky top-0 z-20 py-2\">\n                <VirtualizedLogsListDisplayOptions />\n            </div>\n            {pinnedParsedLogs.length > 0 && (\n                <div className=\"border rounded-t bg-bg-light shadow-sm\">\n                    <VirtualizedLogsList\n                        dataSource={pinnedParsedLogs}\n                        loading={false}\n                        isPinned={isPinned}\n                        wrapBody={wrapBody}\n                        prettifyJson={prettifyJson}\n                        tzLabelFormat={tzLabelFormat}\n                        showPinnedWithOpacity\n                        fixedHeight={250}\n                        disableInfiniteScroll\n                    />\n                </div>\n            )}\n            <div\n                className={cn(\n                    'border bg-bg-light flex-1 min-h-0',\n                    pinnedParsedLogs.length > 0 ? 'rounded-b' : 'rounded'\n                )}\n            >\n                <VirtualizedLogsList\n                    dataSource={parsedLogs}\n                    loading={logsLoading}\n                    isPinned={isPinned}\n                    wrapBody={wrapBody}\n                    prettifyJson={prettifyJson}\n                    tzLabelFormat={tzLabelFormat}\n                    showPinnedWithOpacity\n                />\n            </div>\n        </div>\n    )\n}\n\ninterface LogsTableProps {\n    dataSource: ParsedLogMessage[]\n    loading: boolean\n    isPinned: (uuid: string) => boolean\n    wrapBody: boolean\n    prettifyJson: boolean\n    tzLabelFormat: Pick<TZLabelProps, 'formatDate' | 'formatTime'>\n    showPinnedWithOpacity?: boolean\n    showHeader?: boolean\n}\n\nfunction LogsTable({\n    dataSource,\n    loading,\n    isPinned,\n    wrapBody,\n    prettifyJson,\n    tzLabelFormat,\n    showPinnedWithOpacity = false,\n    showHeader = true,\n}: LogsTableProps): JSX.Element {\n    const { togglePinLog, setHighlightedLogId, toggleExpandLog } = useActions(logsLogic)\n    const { highlightedLogId, expandedLogIds } = useValues(logsLogic)\n    const tableRef = useRef<HTMLDivElement>(null)\n\n    useEffect(() => {\n        if (!loading && highlightedLogId && tableRef.current) {\n            requestAnimationFrame(() => {\n                const highlightedRow = tableRef.current?.querySelector(`[data-row-key=\"${highlightedLogId}\"]`)\n                if (highlightedRow) {\n                    highlightedRow.scrollIntoView({ behavior: 'smooth', block: 'center' })\n                }\n            })\n        }\n    }, [loading, highlightedLogId])\n\n    return (\n        <div ref={tableRef}>\n            <LemonTable\n                hideScrollbar\n                showHeader={showHeader}\n                dataSource={dataSource}\n                loading={loading}\n                size=\"small\"\n                embedded\n                rowKey=\"uuid\"\n                rowStatus={(record) =>\n                    record.uuid === highlightedLogId ? 'highlighted' : record.new ? 'highlight-new' : null\n                }\n                rowClassName={(record) =>\n                    isPinned(record.uuid) ? cn('bg-primary-highlight', showPinnedWithOpacity && 'opacity-50') : 'group'\n                }\n                columns={[\n                    {\n                        title: '#',\n                        key: 'row_number',\n                        width: 0,\n                        className: 'relative',\n                        render: (_, record, index) => {\n                            const isHighlighted = record.uuid === highlightedLogId\n                            return (\n                                <Tooltip title=\"Click to highlight (\u2191\u2193 or j/k to navigate, Enter to expand)\">\n                                    <button\n                                        type=\"button\"\n                                        onClick={() => setHighlightedLogId(isHighlighted ? null : record.uuid)}\n                                        className=\"absolute inset-0 cursor-pointer\"\n                                    />\n                                    <span\n                                        className={cn(\n                                            'font-mono text-xs pointer-events-none transition-colors',\n                                            isPinned(record.uuid) ? 'opacity-0' : '',\n                                            isHighlighted ? 'text-primary font-semibold' : 'text-muted'\n                                        )}\n                                    >\n                                        {index + 1}\n                                    </span>\n                                </Tooltip>\n                            )\n                        },\n                    },\n                    {\n                        title: '',\n                        key: 'actions',\n                        width: 0,\n                        render: (_, record) => {\n                            const pinned = isPinned(record.uuid)\n                            return (\n                                <div className=\"flex items-center gap-1\">\n                                    <LemonButton\n                                        size=\"xsmall\"\n                                        noPadding\n                                        icon={pinned ? <IconPinFilled /> : <IconPin />}\n                                        onClick={() => togglePinLog(record.uuid)}\n                                        tooltip={pinned ? 'Unpin log' : 'Pin log'}\n                                        className={cn(\n                                            'transition-opacity',\n                                            pinned\n                                                ? 'text-primary opacity-100'\n                                                : 'text-muted opacity-0 group-hover:opacity-100'\n                                        )}",
            "cost": 0.14566500000000002
        },
        "PostHog__posthog.main/products/logs/frontend/logsLogic.test.ts": {
            "output": "import { expectLogic } from 'kea-test-utils'\n\nimport { LogMessage } from '~/queries/schema/schema-general'\nimport { initKeaTests } from '~/test/init'\n\nimport { logsLogic } from './logsLogic'\n\nconst createMockLog = (uuid: string): LogMessage => ({\n    uuid,\n    trace_id: 'trace-1',\n    span_id: 'span-1',\n    body: `Log ${uuid}`,\n    attributes: {},\n    timestamp: '2024-01-01T00:00:00Z',\n    observed_timestamp: '2024-01-01T00:00:00Z',\n    severity_text: 'info',\n    severity_number: 9,\n    level: 'info',\n    resource_attributes: {},\n    instrumentation_scope: 'test',\n    event_name: 'log',\n})\n\ndescribe('logsLogic', () => {\n    let logic: ReturnType<typeof logsLogic.build>\n\n    beforeEach(() => {\n        initKeaTests()\n        logic = logsLogic({ tabId: 'test-tab' })\n        logic.mount()\n    })\n\n    afterEach(() => {\n        logic.unmount()\n    })\n\n    describe('keyboard navigation', () => {\n        const mockLogs = [createMockLog('log-1'), createMockLog('log-2'), createMockLog('log-3')]\n\n        describe('highlightNextLog', () => {\n            it('highlights first log when none is highlighted', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightNextLog()\n                })\n                    .toDispatchActions(['highlightNextLog', 'setHighlightedLogId'])\n                    .toMatchValues({\n                        highlightedLogId: 'log-1',\n                    })\n            })\n\n            it('highlights next log in sequence', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                logic.actions.setHighlightedLogId('log-1')\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightNextLog()\n                })\n                    .toDispatchActions(['highlightNextLog', 'setHighlightedLogId'])\n                    .toMatchValues({\n                        highlightedLogId: 'log-2',\n                    })\n            })\n\n            it('loads more logs when at last log and more available', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                logic.actions.setHighlightedLogId('log-3')\n                logic.actions.setHasMoreLogsToLoad(true)\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightNextLog()\n                }).toDispatchActions(['highlightNextLog', 'fetchNextLogsPage'])\n            })\n\n            it('does nothing when at last log and no more to load', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                logic.actions.setHighlightedLogId('log-3')\n                logic.actions.setHasMoreLogsToLoad(false)\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightNextLog()\n                })\n                    .toDispatchActions(['highlightNextLog'])\n                    .toNotHaveDispatchedActions(['setHighlightedLogId', 'fetchNextLogsPage'])\n            })\n\n            it('does nothing when logs are empty', async () => {\n                logic.actions.fetchLogsSuccess([])\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightNextLog()\n                })\n                    .toDispatchActions(['highlightNextLog'])\n                    .toNotHaveDispatchedActions(['setHighlightedLogId'])\n            })\n        })\n\n        describe('highlightPreviousLog', () => {\n            it('highlights last log when none is highlighted', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightPreviousLog()\n                })\n                    .toDispatchActions(['highlightPreviousLog', 'setHighlightedLogId'])\n                    .toMatchValues({\n                        highlightedLogId: 'log-3',\n                    })\n            })\n\n            it('highlights previous log in sequence', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                logic.actions.setHighlightedLogId('log-2')\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightPreviousLog()\n                })\n                    .toDispatchActions(['highlightPreviousLog', 'setHighlightedLogId'])\n                    .toMatchValues({\n                        highlightedLogId: 'log-1',\n                    })\n            })\n\n            it('does nothing when at first log', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                logic.actions.setHighlightedLogId('log-1')\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightPreviousLog()\n                })\n                    .toDispatchActions(['highlightPreviousLog'])\n                    .toNotHaveDispatchedActions(['setHighlightedLogId'])\n            })\n\n            it('does nothing when logs are empty', async () => {\n                logic.actions.fetchLogsSuccess([])\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightPreviousLog()\n                })\n                    .toDispatchActions(['highlightPreviousLog'])\n                    .toNotHaveDispatchedActions(['setHighlightedLogId'])\n            })\n        })\n\n        describe('toggleExpandLog', () => {\n            it('expands a log when not expanded', async () => {\n                await expectLogic(logic, () => {\n                    logic.actions.toggleExpandLog('log-1')\n                }).toDispatchActions(['toggleExpandLog'])\n\n                expect(logic.values.expandedLogIds.has('log-1')).toBe(true)\n            })\n\n            it('collapses a log when already expanded', async () => {\n                logic.actions.toggleExpandLog('log-1')\n                await expectLogic(logic).toFinishAllListeners()\n\n                expect(logic.values.expandedLogIds.has('log-1')).toBe(true)\n\n                await expectLogic(logic, () => {\n                    logic.actions.toggleExpandLog('log-1')\n                }).toDispatchActions(['toggleExpandLog'])\n\n                expect(logic.values.expandedLogIds.has('log-1')).toBe(false)\n            })\n\n            it('supports multiple expanded logs', async () => {\n                logic.actions.toggleExpandLog('log-1')\n                logic.actions.toggleExpandLog('log-2')\n                logic.actions.toggleExpandLog('log-3')\n                await expectLogic(logic).toFinishAllListeners()\n\n                expect(logic.values.expandedLogIds.has('log-1')).toBe(true)\n                expect(logic.values.expandedLogIds.has('log-2')).toBe(true)\n                expect(logic.values.expandedLogIds.has('log-3')).toBe(true)\n\n                logic.actions.toggleExpandLog('log-2')\n                await expectLogic(logic).toFinishAllListeners()\n\n                expect(logic.values.expandedLogIds.has('log-1')).toBe(true)\n                expect(logic.values.expandedLogIds.has('log-2')).toBe(false)\n                expect(logic.values.expandedLogIds.has('log-3')).toBe(true)\n            })\n        })\n    })\n})",
            "output_extracted": "import { expectLogic } from 'kea-test-utils'\n\nimport { LogMessage } from '~/queries/schema/schema-general'\nimport { initKeaTests } from '~/test/init'\n\nimport { logsLogic } from './logsLogic'\n\nconst createMockLog = (uuid: string): LogMessage => ({\n    uuid,\n    trace_id: 'trace-1',\n    span_id: 'span-1',\n    body: `Log ${uuid}`,\n    attributes: {},\n    timestamp: '2024-01-01T00:00:00Z',\n    observed_timestamp: '2024-01-01T00:00:00Z',\n    severity_text: 'info',\n    severity_number: 9,\n    level: 'info',\n    resource_attributes: {},\n    instrumentation_scope: 'test',\n    event_name: 'log',\n})\n\ndescribe('logsLogic', () => {\n    let logic: ReturnType<typeof logsLogic.build>\n\n    beforeEach(() => {\n        initKeaTests()\n        logic = logsLogic({ tabId: 'test-tab' })\n        logic.mount()\n    })\n\n    afterEach(() => {\n        logic.unmount()\n    })\n\n    describe('keyboard navigation', () => {\n        const mockLogs = [createMockLog('log-1'), createMockLog('log-2'), createMockLog('log-3')]\n\n        describe('highlightNextLog', () => {\n            it('highlights first log when none is highlighted', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightNextLog()\n                })\n                    .toDispatchActions(['highlightNextLog', 'setHighlightedLogId'])\n                    .toMatchValues({\n                        highlightedLogId: 'log-1',\n                    })\n            })\n\n            it('highlights next log in sequence', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                logic.actions.setHighlightedLogId('log-1')\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightNextLog()\n                })\n                    .toDispatchActions(['highlightNextLog', 'setHighlightedLogId'])\n                    .toMatchValues({\n                        highlightedLogId: 'log-2',\n                    })\n            })\n\n            it('loads more logs when at last log and more available', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                logic.actions.setHighlightedLogId('log-3')\n                logic.actions.setHasMoreLogsToLoad(true)\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightNextLog()\n                }).toDispatchActions(['highlightNextLog', 'fetchNextLogsPage'])\n            })\n\n            it('does nothing when at last log and no more to load', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                logic.actions.setHighlightedLogId('log-3')\n                logic.actions.setHasMoreLogsToLoad(false)\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightNextLog()\n                })\n                    .toDispatchActions(['highlightNextLog'])\n                    .toNotHaveDispatchedActions(['setHighlightedLogId', 'fetchNextLogsPage'])\n            })\n\n            it('does nothing when logs are empty', async () => {\n                logic.actions.fetchLogsSuccess([])\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightNextLog()\n                })\n                    .toDispatchActions(['highlightNextLog'])\n                    .toNotHaveDispatchedActions(['setHighlightedLogId'])\n            })\n        })\n\n        describe('highlightPreviousLog', () => {\n            it('highlights last log when none is highlighted', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightPreviousLog()\n                })\n                    .toDispatchActions(['highlightPreviousLog', 'setHighlightedLogId'])\n                    .toMatchValues({\n                        highlightedLogId: 'log-3',\n                    })\n            })\n\n            it('highlights previous log in sequence', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                logic.actions.setHighlightedLogId('log-2')\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightPreviousLog()\n                })\n                    .toDispatchActions(['highlightPreviousLog', 'setHighlightedLogId'])\n                    .toMatchValues({\n                        highlightedLogId: 'log-1',\n                    })\n            })\n\n            it('does nothing when at first log', async () => {\n                logic.actions.fetchLogsSuccess(mockLogs)\n                logic.actions.setHighlightedLogId('log-1')\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightPreviousLog()\n                })\n                    .toDispatchActions(['highlightPreviousLog'])\n                    .toNotHaveDispatchedActions(['setHighlightedLogId'])\n            })\n\n            it('does nothing when logs are empty', async () => {\n                logic.actions.fetchLogsSuccess([])\n                await expectLogic(logic).toFinishAllListeners()\n\n                await expectLogic(logic, () => {\n                    logic.actions.highlightPreviousLog()\n                })\n                    .toDispatchActions(['highlightPreviousLog'])\n                    .toNotHaveDispatchedActions(['setHighlightedLogId'])\n            })\n        })\n\n        describe('toggleExpandLog', () => {\n            it('expands a log when not expanded', async () => {\n                await expectLogic(logic, () => {\n                    logic.actions.toggleExpandLog('log-1')\n                }).toDispatchActions(['toggleExpandLog'])\n\n                expect(logic.values.expandedLogIds.has('log-1')).toBe(true)\n            })\n\n            it('collapses a log when already expanded', async () => {\n                logic.actions.toggleExpandLog('log-1')\n                await expectLogic(logic).toFinishAllListeners()\n\n                expect(logic.values.expandedLogIds.has('log-1')).toBe(true)\n\n                await expectLogic(logic, () => {\n                    logic.actions.toggleExpandLog('log-1')\n                }).toDispatchActions(['toggleExpandLog'])\n\n                expect(logic.values.expandedLogIds.has('log-1')).toBe(false)\n            })\n\n            it('supports multiple expanded logs', async () => {\n                logic.actions.toggleExpandLog('log-1')\n                logic.actions.toggleExpandLog('log-2')\n                logic.actions.toggleExpandLog('log-3')\n                await expectLogic(logic).toFinishAllListeners()\n\n                expect(logic.values.expandedLogIds.has('log-1')).toBe(true)\n                expect(logic.values.expandedLogIds.has('log-2')).toBe(true)\n                expect(logic.values.expandedLogIds.has('log-3')).toBe(true)\n\n                logic.actions.toggleExpandLog('log-2')\n                await expectLogic(logic).toFinishAllListeners()\n\n                expect(logic.values.expandedLogIds.has('log-1')).toBe(true)\n                expect(logic.values.expandedLogIds.has('log-2')).toBe(false)\n                expect(logic.values.expandedLogIds.has('log-3')).toBe(true)\n            })\n        })\n    })\n})",
            "cost": 0.06935000000000001
        },
        "PostHog__posthog.main/products/logs/frontend/logsLogic.tsx": {
            "output": "import colors from 'ansi-colors'\nimport equal from 'fast-deep-equal'\nimport { actions, events, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { router } from 'kea-router'\n\nimport { lemonToast } from '@posthog/lemon-ui'\nimport { syncSearchParams, updateSearchParams } from '@posthog/products-error-tracking/frontend/utils'\n\nimport api from 'lib/api'\nimport { DEFAULT_UNIVERSAL_GROUP_FILTER } from 'lib/components/UniversalFilters/universalFiltersLogic'\nimport { dayjs } from 'lib/dayjs'\nimport { tabAwareActionToUrl } from 'lib/logic/scenes/tabAwareActionToUrl'\nimport { tabAwareScene } from 'lib/logic/scenes/tabAwareScene'\nimport { tabAwareUrlToAction } from 'lib/logic/scenes/tabAwareUrlToAction'\nimport { humanFriendlyDetailedTime } from 'lib/utils'\nimport { copyToClipboard } from 'lib/utils/copyToClipboard'\nimport { Params } from 'scenes/sceneTypes'\n\nimport { DateRange, LogMessage, LogsQuery } from '~/queries/schema/schema-general'\nimport { integer } from '~/queries/schema/type-utils'\nimport { JsonType, PropertyFilterType, PropertyGroupFilter, PropertyOperator, UniversalFiltersGroup } from '~/types'\n\nimport { zoomDateRange } from './filters/zoom-utils'\nimport type { logsLogicType } from './logsLogicType'\nimport { ParsedLogMessage } from './types'\n\nconst DEFAULT_DATE_RANGE = { date_from: '-1h', date_to: null }\nconst DEFAULT_SEVERITY_LEVELS = [] as LogsQuery['severityLevels']\nconst DEFAULT_SERVICE_NAMES = [] as LogsQuery['serviceNames']\nconst DEFAULT_HIGHLIGHTED_LOG_ID = null as string | null\nconst DEFAULT_ORDER_BY = 'latest' as LogsQuery['orderBy']\nconst DEFAULT_WRAP_BODY = true\nconst DEFAULT_PRETTIFY_JSON = true\nconst DEFAULT_LOGS_PAGE_SIZE: number = 100\nconst DEFAULT_INITIAL_LOGS_LIMIT = null as number | null\nconst NEW_QUERY_STARTED_ERROR_MESSAGE = 'new query started' as const\nconst DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS = 1000\nconst DEFAULT_LIVE_TAIL_POLL_INTERVAL_MAX_MS = 5000\n\nconst parseLogAttributes = (logs: LogMessage[]): void => {\n    logs.forEach((row) => {\n        Object.keys(row.attributes).forEach((key) => {\n            const value = row.attributes[key]\n            row.attributes[key] = typeof value === 'string' ? value : JSON.stringify(value)\n        })\n    })\n}\n\nexport enum SparklineTimezone {\n    UTC = 'utc',\n    Project = 'project',\n    Device = 'device',\n}\n\nexport interface LogsLogicProps {\n    tabId: string\n}\n\nexport const logsLogic = kea<logsLogicType>([\n    props({} as LogsLogicProps),\n    path(['products', 'logs', 'frontend', 'logsLogic']),\n    tabAwareScene(),\n    tabAwareUrlToAction(({ actions, values }) => {\n        const urlToAction = (_: any, params: Params): void => {\n            if (params.dateRange) {\n                try {\n                    const dateRange =\n                        typeof params.dateRange === 'string' ? JSON.parse(params.dateRange) : params.dateRange\n                    if (!equal(dateRange, values.dateRange)) {\n                        actions.setDateRange(dateRange)\n                    }\n                } catch {\n                    // Ignore malformed dateRange JSON in URL\n                }\n            }\n            if (params.filterGroup && !equal(params.filterGroup, values.filterGroup)) {\n                actions.setFilterGroup(params.filterGroup, false)\n            }\n            if (params.searchTerm && !equal(params.searchTerm, values.searchTerm)) {\n                actions.setSearchTerm(params.searchTerm)\n            }\n            if (params.severityLevels && !equal(params.severityLevels, values.severityLevels)) {\n                actions.setSeverityLevels(params.severityLevels)\n            }\n            if (params.serviceNames && !equal(params.serviceNames, values.serviceNames)) {\n                actions.setServiceNames(params.serviceNames)\n            }\n            if (params.highlightedLogId !== undefined && params.highlightedLogId !== values.highlightedLogId) {\n                actions.setHighlightedLogId(params.highlightedLogId)\n            }\n            if (params.orderBy && !equal(params.orderBy, values.orderBy)) {\n                actions.setOrderBy(params.orderBy)\n            }\n            if (params.wrapBody !== undefined && params.wrapBody !== values.wrapBody) {\n                actions.setWrapBody(params.wrapBody)\n            }\n            if (params.prettifyJson !== undefined && params.prettifyJson !== values.prettifyJson) {\n                actions.setPrettifyJson(params.prettifyJson)\n            }\n            if (+params.logsPageSize && +params.logsPageSize !== values.logsPageSize) {\n                actions.setLogsPageSize(+params.logsPageSize)\n            }\n            if (params.initialLogsLimit != null && +params.initialLogsLimit !== values.initialLogsLimit) {\n                actions.setInitialLogsLimit(+params.initialLogsLimit)\n            }\n        }\n        return {\n            '*': urlToAction,\n        }\n    }),\n\n    tabAwareActionToUrl(({ actions, values }) => {\n        const buildUrlAndRunQuery = (): [\n            string,\n            Params,\n            Record<string, any>,\n            {\n                replace: boolean\n            },\n        ] => {\n            return syncSearchParams(router, (params: Params) => {\n                updateSearchParams(params, 'searchTerm', values.searchTerm, '')\n                updateSearchParams(params, 'filterGroup', values.filterGroup, DEFAULT_UNIVERSAL_GROUP_FILTER)\n                updateSearchParams(params, 'dateRange', values.dateRange, DEFAULT_DATE_RANGE)\n                updateSearchParams(params, 'severityLevels', values.severityLevels, DEFAULT_SEVERITY_LEVELS)\n                updateSearchParams(params, 'serviceNames', values.serviceNames, DEFAULT_SERVICE_NAMES)\n                updateSearchParams(params, 'highlightedLogId', values.highlightedLogId, DEFAULT_HIGHLIGHTED_LOG_ID)\n                updateSearchParams(params, 'orderBy', values.orderBy, DEFAULT_ORDER_BY)\n                updateSearchParams(params, 'logsPageSize', values.logsPageSize, DEFAULT_LOGS_PAGE_SIZE)\n                actions.runQuery()\n                return params\n            })\n        }\n\n        const updateHighlightURL = (): [\n            string,\n            Params,\n            Record<string, any>,\n            {\n                replace: boolean\n            },\n        ] => {\n            return syncSearchParams(router, (params: Params) => {\n                updateSearchParams(params, 'highlightedLogId', values.highlightedLogId, DEFAULT_HIGHLIGHTED_LOG_ID)\n                return params\n            })\n        }\n\n        const updateUrlWithDisplayPreferences = (): [\n            string,\n            Params,\n            Record<string, any>,\n            {\n                replace: boolean\n            },\n        ] => {\n            return syncSearchParams(router, (params: Params) => {\n                updateSearchParams(params, 'wrapBody', values.wrapBody, DEFAULT_WRAP_BODY)\n                updateSearchParams(params, 'prettifyJson', values.prettifyJson, DEFAULT_PRETTIFY_JSON)\n                return params\n            })\n        }\n\n        const updateUrlWithPageSize = (): [\n            string,\n            Params,\n            Record<string, any>,\n            {\n                replace: boolean\n            },\n        ] => {\n            return syncSearchParams(router, (params: Params) => {\n                updateSearchParams(params, 'logsPageSize', values.logsPageSize, DEFAULT_LOGS_PAGE_SIZE)\n                actions.applyLogsPageSize(values.logsPageSize)\n                return params\n            })\n        }\n\n        const clearInitialLogsLimit = (): [\n            string,\n            Params,\n            Record<string, any>,\n            {\n                replace: boolean\n            },\n        ] => {\n            return syncSearchParams(router, (params: Params) => {\n                updateSearchParams(params, 'initialLogsLimit', null, DEFAULT_INITIAL_LOGS_LIMIT)\n                return params\n            })\n        }\n\n        return {\n            fetchLogsSuccess: () => clearInitialLogsLimit(),\n            setDateRange: () => buildUrlAndRunQuery(),\n            setFilterGroup: () => buildUrlAndRunQuery(),\n            setSearchTerm: () => buildUrlAndRunQuery(),\n            setSeverityLevels: () => buildUrlAndRunQuery(),\n            setServiceNames: () => buildUrlAndRunQuery(),\n            setOrderBy: () => buildUrlAndRunQuery(),\n            setLogsPageSize: () => updateUrlWithPageSize(),\n            setHighlightedLogId: () => updateHighlightURL(),\n            setWrapBody: () => updateUrlWithDisplayPreferences(),\n            setPrettifyJson: () => updateUrlWithDisplayPreferences(),\n        }\n    }),\n\n    actions({\n        runQuery: (debounce?: integer) => ({ debounce }),\n        fetchNextLogsPage: (limit?: number) => ({ limit }),\n        truncateLogs: (limit: number) => ({ limit }),\n        applyLogsPageSize: (logsPageSize: number) => ({ logsPageSize }),\n        clearLogs: true,\n        cancelInProgressLogs: (logsAbortController: AbortController | null) => ({ logsAbortController }),\n        cancelInProgressSparkline: (sparklineAbortController: AbortController | null) => ({ sparklineAbortController }),\n        cancelInProgressLiveTail: (liveTailAbortController: AbortController | null) => ({ liveTailAbortController }),\n        setLogsAbortController: (logsAbortController: AbortController | null) => ({ logsAbortController }),\n        setSparklineAbortController: (sparklineAbortController: AbortController | null) => ({\n            sparklineAbortController,\n        }),\n        setLiveTailAbortController: (liveTailAbortController: AbortController | null) => ({\n            liveTailAbortController,\n        }),\n        setDateRange: (dateRange: DateRange) => ({ dateRange }),\n        setOrderBy: (orderBy: LogsQuery['orderBy']) => ({ orderBy }),\n        setSearchTerm: (searchTerm: LogsQuery['searchTerm']) => ({ searchTerm }),\n        setSeverityLevels: (severityLevels: LogsQuery['severityLevels']) => ({ severityLevels }),\n        setServiceNames: (serviceNames: LogsQuery['serviceNames']) => ({ serviceNames }),\n        setWrapBody: (wrapBody: boolean) => ({ wrapBody }),\n        setPrettifyJson: (prettifyJson: boolean) => ({ prettifyJson }),\n        setLiveLogsCheckpoint: (liveLogsCheckpoint: string | null) => ({ liveLogsCheckpoint }),\n\n        setFilterGroup: (filterGroup: UniversalFiltersGroup, openFilterOnInsert: boolean = true) => ({\n            filterGroup,\n            openFilterOnInsert,\n        }),\n        toggleAttributeBreakdown: (key: string) => ({ key }),\n        setExpandedAttributeBreaksdowns: (expandedAttributeBreaksdowns: string[]) => ({ expandedAttributeBreaksdowns }),\n        zoomDateRange: (multiplier: number) => ({ multiplier }),\n        setDateRangeFromSparkline: (startIndex: number, endIndex: number) => ({ startIndex, endIndex }),\n        addFilter: (key: string, value: string, operator: PropertyOperator = PropertyOperator.Exact) => ({\n            key,\n            value,\n            operator,\n        }),\n        togglePinLog: (logId: string) => ({ logId }),\n        pinLog: (log: LogMessage) => ({ log }),\n        unpinLog: (logId: string) => ({ logId }),\n        setHighlightedLogId: (highlightedLogId: string | null) => ({ highlightedLogId }),\n        setHasMoreLogsToLoad: (hasMoreLogsToLoad: boolean) => ({ hasMoreLogsToLoad }),\n        setLogsPageSize: (logsPageSize: number) => ({ logsPageSize }),\n        setInitialLogsLimit: (initialLogsLimit: number | null) => ({ initialLogsLimit }),\n        copyLinkToLog: (logId: string) => ({ logId }),\n        highlightNextLog: true,\n        highlightPreviousLog: true,\n        toggleExpandLog: (logId: string) => ({ logId }),\n        setLiveTailRunning: (enabled: boolean) => ({ enabled }),\n        setLiveTailInterval: (interval: number) => ({ interval }),\n        pollForNewLogs: true,\n        setLogs: (logs: LogMessage[]) => ({ logs }),\n        setSparkline: (sparkline: any[]) => ({ sparkline }),\n        expireLiveTail: () => true,\n        setLiveTailExpired: (liveTailExpired: boolean) => ({ liveTailExpired }),\n        addLogsToSparkline: (logs: LogMessage[]) => logs,\n    }),\n\n    reducers({\n        logsPageSize: [\n            DEFAULT_LOGS_PAGE_SIZE,\n            {\n                setLogsPageSize: (_, { logsPageSize }) => logsPageSize,\n            },\n        ],\n        initialLogsLimit: [\n            DEFAULT_INITIAL_LOGS_LIMIT as number | null,\n            {\n                setInitialLogsLimit: (_, { initialLogsLimit }) => initialLogsLimit,\n                fetchLogsSuccess: () => null,\n            },\n        ],\n        dateRange: [\n            DEFAULT_DATE_RANGE as DateRange,\n            {\n                setDateRange: (_, { dateRange }) => dateRange,\n            },\n        ],\n        orderBy: [\n            DEFAULT_ORDER_BY,\n            {\n                setOrderBy: (_, { orderBy }) => orderBy,\n            },\n        ],\n        searchTerm: [\n            '' as LogsQuery['searchTerm'],\n            {\n                setSearchTerm: (_, { searchTerm }) => searchTerm,\n            },\n        ],\n        severityLevels: [\n            DEFAULT_SEVERITY_LEVELS,\n            {\n                setSeverityLevels: (_, { severityLevels }) => severityLevels,\n            },\n        ],\n        serviceNames: [\n            DEFAULT_SERVICE_NAMES,\n            {\n                setServiceNames: (_, { serviceNames }) => serviceNames,\n            },\n        ],\n        filterGroup: [\n            DEFAULT_UNIVERSAL_GROUP_FILTER,\n            {\n                setFilterGroup: (_, { filterGroup }) => filterGroup,\n            },\n        ],\n        wrapBody: [\n            DEFAULT_WRAP_BODY as boolean,\n            {\n                setWrapBody: (_, { wrapBody }) => wrapBody,\n            },\n        ],\n        liveLogsCheckpoint: [\n            null as string | null,\n            { persist: false },\n            {\n                setLiveLogsCheckpoint: (_, { liveLogsCheckpoint }) => liveLogsCheckpoint,\n            },\n        ],\n        liveTailExpired: [\n            true as boolean,\n            { persist: false },\n            {\n                setLiveTailExpired: (_, { liveTailExpired }) => liveTailExpired,\n                fetchLogsSuccess: () => false,\n            },\n        ],\n        prettifyJson: [\n            DEFAULT_PRETTIFY_JSON as boolean,\n            {\n                setPrettifyJson: (_, { prettifyJson }) => prettifyJson,\n            },\n        ],\n        logsAbortController: [\n            null as AbortController | null,\n            {\n                setLogsAbortController: (_, { logsAbortController }) => logsAbort",
            "output_extracted": "import colors from 'ansi-colors'\nimport equal from 'fast-deep-equal'\nimport { actions, events, kea, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { router } from 'kea-router'\n\nimport { lemonToast } from '@posthog/lemon-ui'\nimport { syncSearchParams, updateSearchParams } from '@posthog/products-error-tracking/frontend/utils'\n\nimport api from 'lib/api'\nimport { DEFAULT_UNIVERSAL_GROUP_FILTER } from 'lib/components/UniversalFilters/universalFiltersLogic'\nimport { dayjs } from 'lib/dayjs'\nimport { tabAwareActionToUrl } from 'lib/logic/scenes/tabAwareActionToUrl'\nimport { tabAwareScene } from 'lib/logic/scenes/tabAwareScene'\nimport { tabAwareUrlToAction } from 'lib/logic/scenes/tabAwareUrlToAction'\nimport { humanFriendlyDetailedTime } from 'lib/utils'\nimport { copyToClipboard } from 'lib/utils/copyToClipboard'\nimport { Params } from 'scenes/sceneTypes'\n\nimport { DateRange, LogMessage, LogsQuery } from '~/queries/schema/schema-general'\nimport { integer } from '~/queries/schema/type-utils'\nimport { JsonType, PropertyFilterType, PropertyGroupFilter, PropertyOperator, UniversalFiltersGroup } from '~/types'\n\nimport { zoomDateRange } from './filters/zoom-utils'\nimport type { logsLogicType } from './logsLogicType'\nimport { ParsedLogMessage } from './types'\n\nconst DEFAULT_DATE_RANGE = { date_from: '-1h', date_to: null }\nconst DEFAULT_SEVERITY_LEVELS = [] as LogsQuery['severityLevels']\nconst DEFAULT_SERVICE_NAMES = [] as LogsQuery['serviceNames']\nconst DEFAULT_HIGHLIGHTED_LOG_ID = null as string | null\nconst DEFAULT_ORDER_BY = 'latest' as LogsQuery['orderBy']\nconst DEFAULT_WRAP_BODY = true\nconst DEFAULT_PRETTIFY_JSON = true\nconst DEFAULT_LOGS_PAGE_SIZE: number = 100\nconst DEFAULT_INITIAL_LOGS_LIMIT = null as number | null\nconst NEW_QUERY_STARTED_ERROR_MESSAGE = 'new query started' as const\nconst DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS = 1000\nconst DEFAULT_LIVE_TAIL_POLL_INTERVAL_MAX_MS = 5000\n\nconst parseLogAttributes = (logs: LogMessage[]): void => {\n    logs.forEach((row) => {\n        Object.keys(row.attributes).forEach((key) => {\n            const value = row.attributes[key]\n            row.attributes[key] = typeof value === 'string' ? value : JSON.stringify(value)\n        })\n    })\n}\n\nexport enum SparklineTimezone {\n    UTC = 'utc',\n    Project = 'project',\n    Device = 'device',\n}\n\nexport interface LogsLogicProps {\n    tabId: string\n}\n\nexport const logsLogic = kea<logsLogicType>([\n    props({} as LogsLogicProps),\n    path(['products', 'logs', 'frontend', 'logsLogic']),\n    tabAwareScene(),\n    tabAwareUrlToAction(({ actions, values }) => {\n        const urlToAction = (_: any, params: Params): void => {\n            if (params.dateRange) {\n                try {\n                    const dateRange =\n                        typeof params.dateRange === 'string' ? JSON.parse(params.dateRange) : params.dateRange\n                    if (!equal(dateRange, values.dateRange)) {\n                        actions.setDateRange(dateRange)\n                    }\n                } catch {\n                    // Ignore malformed dateRange JSON in URL\n                }\n            }\n            if (params.filterGroup && !equal(params.filterGroup, values.filterGroup)) {\n                actions.setFilterGroup(params.filterGroup, false)\n            }\n            if (params.searchTerm && !equal(params.searchTerm, values.searchTerm)) {\n                actions.setSearchTerm(params.searchTerm)\n            }\n            if (params.severityLevels && !equal(params.severityLevels, values.severityLevels)) {\n                actions.setSeverityLevels(params.severityLevels)\n            }\n            if (params.serviceNames && !equal(params.serviceNames, values.serviceNames)) {\n                actions.setServiceNames(params.serviceNames)\n            }\n            if (params.highlightedLogId !== undefined && params.highlightedLogId !== values.highlightedLogId) {\n                actions.setHighlightedLogId(params.highlightedLogId)\n            }\n            if (params.orderBy && !equal(params.orderBy, values.orderBy)) {\n                actions.setOrderBy(params.orderBy)\n            }\n            if (params.wrapBody !== undefined && params.wrapBody !== values.wrapBody) {\n                actions.setWrapBody(params.wrapBody)\n            }\n            if (params.prettifyJson !== undefined && params.prettifyJson !== values.prettifyJson) {\n                actions.setPrettifyJson(params.prettifyJson)\n            }\n            if (+params.logsPageSize && +params.logsPageSize !== values.logsPageSize) {\n                actions.setLogsPageSize(+params.logsPageSize)\n            }\n            if (params.initialLogsLimit != null && +params.initialLogsLimit !== values.initialLogsLimit) {\n                actions.setInitialLogsLimit(+params.initialLogsLimit)\n            }\n        }\n        return {\n            '*': urlToAction,\n        }\n    }),\n\n    tabAwareActionToUrl(({ actions, values }) => {\n        const buildUrlAndRunQuery = (): [\n            string,\n            Params,\n            Record<string, any>,\n            {\n                replace: boolean\n            },\n        ] => {\n            return syncSearchParams(router, (params: Params) => {\n                updateSearchParams(params, 'searchTerm', values.searchTerm, '')\n                updateSearchParams(params, 'filterGroup', values.filterGroup, DEFAULT_UNIVERSAL_GROUP_FILTER)\n                updateSearchParams(params, 'dateRange', values.dateRange, DEFAULT_DATE_RANGE)\n                updateSearchParams(params, 'severityLevels', values.severityLevels, DEFAULT_SEVERITY_LEVELS)\n                updateSearchParams(params, 'serviceNames', values.serviceNames, DEFAULT_SERVICE_NAMES)\n                updateSearchParams(params, 'highlightedLogId', values.highlightedLogId, DEFAULT_HIGHLIGHTED_LOG_ID)\n                updateSearchParams(params, 'orderBy', values.orderBy, DEFAULT_ORDER_BY)\n                updateSearchParams(params, 'logsPageSize', values.logsPageSize, DEFAULT_LOGS_PAGE_SIZE)\n                actions.runQuery()\n                return params\n            })\n        }\n\n        const updateHighlightURL = (): [\n            string,\n            Params,\n            Record<string, any>,\n            {\n                replace: boolean\n            },\n        ] => {\n            return syncSearchParams(router, (params: Params) => {\n                updateSearchParams(params, 'highlightedLogId', values.highlightedLogId, DEFAULT_HIGHLIGHTED_LOG_ID)\n                return params\n            })\n        }\n\n        const updateUrlWithDisplayPreferences = (): [\n            string,\n            Params,\n            Record<string, any>,\n            {\n                replace: boolean\n            },\n        ] => {\n            return syncSearchParams(router, (params: Params) => {\n                updateSearchParams(params, 'wrapBody', values.wrapBody, DEFAULT_WRAP_BODY)\n                updateSearchParams(params, 'prettifyJson', values.prettifyJson, DEFAULT_PRETTIFY_JSON)\n                return params\n            })\n        }\n\n        const updateUrlWithPageSize = (): [\n            string,\n            Params,\n            Record<string, any>,\n            {\n                replace: boolean\n            },\n        ] => {\n            return syncSearchParams(router, (params: Params) => {\n                updateSearchParams(params, 'logsPageSize', values.logsPageSize, DEFAULT_LOGS_PAGE_SIZE)\n                actions.applyLogsPageSize(values.logsPageSize)\n                return params\n            })\n        }\n\n        const clearInitialLogsLimit = (): [\n            string,\n            Params,\n            Record<string, any>,\n            {\n                replace: boolean\n            },\n        ] => {\n            return syncSearchParams(router, (params: Params) => {\n                updateSearchParams(params, 'initialLogsLimit', null, DEFAULT_INITIAL_LOGS_LIMIT)\n                return params\n            })\n        }\n\n        return {\n            fetchLogsSuccess: () => clearInitialLogsLimit(),\n            setDateRange: () => buildUrlAndRunQuery(),\n            setFilterGroup: () => buildUrlAndRunQuery(),\n            setSearchTerm: () => buildUrlAndRunQuery(),\n            setSeverityLevels: () => buildUrlAndRunQuery(),\n            setServiceNames: () => buildUrlAndRunQuery(),\n            setOrderBy: () => buildUrlAndRunQuery(),\n            setLogsPageSize: () => updateUrlWithPageSize(),\n            setHighlightedLogId: () => updateHighlightURL(),\n            setWrapBody: () => updateUrlWithDisplayPreferences(),\n            setPrettifyJson: () => updateUrlWithDisplayPreferences(),\n        }\n    }),\n\n    actions({\n        runQuery: (debounce?: integer) => ({ debounce }),\n        fetchNextLogsPage: (limit?: number) => ({ limit }),\n        truncateLogs: (limit: number) => ({ limit }),\n        applyLogsPageSize: (logsPageSize: number) => ({ logsPageSize }),\n        clearLogs: true,\n        cancelInProgressLogs: (logsAbortController: AbortController | null) => ({ logsAbortController }),\n        cancelInProgressSparkline: (sparklineAbortController: AbortController | null) => ({ sparklineAbortController }),\n        cancelInProgressLiveTail: (liveTailAbortController: AbortController | null) => ({ liveTailAbortController }),\n        setLogsAbortController: (logsAbortController: AbortController | null) => ({ logsAbortController }),\n        setSparklineAbortController: (sparklineAbortController: AbortController | null) => ({\n            sparklineAbortController,\n        }),\n        setLiveTailAbortController: (liveTailAbortController: AbortController | null) => ({\n            liveTailAbortController,\n        }),\n        setDateRange: (dateRange: DateRange) => ({ dateRange }),\n        setOrderBy: (orderBy: LogsQuery['orderBy']) => ({ orderBy }),\n        setSearchTerm: (searchTerm: LogsQuery['searchTerm']) => ({ searchTerm }),\n        setSeverityLevels: (severityLevels: LogsQuery['severityLevels']) => ({ severityLevels }),\n        setServiceNames: (serviceNames: LogsQuery['serviceNames']) => ({ serviceNames }),\n        setWrapBody: (wrapBody: boolean) => ({ wrapBody }),\n        setPrettifyJson: (prettifyJson: boolean) => ({ prettifyJson }),\n        setLiveLogsCheckpoint: (liveLogsCheckpoint: string | null) => ({ liveLogsCheckpoint }),\n\n        setFilterGroup: (filterGroup: UniversalFiltersGroup, openFilterOnInsert: boolean = true) => ({\n            filterGroup,\n            openFilterOnInsert,\n        }),\n        toggleAttributeBreakdown: (key: string) => ({ key }),\n        setExpandedAttributeBreaksdowns: (expandedAttributeBreaksdowns: string[]) => ({ expandedAttributeBreaksdowns }),\n        zoomDateRange: (multiplier: number) => ({ multiplier }),\n        setDateRangeFromSparkline: (startIndex: number, endIndex: number) => ({ startIndex, endIndex }),\n        addFilter: (key: string, value: string, operator: PropertyOperator = PropertyOperator.Exact) => ({\n            key,\n            value,\n            operator,\n        }),\n        togglePinLog: (logId: string) => ({ logId }),\n        pinLog: (log: LogMessage) => ({ log }),\n        unpinLog: (logId: string) => ({ logId }),\n        setHighlightedLogId: (highlightedLogId: string | null) => ({ highlightedLogId }),\n        setHasMoreLogsToLoad: (hasMoreLogsToLoad: boolean) => ({ hasMoreLogsToLoad }),\n        setLogsPageSize: (logsPageSize: number) => ({ logsPageSize }),\n        setInitialLogsLimit: (initialLogsLimit: number | null) => ({ initialLogsLimit }),\n        copyLinkToLog: (logId: string) => ({ logId }),\n        highlightNextLog: true,\n        highlightPreviousLog: true,\n        toggleExpandLog: (logId: string) => ({ logId }),\n        setLiveTailRunning: (enabled: boolean) => ({ enabled }),\n        setLiveTailInterval: (interval: number) => ({ interval }),\n        pollForNewLogs: true,\n        setLogs: (logs: LogMessage[]) => ({ logs }),\n        setSparkline: (sparkline: any[]) => ({ sparkline }),\n        expireLiveTail: () => true,\n        setLiveTailExpired: (liveTailExpired: boolean) => ({ liveTailExpired }),\n        addLogsToSparkline: (logs: LogMessage[]) => logs,\n    }),\n\n    reducers({\n        logsPageSize: [\n            DEFAULT_LOGS_PAGE_SIZE,\n            {\n                setLogsPageSize: (_, { logsPageSize }) => logsPageSize,\n            },\n        ],\n        initialLogsLimit: [\n            DEFAULT_INITIAL_LOGS_LIMIT as number | null,\n            {\n                setInitialLogsLimit: (_, { initialLogsLimit }) => initialLogsLimit,\n                fetchLogsSuccess: () => null,\n            },\n        ],\n        dateRange: [\n            DEFAULT_DATE_RANGE as DateRange,\n            {\n                setDateRange: (_, { dateRange }) => dateRange,\n            },\n        ],\n        orderBy: [\n            DEFAULT_ORDER_BY,\n            {\n                setOrderBy: (_, { orderBy }) => orderBy,\n            },\n        ],\n        searchTerm: [\n            '' as LogsQuery['searchTerm'],\n            {\n                setSearchTerm: (_, { searchTerm }) => searchTerm,\n            },\n        ],\n        severityLevels: [\n            DEFAULT_SEVERITY_LEVELS,\n            {\n                setSeverityLevels: (_, { severityLevels }) => severityLevels,\n            },\n        ],\n        serviceNames: [\n            DEFAULT_SERVICE_NAMES,\n            {\n                setServiceNames: (_, { serviceNames }) => serviceNames,\n            },\n        ],\n        filterGroup: [\n            DEFAULT_UNIVERSAL_GROUP_FILTER,\n            {\n                setFilterGroup: (_, { filterGroup }) => filterGroup,\n            },\n        ],\n        wrapBody: [\n            DEFAULT_WRAP_BODY as boolean,\n            {\n                setWrapBody: (_, { wrapBody }) => wrapBody,\n            },\n        ],\n        liveLogsCheckpoint: [\n            null as string | null,\n            { persist: false },\n            {\n                setLiveLogsCheckpoint: (_, { liveLogsCheckpoint }) => liveLogsCheckpoint,\n            },\n        ],\n        liveTailExpired: [\n            true as boolean,\n            { persist: false },\n            {\n                setLiveTailExpired: (_, { liveTailExpired }) => liveTailExpired,\n                fetchLogsSuccess: () => false,\n            },\n        ],\n        prettifyJson: [\n            DEFAULT_PRETTIFY_JSON as boolean,\n            {\n                setPrettifyJson: (_, { prettifyJson }) => prettifyJson,\n            },\n        ],\n        logsAbortController: [\n            null as AbortController | null,\n            {\n                setLogsAbortController: (_, { logsAbortController }) => logsAbort",
            "cost": 0.16494
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "PostHog__posthog.main.42716",
        "repo": "PostHog/posthog",
        "base_commit": "7ade7ab65f97207781f2fce296da071725e3e955",
        "head_commit": "b4ae408f1a8d884f1dcabf9dda5f6afc2074845c",
        "title": "feat(logs): add timezone support for sparkline and refactor component",
        "merged_at": "2025-12-04T17:31:03Z",
        "html_url": "https://github.com/PostHog/posthog/pull/42716",
        "test_files": [
            "products/logs/frontend/logsLogic.test.ts"
        ],
        "code_files": [
            "products/logs/frontend/LogsScene.tsx",
            "products/logs/frontend/components/LogsSparkline.tsx",
            "products/logs/frontend/logsLogic.tsx"
        ],
        "total_changes": 206,
        "num_files": 4,
        "pull_number": 42716,
        "patch": "diff --git a/products/logs/frontend/LogsScene.tsx b/products/logs/frontend/LogsScene.tsx\nindex 62d6a84b3fcb2..d48921c51a1f0 100644\n--- a/products/logs/frontend/LogsScene.tsx\n+++ b/products/logs/frontend/LogsScene.tsx\n@@ -9,13 +9,11 @@ import {\n     LemonSegmentedButton,\n     LemonSelect,\n     LemonTable,\n-    SpinnerOverlay,\n     Tooltip,\n } from '@posthog/lemon-ui'\n \n import { CopyToClipboardInline } from 'lib/components/CopyToClipboard'\n import { ProductIntroduction } from 'lib/components/ProductIntroduction/ProductIntroduction'\n-import { Sparkline } from 'lib/components/Sparkline'\n import { TZLabel, TZLabelProps } from 'lib/components/TZLabel'\n import { ListHog } from 'lib/components/hedgehogs'\n import { FEATURE_FLAGS } from 'lib/constants'\n@@ -36,6 +34,7 @@ import { LogMessage, ProductKey } from '~/queries/schema/schema-general'\n import { PropertyOperator } from '~/types'\n \n import { LogTag } from 'products/logs/frontend/components/LogTag'\n+import { LogsSparkline } from 'products/logs/frontend/components/LogsSparkline'\n import { LogsTableRowActions } from 'products/logs/frontend/components/LogsTable/LogsTableRowActions'\n import { VirtualizedLogsList } from 'products/logs/frontend/components/VirtualizedLogsList'\n import { LogsFilterGroup } from 'products/logs/frontend/components/filters/LogsFilters/FilterGroup'\n@@ -54,9 +53,8 @@ export const scene: SceneExport = {\n }\n \n export function LogsScene(): JSX.Element {\n-    const { sparklineData, sparklineLoading, logsLoading } = useValues(logsLogic)\n-    const { runQuery, setDateRangeFromSparkline, highlightNextLog, highlightPreviousLog, toggleExpandLog } =\n-        useActions(logsLogic)\n+    const { logsLoading } = useValues(logsLogic)\n+    const { runQuery, highlightNextLog, highlightPreviousLog, toggleExpandLog } = useActions(logsLogic)\n     const { highlightedLogId: sceneHighlightedLogId } = useValues(logsLogic)\n \n     useEffect(() => {\n@@ -81,10 +79,6 @@ export function LogsScene(): JSX.Element {\n         [sceneHighlightedLogId, logsLoading, runQuery]\n     )\n \n-    const onSelectionChange = (selection: { startIndex: number; endIndex: number }): void => {\n-        setDateRangeFromSparkline(selection.startIndex, selection.endIndex)\n-    }\n-\n     return (\n         <SceneContent>\n             <SceneTitleSection\n@@ -115,21 +109,7 @@ export function LogsScene(): JSX.Element {\n                 isEmpty={false}\n             />\n             <Filters />\n-            <div className=\"relative h-40 flex flex-col\">\n-                {sparklineData.data.length > 0 ? (\n-                    <Sparkline\n-                        labels={sparklineData.labels}\n-                        data={sparklineData.data}\n-                        className=\"w-full flex-1\"\n-                        onSelectionChange={onSelectionChange}\n-                    />\n-                ) : !sparklineLoading ? (\n-                    <div className=\"flex-1 text-muted flex items-center justify-center\">\n-                        No results matching filters\n-                    </div>\n-                ) : null}\n-                {sparklineLoading && <SpinnerOverlay />}\n-            </div>\n+            <LogsSparkline />\n             <SceneDivider />\n             <LogsListContainer />\n         </SceneContent>\ndiff --git a/products/logs/frontend/components/LogsSparkline.tsx b/products/logs/frontend/components/LogsSparkline.tsx\nnew file mode 100644\nindex 0000000000000..0a75f25457f92\n--- /dev/null\n+++ b/products/logs/frontend/components/LogsSparkline.tsx\n@@ -0,0 +1,142 @@\n+import { useActions, useValues } from 'kea'\n+import { useCallback, useMemo } from 'react'\n+\n+import { LemonSelect, SpinnerOverlay } from '@posthog/lemon-ui'\n+\n+import { AnyScaleOptions, Sparkline } from 'lib/components/Sparkline'\n+import { dayjs } from 'lib/dayjs'\n+import { shortTimeZone } from 'lib/utils'\n+import { teamLogic } from 'scenes/teamLogic'\n+\n+import { SparklineTimezone, logsLogic } from '../logsLogic'\n+\n+export function LogsSparkline(): JSX.Element {\n+    const { sparklineData, sparklineLoading, sparklineTimezone } = useValues(logsLogic)\n+    const { setDateRangeFromSparkline, setSparklineTimezone } = useActions(logsLogic)\n+    const { timezone: projectTimezone } = useValues(teamLogic)\n+\n+    const deviceTimezone = shortTimeZone()\n+\n+    // Determine which timezone string to use for formatting\n+    const activeTimezone = useMemo(() => {\n+        switch (sparklineTimezone) {\n+            case SparklineTimezone.UTC:\n+                return 'UTC'\n+            case SparklineTimezone.Project:\n+                return projectTimezone\n+            case SparklineTimezone.Device:\n+            default:\n+                return undefined // undefined means local\n+        }\n+    }, [sparklineTimezone, projectTimezone])\n+\n+    // Build timezone options, deduplicating if any match\n+    const timezoneOptions = useMemo(() => {\n+        const options: { value: SparklineTimezone; label: string }[] = [{ value: SparklineTimezone.UTC, label: 'UTC' }]\n+\n+        const projectTzLabel = shortTimeZone(projectTimezone) ?? projectTimezone\n+        if (projectTimezone !== 'UTC') {\n+            options.push({ value: SparklineTimezone.Project, label: `Project (${projectTzLabel})` })\n+        }\n+\n+        if (deviceTimezone && deviceTimezone !== 'UTC' && deviceTimezone !== projectTzLabel) {\n+            options.push({ value: SparklineTimezone.Device, label: `Device (${deviceTimezone})` })\n+        }\n+\n+        return options\n+    }, [projectTimezone, deviceTimezone])\n+\n+    const showTimezoneSelector = timezoneOptions.length > 1\n+\n+    const { timeUnit, tickFormat } = useMemo(() => {\n+        if (!sparklineData.dates.length) {\n+            return { timeUnit: 'hour' as const, tickFormat: 'HH:mm:ss' }\n+        }\n+        const firstDate = dayjs(sparklineData.dates[0])\n+        const lastDate = dayjs(sparklineData.dates[sparklineData.dates.length - 1])\n+        const hoursDiff = lastDate.diff(firstDate, 'hours')\n+\n+        if (hoursDiff <= 1) {\n+            return { timeUnit: 'second' as const, tickFormat: 'HH:mm:ss' }\n+        } else if (hoursDiff <= 6) {\n+            return { timeUnit: 'minute' as const, tickFormat: 'HH:mm:ss' }\n+        } else if (hoursDiff <= 48) {\n+            return { timeUnit: 'hour' as const, tickFormat: 'HH:mm' }\n+        }\n+        return { timeUnit: 'day' as const, tickFormat: 'D MMM HH:mm' }\n+    }, [sparklineData.dates])\n+\n+    const withXScale = useCallback(\n+        (scale: AnyScaleOptions): AnyScaleOptions => {\n+            return {\n+                ...scale,\n+                type: 'timeseries',\n+                ticks: {\n+                    display: true,\n+                    maxRotation: 0,\n+                    maxTicksLimit: 6,\n+                    font: {\n+                        size: 10,\n+                        lineHeight: 1,\n+                    },\n+                    callback: function (value: string | number) {\n+                        const d = activeTimezone ? dayjs(value).tz(activeTimezone) : dayjs(value)\n+                        return d.format(tickFormat)\n+                    },\n+                },\n+                time: {\n+                    unit: timeUnit,\n+                },\n+            } as AnyScaleOptions\n+        },\n+        [timeUnit, tickFormat, activeTimezone]\n+    )\n+\n+    const renderLabel = useCallback(\n+        (label: string): string => {\n+            const d = activeTimezone ? dayjs(label).tz(activeTimezone) : dayjs(label)\n+            const tz = activeTimezone === 'UTC' ? 'UTC' : (shortTimeZone(activeTimezone, d.toDate()) ?? 'Local')\n+            return `${d.format('D MMM YYYY HH:mm:ss')} ${tz}`\n+        },\n+        [activeTimezone]\n+    )\n+\n+    const sparklineLabels = useMemo(() => {\n+        return sparklineData.dates.map((date) => dayjs(date).toISOString())\n+    }, [sparklineData.dates])\n+\n+    const onSelectionChange = useCallback(\n+        (selection: { startIndex: number; endIndex: number }): void => {\n+            setDateRangeFromSparkline(selection.startIndex, selection.endIndex)\n+        },\n+        [setDateRangeFromSparkline]\n+    )\n+\n+    return (\n+        <div className=\"relative h-40 flex flex-col\">\n+            {showTimezoneSelector && (\n+                <div className=\"absolute top-1 right-1 z-10\">\n+                    <LemonSelect\n+                        size=\"xsmall\"\n+                        value={sparklineTimezone}\n+                        onChange={(value) => value && setSparklineTimezone(value)}\n+                        options={timezoneOptions}\n+                    />\n+                </div>\n+            )}\n+            {sparklineData.data.length > 0 ? (\n+                <Sparkline\n+                    labels={sparklineLabels}\n+                    data={sparklineData.data}\n+                    className=\"w-full flex-1\"\n+                    onSelectionChange={onSelectionChange}\n+                    withXScale={withXScale}\n+                    renderLabel={renderLabel}\n+                />\n+            ) : !sparklineLoading ? (\n+                <div className=\"flex-1 text-muted flex items-center justify-center\">No results matching filters</div>\n+            ) : null}\n+            {sparklineLoading && <SpinnerOverlay />}\n+        </div>\n+    )\n+}\ndiff --git a/products/logs/frontend/logsLogic.test.ts b/products/logs/frontend/logsLogic.test.ts\nindex ff3d7aa8c9747..d8a6a00251a4a 100644\n--- a/products/logs/frontend/logsLogic.test.ts\n+++ b/products/logs/frontend/logsLogic.test.ts\n@@ -3,7 +3,7 @@ import { expectLogic } from 'kea-test-utils'\n import { LogMessage } from '~/queries/schema/schema-general'\n import { initKeaTests } from '~/test/init'\n \n-import { logsLogic } from './logsLogic'\n+import { SparklineTimezone, logsLogic } from './logsLogic'\n \n const createMockLog = (uuid: string): LogMessage => ({\n     uuid,\n@@ -194,4 +194,24 @@ describe('logsLogic', () => {\n             })\n         })\n     })\n+\n+    describe('sparklineTimezone', () => {\n+        it('updates when setSparklineTimezone is called', async () => {\n+            await expectLogic(logic, () => {\n+                logic.actions.setSparklineTimezone(SparklineTimezone.Device)\n+            })\n+                .toDispatchActions(['setSparklineTimezone'])\n+                .toMatchValues({\n+                    sparklineTimezone: SparklineTimezone.Device,\n+                })\n+\n+            await expectLogic(logic, () => {\n+                logic.actions.setSparklineTimezone(SparklineTimezone.UTC)\n+            })\n+                .toDispatchActions(['setSparklineTimezone'])\n+                .toMatchValues({\n+                    sparklineTimezone: SparklineTimezone.UTC,\n+                })\n+        })\n+    })\n })\ndiff --git a/products/logs/frontend/logsLogic.tsx b/products/logs/frontend/logsLogic.tsx\nindex 3260c948007fe..a0b377414b930 100644\n--- a/products/logs/frontend/logsLogic.tsx\n+++ b/products/logs/frontend/logsLogic.tsx\n@@ -38,6 +38,12 @@ const NEW_QUERY_STARTED_ERROR_MESSAGE = 'new query started' as const\n const DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS = 1000\n const DEFAULT_LIVE_TAIL_POLL_INTERVAL_MAX_MS = 5000\n \n+export enum SparklineTimezone {\n+    UTC = 'utc',\n+    Project = 'project',\n+    Device = 'device',\n+}\n+\n const parseLogAttributes = (logs: LogMessage[]): void => {\n     logs.forEach((row) => {\n         Object.keys(row.attributes).forEach((key) => {\n@@ -257,6 +263,7 @@ export const logsLogic = kea<logsLogicType>([\n         expireLiveTail: () => true,\n         setLiveTailExpired: (liveTailExpired: boolean) => ({ liveTailExpired }),\n         addLogsToSparkline: (logs: LogMessage[]) => logs,\n+        setSparklineTimezone: (sparklineTimezone: SparklineTimezone) => ({ sparklineTimezone }),\n     }),\n \n     reducers({\n@@ -408,6 +415,13 @@ export const logsLogic = kea<logsLogicType>([\n                 runQuery: () => false,\n             },\n         ],\n+        sparklineTimezone: [\n+            SparklineTimezone.UTC as SparklineTimezone,\n+            { persist: true },\n+            {\n+                setSparklineTimezone: (_, { sparklineTimezone }) => sparklineTimezone,\n+            },\n+        ],\n         liveTailPollInterval: [\n             DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS as number,\n             {\n",
        "pr_mirror": "PostHog__posthog.main"
    }
}