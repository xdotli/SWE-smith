{
    "cost": 0.26959500000000003,
    "rewrites": {
        "PostHog__posthog.main/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts": {
            "output": "import { mockProducerObserver } from '../../../tests/helpers/mocks/producer.mock'\n\nimport { HogFlow } from '~/schema/hogflow'\n\nimport { createOrganization, createTeam, getFirstTeam, getTeam, resetTestDatabase } from '../../../tests/helpers/sql'\nimport { Hub, Team } from '../../types'\nimport { closeHub, createHub } from '../../utils/db/hub'\nimport { FixtureHogFlowBuilder } from '../_tests/builders/hogflow.builder'\nimport { HOG_EXAMPLES, HOG_FILTERS_EXAMPLES, HOG_INPUTS_EXAMPLES } from '../_tests/examples'\nimport {\n    insertHogFunction as _insertHogFunction,\n    createHogExecutionGlobals,\n    createIncomingEvent,\n    createInternalEvent,\n    createKafkaMessage,\n} from '../_tests/fixtures'\nimport { insertHogFlow as _insertHogFlow } from '../_tests/fixtures-hogflows'\nimport { CyclotronJobQueue } from '../services/job-queue/job-queue'\nimport { HogWatcherState } from '../services/monitoring/hog-watcher.service'\nimport { HogFunctionInvocationGlobals, HogFunctionType } from '../types'\nimport { CdpEventsConsumer } from './cdp-events.consumer'\nimport { CdpInternalEventsConsumer } from './cdp-internal-event.consumer'\n\njest.setTimeout(1000)\n\n/**\n * NOTE: The internal and normal events consumers are very similar so we can test them together\n */\ndescribe.each([\n    [CdpEventsConsumer.name, CdpEventsConsumer, 'destination' as const],\n    [CdpInternalEventsConsumer.name, CdpInternalEventsConsumer, 'internal_destination' as const],\n])('%s', (_name, Consumer, hogType) => {\n    let processor: CdpEventsConsumer | CdpInternalEventsConsumer\n    let hub: Hub\n    let team: Team\n    let team2: Team\n    let mockQueueInvocations: jest.Mock\n\n    const insertHogFunction = async (hogFunction: Partial<HogFunctionType>) => {\n        const teamId = hogFunction.team_id ?? team.id\n        const item = await _insertHogFunction(hub.postgres, teamId, {\n            ...hogFunction,\n            type: hogType,\n        })\n        // Trigger the reload that django would do\n        processor['hogFunctionManager']['onHogFunctionsReloaded'](teamId, [item.id])\n        return item\n    }\n\n    beforeEach(async () => {\n        await resetTestDatabase()\n        hub = await createHub()\n        team = await getFirstTeam(hub)\n        const otherOrganizationId = await createOrganization(hub.postgres)\n        const team2Id = await createTeam(hub.postgres, otherOrganizationId)\n        team2 = (await getTeam(hub, team2Id))!\n\n        processor = new Consumer(hub)\n\n        // NOTE: We don't want to actually connect to Kafka for these tests as it is slow and we are testing the core logic only\n        processor['kafkaConsumer'] = {\n            connect: jest.fn(),\n            disconnect: jest.fn(),\n            isHealthy: jest.fn(),\n        } as any\n\n        processor['cyclotronJobQueue'] = {\n            queueInvocations: jest.fn(),\n            startAsProducer: jest.fn(() => Promise.resolve()),\n            stop: jest.fn(),\n        } as unknown as jest.Mocked<CyclotronJobQueue>\n\n        mockQueueInvocations = jest.mocked(processor['cyclotronJobQueue']['queueInvocations'])\n\n        await processor.start()\n    })\n\n    afterEach(async () => {\n        jest.setTimeout(10000)\n        await processor.stop()\n        await closeHub(hub)\n    })\n\n    afterAll(() => {\n        jest.useRealTimers()\n    })\n\n    describe('team filtering', () => {\n        it('should not parse events for teams without hog functions', async () => {\n            await insertHogFunction({\n                team_id: team.id,\n                ...HOG_EXAMPLES.simple_fetch,\n                ...HOG_INPUTS_EXAMPLES.simple_fetch,\n                ...HOG_FILTERS_EXAMPLES.no_filters,\n            })\n\n            const events =\n                processor instanceof CdpInternalEventsConsumer\n                    ? [\n                          createKafkaMessage(createInternalEvent(team.id, {})),\n                          createKafkaMessage(createInternalEvent(team2.id, {})),\n                      ]\n                    : [\n                          createKafkaMessage(createIncomingEvent(team.id, {})),\n                          createKafkaMessage(createIncomingEvent(team2.id, {})),\n                      ]\n            const invocations = await processor._parseKafkaBatch(events)\n            expect(invocations).toHaveLength(1)\n            expect(invocations[0].project.id).toBe(team.id)\n\n            await insertHogFunction({\n                team_id: team2.id,\n                ...HOG_EXAMPLES.simple_fetch,\n                ...HOG_INPUTS_EXAMPLES.simple_fetch,\n                ...HOG_FILTERS_EXAMPLES.no_filters,\n            })\n\n            const invocations2 = await processor._parseKafkaBatch(events)\n            expect(invocations2).toHaveLength(2)\n        })\n    })\n\n    describe('general event processing', () => {\n        describe('common processing', () => {\n            let fnFetchNoFilters: HogFunctionType\n            let fnPrinterPageviewFilters: HogFunctionType\n            let globals: HogFunctionInvocationGlobals\n\n            beforeEach(async () => {\n                fnFetchNoFilters = await insertHogFunction({\n                    ...HOG_EXAMPLES.simple_fetch,\n                    ...HOG_INPUTS_EXAMPLES.simple_fetch,\n                    ...HOG_FILTERS_EXAMPLES.no_filters,\n                })\n\n                fnPrinterPageviewFilters = await insertHogFunction({\n                    ...HOG_EXAMPLES.input_printer,\n                    ...HOG_INPUTS_EXAMPLES.secret_inputs,\n                    ...HOG_FILTERS_EXAMPLES.pageview_or_autocapture_filter,\n                })\n\n                globals = createHogExecutionGlobals({\n                    project: {\n                        id: team.id,\n                    } as any,\n                    event: {\n                        uuid: 'b3a1fe86-b10c-43cc-acaf-d208977608d0',\n                        event: '$pageview',\n                        properties: {\n                            $current_url: 'https://posthog.com',\n                            $lib_version: '1.0.0',\n                        },\n                    } as any,\n                })\n            })\n\n            const matchInvocation = (hogFunction: HogFunctionType, globals: HogFunctionInvocationGlobals) => {\n                return {\n                    hogFunction: {\n                        id: hogFunction.id,\n                    },\n                    state: {\n                        globals: {\n                            event: globals.event,\n                        },\n                    },\n                }\n            }\n\n            it('should process events', async () => {\n                const { invocations } = await processor.processBatch([globals])\n\n                expect(invocations).toHaveLength(2)\n                expect(invocations).toMatchObject([\n                    matchInvocation(fnFetchNoFilters, globals),\n                    matchInvocation(fnPrinterPageviewFilters, globals),\n                ])\n\n                // Verify Cyclotron jobs\n                expect(mockQueueInvocations).toHaveBeenCalledWith(invocations)\n            })\n\n            it('should log correct metrics', async () => {\n                const { invocations } = await processor.processBatch([globals])\n\n                expect(invocations).toHaveLength(2)\n                expect(invocations).toMatchObject([\n                    matchInvocation(fnFetchNoFilters, globals),\n                    matchInvocation(fnPrinterPageviewFilters, globals),\n                ])\n\n                expect(mockQueueInvocations).toHaveBeenCalledWith(invocations)\n\n                expect(\n                    mockProducerObserver.getProducedKafkaMessagesForTopic('clickhouse_app_metrics2_test')\n                ).toMatchObject(\n                    [\n                        {\n                            key: expect.any(String),\n                            topic: 'clickhouse_app_metrics2_test',\n                            value: {\n                                app_source: 'hog_function',\n                                app_source_id: fnFetchNoFilters.id,\n                                count: 1,\n                                metric_kind: 'other',\n                                metric_name: 'triggered',\n                                team_id: 2,\n                                timestamp: expect.any(String),\n                            },\n                        },\n                        hogType === 'destination' && {\n                            key: expect.any(String),\n                            topic: 'clickhouse_app_metrics2_test',\n                            value: {\n                                app_source: 'hog_function',\n                                app_source_id: fnFetchNoFilters.id,\n                                count: 1,\n                                metric_kind: 'billing',\n                                metric_name: 'billable_invocation',\n                                team_id: 2,\n                                timestamp: expect.any(String),\n                            },\n                        },\n                        {\n                            key: expect.any(String),\n                            topic: 'clickhouse_app_metrics2_test',\n                            value: {\n                                app_source: 'hog_function',\n                                app_source_id: fnPrinterPageviewFilters.id,\n                                count: 1,\n                                metric_kind: 'other',\n                                metric_name: 'triggered',\n                                team_id: 2,\n                                timestamp: expect.any(String),\n                            },\n                        },\n                        hogType === 'destination' && {\n                            key: expect.any(String),\n                            topic: 'clickhouse_app_metrics2_test',\n                            value: {\n                                app_source: 'hog_function',\n                                app_source_id: fnPrinterPageviewFilters.id,\n                                count: 1,\n                                metric_kind: 'billing',\n                                metric_name: 'billable_invocation',\n                                team_id: 2,\n                                timestamp: expect.any(String),\n                            },\n                        },\n                    ].filter((x) => !!x)\n                )\n            })\n\n            it(\"should filter out functions that don't match the filter\", async () => {\n                globals.event.properties.$current_url = 'https://nomatch.com'\n\n                const { invocations } = await processor.processBatch([globals])\n\n                expect(invocations).toHaveLength(1)\n                expect(invocations).toMatchObject([matchInvocation(fnFetchNoFilters, globals)])\n\n                // Verify only one Cyclotron job is created (for fnFetchNoFilters)\n                expect(mockQueueInvocations).toHaveBeenCalledWith(invocations)\n\n                // Still verify the metric for the filtered function\n                expect(\n                    mockProducerObserver.getProducedKafkaMessagesForTopic('clickhouse_app_metrics2_test')\n                ).toMatchObject([\n                    {\n                        key: expect.any(String),\n                        topic: 'clickhouse_app_metrics2_test',\n                        value: {\n                            app_source: 'hog_function',\n                            app_source_id: fnPrinterPageviewFilters.id,\n                            count: 1,\n                            metric_kind: 'other',\n                            metric_name: 'filtered',\n                            team_id: 2,\n                            timestamp: expect.any(String),\n                        },\n                    },\n                    {\n                        key: expect.any(String),\n                        topic: 'clickhouse_app_metrics2_test',\n                        value: {\n                            app_source: 'hog_function',\n                            app_source_id: fnFetchNoFilters.id,\n                            count: 1,\n                            metric_kind: 'other',\n                            metric_name: 'triggered',\n                            team_id: 2,\n                            timestamp: expect.any(String),\n                        },\n                    },\n                    ...(hogType !== 'destination'\n                        ? []\n                        : [\n                              {\n                                  key: expect.any(String),\n                                  topic: 'clickhouse_app_metrics2_test',\n                                  value: {\n                                      app_source: 'hog_function',\n                                      app_source_id: fnFetchNoFilters.id,\n                                      count: 1,\n                                      metric_kind: 'billing',\n                                      metric_name: 'billable_invocation',\n                                      team_id: 2,\n                                      timestamp: expect.any(String),\n                                  },\n                              },\n                          ]),\n                ])\n            })\n\n            it('should filter out functions that are disabled', async () => {\n                await processor.hogWatcher.forceStateChange(fnFetchNoFilters, HogWatcherState.disabled)\n                await processor.hogWatcher.forceStateChange(fnPrinterPageviewFilters, HogWatcherState.disabled)\n\n                const { invocations } = await processor.processBatch([globals])\n\n                expect(invocations).toHaveLength(0)\n                expect(mockProducerObserver.produceSpy).toHaveBeenCalledTimes(2)\n\n                expect(mockProducerObserver.getProducedKafkaMessages()).toMatchObject([\n                    {\n                        topic: 'clickhouse_app_metrics2_test',\n                        value: {\n                            app_source: 'hog_function',\n                            app_source_id: fnFetchNoFilters.id,\n                            count: 1,\n                            metric_kind: 'failure',\n                            metric_name: 'disabled_permanently',\n                            team_id: 2,\n                        },\n                    },\n                    {\n                        topic: 'clickhouse_app_metrics2_test',\n                        value: {\n                            app_source: 'hog_function',\n                            app_source_id: fnPrinterPageviewFilters.id,\n                            count: 1,\n                            metric_kind: 'failure',\n                            metric_name: 'disabled_permanently',\n                            team_id: 2,\n                        },\n                    },\n                ])\n            })\n        })\n\n        describe('filtering errors', () => {\n            let globals: HogFunctionInvocationGlobals\n\n            beforeEach(() => {\n                globals = createHogExecutionGlobals({\n                    project: {\n                        id: team.id,\n                    } as any,\n                    event: {\n                        uuid: 'b3a1fe86-b10c-43cc-acaf-d208977608d0',\n                        event: '$pageview',\n                        properties: {\n                            $current_url: 'https://posthog.com',\n                            $lib_version: '1.0.0',\n                        },\n                    } as any,\n                })\n            })\n\n            it('should filter out functions that error while filtering', async () => {\n                const erroringFunction = await insertHogFunction({\n                    ...HOG_EXAMPLES.input_printer,\n                    ...HOG_INPUTS_EXAMPLES.secret_inputs,\n                    ...HOG_FILTERS_EXAMPLES.broken_filters,\n                })\n                await processor.processBatch([globals])\n                expect(mockProducerObserver.getProducedKafkaMessages()).toMatchObject([\n                    {\n                        key: expect.any(String),\n                        topic: 'clickhouse_app_metrics2_test',\n                        value: {\n                            app_source: 'hog_function',\n                            app_source_id: erroringFunction.id,\n                            count: 1,\n                            metric_kind: 'other",
            "output_extracted": "import { mockProducerObserver } from '../../../tests/helpers/mocks/producer.mock'\n\nimport { HogFlow } from '~/schema/hogflow'\n\nimport { createOrganization, createTeam, getFirstTeam, getTeam, resetTestDatabase } from '../../../tests/helpers/sql'\nimport { Hub, Team } from '../../types'\nimport { closeHub, createHub } from '../../utils/db/hub'\nimport { FixtureHogFlowBuilder } from '../_tests/builders/hogflow.builder'\nimport { HOG_EXAMPLES, HOG_FILTERS_EXAMPLES, HOG_INPUTS_EXAMPLES } from '../_tests/examples'\nimport {\n    insertHogFunction as _insertHogFunction,\n    createHogExecutionGlobals,\n    createIncomingEvent,\n    createInternalEvent,\n    createKafkaMessage,\n} from '../_tests/fixtures'\nimport { insertHogFlow as _insertHogFlow } from '../_tests/fixtures-hogflows'\nimport { CyclotronJobQueue } from '../services/job-queue/job-queue'\nimport { HogWatcherState } from '../services/monitoring/hog-watcher.service'\nimport { HogFunctionInvocationGlobals, HogFunctionType } from '../types'\nimport { CdpEventsConsumer } from './cdp-events.consumer'\nimport { CdpInternalEventsConsumer } from './cdp-internal-event.consumer'\n\njest.setTimeout(1000)\n\n/**\n * NOTE: The internal and normal events consumers are very similar so we can test them together\n */\ndescribe.each([\n    [CdpEventsConsumer.name, CdpEventsConsumer, 'destination' as const],\n    [CdpInternalEventsConsumer.name, CdpInternalEventsConsumer, 'internal_destination' as const],\n])('%s', (_name, Consumer, hogType) => {\n    let processor: CdpEventsConsumer | CdpInternalEventsConsumer\n    let hub: Hub\n    let team: Team\n    let team2: Team\n    let mockQueueInvocations: jest.Mock\n\n    const insertHogFunction = async (hogFunction: Partial<HogFunctionType>) => {\n        const teamId = hogFunction.team_id ?? team.id\n        const item = await _insertHogFunction(hub.postgres, teamId, {\n            ...hogFunction,\n            type: hogType,\n        })\n        // Trigger the reload that django would do\n        processor['hogFunctionManager']['onHogFunctionsReloaded'](teamId, [item.id])\n        return item\n    }\n\n    beforeEach(async () => {\n        await resetTestDatabase()\n        hub = await createHub()\n        team = await getFirstTeam(hub)\n        const otherOrganizationId = await createOrganization(hub.postgres)\n        const team2Id = await createTeam(hub.postgres, otherOrganizationId)\n        team2 = (await getTeam(hub, team2Id))!\n\n        processor = new Consumer(hub)\n\n        // NOTE: We don't want to actually connect to Kafka for these tests as it is slow and we are testing the core logic only\n        processor['kafkaConsumer'] = {\n            connect: jest.fn(),\n            disconnect: jest.fn(),\n            isHealthy: jest.fn(),\n        } as any\n\n        processor['cyclotronJobQueue'] = {\n            queueInvocations: jest.fn(),\n            startAsProducer: jest.fn(() => Promise.resolve()),\n            stop: jest.fn(),\n        } as unknown as jest.Mocked<CyclotronJobQueue>\n\n        mockQueueInvocations = jest.mocked(processor['cyclotronJobQueue']['queueInvocations'])\n\n        await processor.start()\n    })\n\n    afterEach(async () => {\n        jest.setTimeout(10000)\n        await processor.stop()\n        await closeHub(hub)\n    })\n\n    afterAll(() => {\n        jest.useRealTimers()\n    })\n\n    describe('team filtering', () => {\n        it('should not parse events for teams without hog functions', async () => {\n            await insertHogFunction({\n                team_id: team.id,\n                ...HOG_EXAMPLES.simple_fetch,\n                ...HOG_INPUTS_EXAMPLES.simple_fetch,\n                ...HOG_FILTERS_EXAMPLES.no_filters,\n            })\n\n            const events =\n                processor instanceof CdpInternalEventsConsumer\n                    ? [\n                          createKafkaMessage(createInternalEvent(team.id, {})),\n                          createKafkaMessage(createInternalEvent(team2.id, {})),\n                      ]\n                    : [\n                          createKafkaMessage(createIncomingEvent(team.id, {})),\n                          createKafkaMessage(createIncomingEvent(team2.id, {})),\n                      ]\n            const invocations = await processor._parseKafkaBatch(events)\n            expect(invocations).toHaveLength(1)\n            expect(invocations[0].project.id).toBe(team.id)\n\n            await insertHogFunction({\n                team_id: team2.id,\n                ...HOG_EXAMPLES.simple_fetch,\n                ...HOG_INPUTS_EXAMPLES.simple_fetch,\n                ...HOG_FILTERS_EXAMPLES.no_filters,\n            })\n\n            const invocations2 = await processor._parseKafkaBatch(events)\n            expect(invocations2).toHaveLength(2)\n        })\n    })\n\n    describe('general event processing', () => {\n        describe('common processing', () => {\n            let fnFetchNoFilters: HogFunctionType\n            let fnPrinterPageviewFilters: HogFunctionType\n            let globals: HogFunctionInvocationGlobals\n\n            beforeEach(async () => {\n                fnFetchNoFilters = await insertHogFunction({\n                    ...HOG_EXAMPLES.simple_fetch,\n                    ...HOG_INPUTS_EXAMPLES.simple_fetch,\n                    ...HOG_FILTERS_EXAMPLES.no_filters,\n                })\n\n                fnPrinterPageviewFilters = await insertHogFunction({\n                    ...HOG_EXAMPLES.input_printer,\n                    ...HOG_INPUTS_EXAMPLES.secret_inputs,\n                    ...HOG_FILTERS_EXAMPLES.pageview_or_autocapture_filter,\n                })\n\n                globals = createHogExecutionGlobals({\n                    project: {\n                        id: team.id,\n                    } as any,\n                    event: {\n                        uuid: 'b3a1fe86-b10c-43cc-acaf-d208977608d0',\n                        event: '$pageview',\n                        properties: {\n                            $current_url: 'https://posthog.com',\n                            $lib_version: '1.0.0',\n                        },\n                    } as any,\n                })\n            })\n\n            const matchInvocation = (hogFunction: HogFunctionType, globals: HogFunctionInvocationGlobals) => {\n                return {\n                    hogFunction: {\n                        id: hogFunction.id,\n                    },\n                    state: {\n                        globals: {\n                            event: globals.event,\n                        },\n                    },\n                }\n            }\n\n            it('should process events', async () => {\n                const { invocations } = await processor.processBatch([globals])\n\n                expect(invocations).toHaveLength(2)\n                expect(invocations).toMatchObject([\n                    matchInvocation(fnFetchNoFilters, globals),\n                    matchInvocation(fnPrinterPageviewFilters, globals),\n                ])\n\n                // Verify Cyclotron jobs\n                expect(mockQueueInvocations).toHaveBeenCalledWith(invocations)\n            })\n\n            it('should log correct metrics', async () => {\n                const { invocations } = await processor.processBatch([globals])\n\n                expect(invocations).toHaveLength(2)\n                expect(invocations).toMatchObject([\n                    matchInvocation(fnFetchNoFilters, globals),\n                    matchInvocation(fnPrinterPageviewFilters, globals),\n                ])\n\n                expect(mockQueueInvocations).toHaveBeenCalledWith(invocations)\n\n                expect(\n                    mockProducerObserver.getProducedKafkaMessagesForTopic('clickhouse_app_metrics2_test')\n                ).toMatchObject(\n                    [\n                        {\n                            key: expect.any(String),\n                            topic: 'clickhouse_app_metrics2_test',\n                            value: {\n                                app_source: 'hog_function',\n                                app_source_id: fnFetchNoFilters.id,\n                                count: 1,\n                                metric_kind: 'other',\n                                metric_name: 'triggered',\n                                team_id: 2,\n                                timestamp: expect.any(String),\n                            },\n                        },\n                        hogType === 'destination' && {\n                            key: expect.any(String),\n                            topic: 'clickhouse_app_metrics2_test',\n                            value: {\n                                app_source: 'hog_function',\n                                app_source_id: fnFetchNoFilters.id,\n                                count: 1,\n                                metric_kind: 'billing',\n                                metric_name: 'billable_invocation',\n                                team_id: 2,\n                                timestamp: expect.any(String),\n                            },\n                        },\n                        {\n                            key: expect.any(String),\n                            topic: 'clickhouse_app_metrics2_test',\n                            value: {\n                                app_source: 'hog_function',\n                                app_source_id: fnPrinterPageviewFilters.id,\n                                count: 1,\n                                metric_kind: 'other',\n                                metric_name: 'triggered',\n                                team_id: 2,\n                                timestamp: expect.any(String),\n                            },\n                        },\n                        hogType === 'destination' && {\n                            key: expect.any(String),\n                            topic: 'clickhouse_app_metrics2_test',\n                            value: {\n                                app_source: 'hog_function',\n                                app_source_id: fnPrinterPageviewFilters.id,\n                                count: 1,\n                                metric_kind: 'billing',\n                                metric_name: 'billable_invocation',\n                                team_id: 2,\n                                timestamp: expect.any(String),\n                            },\n                        },\n                    ].filter((x) => !!x)\n                )\n            })\n\n            it(\"should filter out functions that don't match the filter\", async () => {\n                globals.event.properties.$current_url = 'https://nomatch.com'\n\n                const { invocations } = await processor.processBatch([globals])\n\n                expect(invocations).toHaveLength(1)\n                expect(invocations).toMatchObject([matchInvocation(fnFetchNoFilters, globals)])\n\n                // Verify only one Cyclotron job is created (for fnFetchNoFilters)\n                expect(mockQueueInvocations).toHaveBeenCalledWith(invocations)\n\n                // Still verify the metric for the filtered function\n                expect(\n                    mockProducerObserver.getProducedKafkaMessagesForTopic('clickhouse_app_metrics2_test')\n                ).toMatchObject([\n                    {\n                        key: expect.any(String),\n                        topic: 'clickhouse_app_metrics2_test',\n                        value: {\n                            app_source: 'hog_function',\n                            app_source_id: fnPrinterPageviewFilters.id,\n                            count: 1,\n                            metric_kind: 'other',\n                            metric_name: 'filtered',\n                            team_id: 2,\n                            timestamp: expect.any(String),\n                        },\n                    },\n                    {\n                        key: expect.any(String),\n                        topic: 'clickhouse_app_metrics2_test',\n                        value: {\n                            app_source: 'hog_function',\n                            app_source_id: fnFetchNoFilters.id,\n                            count: 1,\n                            metric_kind: 'other',\n                            metric_name: 'triggered',\n                            team_id: 2,\n                            timestamp: expect.any(String),\n                        },\n                    },\n                    ...(hogType !== 'destination'\n                        ? []\n                        : [\n                              {\n                                  key: expect.any(String),\n                                  topic: 'clickhouse_app_metrics2_test',\n                                  value: {\n                                      app_source: 'hog_function',\n                                      app_source_id: fnFetchNoFilters.id,\n                                      count: 1,\n                                      metric_kind: 'billing',\n                                      metric_name: 'billable_invocation',\n                                      team_id: 2,\n                                      timestamp: expect.any(String),\n                                  },\n                              },\n                          ]),\n                ])\n            })\n\n            it('should filter out functions that are disabled', async () => {\n                await processor.hogWatcher.forceStateChange(fnFetchNoFilters, HogWatcherState.disabled)\n                await processor.hogWatcher.forceStateChange(fnPrinterPageviewFilters, HogWatcherState.disabled)\n\n                const { invocations } = await processor.processBatch([globals])\n\n                expect(invocations).toHaveLength(0)\n                expect(mockProducerObserver.produceSpy).toHaveBeenCalledTimes(2)\n\n                expect(mockProducerObserver.getProducedKafkaMessages()).toMatchObject([\n                    {\n                        topic: 'clickhouse_app_metrics2_test',\n                        value: {\n                            app_source: 'hog_function',\n                            app_source_id: fnFetchNoFilters.id,\n                            count: 1,\n                            metric_kind: 'failure',\n                            metric_name: 'disabled_permanently',\n                            team_id: 2,\n                        },\n                    },\n                    {\n                        topic: 'clickhouse_app_metrics2_test',\n                        value: {\n                            app_source: 'hog_function',\n                            app_source_id: fnPrinterPageviewFilters.id,\n                            count: 1,\n                            metric_kind: 'failure',\n                            metric_name: 'disabled_permanently',\n                            team_id: 2,\n                        },\n                    },\n                ])\n            })\n        })\n\n        describe('filtering errors', () => {\n            let globals: HogFunctionInvocationGlobals\n\n            beforeEach(() => {\n                globals = createHogExecutionGlobals({\n                    project: {\n                        id: team.id,\n                    } as any,\n                    event: {\n                        uuid: 'b3a1fe86-b10c-43cc-acaf-d208977608d0',\n                        event: '$pageview',\n                        properties: {\n                            $current_url: 'https://posthog.com',\n                            $lib_version: '1.0.0',\n                        },\n                    } as any,\n                })\n            })\n\n            it('should filter out functions that error while filtering', async () => {\n                const erroringFunction = await insertHogFunction({\n                    ...HOG_EXAMPLES.input_printer,\n                    ...HOG_INPUTS_EXAMPLES.secret_inputs,\n                    ...HOG_FILTERS_EXAMPLES.broken_filters,\n                })\n                await processor.processBatch([globals])\n                expect(mockProducerObserver.getProducedKafkaMessages()).toMatchObject([\n                    {\n                        key: expect.any(String),\n                        topic: 'clickhouse_app_metrics2_test',\n                        value: {\n                            app_source: 'hog_function',\n                            app_source_id: erroringFunction.id,\n                            count: 1,\n                            metric_kind: 'other",
            "cost": 0.13686
        },
        "PostHog__posthog.main/plugin-server/src/cdp/consumers/cdp-events.consumer.ts": {
            "output": "import { Message } from 'node-rdkafka'\nimport { Counter } from 'prom-client'\n\nimport { instrumentFn, instrumented } from '~/common/tracing/tracing-utils'\n\nimport { convertToHogFunctionInvocationGlobals } from '../../cdp/utils'\nimport { KAFKA_EVENTS_JSON } from '../../config/kafka-topics'\nimport { KafkaConsumer } from '../../kafka/consumer'\nimport { HealthCheckResult, Hub, RawClickHouseEvent } from '../../types'\nimport { parseJSON } from '../../utils/json-parse'\nimport { logger } from '../../utils/logger'\nimport { captureException } from '../../utils/posthog'\nimport { CyclotronJobQueue } from '../services/job-queue/job-queue'\nimport { HogRateLimiterService } from '../services/monitoring/hog-rate-limiter.service'\nimport { HogWatcherState } from '../services/monitoring/hog-watcher.service'\nimport {\n    CyclotronJobInvocation,\n    CyclotronJobInvocationHogFunction,\n    HogFunctionInvocationGlobals,\n    HogFunctionType,\n    HogFunctionTypeType,\n    MinimalAppMetric,\n} from '../types'\nimport { CdpConsumerBase } from './cdp-base.consumer'\n\nexport const counterParseError = new Counter({\n    name: 'cdp_function_parse_error',\n    help: 'A function invocation was parsed with an error',\n    labelNames: ['error'],\n})\n\nconst counterQuotaLimited = new Counter({\n    name: 'cdp_function_quota_limited',\n    help: 'A function invocation was quota limited',\n    labelNames: ['team_id'],\n})\n\nconst counterRateLimited = new Counter({\n    name: 'cdp_function_rate_limited',\n    help: 'A function invocation was rate limited',\n    labelNames: ['kind'],\n})\n\nconst counterHogFunctionStateOnEvent = new Counter({\n    name: 'cdp_hog_function_state_on_event',\n    help: 'Metric the state of a hog function that matched an event',\n    labelNames: ['state', 'kind'],\n})\n\nexport class CdpEventsConsumer extends CdpConsumerBase {\n    protected name = 'CdpEventsConsumer'\n    protected hogTypes: HogFunctionTypeType[] = ['destination']\n    private cyclotronJobQueue: CyclotronJobQueue\n    protected kafkaConsumer: KafkaConsumer\n\n    private hogRateLimiter: HogRateLimiterService\n\n    constructor(hub: Hub, topic: string = KAFKA_EVENTS_JSON, groupId: string = 'cdp-processed-events-consumer') {\n        super(hub)\n        this.cyclotronJobQueue = new CyclotronJobQueue(hub, 'hog')\n        this.kafkaConsumer = new KafkaConsumer({ groupId, topic })\n        this.hogRateLimiter = new HogRateLimiterService(hub, this.redis)\n    }\n\n    public async processBatch(\n        invocationGlobals: HogFunctionInvocationGlobals[]\n    ): Promise<{ backgroundTask: Promise<any>; invocations: CyclotronJobInvocation[] }> {\n        if (!invocationGlobals.length) {\n            return { backgroundTask: Promise.resolve(), invocations: [] }\n        }\n\n        const invocationsToBeQueued = [\n            ...(await this.createHogFunctionInvocations(invocationGlobals)),\n            ...(await this.createHogFlowInvocations(invocationGlobals)),\n        ]\n\n        return {\n            // This is all IO so we can set them off in the background and start processing the next batch\n            backgroundTask: Promise.all([\n                this.cyclotronJobQueue.queueInvocations(invocationsToBeQueued),\n                this.hogFunctionMonitoringService.flush().catch((err) => {\n                    captureException(err)\n                    logger.error('\ud83d\udd34', 'Error producing queued messages for monitoring', { err })\n                }),\n            ]),\n            invocations: invocationsToBeQueued,\n        }\n    }\n\n    protected filterHogFunction(hogFunction: HogFunctionType): boolean {\n        // By default we filter for those with no filters or filters specifically for events\n        return (hogFunction.filters?.source ?? 'events') === 'events'\n    }\n\n    /**\n     * Finds all matching hog functions for the given globals.\n     * Filters them for their disabled state as well as masking configs\n     */\n    @instrumented('cdpConsumer.handleEachBatch.queueMatchingFunctions')\n    protected async createHogFunctionInvocations(\n        invocationGlobals: HogFunctionInvocationGlobals[]\n    ): Promise<CyclotronJobInvocation[]> {\n        // TODO: Add a helper to hog functions to determine if they require groups or not and then only load those\n        await this.groupsManager.enrichGroups(invocationGlobals)\n\n        const teamsToLoad = [...new Set(invocationGlobals.map((x) => x.project.id))]\n        const [hogFunctionsByTeam, teamsById] = await Promise.all([\n            this.hogFunctionManager.getHogFunctionsForTeams(teamsToLoad, this.hogTypes, this.filterHogFunction),\n            this.hub.teamManager.getTeams(teamsToLoad),\n        ])\n\n        const possibleInvocations = (\n            await Promise.all(\n                invocationGlobals.map(async (globals) => {\n                    const teamHogFunctions = hogFunctionsByTeam[globals.project.id]\n\n                    const { invocations, metrics, logs } = await this.hogExecutor.buildHogFunctionInvocations(\n                        teamHogFunctions,\n                        globals\n                    )\n\n                    this.hogFunctionMonitoringService.queueAppMetrics(metrics, 'hog_function')\n                    this.hogFunctionMonitoringService.queueLogs(logs, 'hog_function')\n                    this.heartbeat()\n\n                    return invocations\n                })\n            )\n        ).flat()\n\n        const states = await instrumentFn('cdpConsumer.handleEachBatch.hogWatcher.getEffectiveStates', async () => {\n            return await this.hogWatcher.getEffectiveStates(possibleInvocations.map((x) => x.hogFunction.id))\n        })\n        const rateLimits = await instrumentFn('cdpConsumer.handleEachBatch.hogRateLimiter.rateLimitMany', async () => {\n            return await this.hogRateLimiter.rateLimitMany(possibleInvocations.map((x) => [x.hogFunction.id, 1]))\n        })\n\n        const validInvocations: CyclotronJobInvocationHogFunction[] = []\n\n        // Iterate over adding them to the list and updating their priority\n        await Promise.all(\n            possibleInvocations.map(async (item, index) => {\n                // Disable invocations for teams that don't have the addon (for now just metric them out..)\n\n                try {\n                    const rateLimit = rateLimits[index][1]\n                    if (rateLimit.isRateLimited) {\n                        counterRateLimited.labels({ kind: 'hog_function' }).inc()\n                        // NOTE: We don't return here as we are just monitoring this feature currently\n                        // this.hogFunctionMonitoringService.queueAppMetric(\n                        //     {\n                        //         team_id: item.teamId,\n                        //         app_source_id: item.functionId,\n                        //         metric_kind: 'failure',\n                        //         metric_name: 'rate_limited',\n                        //         count: 1,\n                        //     },\n                        //     'hog_function'\n                        // )\n                        // return\n                    }\n                } catch (e) {\n                    captureException(e)\n                    logger.error('\ud83d\udd34', 'Error checking rate limit for hog function', { err: e })\n                }\n\n                const isQuotaLimited = await this.hub.quotaLimiting.isTeamQuotaLimited(\n                    item.teamId,\n                    'cdp_trigger_events'\n                )\n\n                // The legacy addon was not usage based so we skip dropping if they are on it\n                const isTeamOnLegacyAddon = !!teamsById[`${item.teamId}`]?.available_features.includes('data_pipelines')\n\n                if (isQuotaLimited && !isTeamOnLegacyAddon) {\n                    counterQuotaLimited.labels({ team_id: item.teamId }).inc()\n\n                    // TODO: Once happy - we add the below code to track a quota limited metric and skip the invocation\n\n                    // this.hogFunctionMonitoringService.queueAppMetric(\n                    //     {\n                    //         team_id: item.teamId,\n                    //         app_source_id: item.functionId,\n                    //         metric_kind: 'failure',\n                    //         metric_name: 'quota_limited',\n                    //         count: 1,\n                    //     },\n                    //     'hog_function'\n                    // )\n                    // return\n                }\n\n                const state = states[item.hogFunction.id].state\n\n                counterHogFunctionStateOnEvent\n                    .labels({\n                        state: HogWatcherState[state],\n                        kind: item.hogFunction.type,\n                    })\n                    .inc()\n\n                if (state === HogWatcherState.disabled) {\n                    this.hogFunctionMonitoringService.queueAppMetric(\n                        {\n                            team_id: item.teamId,\n                            app_source_id: item.functionId,\n                            metric_kind: 'failure',\n                            metric_name: 'disabled_permanently',\n                            count: 1,\n                        },\n                        'hog_function'\n                    )\n                    return\n                }\n\n                if (state === HogWatcherState.degraded) {\n                    item.queuePriority = 2\n                    if (this.hub.CDP_OVERFLOW_QUEUE_ENABLED) {\n                        item.queue = 'hogoverflow'\n                    }\n                }\n\n                validInvocations.push(item)\n            })\n        )\n\n        // Now we can filter by masking configs\n        const { masked, notMasked: notMaskedInvocations } = await this.hogMasker.filterByMasking(validInvocations)\n\n        this.hogFunctionMonitoringService.queueAppMetrics(\n            masked.map((item) => ({\n                team_id: item.teamId,\n                app_source_id: item.functionId,\n                metric_kind: 'other',\n                metric_name: 'masked',\n                count: 1,\n            })),\n            'hog_function'\n        )\n\n        const triggeredInvocationsMetrics: MinimalAppMetric[] = []\n\n        notMaskedInvocations.forEach((item) => {\n            triggeredInvocationsMetrics.push({\n                team_id: item.teamId,\n                app_source_id: item.functionId,\n                metric_kind: 'other',\n                metric_name: 'triggered',\n                count: 1,\n            })\n\n            if (item.hogFunction.type === 'destination') {\n                triggeredInvocationsMetrics.push({\n                    team_id: item.teamId,\n                    app_source_id: item.functionId,\n                    metric_kind: 'billing',\n                    metric_name: 'billable_invocation',\n                    count: 1,\n                })\n            }\n        })\n\n        this.hogFunctionMonitoringService.queueAppMetrics(triggeredInvocationsMetrics, 'hog_function')\n\n        return notMaskedInvocations\n    }\n\n    /**\n     * Finds all matching hog flows for the given globals.\n     * Filters them for their disabled state as well as masking configs\n     */\n    @instrumented('cdpConsumer.handleEachBatch.queueMatchingFlows')\n    protected async createHogFlowInvocations(\n        invocationGlobals: HogFunctionInvocationGlobals[]\n    ): Promise<CyclotronJobInvocation[]> {\n        // TODO: Add back in group enrichment if necessary\n        // await this.groupsManager.enrichGroups(invocationGlobals)\n\n        const teamsToLoad = [...new Set(invocationGlobals.map((x) => x.project.id))]\n        const hogFlowsByTeam = await this.hogFlowManager.getHogFlowsForTeams(teamsToLoad)\n\n        const possibleInvocations = (\n            await Promise.all(\n                invocationGlobals.map(async (globals) => {\n                    const teamHogFlows = hogFlowsByTeam[globals.project.id]\n\n                    const { invocations, metrics, logs } = await this.hogFlowExecutor.buildHogFlowInvocations(\n                        teamHogFlows,\n                        globals\n                    )\n\n                    this.hogFunctionMonitoringService.queueAppMetrics(metrics, 'hog_flow')\n                    this.hogFunctionMonitoringService.queueLogs(logs, 'hog_flow')\n                    this.heartbeat()\n\n                    return invocations\n                })\n            )\n        ).flat()\n\n        const states = await instrumentFn('cdpConsumer.handleEachBatch.hogWatcher.getEffectiveStates', async () => {\n            return await this.hogWatcher.getEffectiveStates(possibleInvocations.map((x) => x.hogFlow.id))\n        })\n        const rateLimits = await instrumentFn('cdpConsumer.handleEachBatch.hogRateLimiter.rateLimitMany', async () => {\n            return await this.hogRateLimiter.rateLimitMany(possibleInvocations.map((x) => [x.hogFlow.id, 1]))\n        })\n        const validInvocations: CyclotronJobInvocation[] = []\n\n        // Iterate over adding them to the list and updating their priority\n        possibleInvocations.forEach((item, index) => {\n            try {\n                const rateLimit = rateLimits[index][1]\n                if (rateLimit.isRateLimited) {\n                    counterRateLimited.labels({ kind: 'hog_flow' }).inc()\n                    this.hogFunctionMonitoringService.queueAppMetric(\n                        {\n                            team_id: item.teamId,\n                            app_source_id: item.functionId,\n                            metric_kind: 'failure',\n                            metric_name: 'rate_limited',\n                            count: 1,\n                        },\n                        'hog_flow'\n                    )\n                    return\n                }\n            } catch (e) {\n                captureException(e)\n                logger.error('\ud83d\udd34', 'Error checking rate limit for hog flow', { err: e })\n            }\n\n            const state = states[item.hogFlow.id].state\n            if (state === HogWatcherState.disabled) {\n                this.hogFunctionMonitoringService.queueAppMetric(\n                    {\n                        team_id: item.teamId,\n                        app_source_id: item.functionId,\n                        metric_kind: 'failure',\n                        metric_name: 'disabled_permanently',\n                        count: 1,\n                    },\n                    'hog_flow'\n                )\n                return\n            }\n\n            if (state === HogWatcherState.degraded) {\n                item.queuePriority = 2\n            }\n\n            validInvocations.push(item)\n        })\n\n        // Now we can filter by masking configs\n        const { masked, notMasked: notMaskedInvocations } = await this.hogMasker.filterByMasking(",
            "output_extracted": "import { Message } from 'node-rdkafka'\nimport { Counter } from 'prom-client'\n\nimport { instrumentFn, instrumented } from '~/common/tracing/tracing-utils'\n\nimport { convertToHogFunctionInvocationGlobals } from '../../cdp/utils'\nimport { KAFKA_EVENTS_JSON } from '../../config/kafka-topics'\nimport { KafkaConsumer } from '../../kafka/consumer'\nimport { HealthCheckResult, Hub, RawClickHouseEvent } from '../../types'\nimport { parseJSON } from '../../utils/json-parse'\nimport { logger } from '../../utils/logger'\nimport { captureException } from '../../utils/posthog'\nimport { CyclotronJobQueue } from '../services/job-queue/job-queue'\nimport { HogRateLimiterService } from '../services/monitoring/hog-rate-limiter.service'\nimport { HogWatcherState } from '../services/monitoring/hog-watcher.service'\nimport {\n    CyclotronJobInvocation,\n    CyclotronJobInvocationHogFunction,\n    HogFunctionInvocationGlobals,\n    HogFunctionType,\n    HogFunctionTypeType,\n    MinimalAppMetric,\n} from '../types'\nimport { CdpConsumerBase } from './cdp-base.consumer'\n\nexport const counterParseError = new Counter({\n    name: 'cdp_function_parse_error',\n    help: 'A function invocation was parsed with an error',\n    labelNames: ['error'],\n})\n\nconst counterQuotaLimited = new Counter({\n    name: 'cdp_function_quota_limited',\n    help: 'A function invocation was quota limited',\n    labelNames: ['team_id'],\n})\n\nconst counterRateLimited = new Counter({\n    name: 'cdp_function_rate_limited',\n    help: 'A function invocation was rate limited',\n    labelNames: ['kind'],\n})\n\nconst counterHogFunctionStateOnEvent = new Counter({\n    name: 'cdp_hog_function_state_on_event',\n    help: 'Metric the state of a hog function that matched an event',\n    labelNames: ['state', 'kind'],\n})\n\nexport class CdpEventsConsumer extends CdpConsumerBase {\n    protected name = 'CdpEventsConsumer'\n    protected hogTypes: HogFunctionTypeType[] = ['destination']\n    private cyclotronJobQueue: CyclotronJobQueue\n    protected kafkaConsumer: KafkaConsumer\n\n    private hogRateLimiter: HogRateLimiterService\n\n    constructor(hub: Hub, topic: string = KAFKA_EVENTS_JSON, groupId: string = 'cdp-processed-events-consumer') {\n        super(hub)\n        this.cyclotronJobQueue = new CyclotronJobQueue(hub, 'hog')\n        this.kafkaConsumer = new KafkaConsumer({ groupId, topic })\n        this.hogRateLimiter = new HogRateLimiterService(hub, this.redis)\n    }\n\n    public async processBatch(\n        invocationGlobals: HogFunctionInvocationGlobals[]\n    ): Promise<{ backgroundTask: Promise<any>; invocations: CyclotronJobInvocation[] }> {\n        if (!invocationGlobals.length) {\n            return { backgroundTask: Promise.resolve(), invocations: [] }\n        }\n\n        const invocationsToBeQueued = [\n            ...(await this.createHogFunctionInvocations(invocationGlobals)),\n            ...(await this.createHogFlowInvocations(invocationGlobals)),\n        ]\n\n        return {\n            // This is all IO so we can set them off in the background and start processing the next batch\n            backgroundTask: Promise.all([\n                this.cyclotronJobQueue.queueInvocations(invocationsToBeQueued),\n                this.hogFunctionMonitoringService.flush().catch((err) => {\n                    captureException(err)\n                    logger.error('\ud83d\udd34', 'Error producing queued messages for monitoring', { err })\n                }),\n            ]),\n            invocations: invocationsToBeQueued,\n        }\n    }\n\n    protected filterHogFunction(hogFunction: HogFunctionType): boolean {\n        // By default we filter for those with no filters or filters specifically for events\n        return (hogFunction.filters?.source ?? 'events') === 'events'\n    }\n\n    /**\n     * Finds all matching hog functions for the given globals.\n     * Filters them for their disabled state as well as masking configs\n     */\n    @instrumented('cdpConsumer.handleEachBatch.queueMatchingFunctions')\n    protected async createHogFunctionInvocations(\n        invocationGlobals: HogFunctionInvocationGlobals[]\n    ): Promise<CyclotronJobInvocation[]> {\n        // TODO: Add a helper to hog functions to determine if they require groups or not and then only load those\n        await this.groupsManager.enrichGroups(invocationGlobals)\n\n        const teamsToLoad = [...new Set(invocationGlobals.map((x) => x.project.id))]\n        const [hogFunctionsByTeam, teamsById] = await Promise.all([\n            this.hogFunctionManager.getHogFunctionsForTeams(teamsToLoad, this.hogTypes, this.filterHogFunction),\n            this.hub.teamManager.getTeams(teamsToLoad),\n        ])\n\n        const possibleInvocations = (\n            await Promise.all(\n                invocationGlobals.map(async (globals) => {\n                    const teamHogFunctions = hogFunctionsByTeam[globals.project.id]\n\n                    const { invocations, metrics, logs } = await this.hogExecutor.buildHogFunctionInvocations(\n                        teamHogFunctions,\n                        globals\n                    )\n\n                    this.hogFunctionMonitoringService.queueAppMetrics(metrics, 'hog_function')\n                    this.hogFunctionMonitoringService.queueLogs(logs, 'hog_function')\n                    this.heartbeat()\n\n                    return invocations\n                })\n            )\n        ).flat()\n\n        const states = await instrumentFn('cdpConsumer.handleEachBatch.hogWatcher.getEffectiveStates', async () => {\n            return await this.hogWatcher.getEffectiveStates(possibleInvocations.map((x) => x.hogFunction.id))\n        })\n        const rateLimits = await instrumentFn('cdpConsumer.handleEachBatch.hogRateLimiter.rateLimitMany', async () => {\n            return await this.hogRateLimiter.rateLimitMany(possibleInvocations.map((x) => [x.hogFunction.id, 1]))\n        })\n\n        const validInvocations: CyclotronJobInvocationHogFunction[] = []\n\n        // Iterate over adding them to the list and updating their priority\n        await Promise.all(\n            possibleInvocations.map(async (item, index) => {\n                // Disable invocations for teams that don't have the addon (for now just metric them out..)\n\n                try {\n                    const rateLimit = rateLimits[index][1]\n                    if (rateLimit.isRateLimited) {\n                        counterRateLimited.labels({ kind: 'hog_function' }).inc()\n                        // NOTE: We don't return here as we are just monitoring this feature currently\n                        // this.hogFunctionMonitoringService.queueAppMetric(\n                        //     {\n                        //         team_id: item.teamId,\n                        //         app_source_id: item.functionId,\n                        //         metric_kind: 'failure',\n                        //         metric_name: 'rate_limited',\n                        //         count: 1,\n                        //     },\n                        //     'hog_function'\n                        // )\n                        // return\n                    }\n                } catch (e) {\n                    captureException(e)\n                    logger.error('\ud83d\udd34', 'Error checking rate limit for hog function', { err: e })\n                }\n\n                const isQuotaLimited = await this.hub.quotaLimiting.isTeamQuotaLimited(\n                    item.teamId,\n                    'cdp_trigger_events'\n                )\n\n                // The legacy addon was not usage based so we skip dropping if they are on it\n                const isTeamOnLegacyAddon = !!teamsById[`${item.teamId}`]?.available_features.includes('data_pipelines')\n\n                if (isQuotaLimited && !isTeamOnLegacyAddon) {\n                    counterQuotaLimited.labels({ team_id: item.teamId }).inc()\n\n                    // TODO: Once happy - we add the below code to track a quota limited metric and skip the invocation\n\n                    // this.hogFunctionMonitoringService.queueAppMetric(\n                    //     {\n                    //         team_id: item.teamId,\n                    //         app_source_id: item.functionId,\n                    //         metric_kind: 'failure',\n                    //         metric_name: 'quota_limited',\n                    //         count: 1,\n                    //     },\n                    //     'hog_function'\n                    // )\n                    // return\n                }\n\n                const state = states[item.hogFunction.id].state\n\n                counterHogFunctionStateOnEvent\n                    .labels({\n                        state: HogWatcherState[state],\n                        kind: item.hogFunction.type,\n                    })\n                    .inc()\n\n                if (state === HogWatcherState.disabled) {\n                    this.hogFunctionMonitoringService.queueAppMetric(\n                        {\n                            team_id: item.teamId,\n                            app_source_id: item.functionId,\n                            metric_kind: 'failure',\n                            metric_name: 'disabled_permanently',\n                            count: 1,\n                        },\n                        'hog_function'\n                    )\n                    return\n                }\n\n                if (state === HogWatcherState.degraded) {\n                    item.queuePriority = 2\n                    if (this.hub.CDP_OVERFLOW_QUEUE_ENABLED) {\n                        item.queue = 'hogoverflow'\n                    }\n                }\n\n                validInvocations.push(item)\n            })\n        )\n\n        // Now we can filter by masking configs\n        const { masked, notMasked: notMaskedInvocations } = await this.hogMasker.filterByMasking(validInvocations)\n\n        this.hogFunctionMonitoringService.queueAppMetrics(\n            masked.map((item) => ({\n                team_id: item.teamId,\n                app_source_id: item.functionId,\n                metric_kind: 'other',\n                metric_name: 'masked',\n                count: 1,\n            })),\n            'hog_function'\n        )\n\n        const triggeredInvocationsMetrics: MinimalAppMetric[] = []\n\n        notMaskedInvocations.forEach((item) => {\n            triggeredInvocationsMetrics.push({\n                team_id: item.teamId,\n                app_source_id: item.functionId,\n                metric_kind: 'other',\n                metric_name: 'triggered',\n                count: 1,\n            })\n\n            if (item.hogFunction.type === 'destination') {\n                triggeredInvocationsMetrics.push({\n                    team_id: item.teamId,\n                    app_source_id: item.functionId,\n                    metric_kind: 'billing',\n                    metric_name: 'billable_invocation',\n                    count: 1,\n                })\n            }\n        })\n\n        this.hogFunctionMonitoringService.queueAppMetrics(triggeredInvocationsMetrics, 'hog_function')\n\n        return notMaskedInvocations\n    }\n\n    /**\n     * Finds all matching hog flows for the given globals.\n     * Filters them for their disabled state as well as masking configs\n     */\n    @instrumented('cdpConsumer.handleEachBatch.queueMatchingFlows')\n    protected async createHogFlowInvocations(\n        invocationGlobals: HogFunctionInvocationGlobals[]\n    ): Promise<CyclotronJobInvocation[]> {\n        // TODO: Add back in group enrichment if necessary\n        // await this.groupsManager.enrichGroups(invocationGlobals)\n\n        const teamsToLoad = [...new Set(invocationGlobals.map((x) => x.project.id))]\n        const hogFlowsByTeam = await this.hogFlowManager.getHogFlowsForTeams(teamsToLoad)\n\n        const possibleInvocations = (\n            await Promise.all(\n                invocationGlobals.map(async (globals) => {\n                    const teamHogFlows = hogFlowsByTeam[globals.project.id]\n\n                    const { invocations, metrics, logs } = await this.hogFlowExecutor.buildHogFlowInvocations(\n                        teamHogFlows,\n                        globals\n                    )\n\n                    this.hogFunctionMonitoringService.queueAppMetrics(metrics, 'hog_flow')\n                    this.hogFunctionMonitoringService.queueLogs(logs, 'hog_flow')\n                    this.heartbeat()\n\n                    return invocations\n                })\n            )\n        ).flat()\n\n        const states = await instrumentFn('cdpConsumer.handleEachBatch.hogWatcher.getEffectiveStates', async () => {\n            return await this.hogWatcher.getEffectiveStates(possibleInvocations.map((x) => x.hogFlow.id))\n        })\n        const rateLimits = await instrumentFn('cdpConsumer.handleEachBatch.hogRateLimiter.rateLimitMany', async () => {\n            return await this.hogRateLimiter.rateLimitMany(possibleInvocations.map((x) => [x.hogFlow.id, 1]))\n        })\n        const validInvocations: CyclotronJobInvocation[] = []\n\n        // Iterate over adding them to the list and updating their priority\n        possibleInvocations.forEach((item, index) => {\n            try {\n                const rateLimit = rateLimits[index][1]\n                if (rateLimit.isRateLimited) {\n                    counterRateLimited.labels({ kind: 'hog_flow' }).inc()\n                    this.hogFunctionMonitoringService.queueAppMetric(\n                        {\n                            team_id: item.teamId,\n                            app_source_id: item.functionId,\n                            metric_kind: 'failure',\n                            metric_name: 'rate_limited',\n                            count: 1,\n                        },\n                        'hog_flow'\n                    )\n                    return\n                }\n            } catch (e) {\n                captureException(e)\n                logger.error('\ud83d\udd34', 'Error checking rate limit for hog flow', { err: e })\n            }\n\n            const state = states[item.hogFlow.id].state\n            if (state === HogWatcherState.disabled) {\n                this.hogFunctionMonitoringService.queueAppMetric(\n                    {\n                        team_id: item.teamId,\n                        app_source_id: item.functionId,\n                        metric_kind: 'failure',\n                        metric_name: 'disabled_permanently',\n                        count: 1,\n                    },\n                    'hog_flow'\n                )\n                return\n            }\n\n            if (state === HogWatcherState.degraded) {\n                item.queuePriority = 2\n            }\n\n            validInvocations.push(item)\n        })\n\n        // Now we can filter by masking configs\n        const { masked, notMasked: notMaskedInvocations } = await this.hogMasker.filterByMasking(",
            "cost": 0.132735
        }
    },
    "recover_status": "success",
    "instance_ref": {
        "instance_id": "PostHog__posthog.main.42599",
        "repo": "PostHog/posthog",
        "base_commit": "9d66861e8cf6e1d81d7b371a79e565a1a6273357",
        "head_commit": "48833e7f479f48767650d458cc5fe8eff8df4313",
        "title": "fix(workflows): dont bill for hogflow invocations",
        "merged_at": "2025-12-03T17:44:55Z",
        "html_url": "https://github.com/PostHog/posthog/pull/42599",
        "test_files": [
            "plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts"
        ],
        "code_files": [
            "plugin-server/src/cdp/consumers/cdp-events.consumer.ts"
        ],
        "total_changes": 36,
        "num_files": 2,
        "pull_number": 42599,
        "patch": "diff --git a/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts b/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts\nindex 47125eae22135..fe056d73e532e 100644\n--- a/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts\n+++ b/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts\n@@ -534,5 +534,33 @@ describe('hog flow processing', () => {\n                 teamId: 2,\n             })\n         })\n+\n+        it('should not produce billable_invocation metrics for hog flow invocations', async () => {\n+            await insertHogFlow(\n+                new FixtureHogFlowBuilder()\n+                    .withTeamId(team.id)\n+                    .withSimpleWorkflow({\n+                        trigger: {\n+                            type: 'event',\n+                            filters: HOG_FILTERS_EXAMPLES.pageview_or_autocapture_filter.filters ?? {},\n+                        },\n+                    })\n+                    .build()\n+            )\n+\n+            await processor['createHogFlowInvocations']([globals])\n+\n+            const producedMetrics =\n+                mockProducerObserver.getProducedKafkaMessagesForTopic('clickhouse_app_metrics2_test')\n+            expect(producedMetrics).not.toEqual(\n+                expect.arrayContaining([\n+                    expect.objectContaining({\n+                        value: expect.objectContaining({\n+                            metric_name: 'billable_invocation',\n+                        }),\n+                    }),\n+                ])\n+            )\n+        })\n     })\n })\ndiff --git a/plugin-server/src/cdp/consumers/cdp-events.consumer.ts b/plugin-server/src/cdp/consumers/cdp-events.consumer.ts\nindex 6f44c0c5f3d5c..5236d5060b960 100644\n--- a/plugin-server/src/cdp/consumers/cdp-events.consumer.ts\n+++ b/plugin-server/src/cdp/consumers/cdp-events.consumer.ts\n@@ -375,14 +375,6 @@ export class CdpEventsConsumer extends CdpConsumerBase {\n                 metric_name: 'triggered',\n                 count: 1,\n             })\n-\n-            triggeredInvocationsMetrics.push({\n-                team_id: item.teamId,\n-                app_source_id: item.functionId,\n-                metric_kind: 'billing',\n-                metric_name: 'billable_invocation',\n-                count: 1,\n-            })\n         })\n \n         this.hogFunctionMonitoringService.queueAppMetrics(triggeredInvocationsMetrics, 'hog_flow')\n",
        "pr_mirror": "PostHog__posthog.main"
    }
}