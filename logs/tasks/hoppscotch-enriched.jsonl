{"instance_id": "hoppscotch__hoppscotch.main.5624", "repo": "hoppscotch/hoppscotch", "base_commit": "217563e7ddf63ef83eea2b27762ea0d2113b8d2e", "head_commit": "0a70615eab82ef724121c7620ec57f405fe65627", "title": "hotfix: clean up published docs with deleted collections", "merged_at": "2025-12-02T08:07:08Z", "html_url": "https://github.com/hoppscotch/hoppscotch/pull/5624", "test_files": ["packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts"], "code_files": ["packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts", "packages/hoppscotch-backend/src/published-docs/published-docs.service.ts", "packages/hoppscotch-backend/src/user-collection/user-collection.service.ts"], "total_changes": 294, "num_files": 4, "pull_number": 5624, "patch": "diff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts\nindex 0f038bd6ba..11e72ec2c8 100644\n--- a/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts\n+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts\n@@ -34,6 +34,7 @@ export class PublishedDocsResolver {\n \n   @ResolveField(() => User, {\n     description: 'Returns the creator of the published document',\n+    nullable: true,\n   })\n   async creator(@Parent() publishedDocs: PublishedDocs): Promise<User> {\n     const creator = await this.publishedDocsService.getPublishedDocsCreator(\n@@ -41,11 +42,7 @@ export class PublishedDocsResolver {\n     );\n \n     if (E.isLeft(creator)) throwErr(creator.left);\n-    return {\n-      ...creator.right,\n-      currentGQLSession: JSON.stringify(creator.right.currentGQLSession),\n-      currentRESTSession: JSON.stringify(creator.right.currentRESTSession),\n-    };\n+    return creator.right;\n   }\n \n   @ResolveField(() => PublishedDocsCollection, {\ndiff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts\nindex 624517fb83..e532eb6194 100644\n--- a/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts\n+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts\n@@ -47,8 +47,8 @@ const user: User = {\n   lastLoggedOn: currentTime,\n   lastActiveOn: currentTime,\n   createdOn: currentTime,\n-  currentGQLSession: JSON.stringify({}),\n-  currentRESTSession: JSON.stringify({}),\n+  currentGQLSession: {} as any,\n+  currentRESTSession: {} as any,\n };\n \n const userPublishedDoc: DBPublishedDocs = {\n@@ -179,6 +179,9 @@ describe('getPublishedDocByID', () => {\n describe('getAllUserPublishedDocs', () => {\n   test('should return a list of user published documents with pagination', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([userPublishedDoc]);\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n+      { id: 'collection_1' },\n+    ] as any);\n \n     const result = await publishedDocsService.getAllUserPublishedDocs(\n       user.uid,\n@@ -190,6 +193,7 @@ describe('getAllUserPublishedDocs', () => {\n \n   test('should return an empty array when no documents found', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([]);\n \n     const result = await publishedDocsService.getAllUserPublishedDocs(\n       user.uid,\n@@ -201,6 +205,9 @@ describe('getAllUserPublishedDocs', () => {\n   test('should return paginated results correctly', async () => {\n     const docs = [userPublishedDoc, { ...userPublishedDoc, id: 'pub_doc_3' }];\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([docs[0]]);\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n+      { id: 'collection_1' },\n+    ] as any);\n \n     const result = await publishedDocsService.getAllUserPublishedDocs(\n       user.uid,\n@@ -208,11 +215,94 @@ describe('getAllUserPublishedDocs', () => {\n     );\n     expect(result).toHaveLength(1);\n   });\n+\n+  test('should filter out published docs with non-existent collections', async () => {\n+    const doc1 = {\n+      ...userPublishedDoc,\n+      id: 'pub_doc_1',\n+      collectionID: 'collection_1',\n+    };\n+    const doc2 = {\n+      ...userPublishedDoc,\n+      id: 'pub_doc_2',\n+      collectionID: 'collection_2',\n+    };\n+    const doc3 = {\n+      ...userPublishedDoc,\n+      id: 'pub_doc_3',\n+      collectionID: 'collection_3',\n+    };\n+\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2, doc3]);\n+    // Only collection_1 and collection_3 exist\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n+      { id: 'collection_1' },\n+      { id: 'collection_3' },\n+    ] as any);\n+\n+    const result = await publishedDocsService.getAllUserPublishedDocs(\n+      user.uid,\n+      { skip: 0, take: 10 },\n+    );\n+\n+    // Should only return docs with existing collections\n+    expect(result).toHaveLength(2);\n+    expect(result.map((d) => d.id)).toEqual(['pub_doc_1', 'pub_doc_3']);\n+  });\n+\n+  test('should delete published docs with non-existent collections', async () => {\n+    const doc1 = {\n+      ...userPublishedDoc,\n+      id: 'pub_doc_1',\n+      collectionID: 'collection_1',\n+    };\n+    const doc2 = {\n+      ...userPublishedDoc,\n+      id: 'pub_doc_2',\n+      collectionID: 'collection_deleted',\n+    };\n+\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2]);\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n+      { id: 'collection_1' },\n+    ] as any);\n+    mockPrisma.publishedDocs.deleteMany.mockResolvedValueOnce({\n+      count: 1,\n+    } as any);\n+\n+    await publishedDocsService.getAllUserPublishedDocs(user.uid, {\n+      skip: 0,\n+      take: 10,\n+    });\n+\n+    expect(mockPrisma.publishedDocs.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        id: { in: ['pub_doc_2'] },\n+      },\n+    });\n+  });\n+\n+  test('should not call deleteMany when all collections exist', async () => {\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([userPublishedDoc]);\n+    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n+      { id: 'collection_1' },\n+    ] as any);\n+\n+    await publishedDocsService.getAllUserPublishedDocs(user.uid, {\n+      skip: 0,\n+      take: 10,\n+    });\n+\n+    expect(mockPrisma.publishedDocs.deleteMany).not.toHaveBeenCalled();\n+  });\n });\n \n describe('getAllTeamPublishedDocs', () => {\n   test('should return a list of team published documents with pagination', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n+      { id: 'team_collection_1' },\n+    ] as any);\n \n     const result = await publishedDocsService.getAllTeamPublishedDocs(\n       'team_1',\n@@ -225,6 +315,7 @@ describe('getAllTeamPublishedDocs', () => {\n \n   test('should return an empty array when no team documents found', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([]);\n \n     const result = await publishedDocsService.getAllTeamPublishedDocs(\n       'team_1',\n@@ -236,6 +327,9 @@ describe('getAllTeamPublishedDocs', () => {\n \n   test('should filter by teamID and collectionID correctly', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n+      { id: 'team_collection_1' },\n+    ] as any);\n \n     await publishedDocsService.getAllTeamPublishedDocs(\n       'team_1',\n@@ -256,6 +350,88 @@ describe('getAllTeamPublishedDocs', () => {\n       },\n     });\n   });\n+\n+  test('should filter out published docs with non-existent team collections', async () => {\n+    const doc1 = {\n+      ...teamPublishedDoc,\n+      id: 'pub_doc_1',\n+      collectionID: 'team_collection_1',\n+    };\n+    const doc2 = {\n+      ...teamPublishedDoc,\n+      id: 'pub_doc_2',\n+      collectionID: 'team_collection_2',\n+    };\n+    const doc3 = {\n+      ...teamPublishedDoc,\n+      id: 'pub_doc_3',\n+      collectionID: 'team_collection_3',\n+    };\n+\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2, doc3]);\n+    // Only team_collection_1 and team_collection_3 exist\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n+      { id: 'team_collection_1' },\n+      { id: 'team_collection_3' },\n+    ] as any);\n+\n+    const result = await publishedDocsService.getAllTeamPublishedDocs(\n+      'team_1',\n+      undefined,\n+      { skip: 0, take: 10 },\n+    );\n+\n+    // Should only return docs with existing collections\n+    expect(result).toHaveLength(2);\n+    expect(result.map((d) => d.id)).toEqual(['pub_doc_1', 'pub_doc_3']);\n+  });\n+\n+  test('should delete published docs with non-existent team collections', async () => {\n+    const doc1 = {\n+      ...teamPublishedDoc,\n+      id: 'pub_doc_1',\n+      collectionID: 'team_collection_1',\n+    };\n+    const doc2 = {\n+      ...teamPublishedDoc,\n+      id: 'pub_doc_2',\n+      collectionID: 'team_collection_deleted',\n+    };\n+\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2]);\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n+      { id: 'team_collection_1' },\n+    ] as any);\n+    mockPrisma.publishedDocs.deleteMany.mockResolvedValueOnce({\n+      count: 1,\n+    } as any);\n+\n+    await publishedDocsService.getAllTeamPublishedDocs('team_1', undefined, {\n+      skip: 0,\n+      take: 10,\n+    });\n+\n+    expect(mockPrisma.publishedDocs.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        id: { in: ['pub_doc_2'] },\n+      },\n+    });\n+  });\n+\n+  test('should not call deleteMany when all team collections exist', async () => {\n+    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n+    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n+      { id: 'team_collection_1' },\n+    ] as any);\n+\n+    await publishedDocsService.getAllTeamPublishedDocs(\n+      'team_1',\n+      'team_collection_1',\n+      { skip: 0, take: 10 },\n+    );\n+\n+    expect(mockPrisma.publishedDocs.deleteMany).not.toHaveBeenCalled();\n+  });\n });\n \n describe('createPublishedDoc', () => {\n@@ -650,7 +826,14 @@ describe('getPublishedDocsCreator', () => {\n     const result = await publishedDocsService.getPublishedDocsCreator(\n       userPublishedDoc.id,\n     );\n-    expect(result).toEqualRight(user);\n+\n+    const expectedUser = {\n+      ...user,\n+      currentGQLSession: JSON.stringify(user.currentGQLSession),\n+      currentRESTSession: JSON.stringify(user.currentRESTSession),\n+    };\n+\n+    expect(result).toEqualRight(expectedUser);\n   });\n \n   test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {\ndiff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts\nindex 215e2fcc7c..43e5001f64 100644\n--- a/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts\n+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts\n@@ -14,8 +14,9 @@ import {\n   PUBLISHED_DOCS_INVALID_COLLECTION,\n   PUBLISHED_DOCS_NOT_FOUND,\n   PUBLISHED_DOCS_UPDATE_FAILED,\n+  TEAM_INVALID_COLL_ID,\n   TEAM_INVALID_ID,\n-  USERS_NOT_FOUND,\n+  USER_COLL_NOT_FOUND,\n } from 'src/errors';\n import * as E from 'fp-ts/Either';\n import { PublishedDocs } from './published-docs.model';\n@@ -155,9 +156,16 @@ export class PublishedDocsService {\n     const user = await this.prisma.user.findUnique({\n       where: { uid: publishedDocs.creatorUid },\n     });\n-    if (!user) return E.left(USERS_NOT_FOUND);\n \n-    return E.right(user);\n+    const creator = user\n+      ? {\n+          ...user,\n+          currentGQLSession: JSON.stringify(user.currentGQLSession),\n+          currentRESTSession: JSON.stringify(user.currentRESTSession),\n+        }\n+      : null;\n+\n+    return E.right(creator);\n   }\n \n   /**\n@@ -235,7 +243,20 @@ export class PublishedDocsService {\n               query.tree === TreeLevel.FULL,\n             );\n \n-      if (E.isLeft(collectionResult)) return E.left(collectionResult.left);\n+      if (E.isLeft(collectionResult)) {\n+        // Delete the published doc if its collection is missing\n+        const isCollectionNotFound =\n+          collectionResult.left === USER_COLL_NOT_FOUND ||\n+          collectionResult.left === TEAM_INVALID_COLL_ID;\n+\n+        if (isCollectionNotFound) {\n+          await this.prisma.publishedDocs.delete({\n+            where: { id: publishedDocs.id },\n+          });\n+        }\n+\n+        return E.left(collectionResult.left);\n+      }\n \n       return E.right(\n         this.cast({\n@@ -248,6 +269,26 @@ export class PublishedDocsService {\n     return E.right(this.cast(publishedDocs));\n   }\n \n+  /**\n+   * Cleanup orphaned published documents whose collections no longer exist\n+   */\n+  private async cleanupOrphanedPublishedDocs<\n+    T extends { id: string; collectionID: string },\n+  >(docs: T[], existingCollectionIDs: Set<string>): Promise<T[]> {\n+    const docsToDelete = docs.filter(\n+      (doc) => !existingCollectionIDs.has(doc.collectionID),\n+    );\n+\n+    if (docsToDelete.length > 0) {\n+      const idsToDelete = docsToDelete.map((doc) => doc.id);\n+      this.prisma.publishedDocs.deleteMany({\n+        where: { id: { in: idsToDelete } },\n+      });\n+    }\n+\n+    return docs.filter((doc) => existingCollectionIDs.has(doc.collectionID));\n+  }\n+\n   /**\n    * Get all published documents for a user with pagination\n    * @param userUid - The UID of the user\n@@ -266,7 +307,29 @@ export class PublishedDocsService {\n       },\n     });\n \n-    return docs.map((doc) => this.cast(doc));\n+    if (docs.length === 0) return [];\n+\n+    // Cross-check if all collections exist\n+    const collectionIDs = docs.map((doc) => doc.collectionID);\n+    const existingCollections = await this.prisma.userCollection.findMany({\n+      where: {\n+        id: { in: collectionIDs },\n+        userUid,\n+      },\n+      select: { id: true },\n+    });\n+\n+    const existingCollectionIDs = new Set(\n+      existingCollections.map((col) => col.id),\n+    );\n+\n+    const validDocs = await this.cleanupOrphanedPublishedDocs<DbPublishedDocs>(\n+      docs,\n+      existingCollectionIDs,\n+    );\n+\n+    // Return only docs with existing collections\n+    return validDocs.map((doc) => this.cast(doc));\n   }\n \n   /**\n@@ -290,7 +353,29 @@ export class PublishedDocsService {\n       },\n     });\n \n-    return docs.map((doc) => this.cast(doc));\n+    if (docs.length === 0) return [];\n+\n+    // Cross-check if all collections exist\n+    const collectionIDs = docs.map((doc) => doc.collectionID);\n+    const existingCollections = await this.prisma.teamCollection.findMany({\n+      where: {\n+        id: { in: collectionIDs },\n+        teamID,\n+      },\n+      select: { id: true },\n+    });\n+\n+    const existingCollectionIDs = new Set(\n+      existingCollections.map((col) => col.id),\n+    );\n+\n+    const validDocs = await this.cleanupOrphanedPublishedDocs<DbPublishedDocs>(\n+      docs,\n+      existingCollectionIDs,\n+    );\n+\n+    // Return only docs with existing collections\n+    return validDocs.map((doc) => this.cast(doc));\n   }\n \n   /**\ndiff --git a/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts b/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts\nindex 5d89c04b88..270c441b0f 100644\n--- a/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts\n+++ b/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts\n@@ -40,7 +40,6 @@ import {\n import { CollectionFolder } from 'src/types/CollectionFolder';\n import { PrismaError } from 'src/prisma/prisma-error-codes';\n import { SortOptions } from 'src/types/SortOptions';\n-import { UserRequest } from 'src/user-request/user-request.model';\n \n @Injectable()\n export class UserCollectionService {\n"}
{"instance_id": "hoppscotch__hoppscotch.main.5533", "repo": "hoppscotch/hoppscotch", "base_commit": "98f07f8a4c002926e24676af45067d911b589b58", "head_commit": "f5cc773f21e6a71da741f825dae7079416d9fe2b", "title": "fix: team collection not loading on route change", "merged_at": "2025-11-12T09:13:35Z", "html_url": "https://github.com/hoppscotch/hoppscotch/pull/5533", "test_files": ["packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts"], "code_files": ["packages/hoppscotch-common/src/services/team-collection.service.ts", "packages/hoppscotch-common/src/services/workspace.service.ts"], "total_changes": 337, "num_files": 3, "pull_number": 5533, "patch": "diff --git a/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts b/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts\nindex 6720df179e..7d049a39f2 100644\n--- a/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts\n+++ b/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts\n@@ -25,6 +25,18 @@ vi.mock(\"~/helpers/teams/TeamListAdapter\", () => ({\n   },\n }))\n \n+// Mock TeamCollectionsService to prevent i18n dependency issues\n+vi.mock(\"../team-collection.service\", () => ({\n+  TeamCollectionsService: class MockTeamCollectionsService {\n+    static readonly ID = \"TEAM_COLLECTIONS_SERVICE\"\n+\n+    changeTeamID = vi.fn()\n+    clearCollections = vi.fn()\n+\n+    onServiceInit = vi.fn()\n+  },\n+}))\n+\n describe(\"WorkspaceService\", () => {\n   const platformMock = {\n     auth: {\n@@ -239,4 +251,226 @@ describe(\"WorkspaceService\", () => {\n       expect(listAdapterMock.fetchList).not.toHaveBeenCalled()\n     })\n   })\n+\n+  describe(\"Team Collection Service Synchronization\", () => {\n+    it(\"should call changeTeamID when workspace changes to a team workspace\", async () => {\n+      const container = new TestContainer()\n+      const service = container.bind(WorkspaceService)\n+\n+      // Access the team collection service mock\n+      const teamCollectionServiceMock = (service as any).teamCollectionService\n+\n+      // Change to team workspace\n+      service.changeWorkspace({\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Test Team\",\n+        role: null,\n+      })\n+\n+      await nextTick()\n+\n+      expect(teamCollectionServiceMock.changeTeamID).toHaveBeenCalledWith(\n+        \"team-123\"\n+      )\n+    })\n+\n+    it(\"should call clearCollections when workspace changes to personal workspace\", async () => {\n+      const container = new TestContainer()\n+      const service = container.bind(WorkspaceService)\n+\n+      // Start with a team workspace\n+      service.changeWorkspace({\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Test Team\",\n+        role: null,\n+      })\n+\n+      await nextTick()\n+\n+      const teamCollectionServiceMock = (service as any).teamCollectionService\n+      teamCollectionServiceMock.clearCollections.mockClear()\n+\n+      // Change to personal workspace\n+      service.changeWorkspace({\n+        type: \"personal\",\n+      })\n+\n+      await nextTick()\n+\n+      expect(teamCollectionServiceMock.clearCollections).toHaveBeenCalled()\n+    })\n+\n+    it(\"should call clearCollections when workspace changes to team workspace without teamID\", async () => {\n+      const container = new TestContainer()\n+      const service = container.bind(WorkspaceService)\n+\n+      const teamCollectionServiceMock = (service as any).teamCollectionService\n+\n+      // Change to team workspace without teamID\n+      service.changeWorkspace({\n+        type: \"team\",\n+        teamID: \"\",\n+        teamName: \"Test Team\",\n+        role: null,\n+      })\n+\n+      await nextTick()\n+\n+      expect(teamCollectionServiceMock.clearCollections).toHaveBeenCalled()\n+    })\n+\n+    it(\"should not sync when workspaces are effectively the same\", async () => {\n+      const container = new TestContainer()\n+      const service = container.bind(WorkspaceService)\n+\n+      // Start with a team workspace\n+      service.changeWorkspace({\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Test Team\",\n+        role: null,\n+      })\n+\n+      await nextTick()\n+\n+      const teamCollectionServiceMock = (service as any).teamCollectionService\n+      teamCollectionServiceMock.changeTeamID.mockClear()\n+\n+      // Change to same team workspace (different name, same ID)\n+      service.changeWorkspace({\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Updated Team Name\",\n+        role: null,\n+      })\n+\n+      await nextTick()\n+\n+      // Should not call changeTeamID again since it's the same team\n+      expect(teamCollectionServiceMock.changeTeamID).not.toHaveBeenCalled()\n+    })\n+\n+    it(\"should handle errors during team collection service sync gracefully\", async () => {\n+      const container = new TestContainer()\n+      const service = container.bind(WorkspaceService)\n+\n+      const teamCollectionServiceMock = (service as any).teamCollectionService\n+      teamCollectionServiceMock.changeTeamID.mockImplementation(() => {\n+        throw new Error(\"Sync failed\")\n+      })\n+\n+      const consoleSpy = vi.spyOn(console, \"error\").mockImplementation(() => {})\n+\n+      // Change to team workspace (should not throw)\n+      expect(() => {\n+        service.changeWorkspace({\n+          type: \"team\",\n+          teamID: \"team-123\",\n+          teamName: \"Test Team\",\n+          role: null,\n+        })\n+      }).not.toThrow()\n+\n+      await nextTick()\n+\n+      expect(consoleSpy).toHaveBeenCalledWith(\n+        \"Failed to sync team collections:\",\n+        expect.any(Error)\n+      )\n+\n+      consoleSpy.mockRestore()\n+    })\n+  })\n+\n+  describe(\"areWorkspacesEqual\", () => {\n+    let service: WorkspaceService\n+\n+    beforeEach(() => {\n+      const container = new TestContainer()\n+      service = container.bind(WorkspaceService)\n+    })\n+\n+    it(\"should return false when newWorkspace is undefined\", () => {\n+      const result = (service as any).areWorkspacesEqual(undefined, {\n+        type: \"personal\",\n+      })\n+      expect(result).toBe(false)\n+    })\n+\n+    it(\"should return false when oldWorkspace is undefined\", () => {\n+      const result = (service as any).areWorkspacesEqual(\n+        { type: \"personal\" },\n+        undefined\n+      )\n+      expect(result).toBe(false)\n+    })\n+\n+    it(\"should return true when both workspaces are personal\", () => {\n+      const result = (service as any).areWorkspacesEqual(\n+        { type: \"personal\" },\n+        { type: \"personal\" }\n+      )\n+      expect(result).toBe(true)\n+    })\n+\n+    it(\"should return true when both workspaces are team workspaces with same teamID\", () => {\n+      const workspace1 = {\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Team A\",\n+        role: null,\n+      }\n+      const workspace2 = {\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Team A Updated\",\n+        role: null,\n+      }\n+\n+      const result = (service as any).areWorkspacesEqual(workspace1, workspace2)\n+      expect(result).toBe(true)\n+    })\n+\n+    it(\"should return false when team workspaces have different teamIDs\", () => {\n+      const workspace1 = {\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Team A\",\n+        role: null,\n+      }\n+      const workspace2 = {\n+        type: \"team\",\n+        teamID: \"team-456\",\n+        teamName: \"Team B\",\n+        role: null,\n+      }\n+\n+      const result = (service as any).areWorkspacesEqual(workspace1, workspace2)\n+      expect(result).toBe(false)\n+    })\n+\n+    it(\"should return false when one is personal and other is team workspace\", () => {\n+      const personalWorkspace = { type: \"personal\" }\n+      const teamWorkspace = {\n+        type: \"team\",\n+        teamID: \"team-123\",\n+        teamName: \"Team A\",\n+        role: null,\n+      }\n+\n+      const result1 = (service as any).areWorkspacesEqual(\n+        personalWorkspace,\n+        teamWorkspace\n+      )\n+      const result2 = (service as any).areWorkspacesEqual(\n+        teamWorkspace,\n+        personalWorkspace\n+      )\n+\n+      expect(result1).toBe(false)\n+      expect(result2).toBe(false)\n+    })\n+  })\n })\ndiff --git a/packages/hoppscotch-common/src/services/team-collection.service.ts b/packages/hoppscotch-common/src/services/team-collection.service.ts\nindex 0fcca76f5e..3ead4e43ec 100644\n--- a/packages/hoppscotch-common/src/services/team-collection.service.ts\n+++ b/packages/hoppscotch-common/src/services/team-collection.service.ts\n@@ -31,7 +31,6 @@ import { TeamCollection } from \"~/helpers/teams/TeamCollection\"\n import { TeamRequest } from \"~/helpers/teams/TeamRequest\"\n import { runGQLQuery, runGQLSubscription } from \"~/helpers/backend/GQLClient\"\n import { HoppInheritedProperty } from \"~/helpers/types/HoppInheritedProperties\"\n-import { WorkspaceService } from \"./workspace.service\"\n import { ref, watch } from \"vue\"\n import { Service } from \"dioc\"\n import { updateInheritedPropertiesForAffectedRequests } from \"~/helpers/collection/collection\"\n@@ -139,8 +138,6 @@ export class TeamCollectionsService extends Service<void> {\n   private secretEnvironmentService = this.bind(SecretEnvironmentService)\n   private currentEnvironmentValueService = this.bind(CurrentValueService)\n \n-  private workspaceService = this.bind(WorkspaceService)\n-\n   private teamID: string | null = null\n \n   public collections = ref<TeamCollection[]>([])\n@@ -176,20 +173,13 @@ export class TeamCollectionsService extends Service<void> {\n   private teamChildCollectionSortedSub: WSubscription | null = null\n \n   override onServiceInit() {\n-    // Watch for team change and update the collections accordingly\n-    watch(\n-      () => this.workspaceService.currentWorkspace,\n-      (workspace) => {\n-        if (workspace.value.type === \"team\" && workspace.value.teamID) {\n-          this.changeTeamID(workspace.value.teamID)\n-        } else {\n-          this.clearCollections()\n-        }\n-      },\n-      { immediate: true, deep: true }\n-    )\n+    this.collectionLoadingWatcher()\n+  }\n \n-    // Watch for completion of loading (when all loading flags are cleared) to update inherited properties once\n+  /**\n+   * Watches for loading collections and updates inherited properties once loading is done\n+   */\n+  private collectionLoadingWatcher() {\n     watch(\n       () => this.loadingCollections.value.length,\n       (loadingCount) => {\n@@ -208,7 +198,11 @@ export class TeamCollectionsService extends Service<void> {\n     )\n   }\n \n-  changeTeamID(newTeamID: string | null) {\n+  /**\n+   * Change the current team ID and resets the collections\n+   * @param newTeamID The new team ID to switch to\n+   */\n+  public changeTeamID(newTeamID: string | null) {\n     this.teamID = newTeamID\n     this.collections.value = []\n     this.entityIDs.clear()\n@@ -220,6 +214,17 @@ export class TeamCollectionsService extends Service<void> {\n     if (this.teamID) this.initialize()\n   }\n \n+  /**\n+   * Clears all collections and resets the service state\n+   */\n+  public clearCollections() {\n+    this.collections.value = []\n+    this.entityIDs.clear()\n+    this.loadingCollections.value = []\n+    this.unsubscribeSubscriptions()\n+    this.teamID = null\n+  }\n+\n   /**\n    * Unsubscribes from the subscriptions\n    * NOTE: Once this is called, no new updates to the tree will be detected\n@@ -292,14 +297,6 @@ export class TeamCollectionsService extends Service<void> {\n     this.collections.value = tree\n   }\n \n-  private clearCollections() {\n-    this.collections.value = []\n-    this.entityIDs.clear()\n-    this.loadingCollections.value = []\n-    this.unsubscribeSubscriptions()\n-    this.teamID = null\n-  }\n-\n   /**\n    * Loads the root collections of the current team\n    * @param replace Whether to replace the existing collections or append to them\ndiff --git a/packages/hoppscotch-common/src/services/workspace.service.ts b/packages/hoppscotch-common/src/services/workspace.service.ts\nindex bcf67c14a8..7bd3dbcb85 100644\n--- a/packages/hoppscotch-common/src/services/workspace.service.ts\n+++ b/packages/hoppscotch-common/src/services/workspace.service.ts\n@@ -6,6 +6,7 @@ import TeamListAdapter from \"~/helpers/teams/TeamListAdapter\"\n import { platform } from \"~/platform\"\n import { min } from \"lodash-es\"\n import { TeamAccessRole } from \"~/helpers/backend/graphql\"\n+import { TeamCollectionsService } from \"./team-collection.service\"\n \n /**\n  * Defines a workspace and its information\n@@ -45,6 +46,8 @@ export class WorkspaceService extends Service<WorkspaceServiceEvent> {\n   private teamListAdapterLockTicker = 0 // Used to generate unique lock IDs\n   private managedTeamListAdapter = new TeamListAdapter(true, false)\n \n+  private teamCollectionService = this.bind(TeamCollectionsService)\n+\n   private currentUser = useStreamStatic(\n     platform.auth.getCurrentUserStream(),\n     platform.auth.getCurrentUser(),\n@@ -101,6 +104,59 @@ export class WorkspaceService extends Service<WorkspaceServiceEvent> {\n       },\n       { immediate: true }\n     )\n+\n+    // Watch for workspace changes and update team collection service accordingly\n+    this.setupTeamCollectionServiceSync()\n+  }\n+\n+  /**\n+   * Sets up synchronization with team collection service\n+   * This ensures team collections are updated when workspace changes\n+   */\n+  private setupTeamCollectionServiceSync() {\n+    watch(\n+      this._currentWorkspace,\n+      (newWorkspace, oldWorkspace) => {\n+        // Skip update if workspaces are effectively the same\n+        if (this.areWorkspacesEqual(newWorkspace, oldWorkspace)) return\n+\n+        try {\n+          if (newWorkspace.type === \"team\" && newWorkspace.teamID) {\n+            this.teamCollectionService.changeTeamID(newWorkspace.teamID)\n+          } else {\n+            this.teamCollectionService.clearCollections()\n+          }\n+        } catch (error) {\n+          console.error(\"Failed to sync team collections:\", error)\n+        }\n+      },\n+      { immediate: true }\n+    )\n+  }\n+\n+  /**\n+   * Checks if two workspaces are effectively equal to avoid unnecessary updates\n+   *\n+   * Note: Vue's watch API provides `undefined` as `oldValue` on the first callback\n+   * invocation when using `{ immediate: true }`, since there is no previous value yet.\n+   * This is why `oldWorkspace` has an optional type, while `newWorkspace` is always defined.\n+   */\n+  private areWorkspacesEqual(\n+    newWorkspace: Workspace,\n+    oldWorkspace?: Workspace\n+  ): boolean {\n+    if (!newWorkspace || !oldWorkspace) return false\n+\n+    // Both are personal workspaces\n+    if (newWorkspace.type === \"personal\" && oldWorkspace.type === \"personal\")\n+      return true\n+\n+    // Team workspaces are equal only if they share the same team ID\n+    return (\n+      newWorkspace.type === \"team\" &&\n+      oldWorkspace.type === \"team\" &&\n+      newWorkspace.teamID === oldWorkspace.teamID\n+    )\n   }\n \n   // TODO: Update this function, its existence is pretty weird\n"}
{"instance_id": "hoppscotch__hoppscotch.main.5363", "repo": "hoppscotch/hoppscotch", "base_commit": "aac4c5b34b833b3bf463d20091c903c645de533c", "head_commit": "13f119ed3dbc1c0ea4a7cd7e796dc9d7b3d2fa37", "title": "feat: remove minimum length restriction on shared workspace names", "merged_at": "2025-09-02T08:18:29Z", "html_url": "https://github.com/hoppscotch/hoppscotch/pull/5363", "test_files": ["packages/hoppscotch-backend/src/team/team.service.spec.ts"], "code_files": ["packages/hoppscotch-backend/src/team/team.service.ts", "packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts"], "total_changes": 14, "num_files": 4, "pull_number": 5363, "patch": "diff --git a/packages/hoppscotch-backend/src/team/team.service.spec.ts b/packages/hoppscotch-backend/src/team/team.service.spec.ts\nindex 44954535001..5fa2e2ffd4f 100644\n--- a/packages/hoppscotch-backend/src/team/team.service.spec.ts\n+++ b/packages/hoppscotch-backend/src/team/team.service.spec.ts\n@@ -361,8 +361,8 @@ describe('renameTeam', () => {\n     ).resolves.toEqualLeft(TEAM_INVALID_ID);\n   });\n \n-  test('rejects for new team name length < 6 with TEAM_NAME_INVALID', () => {\n-    const newTeamName = 'smol';\n+  test('rejects for new team name empty with TEAM_NAME_INVALID', () => {\n+    const newTeamName = '';\n \n     // Prisma doesn't care about the team name length, so it will resolve\n     mockPrisma.team.update.mockResolvedValue({\n@@ -668,8 +668,8 @@ describe('createTeam', () => {\n     ).resolves.toEqualRight(expect.objectContaining(team));\n   });\n \n-  test('rejects for team name length < 6 with TEAM_NAME_INVALID', () => {\n-    const newName = 'smol';\n+  test('rejects for team name empty with TEAM_NAME_INVALID', () => {\n+    const newName = '';\n \n     // Prisma doesn't care\n     mockPrisma.team.create.mockResolvedValue({\ndiff --git a/packages/hoppscotch-backend/src/team/team.service.ts b/packages/hoppscotch-backend/src/team/team.service.ts\nindex 96d3112e7a0..11ea9613fdf 100644\n--- a/packages/hoppscotch-backend/src/team/team.service.ts\n+++ b/packages/hoppscotch-backend/src/team/team.service.ts\n@@ -124,7 +124,7 @@ export class TeamService implements UserDataHandler, OnModuleInit {\n   }\n \n   validateTeamName(title: string): E.Left<string> | E.Right<boolean> {\n-    if (!title || title.length < 6) return E.left(TEAM_NAME_INVALID);\n+    if (!title || title.trim() === '') return E.left(TEAM_NAME_INVALID);\n     return E.right(true);\n   }\n \ndiff --git a/packages/hoppscotch-common/locales/en.json b/packages/hoppscotch-common/locales/en.json\nindex e5527b1caa4..7c4c60cfc53 100644\n--- a/packages/hoppscotch-common/locales/en.json\n+++ b/packages/hoppscotch-common/locales/en.json\n@@ -1521,7 +1521,7 @@\n     \"member_role_updated\": \"User roles updated\",\n     \"members\": \"Members\",\n     \"more_members\": \"+{count} more\",\n-    \"name_length_insufficient\": \"Workspace name should be at least 6 characters long\",\n+    \"name_length_insufficient\": \"Workspace name should not be empty\",\n     \"name_updated\": \"Workspace name updated\",\n     \"new\": \"New Workspace\",\n     \"new_created\": \"New workspace created\",\ndiff --git a/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts b/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts\nindex bbcdb6c0af8..26182eca31b 100644\n--- a/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts\n+++ b/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts\n@@ -6,7 +6,7 @@ interface TeamNameBrand {\n \n export const TeamNameCodec = t.brand(\n   t.string,\n-  (x): x is t.Branded<string, TeamNameBrand> => x.trim().length >= 6,\n+  (x): x is t.Branded<string, TeamNameBrand> => x.trim() !== \"\",\n   \"TeamName\"\n )\n \n"}
{"instance_id": "hoppscotch__hoppscotch.main.5231", "repo": "hoppscotch/hoppscotch", "base_commit": "e5bb60f8b3ccff752e8902a56718966099b2a2c6", "head_commit": "c4fbe930c7c0cbc6e954581879a25bbbb40f653d", "title": "fix: allow aws signature to work with query params", "merged_at": "2025-07-27T14:23:15Z", "html_url": "https://github.com/hoppscotch/hoppscotch/pull/5231", "test_files": ["packages/hoppscotch-common/src/helpers/auth/types/__tests__/aws-signature.spec.ts"], "code_files": ["packages/hoppscotch-common/src/helpers/auth/types/aws-signature.ts"], "total_changes": 570, "num_files": 2, "pull_number": 5231, "patch": "diff --git a/packages/hoppscotch-common/src/helpers/auth/types/__tests__/aws-signature.spec.ts b/packages/hoppscotch-common/src/helpers/auth/types/__tests__/aws-signature.spec.ts\nnew file mode 100644\nindex 00000000000..54d94040154\n--- /dev/null\n+++ b/packages/hoppscotch-common/src/helpers/auth/types/__tests__/aws-signature.spec.ts\n@@ -0,0 +1,431 @@\n+import { describe, expect, test, vi, beforeEach, afterEach } from \"vitest\"\n+import { makeRESTRequest } from \"@hoppscotch/data\"\n+import {\n+  generateAwsSignatureAuthHeaders,\n+  generateAwsSignatureAuthParams,\n+} from \"../aws-signature\"\n+import type { HoppRESTAuth, Environment } from \"@hoppscotch/data\"\n+\n+vi.mock(\"aws4fetch\", () => ({\n+  AwsV4Signer: vi.fn().mockImplementation((config) => ({\n+    sign: vi.fn().mockResolvedValue({\n+      headers: new Map([\n+        [\n+          \"Authorization\",\n+          \"AWS4-HMAC-SHA256 Credential=test-key/20240101/us-east-1/s3/aws4_request, SignedHeaders=host;x-amz-date, Signature=test-signature\",\n+        ],\n+        [\"X-Amz-Date\", \"20240101T120000Z\"],\n+        [\"Host\", \"s3.amazonaws.com\"],\n+      ]),\n+      url: new URL(config.url),\n+    }),\n+  })),\n+}))\n+\n+vi.mock(\"~/helpers/utils/EffectiveURL\", () => ({\n+  getFinalBodyFromRequest: vi.fn().mockReturnValue(\"test body\"),\n+}))\n+\n+describe(\"AWS Signature Auth\", () => {\n+  const mockEnvVars: Environment[\"variables\"] = [\n+    {\n+      key: \"AWS_ACCESS_KEY\",\n+      secret: false,\n+      initialValue: \"test-access-key\",\n+      currentValue: \"test-access-key\",\n+    },\n+    {\n+      key: \"AWS_SECRET_KEY\",\n+      secret: true,\n+      initialValue: \"test-secret-key\",\n+      currentValue: \"test-secret-key\",\n+    },\n+    {\n+      key: \"AWS_REGION\",\n+      secret: false,\n+      initialValue: \"us-east-1\",\n+      currentValue: \"us-east-1\",\n+    },\n+    {\n+      key: \"AWS_SERVICE\",\n+      secret: false,\n+      initialValue: \"s3\",\n+      currentValue: \"s3\",\n+    },\n+  ]\n+\n+  // Helper function to create base auth configuration\n+  const createBaseAuth = (\n+    overrides: Partial<HoppRESTAuth & { authType: \"aws-signature\" }> = {}\n+  ): HoppRESTAuth & { authType: \"aws-signature\" } => ({\n+    authType: \"aws-signature\",\n+    authActive: true,\n+    addTo: \"HEADERS\",\n+    accessKey: \"test-access-key\",\n+    secretKey: \"test-secret-key\",\n+    region: \"us-east-1\",\n+    serviceName: \"s3\",\n+    serviceToken: \"\",\n+    ...overrides,\n+  })\n+\n+  // Helper function to create base request\n+  const createBaseRequest = (\n+    overrides: Partial<Parameters<typeof makeRESTRequest>[0]> = {}\n+  ) => {\n+    const baseRequest: Parameters<typeof makeRESTRequest>[0] = {\n+      method: \"GET\",\n+      endpoint: \"https://s3.amazonaws.com/bucket/key\",\n+      name: \"Test Request\",\n+      params: [],\n+      headers: [],\n+      preRequestScript: \"\",\n+      testScript: \"\",\n+      auth: {\n+        authType: \"inherit\",\n+        authActive: true,\n+      },\n+      body: {\n+        contentType: null,\n+        body: null,\n+      },\n+      requestVariables: [],\n+      responses: {},\n+    }\n+\n+    return makeRESTRequest({ ...baseRequest, ...overrides })\n+  }\n+\n+  beforeEach(() => {\n+    vi.clearAllMocks()\n+    vi.useFakeTimers()\n+    vi.setSystemTime(new Date(\"2024-01-01T12:00:00Z\"))\n+  })\n+\n+  afterEach(() => {\n+    vi.useRealTimers()\n+  })\n+\n+  describe(\"generateAwsSignatureAuthHeaders\", () => {\n+    test(\"should return empty array when addTo is not HEADERS\", async () => {\n+      const auth = createBaseAuth({ addTo: \"QUERY_PARAMS\" })\n+      const request = createBaseRequest()\n+\n+      const result = await generateAwsSignatureAuthHeaders(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+      expect(result).toEqual([])\n+    })\n+\n+    test(\"should generate AWS signature headers correctly\", async () => {\n+      const auth = createBaseAuth() // uses default HEADERS addTo\n+      const request = createBaseRequest()\n+\n+      const result = await generateAwsSignatureAuthHeaders(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+\n+      expect(result).toHaveLength(3)\n+      expect(result).toEqual([\n+        {\n+          active: true,\n+          key: \"Authorization\",\n+          value:\n+            \"AWS4-HMAC-SHA256 Credential=test-key/20240101/us-east-1/s3/aws4_request, SignedHeaders=host;x-amz-date, Signature=test-signature\",\n+          description: \"\",\n+        },\n+        {\n+          active: true,\n+          key: \"X-Amz-Date\",\n+          value: \"20240101T120000Z\",\n+          description: \"\",\n+        },\n+        {\n+          active: true,\n+          key: \"Host\",\n+          value: \"s3.amazonaws.com\",\n+          description: \"\",\n+        },\n+      ])\n+    })\n+\n+    test(\"should parse template strings for auth parameters\", async () => {\n+      const auth = createBaseAuth({\n+        accessKey: \"<<AWS_ACCESS_KEY>>\",\n+        secretKey: \"<<AWS_SECRET_KEY>>\",\n+        region: \"<<AWS_REGION>>\",\n+        serviceName: \"<<AWS_SERVICE>>\",\n+      })\n+      const request = createBaseRequest()\n+\n+      const result = await generateAwsSignatureAuthHeaders(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+      expect(result).toHaveLength(3)\n+    })\n+\n+    test(\"should handle request parameters and sort them alphabetically\", async () => {\n+      const auth = createBaseAuth()\n+      const request = createBaseRequest({\n+        params: [\n+          { active: true, key: \"z-param\", value: \"value1\", description: \"\" },\n+          { active: true, key: \"a-param\", value: \"value2\", description: \"\" },\n+          { active: false, key: \"inactive\", value: \"value3\", description: \"\" },\n+          { active: true, key: \"\", value: \"empty-key\", description: \"\" },\n+        ],\n+      })\n+\n+      const result = await generateAwsSignatureAuthHeaders(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+      expect(result).toHaveLength(3)\n+    })\n+\n+    test(\"should handle session token when provided\", async () => {\n+      const auth = createBaseAuth({ serviceToken: \"test-session-token\" })\n+      const request = createBaseRequest()\n+\n+      const result = await generateAwsSignatureAuthHeaders(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+      expect(result).toHaveLength(3)\n+    })\n+\n+    test(\"should default to us-east-1 region when region is empty\", async () => {\n+      const auth = createBaseAuth({ region: \"\" })\n+      const request = createBaseRequest()\n+\n+      const result = await generateAwsSignatureAuthHeaders(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+      expect(result).toHaveLength(3)\n+    })\n+  })\n+\n+  describe(\"generateAwsSignatureAuthParams\", () => {\n+    test(\"should return empty array when addTo is not QUERY_PARAMS\", async () => {\n+      const auth = createBaseAuth({ addTo: \"HEADERS\" })\n+      const request = createBaseRequest()\n+\n+      const result = await generateAwsSignatureAuthParams(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+      expect(result).toEqual([])\n+    })\n+\n+    test(\"should generate AWS signature query parameters correctly\", async () => {\n+      const { AwsV4Signer } = await import(\"aws4fetch\")\n+      vi.mocked(AwsV4Signer).mockImplementation(\n+        (config) =>\n+          ({\n+            sign: vi.fn().mockResolvedValue({\n+              headers: new Map(),\n+              url: new URL(\n+                config.url +\n+                  \"?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=test-key%2F20240101%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240101T120000Z&X-Amz-SignedHeaders=host&X-Amz-Signature=test-signature\"\n+              ),\n+            }),\n+          }) as any\n+      )\n+\n+      const auth = createBaseAuth({ addTo: \"QUERY_PARAMS\" })\n+      const request = createBaseRequest()\n+\n+      const result = await generateAwsSignatureAuthParams(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+\n+      expect(result).toHaveLength(5)\n+      expect(result).toEqual([\n+        {\n+          active: true,\n+          key: \"X-Amz-Algorithm\",\n+          value: \"AWS4-HMAC-SHA256\",\n+          description: \"\",\n+        },\n+        {\n+          active: true,\n+          key: \"X-Amz-Credential\",\n+          value: \"test-key/20240101/us-east-1/s3/aws4_request\",\n+          description: \"\",\n+        },\n+        {\n+          active: true,\n+          key: \"X-Amz-Date\",\n+          value: \"20240101T120000Z\",\n+          description: \"\",\n+        },\n+        {\n+          active: true,\n+          key: \"X-Amz-SignedHeaders\",\n+          value: \"host\",\n+          description: \"\",\n+        },\n+        {\n+          active: true,\n+          key: \"X-Amz-Signature\",\n+          value: \"test-signature\",\n+          description: \"\",\n+        },\n+      ])\n+    })\n+\n+    test(\"should exclude original request parameters from result\", async () => {\n+      const { AwsV4Signer } = await import(\"aws4fetch\")\n+      vi.mocked(AwsV4Signer).mockImplementation(\n+        (config) =>\n+          ({\n+            sign: vi.fn().mockResolvedValue({\n+              headers: new Map(),\n+              url: new URL(\n+                config.url +\n+                  \"?original-param=value&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Signature=test-signature\"\n+              ),\n+            }),\n+          }) as any\n+      )\n+\n+      const auth = createBaseAuth({ addTo: \"QUERY_PARAMS\" })\n+      const request = createBaseRequest({\n+        params: [\n+          {\n+            active: true,\n+            key: \"original-param\",\n+            value: \"value\",\n+            description: \"\",\n+          },\n+        ],\n+      })\n+\n+      const result = await generateAwsSignatureAuthParams(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+\n+      // only return AWS signature parameters, not the original parameter\n+      expect(result).toHaveLength(2)\n+      expect(result.find((p) => p.key === \"original-param\")).toBeUndefined()\n+      expect(result.find((p) => p.key === \"X-Amz-Algorithm\")).toBeDefined()\n+      expect(result.find((p) => p.key === \"X-Amz-Signature\")).toBeDefined()\n+    })\n+\n+    test(\"should handle template strings in endpoint\", async () => {\n+      const { AwsV4Signer } = await import(\"aws4fetch\")\n+      vi.mocked(AwsV4Signer).mockImplementation(\n+        (config) =>\n+          ({\n+            sign: vi.fn().mockResolvedValue({\n+              headers: new Map(),\n+              url: new URL(\n+                config.url +\n+                  \"?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Signature=test-signature\"\n+              ),\n+            }),\n+          }) as any\n+      )\n+\n+      const auth = createBaseAuth({ addTo: \"QUERY_PARAMS\" })\n+\n+      const envVarsWithHost: Environment[\"variables\"] = [\n+        ...mockEnvVars,\n+        {\n+          key: \"HOST\",\n+          secret: false,\n+          initialValue: \"s3.amazonaws.com\",\n+          currentValue: \"s3.amazonaws.com\",\n+        },\n+      ]\n+\n+      const request = createBaseRequest({\n+        endpoint: \"https://<<HOST>>/bucket/key\",\n+      })\n+\n+      const result = await generateAwsSignatureAuthParams(\n+        auth,\n+        request,\n+        envVarsWithHost\n+      )\n+      expect(result).toHaveLength(2)\n+    })\n+\n+    test(\"should sort existing parameters alphabetically before signing\", async () => {\n+      const { AwsV4Signer } = await import(\"aws4fetch\")\n+      vi.mocked(AwsV4Signer).mockImplementation(\n+        (config) =>\n+          ({\n+            sign: vi.fn().mockResolvedValue({\n+              headers: new Map(),\n+              url: new URL(\n+                config.url +\n+                  \"?z-param=value1&a-param=value2&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Signature=test-signature\"\n+              ),\n+            }),\n+          }) as any\n+      )\n+\n+      const auth = createBaseAuth({ addTo: \"QUERY_PARAMS\" })\n+      const request = createBaseRequest({\n+        params: [\n+          { active: true, key: \"z-param\", value: \"value1\", description: \"\" },\n+          { active: true, key: \"a-param\", value: \"value2\", description: \"\" },\n+          { active: false, key: \"inactive\", value: \"value3\", description: \"\" },\n+        ],\n+      })\n+\n+      const result = await generateAwsSignatureAuthParams(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+\n+      // exclude original parameters and only return AWS signature parameters\n+      expect(result).toHaveLength(2)\n+      expect(result.find((p) => p.key === \"z-param\")).toBeUndefined()\n+      expect(result.find((p) => p.key === \"a-param\")).toBeUndefined()\n+      expect(result.find((p) => p.key === \"inactive\")).toBeUndefined()\n+    })\n+\n+    test(\"should handle empty or missing session token\", async () => {\n+      const { AwsV4Signer } = await import(\"aws4fetch\")\n+      vi.mocked(AwsV4Signer).mockImplementation(\n+        (config) =>\n+          ({\n+            sign: vi.fn().mockResolvedValue({\n+              headers: new Map(),\n+              url: new URL(\n+                config.url +\n+                  \"?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Signature=test-signature\"\n+              ),\n+            }),\n+          }) as any\n+      )\n+\n+      const auth = createBaseAuth({ addTo: \"QUERY_PARAMS\" })\n+      const request = createBaseRequest()\n+\n+      const result = await generateAwsSignatureAuthParams(\n+        auth,\n+        request,\n+        mockEnvVars\n+      )\n+      expect(result).toHaveLength(2)\n+    })\n+  })\n+})\ndiff --git a/packages/hoppscotch-common/src/helpers/auth/types/aws-signature.ts b/packages/hoppscotch-common/src/helpers/auth/types/aws-signature.ts\nindex 4b253c9babc..1a0568ec027 100644\n--- a/packages/hoppscotch-common/src/helpers/auth/types/aws-signature.ts\n+++ b/packages/hoppscotch-common/src/helpers/auth/types/aws-signature.ts\n@@ -3,46 +3,110 @@ import {\n   HoppRESTAuth,\n   HoppRESTHeader,\n   HoppRESTParam,\n+  HoppRESTParams,\n   HoppRESTRequest,\n   parseTemplateString,\n } from \"@hoppscotch/data\"\n import { AwsV4Signer } from \"aws4fetch\"\n import { getFinalBodyFromRequest } from \"~/helpers/utils/EffectiveURL\"\n \n-export async function generateAwsSignatureAuthHeaders(\n-  auth: HoppRESTAuth & { authType: \"aws-signature\" },\n-  request: HoppRESTRequest,\n+type SignOptions = {\n+  auth: HoppRESTAuth & { authType: \"aws-signature\" }\n+  request: HoppRESTRequest\n   envVars: Environment[\"variables\"]\n-): Promise<HoppRESTHeader[]> {\n-  if (auth.addTo !== \"HEADERS\") return []\n+  signQuery?: boolean\n+}\n+\n+function processQueryParameters(\n+  params: HoppRESTParams,\n+  envVars: Environment[\"variables\"],\n+  baseUrl: string\n+): { url: URL; sortedParams: Array<{ key: string; value: string }> } {\n+  const url = new URL(baseUrl)\n+\n+  // add existing query parameters from the request in lexicographical order as per AWS documentation\n+  const sortedParams = params\n+    .filter((param) => param.active && param.key !== \"\")\n+    .map((param) => ({\n+      key: parseTemplateString(param.key, envVars),\n+      value: parseTemplateString(param.value, envVars),\n+    }))\n+    .sort((a, b) => a.key.localeCompare(b.key))\n+\n+  sortedParams.forEach((param) => {\n+    url.searchParams.append(param.key, param.value)\n+  })\n \n+  return { url, sortedParams }\n+}\n+\n+async function signAWSRequest({\n+  auth,\n+  request,\n+  envVars,\n+  signQuery = false,\n+}: SignOptions) {\n   const currentDate = new Date()\n   const amzDate = currentDate.toISOString().replace(/[:-]|\\.\\d{3}/g, \"\")\n-  const { method, endpoint } = request\n \n-  const body = getFinalBodyFromRequest(request, envVars)\n+  const baseUrl = parseTemplateString(request.endpoint, envVars)\n+  const { url, sortedParams } = processQueryParameters(\n+    request.params,\n+    envVars,\n+    baseUrl\n+  )\n+\n+  const accessKeyId = parseTemplateString(auth.accessKey, envVars)\n+  const secretAccessKey = parseTemplateString(auth.secretKey, envVars)\n+  const region = parseTemplateString(auth.region, envVars) ?? \"us-east-1\"\n+  const service = parseTemplateString(auth.serviceName, envVars)\n+  const sessionToken = auth.serviceToken\n+    ? parseTemplateString(auth.serviceToken, envVars)\n+    : undefined\n \n-  const signer = new AwsV4Signer({\n-    method: method,\n-    body: body?.toString(),\n+  const signerConfig: ConstructorParameters<typeof AwsV4Signer>[0] = {\n+    method: request.method,\n     datetime: amzDate,\n-    accessKeyId: parseTemplateString(auth.accessKey, envVars),\n-    secretAccessKey: parseTemplateString(auth.secretKey, envVars),\n-    region: parseTemplateString(auth.region, envVars) ?? \"us-east-1\",\n-    service: parseTemplateString(auth.serviceName, envVars),\n-    sessionToken:\n-      auth.serviceToken && parseTemplateString(auth.serviceToken, envVars),\n-    url: parseTemplateString(endpoint, envVars),\n-  })\n+    accessKeyId,\n+    secretAccessKey,\n+    region,\n+    service,\n+    sessionToken,\n+    url: url.toString(),\n+    signQuery,\n+  }\n+\n+  if (!signQuery) {\n+    const body = getFinalBodyFromRequest(request, envVars)\n+    signerConfig.body = body?.toString()\n+  }\n \n+  const signer = new AwsV4Signer(signerConfig)\n   const sign = await signer.sign()\n+\n+  return { sign, sortedParams }\n+}\n+\n+export async function generateAwsSignatureAuthHeaders(\n+  auth: HoppRESTAuth & { authType: \"aws-signature\" },\n+  request: HoppRESTRequest,\n+  envVars: Environment[\"variables\"]\n+): Promise<HoppRESTHeader[]> {\n+  if (auth.addTo !== \"HEADERS\") return []\n+\n+  const { sign } = await signAWSRequest({\n+    auth,\n+    request,\n+    envVars,\n+    signQuery: false,\n+  })\n   const headers: HoppRESTHeader[] = []\n \n   sign.headers.forEach((value, key) => {\n     headers.push({\n       active: true,\n-      key: key,\n-      value: value,\n+      key,\n+      value,\n       description: \"\",\n     })\n   })\n@@ -57,32 +121,25 @@ export async function generateAwsSignatureAuthParams(\n ): Promise<HoppRESTParam[]> {\n   if (auth.addTo !== \"QUERY_PARAMS\") return []\n \n-  const currentDate = new Date()\n-  const amzDate = currentDate.toISOString().replace(/[:-]|\\.\\d{3}/g, \"\")\n-\n-  const signer = new AwsV4Signer({\n-    method: request.method,\n-    datetime: amzDate,\n+  const { sign, sortedParams } = await signAWSRequest({\n+    auth,\n+    request,\n+    envVars,\n     signQuery: true,\n-    accessKeyId: parseTemplateString(auth.accessKey, envVars),\n-    secretAccessKey: parseTemplateString(auth.secretKey, envVars),\n-    region: parseTemplateString(auth.region, envVars) ?? \"us-east-1\",\n-    service: parseTemplateString(auth.serviceName, envVars),\n-    sessionToken:\n-      auth.serviceToken && parseTemplateString(auth.serviceToken, envVars),\n-    url: parseTemplateString(request.endpoint, envVars),\n   })\n-\n-  const sign = await signer.sign()\n   const params: HoppRESTParam[] = []\n \n+  const originalParams = new Set(sortedParams.map((param) => param.key))\n+\n   for (const [key, value] of sign.url.searchParams) {\n-    params.push({\n-      active: true,\n-      key: key,\n-      value: value,\n-      description: \"\",\n-    })\n+    if (!originalParams.has(key)) {\n+      params.push({\n+        active: true,\n+        key,\n+        value,\n+        description: \"\",\n+      })\n+    }\n   }\n \n   return params\n"}
