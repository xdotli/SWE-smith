{"instance_id": "PostHog__posthog.main.42729", "repo": "PostHog/posthog", "base_commit": "7e9060facaf104f63f506ff0ef5480d5704ea615", "head_commit": "67934a0548e84f66a3c1fd3ef47bed3cb116ca12", "title": "revert: \"fix(replay): account for css stylesheets\"", "merged_at": "2025-12-04T19:08:51Z", "html_url": "https://github.com/PostHog/posthog/pull/42729", "test_files": ["frontend/src/scenes/session-recordings/player/rrweb/index.test.ts"], "code_files": ["frontend/src/scenes/session-recordings/player/rrweb/index.ts"], "total_changes": 34, "num_files": 2, "pull_number": 42729, "patch": "diff --git a/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts b/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\nindex d24ed895f3be4..c71605038780d 100644\n--- a/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\n+++ b/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\n@@ -33,30 +33,6 @@ describe('CorsPlugin', () => {\n         CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n         expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/my-image.js`)\n     })\n-\n-    it('can replace a stylesheet css link', () => {\n-        const el = document.createElement('link')\n-        el.setAttribute('rel', 'stylesheet')\n-        el.href = 'https://app.posthog.com/assets/styles.css'\n-        CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n-        expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/assets/styles.css`)\n-    })\n-\n-    it('can replace a stylesheet css link with query parameters', () => {\n-        const el = document.createElement('link')\n-        el.setAttribute('rel', 'stylesheet')\n-        el.href = 'https://app.posthog.com/assets/styles.css?v=123'\n-        CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n-        expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/assets/styles.css?v=123`)\n-    })\n-\n-    it.each([\n-        'https://app.posthog.com/styles.css',\n-        'https://app.posthog.com/styles.css?v=123',\n-        'https://app.posthog.com/assets/main.css?t=1234567890',\n-    ])('should replace CSS urls', (cssUrl) => {\n-        expect(CorsPlugin._replaceCSSUrl(cssUrl)).toEqual(`https://replay.ph-proxy.com/proxy?url=${cssUrl}`)\n-    })\n })\n \n describe('WindowTitlePlugin', () => {\ndiff --git a/frontend/src/scenes/session-recordings/player/rrweb/index.ts b/frontend/src/scenes/session-recordings/player/rrweb/index.ts\nindex 8dd021ca88428..ee36a8be2ea11 100644\n--- a/frontend/src/scenes/session-recordings/player/rrweb/index.ts\n+++ b/frontend/src/scenes/session-recordings/player/rrweb/index.ts\n@@ -12,7 +12,6 @@ export const CorsPlugin: ReplayPlugin & {\n     _replaceFontCssUrls: (value: string | null) => string | null\n     _replaceFontUrl: (value: string) => string\n     _replaceJSUrl: (value: string) => string\n-    _replaceCSSUrl: (value: string) => string\n } = {\n     _replaceFontCssUrls: (value: string | null): string | null => {\n         return (\n@@ -31,10 +30,6 @@ export const CorsPlugin: ReplayPlugin & {\n         return value.replace(/^(https:\\/\\/\\S*(?:\\.js)\\S*)$/i, `${PROXY_URL}/proxy?url=$1`)\n     },\n \n-    _replaceCSSUrl: (value: string): string => {\n-        return value.replace(/^(https:\\/\\/\\S*(?:\\.css)\\S*)$/i, `${PROXY_URL}/proxy?url=$1`)\n-    },\n-\n     onBuild: (node) => {\n         if (node.nodeName === 'STYLE') {\n             const styleElement = node as HTMLStyleElement\n@@ -60,11 +55,8 @@ export const CorsPlugin: ReplayPlugin & {\n             if (!href) {\n                 return\n             }\n-            const rel = linkElement.getAttribute('rel')\n-            if (rel === 'modulepreload') {\n+            if (linkElement.getAttribute('rel') == 'modulepreload') {\n                 linkElement.href = CorsPlugin._replaceJSUrl(href)\n-            } else if (rel === 'stylesheet') {\n-                linkElement.href = CorsPlugin._replaceCSSUrl(href)\n             } else {\n                 linkElement.href = CorsPlugin._replaceFontUrl(href)\n             }\n"}
{"instance_id": "PostHog__posthog.main.42716", "repo": "PostHog/posthog", "base_commit": "7ade7ab65f97207781f2fce296da071725e3e955", "head_commit": "b4ae408f1a8d884f1dcabf9dda5f6afc2074845c", "title": "feat(logs): add timezone support for sparkline and refactor component", "merged_at": "2025-12-04T17:31:03Z", "html_url": "https://github.com/PostHog/posthog/pull/42716", "test_files": ["products/logs/frontend/logsLogic.test.ts"], "code_files": ["products/logs/frontend/LogsScene.tsx", "products/logs/frontend/components/LogsSparkline.tsx", "products/logs/frontend/logsLogic.tsx"], "total_changes": 206, "num_files": 4, "pull_number": 42716, "patch": "diff --git a/products/logs/frontend/LogsScene.tsx b/products/logs/frontend/LogsScene.tsx\nindex 62d6a84b3fcb2..d48921c51a1f0 100644\n--- a/products/logs/frontend/LogsScene.tsx\n+++ b/products/logs/frontend/LogsScene.tsx\n@@ -9,13 +9,11 @@ import {\n     LemonSegmentedButton,\n     LemonSelect,\n     LemonTable,\n-    SpinnerOverlay,\n     Tooltip,\n } from '@posthog/lemon-ui'\n \n import { CopyToClipboardInline } from 'lib/components/CopyToClipboard'\n import { ProductIntroduction } from 'lib/components/ProductIntroduction/ProductIntroduction'\n-import { Sparkline } from 'lib/components/Sparkline'\n import { TZLabel, TZLabelProps } from 'lib/components/TZLabel'\n import { ListHog } from 'lib/components/hedgehogs'\n import { FEATURE_FLAGS } from 'lib/constants'\n@@ -36,6 +34,7 @@ import { LogMessage, ProductKey } from '~/queries/schema/schema-general'\n import { PropertyOperator } from '~/types'\n \n import { LogTag } from 'products/logs/frontend/components/LogTag'\n+import { LogsSparkline } from 'products/logs/frontend/components/LogsSparkline'\n import { LogsTableRowActions } from 'products/logs/frontend/components/LogsTable/LogsTableRowActions'\n import { VirtualizedLogsList } from 'products/logs/frontend/components/VirtualizedLogsList'\n import { LogsFilterGroup } from 'products/logs/frontend/components/filters/LogsFilters/FilterGroup'\n@@ -54,9 +53,8 @@ export const scene: SceneExport = {\n }\n \n export function LogsScene(): JSX.Element {\n-    const { sparklineData, sparklineLoading, logsLoading } = useValues(logsLogic)\n-    const { runQuery, setDateRangeFromSparkline, highlightNextLog, highlightPreviousLog, toggleExpandLog } =\n-        useActions(logsLogic)\n+    const { logsLoading } = useValues(logsLogic)\n+    const { runQuery, highlightNextLog, highlightPreviousLog, toggleExpandLog } = useActions(logsLogic)\n     const { highlightedLogId: sceneHighlightedLogId } = useValues(logsLogic)\n \n     useEffect(() => {\n@@ -81,10 +79,6 @@ export function LogsScene(): JSX.Element {\n         [sceneHighlightedLogId, logsLoading, runQuery]\n     )\n \n-    const onSelectionChange = (selection: { startIndex: number; endIndex: number }): void => {\n-        setDateRangeFromSparkline(selection.startIndex, selection.endIndex)\n-    }\n-\n     return (\n         <SceneContent>\n             <SceneTitleSection\n@@ -115,21 +109,7 @@ export function LogsScene(): JSX.Element {\n                 isEmpty={false}\n             />\n             <Filters />\n-            <div className=\"relative h-40 flex flex-col\">\n-                {sparklineData.data.length > 0 ? (\n-                    <Sparkline\n-                        labels={sparklineData.labels}\n-                        data={sparklineData.data}\n-                        className=\"w-full flex-1\"\n-                        onSelectionChange={onSelectionChange}\n-                    />\n-                ) : !sparklineLoading ? (\n-                    <div className=\"flex-1 text-muted flex items-center justify-center\">\n-                        No results matching filters\n-                    </div>\n-                ) : null}\n-                {sparklineLoading && <SpinnerOverlay />}\n-            </div>\n+            <LogsSparkline />\n             <SceneDivider />\n             <LogsListContainer />\n         </SceneContent>\ndiff --git a/products/logs/frontend/components/LogsSparkline.tsx b/products/logs/frontend/components/LogsSparkline.tsx\nnew file mode 100644\nindex 0000000000000..0a75f25457f92\n--- /dev/null\n+++ b/products/logs/frontend/components/LogsSparkline.tsx\n@@ -0,0 +1,142 @@\n+import { useActions, useValues } from 'kea'\n+import { useCallback, useMemo } from 'react'\n+\n+import { LemonSelect, SpinnerOverlay } from '@posthog/lemon-ui'\n+\n+import { AnyScaleOptions, Sparkline } from 'lib/components/Sparkline'\n+import { dayjs } from 'lib/dayjs'\n+import { shortTimeZone } from 'lib/utils'\n+import { teamLogic } from 'scenes/teamLogic'\n+\n+import { SparklineTimezone, logsLogic } from '../logsLogic'\n+\n+export function LogsSparkline(): JSX.Element {\n+    const { sparklineData, sparklineLoading, sparklineTimezone } = useValues(logsLogic)\n+    const { setDateRangeFromSparkline, setSparklineTimezone } = useActions(logsLogic)\n+    const { timezone: projectTimezone } = useValues(teamLogic)\n+\n+    const deviceTimezone = shortTimeZone()\n+\n+    // Determine which timezone string to use for formatting\n+    const activeTimezone = useMemo(() => {\n+        switch (sparklineTimezone) {\n+            case SparklineTimezone.UTC:\n+                return 'UTC'\n+            case SparklineTimezone.Project:\n+                return projectTimezone\n+            case SparklineTimezone.Device:\n+            default:\n+                return undefined // undefined means local\n+        }\n+    }, [sparklineTimezone, projectTimezone])\n+\n+    // Build timezone options, deduplicating if any match\n+    const timezoneOptions = useMemo(() => {\n+        const options: { value: SparklineTimezone; label: string }[] = [{ value: SparklineTimezone.UTC, label: 'UTC' }]\n+\n+        const projectTzLabel = shortTimeZone(projectTimezone) ?? projectTimezone\n+        if (projectTimezone !== 'UTC') {\n+            options.push({ value: SparklineTimezone.Project, label: `Project (${projectTzLabel})` })\n+        }\n+\n+        if (deviceTimezone && deviceTimezone !== 'UTC' && deviceTimezone !== projectTzLabel) {\n+            options.push({ value: SparklineTimezone.Device, label: `Device (${deviceTimezone})` })\n+        }\n+\n+        return options\n+    }, [projectTimezone, deviceTimezone])\n+\n+    const showTimezoneSelector = timezoneOptions.length > 1\n+\n+    const { timeUnit, tickFormat } = useMemo(() => {\n+        if (!sparklineData.dates.length) {\n+            return { timeUnit: 'hour' as const, tickFormat: 'HH:mm:ss' }\n+        }\n+        const firstDate = dayjs(sparklineData.dates[0])\n+        const lastDate = dayjs(sparklineData.dates[sparklineData.dates.length - 1])\n+        const hoursDiff = lastDate.diff(firstDate, 'hours')\n+\n+        if (hoursDiff <= 1) {\n+            return { timeUnit: 'second' as const, tickFormat: 'HH:mm:ss' }\n+        } else if (hoursDiff <= 6) {\n+            return { timeUnit: 'minute' as const, tickFormat: 'HH:mm:ss' }\n+        } else if (hoursDiff <= 48) {\n+            return { timeUnit: 'hour' as const, tickFormat: 'HH:mm' }\n+        }\n+        return { timeUnit: 'day' as const, tickFormat: 'D MMM HH:mm' }\n+    }, [sparklineData.dates])\n+\n+    const withXScale = useCallback(\n+        (scale: AnyScaleOptions): AnyScaleOptions => {\n+            return {\n+                ...scale,\n+                type: 'timeseries',\n+                ticks: {\n+                    display: true,\n+                    maxRotation: 0,\n+                    maxTicksLimit: 6,\n+                    font: {\n+                        size: 10,\n+                        lineHeight: 1,\n+                    },\n+                    callback: function (value: string | number) {\n+                        const d = activeTimezone ? dayjs(value).tz(activeTimezone) : dayjs(value)\n+                        return d.format(tickFormat)\n+                    },\n+                },\n+                time: {\n+                    unit: timeUnit,\n+                },\n+            } as AnyScaleOptions\n+        },\n+        [timeUnit, tickFormat, activeTimezone]\n+    )\n+\n+    const renderLabel = useCallback(\n+        (label: string): string => {\n+            const d = activeTimezone ? dayjs(label).tz(activeTimezone) : dayjs(label)\n+            const tz = activeTimezone === 'UTC' ? 'UTC' : (shortTimeZone(activeTimezone, d.toDate()) ?? 'Local')\n+            return `${d.format('D MMM YYYY HH:mm:ss')} ${tz}`\n+        },\n+        [activeTimezone]\n+    )\n+\n+    const sparklineLabels = useMemo(() => {\n+        return sparklineData.dates.map((date) => dayjs(date).toISOString())\n+    }, [sparklineData.dates])\n+\n+    const onSelectionChange = useCallback(\n+        (selection: { startIndex: number; endIndex: number }): void => {\n+            setDateRangeFromSparkline(selection.startIndex, selection.endIndex)\n+        },\n+        [setDateRangeFromSparkline]\n+    )\n+\n+    return (\n+        <div className=\"relative h-40 flex flex-col\">\n+            {showTimezoneSelector && (\n+                <div className=\"absolute top-1 right-1 z-10\">\n+                    <LemonSelect\n+                        size=\"xsmall\"\n+                        value={sparklineTimezone}\n+                        onChange={(value) => value && setSparklineTimezone(value)}\n+                        options={timezoneOptions}\n+                    />\n+                </div>\n+            )}\n+            {sparklineData.data.length > 0 ? (\n+                <Sparkline\n+                    labels={sparklineLabels}\n+                    data={sparklineData.data}\n+                    className=\"w-full flex-1\"\n+                    onSelectionChange={onSelectionChange}\n+                    withXScale={withXScale}\n+                    renderLabel={renderLabel}\n+                />\n+            ) : !sparklineLoading ? (\n+                <div className=\"flex-1 text-muted flex items-center justify-center\">No results matching filters</div>\n+            ) : null}\n+            {sparklineLoading && <SpinnerOverlay />}\n+        </div>\n+    )\n+}\ndiff --git a/products/logs/frontend/logsLogic.test.ts b/products/logs/frontend/logsLogic.test.ts\nindex ff3d7aa8c9747..d8a6a00251a4a 100644\n--- a/products/logs/frontend/logsLogic.test.ts\n+++ b/products/logs/frontend/logsLogic.test.ts\n@@ -3,7 +3,7 @@ import { expectLogic } from 'kea-test-utils'\n import { LogMessage } from '~/queries/schema/schema-general'\n import { initKeaTests } from '~/test/init'\n \n-import { logsLogic } from './logsLogic'\n+import { SparklineTimezone, logsLogic } from './logsLogic'\n \n const createMockLog = (uuid: string): LogMessage => ({\n     uuid,\n@@ -194,4 +194,24 @@ describe('logsLogic', () => {\n             })\n         })\n     })\n+\n+    describe('sparklineTimezone', () => {\n+        it('updates when setSparklineTimezone is called', async () => {\n+            await expectLogic(logic, () => {\n+                logic.actions.setSparklineTimezone(SparklineTimezone.Device)\n+            })\n+                .toDispatchActions(['setSparklineTimezone'])\n+                .toMatchValues({\n+                    sparklineTimezone: SparklineTimezone.Device,\n+                })\n+\n+            await expectLogic(logic, () => {\n+                logic.actions.setSparklineTimezone(SparklineTimezone.UTC)\n+            })\n+                .toDispatchActions(['setSparklineTimezone'])\n+                .toMatchValues({\n+                    sparklineTimezone: SparklineTimezone.UTC,\n+                })\n+        })\n+    })\n })\ndiff --git a/products/logs/frontend/logsLogic.tsx b/products/logs/frontend/logsLogic.tsx\nindex 3260c948007fe..a0b377414b930 100644\n--- a/products/logs/frontend/logsLogic.tsx\n+++ b/products/logs/frontend/logsLogic.tsx\n@@ -38,6 +38,12 @@ const NEW_QUERY_STARTED_ERROR_MESSAGE = 'new query started' as const\n const DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS = 1000\n const DEFAULT_LIVE_TAIL_POLL_INTERVAL_MAX_MS = 5000\n \n+export enum SparklineTimezone {\n+    UTC = 'utc',\n+    Project = 'project',\n+    Device = 'device',\n+}\n+\n const parseLogAttributes = (logs: LogMessage[]): void => {\n     logs.forEach((row) => {\n         Object.keys(row.attributes).forEach((key) => {\n@@ -257,6 +263,7 @@ export const logsLogic = kea<logsLogicType>([\n         expireLiveTail: () => true,\n         setLiveTailExpired: (liveTailExpired: boolean) => ({ liveTailExpired }),\n         addLogsToSparkline: (logs: LogMessage[]) => logs,\n+        setSparklineTimezone: (sparklineTimezone: SparklineTimezone) => ({ sparklineTimezone }),\n     }),\n \n     reducers({\n@@ -408,6 +415,13 @@ export const logsLogic = kea<logsLogicType>([\n                 runQuery: () => false,\n             },\n         ],\n+        sparklineTimezone: [\n+            SparklineTimezone.UTC as SparklineTimezone,\n+            { persist: true },\n+            {\n+                setSparklineTimezone: (_, { sparklineTimezone }) => sparklineTimezone,\n+            },\n+        ],\n         liveTailPollInterval: [\n             DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS as number,\n             {\n"}
{"instance_id": "PostHog__posthog.main.42672", "repo": "PostHog/posthog", "base_commit": "3f92060317c7f47ed200f8300af0752c657769cb", "head_commit": "1aff155621ed5e993a0504d23c16a605db0ec9c8", "title": "chore: Fix phrasing (\"at between time and time\" to \"between time and time\")", "merged_at": "2025-12-04T12:09:22Z", "html_url": "https://github.com/PostHog/posthog/pull/42672", "test_files": ["products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts"], "code_files": ["products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts"], "total_changes": 12, "num_files": 2, "pull_number": 42672, "patch": "diff --git a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts\nindex d978403e2e384..5ef12bf3fa00d 100644\n--- a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts\n+++ b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts\n@@ -64,7 +64,7 @@ describe('stepWaitUntilTimeWindowLogic', () => {\n             workflow: partial({\n                 actions: expect.arrayContaining([\n                     expect.objectContaining({\n-                        description: 'Wait until weekends at between 09:00 and 17:00 (UTC).',\n+                        description: 'Wait until weekends between 09:00 and 17:00 (UTC).',\n                     }),\n                 ]),\n             }),\n@@ -85,7 +85,7 @@ describe('stepWaitUntilTimeWindowLogic', () => {\n             workflow: partial({\n                 actions: expect.arrayContaining([\n                     expect.objectContaining({\n-                        description: 'Wait until weekdays at between 10:00 and 18:00 (UTC).',\n+                        description: 'Wait until weekdays between 10:00 and 18:00 (UTC).',\n                     }),\n                 ]),\n             }),\n@@ -106,7 +106,7 @@ describe('stepWaitUntilTimeWindowLogic', () => {\n             workflow: partial({\n                 actions: expect.arrayContaining([\n                     expect.objectContaining({\n-                        description: 'Wait until weekdays at between 09:00 and 17:00 (America/New_York).',\n+                        description: 'Wait until weekdays between 09:00 and 17:00 (America/New_York).',\n                     }),\n                 ]),\n             }),\ndiff --git a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts\nindex 4ac804559ca2e..db4b641f45681 100644\n--- a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts\n+++ b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts\n@@ -14,7 +14,7 @@ export type WaitUntilTimeWindowConfig = {\n     time?: TimeConfig\n }\n \n-const AUTO_DESCRIPTION_REGEX = /^Wait until .+ at .+ \\(.+\\)\\.$/\n+const AUTO_DESCRIPTION_REGEX = /^Wait until .+ (at any time|between .+ and .+) \\(.+\\)\\.$/\n const LEGACY_DEFAULT_DESCRIPTION = 'Wait until a specified time window.'\n \n function capitalize(str: string): string {\n@@ -54,7 +54,9 @@ export function getWaitUntilTimeWindowDescription(day: DayConfig, time: TimeConf\n     const dayDesc = getDayDescription(day)\n     const timeDesc = getTimeDescription(time)\n     const tz = timezone || 'UTC'\n-    return `Wait until ${dayDesc} at ${timeDesc} (${tz}).`\n+    // Use \"at\" only for \"any time\", otherwise use the time description directly (e.g., \"between X and Y\")\n+    const timeClause = time === 'any' ? `at ${timeDesc}` : timeDesc\n+    return `Wait until ${dayDesc} ${timeClause} (${tz}).`\n }\n \n export function shouldAutoUpdateDescription(description: string): boolean {\n"}
{"instance_id": "PostHog__posthog.main.42640", "repo": "PostHog/posthog", "base_commit": "e1ac9f97469f120f9b0c2b28a86a1c286189486e", "head_commit": "a7ca24872b56bf4a6fa5d957e0a57c49143d1ff2", "title": "fix(replay): account for css stylesheets", "merged_at": "2025-12-04T17:52:50Z", "html_url": "https://github.com/PostHog/posthog/pull/42640", "test_files": ["frontend/src/scenes/session-recordings/player/rrweb/index.test.ts"], "code_files": ["frontend/src/scenes/session-recordings/player/rrweb/index.ts"], "total_changes": 34, "num_files": 2, "pull_number": 42640, "patch": "diff --git a/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts b/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\nindex c71605038780d..d24ed895f3be4 100644\n--- a/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\n+++ b/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\n@@ -33,6 +33,30 @@ describe('CorsPlugin', () => {\n         CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n         expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/my-image.js`)\n     })\n+\n+    it('can replace a stylesheet css link', () => {\n+        const el = document.createElement('link')\n+        el.setAttribute('rel', 'stylesheet')\n+        el.href = 'https://app.posthog.com/assets/styles.css'\n+        CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n+        expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/assets/styles.css`)\n+    })\n+\n+    it('can replace a stylesheet css link with query parameters', () => {\n+        const el = document.createElement('link')\n+        el.setAttribute('rel', 'stylesheet')\n+        el.href = 'https://app.posthog.com/assets/styles.css?v=123'\n+        CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n+        expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/assets/styles.css?v=123`)\n+    })\n+\n+    it.each([\n+        'https://app.posthog.com/styles.css',\n+        'https://app.posthog.com/styles.css?v=123',\n+        'https://app.posthog.com/assets/main.css?t=1234567890',\n+    ])('should replace CSS urls', (cssUrl) => {\n+        expect(CorsPlugin._replaceCSSUrl(cssUrl)).toEqual(`https://replay.ph-proxy.com/proxy?url=${cssUrl}`)\n+    })\n })\n \n describe('WindowTitlePlugin', () => {\ndiff --git a/frontend/src/scenes/session-recordings/player/rrweb/index.ts b/frontend/src/scenes/session-recordings/player/rrweb/index.ts\nindex ee36a8be2ea11..8dd021ca88428 100644\n--- a/frontend/src/scenes/session-recordings/player/rrweb/index.ts\n+++ b/frontend/src/scenes/session-recordings/player/rrweb/index.ts\n@@ -12,6 +12,7 @@ export const CorsPlugin: ReplayPlugin & {\n     _replaceFontCssUrls: (value: string | null) => string | null\n     _replaceFontUrl: (value: string) => string\n     _replaceJSUrl: (value: string) => string\n+    _replaceCSSUrl: (value: string) => string\n } = {\n     _replaceFontCssUrls: (value: string | null): string | null => {\n         return (\n@@ -30,6 +31,10 @@ export const CorsPlugin: ReplayPlugin & {\n         return value.replace(/^(https:\\/\\/\\S*(?:\\.js)\\S*)$/i, `${PROXY_URL}/proxy?url=$1`)\n     },\n \n+    _replaceCSSUrl: (value: string): string => {\n+        return value.replace(/^(https:\\/\\/\\S*(?:\\.css)\\S*)$/i, `${PROXY_URL}/proxy?url=$1`)\n+    },\n+\n     onBuild: (node) => {\n         if (node.nodeName === 'STYLE') {\n             const styleElement = node as HTMLStyleElement\n@@ -55,8 +60,11 @@ export const CorsPlugin: ReplayPlugin & {\n             if (!href) {\n                 return\n             }\n-            if (linkElement.getAttribute('rel') == 'modulepreload') {\n+            const rel = linkElement.getAttribute('rel')\n+            if (rel === 'modulepreload') {\n                 linkElement.href = CorsPlugin._replaceJSUrl(href)\n+            } else if (rel === 'stylesheet') {\n+                linkElement.href = CorsPlugin._replaceCSSUrl(href)\n             } else {\n                 linkElement.href = CorsPlugin._replaceFontUrl(href)\n             }\n"}
{"instance_id": "PostHog__posthog.main.42628", "repo": "PostHog/posthog", "base_commit": "e0fc7f7a8bd41e0e75e494b9ac2356c6e4543a14", "head_commit": "6be2364067e542770350f818bf0f5428a5c223d2", "title": "chore(customers): Gate customer analytics behind early access feature flag", "merged_at": "2025-12-03T22:09:47Z", "html_url": "https://github.com/PostHog/posthog/pull/42628", "test_files": ["frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts"], "code_files": ["frontend/src/lib/constants.tsx", "frontend/src/queries/nodes/DataTable/DataTable.tsx", "frontend/src/scenes/groups/Group.tsx", "frontend/src/scenes/groups/Groups.tsx", "frontend/src/scenes/groups/groupsNewLogic.ts"], "total_changes": 25, "num_files": 6, "pull_number": 42628, "patch": "diff --git a/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts b/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts\nindex 9004f8dfa1763..757be6c1b91f1 100644\n--- a/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts\n+++ b/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts\n@@ -86,7 +86,7 @@ describe('topBarSettingsButtonLogic', () => {\n         it('returns other setting section IDs regardless of CRM feature flag state', async () => {\n             router.actions.push(urls.persons())\n             featureFlagLogic.actions.setFeatureFlags([], {\n-                [FEATURE_FLAGS.CRM_ITERATION_ONE]: false,\n+                [FEATURE_FLAGS.CUSTOMER_ANALYTICS]: false,\n             })\n \n             await expectLogic(logic).toMatchValues({\n@@ -94,7 +94,7 @@ describe('topBarSettingsButtonLogic', () => {\n             })\n \n             featureFlagLogic.actions.setFeatureFlags([], {\n-                [FEATURE_FLAGS.CRM_ITERATION_ONE]: true,\n+                [FEATURE_FLAGS.CUSTOMER_ANALYTICS]: true,\n             })\n \n             await expectLogic(logic).toMatchValues({\ndiff --git a/frontend/src/lib/constants.tsx b/frontend/src/lib/constants.tsx\nindex b459816585d09..c4433c567dc8c 100644\n--- a/frontend/src/lib/constants.tsx\n+++ b/frontend/src/lib/constants.tsx\n@@ -237,10 +237,9 @@ export const FEATURE_FLAGS = {\n     ENDPOINTS: 'embedded-analytics', // owner: @sakce #team-clickhouse\n     SUPPORT_FORM_IN_ONBOARDING: 'support-form-in-onboarding', // owner: @joshsny\n     CRM_ITERATION_ONE: 'crm-iteration-one', // owner: @arthurdedeus #team-customer-analytics\n-    CRM_USAGE_METRICS: 'crm-usage-metrics', // owner: @arthurdedeus #team-customer-analytics\n     TOGGLE_PROPERTY_ARRAYS: 'toggle-property-arrays', // owner: @arthurdedeus #team-customer-analytics\n     DWH_JOIN_TABLE_PREVIEW: 'dwh-join-table-preview', // owner: @arthurdedeus #team-customer-analytics\n-    CUSTOMER_ANALYTICS: 'customer-analytics', // owner: @arthurdedeus #team-customer-analytics\n+    CUSTOMER_ANALYTICS: 'customer-analytics-roadmap', // owner: @arthurdedeus #team-customer-analytics\n     SETTINGS_SESSIONS_V2_JOIN: 'settings-sessions-v2-join', // owner: @robbie-c #team-web-analytics\n     SESSIONS_EXPLORER: 'sessions-explorer', // owner: @jabahamondes #team-web-analytics\n     SAVE_INSIGHT_TASK: 'save-insight-task', // owner: @joshsny\ndiff --git a/frontend/src/queries/nodes/DataTable/DataTable.tsx b/frontend/src/queries/nodes/DataTable/DataTable.tsx\nindex 013cc86d5bf95..2f99a9ad1faf5 100644\n--- a/frontend/src/queries/nodes/DataTable/DataTable.tsx\n+++ b/frontend/src/queries/nodes/DataTable/DataTable.tsx\n@@ -174,6 +174,7 @@ export function DataTable({\n \n     const canUseWebAnalyticsPreAggregatedTables = useFeatureFlag('SETTINGS_WEB_ANALYTICS_PRE_AGGREGATED_TABLES')\n     const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n+    const hasCustomerAnalyticsEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n     const usedWebAnalyticsPreAggregatedTables =\n         canUseWebAnalyticsPreAggregatedTables &&\n         response &&\n@@ -734,7 +735,8 @@ export function DataTable({\n     ].filter((x) => !!x)\n \n     const secondRowRight = [\n-        sourceFeatures.has(QueryFeature.linkDataButton) && hasCrmIterationOneEnabled ? (\n+        sourceFeatures.has(QueryFeature.linkDataButton) &&\n+        (hasCrmIterationOneEnabled || hasCustomerAnalyticsEnabled) ? (\n             <ViewLinkButton tableName=\"groups\" />\n         ) : null,\n         (showColumnConfigurator || showPersistentColumnConfigurator) &&\ndiff --git a/frontend/src/scenes/groups/Group.tsx b/frontend/src/scenes/groups/Group.tsx\nindex 92be4f42acd96..148c29e54ceab 100644\n--- a/frontend/src/scenes/groups/Group.tsx\n+++ b/frontend/src/scenes/groups/Group.tsx\n@@ -121,7 +121,7 @@ export function Group({ tabId }: { tabId?: string }): JSX.Element {\n                         label: <span data-attr=\"groups-overview-tab\">Overview</span>,\n                         content: <GroupOverview groupData={groupData} />,\n                     },\n-                    ...(featureFlags[FEATURE_FLAGS.CRM_ITERATION_ONE] && groupData.notebook\n+                    ...(featureFlags[FEATURE_FLAGS.CUSTOMER_ANALYTICS] && groupData.notebook\n                         ? [\n                               {\n                                   key: GroupsTabType.NOTES,\ndiff --git a/frontend/src/scenes/groups/Groups.tsx b/frontend/src/scenes/groups/Groups.tsx\nindex c4a4b5370c8a9..a83a6343156c6 100644\n--- a/frontend/src/scenes/groups/Groups.tsx\n+++ b/frontend/src/scenes/groups/Groups.tsx\n@@ -46,7 +46,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n \n     const { groupsAccessStatus } = useValues(groupsAccessLogic)\n     const { aggregationLabel } = useValues(groupsModel)\n-    const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n+    const hasCustomerAnalyticsEnabled = useFeatureFlag('CUSTOMER_ANALYTICS')\n \n     if (groupTypeIndex === undefined) {\n         throw new Error('groupTypeIndex is undefined')\n@@ -79,7 +79,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n         },\n     } as QueryContext['columns']\n     let hiddenColumns = [] as string[]\n-    if (hasCrmIterationOneEnabled) {\n+    if (hasCustomerAnalyticsEnabled) {\n         columns = getCRMColumns(groupTypeName, groupTypeIndex)\n         hiddenColumns.push('key')\n     }\n@@ -95,7 +95,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n                     type: 'cohort',\n                 }}\n                 actions={\n-                    hasCrmIterationOneEnabled ? (\n+                    hasCustomerAnalyticsEnabled ? (\n                         <LemonButton\n                             type=\"primary\"\n                             size=\"small\"\n@@ -135,7 +135,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n                 dataAttr=\"groups-table\"\n             />\n \n-            {hasCrmIterationOneEnabled && (\n+            {hasCustomerAnalyticsEnabled && (\n                 <LemonModal\n                     isOpen={saveGroupViewModalOpen}\n                     onClose={() => setSaveGroupViewModalOpen(false)}\ndiff --git a/frontend/src/scenes/groups/groupsNewLogic.ts b/frontend/src/scenes/groups/groupsNewLogic.ts\nindex 035f7a3134995..15cf699b4d92a 100644\n--- a/frontend/src/scenes/groups/groupsNewLogic.ts\n+++ b/frontend/src/scenes/groups/groupsNewLogic.ts\n@@ -213,8 +213,8 @@ export const groupsNewLogic = kea<groupsNewLogicType>([\n     })),\n \n     afterMount(({ props, values }) => {\n-        // Redirect if the CRM feature flag is not enabled\n-        if (!values.featureFlags[FEATURE_FLAGS.CRM_ITERATION_ONE]) {\n+        // Redirect if customer analytics is not enabled\n+        if (!values.featureFlags[FEATURE_FLAGS.CUSTOMER_ANALYTICS]) {\n             router.actions.push(urls.groups(props.groupTypeIndex))\n         }\n     }),\n"}
{"instance_id": "PostHog__posthog.main.42599", "repo": "PostHog/posthog", "base_commit": "9d66861e8cf6e1d81d7b371a79e565a1a6273357", "head_commit": "48833e7f479f48767650d458cc5fe8eff8df4313", "title": "fix(workflows): dont bill for hogflow invocations", "merged_at": "2025-12-03T17:44:55Z", "html_url": "https://github.com/PostHog/posthog/pull/42599", "test_files": ["plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts"], "code_files": ["plugin-server/src/cdp/consumers/cdp-events.consumer.ts"], "total_changes": 36, "num_files": 2, "pull_number": 42599, "patch": "diff --git a/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts b/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts\nindex 47125eae22135..fe056d73e532e 100644\n--- a/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts\n+++ b/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts\n@@ -534,5 +534,33 @@ describe('hog flow processing', () => {\n                 teamId: 2,\n             })\n         })\n+\n+        it('should not produce billable_invocation metrics for hog flow invocations', async () => {\n+            await insertHogFlow(\n+                new FixtureHogFlowBuilder()\n+                    .withTeamId(team.id)\n+                    .withSimpleWorkflow({\n+                        trigger: {\n+                            type: 'event',\n+                            filters: HOG_FILTERS_EXAMPLES.pageview_or_autocapture_filter.filters ?? {},\n+                        },\n+                    })\n+                    .build()\n+            )\n+\n+            await processor['createHogFlowInvocations']([globals])\n+\n+            const producedMetrics =\n+                mockProducerObserver.getProducedKafkaMessagesForTopic('clickhouse_app_metrics2_test')\n+            expect(producedMetrics).not.toEqual(\n+                expect.arrayContaining([\n+                    expect.objectContaining({\n+                        value: expect.objectContaining({\n+                            metric_name: 'billable_invocation',\n+                        }),\n+                    }),\n+                ])\n+            )\n+        })\n     })\n })\ndiff --git a/plugin-server/src/cdp/consumers/cdp-events.consumer.ts b/plugin-server/src/cdp/consumers/cdp-events.consumer.ts\nindex 6f44c0c5f3d5c..5236d5060b960 100644\n--- a/plugin-server/src/cdp/consumers/cdp-events.consumer.ts\n+++ b/plugin-server/src/cdp/consumers/cdp-events.consumer.ts\n@@ -375,14 +375,6 @@ export class CdpEventsConsumer extends CdpConsumerBase {\n                 metric_name: 'triggered',\n                 count: 1,\n             })\n-\n-            triggeredInvocationsMetrics.push({\n-                team_id: item.teamId,\n-                app_source_id: item.functionId,\n-                metric_kind: 'billing',\n-                metric_name: 'billable_invocation',\n-                count: 1,\n-            })\n         })\n \n         this.hogFunctionMonitoringService.queueAppMetrics(triggeredInvocationsMetrics, 'hog_flow')\n"}
{"instance_id": "PostHog__posthog.main.42570", "repo": "PostHog/posthog", "base_commit": "1eef58d5b1a249b5cb594431065fa5590cbff5b0", "head_commit": "122f638320d8fc3e71e3094b1cee90002c247098", "title": "feat(persons): Update app* attributes", "merged_at": "2025-12-04T08:34:20Z", "html_url": "https://github.com/PostHog/posthog/pull/42570", "test_files": ["plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts", "plugin-server/src/worker/ingestion/persons/person-update.test.ts"], "code_files": ["plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts", "plugin-server/src/worker/ingestion/persons/person-property-utils.ts", "plugin-server/src/worker/ingestion/persons/person-update.ts"], "total_changes": 214, "num_files": 5, "pull_number": 42570, "patch": "diff --git a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts\nindex c4e46a8913bff..8d7f96b85fdd0 100644\n--- a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts\n+++ b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts\n@@ -1557,15 +1557,16 @@ describe('BatchWritingPersonStore', () => {\n             typeof personPropertyKeyUpdateCounter\n         >\n \n-        it('should skip database write when only eventToPersonProperties are updated', async () => {\n+        it('should skip database write when only filtered properties are updated', async () => {\n             const mockRepo = createMockRepository()\n             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n \n             // Update person with only filtered properties (existing properties being updated)\n+            // Using $current_url and $pathname which are in FILTERED_PERSON_UPDATE_PROPERTIES\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n-                { ...person, properties: { $browser: 'Firefox', $app_build: '100' } },\n-                { $browser: 'Chrome', $app_build: '200' },\n+                { ...person, properties: { $current_url: 'https://old.com', $pathname: '/old' } },\n+                { $current_url: 'https://new.com', $pathname: '/new' },\n                 [],\n                 {},\n                 'test'\n@@ -1585,10 +1586,10 @@ describe('BatchWritingPersonStore', () => {\n             )\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledTimes(2)\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$browser',\n+                property: '$current_url',\n             })\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$app_build',\n+                property: '$pathname',\n             })\n             // personPropertyKeyUpdateCounter should NOT be called for 'ignored' outcomes\n             expect(mockPersonPropertyKeyUpdateCounter.labels).not.toHaveBeenCalled()\n@@ -1744,9 +1745,10 @@ describe('BatchWritingPersonStore', () => {\n             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n \n             // Update person with only filtered properties but with force_update=true (simulating $identify/$set events)\n+            // Using $current_url and $pathname which are in FILTERED_PERSON_UPDATE_PROPERTIES\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n-                { ...person, properties: { $browser: 'Firefox', $app_build: '100' } },\n-                { $browser: 'Chrome', $app_build: '200' },\n+                { ...person, properties: { $current_url: 'https://old.com', $pathname: '/old' } },\n+                { $current_url: 'https://new.com', $pathname: '/new' },\n                 [],\n                 {},\n                 'test',\n@@ -1768,8 +1770,8 @@ describe('BatchWritingPersonStore', () => {\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n             // personPropertyKeyUpdateCounter should be called for the updated properties\n             expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledTimes(2)\n-            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$browser' })\n-            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$app_build' })\n+            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$current_url' })\n+            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: '$pathname' })\n         })\n \n         it('integration: multiple events with only filtered properties should not trigger database write', async () => {\n@@ -1777,28 +1779,29 @@ describe('BatchWritingPersonStore', () => {\n             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n \n+            // Using properties that are in FILTERED_PERSON_UPDATE_PROPERTIES\n             const personWithFiltered = {\n                 ...person,\n                 properties: {\n-                    $browser: 'Firefox',\n-                    $app_build: '100',\n+                    $current_url: 'https://old.com',\n+                    $pathname: '/old',\n                     $geoip_latitude: 40.7128,\n                 },\n             }\n \n-            // Event 1: Update browser\n+            // Event 1: Update current_url (filtered)\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $browser: 'Chrome' },\n+                { $current_url: 'https://new.com' },\n                 [],\n                 {},\n                 'test'\n             )\n \n-            // Event 2: Update app build\n+            // Event 2: Update pathname (filtered)\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $app_build: '200' },\n+                { $pathname: '/new' },\n                 [],\n                 {},\n                 'test'\n@@ -1827,10 +1830,10 @@ describe('BatchWritingPersonStore', () => {\n             )\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledTimes(3)\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$browser',\n+                property: '$current_url',\n             })\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$app_build',\n+                property: '$pathname',\n             })\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n                 property: '$geoip_latitude',\n@@ -2098,18 +2101,19 @@ describe('BatchWritingPersonStore', () => {\n             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n \n+            // Using properties that are in FILTERED_PERSON_UPDATE_PROPERTIES\n             const personWithFiltered = {\n                 ...person,\n                 properties: {\n-                    $browser: 'Firefox',\n-                    $app_build: '100',\n+                    $current_url: 'https://old.com',\n+                    $pathname: '/old',\n                 },\n             }\n \n             // Event 1: Normal event with filtered properties\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $browser: 'Chrome' },\n+                { $current_url: 'https://new.com' },\n                 [],\n                 {},\n                 'test'\n@@ -2119,7 +2123,7 @@ describe('BatchWritingPersonStore', () => {\n             // Event 2: Another normal event with filtered properties\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $app_build: '200' },\n+                { $pathname: '/new' },\n                 [],\n                 {},\n                 'test'\n@@ -2129,7 +2133,7 @@ describe('BatchWritingPersonStore', () => {\n             // Event 3: Yet another normal event with filtered properties\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $browser: 'Safari' },\n+                { $current_url: 'https://another.com' },\n                 [],\n                 {},\n                 'test'\n@@ -2151,10 +2155,10 @@ describe('BatchWritingPersonStore', () => {\n             // Properties should be marked as ignored\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledTimes(2)\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$browser',\n+                property: '$current_url',\n             })\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$app_build',\n+                property: '$pathname',\n             })\n             // personPropertyKeyUpdateCounter should NOT be called for 'ignored' outcomes\n             expect(mockPersonPropertyKeyUpdateCounter.labels).not.toHaveBeenCalled()\ndiff --git a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts\nindex 950dcc22aee0a..958f258fff405 100644\n--- a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts\n+++ b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts\n@@ -36,7 +36,8 @@ import {\n     personWriteMethodAttemptCounter,\n     totalPersonUpdateLatencyPerBatchHistogram,\n } from './metrics'\n-import { getMetricKey, isFilteredPersonPropertyKey } from './person-update'\n+import { isFilteredPersonUpdateProperty } from './person-property-utils'\n+import { getMetricKey } from './person-update'\n import { PersonUpdate, fromInternalPerson, toInternalPerson } from './person-update-batch'\n import { PersonsStore } from './persons-store'\n import { FlushResult, PersonsStoreForBatch } from './persons-store-for-batch'\n@@ -206,7 +207,7 @@ export class BatchWritingPersonsStoreForBatch implements PersonsStoreForBatch, B\n                 return true\n             }\n \n-            const isFiltered = isFilteredPersonPropertyKey(key)\n+            const isFiltered = isFilteredPersonUpdateProperty(key)\n             if (isFiltered) {\n                 ignoredProperties.push(key)\n                 return false\ndiff --git a/plugin-server/src/worker/ingestion/persons/person-property-utils.ts b/plugin-server/src/worker/ingestion/persons/person-property-utils.ts\nindex dfbdf3f1cf54c..b576133eeeed5 100644\n--- a/plugin-server/src/worker/ingestion/persons/person-property-utils.ts\n+++ b/plugin-server/src/worker/ingestion/persons/person-property-utils.ts\n@@ -143,3 +143,68 @@ export const initialCampaignParams = new Set(\n export const initialEventToPersonProperties = new Set(\n     Array.from(eventToPersonProperties, (key) => `$initial_${key.replace('$', '')}`)\n )\n+\n+/**\n+ * Properties that should NOT trigger a person update on their own.\n+ * These change frequently but aren't valuable enough to update the person record for.\n+ * They will still be included in the person properties when an update happens for other reasons.\n+ *\n+ * This is the single source of truth for person update filtering logic.\n+ *\n+ * Note: Properties NOT in this list will trigger updates by default.\n+ *\n+ * GeoIP properties source: posthog/geoip.py and posthog/taxonomy/taxonomy.py\n+ * GeoIP properties that DO trigger updates (not listed here): $geoip_country_name, $geoip_city_name\n+ */\n+export const FILTERED_PERSON_UPDATE_PROPERTIES = new Set([\n+    // URL/navigation properties - change on every page view\n+    '$current_url',\n+    '$pathname',\n+    '$referring_domain',\n+    '$referrer',\n+\n+    // Screen/viewport dimensions - can change on window resize\n+    '$screen_height',\n+    '$screen_width',\n+    '$viewport_height',\n+    '$viewport_width',\n+\n+    // Browser/device properties - change less frequently but still filtered\n+    '$browser',\n+    '$browser_version',\n+    '$device_type',\n+    '$raw_user_agent',\n+    '$os',\n+    '$os_name',\n+    '$os_version',\n+\n+    // GeoIP properties - filtered because they change frequently\n+    '$geoip_postal_code',\n+    '$geoip_time_zone',\n+    '$geoip_latitude',\n+    '$geoip_longitude',\n+    '$geoip_accuracy_radius',\n+    '$geoip_subdivision_1_code',\n+    '$geoip_subdivision_1_name',\n+    '$geoip_subdivision_2_code',\n+    '$geoip_subdivision_2_name',\n+    '$geoip_subdivision_3_code',\n+    '$geoip_subdivision_3_name',\n+    '$geoip_city_confidence',\n+    '$geoip_country_confidence',\n+    '$geoip_postal_code_confidence',\n+    '$geoip_subdivision_1_confidence',\n+    '$geoip_subdivision_2_confidence',\n+])\n+\n+/**\n+ * Determines if a property key should be filtered out from triggering person updates.\n+ * These are properties that change frequently but aren't valuable enough to update the person record for.\n+ *\n+ * This is the single source of truth for property filtering logic, used by both:\n+ * - Event-level processing (computeEventPropertyUpdates in person-update.ts)\n+ * - Batch-level processing (getPersonUpdateOutcome in batch-writing-person-store.ts)\n+ */\n+export function isFilteredPersonUpdateProperty(key: string): boolean {\n+    return FILTERED_PERSON_UPDATE_PROPERTIES.has(key)\n+}\ndiff --git a/plugin-server/src/worker/ingestion/persons/person-update.test.ts b/plugin-server/src/worker/ingestion/persons/person-update.test.ts\nindex c55c6e1cd95e3..9790636a47bf7 100644\n--- a/plugin-server/src/worker/ingestion/persons/person-update.test.ts\n+++ b/plugin-server/src/worker/ingestion/persons/person-update.test.ts\n@@ -1,7 +1,7 @@\n import { PluginEvent } from '@posthog/plugin-scaffold'\n \n import { personProfileIgnoredPropertiesCounter, personProfileUpdateOutcomeCounter } from './metrics'\n-import { eventToPersonProperties } from './person-property-utils'\n+import { FILTERED_PERSON_UPDATE_PROPERTIES } from './person-property-utils'\n import { applyEventPropertyUpdates, computeEventPropertyUpdates } from './person-update'\n \n jest.mock('./metrics', () => ({\n@@ -123,9 +123,9 @@ describe('person-update', () => {\n             })\n         })\n \n-        describe('eventToPersonProperties accepted at event level', () => {\n-            it.each(Array.from(eventToPersonProperties))(\n-                'should accept \"%s\" updates at event level (filtering happens at batch level)',\n+        describe('filtered properties behavior', () => {\n+            it.each(Array.from(FILTERED_PERSON_UPDATE_PROPERTIES))(\n+                'should mark \"%s\" as ignored when updated',\n                 (propertyName) => {\n                     const event: PluginEvent = {\n                         event: 'pageview',\n@@ -141,8 +141,7 @@ describe('person-update', () => {\n                     expect(result.hasChanges).toBe(true)\n                     expect(result.toSet).toEqual({ [propertyName]: 'new_value' })\n                     expect(result.shouldForceUpdate).toBe(false)\n-                    // At event level, this property would be marked as ignored (outcome: 'ignored')\n-                    // but it's still included in toSet for batch-level filtering\n+                    // Filtered properties are marked as ignored\n                     expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                     expect(mockPersonProfileUpdateOutcomeCounter.labels({ outcome: 'ignored' }).inc).toHaveBeenCalled()\n                     expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n@@ -250,54 +249,54 @@ describe('person-update', () => {\n                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n             })\n \n-            it('should accept eventToPersonProperties even when mixed with unchanged custom properties', () => {\n+            it('should accept filtered properties even when mixed with unchanged custom properties', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n-                        $set: { $browser: 'Chrome', custom_prop: 'same_value' },\n+                        $set: { $current_url: 'https://example.com/new', custom_prop: 'same_value' },\n                     },\n                 } as any\n \n-                const personProperties = { $browser: 'Firefox', custom_prop: 'same_value' }\n+                const personProperties = { $current_url: 'https://example.com/old', custom_prop: 'same_value' }\n \n                 const result = computeEventPropertyUpdates(event, personProperties)\n \n                 expect(result.hasChanges).toBe(true)\n-                expect(result.toSet).toEqual({ $browser: 'Chrome' })\n+                expect(result.toSet).toEqual({ $current_url: 'https://example.com/new' })\n                 expect(result.shouldForceUpdate).toBe(false)\n-                // At event level, $browser would be marked as ignored\n+                // $current_url is filtered, so it should be marked as ignored\n                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                    property: '$browser',\n+                    property: '$current_url',\n                 })\n             })\n \n-            it('should accept multiple eventToPersonProperties at event level', () => {\n-                // Note: Campaign properties (utm_source, utm_campaign) are no longer in eventToPersonProperties\n-                // and will trigger updates like custom properties\n+            it('should accept multiple filtered properties at event level', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n                         $set: {\n-                            $browser: 'Chrome',\n-                            $os: 'macOS',\n+                            $current_url: 'https://example.com/new',\n+                            $pathname: '/new-path',\n                         },\n                     },\n                 } as any\n \n                 const personProperties = {\n-                    $browser: 'Firefox',\n-                    $os: 'Windows',\n+                    $current_url: 'https://example.com/old',\n+                    $pathname: '/old-path',\n                 }\n \n                 const result = computeEventPropertyUpdates(event, personProperties)\n \n                 expect(result.hasChanges).toBe(true)\n                 expect(result.shouldForceUpdate).toBe(false)\n-                // At event level, eventToPersonProperties would be marked as ignored\n+                // Filtered properties should be marked as ignored\n                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n-                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$browser' })\n-                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$os' })\n+                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n+                    property: '$current_url',\n+                })\n+                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({ property: '$pathname' })\n             })\n         })\n \n@@ -376,7 +375,7 @@ describe('person-update', () => {\n         })\n \n         describe('person events behavior', () => {\n-            it('should compute updates for eventToPersonProperties on $identify events', () => {\n+            it('should compute updates for any property on $identify events', () => {\n                 const event: PluginEvent = {\n                     event: '$identify',\n                     properties: {\n@@ -394,7 +393,7 @@ describe('person-update', () => {\n                 expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n             })\n \n-            it('should compute updates for eventToPersonProperties on $set events', () => {\n+            it('should compute updates for any property on $set events', () => {\n                 const event: PluginEvent = {\n                     event: '$set',\n                     properties: {\n@@ -466,7 +465,7 @@ describe('person-update', () => {\n         })\n \n         describe('mixed scenarios', () => {\n-            it('should compute updates when both custom and eventToPersonProperties change', () => {\n+            it('should compute updates when both custom and allowed properties change', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n@@ -486,8 +485,8 @@ describe('person-update', () => {\n         })\n \n         describe('updateAllProperties flag enabled', () => {\n-            it.each(Array.from(eventToPersonProperties))(\n-                'should trigger update for \"%s\" when updateAllProperties is true',\n+            it.each(Array.from(FILTERED_PERSON_UPDATE_PROPERTIES))(\n+                'should trigger update for filtered property \"%s\" when updateAllProperties is true',\n                 (propertyName) => {\n                     const event: PluginEvent = {\n                         event: 'pageview',\n@@ -529,7 +528,7 @@ describe('person-update', () => {\n                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n             })\n \n-            it('should trigger update for multiple eventToPersonProperties when updateAllProperties is true', () => {\n+            it('should trigger update for multiple allowed properties when updateAllProperties is true', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n@@ -555,7 +554,7 @@ describe('person-update', () => {\n                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n             })\n \n-            it('should trigger update for mixed eventToPersonProperties and custom properties when updateAllProperties is true', () => {\n+            it('should trigger update for mixed allowed and custom properties when updateAllProperties is true', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n@@ -575,7 +574,7 @@ describe('person-update', () => {\n                 expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n             })\n \n-            it('should trigger update for mixed $geoip_* and eventToPersonProperties when updateAllProperties is true', () => {\n+            it('should trigger update for mixed $geoip_* and allowed properties when updateAllProperties is true', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\ndiff --git a/plugin-server/src/worker/ingestion/persons/person-update.ts b/plugin-server/src/worker/ingestion/persons/person-update.ts\nindex 9b40787ff1928..1b2ebca4071e2 100644\n--- a/plugin-server/src/worker/ingestion/persons/person-update.ts\n+++ b/plugin-server/src/worker/ingestion/persons/person-update.ts\n@@ -5,7 +5,11 @@ import { cloneObject } from '~/utils/utils'\n import { InternalPerson } from '../../../types'\n import { logger } from '../../../utils/logger'\n import { personProfileIgnoredPropertiesCounter, personProfileUpdateOutcomeCounter } from './metrics'\n-import { eventToPersonProperties, initialEventToPersonProperties } from './person-property-utils'\n+import {\n+    eventToPersonProperties,\n+    initialEventToPersonProperties,\n+    isFilteredPersonUpdateProperty,\n+} from './person-property-utils'\n \n export interface PropertyUpdates {\n     toSet: Properties\n@@ -19,10 +23,6 @@ export interface PropertyUpdates {\n const NO_PERSON_UPDATE_EVENTS = new Set(['$exception', '$$heatmap'])\n const PERSON_EVENTS = new Set(['$identify', '$create_alias', '$merge_dangerously', '$set'])\n \n-// GeoIP properties that should still trigger person updates even when other geoip properties are blocked\n-// These are commonly used for segmentation and are worth keeping up-to-date\n-const ALLOWED_GEOIP_PROPERTIES = new Set(['$geoip_country_name', '$geoip_city_name'])\n-\n // For tracking what property keys cause us to update persons\n // tracking all properties we add from the event, 'geoip' for '$geoip_*' or '$initial_geoip_*' and 'other' for anything outside of those\n export function getMetricKey(key: string): string {\n@@ -173,27 +173,6 @@ export function applyEventPropertyUpdates(\n     return [updatedPerson, updated]\n }\n \n-/**\n- * Determines if a property key should be filtered out from triggering person updates.\n- * These are properties that change frequently but aren't valuable enough to update the person record for.\n- *\n- * This is the single source of truth for property filtering logic, used by both:\n- * - Event-level processing (computeEventPropertyUpdates)\n- * - Batch-level processing (getPersonUpdateOutcome in batch-writing-person-store)\n- */\n-export function isFilteredPersonPropertyKey(key: string): boolean {\n-    // These are properties we add from the event and some change often, it's useless to update person always\n-    if (eventToPersonProperties.has(key)) {\n-        return true\n-    }\n-    // same as above, coming from GeoIP plugin\n-    // but allow country and city updates as they're commonly used for segmentation\n-    if (key.startsWith('$geoip_')) {\n-        return !ALLOWED_GEOIP_PROPERTIES.has(key)\n-    }\n-    return false\n-}\n-\n // Minimize useless person updates by not overriding properties if it's not a person event and we added from the event\n // They will still show up for PoE as it's not removed from the event, we just don't update the person in PG anymore\n function shouldUpdatePersonIfOnlyChange(event: PluginEvent, key: string, updateAllProperties: boolean): boolean {\n@@ -205,5 +184,5 @@ function shouldUpdatePersonIfOnlyChange(event: PluginEvent, key: string, updateA\n         // for person events always update everything\n         return true\n     }\n-    return !isFilteredPersonPropertyKey(key)\n+    return !isFilteredPersonUpdateProperty(key)\n }\n"}
{"instance_id": "PostHog__posthog.main.42569", "repo": "PostHog/posthog", "base_commit": "ecae84a58c3a843ff35a4c105beec5b78f8ff5d9", "head_commit": "6e8d3bfa86633fd85c8ecc7bce72ca81bf879322", "title": "feat(DateFilter): add fixed date range with time picker", "merged_at": "2025-12-03T12:56:00Z", "html_url": "https://github.com/PostHog/posthog/pull/42569", "test_files": ["frontend/src/lib/components/DateFilter/DateFilter.test.tsx", "frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.test.tsx", "frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts"], "code_files": ["frontend/src/lib/components/DateFilter/DateFilter.tsx", "frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.tsx", "frontend/src/lib/components/DateFilter/dateFilterLogic.ts", "frontend/src/lib/components/DateFilter/types.ts", "products/logs/frontend/filters/DateRangeFilter.tsx"], "total_changes": 426, "num_files": 8, "pull_number": 42569, "patch": "diff --git a/frontend/src/lib/components/DateFilter/DateFilter.test.tsx b/frontend/src/lib/components/DateFilter/DateFilter.test.tsx\nindex 0884e1c9243f5..b05a8b62a3e5d 100644\n--- a/frontend/src/lib/components/DateFilter/DateFilter.test.tsx\n+++ b/frontend/src/lib/components/DateFilter/DateFilter.test.tsx\n@@ -54,3 +54,40 @@ describe('DateFilter', () => {\n         await waitFor(() => expect(onChange).toHaveBeenCalledWith('-5d', '', false))\n     })\n })\n+\n+describe('DateFilter with allowFixedRangeWithTime', () => {\n+    let onChange = jest.fn()\n+    beforeEach(() => {\n+        initKeaTests()\n+        onChange = jest.fn()\n+        render(\n+            <Provider>\n+                <DateFilter onChange={onChange} dateOptions={dateMapping} allowFixedRangeWithTime />\n+            </Provider>\n+        )\n+    })\n+\n+    afterEach(() => {\n+        cleanup()\n+    })\n+\n+    it('shows custom fixed date range with time option', async () => {\n+        const dateFilter = screen.getByTestId('date-filter')\n+        userEvent.click(dateFilter)\n+\n+        expect(screen.getByText(/custom fixed date range with time/i)).toBeInTheDocument()\n+        expect(screen.getByText(/custom fixed date range\u2026$/i)).toBeInTheDocument()\n+    })\n+\n+    it('opens the time range picker when clicking custom fixed date range with time', async () => {\n+        const dateFilter = screen.getByTestId('date-filter')\n+        userEvent.click(dateFilter)\n+\n+        const timeRangeOption = screen.getByText(/custom fixed date range with time/i)\n+        userEvent.click(timeRangeOption)\n+\n+        await waitFor(() => {\n+            expect(screen.getByText(/select a date and time range/i)).toBeInTheDocument()\n+        })\n+    })\n+})\ndiff --git a/frontend/src/lib/components/DateFilter/DateFilter.tsx b/frontend/src/lib/components/DateFilter/DateFilter.tsx\nindex a9501746a48b4..5ec8dfaa2f725 100644\n--- a/frontend/src/lib/components/DateFilter/DateFilter.tsx\n+++ b/frontend/src/lib/components/DateFilter/DateFilter.tsx\n@@ -24,6 +24,7 @@ import { ResolvedDateRangeResponse } from '~/queries/schema/schema-general'\n import { DateMappingOption, PropertyOperator } from '~/types'\n \n import { PropertyFilterDatePicker } from '../PropertyFilters/components/PropertyFilterDatePicker'\n+import { FixedRangeWithTimePicker } from './FixedRangeWithTimePicker'\n import { RollingDateRangeFilter } from './RollingDateRangeFilter'\n import { dateFilterLogic } from './dateFilterLogic'\n import { DateOption } from './rollingDateRangeFilterLogic'\n@@ -54,6 +55,7 @@ interface RawDateFilterProps extends DateFilterProps {\n     max?: number | null\n     allowedRollingDateOptions?: DateOption[]\n     allowTimePrecision?: boolean\n+    allowFixedRangeWithTime?: boolean\n     /**\n      * Granularity is picked based on the dateFrom value\n      * but can be overridden to force a specific granularity.\n@@ -82,6 +84,7 @@ export function DateFilter({\n     isFixedDateMode = false,\n     allowedRollingDateOptions,\n     allowTimePrecision = false,\n+    allowFixedRangeWithTime = false,\n     placeholder,\n     fullWidth = false,\n     forceGranularity,\n@@ -105,6 +108,7 @@ export function DateFilter({\n     const {\n         open,\n         openFixedRange,\n+        openFixedRangeWithTime,\n         openDateToNow,\n         openFixedDate,\n         close,\n@@ -121,6 +125,7 @@ export function DateFilter({\n         rangeDateTo,\n         label,\n         isFixedRange,\n+        isFixedRangeWithTime,\n         isDateToNow,\n         isFixedDate,\n         isRollingDateRange,\n@@ -146,6 +151,13 @@ export function DateFilter({\n                 onClose={open}\n                 months={2}\n             />\n+        ) : view === DateFilterView.FixedRangeWithTime ? (\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={rangeDateFrom}\n+                rangeDateTo={rangeDateTo}\n+                setDate={setDate}\n+                onClose={open}\n+            />\n         ) : view === DateFilterView.DateToNow ? (\n             <LemonCalendarSelect\n                 value={rangeDateFrom ?? dayjs()}\n@@ -246,9 +258,14 @@ export function DateFilter({\n                         <LemonButton onClick={openDateToNow} active={isDateToNow} fullWidth>\n                             From custom date until now\u2026\n                         </LemonButton>\n-                        <LemonButton onClick={openFixedRange} active={isFixedRange} fullWidth>\n+                        <LemonButton onClick={openFixedRange} active={isFixedRange && !isFixedRangeWithTime} fullWidth>\n                             Custom fixed date range\u2026\n                         </LemonButton>\n+                        {allowFixedRangeWithTime && (\n+                            <LemonButton onClick={openFixedRangeWithTime} active={isFixedRangeWithTime} fullWidth>\n+                                Custom fixed date range with time\u2026\n+                            </LemonButton>\n+                        )}\n                     </>\n                 )}\n                 {showExplicitDateToggle && (\ndiff --git a/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.test.tsx b/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.test.tsx\nnew file mode 100644\nindex 0000000000000..891363886c69e\n--- /dev/null\n+++ b/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.test.tsx\n@@ -0,0 +1,127 @@\n+import '@testing-library/jest-dom'\n+import { render, screen, within } from '@testing-library/react'\n+import userEvent from '@testing-library/user-event'\n+\n+import { dayjs } from 'lib/dayjs'\n+\n+import { FixedRangeWithTimePicker } from './FixedRangeWithTimePicker'\n+\n+describe('FixedRangeWithTimePicker', () => {\n+    const setDate = jest.fn()\n+    const onClose = jest.fn()\n+\n+    beforeEach(() => {\n+        jest.clearAllMocks()\n+    })\n+\n+    it('renders header', () => {\n+        render(<FixedRangeWithTimePicker rangeDateFrom={null} rangeDateTo={null} setDate={setDate} onClose={onClose} />)\n+\n+        expect(screen.getByText(/select a date and time range/i)).toBeInTheDocument()\n+    })\n+\n+    it('renders Start and End buttons', () => {\n+        render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T10:00:00')}\n+                rangeDateTo={dayjs('2024-01-15T11:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        expect(screen.getAllByText(/start:/i).length).toBeGreaterThan(0)\n+        expect(screen.getAllByText(/end:/i).length).toBeGreaterThan(0)\n+    })\n+\n+    it('calls onClose when close button is clicked', () => {\n+        const { container } = render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T10:00:00')}\n+                rangeDateTo={dayjs('2024-01-15T11:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        const closeButton = container.querySelector('[aria-label=\"close\"]') as HTMLElement\n+        expect(closeButton).toBeTruthy()\n+        userEvent.click(closeButton)\n+        expect(onClose).toHaveBeenCalled()\n+    })\n+\n+    it('calls setDate with ISO format when Apply is clicked', () => {\n+        const { container } = render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T10:00:00')}\n+                rangeDateTo={dayjs('2024-01-15T11:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        const footer = container.querySelector('[data-attr=\"lemon-calendar-range-with-time-footer\"]') as HTMLElement\n+        userEvent.click(within(footer).getByText(/apply/i))\n+        expect(setDate).toHaveBeenCalledWith('2024-01-15T10:00:00', '2024-01-15T11:00:00', false, true)\n+    })\n+\n+    it('swaps dates on Apply if start is after end', () => {\n+        const { container } = render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T14:00:00')}\n+                rangeDateTo={dayjs('2024-01-15T10:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        const footer = container.querySelector('[data-attr=\"lemon-calendar-range-with-time-footer\"]') as HTMLElement\n+        userEvent.click(within(footer).getByText(/apply/i))\n+        expect(setDate).toHaveBeenCalledWith('2024-01-15T10:00:00', '2024-01-15T14:00:00', false, true)\n+    })\n+\n+    it('preserves PM time when initialized with PM', () => {\n+        const { container } = render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T14:30:00')}\n+                rangeDateTo={dayjs('2024-01-15T16:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        const footer = container.querySelector('[data-attr=\"lemon-calendar-range-with-time-footer\"]') as HTMLElement\n+        userEvent.click(within(footer).getByText(/apply/i))\n+        expect(setDate).toHaveBeenCalledWith('2024-01-15T14:30:00', '2024-01-15T16:00:00', false, true)\n+    })\n+\n+    it('adjusts end time when start hour is changed to be after end', () => {\n+        const { container } = render(\n+            <FixedRangeWithTimePicker\n+                rangeDateFrom={dayjs('2024-01-15T10:00:00')}\n+                rangeDateTo={dayjs('2024-01-15T11:00:00')}\n+                setDate={setDate}\n+                onClose={onClose}\n+            />\n+        )\n+\n+        // Click on hour 12 (PM) - this should be after the end time of 11:00 AM\n+        const hourButton = container.querySelector('[data-attr=\"12-h\"]') as HTMLElement\n+        expect(hourButton).toBeTruthy()\n+        userEvent.click(hourButton)\n+\n+        // Click PM to make it 12 PM (noon)\n+        const pmButton = container.querySelector('[data-attr=\"pm-a\"]') as HTMLElement\n+        expect(pmButton).toBeTruthy()\n+        userEvent.click(pmButton)\n+\n+        // Apply and verify end was adjusted (start 12:00 PM, end should be 1:00 PM)\n+        const footer = container.querySelector('[data-attr=\"lemon-calendar-range-with-time-footer\"]') as HTMLElement\n+        userEvent.click(within(footer).getByText(/apply/i))\n+\n+        // The handleApply swaps if needed, so result should be valid\n+        expect(setDate).toHaveBeenCalled()\n+        const [from, to] = setDate.mock.calls[0]\n+        expect(dayjs(from).isBefore(dayjs(to))).toBe(true)\n+    })\n+})\ndiff --git a/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.tsx b/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.tsx\nnew file mode 100644\nindex 0000000000000..bb8af28af6517\n--- /dev/null\n+++ b/frontend/src/lib/components/DateFilter/FixedRangeWithTimePicker.tsx\n@@ -0,0 +1,147 @@\n+import { useState } from 'react'\n+\n+import { IconX } from '@posthog/icons'\n+import { LemonButton } from '@posthog/lemon-ui'\n+\n+import { dayjs } from 'lib/dayjs'\n+import { LemonCalendar } from 'lib/lemon-ui/LemonCalendar/LemonCalendar'\n+\n+export interface FixedRangeWithTimePickerProps {\n+    rangeDateFrom: dayjs.Dayjs | null\n+    rangeDateTo: dayjs.Dayjs | null\n+    setDate: (dateFrom: string | null, dateTo: string | null, keepPopoverOpen: boolean, explicitDate: boolean) => void\n+    onClose: () => void\n+}\n+\n+export function FixedRangeWithTimePicker({\n+    rangeDateFrom,\n+    rangeDateTo,\n+    setDate,\n+    onClose,\n+}: FixedRangeWithTimePickerProps): JSX.Element {\n+    const [selectingStart, setSelectingStart] = useState(true)\n+    const [localFrom, setLocalFrom] = useState<dayjs.Dayjs | null>(rangeDateFrom)\n+    const [localTo, setLocalTo] = useState<dayjs.Dayjs | null>(rangeDateTo)\n+\n+    const handleApply = (): void => {\n+        if (localFrom && localTo) {\n+            const [from, to] = localFrom.isBefore(localTo) ? [localFrom, localTo] : [localTo, localFrom]\n+            setDate(from.format('YYYY-MM-DDTHH:mm:ss'), to.format('YYYY-MM-DDTHH:mm:ss'), false, true)\n+        }\n+    }\n+\n+    return (\n+        <div className=\"LemonCalendarRangeWithTime\" data-attr=\"lemon-calendar-range-with-time\">\n+            <div className=\"flex justify-between border-b p-2 pb-4\">\n+                <h3 className=\"text-base mb-0\">Select a date and time range</h3>\n+                <LemonButton icon={<IconX />} size=\"small\" noPadding onClick={onClose} aria-label=\"close\" />\n+            </div>\n+            <div className=\"flex gap-2 p-2 border-b\">\n+                <LemonButton\n+                    type={selectingStart ? 'primary' : 'secondary'}\n+                    size=\"small\"\n+                    onClick={() => setSelectingStart(true)}\n+                >\n+                    Start: {localFrom ? localFrom.format('MMM D, YYYY h:mm A') : 'Not set'}\n+                </LemonButton>\n+                <LemonButton\n+                    type={!selectingStart ? 'primary' : 'secondary'}\n+                    size=\"small\"\n+                    onClick={() => setSelectingStart(false)}\n+                >\n+                    End: {localTo ? localTo.format('MMM D, YYYY h:mm A') : 'Not set'}\n+                </LemonButton>\n+            </div>\n+            <div className=\"p-2\">\n+                <LemonCalendar\n+                    onDateClick={(date) => {\n+                        if (date) {\n+                            const currentValue = selectingStart ? localFrom : localTo\n+                            const newDate = date\n+                                .hour(currentValue?.hour() ?? dayjs().hour())\n+                                .minute(currentValue?.minute() ?? dayjs().minute())\n+\n+                            if (selectingStart) {\n+                                setLocalFrom(newDate)\n+                                // Auto-set end to 1 hour later if not set or if new start is after current end\n+                                if (!localTo || newDate.isAfter(localTo)) {\n+                                    setLocalTo(newDate.add(1, 'hour'))\n+                                }\n+                            } else {\n+                                // If end date is before start, swap them\n+                                if (localFrom && newDate.isBefore(localFrom)) {\n+                                    setLocalTo(localFrom)\n+                                    setLocalFrom(newDate)\n+                                } else {\n+                                    setLocalTo(newDate)\n+                                }\n+                            }\n+                        }\n+                    }}\n+                    leftmostMonth={(selectingStart ? localFrom : localTo)?.startOf('month')}\n+                    getLemonButtonProps={({ date, props }) => {\n+                        const currentValue = selectingStart ? localFrom : localTo\n+                        if (date.isSame(currentValue, 'd')) {\n+                            return { ...props, status: 'default', type: 'primary' }\n+                        }\n+                        return props\n+                    }}\n+                    getLemonButtonTimeProps={(timeProps) => {\n+                        const currentValue = selectingStart ? localFrom : localTo\n+                        const selected = currentValue ? currentValue.format(timeProps.unit) : null\n+\n+                        return {\n+                            active: selected === String(timeProps.value),\n+                            className: 'rounded-none',\n+                            'data-attr': `${timeProps.value}-${timeProps.unit}`,\n+                            onClick: () => {\n+                                if (currentValue) {\n+                                    let newDate = currentValue\n+                                    if (timeProps.unit === 'h') {\n+                                        const isPM = currentValue.format('a') === 'pm'\n+                                        newDate = currentValue.hour(\n+                                            isPM && timeProps.value !== 12\n+                                                ? Number(timeProps.value) + 12\n+                                                : !isPM && timeProps.value === 12\n+                                                  ? 0\n+                                                  : Number(timeProps.value)\n+                                        )\n+                                    } else if (timeProps.unit === 'm') {\n+                                        newDate = currentValue.minute(Number(timeProps.value))\n+                                    } else if (timeProps.unit === 'a') {\n+                                        const currentHour = currentValue.hour()\n+                                        if (timeProps.value === 'am' && currentHour >= 12) {\n+                                            newDate = currentValue.subtract(12, 'hour')\n+                                        } else if (timeProps.value === 'pm' && currentHour < 12) {\n+                                            newDate = currentValue.add(12, 'hour')\n+                                        }\n+                                    }\n+                                    if (selectingStart) {\n+                                        setLocalFrom(newDate)\n+                                        if (localTo && newDate.isAfter(localTo)) {\n+                                            setLocalTo(newDate.add(1, 'hour'))\n+                                        }\n+                                    } else {\n+                                        setLocalTo(newDate)\n+                                        if (localFrom && newDate.isBefore(localFrom)) {\n+                                            setLocalFrom(newDate.subtract(1, 'hour'))\n+                                        }\n+                                    }\n+                                }\n+                            },\n+                        }\n+                    }}\n+                    granularity=\"minute\"\n+                />\n+            </div>\n+            <div className=\"flex justify-end gap-2 border-t p-2 pt-4\" data-attr=\"lemon-calendar-range-with-time-footer\">\n+                <LemonButton type=\"secondary\" onClick={onClose}>\n+                    Cancel\n+                </LemonButton>\n+                <LemonButton type=\"primary\" disabled={!localFrom || !localTo} onClick={handleApply}>\n+                    Apply\n+                </LemonButton>\n+            </div>\n+        </div>\n+    )\n+}\ndiff --git a/frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts b/frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts\nindex 97341a08aaeaa..dd811b8985856 100644\n--- a/frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts\n+++ b/frontend/src/lib/components/DateFilter/dateFilterLogic.test.ts\n@@ -41,6 +41,11 @@ describe('dateFilterLogic', () => {\n             isVisible: true,\n             view: DateFilterView.FixedRange,\n         })\n+        logic.actions.openFixedRangeWithTime()\n+        await expectLogic(logic).toMatchValues({\n+            isVisible: true,\n+            view: DateFilterView.FixedRangeWithTime,\n+        })\n         logic.actions.openDateToNow()\n         await expectLogic(logic).toMatchValues({\n             isVisible: true,\n@@ -53,6 +58,86 @@ describe('dateFilterLogic', () => {\n         })\n     })\n \n+    it('isFixedRangeWithTime is true when both dates have time precision', async () => {\n+        props = {\n+            key: 'test-time-precision',\n+            onChange,\n+            dateFrom: '2024-01-15T10:30:00',\n+            dateTo: '2024-01-16T14:45:00',\n+            dateOptions: dateMapping,\n+            isDateFormatted: false,\n+        }\n+        const withTimePrecision = dateFilterLogic(props)\n+        withTimePrecision.mount()\n+\n+        await expectLogic(withTimePrecision).toMatchValues({\n+            isFixedRange: true,\n+            isFixedRangeWithTime: true,\n+            dateFromHasTimePrecision: true,\n+            dateToHasTimePrecision: true,\n+        })\n+    })\n+\n+    it('isFixedRangeWithTime is false when dates have no time precision', async () => {\n+        props = {\n+            key: 'test-no-time-precision',\n+            onChange,\n+            dateFrom: '2024-01-15',\n+            dateTo: '2024-01-16',\n+            dateOptions: dateMapping,\n+            isDateFormatted: false,\n+        }\n+        const withoutTimePrecision = dateFilterLogic(props)\n+        withoutTimePrecision.mount()\n+\n+        await expectLogic(withoutTimePrecision).toMatchValues({\n+            isFixedRange: true,\n+            isFixedRangeWithTime: false,\n+            dateFromHasTimePrecision: false,\n+            dateToHasTimePrecision: false,\n+        })\n+    })\n+\n+    it('isFixedRangeWithTime is true when only dateFrom has time precision', async () => {\n+        props = {\n+            key: 'test-from-time-precision',\n+            onChange,\n+            dateFrom: '2024-01-15T10:30:00',\n+            dateTo: '2024-01-16',\n+            dateOptions: dateMapping,\n+            isDateFormatted: false,\n+        }\n+        const withFromTimePrecision = dateFilterLogic(props)\n+        withFromTimePrecision.mount()\n+\n+        await expectLogic(withFromTimePrecision).toMatchValues({\n+            isFixedRange: true,\n+            isFixedRangeWithTime: true,\n+            dateFromHasTimePrecision: true,\n+            dateToHasTimePrecision: false,\n+        })\n+    })\n+\n+    it('isFixedRangeWithTime is true when only dateTo has time precision', async () => {\n+        props = {\n+            key: 'test-to-time-precision',\n+            onChange,\n+            dateFrom: '2024-01-15',\n+            dateTo: '2024-01-16T14:45:00',\n+            dateOptions: dateMapping,\n+            isDateFormatted: false,\n+        }\n+        const withToTimePrecision = dateFilterLogic(props)\n+        withToTimePrecision.mount()\n+\n+        await expectLogic(withToTimePrecision).toMatchValues({\n+            isFixedRange: true,\n+            isFixedRangeWithTime: true,\n+            dateFromHasTimePrecision: false,\n+            dateToHasTimePrecision: true,\n+        })\n+    })\n+\n     it('can set the date range', async () => {\n         props = {\n             key: 'test',\ndiff --git a/frontend/src/lib/components/DateFilter/dateFilterLogic.ts b/frontend/src/lib/components/DateFilter/dateFilterLogic.ts\nindex f42779f2cfaeb..a669ec454bf13 100644\n--- a/frontend/src/lib/components/DateFilter/dateFilterLogic.ts\n+++ b/frontend/src/lib/components/DateFilter/dateFilterLogic.ts\n@@ -28,6 +28,7 @@ export const dateFilterLogic = kea<dateFilterLogicType>([\n     actions({\n         open: true,\n         openFixedRange: true,\n+        openFixedRangeWithTime: true,\n         openDateToNow: true,\n         openFixedDate: true,\n         close: true,\n@@ -53,6 +54,7 @@ export const dateFilterLogic = kea<dateFilterLogicType>([\n             {\n                 open: () => DateFilterView.QuickList,\n                 openFixedRange: () => DateFilterView.FixedRange,\n+                openFixedRangeWithTime: () => DateFilterView.FixedRangeWithTime,\n                 openDateToNow: () => DateFilterView.DateToNow,\n                 openFixedDate: () => DateFilterView.FixedDate,\n             },\n@@ -62,6 +64,7 @@ export const dateFilterLogic = kea<dateFilterLogicType>([\n             {\n                 open: () => true,\n                 openFixedRange: () => true,\n+                openFixedRangeWithTime: () => true,\n                 openDateToNow: () => true,\n                 openFixedDate: () => true,\n                 setDate: (_, { keepPopoverOpen }) => keepPopoverOpen,\n@@ -109,6 +112,11 @@ export const dateFilterLogic = kea<dateFilterLogicType>([\n             (s) => [s.dateFrom, s.dateTo],\n             (dateFrom, dateTo) => !!(dateFrom && dateTo && dayjs(dateFrom).isValid() && dayjs(dateTo).isValid()),\n         ],\n+        isFixedRangeWithTime: [\n+            (s) => [s.isFixedRange, s.dateFromHasTimePrecision, s.dateToHasTimePrecision],\n+            (isFixedRange, dateFromHasTimePrecision, dateToHasTimePrecision) =>\n+                isFixedRange && (dateFromHasTimePrecision || dateToHasTimePrecision),\n+        ],\n         isDateToNow: [\n             (s) => [s.dateFrom, s.dateTo, (_, p) => p.isFixedDateMode],\n             (dateFrom, dateTo, isFixedDateMode) =>\ndiff --git a/frontend/src/lib/components/DateFilter/types.ts b/frontend/src/lib/components/DateFilter/types.ts\nindex 665c34713bef3..8ae0f75a8e28f 100644\n--- a/frontend/src/lib/components/DateFilter/types.ts\n+++ b/frontend/src/lib/components/DateFilter/types.ts\n@@ -6,6 +6,7 @@ export enum DateFilterView {\n     QuickList = 'QuickList',\n     DateToNow = 'DateToNow',\n     FixedRange = 'FixedRange',\n+    FixedRangeWithTime = 'FixedRangeWithTime',\n     FixedDate = 'FixedDate',\n }\n \n@@ -19,6 +20,7 @@ export type DateFilterLogicProps = {\n     isFixedDateMode?: boolean\n     placeholder?: string\n     allowTimePrecision?: boolean\n+    allowFixedRangeWithTime?: boolean\n     explicitDate?: boolean\n }\n \ndiff --git a/products/logs/frontend/filters/DateRangeFilter.tsx b/products/logs/frontend/filters/DateRangeFilter.tsx\nindex 3967f03a6a010..fe263d35f376b 100644\n--- a/products/logs/frontend/filters/DateRangeFilter.tsx\n+++ b/products/logs/frontend/filters/DateRangeFilter.tsx\n@@ -67,6 +67,7 @@ export const DateRangeFilter = (): JSX.Element => {\n                 setDateRange({ date_from: changedDateFrom, date_to: changedDateTo })\n             }}\n             allowTimePrecision\n+            allowFixedRangeWithTime\n             allowedRollingDateOptions={['minutes', 'hours', 'days', 'weeks', 'months']}\n         />\n     )\n"}
{"instance_id": "PostHog__posthog.main.42552", "repo": "PostHog/posthog", "base_commit": "51af4a65b07d90944ac7ef8c285953710b954337", "head_commit": "16305d4983df0b64053a32d18807f1b1721cc858", "title": "feat(persons): Update geoip_country and geoip_city_name", "merged_at": "2025-12-03T10:35:39Z", "html_url": "https://github.com/PostHog/posthog/pull/42552", "test_files": ["plugin-server/src/ingestion/ingestion-e2e.test.ts", "plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts", "plugin-server/src/worker/ingestion/persons/person-update.test.ts"], "code_files": ["plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts", "plugin-server/src/worker/ingestion/persons/person-update.ts"], "total_changes": 305, "num_files": 5, "pull_number": 42552, "patch": "diff --git a/plugin-server/src/ingestion/ingestion-e2e.test.ts b/plugin-server/src/ingestion/ingestion-e2e.test.ts\nindex 0fd07003fc8d3..453bd3534c20e 100644\n--- a/plugin-server/src/ingestion/ingestion-e2e.test.ts\n+++ b/plugin-server/src/ingestion/ingestion-e2e.test.ts\n@@ -784,6 +784,84 @@ describe('Event Pipeline E2E tests', () => {\n         }\n     )\n \n+    testWithTeamIngester(\n+        'allowed geoip properties ($geoip_country_name, $geoip_city_name) trigger person updates alongside blocked geoip properties',\n+        {},\n+        async (ingester, hub, team) => {\n+            const distinctId = new UUIDT().toString()\n+            const timestamp = DateTime.now().toMillis()\n+\n+            // When $geoip_country_name or $geoip_city_name changes, all geoip properties in the batch\n+            // should be updated, even the normally-blocked ones like $geoip_latitude\n+            await ingester.handleKafkaBatch(\n+                createKafkaMessages([\n+                    // Event 1: Create person with initial geoip properties\n+                    new EventBuilder(team, distinctId)\n+                        .withEvent('$pageview')\n+                        .withProperties({\n+                            $set: {\n+                                $geoip_country_name: 'Canada',\n+                                $geoip_city_name: 'Toronto',\n+                                $geoip_latitude: 43.6532,\n+                                $geoip_longitude: -79.3832,\n+                            },\n+                        })\n+                        .withTimestamp(timestamp)\n+                        .build(),\n+                    // Event 2: Update geoip properties including allowed ones (country/city)\n+                    // Since $geoip_country_name changes, all geoip properties should be updated\n+                    new EventBuilder(team, distinctId)\n+                        .withEvent('$pageview')\n+                        .withProperties({\n+                            $set: {\n+                                $geoip_country_name: 'United States',\n+                                $geoip_city_name: 'San Francisco',\n+                                $geoip_latitude: 37.7749,\n+                                $geoip_longitude: -122.4194,\n+                            },\n+                        })\n+                        .withTimestamp(timestamp + 1)\n+                        .build(),\n+                ])\n+            )\n+\n+            await waitForExpect(async () => {\n+                const events = await fetchEvents(hub, team.id)\n+                expect(events.length).toEqual(2)\n+\n+                // Event 0 (first pageview): Should have initial geoip properties\n+                expect(events[0].person_properties).toEqual({\n+                    $creator_event_uuid: events[0].uuid,\n+                    $geoip_country_name: 'Canada',\n+                    $geoip_city_name: 'Toronto',\n+                    $geoip_latitude: 43.6532,\n+                    $geoip_longitude: -79.3832,\n+                })\n+\n+                // Event 1 (second pageview): Should have UPDATED geoip properties\n+                // Because $geoip_country_name is an allowed property, all geoip properties get updated\n+                expect(events[1].person_properties).toEqual({\n+                    $creator_event_uuid: events[0].uuid,\n+                    $geoip_country_name: 'United States',\n+                    $geoip_city_name: 'San Francisco',\n+                    $geoip_latitude: 37.7749,\n+                    $geoip_longitude: -122.4194,\n+                })\n+\n+                // Verify the final state of the person in the database reflects the updates\n+                const person = await hub.personRepository.fetchPerson(team.id, distinctId)\n+                expect(person).toBeDefined()\n+                expect(person!.properties).toEqual({\n+                    $creator_event_uuid: events[0].uuid,\n+                    $geoip_country_name: 'United States',\n+                    $geoip_city_name: 'San Francisco',\n+                    $geoip_latitude: 37.7749,\n+                    $geoip_longitude: -122.4194,\n+                })\n+            })\n+        }\n+    )\n+\n     testWithTeamIngester('can handle events with $process_person_profile=false', {}, async (ingester, hub, team) => {\n         const distinctId = new UUIDT().toString()\n         const timestamp = DateTime.now().toMillis()\ndiff --git a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts\nindex 4c50a7768ae42..c4e46a8913bff 100644\n--- a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts\n+++ b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.test.ts\n@@ -1594,15 +1594,16 @@ describe('BatchWritingPersonStore', () => {\n             expect(mockPersonPropertyKeyUpdateCounter.labels).not.toHaveBeenCalled()\n         })\n \n-        it('should skip database write when only $geoip_* properties are updated', async () => {\n+        it('should skip database write when only blocked $geoip_* properties are updated', async () => {\n             const mockRepo = createMockRepository()\n             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n             const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n \n-            // Update person with only geoip properties (existing properties being updated)\n+            // Update person with only blocked geoip properties (existing properties being updated)\n+            // Note: $geoip_country_name and $geoip_city_name are allowed, but $geoip_latitude is blocked\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n-                { ...person, properties: { $geoip_city_name: 'New York', $geoip_country_code: 'US' } },\n-                { $geoip_city_name: 'San Francisco', $geoip_country_code: 'US' },\n+                { ...person, properties: { $geoip_latitude: 40.7128, $geoip_longitude: -74.006 } },\n+                { $geoip_latitude: 37.7749, $geoip_longitude: -74.006 },\n                 [],\n                 {},\n                 'test'\n@@ -1622,7 +1623,7 @@ describe('BatchWritingPersonStore', () => {\n             )\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledTimes(1)\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$geoip_city_name',\n+                property: '$geoip_latitude',\n             })\n             // personPropertyKeyUpdateCounter should NOT be called for 'ignored' outcomes\n             expect(mockPersonPropertyKeyUpdateCounter.labels).not.toHaveBeenCalled()\n@@ -1781,7 +1782,7 @@ describe('BatchWritingPersonStore', () => {\n                 properties: {\n                     $browser: 'Firefox',\n                     $app_build: '100',\n-                    $geoip_city_name: 'New York',\n+                    $geoip_latitude: 40.7128,\n                 },\n             }\n \n@@ -1803,10 +1804,10 @@ describe('BatchWritingPersonStore', () => {\n                 'test'\n             )\n \n-            // Event 3: Update geoip\n+            // Event 3: Update blocked geoip property (latitude is blocked, city_name is allowed)\n             await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n                 personWithFiltered,\n-                { $geoip_city_name: 'Los Angeles' },\n+                { $geoip_latitude: 37.7749 },\n                 [],\n                 {},\n                 'test'\n@@ -1832,12 +1833,68 @@ describe('BatchWritingPersonStore', () => {\n                 property: '$app_build',\n             })\n             expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                property: '$geoip_city_name',\n+                property: '$geoip_latitude',\n             })\n             // personPropertyKeyUpdateCounter should NOT be called for 'ignored' outcomes\n             expect(mockPersonPropertyKeyUpdateCounter.labels).not.toHaveBeenCalled()\n         })\n \n+        it('should write to database when allowed geoip property ($geoip_country_name) is updated alongside blocked ones', async () => {\n+            const mockRepo = createMockRepository()\n+            const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\n+            const personStoreForBatch = testPersonStore.forBatch() as BatchWritingPersonsStoreForBatch\n+\n+            // Person with existing geoip properties\n+            const personWithGeoip = {\n+                ...person,\n+                properties: {\n+                    $geoip_country_name: 'Canada',\n+                    $geoip_city_name: 'Toronto',\n+                    $geoip_latitude: 43.6532,\n+                    $geoip_longitude: -79.3832,\n+                },\n+            }\n+\n+            // Update all geoip properties including allowed ones (country_name, city_name)\n+            // Since $geoip_country_name is allowed, all properties should be updated\n+            await personStoreForBatch.updatePersonWithPropertiesDiffForUpdate(\n+                personWithGeoip,\n+                {\n+                    $geoip_country_name: 'United States',\n+                    $geoip_city_name: 'San Francisco',\n+                    $geoip_latitude: 37.7749,\n+                    $geoip_longitude: -122.4194,\n+                },\n+                [],\n+                {},\n+                'test'\n+            )\n+\n+            // Flush SHOULD write to database because $geoip_country_name is allowed\n+            await personStoreForBatch.flush()\n+\n+            expect(mockRepo.updatePerson).toHaveBeenCalledTimes(1)\n+            expect(mockRepo.updatePerson).toHaveBeenCalledWith(\n+                expect.objectContaining({\n+                    properties: {\n+                        $geoip_country_name: 'United States',\n+                        $geoip_city_name: 'San Francisco',\n+                        $geoip_latitude: 37.7749,\n+                        $geoip_longitude: -122.4194,\n+                    },\n+                }),\n+                expect.anything(),\n+                'updatePersonNoAssert'\n+            )\n+\n+            // Verify metrics - should be 'changed' since allowed geoip property triggers write\n+            expect(mockPersonProfileBatchUpdateOutcomeCounter.labels).toHaveBeenCalledTimes(1)\n+            expect(mockPersonProfileBatchUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n+            expect(mockPersonProfileBatchIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n+            // personPropertyKeyUpdateCounter uses getMetricKey which returns 'geoIP' for all $geoip_* properties\n+            expect(mockPersonPropertyKeyUpdateCounter.labels).toHaveBeenCalledWith({ key: 'geoIP' })\n+        })\n+\n         it('integration: filtered properties then non-filtered property should trigger database write', async () => {\n             const mockRepo = createMockRepository()\n             const testPersonStore = new BatchWritingPersonsStore(mockRepo, db.kafkaProducer)\ndiff --git a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts\nindex b7573fbf12c31..950dcc22aee0a 100644\n--- a/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts\n+++ b/plugin-server/src/worker/ingestion/persons/batch-writing-person-store.ts\n@@ -36,8 +36,7 @@ import {\n     personWriteMethodAttemptCounter,\n     totalPersonUpdateLatencyPerBatchHistogram,\n } from './metrics'\n-import { eventToPersonProperties } from './person-property-utils'\n-import { getMetricKey } from './person-update'\n+import { getMetricKey, isFilteredPersonPropertyKey } from './person-update'\n import { PersonUpdate, fromInternalPerson, toInternalPerson } from './person-update-batch'\n import { PersonsStore } from './persons-store'\n import { FlushResult, PersonsStoreForBatch } from './persons-store-for-batch'\n@@ -207,7 +206,7 @@ export class BatchWritingPersonsStoreForBatch implements PersonsStoreForBatch, B\n                 return true\n             }\n \n-            const isFiltered = eventToPersonProperties.has(key) || key.startsWith('$geoip_')\n+            const isFiltered = isFilteredPersonPropertyKey(key)\n             if (isFiltered) {\n                 ignoredProperties.push(key)\n                 return false\ndiff --git a/plugin-server/src/worker/ingestion/persons/person-update.test.ts b/plugin-server/src/worker/ingestion/persons/person-update.test.ts\nindex 3e71704a024fa..c55c6e1cd95e3 100644\n--- a/plugin-server/src/worker/ingestion/persons/person-update.test.ts\n+++ b/plugin-server/src/worker/ingestion/persons/person-update.test.ts\n@@ -154,7 +154,49 @@ describe('person-update', () => {\n                 }\n             )\n \n-            it('should accept $geoip_* property updates at event level (filtering happens at batch level)', () => {\n+            it('should accept blocked $geoip_* property updates at event level (filtering happens at batch level)', () => {\n+                const event: PluginEvent = {\n+                    event: 'pageview',\n+                    properties: {\n+                        $set: { $geoip_latitude: 37.7749 },\n+                    },\n+                } as any\n+\n+                const personProperties = { $geoip_latitude: 40.7128 }\n+\n+                const result = computeEventPropertyUpdates(event, personProperties)\n+\n+                expect(result.hasChanges).toBe(true)\n+                expect(result.toSet).toEqual({ $geoip_latitude: 37.7749 })\n+                expect(result.shouldForceUpdate).toBe(false)\n+                // At event level, blocked geoip properties would be marked as ignored\n+                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n+                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n+                    property: '$geoip_latitude',\n+                })\n+            })\n+\n+            it('should trigger update when $geoip_country_name changes (allowed geoip property)', () => {\n+                const event: PluginEvent = {\n+                    event: 'pageview',\n+                    properties: {\n+                        $set: { $geoip_country_name: 'United States' },\n+                    },\n+                } as any\n+\n+                const personProperties = { $geoip_country_name: 'Canada' }\n+\n+                const result = computeEventPropertyUpdates(event, personProperties)\n+\n+                expect(result.hasChanges).toBe(true)\n+                expect(result.toSet).toEqual({ $geoip_country_name: 'United States' })\n+                expect(result.shouldForceUpdate).toBe(false)\n+                // $geoip_country_name is allowed so should be marked as changed\n+                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n+                expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n+            })\n+\n+            it('should trigger update when $geoip_city_name changes (allowed geoip property)', () => {\n                 const event: PluginEvent = {\n                     event: 'pageview',\n                     properties: {\n@@ -169,11 +211,43 @@ describe('person-update', () => {\n                 expect(result.hasChanges).toBe(true)\n                 expect(result.toSet).toEqual({ $geoip_city_name: 'San Francisco' })\n                 expect(result.shouldForceUpdate).toBe(false)\n-                // At event level, geoip properties would be marked as ignored\n-                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'ignored' })\n-                expect(mockPersonProfileIgnoredPropertiesCounter.labels).toHaveBeenCalledWith({\n-                    property: '$geoip_city_name',\n+                // $geoip_city_name is allowed so should be marked as changed\n+                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n+                expect(mockPersonProfileIgnoredPropertiesCounter.labels).not.toHaveBeenCalled()\n+            })\n+\n+            it('should update all geoip properties when allowed property ($geoip_country_name) changes alongside blocked ones', () => {\n+                const event: PluginEvent = {\n+                    event: 'pageview',\n+                    properties: {\n+                        $set: {\n+                            $geoip_country_name: 'United States',\n+                            $geoip_latitude: 37.7749,\n+                            $geoip_longitude: -122.4194,\n+                            $geoip_postal_code: '94102',\n+                        },\n+                    },\n+                } as any\n+\n+                const personProperties = {\n+                    $geoip_country_name: 'Canada',\n+                    $geoip_latitude: 43.6532,\n+                    $geoip_longitude: -79.3832,\n+                    $geoip_postal_code: 'M5V',\n+                }\n+\n+                const result = computeEventPropertyUpdates(event, personProperties)\n+\n+                expect(result.hasChanges).toBe(true)\n+                expect(result.toSet).toEqual({\n+                    $geoip_country_name: 'United States',\n+                    $geoip_latitude: 37.7749,\n+                    $geoip_longitude: -122.4194,\n+                    $geoip_postal_code: '94102',\n                 })\n+                expect(result.shouldForceUpdate).toBe(false)\n+                // Since $geoip_country_name is allowed, the update is marked as changed (not ignored)\n+                expect(mockPersonProfileUpdateOutcomeCounter.labels).toHaveBeenCalledWith({ outcome: 'changed' })\n             })\n \n             it('should accept eventToPersonProperties even when mixed with unchanged custom properties', () => {\ndiff --git a/plugin-server/src/worker/ingestion/persons/person-update.ts b/plugin-server/src/worker/ingestion/persons/person-update.ts\nindex 8894149a95d0b..9b40787ff1928 100644\n--- a/plugin-server/src/worker/ingestion/persons/person-update.ts\n+++ b/plugin-server/src/worker/ingestion/persons/person-update.ts\n@@ -19,6 +19,10 @@ export interface PropertyUpdates {\n const NO_PERSON_UPDATE_EVENTS = new Set(['$exception', '$$heatmap'])\n const PERSON_EVENTS = new Set(['$identify', '$create_alias', '$merge_dangerously', '$set'])\n \n+// GeoIP properties that should still trigger person updates even when other geoip properties are blocked\n+// These are commonly used for segmentation and are worth keeping up-to-date\n+const ALLOWED_GEOIP_PROPERTIES = new Set(['$geoip_country_name', '$geoip_city_name'])\n+\n // For tracking what property keys cause us to update persons\n // tracking all properties we add from the event, 'geoip' for '$geoip_*' or '$initial_geoip_*' and 'other' for anything outside of those\n export function getMetricKey(key: string): string {\n@@ -76,22 +80,32 @@ export function computeEventPropertyUpdates(\n         }\n     })\n \n+    // First pass: detect if any property would trigger an update\n+    // If so, all changed properties in this $set should be updated together\n+    let anyPropertyTriggersUpdate = false\n+    const changedProperties: Array<[string, unknown]> = []\n+\n     Object.entries(properties).forEach(([key, value]) => {\n         if (personProperties[key] !== value) {\n+            changedProperties.push([key, value])\n             const isNewProperty = typeof personProperties[key] === 'undefined'\n-            const shouldUpdate = isNewProperty || shouldUpdatePersonIfOnlyChange(event, key, updateAllProperties)\n-\n-            if (shouldUpdate) {\n-                hasChanges = true\n-                hasNonFilteredChanges = true\n-            } else {\n-                hasChanges = true\n-                ignoredProperties.push(key)\n+            if (isNewProperty || shouldUpdatePersonIfOnlyChange(event, key, updateAllProperties)) {\n+                anyPropertyTriggersUpdate = true\n             }\n-            toSet[key] = value\n         }\n     })\n \n+    // Second pass: apply changes - if any property triggers update, all do\n+    changedProperties.forEach(([key, value]) => {\n+        hasChanges = true\n+        if (anyPropertyTriggersUpdate) {\n+            hasNonFilteredChanges = true\n+        } else {\n+            ignoredProperties.push(key)\n+        }\n+        toSet[key] = value\n+    })\n+\n     unsetProperties.forEach((propertyKey) => {\n         if (propertyKey in personProperties) {\n             if (typeof propertyKey === 'string') {\n@@ -159,6 +173,27 @@ export function applyEventPropertyUpdates(\n     return [updatedPerson, updated]\n }\n \n+/**\n+ * Determines if a property key should be filtered out from triggering person updates.\n+ * These are properties that change frequently but aren't valuable enough to update the person record for.\n+ *\n+ * This is the single source of truth for property filtering logic, used by both:\n+ * - Event-level processing (computeEventPropertyUpdates)\n+ * - Batch-level processing (getPersonUpdateOutcome in batch-writing-person-store)\n+ */\n+export function isFilteredPersonPropertyKey(key: string): boolean {\n+    // These are properties we add from the event and some change often, it's useless to update person always\n+    if (eventToPersonProperties.has(key)) {\n+        return true\n+    }\n+    // same as above, coming from GeoIP plugin\n+    // but allow country and city updates as they're commonly used for segmentation\n+    if (key.startsWith('$geoip_')) {\n+        return !ALLOWED_GEOIP_PROPERTIES.has(key)\n+    }\n+    return false\n+}\n+\n // Minimize useless person updates by not overriding properties if it's not a person event and we added from the event\n // They will still show up for PoE as it's not removed from the event, we just don't update the person in PG anymore\n function shouldUpdatePersonIfOnlyChange(event: PluginEvent, key: string, updateAllProperties: boolean): boolean {\n@@ -170,13 +205,5 @@ function shouldUpdatePersonIfOnlyChange(event: PluginEvent, key: string, updateA\n         // for person events always update everything\n         return true\n     }\n-    // These are properties we add from the event and some change often, it's useless to update person always\n-    if (eventToPersonProperties.has(key)) {\n-        return false\n-    }\n-    // same as above, coming from GeoIP plugin\n-    if (key.startsWith('$geoip_')) {\n-        return false\n-    }\n-    return true\n+    return !isFilteredPersonPropertyKey(key)\n }\n"}
