{"instance_id": "calcom__cal.com.main.25597", "repo": "calcom/cal.com", "base_commit": "06055729692e4e6df0f1684d94158b75ac7c02bb", "head_commit": "80f829e1ba2470cc1849cd5dbfc54cd842346b7c", "title": "fix: workflow reminder send to all RR hosts.", "merged_at": "2025-12-04T07:21:48Z", "html_url": "https://github.com/calcom/cal.com/pull/25597", "test_files": ["packages/features/CalendarEventBuilder.test.ts", "packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts"], "code_files": ["packages/features/CalendarEventBuilder.ts"], "total_changes": 273, "num_files": 3, "pull_number": 25597, "patch": "diff --git a/packages/features/CalendarEventBuilder.test.ts b/packages/features/CalendarEventBuilder.test.ts\nindex cd12f0f26e85dc..4bede68260953e 100644\n--- a/packages/features/CalendarEventBuilder.test.ts\n+++ b/packages/features/CalendarEventBuilder.test.ts\n@@ -980,6 +980,9 @@ describe(\"CalendarEventBuilder\", () => {\n     });\n \n     it(\"should create a calendar event from booking with team\", async () => {\n+      // Note: The CalendarEventBuilder filters team members to only include hosts\n+      // whose emails appear in booking.attendees. This simulates a COLLECTIVE event\n+      // where all hosts are assigned to the booking.\n       const mockBooking = {\n         uid: \"booking-789\",\n         metadata: null,\n@@ -1001,6 +1004,14 @@ describe(\"CalendarEventBuilder\", () => {\n             locale: \"en\",\n             phoneNumber: null,\n           },\n+          {\n+            // Team member host - included in attendees for COLLECTIVE events\n+            name: \"Team Member\",\n+            email: \"member@example.com\",\n+            timeZone: \"America/Los_Angeles\",\n+            locale: \"en\",\n+            phoneNumber: null,\n+          },\n         ],\n         user: {\n           id: 3,\n@@ -1647,6 +1658,14 @@ describe(\"CalendarEventBuilder\", () => {\n             locale: \"en\",\n             phoneNumber: null,\n           },\n+          {\n+            // Team member host - included in attendees for COLLECTIVE events\n+            name: \"Team Member\",\n+            email: \"member@example.com\",\n+            timeZone: \"America/Los_Angeles\",\n+            locale: \"en\",\n+            phoneNumber: null,\n+          },\n         ],\n         user: {\n           id: 100,\n@@ -1836,12 +1855,14 @@ describe(\"CalendarEventBuilder\", () => {\n       expect(builtFromBooking.organizer.username).toBe(\"teamlead\");\n       expect(builtFromBooking.organizer.timeZone).toBe(\"America/New_York\");\n \n-      expect(builtFromBooking.attendees).toHaveLength(2);\n+      expect(builtFromBooking.attendees).toHaveLength(3);\n       expect(builtFromBooking.attendees[0].name).toBe(\"Complete User\");\n       expect(builtFromBooking.attendees[0].email).toBe(\"complete@example.com\");\n       expect(builtFromBooking.attendees[0].timeZone).toBe(\"America/New_York\");\n       expect(builtFromBooking.attendees[1].name).toBe(\"Guest User\");\n       expect(builtFromBooking.attendees[1].email).toBe(\"guest@example.com\");\n+      expect(builtFromBooking.attendees[2].name).toBe(\"Team Member\");\n+      expect(builtFromBooking.attendees[2].email).toBe(\"member@example.com\");\n \n       expect(builtFromBooking.team).toBeDefined();\n       expect(builtFromBooking.team?.id).toBe(50);\ndiff --git a/packages/features/CalendarEventBuilder.ts b/packages/features/CalendarEventBuilder.ts\nindex 9ec0e6346a25ba..492b1aed7d455a 100644\n--- a/packages/features/CalendarEventBuilder.ts\n+++ b/packages/features/CalendarEventBuilder.ts\n@@ -7,7 +7,7 @@ import { parseRecurringEvent } from \"@calcom/lib/isRecurringEvent\";\n import { getTranslation } from \"@calcom/lib/server/i18n\";\n import { getTimeFormatStringFromUserTimeFormat, type TimeFormat } from \"@calcom/lib/timeFormat\";\n import type { Attendee, BookingSeat, DestinationCalendar, Prisma, User } from \"@calcom/prisma/client\";\n-import type { SchedulingType } from \"@calcom/prisma/enums\";\n+import { SchedulingType } from \"@calcom/prisma/enums\";\n import { bookingResponses as bookingResponsesSchema } from \"@calcom/prisma/zod-utils\";\n import type { CalendarEvent, Person, CalEventResponses, AppsStatus } from \"@calcom/types/Calendar\";\n import type { VideoCallData } from \"@calcom/types/VideoApiAdapter\";\n@@ -226,12 +226,25 @@ export class CalendarEventBuilder {\n \n     // Team & calendars\n     if (eventType.team) {\n+      // We need to get the team members assigned to the booking\n+      // In the DB team members are stored in the Attendee table\n+      const bookingAttendees = booking.attendees;\n+\n+      const hostsToInclude = eventType.hosts.filter((host) =>\n+        bookingAttendees.some((attendee) => attendee.email === host.user.email)\n+      );\n+\n+      const hostsWithoutOrganizerData = hostsToInclude.filter(\n+        (host) => host.user.email !== user.email\n+      );\n+\n       const hostsWithoutOrganizer = await Promise.all(\n-        eventType.hosts.filter((h) => h.user.email !== user.email).map((h) => _buildPersonFromUser(h.user))\n+        hostsWithoutOrganizerData.map((host) => _buildPersonFromUser(host.user))\n       );\n \n       const hostCalendars = [\n-        ...eventType.hosts.map((h) => h.user.destinationCalendar).filter(Boolean),\n+        user.destinationCalendar,\n+        ...hostsWithoutOrganizerData.map((h) => h.user.destinationCalendar).filter(Boolean),\n         user.destinationCalendar,\n       ].filter(Boolean) as NonNullable<DestinationCalendar>[];\n \ndiff --git a/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts b/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts\nindex 64fd338591ab7c..b11f5d7cc1cc27 100644\n--- a/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts\n+++ b/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts\n@@ -2,9 +2,17 @@ import { describe, expect, vi, beforeEach, test } from \"vitest\";\n \n import type { BookingSeatRepository } from \"@calcom/features/bookings/repositories/BookingSeatRepository\";\n import type { WorkflowReminderRepository } from \"@calcom/features/ee/workflows/repositories/WorkflowReminderRepository\";\n-import { WorkflowActions, WorkflowTemplates, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\n+import {\n+  SchedulingType,\n+  TimeUnit,\n+  WorkflowActions,\n+  WorkflowTemplates,\n+  WorkflowTriggerEvents,\n+} from \"@calcom/prisma/enums\";\n import type { CalendarEvent } from \"@calcom/types/Calendar\";\n \n+import { EmailWorkflowService } from \"./EmailWorkflowService\";\n+\n vi.mock(\"@calcom/emails/workflow-email-service\", () => ({\n   sendCustomWorkflowEmail: vi.fn(),\n }));\n@@ -22,8 +30,6 @@ vi.mock(\"@calcom/prisma\", () => ({\n   prisma: {},\n }));\n \n-import { EmailWorkflowService } from \"./EmailWorkflowService\";\n-\n const mockWorkflowReminderRepository: Pick<WorkflowReminderRepository, \"findByIdIncludeStepAndWorkflow\"> = {\n   findByIdIncludeStepAndWorkflow: vi.fn(),\n };\n@@ -156,4 +162,223 @@ describe(\"EmailWorkflowService\", () => {\n       expect(mockBookingSeatRepository.getByUidIncludeAttendee).toHaveBeenCalledWith(\"seat-123\");\n     });\n   });\n+\n+  describe(\"generateParametersToBuildEmailWorkflowContent - EMAIL_HOST\", () => {\n+    const mockCommonScheduleFunctionParams = {\n+      triggerEvent: WorkflowTriggerEvents.BEFORE_EVENT,\n+      timeSpan: {\n+        time: 24,\n+        timeUnit: TimeUnit.HOUR,\n+      },\n+      workflowStepId: 1,\n+      template: WorkflowTemplates.REMINDER,\n+      userId: 1,\n+      teamId: null,\n+      seatReferenceUid: undefined,\n+      verifiedAt: new Date(),\n+      creditCheckFn: vi.fn().mockResolvedValue(true),\n+    };\n+\n+    const baseMockEvt: Partial<CalendarEvent> = {\n+      uid: \"booking-123\",\n+      bookerUrl: \"https://cal.com\",\n+      title: \"Test Meeting\",\n+      startTime: \"2024-12-01T10:00:00Z\",\n+      endTime: \"2024-12-01T11:00:00Z\",\n+      organizer: {\n+        name: \"Organizer Name\",\n+        email: \"organizer@example.com\",\n+        timeZone: \"UTC\",\n+        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+        language: { locale: \"en\", translate: (() => \"\") as any },\n+        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+        timeFormat: \"h:mma\" as any,\n+      },\n+      attendees: [\n+        {\n+          name: \"Attendee Name\",\n+          email: \"attendee@example.com\",\n+          timeZone: \"UTC\",\n+          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+          language: { locale: \"en\", translate: (() => \"\") as any },\n+        },\n+      ],\n+    };\n+\n+    const mockWorkflowStep = {\n+      id: 1,\n+      action: WorkflowActions.EMAIL_HOST,\n+      verifiedAt: new Date(),\n+      sendTo: null,\n+      template: WorkflowTemplates.REMINDER,\n+      reminderBody: null,\n+      emailSubject: null,\n+      sender: null,\n+      includeCalendarEvent: false,\n+      numberVerificationPending: false,\n+      numberRequired: false,\n+    };\n+\n+    test(\"should send to organizer and team members for ROUND_ROBIN scheduling type\", async () => {\n+      // Note: For ROUND_ROBIN, the CalendarEventBuilder filters team members to only include\n+      // those assigned to the booking. EmailWorkflowService sends to all team members in evt.team.members.\n+      const mockEvt: Partial<CalendarEvent> = {\n+        ...baseMockEvt,\n+        schedulingType: SchedulingType.ROUND_ROBIN,\n+        team: {\n+          id: 1,\n+          name: \"Test Team\",\n+          members: [\n+            {\n+              id: 1,\n+              name: \"Team Member 1\",\n+              email: \"team1@example.com\",\n+              timeZone: \"UTC\",\n+              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+              language: { locale: \"en\", translate: (() => \"\") as any },\n+            },\n+            {\n+              id: 2,\n+              name: \"Team Member 2\",\n+              email: \"team2@example.com\",\n+              timeZone: \"UTC\",\n+              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+              language: { locale: \"en\", translate: (() => \"\") as any },\n+            },\n+          ],\n+        },\n+      };\n+\n+      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n+        evt: mockEvt as CalendarEvent,\n+        workflowStep: mockWorkflowStep,\n+        workflow: { userId: 1 },\n+        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n+        hideBranding: false,\n+      });\n+\n+      // EmailWorkflowService sends to organizer + all team members in evt.team.members\n+      // The filtering of team members happens in CalendarEventBuilder, not here\n+      expect(result.sendTo).toContain(\"organizer@example.com\");\n+      expect(result.sendTo).toContain(\"team1@example.com\");\n+      expect(result.sendTo).toContain(\"team2@example.com\");\n+      expect(result.sendTo.length).toBe(3);\n+    });\n+\n+    test(\"should send to organizer and team members for COLLECTIVE scheduling type\", async () => {\n+      const mockEvt: Partial<CalendarEvent> = {\n+        ...baseMockEvt,\n+        schedulingType: SchedulingType.COLLECTIVE,\n+        team: {\n+          id: 1,\n+          name: \"Test Team\",\n+          members: [\n+            {\n+              id: 1,\n+              name: \"Team Member 1\",\n+              email: \"team1@example.com\",\n+              timeZone: \"UTC\",\n+              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+              language: { locale: \"en\", translate: (() => \"\") as any },\n+            },\n+            {\n+              id: 2,\n+              name: \"Team Member 2\",\n+              email: \"team2@example.com\",\n+              timeZone: \"UTC\",\n+              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+              language: { locale: \"en\", translate: (() => \"\") as any },\n+            },\n+          ],\n+        },\n+      };\n+\n+      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n+        evt: mockEvt as CalendarEvent,\n+        workflowStep: mockWorkflowStep,\n+        workflow: { userId: 1 },\n+        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n+        hideBranding: false,\n+      });\n+\n+      expect(result.sendTo).toContain(\"organizer@example.com\");\n+      expect(result.sendTo).toContain(\"team1@example.com\");\n+      expect(result.sendTo).toContain(\"team2@example.com\");\n+      expect(result.sendTo.length).toBe(3);\n+    });\n+\n+    test(\"should send to organizer only when team is undefined for COLLECTIVE\", async () => {\n+      const mockEvt: Partial<CalendarEvent> = {\n+        ...baseMockEvt,\n+        schedulingType: SchedulingType.COLLECTIVE,\n+        team: undefined,\n+      } as Partial<CalendarEvent>;\n+\n+      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n+        evt: mockEvt as CalendarEvent,\n+        workflowStep: mockWorkflowStep,\n+        workflow: { userId: 1 },\n+        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n+        hideBranding: false,\n+      });\n+\n+      expect(result.sendTo).toEqual([\"organizer@example.com\"]);\n+      expect(result.sendTo.length).toBe(1);\n+    });\n+\n+    test(\"should send to organizer only when team members array is empty for COLLECTIVE\", async () => {\n+      const mockEvt: Partial<CalendarEvent> = {\n+        ...baseMockEvt,\n+        schedulingType: SchedulingType.COLLECTIVE,\n+        team: {\n+          id: 1,\n+          name: \"Test Team\",\n+          members: [],\n+        },\n+      };\n+\n+      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n+        evt: mockEvt as CalendarEvent,\n+        workflowStep: mockWorkflowStep,\n+        workflow: { userId: 1 },\n+        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n+        hideBranding: false,\n+      });\n+\n+      expect(result.sendTo).toEqual([\"organizer@example.com\"]);\n+      expect(result.sendTo.length).toBe(1);\n+    });\n+\n+    test(\"should send to organizer only for other scheduling types (e.g., null)\", async () => {\n+      const mockEvt: Partial<CalendarEvent> = {\n+        ...baseMockEvt,\n+        schedulingType: null,\n+        team: {\n+          id: 1,\n+          name: \"Test Team\",\n+          members: [\n+            {\n+              id: 1,\n+              name: \"Team Member 1\",\n+              email: \"team1@example.com\",\n+              timeZone: \"UTC\",\n+              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+              language: { locale: \"en\", translate: (() => \"\") as any },\n+            },\n+          ],\n+        },\n+      } as Partial<CalendarEvent>;\n+\n+      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n+        evt: mockEvt as CalendarEvent,\n+        workflowStep: mockWorkflowStep,\n+        workflow: { userId: 1 },\n+        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n+        hideBranding: false,\n+      });\n+\n+      expect(result.sendTo).toEqual([\"organizer@example.com\"]);\n+      expect(result.sendTo.length).toBe(1);\n+    });\n+  });\n });\n"}
{"instance_id": "calcom__cal.com.main.25587", "repo": "calcom/cal.com", "base_commit": "1c3ced5b7040115e0ac1301e8482d49a80881d6c", "head_commit": "8aee08ccacf7fd36f648401cb49307442636d95d", "title": "fix: unable to edit member as a team owner/admin", "merged_at": "2025-12-03T18:14:35Z", "html_url": "https://github.com/calcom/cal.com/pull/25587", "test_files": ["packages/features/ee/teams/components/EditMemberSheet.test.tsx"], "code_files": ["apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx", "packages/features/ee/teams/components/EditMemberSheet.tsx", "packages/features/ee/teams/components/MemberList.tsx", "packages/features/pbac/lib/team-member-permissions.ts"], "total_changes": 484, "num_files": 5, "pull_number": 25587, "patch": "diff --git a/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx b/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx\nindex 97adac481de73b..3cf44ce444e2a9 100644\n--- a/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx\n+++ b/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx\n@@ -5,13 +5,11 @@ import { headers, cookies } from \"next/headers\";\n import { redirect } from \"next/navigation\";\n \n import { getServerSession } from \"@calcom/features/auth/lib/getServerSession\";\n-import { Resource, CustomAction } from \"@calcom/features/pbac/domain/types/permission-registry\";\n-import { getSpecificPermissions } from \"@calcom/features/pbac/lib/resource-permissions\";\n+import { getTeamMemberPermissions } from \"@calcom/features/pbac/lib/team-member-permissions\";\n import { RoleManagementFactory } from \"@calcom/features/pbac/services/role-management.factory\";\n import SettingsHeader from \"@calcom/features/settings/appDir/SettingsHeader\";\n import { PrismaAttributeRepository } from \"@calcom/lib/server/repository/PrismaAttributeRepository\";\n import { prisma } from \"@calcom/prisma\";\n-import { MembershipRole } from \"@calcom/prisma/enums\";\n import { viewerTeamsRouter } from \"@calcom/trpc/server/routers/viewer/teams/_router\";\n \n import { buildLegacyRequest } from \"@lib/buildLegacyCtx\";\n@@ -33,7 +31,7 @@ const getCachedTeamRoles = unstable_cache(\n     try {\n       const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n       return await roleManager.getTeamRoles(teamId);\n-    } catch (error) {\n+    } catch {\n       // PBAC not enabled or error occurred, return empty array\n       return [];\n     }\n@@ -49,7 +47,7 @@ const getCachedTeamAttributes = unstable_cache(\n \n     try {\n       return await attributeRepo.findAllByOrgIdWithOptions({ orgId: organizationId });\n-    } catch (error) {\n+    } catch {\n       return [];\n     }\n   },\n@@ -79,65 +77,15 @@ const Page = async ({ params }: { params: Promise<{ id: string }> }) => {\n   const organizationId = team.parentId || teamId;\n \n   // Load PBAC roles and attributes if available\n-  const [roles, attributes] = await Promise.all([\n+  const [roles, attributes, memberPermissions] = await Promise.all([\n     getCachedTeamRoles(teamId, organizationId),\n     getCachedTeamAttributes(organizationId),\n+    getTeamMemberPermissions({\n+      userId: session.user.id,\n+      team,\n+    }),\n   ]);\n \n-  const fallbackRolesCanListMembers: MembershipRole[] = [MembershipRole.ADMIN, MembershipRole.OWNER];\n-\n-  // If the team is not private we allow members to list other members\n-  if (!team.isPrivate) {\n-    fallbackRolesCanListMembers.push(MembershipRole.MEMBER);\n-  }\n-\n-  // Get specific PBAC permissions for team member actions\n-  const permissions = await getSpecificPermissions({\n-    userId: session.user.id,\n-    teamId: teamId,\n-    resource: Resource.Team,\n-    userRole: team.membership.role,\n-    actions: [\n-      CustomAction.Invite,\n-      CustomAction.ChangeMemberRole,\n-      CustomAction.Remove,\n-      CustomAction.ListMembers,\n-      CustomAction.ListMembersPrivate,\n-      CustomAction.Impersonate,\n-    ],\n-    fallbackRoles: {\n-      [CustomAction.Invite]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.ChangeMemberRole]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.Remove]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.ListMembers]: {\n-        roles: fallbackRolesCanListMembers,\n-      },\n-      [CustomAction.Impersonate]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.ListMembersPrivate]: {\n-        roles: fallbackRolesCanListMembers,\n-      },\n-    },\n-  });\n-\n-  // Map specific permissions to member actions\n-  const memberPermissions = {\n-    canListMembers: team.isPrivate\n-      ? permissions[CustomAction.ListMembersPrivate]\n-      : permissions[CustomAction.ListMembers],\n-    canInvite: permissions[CustomAction.Invite],\n-    canChangeMemberRole: permissions[CustomAction.ChangeMemberRole],\n-    canRemove: permissions[CustomAction.Remove],\n-    canImpersonate: permissions[CustomAction.Impersonate],\n-  };\n-\n   const facetedTeamValues = {\n     roles,\n     teams: [team],\ndiff --git a/packages/features/ee/teams/components/EditMemberSheet.test.tsx b/packages/features/ee/teams/components/EditMemberSheet.test.tsx\nnew file mode 100644\nindex 00000000000000..77f8e480db0fa9\n--- /dev/null\n+++ b/packages/features/ee/teams/components/EditMemberSheet.test.tsx\n@@ -0,0 +1,327 @@\n+import { render } from \"@testing-library/react\";\n+import React, { type ReactNode } from \"react\";\n+import { vi } from \"vitest\";\n+\n+import type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\n+import { MembershipRole } from \"@calcom/prisma/enums\";\n+\n+import { EditMemberSheet } from \"./EditMemberSheet\";\n+import type { State, User } from \"./MemberList\";\n+\n+// Mock dependencies\n+vi.mock(\"@calcom/lib/hooks/useLocale\", () => ({\n+  useLocale: () => ({\n+    t: (key: string) => key,\n+  }),\n+}));\n+\n+vi.mock(\"@calcom/trpc/react\", () => ({\n+  trpc: {\n+    viewer: {\n+      pbac: {\n+        getTeamRoles: {\n+          useQuery: () => ({\n+            data: undefined,\n+            isPending: false,\n+          }),\n+        },\n+      },\n+      teams: {\n+        getUserConnectedApps: {\n+          useQuery: () => ({\n+            data: {},\n+            isPending: false,\n+          }),\n+        },\n+        changeMemberRole: {\n+          useMutation: () => ({\n+            mutate: vi.fn(),\n+            mutateAsync: vi.fn(),\n+          }),\n+        },\n+        listMembers: {\n+          cancel: vi.fn(),\n+          getInfiniteData: vi.fn(),\n+          invalidate: vi.fn(),\n+        },\n+        get: {\n+          setData: vi.fn(),\n+          invalidate: vi.fn(),\n+        },\n+      },\n+    },\n+    useUtils: () => ({\n+      viewer: {\n+        teams: {\n+          listMembers: {\n+            cancel: vi.fn(),\n+            getInfiniteData: vi.fn(),\n+            invalidate: vi.fn(),\n+          },\n+          get: {\n+            setData: vi.fn(),\n+            invalidate: vi.fn(),\n+          },\n+        },\n+      },\n+    }),\n+  },\n+}));\n+\n+const mockSetEditMode = vi.fn();\n+const mockSetMutationLoading = vi.fn();\n+\n+vi.mock(\"@calcom/features/users/components/UserTable/EditSheet/store\", () => ({\n+  useEditMode: vi.fn((selector) => {\n+    const state = {\n+      editMode: false,\n+      setEditMode: mockSetEditMode,\n+      mutationLoading: false,\n+      setMutationLoading: mockSetMutationLoading,\n+    };\n+    if (typeof selector === \"function\") {\n+      return selector(state);\n+    }\n+    return state;\n+  }),\n+}));\n+\n+// Mock SheetFooterControls to verify props\n+let capturedProps: { canChangeMemberRole?: boolean; canEditAttributesForUser?: boolean }[] = [];\n+vi.mock(\"@calcom/features/users/components/UserTable/EditSheet/SheetFooterControls\", () => ({\n+  SheetFooterControls: (props: { canChangeMemberRole?: boolean; canEditAttributesForUser?: boolean }) => {\n+    capturedProps.push(props);\n+    return React.createElement(\"div\", { \"data-testid\": \"sheet-footer-controls\" }, \"SheetFooterControls\");\n+  },\n+}));\n+\n+// Mock other UI components\n+vi.mock(\"@calcom/ui/components/sheet\", () => ({\n+  Sheet: ({ children }: { children: ReactNode }) =>\n+    React.createElement(\"div\", { \"data-testid\": \"sheet\" }, children),\n+  SheetContent: ({ children }: { children: ReactNode }) =>\n+    React.createElement(\"div\", { \"data-testid\": \"sheet-content\" }, children),\n+  SheetHeader: ({ children }: { children: ReactNode }) =>\n+    React.createElement(\"div\", { \"data-testid\": \"sheet-header\" }, children),\n+  SheetBody: ({ children }: { children: ReactNode }) =>\n+    React.createElement(\"div\", { \"data-testid\": \"sheet-body\" }, children),\n+  SheetFooter: ({ children }: { children: ReactNode }) =>\n+    React.createElement(\"div\", { \"data-testid\": \"sheet-footer\" }, children),\n+}));\n+\n+vi.mock(\"@calcom/ui/components/form\", () => ({\n+  Form: ({ children }: { children: ReactNode }) => React.createElement(\"form\", null, children),\n+  ToggleGroup: () => React.createElement(\"div\", { \"data-testid\": \"toggle-group\" }, \"ToggleGroup\"),\n+  Select: () => React.createElement(\"div\", { \"data-testid\": \"select\" }, \"Select\"),\n+}));\n+\n+vi.mock(\"@calcom/ui/components/avatar\", () => ({\n+  Avatar: () => React.createElement(\"div\", { \"data-testid\": \"avatar\" }, \"Avatar\"),\n+}));\n+\n+vi.mock(\"@calcom/ui/components/skeleton\", () => ({\n+  Skeleton: ({ children }: { children: ReactNode }) => React.createElement(\"div\", null, children),\n+  Loader: () => React.createElement(\"div\", { \"data-testid\": \"loader\" }, \"Loading...\"),\n+}));\n+\n+vi.mock(\"@calcom/features/users/components/UserTable/EditSheet/DisplayInfo\", () => ({\n+  DisplayInfo: () => <div data-testid=\"display-info\">DisplayInfo</div>,\n+}));\n+\n+describe(\"EditMemberSheet\", () => {\n+  const mockDispatch = vi.fn();\n+\n+  // Create a minimal mock user that satisfies the User type\n+  const mockUser = {\n+    id: 1,\n+    name: \"Test User\",\n+    email: \"test@example.com\",\n+    username: \"testuser\",\n+    role: MembershipRole.MEMBER,\n+    accepted: true,\n+    avatarUrl: \"\",\n+    bookerUrl: \"https://cal.com\",\n+    lastActiveAt: \"2024-01-01\",\n+    customRoleId: null,\n+  } as User;\n+\n+  const mockState: State = {\n+    editSheet: {\n+      user: mockUser,\n+      showModal: true,\n+    },\n+    deleteMember: {\n+      showModal: false,\n+    },\n+    impersonateMember: {\n+      showModal: false,\n+    },\n+    teamAvailability: {\n+      showModal: false,\n+    },\n+  };\n+\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+    mockSetEditMode.mockClear();\n+    mockSetMutationLoading.mockClear();\n+    capturedProps = [];\n+  });\n+\n+  describe(\"Fix verification: canChangeMemberRole prop passing\", () => {\n+    it(\"should pass canChangeMemberRole=true to SheetFooterControls when permissions.canChangeMemberRole is true\", () => {\n+      const permissions: MemberPermissions = {\n+        canListMembers: false,\n+        canInvite: false,\n+        canChangeMemberRole: true,\n+        canRemove: false,\n+        canImpersonate: false,\n+      };\n+\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={permissions}\n+        />\n+      );\n+\n+      // Verify SheetFooterControls was called with canChangeMemberRole=true\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: true,\n+        })\n+      );\n+    });\n+\n+    it(\"should pass canChangeMemberRole=false to SheetFooterControls when permissions.canChangeMemberRole is false\", () => {\n+      const permissions: MemberPermissions = {\n+        canListMembers: false,\n+        canInvite: false,\n+        canChangeMemberRole: false,\n+        canRemove: false,\n+        canImpersonate: false,\n+      };\n+\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={permissions}\n+        />\n+      );\n+\n+      // Verify SheetFooterControls was called with canChangeMemberRole=false\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: false,\n+        })\n+      );\n+    });\n+\n+    it(\"should pass canChangeMemberRole=undefined to SheetFooterControls when permissions is undefined\", () => {\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={undefined}\n+        />\n+      );\n+\n+      // Verify SheetFooterControls was called with canChangeMemberRole=undefined\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: undefined,\n+        })\n+      );\n+    });\n+\n+    it(\"should pass canChangeMemberRole=undefined to SheetFooterControls when permissions object exists but canChangeMemberRole is undefined\", () => {\n+      const permissions: Partial<MemberPermissions> = {\n+        canListMembers: true,\n+        canInvite: false,\n+        // canChangeMemberRole is intentionally omitted\n+      };\n+\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={permissions as MemberPermissions}\n+        />\n+      );\n+\n+      // Verify SheetFooterControls was called with canChangeMemberRole=undefined\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: undefined,\n+        })\n+      );\n+    });\n+\n+    it(\"should pass canEditAttributesForUser from permissions to SheetFooterControls\", () => {\n+      const permissions: MemberPermissions = {\n+        canListMembers: false,\n+        canInvite: false,\n+        canChangeMemberRole: true,\n+        canRemove: false,\n+        canImpersonate: false,\n+        canEditAttributesForUser: true,\n+      };\n+\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={permissions}\n+        />\n+      );\n+\n+      // Verify SheetFooterControls was called with both props\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: true,\n+          canEditAttributesForUser: true,\n+        })\n+      );\n+    });\n+\n+    it(\"should correctly extract canChangeMemberRole from permissions object (verifies fix)\", () => {\n+      // This test specifically verifies the fix where permissions?.canChangeMemberRole\n+      // is now correctly passed to SheetFooterControls\n+      const permissions: MemberPermissions = {\n+        canListMembers: false,\n+        canInvite: false,\n+        canChangeMemberRole: true, // This should be passed to SheetFooterControls\n+        canRemove: false,\n+        canImpersonate: false,\n+      };\n+\n+      render(\n+        <EditMemberSheet\n+          state={mockState}\n+          dispatch={mockDispatch}\n+          currentMember={MembershipRole.OWNER}\n+          teamId={1}\n+          permissions={permissions}\n+        />\n+      );\n+\n+      expect(capturedProps).toContainEqual(\n+        expect.objectContaining({\n+          canChangeMemberRole: true,\n+        })\n+      );\n+    });\n+  });\n+});\ndiff --git a/packages/features/ee/teams/components/EditMemberSheet.tsx b/packages/features/ee/teams/components/EditMemberSheet.tsx\nindex 61bbb6693c8ded..8611d8d9f35582 100644\n--- a/packages/features/ee/teams/components/EditMemberSheet.tsx\n+++ b/packages/features/ee/teams/components/EditMemberSheet.tsx\n@@ -8,6 +8,7 @@ import { shallow } from \"zustand/shallow\";\n import { DisplayInfo } from \"@calcom/features/users/components/UserTable/EditSheet/DisplayInfo\";\n import { SheetFooterControls } from \"@calcom/features/users/components/UserTable/EditSheet/SheetFooterControls\";\n import { useEditMode } from \"@calcom/features/users/components/UserTable/EditSheet/store\";\n+import type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\n import { useLocale } from \"@calcom/lib/hooks/useLocale\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n import { trpc } from \"@calcom/trpc/react\";\n@@ -34,11 +35,13 @@ export function EditMemberSheet({\n   dispatch,\n   currentMember,\n   teamId,\n+  permissions,\n }: {\n   state: State;\n   dispatch: Dispatch<Action>;\n   currentMember: MembershipRole;\n   teamId: number;\n+  permissions?: MemberPermissions;\n }) {\n   const { t } = useLocale();\n   const { user } = state.editSheet;\n@@ -277,7 +280,10 @@ export function EditMemberSheet({\n               </div>\n             </SheetBody>\n             <SheetFooter className=\"mt-auto\">\n-              <SheetFooterControls />\n+              <SheetFooterControls\n+                canChangeMemberRole={permissions?.canChangeMemberRole}\n+                canEditAttributesForUser={permissions?.canEditAttributesForUser}\n+              />\n             </SheetFooter>\n           </Form>\n         ) : (\ndiff --git a/packages/features/ee/teams/components/MemberList.tsx b/packages/features/ee/teams/components/MemberList.tsx\nindex b2be14f2ee159c..ff1ee1627c3b9a 100644\n--- a/packages/features/ee/teams/components/MemberList.tsx\n+++ b/packages/features/ee/teams/components/MemberList.tsx\n@@ -830,6 +830,7 @@ function MemberListContent(props: Props) {\n           state={state}\n           currentMember={props.team.membership.role}\n           teamId={props.team.id}\n+          permissions={props.permissions}\n         />\n       )}\n     </>\ndiff --git a/packages/features/pbac/lib/team-member-permissions.ts b/packages/features/pbac/lib/team-member-permissions.ts\nnew file mode 100644\nindex 00000000000000..ad27cdf27669b7\n--- /dev/null\n+++ b/packages/features/pbac/lib/team-member-permissions.ts\n@@ -0,0 +1,80 @@\n+import type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\n+import { MembershipRole } from \"@calcom/prisma/enums\";\n+\n+import { Resource, CustomAction } from \"../domain/types/permission-registry\";\n+import { getSpecificPermissions } from \"./resource-permissions\";\n+\n+interface TeamWithMembership {\n+  id: number;\n+  isPrivate: boolean;\n+  membership: {\n+    role: MembershipRole;\n+    accepted: boolean;\n+  };\n+}\n+\n+interface GetTeamMemberPermissionsOptions {\n+  userId: number;\n+  team: TeamWithMembership;\n+}\n+\n+/**\n+ * Gets team member permissions using PBAC or fallback to role-based permissions.\n+ */\n+export async function getTeamMemberPermissions({\n+  userId,\n+  team,\n+}: GetTeamMemberPermissionsOptions): Promise<MemberPermissions> {\n+  // Determine fallback roles for ListMembers based on team privacy\n+  const fallbackRolesCanListMembers: MembershipRole[] = [MembershipRole.ADMIN, MembershipRole.OWNER];\n+  if (!team.isPrivate) {\n+    fallbackRolesCanListMembers.push(MembershipRole.MEMBER);\n+  }\n+\n+  // Get specific PBAC permissions for team member actions\n+  const permissions = await getSpecificPermissions({\n+    userId,\n+    teamId: team.id,\n+    resource: Resource.Team,\n+    userRole: team.membership.role,\n+    actions: [\n+      CustomAction.Invite,\n+      CustomAction.ChangeMemberRole,\n+      CustomAction.Remove,\n+      CustomAction.ListMembers,\n+      CustomAction.ListMembersPrivate,\n+      CustomAction.Impersonate,\n+    ],\n+    fallbackRoles: {\n+      [CustomAction.Invite]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.ChangeMemberRole]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.Remove]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.ListMembers]: {\n+        roles: fallbackRolesCanListMembers,\n+      },\n+      [CustomAction.Impersonate]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.ListMembersPrivate]: {\n+        roles: fallbackRolesCanListMembers,\n+      },\n+    },\n+  });\n+\n+  // Map specific permissions to member actions\n+  return {\n+    canListMembers: team.isPrivate\n+      ? permissions[CustomAction.ListMembersPrivate]\n+      : permissions[CustomAction.ListMembers],\n+    canInvite: permissions[CustomAction.Invite],\n+    canChangeMemberRole: permissions[CustomAction.ChangeMemberRole],\n+    canRemove: permissions[CustomAction.Remove],\n+    canImpersonate: permissions[CustomAction.Impersonate],\n+  };\n+}\n"}
{"instance_id": "calcom__cal.com.main.25502", "repo": "calcom/cal.com", "base_commit": "41ad0f718dcda69d502b28302571741470672e05", "head_commit": "070a3394c1a4f735733164948fdea265d9445b57", "title": "perf: Calendar Cache Improvements", "merged_at": "2025-12-02T11:11:52Z", "html_url": "https://github.com/calcom/cal.com/pull/25502", "test_files": ["packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts", "packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts"], "code_files": ["packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts", "packages/features/flags/features.repository.interface.ts", "packages/features/flags/features.repository.ts", "packages/lib/server/repository/SelectedCalendarRepository.interface.ts", "packages/lib/server/repository/SelectedCalendarRepository.ts"], "total_changes": 192, "num_files": 7, "pull_number": 25502, "patch": "diff --git a/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts b/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts\nindex 236a718392a33d..6dfc3ae7031e8d 100644\n--- a/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts\n+++ b/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts\n@@ -12,7 +12,7 @@ import type { CalendarSyncService } from \"@calcom/features/calendar-subscription\n import type { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\n import logger from \"@calcom/lib/logger\";\n import type { ISelectedCalendarRepository } from \"@calcom/lib/server/repository/SelectedCalendarRepository.interface\";\n-import { SelectedCalendar } from \"@calcom/prisma/client\";\n+import type { SelectedCalendar } from \"@calcom/prisma/client\";\n \n const log = logger.getSubLogger({ prefix: [\"CalendarSubscriptionService\"] });\n \n@@ -204,9 +204,14 @@ export class CalendarSubscriptionService {\n    * Subscribe periodically to new calendars\n    */\n   async checkForNewSubscriptions() {\n+    const teamIds = await this.deps.featuresRepository.getTeamsWithFeatureEnabled(\n+      CalendarSubscriptionService.CALENDAR_SUBSCRIPTION_CACHE_FEATURE\n+    );\n+\n     const rows = await this.deps.selectedCalendarRepository.findNextSubscriptionBatch({\n       take: 100,\n       integrations: this.deps.adapterFactory.getProviders(),\n+      teamIds,\n     });\n     log.debug(\"checkForNewSubscriptions\", { count: rows.length });\n     await Promise.allSettled(rows.map(({ id }) => this.subscribe(id)));\ndiff --git a/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts b/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts\nindex a1081a2b1aaa3c..459b870a568b71 100644\n--- a/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts\n+++ b/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts\n@@ -125,6 +125,8 @@ describe(\"CalendarSubscriptionService\", () => {\n     mockFeaturesRepository = {\n       checkIfFeatureIsEnabledGlobally: vi.fn().mockResolvedValue(true),\n       checkIfUserHasFeature: vi.fn().mockResolvedValue(true),\n+      checkIfTeamHasFeature: vi.fn().mockResolvedValue(true),\n+      getTeamsWithFeatureEnabled: vi.fn().mockResolvedValue([1, 2, 3]),\n     };\n \n     mockCalendarCacheEventService = {\n@@ -376,12 +378,94 @@ describe(\"CalendarSubscriptionService\", () => {\n \n       await service.checkForNewSubscriptions();\n \n+      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n+        \"calendar-subscription-cache\"\n+      );\n       expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n         take: 100,\n         integrations: [\"google_calendar\", \"office365_calendar\"],\n+        teamIds: [1, 2, 3],\n       });\n       expect(subscribeSpy).toHaveBeenCalledWith(mockSelectedCalendar.id);\n     });\n+\n+    test(\"should handle mixed cache scenario where some teams have cache enabled and some do not\", async () => {\n+      const calendarWithCache = { ...mockSelectedCalendar, id: \"calendar-with-cache\", userId: 1 };\n+      const calendarWithCache2 = { ...mockSelectedCalendar, id: \"calendar-with-cache-2\", userId: 2 };\n+\n+      mockFeaturesRepository.getTeamsWithFeatureEnabled.mockResolvedValue([10, 20]);\n+\n+      mockSelectedCalendarRepository.findNextSubscriptionBatch.mockResolvedValue([\n+        calendarWithCache,\n+        calendarWithCache2,\n+      ]);\n+\n+      const subscribeSpy = vi.spyOn(service, \"subscribe\").mockResolvedValue(undefined);\n+\n+      await service.checkForNewSubscriptions();\n+\n+      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n+        \"calendar-subscription-cache\"\n+      );\n+      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n+        take: 100,\n+        integrations: [\"google_calendar\", \"office365_calendar\"],\n+        teamIds: [10, 20],\n+      });\n+      expect(subscribeSpy).toHaveBeenCalledTimes(2);\n+      expect(subscribeSpy).toHaveBeenCalledWith(\"calendar-with-cache\");\n+      expect(subscribeSpy).toHaveBeenCalledWith(\"calendar-with-cache-2\");\n+    });\n+\n+    test(\"should only fetch calendars for teams with feature enabled, not entire organization hierarchy\", async () => {\n+      const teamId = 100;\n+      const parentOrgId = 1;\n+\n+      mockFeaturesRepository.getTeamsWithFeatureEnabled.mockResolvedValue([teamId]);\n+\n+      const calendarForTeamMember = { ...mockSelectedCalendar, id: \"team-member-calendar\", userId: 5 };\n+      mockSelectedCalendarRepository.findNextSubscriptionBatch.mockResolvedValue([calendarForTeamMember]);\n+\n+      const subscribeSpy = vi.spyOn(service, \"subscribe\").mockResolvedValue(undefined);\n+\n+      await service.checkForNewSubscriptions();\n+\n+      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n+        \"calendar-subscription-cache\"\n+      );\n+      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n+        take: 100,\n+        integrations: [\"google_calendar\", \"office365_calendar\"],\n+        teamIds: [teamId],\n+      });\n+      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).not.toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teamIds: expect.arrayContaining([parentOrgId]),\n+        })\n+      );\n+      expect(subscribeSpy).toHaveBeenCalledTimes(1);\n+      expect(subscribeSpy).toHaveBeenCalledWith(\"team-member-calendar\");\n+    });\n+\n+    test(\"should not process any calendars when no teams have the feature enabled\", async () => {\n+      mockFeaturesRepository.getTeamsWithFeatureEnabled.mockResolvedValue([]);\n+\n+      mockSelectedCalendarRepository.findNextSubscriptionBatch.mockResolvedValue([]);\n+\n+      const subscribeSpy = vi.spyOn(service, \"subscribe\").mockResolvedValue(undefined);\n+\n+      await service.checkForNewSubscriptions();\n+\n+      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n+        \"calendar-subscription-cache\"\n+      );\n+      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n+        take: 100,\n+        integrations: [\"google_calendar\", \"office365_calendar\"],\n+        teamIds: [],\n+      });\n+      expect(subscribeSpy).not.toHaveBeenCalled();\n+    });\n   });\n \n   describe(\"feature flag methods\", () => {\ndiff --git a/packages/features/flags/features.repository.interface.ts b/packages/features/flags/features.repository.interface.ts\nindex 60fa9a7f9d1e16..782714d4d9284d 100644\n--- a/packages/features/flags/features.repository.interface.ts\n+++ b/packages/features/flags/features.repository.interface.ts\n@@ -4,4 +4,5 @@ export interface IFeaturesRepository {\n   checkIfFeatureIsEnabledGlobally(slug: keyof AppFlags): Promise<boolean>;\n   checkIfUserHasFeature(userId: number, slug: string): Promise<boolean>;\n   checkIfTeamHasFeature(teamId: number, slug: keyof AppFlags): Promise<boolean>;\n+  getTeamsWithFeatureEnabled(slug: keyof AppFlags): Promise<number[]>;\n }\ndiff --git a/packages/features/flags/features.repository.ts b/packages/features/flags/features.repository.ts\nindex b6df40504e82c0..48e3bd010470b6 100644\n--- a/packages/features/flags/features.repository.ts\n+++ b/packages/features/flags/features.repository.ts\n@@ -351,4 +351,23 @@ export class FeaturesRepository implements IFeaturesRepository {\n       throw err;\n     }\n   }\n+\n+  async getTeamsWithFeatureEnabled(slug: keyof AppFlags): Promise<number[]> {\n+    try {\n+      // If globally disabled, treat as effectively disabled everywhere\n+      const isGloballyEnabled = await this.checkIfFeatureIsEnabledGlobally(slug);\n+      if (!isGloballyEnabled) return [];\n+\n+      const rows = await this.prismaClient.teamFeatures.findMany({\n+        where: { featureId: slug },\n+        select: { teamId: true },\n+        orderBy: { teamId: \"asc\" },\n+      });\n+\n+      return rows.map((r) => r.teamId);\n+    } catch (err) {\n+      captureException(err);\n+      throw err;\n+    }\n+  }\n }\ndiff --git a/packages/lib/server/repository/SelectedCalendarRepository.interface.ts b/packages/lib/server/repository/SelectedCalendarRepository.interface.ts\nindex 55b49b7b5ecebd..2d119385175042 100644\n--- a/packages/lib/server/repository/SelectedCalendarRepository.interface.ts\n+++ b/packages/lib/server/repository/SelectedCalendarRepository.interface.ts\n@@ -24,9 +24,11 @@ export interface ISelectedCalendarRepository {\n    */\n   findNextSubscriptionBatch({\n     take,\n+    teamIds,\n     integrations,\n   }: {\n     take: number;\n+    teamIds: number[];\n     integrations?: string[];\n   }): Promise<SelectedCalendar[]>;\n \ndiff --git a/packages/lib/server/repository/SelectedCalendarRepository.ts b/packages/lib/server/repository/SelectedCalendarRepository.ts\nindex b40cfc70a37b57..716a35e646c42b 100644\n--- a/packages/lib/server/repository/SelectedCalendarRepository.ts\n+++ b/packages/lib/server/repository/SelectedCalendarRepository.ts\n@@ -15,26 +15,24 @@ export class SelectedCalendarRepository implements ISelectedCalendarRepository {\n     return this.prismaClient.selectedCalendar.findFirst({ where: { channelId } });\n   }\n \n-  async findNextSubscriptionBatch({ take, integrations }: { take: number; integrations: string[] }) {\n+  async findNextSubscriptionBatch({\n+    take,\n+    teamIds,\n+    integrations,\n+  }: {\n+    take: number;\n+    teamIds: number[];\n+    integrations: string[];\n+  }) {\n     return this.prismaClient.selectedCalendar.findMany({\n       where: {\n         integration: { in: integrations },\n         OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: new Date() } }],\n-        // initially we will run subscription only for teams that have\n-        // the feature flags enabled and it should be removed later\n         user: {\n           teams: {\n             some: {\n-              team: {\n-                features: {\n-                  some: {\n-                    OR: [\n-                      { featureId: \"calendar-subscription-cache\" },\n-                      { featureId: \"calendar-subscription-sync\" },\n-                    ],\n-                  },\n-                },\n-              },\n+              teamId: { in: teamIds },\n+              accepted: true,\n             },\n           },\n         },\ndiff --git a/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts b/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts\nindex d649c6da1754d6..ac1b8153a7335d 100644\n--- a/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts\n+++ b/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts\n@@ -116,6 +116,7 @@ describe(\"SelectedCalendarRepository\", () => {\n \n       const result = await repository.findNextSubscriptionBatch({\n         take: 10,\n+        teamIds: [1, 2, 3],\n         integrations: [\"google_calendar\", \"office365_calendar\"],\n       });\n \n@@ -126,16 +127,8 @@ describe(\"SelectedCalendarRepository\", () => {\n           user: {\n             teams: {\n               some: {\n-                team: {\n-                  features: {\n-                    some: {\n-                      OR: [\n-                        { featureId: \"calendar-subscription-cache\" },\n-                        { featureId: \"calendar-subscription-sync\" },\n-                      ],\n-                    },\n-                  },\n-                },\n+                teamId: { in: [1, 2, 3] },\n+                accepted: true,\n               },\n             },\n           },\n@@ -152,6 +145,7 @@ describe(\"SelectedCalendarRepository\", () => {\n \n       const result = await repository.findNextSubscriptionBatch({\n         take: 5,\n+        teamIds: [10, 20],\n         integrations: [],\n       });\n \n@@ -162,16 +156,8 @@ describe(\"SelectedCalendarRepository\", () => {\n           user: {\n             teams: {\n               some: {\n-                team: {\n-                  features: {\n-                    some: {\n-                      OR: [\n-                        { featureId: \"calendar-subscription-cache\" },\n-                        { featureId: \"calendar-subscription-sync\" },\n-                      ],\n-                    },\n-                  },\n-                },\n+                teamId: { in: [10, 20] },\n+                accepted: true,\n               },\n             },\n           },\n@@ -181,6 +167,35 @@ describe(\"SelectedCalendarRepository\", () => {\n \n       expect(result).toEqual(mockCalendars);\n     });\n+\n+    test(\"should handle empty teamIds array\", async () => {\n+      const mockCalendars: SelectedCalendar[] = [];\n+      vi.mocked(mockPrismaClient.selectedCalendar.findMany).mockResolvedValue(mockCalendars);\n+\n+      const result = await repository.findNextSubscriptionBatch({\n+        take: 10,\n+        teamIds: [],\n+        integrations: [\"google_calendar\"],\n+      });\n+\n+      expect(mockPrismaClient.selectedCalendar.findMany).toHaveBeenCalledWith({\n+        where: {\n+          integration: { in: [\"google_calendar\"] },\n+          OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: expect.any(Date) } }],\n+          user: {\n+            teams: {\n+              some: {\n+                teamId: { in: [] },\n+                accepted: true,\n+              },\n+            },\n+          },\n+        },\n+        take: 10,\n+      });\n+\n+      expect(result).toEqual(mockCalendars);\n+    });\n   });\n \n   describe(\"updateSyncStatus\", () => {\n"}
{"instance_id": "calcom__cal.com.main.25499", "repo": "calcom/cal.com", "base_commit": "d00cf329e80ec9d1bb5e1a7587bfb2d31d4339b7", "head_commit": "cc7ae2e7a6d09f9338a77f5271f8ddb8dc7a906e", "title": "fix(routing-forms): correct variable encoding and URL construction in Routing Forms Event Redirect Custom URLs", "merged_at": "2025-12-04T08:59:22Z", "html_url": "https://github.com/calcom/cal.com/pull/25499", "test_files": ["apps/web/components/apps/routing-forms/TestFormDialog.test.tsx", "packages/app-store/routing-forms/__tests__/getEventTypeRedirectUrl.test.ts", "packages/app-store/routing-forms/lib/substituteVariables.test.ts"], "code_files": ["packages/app-store/routing-forms/getEventTypeRedirectUrl.ts", "packages/app-store/routing-forms/lib/substituteVariables.ts"], "total_changes": 89, "num_files": 5, "pull_number": 25499, "patch": "diff --git a/apps/web/components/apps/routing-forms/TestFormDialog.test.tsx b/apps/web/components/apps/routing-forms/TestFormDialog.test.tsx\nindex 28042573367e66..be21fbd2390510 100644\n--- a/apps/web/components/apps/routing-forms/TestFormDialog.test.tsx\n+++ b/apps/web/components/apps/routing-forms/TestFormDialog.test.tsx\n@@ -452,7 +452,8 @@ describe(\"TestFormDialog\", () => {\n       fireEvent.click(screen.getByText(\"submit\"));\n \n       // Verify the URL shows the substituted value, not the variable\n-      expect(screen.getByTestId(\"test-routing-result\")).toHaveTextContent(\"/team/sales-team/meeting\");\n+      expect(screen.getByTestId(\"test-routing-result\")).toHaveTextContent(\"/team/Sales%20Team/meeting\");\n+      expect(screen.getByTestId(\"test-routing-result\")).not.toHaveTextContent(\"/team/sales-team/meeting\");\n       expect(screen.getByTestId(\"test-routing-result\")).not.toHaveTextContent(\"{name}\");\n     });\n \ndiff --git a/packages/app-store/routing-forms/__tests__/getEventTypeRedirectUrl.test.ts b/packages/app-store/routing-forms/__tests__/getEventTypeRedirectUrl.test.ts\nindex 950d546f862c98..7d627943ac7e92 100644\n--- a/packages/app-store/routing-forms/__tests__/getEventTypeRedirectUrl.test.ts\n+++ b/packages/app-store/routing-forms/__tests__/getEventTypeRedirectUrl.test.ts\n@@ -91,4 +91,49 @@ describe(\"getAbsoluteEventTypeRedirectUrl\", () => {\n       })\n     ).toThrow(\"eventTypeRedirectUrl must have username or teamSlug\");\n   });\n+\n+  it(\"should use '&' separator when redirect URL already contains query parameters\", () => {\n+    const result = getAbsoluteEventTypeRedirectUrl({\n+      ...defaultParams,\n+      eventTypeRedirectUrl: \"user/event?existing=param\",\n+      allURLSearchParams: new URLSearchParams(\"foo=bar\"),\n+    });\n+    expect(result).toBe(\"https://user.cal.com/user/event?existing=param&foo=bar\");\n+  });\n+\n+  it(\"should merge with '&' when redirect URL already contains multiple query parameters\", () => {\n+    const result = getAbsoluteEventTypeRedirectUrl({\n+      ...defaultParams,\n+      eventTypeRedirectUrl: \"user/event?existing1=param1&existing2=param2\",\n+      allURLSearchParams: new URLSearchParams(\"foo=bar\"),\n+    });\n+    expect(result).toBe(\"https://user.cal.com/user/event?existing1=param1&existing2=param2&foo=bar\");\n+  });\n+\n+  it(\"should merge with '&' when no URL search params are present\", () => {\n+    const result = getAbsoluteEventTypeRedirectUrl({\n+      ...defaultParams,\n+      eventTypeRedirectUrl: \"user/event?existing=param\",\n+      allURLSearchParams: new URLSearchParams(),\n+    });\n+    expect(result).toBe(\"https://user.cal.com/user/event?existing=param&\");\n+  });\n+\n+  it(\"should merge when redirect URL ends with '/'\", () => {\n+    const result = getAbsoluteEventTypeRedirectUrl({\n+      ...defaultParams,\n+      eventTypeRedirectUrl: \"user/event/\",\n+      allURLSearchParams: new URLSearchParams(\"foo=bar\"),\n+    });\n+    expect(result).toBe(\"https://user.cal.com/user/event/?foo=bar\");\n+  });\n+\n+  it(\"should be able to merge when redirect URL ends with '?'\", () => {\n+    const result = getAbsoluteEventTypeRedirectUrl({\n+      ...defaultParams,\n+      eventTypeRedirectUrl: \"user/event?\",\n+      allURLSearchParams: new URLSearchParams(\"foo=bar\"),\n+    });\n+    expect(result).toBe(\"https://user.cal.com/user/event?&foo=bar\");\n+  });\n });\ndiff --git a/packages/app-store/routing-forms/getEventTypeRedirectUrl.ts b/packages/app-store/routing-forms/getEventTypeRedirectUrl.ts\nindex 5719553530a2ac..69f2f171761484 100644\n--- a/packages/app-store/routing-forms/getEventTypeRedirectUrl.ts\n+++ b/packages/app-store/routing-forms/getEventTypeRedirectUrl.ts\n@@ -86,7 +86,8 @@ export function getAbsoluteEventTypeRedirectUrl({\n   if (teamSlugInRedirectUrl && form.nonOrgTeamslug) {\n     const isEventTypeRedirectToOldTeamSlug = teamSlugInRedirectUrl === form.nonOrgTeamslug;\n     if (isEventTypeRedirectToOldTeamSlug) {\n-      return `${WEBAPP_URL}/${eventTypeRedirectUrl}?${allURLSearchParams}`;\n+      const joiner = eventTypeRedirectUrl.includes(\"?\") ? \"&\" : \"?\";\n+      return `${WEBAPP_URL}/${eventTypeRedirectUrl}${joiner}${allURLSearchParams}`;\n     }\n   }\n \n@@ -95,7 +96,8 @@ export function getAbsoluteEventTypeRedirectUrl({\n     const isEventTypeRedirectToOldUser =\n       !hasSameProfileUsername && usernameInRedirectUrl === form.nonOrgUsername;\n     if (isEventTypeRedirectToOldUser) {\n-      return `${WEBAPP_URL}/${eventTypeRedirectUrl}?${allURLSearchParams}`;\n+      const joiner = eventTypeRedirectUrl.includes(\"?\") ? \"&\" : \"?\";\n+      return `${WEBAPP_URL}/${eventTypeRedirectUrl}${joiner}${allURLSearchParams}`;\n     }\n   }\n \n@@ -106,7 +108,8 @@ export function getAbsoluteEventTypeRedirectUrl({\n     ? form.teamOrigin\n     : form.userOrigin;\n \n-  return `${origin}/${eventTypeRedirectUrl}?${allURLSearchParams}`;\n+  const joiner = eventTypeRedirectUrl.includes(\"?\") ? \"&\" : \"?\";\n+  return `${origin}/${eventTypeRedirectUrl}${joiner}${allURLSearchParams}`;\n }\n \n export function getAbsoluteEventTypeRedirectUrlWithEmbedSupport(\ndiff --git a/packages/app-store/routing-forms/lib/substituteVariables.test.ts b/packages/app-store/routing-forms/lib/substituteVariables.test.ts\nindex c4caff09bea427..b944a652228bd0 100644\n--- a/packages/app-store/routing-forms/lib/substituteVariables.test.ts\n+++ b/packages/app-store/routing-forms/lib/substituteVariables.test.ts\n@@ -60,7 +60,7 @@ describe(\"substituteVariables\", () => {\n \n     const result = substituteVariables(routeValue, response, fields);\n \n-    expect(result).toBe(\"/team/sales-team/meeting\");\n+    expect(result).toBe(\"/team/Sales%20Team/meeting\");\n     expect(result).not.toBe(\"/team/sales-123/meeting\");\n     expect(result).not.toBe(\"/team/department/meeting\");\n   });\n@@ -78,10 +78,10 @@ describe(\"substituteVariables\", () => {\n \n     const result = substituteVariables(routeValue, response, fields);\n \n-    expect(result).toBe(\"/engineering/backend-team/book\");\n+    expect(result).toBe(\"/Engineering/Backend%20Team/book\");\n   });\n \n-  it(\"should handle special characters in labels by slugifying them\", () => {\n+  it(\"should handle special characters in labels by encoding them\", () => {\n     const fields = [\n       createSelectField(\"field1\", \"department\", \"Department\", [{ id: \"hr_dept\", label: \"HR & Recruitment\" }]),\n     ];\n@@ -89,7 +89,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"hr_dept\", \"Department\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/meeting/hr-recruitment\");\n+    expect(result).toBe(\"/meeting/HR%20%26%20Recruitment\");\n   });\n \n   it(\"should handle case-insensitive variable matching\", () => {\n@@ -102,7 +102,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"support-001\", \"Department\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/team/customer-support/schedule\");\n+    expect(result).toBe(\"/team/Customer%20Support/schedule\");\n   });\n \n   it(\"should not substitute variables that don't have matching fields\", () => {\n@@ -125,7 +125,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field3\", [\"high\", \"urgent\"], \"Priority Level\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/priorities/high-urgent\");\n+    expect(result).toBe(\"/priorities/High%2CUrgent\");\n   });\n \n   it(\"should handle numeric labels\", () => {\n@@ -136,7 +136,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"room-id-123\", \"Department\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/room/room-404\");\n+    expect(result).toBe(\"/room/Room%20404\");\n   });\n \n   it(\"should not modify the URL if no variables are present\", () => {\n@@ -158,7 +158,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"marketing-789\", \"Department\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/event/marketing-pr?type=meeting&priority=high\");\n+    expect(result).toBe(\"/event/Marketing%20%26%20PR?type=meeting&priority=high\");\n   });\n \n   it(\"should substitute text field values directly\", () => {\n@@ -167,7 +167,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"John Doe\", \"Username\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/user/john-doe/profile\");\n+    expect(result).toBe(\"/user/John%20Doe/profile\");\n   });\n \n   it(\"should handle number field values\", () => {\n@@ -195,7 +195,7 @@ describe(\"substituteVariables\", () => {\n     };\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/tower-a/floor/404/engineering\");\n+    expect(result).toBe(\"/Tower%20A/floor/404/Engineering\");\n   });\n \n   it(\"should handle text fields with special characters\", () => {\n@@ -204,7 +204,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"Cal.com Platform & API\", \"Project Name\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/project/cal.com-platform-api/board\");\n+    expect(result).toBe(\"/project/Cal.com%20Platform%20%26%20API/board\");\n   });\n \n   it(\"should handle empty text field values\", () => {\n@@ -224,6 +224,6 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"Bug Report Summary\", \"Description\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/ticket/bug-report-summary\");\n+    expect(result).toBe(\"/ticket/Bug%20Report%20Summary\");\n   });\n });\ndiff --git a/packages/app-store/routing-forms/lib/substituteVariables.ts b/packages/app-store/routing-forms/lib/substituteVariables.ts\nindex 580755b851b60e..8f2857fddfe420 100644\n--- a/packages/app-store/routing-forms/lib/substituteVariables.ts\n+++ b/packages/app-store/routing-forms/lib/substituteVariables.ts\n@@ -1,5 +1,3 @@\n-import slugify from \"@calcom/lib/slugify\";\n-\n import type { FormResponse, NonRouterRoute, Field } from \"../types/types\";\n import getFieldIdentifier from \"./getFieldIdentifier\";\n import { getHumanReadableFieldResponseValue } from \"./responseData/getHumanReadableFieldResponseValue\";\n@@ -18,7 +16,7 @@ export const substituteVariables = (\n   response: FormResponse,\n   fields: Field[]\n ) => {\n-  const regex = /\\{([^\\}]+)\\}/g;\n+  const regex = /\\{([^}]+)\\}/g;\n   const variables: string[] = routeValue.match(regex)?.map((match: string) => match.slice(1, -1)) || [];\n \n   let eventTypeUrl = routeValue;\n@@ -35,8 +33,8 @@ export const substituteVariables = (\n           field,\n           value: response[key].value,\n         });\n-        // ['abc', 'def'] ----toString---> 'abc,def' ----slugify---> 'abc-def'\n-        const valueToSubstitute = slugify(humanReadableValues.toString());\n+        // ['abc', 'def'] ----toString---> 'abc,def' ----encode---> 'abc%2Cdef'\n+        const valueToSubstitute = encodeURIComponent(humanReadableValues.toString());\n         eventTypeUrl = eventTypeUrl.replace(`{${variable}}`, valueToSubstitute);\n       }\n     }\n"}
{"instance_id": "calcom__cal.com.main.25435", "repo": "calcom/cal.com", "base_commit": "a23400777a4696afea85e2e07c090665248afbfa", "head_commit": "a0878dfeff04ddb9292a9fe0f4d706b3aaaa0593", "title": "fix: signup username collision", "merged_at": "2025-11-27T15:41:38Z", "html_url": "https://github.com/calcom/cal.com/pull/25435", "test_files": ["packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts"], "code_files": ["packages/features/auth/lib/next-auth-options.ts"], "total_changes": 28, "num_files": 2, "pull_number": 25435, "patch": "diff --git a/packages/features/auth/lib/next-auth-options.ts b/packages/features/auth/lib/next-auth-options.ts\nindex bab3b102745350..fedc3e958a3b9a 100644\n--- a/packages/features/auth/lib/next-auth-options.ts\n+++ b/packages/features/auth/lib/next-auth-options.ts\n@@ -15,8 +15,8 @@ import { LicenseKeySingleton } from \"@calcom/ee/common/server/LicenseKeyService\"\n import { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\n import createUsersAndConnectToOrg from \"@calcom/features/ee/dsync/lib/users/createUsersAndConnectToOrg\";\n import ImpersonationProvider from \"@calcom/features/ee/impersonation/lib/ImpersonationProvider\";\n-import { getOrgFullOrigin, subdomainSuffix } from \"@calcom/features/ee/organizations/lib/orgDomains\";\n import { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\n+import { getOrgFullOrigin, subdomainSuffix } from \"@calcom/features/ee/organizations/lib/orgDomains\";\n import { clientSecretVerifier, hostedCal, isSAMLLoginEnabled } from \"@calcom/features/ee/sso/lib/saml\";\n import { ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n@@ -962,7 +962,7 @@ export const getOptions = ({\n                 email: user.email,\n                 // Slugify the incoming name and append a few random characters to\n                 // prevent conflicts for users with the same name.\n-                username: getOrgUsernameFromEmail(user.name, getDomainFromEmail(user.email)),\n+                username: getOrgUsernameFromEmail(user.email, getDomainFromEmail(user.email)),\n                 emailVerified: new Date(Date.now()),\n                 name: user.name,\n                 identityProvider: idP,\ndiff --git a/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts b/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts\nindex 62aa8aed79b13b..d5d1cdb1af5088 100644\n--- a/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts\n+++ b/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts\n@@ -16,6 +16,30 @@ describe(\"getOrgUsernameFromEmail\", () => {\n     const result = getOrgUsernameFromEmail(email, autoAcceptEmailDomain);\n     expect(result).toBe(\"john.doe-example\");\n   });\n+\n+  it(\"should generate unique usernames for different emails even with same name\", () => {\n+    const email1 = \"alice@acme.com\";\n+    const email2 = \"alice+work@corp.com\";\n+\n+    const username1 = getOrgUsernameFromEmail(email1, null);\n+    const username2 = getOrgUsernameFromEmail(email2, null);\n+\n+    expect(username1).toBe(\"alice-acme\");\n+    expect(username2).toBe(\"alice-work-corp\");\n+    expect(username1).not.toBe(username2);\n+  });\n+\n+  it(\"should handle email with plus sign correctly\", () => {\n+    const email = \"bob+test@example.com\";\n+    const result = getOrgUsernameFromEmail(email, \"example.com\");\n+    expect(result).toBe(\"bob-test\");\n+  });\n+\n+  it(\"should handle null autoAcceptEmailDomain\", () => {\n+    const email = \"user@company.com\";\n+    const result = getOrgUsernameFromEmail(email, null);\n+    expect(result).toBe(\"user-company\");\n+  });\n });\n \n describe(\"deriveNameFromOrgUsername\", () => {\n"}
{"instance_id": "calcom__cal.com.main.25394", "repo": "calcom/cal.com", "base_commit": "81224f324ada684cd47a6be44388447b12dea1f2", "head_commit": "b83d9c9c63dc25d8ef8359581712fbd8636b8089", "title": "fix: Use the correct user when confirming or rejecting a booking", "merged_at": "2025-11-26T11:23:58Z", "html_url": "https://github.com/calcom/cal.com/pull/25394", "test_files": ["apps/web/test/lib/confirm.handler.test.ts"], "code_files": ["packages/trpc/server/routers/viewer/bookings/confirm.handler.ts"], "total_changes": 11, "num_files": 2, "pull_number": 25394, "patch": "diff --git a/apps/web/test/lib/confirm.handler.test.ts b/apps/web/test/lib/confirm.handler.test.ts\nindex ca85519cfb04d5..0ef053d381fc2e 100644\n--- a/apps/web/test/lib/confirm.handler.test.ts\n+++ b/apps/web/test/lib/confirm.handler.test.ts\n@@ -73,6 +73,7 @@ describe(\"confirmHandler\", () => {\n             location: \"integrations:daily\",\n             attendees: [attendeeUser],\n             responses: { name: attendeeUser.name, email: attendeeUser.email, notes: \"Sensitive information\" },\n+            user: { id: organizer.id },\n           },\n         ],\n         organizer,\ndiff --git a/packages/trpc/server/routers/viewer/bookings/confirm.handler.ts b/packages/trpc/server/routers/viewer/bookings/confirm.handler.ts\nindex 558d98d9960e99..a170e1a7306e05 100644\n--- a/packages/trpc/server/routers/viewer/bookings/confirm.handler.ts\n+++ b/packages/trpc/server/routers/viewer/bookings/confirm.handler.ts\n@@ -45,7 +45,6 @@ type ConfirmOptions = {\n };\n \n export const confirmHandler = async ({ ctx, input }: ConfirmOptions) => {\n-  const { user } = ctx;\n   const {\n     bookingId,\n     recurringEventId,\n@@ -139,12 +138,17 @@ export const confirmHandler = async ({ ctx, input }: ConfirmOptions) => {\n     },\n   });\n \n+  const user = booking.user;\n+  if (!user) {\n+    throw new TRPCError({ code: \"BAD_REQUEST\", message: \"Booking must have an organizer\" });\n+  }\n+\n   await checkIfUserIsAuthorizedToConfirmBooking({\n     eventTypeId: booking.eventTypeId,\n-    loggedInUserId: user.id,\n+    loggedInUserId: ctx.user.id,\n     teamId: booking.eventType?.teamId || booking.eventType?.parent?.teamId,\n     bookingUserId: booking.userId,\n-    userRole: user.role,\n+    userRole: ctx.user.role,\n   });\n \n   // Do not move this before authorization check.\n"}
{"instance_id": "calcom__cal.com.main.25387", "repo": "calcom/cal.com", "base_commit": "71e7f16b2958ba5a9e3e65a0bff5a7440e32e3cc", "head_commit": "a775799b6df631dc77e507ed035e7f0e1e02d2a9", "title": "fix: getTeamIdsWithPermission return sub teams", "merged_at": "2025-12-02T09:11:57Z", "html_url": "https://github.com/calcom/cal.com/pull/25387", "test_files": ["packages/features/pbac/services/__tests__/permission-check.service.test.ts"], "code_files": ["packages/features/pbac/infrastructure/repositories/PermissionRepository.ts", "packages/features/pbac/infrastructure/repositories/__tests__/PermissionRepository.integration-test.ts"], "total_changes": 772, "num_files": 3, "pull_number": 25387, "patch": "diff --git a/packages/features/pbac/infrastructure/repositories/PermissionRepository.ts b/packages/features/pbac/infrastructure/repositories/PermissionRepository.ts\nindex 90cb48eb5b19b1..2e1a6abc327535 100644\n--- a/packages/features/pbac/infrastructure/repositories/PermissionRepository.ts\n+++ b/packages/features/pbac/infrastructure/repositories/PermissionRepository.ts\n@@ -1,3 +1,4 @@\n+import logger from \"@calcom/lib/logger\";\n import db from \"@calcom/prisma\";\n import type { PrismaClient as PrismaClientWithExtensions } from \"@calcom/prisma\";\n import type { MembershipRole } from \"@calcom/prisma/enums\";\n@@ -15,6 +16,7 @@ import {\n export class PermissionRepository implements IPermissionRepository {\n   private readonly PBAC_FEATURE_FLAG = \"pbac\" as const;\n   private client: PrismaClientWithExtensions;\n+  private readonly logger = logger.getSubLogger({ prefix: [\"PermissionRepository\"] });\n \n   constructor(client: PrismaClientWithExtensions = db) {\n     this.client = client;\n@@ -237,7 +239,16 @@ export class PermissionRepository implements IPermissionRepository {\n       return { resource, action };\n     });\n \n+    const permissionPairsJson = JSON.stringify(permissionPairs);\n+\n+    // Teams with PBAC permissions (direct memberships + child teams via org membership)\n     const teamsWithPermissionPromise = this.client.$queryRaw<{ teamId: number }[]>`\n+      WITH required_permissions AS (\n+        SELECT \n+          required_perm->>'resource' as resource,\n+          required_perm->>'action' as action\n+        FROM jsonb_array_elements(${permissionPairsJson}::jsonb) AS required_perm\n+      )\n       SELECT DISTINCT m.\"teamId\"\n       FROM \"Membership\" m\n       INNER JOIN \"Role\" r ON m.\"customRoleId\" = r.id\n@@ -246,26 +257,61 @@ export class PermissionRepository implements IPermissionRepository {\n         AND m.\"customRoleId\" IS NOT NULL\n         AND (\n           SELECT COUNT(*)\n-          FROM jsonb_array_elements(${JSON.stringify(permissionPairs)}::jsonb) AS required_perm(perm)\n+          FROM required_permissions rp_req\n+          WHERE EXISTS (\n+            SELECT 1\n+            FROM \"RolePermission\" rp\n+            WHERE rp.\"roleId\" = r.id\n+              AND (\n+                (rp.\"resource\" = '*' AND rp.\"action\" = '*') OR\n+                (rp.\"resource\" = '*' AND rp.\"action\" = rp_req.action) OR\n+                (rp.\"resource\" = rp_req.resource AND rp.\"action\" = '*') OR\n+                (rp.\"resource\" = rp_req.resource AND rp.\"action\" = rp_req.action)\n+              )\n+          )\n+        ) = ${permissions.length}\n+      UNION\n+      SELECT DISTINCT child.\"id\"\n+      FROM \"Membership\" m\n+      INNER JOIN \"Role\" r ON m.\"customRoleId\" = r.id\n+      INNER JOIN \"Team\" org ON m.\"teamId\" = org.id\n+      INNER JOIN \"Team\" child ON child.\"parentId\" = org.id\n+      WHERE m.\"userId\" = ${userId}\n+        AND m.\"accepted\" = true\n+        AND m.\"customRoleId\" IS NOT NULL\n+        AND (\n+          SELECT COUNT(*)\n+          FROM required_permissions rp_req\n           WHERE EXISTS (\n             SELECT 1\n             FROM \"RolePermission\" rp\n             WHERE rp.\"roleId\" = r.id\n               AND (\n                 (rp.\"resource\" = '*' AND rp.\"action\" = '*') OR\n-                (rp.\"resource\" = '*' AND rp.\"action\" = required_perm.perm->>'action') OR\n-                (rp.\"resource\" = required_perm.perm->>'resource' AND rp.\"action\" = '*') OR\n-                (rp.\"resource\" = required_perm.perm->>'resource' AND rp.\"action\" = required_perm.perm->>'action')\n+                (rp.\"resource\" = '*' AND rp.\"action\" = rp_req.action) OR\n+                (rp.\"resource\" = rp_req.resource AND rp.\"action\" = '*') OR\n+                (rp.\"resource\" = rp_req.resource AND rp.\"action\" = rp_req.action)\n               )\n           )\n         ) = ${permissions.length}\n     `;\n \n+    // Teams with fallback roles (direct memberships + child teams via org membership, PBAC disabled)\n     const teamsWithFallbackRolesPromise = this.client.$queryRaw<{ teamId: number }[]>`\n       SELECT DISTINCT m.\"teamId\"\n       FROM \"Membership\" m\n       INNER JOIN \"Team\" t ON m.\"teamId\" = t.id\n-      LEFT JOIN \"TeamFeatures\" f ON t.id = f.\"teamId\" AND f.\"featureId\" = ${this.PBAC_FEATURE_FLAG}\n+      LEFT JOIN \"TeamFeatures\" f ON f.\"teamId\" = t.id AND f.\"featureId\" = ${this.PBAC_FEATURE_FLAG}\n+      WHERE m.\"userId\" = ${userId}\n+        AND m.\"accepted\" = true\n+        AND m.\"role\"::text = ANY(${fallbackRoles})\n+        AND f.\"teamId\" IS NULL\n+      UNION\n+      SELECT DISTINCT child.\"id\"\n+      FROM \"Membership\" m\n+      INNER JOIN \"Team\" org ON m.\"teamId\" = org.id\n+      INNER JOIN \"Team\" child ON child.\"parentId\" = org.id\n+      LEFT JOIN \"TeamFeatures\" f ON f.\"teamId\" = org.id AND f.\"featureId\" = ${this.PBAC_FEATURE_FLAG}\n       WHERE m.\"userId\" = ${userId}\n         AND m.\"accepted\" = true\n         AND m.\"role\"::text = ANY(${fallbackRoles})\ndiff --git a/packages/features/pbac/infrastructure/repositories/__tests__/PermissionRepository.integration-test.ts b/packages/features/pbac/infrastructure/repositories/__tests__/PermissionRepository.integration-test.ts\nindex 503b4dafed1ab9..3672f1a6e14e8a 100644\n--- a/packages/features/pbac/infrastructure/repositories/__tests__/PermissionRepository.integration-test.ts\n+++ b/packages/features/pbac/infrastructure/repositories/__tests__/PermissionRepository.integration-test.ts\n@@ -1,6 +1,7 @@\n-import { describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from \"vitest\";\n+import { describe, it, expect, beforeEach, afterEach, beforeAll } from \"vitest\";\n \n import { prisma } from \"@calcom/prisma\";\n+import { MembershipRole } from \"@calcom/prisma/enums\";\n \n import type { PermissionString } from \"../../../domain/types/permission-registry\";\n import { PermissionRepository } from \"../PermissionRepository\";\n@@ -55,6 +56,9 @@ describe(\"PermissionRepository - Integration Tests\", () => {\n     await prisma.role.deleteMany({\n       where: { id: testRoleId },\n     });\n+    await prisma.teamFeatures.deleteMany({\n+      where: { teamId: testTeamId },\n+    });\n     await prisma.team.deleteMany({\n       where: { id: testTeamId },\n     });\n@@ -63,7 +67,6 @@ describe(\"PermissionRepository - Integration Tests\", () => {\n     });\n   });\n \n-\n   describe(\"checkRolePermissions\", () => {\n     it(\"should successfully check single permission without serialization error\", async () => {\n       // Create a role permission\n@@ -321,4 +324,618 @@ describe(\"PermissionRepository - Integration Tests\", () => {\n       expect(result).toBe(false);\n     });\n   });\n+\n+  describe(\"getTeamIdsWithPermissions\", () => {\n+    it(\"should return empty array for empty permissions\", async () => {\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).toEqual([]);\n+    });\n+\n+    it(\"should return team IDs for PBAC-enabled team with matching permissions\", async () => {\n+      // Enable PBAC for the team\n+      await prisma.teamFeatures.create({\n+        data: {\n+          teamId: testTeamId,\n+          featureId: \"pbac\",\n+          assignedBy: \"test\",\n+        },\n+      });\n+\n+      // Create membership with custom role\n+      const membership = await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: testTeamId,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+          customRoleId: testRoleId,\n+        },\n+      });\n+\n+      // Update membership to ensure customRoleId is set (in case of trigger override)\n+      await prisma.membership.update({\n+        where: { id: membership.id },\n+        data: { customRoleId: testRoleId },\n+      });\n+\n+      // Create role permissions\n+      await prisma.rolePermission.createMany({\n+        data: [\n+          { roleId: testRoleId, resource: \"eventType\", action: \"create\" },\n+          { roleId: testRoleId, resource: \"eventType\", action: \"read\" },\n+        ],\n+      });\n+\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\", \"eventType.read\"],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).toContain(testTeamId);\n+      expect(result.length).toBe(1);\n+    });\n+\n+    it(\"should not return team IDs when permissions do not match\", async () => {\n+      // Enable PBAC for the team\n+      await prisma.teamFeatures.create({\n+        data: {\n+          teamId: testTeamId,\n+          featureId: \"pbac\",\n+          assignedBy: \"test\",\n+        },\n+      });\n+\n+      // Create membership with custom role\n+      await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: testTeamId,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+          customRoleId: testRoleId,\n+        },\n+      });\n+\n+      // Create role permissions (different from requested)\n+      await prisma.rolePermission.create({\n+        data: {\n+          roleId: testRoleId,\n+          resource: \"eventType\",\n+          action: \"create\",\n+        },\n+      });\n+\n+      // Request permissions that don't match\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.delete\"],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).not.toContain(testTeamId);\n+    });\n+\n+    it(\"should return team IDs for fallback roles when PBAC is disabled\", async () => {\n+      // Do NOT enable PBAC for the team (fallback mode)\n+\n+      // Create membership with fallback role\n+      await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: testTeamId,\n+          role: MembershipRole.ADMIN,\n+          accepted: true,\n+          customRoleId: null,\n+        },\n+      });\n+\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\"],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).toContain(testTeamId);\n+      expect(result.length).toBe(1);\n+    });\n+\n+    it(\"should not return team IDs for fallback roles that are not in the list\", async () => {\n+      // Do NOT enable PBAC for the team\n+\n+      // Create membership with MEMBER role (not in fallbackRoles)\n+      await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: testTeamId,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+          customRoleId: null,\n+        },\n+      });\n+\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\"],\n+        fallbackRoles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      });\n+\n+      expect(result).not.toContain(testTeamId);\n+    });\n+\n+    it(\"should return child team IDs when user has PBAC permissions via org\", async () => {\n+      // Create organization\n+      const org = await prisma.team.create({\n+        data: {\n+          name: `Test Org ${Date.now()}`,\n+          slug: `test-org-${Date.now()}`,\n+          isOrganization: true,\n+        },\n+      });\n+\n+      // Enable PBAC for org\n+      await prisma.teamFeatures.create({\n+        data: {\n+          teamId: org.id,\n+          featureId: \"pbac\",\n+          assignedBy: \"test\",\n+        },\n+      });\n+\n+      // Create org role\n+      const orgRole = await prisma.role.create({\n+        data: {\n+          name: `Org Role ${Date.now()}`,\n+          teamId: org.id,\n+        },\n+      });\n+\n+      // Create org membership with custom role\n+      const orgMembership = await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: org.id,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+          customRoleId: orgRole.id,\n+        },\n+      });\n+\n+      // Update membership to ensure customRoleId is set (in case of trigger override)\n+      await prisma.membership.update({\n+        where: { id: orgMembership.id },\n+        data: { customRoleId: orgRole.id },\n+      });\n+\n+      // Create org role permissions\n+      await prisma.rolePermission.createMany({\n+        data: [\n+          { roleId: orgRole.id, resource: \"eventType\", action: \"create\" },\n+          { roleId: orgRole.id, resource: \"eventType\", action: \"read\" },\n+        ],\n+      });\n+\n+      // Create child team\n+      const childTeam = await prisma.team.create({\n+        data: {\n+          name: `Child Team ${Date.now()}`,\n+          slug: `child-team-${Date.now()}`,\n+          parentId: org.id,\n+        },\n+      });\n+\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\", \"eventType.read\"],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).toContain(childTeam.id);\n+\n+      // Cleanup\n+      await prisma.rolePermission.deleteMany({ where: { roleId: orgRole.id } });\n+      await prisma.membership.deleteMany({ where: { userId: testUserId } });\n+      await prisma.role.deleteMany({ where: { id: orgRole.id } });\n+      await prisma.teamFeatures.deleteMany({ where: { teamId: org.id } });\n+      await prisma.team.deleteMany({ where: { id: { in: [org.id, childTeam.id] } } });\n+    });\n+\n+    it(\"should return child team IDs when user has fallback roles via org\", async () => {\n+      // Create organization\n+      const org = await prisma.team.create({\n+        data: {\n+          name: `Test Org ${Date.now()}`,\n+          slug: `test-org-${Date.now()}`,\n+          isOrganization: true,\n+        },\n+      });\n+\n+      // Do NOT enable PBAC for org\n+\n+      // Create org membership with fallback role\n+      await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: org.id,\n+          role: MembershipRole.OWNER,\n+          accepted: true,\n+          customRoleId: null,\n+        },\n+      });\n+\n+      // Create child team\n+      const childTeam = await prisma.team.create({\n+        data: {\n+          name: `Child Team ${Date.now()}`,\n+          slug: `child-team-${Date.now()}`,\n+          parentId: org.id,\n+        },\n+      });\n+\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\"],\n+        fallbackRoles: [MembershipRole.OWNER],\n+      });\n+\n+      expect(result).toContain(childTeam.id);\n+\n+      // Cleanup\n+      await prisma.membership.deleteMany({ where: { userId: testUserId } });\n+      await prisma.team.deleteMany({ where: { id: { in: [org.id, childTeam.id] } } });\n+    });\n+\n+    it(\"should handle wildcard permissions for PBAC teams\", async () => {\n+      // Enable PBAC for the team\n+      await prisma.teamFeatures.create({\n+        data: {\n+          teamId: testTeamId,\n+          featureId: \"pbac\",\n+          assignedBy: \"test\",\n+        },\n+      });\n+\n+      // Create membership with custom role\n+      const membership = await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: testTeamId,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+          customRoleId: testRoleId,\n+        },\n+      });\n+\n+      // Update membership to ensure customRoleId is set (in case of trigger override)\n+      await prisma.membership.update({\n+        where: { id: membership.id },\n+        data: { customRoleId: testRoleId },\n+      });\n+\n+      // Create wildcard permission\n+      await prisma.rolePermission.create({\n+        data: {\n+          roleId: testRoleId,\n+          resource: \"*\",\n+          action: \"*\",\n+        },\n+      });\n+\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\", \"team.delete\", \"role.update\"],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).toContain(testTeamId);\n+    });\n+\n+    it(\"should require all permissions to match (not just some)\", async () => {\n+      // Enable PBAC for the team\n+      await prisma.teamFeatures.create({\n+        data: {\n+          teamId: testTeamId,\n+          featureId: \"pbac\",\n+          assignedBy: \"test\",\n+        },\n+      });\n+\n+      // Create membership with custom role\n+      await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: testTeamId,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+          customRoleId: testRoleId,\n+        },\n+      });\n+\n+      // Create only 2 out of 3 required permissions\n+      await prisma.rolePermission.createMany({\n+        data: [\n+          { roleId: testRoleId, resource: \"eventType\", action: \"create\" },\n+          { roleId: testRoleId, resource: \"eventType\", action: \"read\" },\n+        ],\n+      });\n+\n+      // Request 3 permissions\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\", \"eventType.read\", \"eventType.delete\"],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).not.toContain(testTeamId);\n+    });\n+\n+    it(\"should not return teams for non-accepted memberships\", async () => {\n+      // Enable PBAC for the team\n+      await prisma.teamFeatures.create({\n+        data: {\n+          teamId: testTeamId,\n+          featureId: \"pbac\",\n+          assignedBy: \"test\",\n+        },\n+      });\n+\n+      // Create membership with accepted: false\n+      await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: testTeamId,\n+          role: MembershipRole.MEMBER,\n+          accepted: false, // Not accepted\n+          customRoleId: testRoleId,\n+        },\n+      });\n+\n+      await prisma.rolePermission.create({\n+        data: {\n+          roleId: testRoleId,\n+          resource: \"eventType\",\n+          action: \"create\",\n+        },\n+      });\n+\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\"],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).not.toContain(testTeamId);\n+    });\n+\n+    it(\"should return multiple teams when user has permissions on multiple teams\", async () => {\n+      // Create first team with its own role\n+      const team1 = await prisma.team.create({\n+        data: {\n+          name: `Test Team 1 ${Date.now()}`,\n+          slug: `test-team-1-${Date.now()}`,\n+        },\n+      });\n+\n+      const role1 = await prisma.role.create({\n+        data: {\n+          name: `Test Role 1 ${Date.now()}`,\n+          teamId: team1.id,\n+        },\n+      });\n+\n+      // Create second team with its own role\n+      const team2 = await prisma.team.create({\n+        data: {\n+          name: `Test Team 2 ${Date.now()}`,\n+          slug: `test-team-2-${Date.now()}`,\n+        },\n+      });\n+\n+      const role2 = await prisma.role.create({\n+        data: {\n+          name: `Test Role 2 ${Date.now()}`,\n+          teamId: team2.id,\n+        },\n+      });\n+\n+      // Enable PBAC for both teams\n+      await prisma.teamFeatures.createMany({\n+        data: [\n+          { teamId: team1.id, featureId: \"pbac\", assignedBy: \"test\" },\n+          { teamId: team2.id, featureId: \"pbac\", assignedBy: \"test\" },\n+        ],\n+      });\n+\n+      // Create memberships for both teams\n+      const membership1 = await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: team1.id,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+          customRoleId: role1.id,\n+        },\n+      });\n+\n+      const membership2 = await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: team2.id,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+          customRoleId: role2.id,\n+        },\n+      });\n+\n+      // Update memberships to ensure customRoleId is set (in case of trigger override)\n+      await prisma.membership.updateMany({\n+        where: {\n+          id: { in: [membership1.id, membership2.id] },\n+        },\n+        data: {\n+          customRoleId: undefined, // This will be set by the individual updates below\n+        },\n+      });\n+\n+      await prisma.membership.update({\n+        where: { id: membership1.id },\n+        data: { customRoleId: role1.id },\n+      });\n+\n+      await prisma.membership.update({\n+        where: { id: membership2.id },\n+        data: { customRoleId: role2.id },\n+      });\n+\n+      // Create permissions for both roles\n+      await prisma.rolePermission.createMany({\n+        data: [\n+          { roleId: role1.id, resource: \"eventType\", action: \"create\" },\n+          { roleId: role2.id, resource: \"eventType\", action: \"create\" },\n+        ],\n+      });\n+\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\"],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).toContain(team1.id);\n+      expect(result).toContain(team2.id);\n+      expect(result.length).toBe(2);\n+\n+      // Cleanup\n+      await prisma.rolePermission.deleteMany({ where: { roleId: { in: [role1.id, role2.id] } } });\n+      await prisma.membership.deleteMany({ where: { userId: testUserId } });\n+      await prisma.role.deleteMany({ where: { id: { in: [role1.id, role2.id] } } });\n+      await prisma.teamFeatures.deleteMany({ where: { teamId: { in: [team1.id, team2.id] } } });\n+      await prisma.team.deleteMany({ where: { id: { in: [team1.id, team2.id] } } });\n+    });\n+\n+    it(\"should combine PBAC and fallback teams in results\", async () => {\n+      // Create first team for PBAC\n+      const team1 = await prisma.team.create({\n+        data: {\n+          name: `Test Team 1 ${Date.now()}`,\n+          slug: `test-team-1-${Date.now()}`,\n+        },\n+      });\n+\n+      const role1 = await prisma.role.create({\n+        data: {\n+          name: `Test Role 1 ${Date.now()}`,\n+          teamId: team1.id,\n+        },\n+      });\n+\n+      // Create second team for fallback\n+      const team2 = await prisma.team.create({\n+        data: {\n+          name: `Test Team 2 ${Date.now()}`,\n+          slug: `test-team-2-${Date.now()}`,\n+        },\n+      });\n+\n+      // Enable PBAC for first team only\n+      await prisma.teamFeatures.create({\n+        data: {\n+          teamId: team1.id,\n+          featureId: \"pbac\",\n+          assignedBy: \"test\",\n+        },\n+      });\n+\n+      // Create PBAC membership\n+      const pbacMembership = await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: team1.id,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+          customRoleId: role1.id,\n+        },\n+      });\n+\n+      // Update membership to ensure customRoleId is set (in case of trigger override)\n+      await prisma.membership.update({\n+        where: { id: pbacMembership.id },\n+        data: { customRoleId: role1.id },\n+      });\n+\n+      await prisma.rolePermission.create({\n+        data: {\n+          roleId: role1.id,\n+          resource: \"eventType\",\n+          action: \"create\",\n+        },\n+      });\n+\n+      // Create fallback membership\n+      await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: team2.id,\n+          role: MembershipRole.ADMIN,\n+          accepted: true,\n+          customRoleId: null,\n+        },\n+      });\n+\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\"],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).toContain(team1.id);\n+      expect(result).toContain(team2.id);\n+      expect(result.length).toBe(2);\n+\n+      // Cleanup\n+      await prisma.rolePermission.deleteMany({ where: { roleId: role1.id } });\n+      await prisma.membership.deleteMany({ where: { userId: testUserId } });\n+      await prisma.role.deleteMany({ where: { id: role1.id } });\n+      await prisma.teamFeatures.deleteMany({ where: { teamId: team1.id } });\n+      await prisma.team.deleteMany({ where: { id: { in: [team1.id, team2.id] } } });\n+    });\n+\n+    it(\"should return empty array when user has no memberships\", async () => {\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\"],\n+        fallbackRoles: [MembershipRole.ADMIN],\n+      });\n+\n+      expect(result).toEqual([]);\n+    });\n+\n+    it(\"should handle multiple fallback roles\", async () => {\n+      // Do NOT enable PBAC\n+\n+      // Create membership with ADMIN role\n+      await prisma.membership.create({\n+        data: {\n+          userId: testUserId,\n+          teamId: testTeamId,\n+          role: MembershipRole.ADMIN,\n+          accepted: true,\n+          customRoleId: null,\n+        },\n+      });\n+\n+      const result = await repository.getTeamIdsWithPermissions({\n+        userId: testUserId,\n+        permissions: [\"eventType.create\"],\n+        fallbackRoles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      });\n+\n+      expect(result).toContain(testTeamId);\n+    });\n+  });\n });\ndiff --git a/packages/features/pbac/services/__tests__/permission-check.service.test.ts b/packages/features/pbac/services/__tests__/permission-check.service.test.ts\nindex b16083ce37ee6e..4989fa24c0c4dc 100644\n--- a/packages/features/pbac/services/__tests__/permission-check.service.test.ts\n+++ b/packages/features/pbac/services/__tests__/permission-check.service.test.ts\n@@ -256,8 +256,16 @@ describe(\"PermissionCheckService\", () => {\n       expect(result).toBe(true);\n       expect(mockRepository.getMembershipByUserAndTeam).toHaveBeenCalledWith(1, 1);\n       expect(mockRepository.getOrgMembership).toHaveBeenCalledWith(1, 100);\n-      expect(mockRepository.checkRolePermission).toHaveBeenNthCalledWith(1, \"team_member_role\", \"eventType.update\");\n-      expect(mockRepository.checkRolePermission).toHaveBeenNthCalledWith(2, \"org_admin_role\", \"eventType.update\");\n+      expect(mockRepository.checkRolePermission).toHaveBeenNthCalledWith(\n+        1,\n+        \"team_member_role\",\n+        \"eventType.update\"\n+      );\n+      expect(mockRepository.checkRolePermission).toHaveBeenNthCalledWith(\n+        2,\n+        \"org_admin_role\",\n+        \"eventType.update\"\n+      );\n     });\n \n     it(\"should check org-level permissions when user has no team membership but PBAC is enabled\", async () => {\n@@ -534,6 +542,47 @@ describe(\"PermissionCheckService\", () => {\n         fallbackRoles: [],\n       });\n     });\n+\n+    it(\"should include child teams where user has org-level fallback roles\", async () => {\n+      // User is ADMIN in org (teamId: 100) but MEMBER in child team (teamId: 1)\n+      // Should get access to child team via org-level ADMIN role\n+      const expectedTeamIds = [1, 100]; // Child team + org team\n+      mockRepository.getTeamIdsWithPermission.mockResolvedValueOnce(expectedTeamIds);\n+\n+      const result = await service.getTeamIdsWithPermission({\n+        userId: 1,\n+        permission: \"insights.read\",\n+        fallbackRoles: [\"ADMIN\", \"OWNER\"],\n+      });\n+\n+      expect(result).toEqual(expectedTeamIds);\n+      expect(mockRepository.getTeamIdsWithPermission).toHaveBeenCalledWith({\n+        userId: 1,\n+        permission: \"insights.read\",\n+        fallbackRoles: [\"ADMIN\", \"OWNER\"],\n+      });\n+    });\n+\n+    it(\"should include child teams where user has org-level PBAC permissions\", async () => {\n+      // User has PBAC permission via custom role in org (teamId: 100) but not in child team (teamId: 1)\n+      // When PBAC is enabled, fallback roles are NOT used - only PBAC permissions matter\n+      // Should get access to child team via org-level PBAC permission\n+      const expectedTeamIds = [1, 100]; // Child team + org team\n+      mockRepository.getTeamIdsWithPermission.mockResolvedValueOnce(expectedTeamIds);\n+\n+      const result = await service.getTeamIdsWithPermission({\n+        userId: 1,\n+        permission: \"insights.read\",\n+        fallbackRoles: [], // Empty fallback roles - PBAC permissions work independently when PBAC is enabled\n+      });\n+\n+      expect(result).toEqual(expectedTeamIds);\n+      expect(mockRepository.getTeamIdsWithPermission).toHaveBeenCalledWith({\n+        userId: 1,\n+        permission: \"insights.read\",\n+        fallbackRoles: [], // Verify PBAC permissions work without fallback roles\n+      });\n+    });\n   });\n \n   describe(\"getTeamIdsWithPermissions\", () => {\n@@ -598,6 +647,48 @@ describe(\"PermissionCheckService\", () => {\n         fallbackRoles: [],\n       });\n     });\n+\n+    it(\"should include child teams where user has org-level fallback roles\", async () => {\n+      // User is ADMIN in org (teamId: 100) but MEMBER in child team (teamId: 1)\n+      // Should get access to child team via org-level ADMIN role\n+      const permissions: PermissionString[] = [\"insights.read\", \"insights.create\"];\n+      const expectedTeamIds = [1, 2, 100]; // Child teams + org team\n+      mockRepository.getTeamIdsWithPermissions.mockResolvedValueOnce(expectedTeamIds);\n+\n+      const result = await service.getTeamIdsWithPermissions({\n+        userId: 1,\n+        permissions,\n+        fallbackRoles: [\"ADMIN\", \"OWNER\"],\n+      });\n+\n+      expect(result).toEqual(expectedTeamIds);\n+      expect(mockRepository.getTeamIdsWithPermissions).toHaveBeenCalledWith({\n+        userId: 1,\n+        permissions,\n+        fallbackRoles: [\"ADMIN\", \"OWNER\"],\n+      });\n+    });\n+\n+    it(\"should include child teams where user has org-level PBAC permissions\", async () => {\n+      // User has PBAC permissions in org (teamId: 100) but not in child team (teamId: 1)\n+      // Should get access to child team via org-level PBAC permissions\n+      const permissions: PermissionString[] = [\"insights.read\", \"insights.create\"];\n+      const expectedTeamIds = [1, 2, 100]; // Child teams + org team\n+      mockRepository.getTeamIdsWithPermissions.mockResolvedValueOnce(expectedTeamIds);\n+\n+      const result = await service.getTeamIdsWithPermissions({\n+        userId: 1,\n+        permissions,\n+        fallbackRoles: [\"ADMIN\", \"OWNER\"],\n+      });\n+\n+      expect(result).toEqual(expectedTeamIds);\n+      expect(mockRepository.getTeamIdsWithPermissions).toHaveBeenCalledWith({\n+        userId: 1,\n+        permissions,\n+        fallbackRoles: [\"ADMIN\", \"OWNER\"],\n+      });\n+    });\n   });\n \n   describe(\"getResourcePermissions\", () => {\n"}
{"instance_id": "calcom__cal.com.main.25386", "repo": "calcom/cal.com", "base_commit": "88ce7868e8100eaf9ec74cd4b508829e8e062308", "head_commit": "6c4cc0acffc171018c97aa229cd0ace9799d3271", "title": "fix: simplify date range picker to Airbnb-style selection", "merged_at": "2025-12-03T14:52:25Z", "html_url": "https://github.com/calcom/cal.com/pull/25386", "test_files": ["packages/ui/components/form/date-range-picker/dateRangeLogic.test.ts"], "code_files": ["apps/web/playwright/out-of-office.e2e.ts", "packages/ui/components/form/date-range-picker/Calendar.tsx", "packages/ui/components/form/date-range-picker/DateRangePicker.tsx", "packages/ui/components/form/date-range-picker/dateRangeLogic.ts"], "total_changes": 590, "num_files": 5, "pull_number": 25386, "patch": "diff --git a/apps/web/playwright/out-of-office.e2e.ts b/apps/web/playwright/out-of-office.e2e.ts\nindex e3b526bd9598d9..ce39645d1e5e05 100644\n--- a/apps/web/playwright/out-of-office.e2e.ts\n+++ b/apps/web/playwright/out-of-office.e2e.ts\n@@ -4,7 +4,7 @@ import { v4 as uuidv4 } from \"uuid\";\n \n import dayjs from \"@calcom/dayjs\";\n import { randomString } from \"@calcom/lib/random\";\n-import prisma from \"@calcom/prisma\";\n+import { prisma } from \"@calcom/prisma\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n \n import { addFilter } from \"./filter-helpers\";\n@@ -23,18 +23,8 @@ test.describe(\"Out of office\", () => {\n \n     await user.apiLogin();\n \n-    const entriesListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-    );\n-    await page.goto(\"/settings/my-account/out-of-office\");\n-    await page.waitForLoadState(\"domcontentloaded\");\n-    await entriesListRespPromise;\n-\n-    const reasonListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeReasonList?batch=1\") && response.status() === 200\n-    );\n-    await page.getByTestId(\"add_entry_ooo\").click();\n-    await reasonListRespPromise;\n+    await goToOOOPage(page);\n+    await openOOODialog(page);\n \n     await page.getByTestId(\"reason_select\").click();\n \n@@ -80,18 +70,8 @@ test.describe(\"Out of office\", () => {\n \n     await user.apiLogin();\n \n-    const entriesListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-    );\n-    await page.goto(\"/settings/my-account/out-of-office\");\n-    await page.waitForLoadState(\"domcontentloaded\");\n-    await entriesListRespPromise;\n-\n-    const reasonListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeReasonList?batch=1\") && response.status() === 200\n-    );\n-    await page.getByTestId(\"add_entry_ooo\").click();\n-    await reasonListRespPromise;\n+    await goToOOOPage(page);\n+    await openOOODialog(page);\n \n     await page.getByTestId(\"reason_select\").click();\n \n@@ -167,12 +147,7 @@ test.describe(\"Out of office\", () => {\n \n     await user.apiLogin();\n \n-    const entriesListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-    );\n-    await page.goto(\"/settings/my-account/out-of-office\");\n-    await page.waitForLoadState(\"domcontentloaded\");\n-    await entriesListRespPromise;\n+    await goToOOOPage(page);\n \n     // expect table-redirect-toUserId to be visible\n     await expect(page.locator(`data-testid=table-redirect-${userTo.username}`)).toBeVisible();\n@@ -231,20 +206,8 @@ test.describe(\"Out of office\", () => {\n \n     await user.apiLogin();\n \n-    const entriesListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-    );\n-    await page.goto(\"/settings/my-account/out-of-office\");\n-    await page.waitForLoadState(\"domcontentloaded\");\n-    await entriesListRespPromise;\n-\n-    const reasonListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeReasonList?batch=1\") && response.status() === 200\n-    );\n-    await page.getByTestId(\"add_entry_ooo\").click();\n-    await reasonListRespPromise;\n-\n-    await page.locator('[data-testid=\"date-range\"]').click();\n+    await goToOOOPage(page);\n+    await openOOODialog(page);\n \n     await selectToAndFromDates(page, \"13\", \"22\", true);\n \n@@ -280,20 +243,8 @@ test.describe(\"Out of office\", () => {\n \n     await user.apiLogin();\n \n-    const entriesListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-    );\n-    await page.goto(\"/settings/my-account/out-of-office\");\n-    await page.waitForLoadState(\"domcontentloaded\");\n-    await entriesListRespPromise;\n-\n-    const reasonListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeReasonList?batch=1\") && response.status() === 200\n-    );\n-    await page.getByTestId(\"add_entry_ooo\").click();\n-    await reasonListRespPromise;\n-\n-    await page.locator('[data-testid=\"date-range\"]').click();\n+    await goToOOOPage(page);\n+    await openOOODialog(page);\n \n     await selectToAndFromDates(page, \"13\", \"22\");\n \n@@ -302,11 +253,7 @@ test.describe(\"Out of office\", () => {\n     await expect(page.locator(`data-testid=table-redirect-n-a`)).toBeVisible();\n \n     // add another entry\n-    await entriesListRespPromise;\n-    await page.getByTestId(\"add_entry_ooo\").click();\n-    await reasonListRespPromise;\n-\n-    await page.locator('[data-testid=\"date-range\"]').click();\n+    await openOOODialog(page);\n \n     await selectToAndFromDates(page, \"11\", \"24\");\n \n@@ -321,20 +268,8 @@ test.describe(\"Out of office\", () => {\n \n     await user.apiLogin();\n \n-    const entriesListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-    );\n-    await page.goto(\"/settings/my-account/out-of-office\");\n-    await page.waitForLoadState(\"domcontentloaded\");\n-    await entriesListRespPromise;\n-\n-    const reasonListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeReasonList?batch=1\") && response.status() === 200\n-    );\n-    await page.getByTestId(\"add_entry_ooo\").click();\n-    await reasonListRespPromise;\n-\n-    await page.locator('[data-testid=\"date-range\"]').click();\n+    await goToOOOPage(page);\n+    await openOOODialog(page);\n \n     await selectToAndFromDates(page, \"13\", \"22\");\n \n@@ -343,11 +278,7 @@ test.describe(\"Out of office\", () => {\n     await expect(page.locator(`data-testid=table-redirect-n-a`)).toBeVisible();\n \n     // add another entry\n-    await entriesListRespPromise;\n-    await page.getByTestId(\"add_entry_ooo\").click();\n-    await reasonListRespPromise;\n-\n-    await page.locator('[data-testid=\"date-range\"]').click();\n+    await openOOODialog(page);\n \n     await selectToAndFromDates(page, \"13\", \"22\");\n \n@@ -359,32 +290,16 @@ test.describe(\"Out of office\", () => {\n     const user = await users.create({ name: \"userOne\" });\n     await user.apiLogin();\n \n-    const entriesListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-    );\n-    await page.goto(\"/settings/my-account/out-of-office\");\n-    await page.waitForLoadState(\"domcontentloaded\");\n-    await entriesListRespPromise;\n-\n-    const addOOOButton = page.getByTestId(\"add_entry_ooo\");\n-    const dateButton = page.locator('[data-testid=\"date-range\"]');\n-    const reasonListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeReasonList?batch=1\") && response.status() === 200\n-    );\n-    await addOOOButton.click();\n-    await reasonListRespPromise;\n+    await goToOOOPage(page);\n+    await openOOODialog(page);\n \n     //Creates 2 OOO entries:\n     //First OOO is created on Next month 1st - 3rd\n-    await dateButton.click();\n     await selectDateAndCreateOOO(page, \"1\", \"3\");\n     await expect(page.locator(`data-testid=table-redirect-n-a`).nth(0)).toBeVisible();\n \n     //Second OOO is created on Next month 4th - 6th\n-    await entriesListRespPromise;\n-    await addOOOButton.click();\n-    await reasonListRespPromise;\n-    await dateButton.click();\n+    await openOOODialog(page);\n     await selectDateAndCreateOOO(page, \"4\", \"6\");\n     await expect(page.locator(`data-testid=table-redirect-n-a`).nth(1)).toBeVisible();\n   });\n@@ -403,23 +318,10 @@ test.describe(\"Out of office\", () => {\n \n     await owner.apiLogin();\n \n-    const entriesListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-    );\n-    await page.goto(\"/settings/my-account/out-of-office\");\n-    await page.waitForLoadState(\"domcontentloaded\");\n-    await entriesListRespPromise;\n-\n-    const addOOOButton = page.getByTestId(\"add_entry_ooo\");\n-    const dateButton = page.locator('[data-testid=\"date-range\"]');\n-    const reasonListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeReasonList?batch=1\") && response.status() === 200\n-    );\n-    await addOOOButton.click();\n-    await reasonListRespPromise;\n+    await goToOOOPage(page);\n+    await openOOODialog(page);\n \n     //As owner,OOO is created on Next month 1st - 3rd, forwarding to 'member-1'\n-    await dateButton.click();\n     await selectDateAndCreateOOO(page, \"1\", \"3\", member1User?.id);\n     await expect(\n       page.locator(`data-testid=table-redirect-${member1User?.username ?? \"n-a\"}`).nth(0)\n@@ -427,12 +329,8 @@ test.describe(\"Out of office\", () => {\n \n     //As member1, OOO is created on Next month 4th - 5th, forwarding to 'owner'\n     await member1User?.apiLogin();\n-    await page.goto(\"/settings/my-account/out-of-office\");\n-    await page.waitForLoadState(\"domcontentloaded\");\n-    await entriesListRespPromise;\n-    await addOOOButton.click();\n-    await reasonListRespPromise;\n-    await dateButton.click();\n+    await goToOOOPage(page);\n+    await openOOODialog(page);\n     await selectDateAndCreateOOO(page, \"4\", \"5\", owner.id);\n     await expect(page.locator(`data-testid=table-redirect-${owner.username ?? \"n-a\"}`).nth(0)).toBeVisible();\n   });\n@@ -452,22 +350,10 @@ test.describe(\"Out of office\", () => {\n \n     await owner.apiLogin();\n \n-    const entriesListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-    );\n-    await page.goto(\"/settings/my-account/out-of-office\");\n-    await page.waitForLoadState(\"domcontentloaded\");\n-    await entriesListRespPromise;\n-\n-    const addOOOButton = page.getByTestId(\"add_entry_ooo\");\n-    const dateButton = page.locator('[data-testid=\"date-range\"]');\n-    const reasonListRespPromise = page.waitForResponse(\n-      (response) => response.url().includes(\"outOfOfficeReasonList?batch=1\") && response.status() === 200\n-    );\n+    await goToOOOPage(page);\n+\n     await test.step(\"As owner,OOO is created on Next month 1st - 3rd, forwarding to 'member-1'\", async () => {\n-      await addOOOButton.click();\n-      await reasonListRespPromise;\n-      await dateButton.click();\n+      await openOOODialog(page);\n       await selectDateAndCreateOOO(page, \"1\", \"3\", member1User?.id);\n       await expect(\n         page.locator(`data-testid=table-redirect-${member1User?.username ?? \"n-a\"}`).nth(0)\n@@ -476,12 +362,8 @@ test.describe(\"Out of office\", () => {\n \n     await test.step(\"As member1, expect error while OOO is created on Next month 4th - 5th, forwarding to 'owner'\", async () => {\n       await member1User?.apiLogin();\n-      await page.goto(\"/settings/my-account/out-of-office\");\n-      await page.waitForLoadState(\"domcontentloaded\");\n-      await entriesListRespPromise;\n-      await addOOOButton.click();\n-      await reasonListRespPromise;\n-      await dateButton.click();\n+      await goToOOOPage(page);\n+      await openOOODialog(page);\n       await selectDateAndCreateOOO(page, \"2\", \"5\", owner.id, 400);\n       await expect(page.locator(`text=${t(\"booking_redirect_infinite_not_allowed\")}`)).toBeTruthy();\n     });\n@@ -505,30 +387,12 @@ test.describe(\"Out of office\", () => {\n       const member3User = users.get().find((user) => user.name === \"member-3\");\n       await teamAdmin.apiLogin();\n \n-      const entriesListRespPromise = page.waitForResponse(\n-        (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-      );\n-      await page.goto(\"/settings/my-account/out-of-office?type=team\");\n-      await page.waitForLoadState(\"domcontentloaded\");\n-      await entriesListRespPromise;\n-\n-      const addOOOButton = page.getByTestId(\"add_entry_ooo\");\n-      const dateButton = page.locator('[data-testid=\"date-range\"]');\n-      const reasonListRespPromise = page.waitForResponse(\n-        (response) => response.url().includes(\"outOfOfficeReasonList?batch=1\") && response.status() === 200\n-      );\n-      const legacyListMembersRespPromise = page.waitForResponse(\n-        (response) => response.url().includes(\"legacyListMembers\") && response.status() === 200\n-      );\n-      await addOOOButton.click();\n-      await reasonListRespPromise;\n-      await legacyListMembersRespPromise;\n-      await legacyListMembersRespPromise;\n+      await goToOOOPage(page, \"team\");\n+      await openOOODialog(page);\n \n       await test.step(\"Admin can create OOO for team member and add redirect\", async () => {\n         //OOO is created for 'member-1' on Next month 1st - 3rd, forwarding to 'member-2'\n         await page.getByTestId(`ooofor_username_select_${member1User?.id}`).click();\n-        await dateButton.click();\n \n         await selectDateAndCreateOOO(page, \"1\", \"3\", member2User?.id, 200, true);\n         await expect(\n@@ -538,13 +402,9 @@ test.describe(\"Out of office\", () => {\n \n       await test.step(\"Reverse redirect not allowed for team member\", async () => {\n         //Try to create OOO for 'member-2' on Next month 1st - 3rd, forwarding to 'member-1'\n-        await page.getByTestId(\"add_entry_ooo\").click();\n-        await reasonListRespPromise;\n-        await legacyListMembersRespPromise;\n-        await legacyListMembersRespPromise;\n+        await openOOODialog(page);\n \n         await page.getByTestId(`ooofor_username_select_${member2User?.id}`).click();\n-        await dateButton.click();\n         await selectDateAndCreateOOO(page, \"1\", \"3\", member1User?.id, 400, true);\n         expect(page.locator(`text=${t(\"booking_redirect_infinite_not_allowed\")}`)).toBeTruthy();\n         await page.locator(`text=${t(\"cancel\")}`).click();\n@@ -553,9 +413,6 @@ test.describe(\"Out of office\", () => {\n       await test.step(\"Edit OOO and change redirect member\", async () => {\n         //Change redirect member to 'member-3' for OOO created in step 1\n         await page.getByTestId(`ooo-edit-${member2User?.username}`).click();\n-        await reasonListRespPromise;\n-        await legacyListMembersRespPromise;\n-        await legacyListMembersRespPromise;\n \n         await page.getByTestId(`team_username_select_${member3User?.id}`).click();\n         await saveAndWaitForResponse(page);\n@@ -620,12 +477,7 @@ test.describe(\"Out of office\", () => {\n \n       await test.step(\"member3 logins and navigates to team OOO\", async () => {\n         await member3User?.apiLogin();\n-        const entriesListRespPromise = page.waitForResponse(\n-          (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-        );\n-        await page.goto(\"/settings/my-account/out-of-office?type=team\");\n-        await page.waitForLoadState(\"domcontentloaded\");\n-        await entriesListRespPromise;\n+        await goToOOOPage(page, \"team\");\n \n         //Non-Admin canNot create OOO for team members\n         await expect(page.locator('[data-testid=\"add_entry_ooo\"]')).toBeDisabled();\n@@ -653,12 +505,7 @@ test.describe(\"Out of office\", () => {\n     test(\"Default date range filter set to `Last 7 Days`\", async ({ page, users }) => {\n       const user = await users.create({ name: `userOne=${Date.now()}` });\n       await user.apiLogin();\n-      const responsePromise = page.waitForResponse(\n-        (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-      );\n-      await page.goto(\"/settings/my-account/out-of-office\");\n-      await page.waitForLoadState(\"domcontentloaded\");\n-      await responsePromise;\n+      await goToOOOPage(page);\n       await addFilter(page, \"dateRange\");\n       await expect(\n         page.locator('[data-testid=\"filter-popover-trigger-dateRange\"]', { hasText: \"Last 7 Days\" }).first()\n@@ -668,12 +515,7 @@ test.describe(\"Out of office\", () => {\n     test(\"Can choose date range presets\", async ({ page, users }) => {\n       const user = await users.create({ name: `userOne=${Date.now()}` });\n       await user.apiLogin();\n-      const responsePromise = page.waitForResponse(\n-        (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-      );\n-      await page.goto(\"/settings/my-account/out-of-office\");\n-      await page.waitForLoadState(\"domcontentloaded\");\n-      await responsePromise;\n+      await goToOOOPage(page);\n       await addFilter(page, \"dateRange\");\n \n       await expect(page.locator('[data-testid=\"date-range-options-tdy\"]')).toBeVisible(); //Today\n@@ -697,8 +539,6 @@ test.describe(\"Out of office\", () => {\n           teammates: teamMatesObj,\n         }\n       );\n-      const member1User = users.get().find((user) => user.name === member1Name);\n-      const member2User = users.get().find((user) => user.name === member2Name);\n \n       //create OOO for member3, start:currentDate+2Days, end:currentDate+4days (future ooo)\n       await prisma.outOfOfficeEntry.create({\n@@ -717,12 +557,7 @@ test.describe(\"Out of office\", () => {\n       });\n \n       await member3User?.apiLogin();\n-      const entriesListRespPromise = page.waitForResponse(\n-        (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-      );\n-      await page.goto(\"/settings/my-account/out-of-office\");\n-      await entriesListRespPromise;\n-      await page.waitForLoadState(\"domcontentloaded\");\n+      await goToOOOPage(page);\n \n       //By Default future OOO will be displayed\n       //1 OOO record should be visible for member3, end=currentDate+4days\n@@ -747,7 +582,6 @@ test.describe(\"Out of office\", () => {\n           teammates: teamMatesObj,\n         }\n       );\n-      const member1User = users.get().find((user) => user.name === member1Name);\n       const member2User = users.get().find((user) => user.name === member2Name);\n \n       //create OOO for member3, start:currentDate-2Days, end:currentDate-4days (for Last 7 Days)\n@@ -768,12 +602,7 @@ test.describe(\"Out of office\", () => {\n       });\n \n       await member3User?.apiLogin();\n-      const entriesListRespPromise = page.waitForResponse(\n-        (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-      );\n-      await page.goto(\"/settings/my-account/out-of-office\");\n-      await entriesListRespPromise;\n-      await page.waitForLoadState(\"domcontentloaded\");\n+      await goToOOOPage(page);\n \n       //Default filter 'Last 7 Days' when DateRange Filter is selected\n       await test.step(\"Default filter - 'Last 7 Days'\", async () => {\n@@ -809,7 +638,6 @@ test.describe(\"Out of office\", () => {\n         }\n       );\n       const member1User = users.get().find((user) => user.name === member1Name);\n-      const member2User = users.get().find((user) => user.name === member2Name);\n \n       //create OOO for member3, start:currentDate-12Days, end:currentDate-10days (for Last 30 Days)\n       await prisma.outOfOfficeEntry.create({\n@@ -829,12 +657,7 @@ test.describe(\"Out of office\", () => {\n       });\n \n       await member3User?.apiLogin();\n-      const entriesListRespPromise = page.waitForResponse(\n-        (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n-      );\n-      await page.goto(\"/settings/my-account/out-of-office\");\n-      await entriesListRespPromise;\n-      await page.waitForLoadState(\"domcontentloaded\");\n+      await goToOOOPage(page);\n \n       //Select 'Last 30 Days'\n       await test.step(\"select 'Last 30 Days'\", async () => {\n@@ -872,6 +695,9 @@ async function saveAndWaitForResponse(page: Page, expectedStatusCode = 200) {\n }\n \n async function selectToAndFromDates(page: Page, fromDate: string, toDate: string, isRangeInPast = false) {\n+  await page.getByTestId(\"date-range\").click();\n+  await page.locator(\".rdp\").waitFor({ state: \"visible\" });\n+\n   const month = isRangeInPast ? \"previous\" : \"next\";\n \n   await page.locator(`button[name=\"${month}-month\"]`).click();\n@@ -891,14 +717,25 @@ async function selectDateAndCreateOOO(\n   editMode = false\n ) {\n   const t = await localize(\"en\");\n-  await page.locator(`button[name=\"${month}-month\"]`).click();\n+\n+  await page.getByTestId(\"date-range\").click();\n+  await page.locator(\".rdp\").waitFor({ state: \"visible\" });\n+\n+  // Look for month navigation button\n+  const monthButtonSelector = `button[name=\"${month}-month\"]`;\n+\n+  await page.locator(monthButtonSelector).click();\n+\n   await page.locator(`button[name=\"day\"]:text-is(\"${fromDate}\")`).nth(0).click();\n+\n   await page.locator(`button[name=\"day\"]:text-is(\"${toDate}\")`).nth(0).click();\n-  editMode\n-    ? await page.locator(`text=${t(\"edit_an_out_of_office\")}`).click()\n-    : forTeamMember\n-    ? await page.locator(`text=${t(\"create_ooo_dialog_team_title\")}`).click()\n-    : await page.locator(`text=${t(\"create_an_out_of_office\")}`).click();\n+  if (editMode) {\n+    await page.locator(`text=${t(\"edit_an_out_of_office\")}`).click();\n+  } else if (forTeamMember) {\n+    await page.locator(`text=${t(\"create_ooo_dialog_team_title\")}`).click();\n+  } else {\n+    await page.locator(`text=${t(\"create_an_out_of_office\")}`).click();\n+  }\n   await page.getByTestId(\"reason_select\").click();\n   await page.getByTestId(\"select-option-4\").click();\n   await page.getByTestId(\"notes_input\").click();\n@@ -909,3 +746,16 @@ async function selectDateAndCreateOOO(\n   }\n   await saveAndWaitForResponse(page, expectedStatusCode);\n }\n+\n+async function goToOOOPage(page: Page, type: \"individual\" | \"team\" = \"individual\") {\n+  const entriesListRespPromise = page.waitForResponse(\n+    (response) => response.url().includes(\"outOfOfficeEntriesList\") && response.status() === 200\n+  );\n+  await page.goto(\"/settings/my-account/out-of-office\" + (type === \"team\" ? \"?type=team\" : \"\"));\n+  await page.waitForLoadState(\"domcontentloaded\");\n+  await entriesListRespPromise;\n+}\n+\n+async function openOOODialog(page: Page) {\n+  await page.getByTestId(\"add_entry_ooo\").click();\n+}\ndiff --git a/packages/ui/components/form/date-range-picker/Calendar.tsx b/packages/ui/components/form/date-range-picker/Calendar.tsx\nindex c5a8015694de5f..fc0e81b56037cd 100644\n--- a/packages/ui/components/form/date-range-picker/Calendar.tsx\n+++ b/packages/ui/components/form/date-range-picker/Calendar.tsx\n@@ -42,8 +42,8 @@ function Calendar({\n           buttonClasses({ color: \"minimal\" }),\n           \"w-8 h-8 md:h-11 md:w-11 p-0 text-sm font-medium aria-selected:opacity-100 inline-flex items-center justify-center\"\n         ),\n-        day_range_end: \"hover:!bg-inverted hover:!text-inverted\",\n-        day_range_start: \"hover:!bg-inverted hover:!text-inverted\",\n+        day_range_end: \"hover:bg-inverted! text-inverted!\",\n+        day_range_start: \"hover:bg-inverted! text-inverted!\",\n         day_selected: \"bg-inverted text-inverted\",\n         day_today: \"\",\n         day_outside: \"\",\ndiff --git a/packages/ui/components/form/date-range-picker/DateRangePicker.tsx b/packages/ui/components/form/date-range-picker/DateRangePicker.tsx\nindex 7fa7fc517da9bc..e0dbe146cc1d49 100644\n--- a/packages/ui/components/form/date-range-picker/DateRangePicker.tsx\n+++ b/packages/ui/components/form/date-range-picker/DateRangePicker.tsx\n@@ -1,13 +1,14 @@\n \"use client\";\n \n import * as Popover from \"@radix-ui/react-popover\";\n-import { format } from \"date-fns\";\n-import * as React from \"react\";\n+import { format, isBefore, isSameDay } from \"date-fns\";\n+import { useState, useMemo, type HTMLAttributes } from \"react\";\n \n import classNames from \"@calcom/ui/classNames\";\n \n import { Button } from \"../../button\";\n import { Calendar } from \"./Calendar\";\n+import { calculateNewDateRange } from \"./dateRangeLogic\";\n \n type DatePickerWithRangeProps = {\n   dates: { startDate?: Date; endDate?: Date };\n@@ -32,41 +33,44 @@ export function DatePickerWithRange({\n   \"data-testid\": testId,\n   strictlyBottom,\n   allowPastDates = false,\n-}: React.HTMLAttributes<HTMLDivElement> & DatePickerWithRangeProps) {\n+}: HTMLAttributes<HTMLDivElement> & DatePickerWithRangeProps) {\n+  const [hoveredDate, setHoveredDate] = useState<Date | undefined>(undefined);\n+\n   function handleDayClick(date: Date) {\n-    if (allowPastDates) {\n-      // for Out of Office (past dates allowed)\n-      if (dates?.endDate) {\n-        onDatesChange({ startDate: date, endDate: undefined });\n-      } else {\n-        const startDate = dates.startDate ? (date < dates.startDate ? date : dates.startDate) : date;\n-        const endDate = dates.startDate ? (date < dates.startDate ? dates.startDate : date) : undefined;\n-        onDatesChange({ startDate, endDate });\n-      }\n-    } else {\n-      // for Limit Future Booking and other date range selections (no past dates)\n-      if (!dates.startDate) {\n-        onDatesChange({ startDate: date, endDate: undefined });\n-      } else if (!dates.endDate) {\n-        if (date < dates.startDate) {\n-          onDatesChange({ startDate: date, endDate: dates.startDate });\n-        } else {\n-          onDatesChange({ startDate: dates.startDate, endDate: date });\n-        }\n-      } else {\n-        if (date.getTime() === dates.startDate.getTime() || date.getTime() === dates.endDate.getTime()) {\n-          onDatesChange({ startDate: date, endDate: undefined });\n-        } else if (date < dates.startDate) {\n-          onDatesChange({ startDate: date, endDate: undefined });\n-        } else {\n-          onDatesChange({ startDate: dates.startDate, endDate: date });\n-        }\n-      }\n+    const newDates = calculateNewDateRange({\n+      startDate: dates.startDate,\n+      endDate: dates.endDate,\n+      clickedDate: date,\n+    });\n+    onDatesChange(newDates);\n+    setHoveredDate(undefined);\n+  }\n+\n+  function handleDayMouseEnter(date: Date) {\n+    if (dates.startDate && !dates.endDate) {\n+      setHoveredDate(date);\n     }\n   }\n \n+  function handleDayMouseLeave() {\n+    setHoveredDate(undefined);\n+  }\n+\n   const fromDate = allowPastDates && minDate === null ? undefined : minDate ?? new Date();\n \n+  const hoverRangeModifier = useMemo(() => {\n+    if (!dates.startDate || dates.endDate || !hoveredDate) {\n+      return undefined;\n+    }\n+    if (isSameDay(dates.startDate, hoveredDate)) {\n+      return undefined;\n+    }\n+    if (isBefore(hoveredDate, dates.startDate)) {\n+      return { from: hoveredDate, to: dates.startDate };\n+    }\n+    return { from: dates.startDate, to: hoveredDate };\n+  }, [dates.startDate, dates.endDate, hoveredDate]);\n+\n   const calendar = (\n     <Calendar\n       initialFocus\n@@ -76,9 +80,13 @@ export function DatePickerWithRange({\n       defaultMonth={dates?.startDate}\n       selected={{ from: dates?.startDate, to: dates?.endDate }}\n       onDayClick={(day) => handleDayClick(day)}\n+      onDayMouseEnter={handleDayMouseEnter}\n+      onDayMouseLeave={handleDayMouseLeave}\n       numberOfMonths={1}\n       disabled={disabled}\n       data-testid={testId}\n+      modifiers={hoverRangeModifier ? { hoverRange: hoverRangeModifier } : undefined}\n+      modifiersClassNames={hoverRangeModifier ? { hoverRange: \"bg-emphasis\" } : undefined}\n     />\n   );\n \n@@ -118,8 +126,8 @@ export function DatePickerWithRange({\n             onInteractOutside={(event) => {\n               if (dates?.startDate && !dates?.endDate) {\n                 event.preventDefault();\n-              }}}\n-            >\n+              }\n+            }}>\n             {calendar}\n           </Popover.Content>\n         </Popover.Portal>\ndiff --git a/packages/ui/components/form/date-range-picker/dateRangeLogic.test.ts b/packages/ui/components/form/date-range-picker/dateRangeLogic.test.ts\nnew file mode 100644\nindex 00000000000000..b0975d8e69d800\n--- /dev/null\n+++ b/packages/ui/components/form/date-range-picker/dateRangeLogic.test.ts\n@@ -0,0 +1,190 @@\n+import { describe, it, expect } from \"vitest\";\n+\n+import { calculateNewDateRange } from \"./dateRangeLogic\";\n+\n+describe(\"calculateNewDateRange\", () => {\n+  // Helper dates for testing\n+  const date1 = new Date(\"2024-01-01\");\n+  const date2 = new Date(\"2024-01-10\");\n+  const date3 = new Date(\"2024-01-20\");\n+  const date4 = new Date(\"2024-01-05\"); // Between date1 and date2\n+\n+  describe(\"Airbnb-style date range selection\", () => {\n+    it(\"should start a new range when no start date is set\", () => {\n+      const result = calculateNewDateRange({\n+        startDate: undefined,\n+        endDate: undefined,\n+        clickedDate: date1,\n+      });\n+\n+      expect(result).toEqual({\n+        startDate: date1,\n+        endDate: undefined,\n+      });\n+    });\n+\n+    it(\"should start a new range when both dates are already set\", () => {\n+      const result = calculateNewDateRange({\n+        startDate: date1,\n+        endDate: date2,\n+        clickedDate: date3,\n+      });\n+\n+      expect(result).toEqual({\n+        startDate: date3,\n+        endDate: undefined,\n+      });\n+    });\n+\n+    it(\"should complete the range when only start date is set (clicked date is after start)\", () => {\n+      const result = calculateNewDateRange({\n+        startDate: date1,\n+        endDate: undefined,\n+        clickedDate: date2,\n+      });\n+\n+      expect(result).toEqual({\n+        startDate: date1,\n+        endDate: date2,\n+      });\n+    });\n+\n+    it(\"should complete the range and swap dates when clicked date is before start date\", () => {\n+      const result = calculateNewDateRange({\n+        startDate: date2,\n+        endDate: undefined,\n+        clickedDate: date1,\n+      });\n+\n+      expect(result).toEqual({\n+        startDate: date1,\n+        endDate: date2,\n+      });\n+    });\n+\n+    it(\"should handle same date click when only start date is set\", () => {\n+      const result = calculateNewDateRange({\n+        startDate: date1,\n+        endDate: undefined,\n+        clickedDate: date1,\n+      });\n+\n+      expect(result).toEqual({\n+        startDate: date1,\n+        endDate: date1,\n+      });\n+    });\n+\n+    it(\"should handle clicking a date between start and end when range is complete\", () => {\n+      const result = calculateNewDateRange({\n+        startDate: date1,\n+        endDate: date2,\n+        clickedDate: date4,\n+      });\n+\n+      expect(result).toEqual({\n+        startDate: date4,\n+        endDate: undefined,\n+      });\n+    });\n+\n+    it(\"should reset range when clicking any date after both dates are set\", () => {\n+      const result = calculateNewDateRange({\n+        startDate: date1,\n+        endDate: date2,\n+        clickedDate: date1, // Click same as start\n+      });\n+\n+      expect(result).toEqual({\n+        startDate: date1,\n+        endDate: undefined,\n+      });\n+    });\n+  });\n+\n+  describe(\"Edge cases\", () => {\n+    it(\"should handle dates with different times on same day\", () => {\n+      const morning = new Date(\"2024-01-01T08:00:00\");\n+      const evening = new Date(\"2024-01-01T20:00:00\");\n+\n+      const result = calculateNewDateRange({\n+        startDate: morning,\n+        endDate: undefined,\n+        clickedDate: evening,\n+      });\n+\n+      expect(result).toEqual({\n+        startDate: morning,\n+        endDate: evening,\n+      });\n+    });\n+\n+    it(\"should maintain immutability - not modify input dates\", () => {\n+      const originalStart = new Date(\"2024-01-01\");\n+      const originalEnd = new Date(\"2024-01-10\");\n+      const clickedDate = new Date(\"2024-01-15\");\n+\n+      calculateNewDateRange({\n+        startDate: originalStart,\n+        endDate: originalEnd,\n+        clickedDate,\n+      });\n+\n+      // Original dates should not be modified\n+      expect(originalStart.toISOString()).toBe(new Date(\"2024-01-01\").toISOString());\n+      expect(originalEnd.toISOString()).toBe(new Date(\"2024-01-10\").toISOString());\n+    });\n+\n+    it(\"should handle selecting dates in reverse order\", () => {\n+      // First click - set start\n+      const result1 = calculateNewDateRange({\n+        startDate: undefined,\n+        endDate: undefined,\n+        clickedDate: date2,\n+      });\n+\n+      expect(result1).toEqual({\n+        startDate: date2,\n+        endDate: undefined,\n+      });\n+\n+      // Second click - click earlier date, should swap\n+      const result2 = calculateNewDateRange({\n+        startDate: result1.startDate,\n+        endDate: result1.endDate,\n+        clickedDate: date1,\n+      });\n+\n+      expect(result2).toEqual({\n+        startDate: date1,\n+        endDate: date2,\n+      });\n+    });\n+\n+    it(\"should start fresh after completing a range\", () => {\n+      // Complete a range\n+      const result1 = calculateNewDateRange({\n+        startDate: date1,\n+        endDate: date2,\n+        clickedDate: date3, // This should reset\n+      });\n+\n+      expect(result1).toEqual({\n+        startDate: date3,\n+        endDate: undefined,\n+      });\n+\n+      // Should be able to complete the new range\n+      const result2 = calculateNewDateRange({\n+        startDate: result1.startDate,\n+        endDate: result1.endDate,\n+        clickedDate: date2,\n+      });\n+\n+      expect(result2).toEqual({\n+        startDate: date2,\n+        endDate: date3,\n+      });\n+    });\n+  });\n+});\ndiff --git a/packages/ui/components/form/date-range-picker/dateRangeLogic.ts b/packages/ui/components/form/date-range-picker/dateRangeLogic.ts\nnew file mode 100644\nindex 00000000000000..23b9628d2d5cf1\n--- /dev/null\n+++ b/packages/ui/components/form/date-range-picker/dateRangeLogic.ts\n@@ -0,0 +1,36 @@\n+export type DateRange = {\n+  startDate?: Date;\n+  endDate?: Date;\n+};\n+\n+export type CalculateNewDateRangeParams = {\n+  startDate?: Date;\n+  endDate?: Date;\n+  clickedDate: Date;\n+};\n+\n+/**\n+ * Determines the new date range based on user's date selection.\n+ * Implements Airbnb-style date range selection behavior.\n+ *\n+ * @param params - Object containing startDate, endDate, and clickedDate\n+ * @returns The new date range state\n+ */\n+export function calculateNewDateRange({\n+  startDate,\n+  endDate,\n+  clickedDate,\n+}: CalculateNewDateRangeParams): DateRange {\n+  // Airbnb-style: when both dates are set, any click starts a new range\n+  if (!startDate || endDate) {\n+    // No start date OR both dates set -> start fresh\n+    return { startDate: clickedDate, endDate: undefined };\n+  } else {\n+    // Have start but no end -> complete the range (swap if needed)\n+    if (clickedDate < startDate) {\n+      return { startDate: clickedDate, endDate: startDate };\n+    } else {\n+      return { startDate: startDate, endDate: clickedDate };\n+    }\n+  }\n+}\n"}
{"instance_id": "calcom__cal.com.main.25369", "repo": "calcom/cal.com", "base_commit": "f2b2b6e491cbb850a917a50c6a0cb3850ffd156a", "head_commit": "e5d70cdaf686614a5ed92ea99b759f01f3826e84", "title": "fix: prevent 500 errors in round-robin scheduling from OOO calibration for single host", "merged_at": "2025-11-25T07:13:04Z", "html_url": "https://github.com/calcom/cal.com/pull/25369", "test_files": ["packages/features/bookings/lib/getLuckyUser.test.ts"], "code_files": ["packages/features/bookings/lib/getLuckyUser.ts"], "total_changes": 74, "num_files": 2, "pull_number": 25369, "patch": "diff --git a/packages/features/bookings/lib/getLuckyUser.test.ts b/packages/features/bookings/lib/getLuckyUser.test.ts\nindex 08e553a83bdfcc..4974f6cd1facae 100644\n--- a/packages/features/bookings/lib/getLuckyUser.test.ts\n+++ b/packages/features/bookings/lib/getLuckyUser.test.ts\n@@ -827,6 +827,75 @@ describe(\"maximize availability and weights\", () => {\n     );\n   });\n \n+  it(\"skips OOO calibration when there is only one host\", async () => {\n+    const users: GetLuckyUserAvailableUsersType = [\n+      buildUser({\n+        id: 1,\n+        username: \"test1\",\n+        name: \"Test User 1\",\n+        email: \"test1@example.com\",\n+        bookings: [],\n+      }),\n+    ];\n+\n+    const allRRHosts = [\n+      {\n+        user: {\n+          id: users[0].id,\n+          email: users[0].email,\n+          credentials: [],\n+          userLevelSelectedCalendars: [],\n+        },\n+        weight: users[0].weight,\n+        createdAt: new Date(0),\n+      },\n+    ];\n+\n+    CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue({ success: true, data: [] });\n+\n+    // Mock OOO entry for the single host\n+    prismaMock.outOfOfficeEntry.findMany.mockResolvedValue([\n+      {\n+        start: dayjs().subtract(10, \"day\").toDate(),\n+        end: dayjs().subtract(5, \"day\").toDate(),\n+        userId: users[0].id,\n+      },\n+    ]);\n+\n+    prismaMock.user.findMany.mockResolvedValue(users);\n+    prismaMock.host.findMany.mockResolvedValue([\n+      {\n+        userId: allRRHosts[0].user.id,\n+        weight: allRRHosts[0].weight,\n+        createdAt: allRRHosts[0].createdAt,\n+      },\n+    ]);\n+\n+    // Mock some bookings during the OOO period (though there's only one host)\n+    prismaMock.booking.findMany.mockResolvedValue([\n+      buildBooking({\n+        id: 1,\n+        userId: 1,\n+        createdAt: dayjs().subtract(7, \"days\").toDate(),\n+      }),\n+    ]);\n+\n+    // Should return the only available user without throwing division by zero error\n+    await expect(\n+      luckyUserService.getLuckyUser({\n+        availableUsers: users,\n+        eventType: {\n+          id: 1,\n+          isRRWeightsEnabled: true,\n+          team: { rrResetInterval: RRResetInterval.MONTH, rrTimestampBasis: RRTimestampBasis.CREATED_AT },\n+          includeNoShowInRRCalculation: false,\n+        },\n+        allRRHosts,\n+        routingFormResponse: null,\n+      })\n+    ).resolves.toStrictEqual(users[0]);\n+  });\n+\n   it(\"applies calibration to newly added hosts so they are not penalized unfairly compared to their peers\", async () => {\n     const users: GetLuckyUserAvailableUsersType = [\n       buildUser({\ndiff --git a/packages/features/bookings/lib/getLuckyUser.ts b/packages/features/bookings/lib/getLuckyUser.ts\nindex 8d6c75d8bc5b52..e0afa668f4608d 100644\n--- a/packages/features/bookings/lib/getLuckyUser.ts\n+++ b/packages/features/bookings/lib/getLuckyUser.ts\n@@ -300,6 +300,11 @@ export class LuckyUserService implements ILuckyUserService {\n     const oooCalibration = new Map<number, number>();\n \n     oooData.forEach(({ userId, oooEntries }) => {\n+      // Skip OOO calibration if there's only one host (division by zero would occur)\n+      if (hosts.length <= 1) {\n+        return;\n+      }\n+\n       let calibration = 0;\n \n       oooEntries.forEach((oooEntry) => {\n"}
{"instance_id": "calcom__cal.com.main.25332", "repo": "calcom/cal.com", "base_commit": "9c2d7f99c2ba3b845fe13456722557555bf2d963", "head_commit": "9817dcf2da9af66e69c368c5ea00f9c5767bb8be", "title": "chore: team update handler refactor", "merged_at": "2025-11-25T11:27:26Z", "html_url": "https://github.com/calcom/cal.com/pull/25332", "test_files": ["packages/trpc/server/routers/viewer/teams/update.handler.test.ts"], "code_files": ["packages/trpc/server/routers/viewer/teams/update.handler.ts"], "total_changes": 262, "num_files": 2, "pull_number": 25332, "patch": "diff --git a/packages/trpc/server/routers/viewer/teams/update.handler.test.ts b/packages/trpc/server/routers/viewer/teams/update.handler.test.ts\nnew file mode 100644\nindex 00000000000000..59cabfd4dc81c5\n--- /dev/null\n+++ b/packages/trpc/server/routers/viewer/teams/update.handler.test.ts\n@@ -0,0 +1,215 @@\n+import { describe, it, expect, vi, beforeEach } from \"vitest\";\n+\n+import { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\n+import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\n+import { prisma } from \"@calcom/prisma\";\n+import { RRTimestampBasis } from \"@calcom/prisma/enums\";\n+\n+import type { TrpcSessionUser } from \"../../../types\";\n+import { updateHandler } from \"./update.handler\";\n+import type { TUpdateInputSchema } from \"./update.schema\";\n+\n+vi.mock(\"@calcom/prisma\", () => ({\n+  prisma: {\n+    team: {\n+      findUnique: vi.fn(),\n+      update: vi.fn(),\n+      updateMany: vi.fn(),\n+    },\n+    eventType: {\n+      updateMany: vi.fn(),\n+    },\n+    tempOrgRedirect: {\n+      updateMany: vi.fn(),\n+    },\n+  },\n+}));\n+\n+vi.mock(\"@calcom/features/pbac/services/permission-check.service\", () => ({\n+  PermissionCheckService: vi.fn().mockImplementation(() => ({\n+    checkPermission: vi.fn(),\n+  })),\n+}));\n+\n+vi.mock(\"@calcom/features/ee/teams/repositories/TeamRepository\", () => ({\n+  TeamRepository: vi.fn().mockImplementation(() => ({\n+    isSlugAvailableForUpdate: vi.fn().mockResolvedValue(true),\n+  })),\n+}));\n+\n+vi.mock(\"@calcom/lib/server/avatar\", () => ({\n+  uploadLogo: vi.fn().mockResolvedValue(\"https://example.com/logo.png\"),\n+}));\n+\n+vi.mock(\"@calcom/lib/intervalLimits/validateIntervalLimitOrder\", () => ({\n+  validateIntervalLimitOrder: vi.fn().mockReturnValue(true),\n+}));\n+\n+vi.mock(\"@calcom/lib/constants\", () => ({\n+  IS_TEAM_BILLING_ENABLED: false,\n+}));\n+\n+vi.mock(\"@calcom/ee/organizations/lib/orgDomains\", () => ({\n+  getOrgFullOrigin: vi.fn((slug: string) => `https://${slug}.cal.com`),\n+}));\n+\n+describe(\"updateHandler - Permission Check Tests\", () => {\n+  const mockPermissionCheckService = {\n+    checkPermission: vi.fn(),\n+  };\n+\n+  const mockTeamRepository = {\n+    isSlugAvailableForUpdate: vi.fn().mockResolvedValue(true),\n+  };\n+\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+    vi.mocked(PermissionCheckService).mockImplementation(\n+      () => mockPermissionCheckService as unknown as InstanceType<typeof PermissionCheckService>\n+    );\n+    vi.mocked(TeamRepository).mockImplementation(\n+      () => mockTeamRepository as unknown as InstanceType<typeof TeamRepository>\n+    );\n+  });\n+\n+  describe(\"Permission Check Service\", () => {\n+    const user: NonNullable<TrpcSessionUser> = {\n+      id: 1,\n+      organizationId: 100,\n+    } as NonNullable<TrpcSessionUser>;\n+\n+    it(\"should use permission check service for all users\", async () => {\n+      const input: TUpdateInputSchema = {\n+        id: 50,\n+        name: \"Updated Team\",\n+      };\n+\n+      mockPermissionCheckService.checkPermission.mockResolvedValue(true);\n+\n+      vi.mocked(prisma.team.findUnique).mockResolvedValue({\n+        id: 50,\n+        parentId: 100,\n+        slug: \"test-team\",\n+        metadata: {},\n+        rrTimestampBasis: RRTimestampBasis.CREATED_AT,\n+      } as any);\n+\n+      vi.mocked(prisma.team.update).mockResolvedValue({\n+        id: 50,\n+        name: \"Updated Team\",\n+        bio: null,\n+        slug: \"test-team\",\n+        theme: null,\n+        brandColor: null,\n+        darkBrandColor: null,\n+        logoUrl: null,\n+        bookingLimits: null,\n+        includeManagedEventsInLimits: null,\n+        rrResetInterval: null,\n+        rrTimestampBasis: RRTimestampBasis.CREATED_AT,\n+      } as any);\n+\n+      await updateHandler({\n+        ctx: { user },\n+        input,\n+      });\n+\n+      expect(mockPermissionCheckService.checkPermission).toHaveBeenCalledWith({\n+        userId: user.id,\n+        teamId: input.id,\n+        permission: \"team.update\",\n+        fallbackRoles: expect.any(Array),\n+      });\n+      expect(prisma.team.update).toHaveBeenCalled();\n+    });\n+\n+    it(\"should throw UNAUTHORIZED when permission check fails\", async () => {\n+      const input: TUpdateInputSchema = {\n+        id: 50,\n+        name: \"Unauthorized Update\",\n+      };\n+\n+      mockPermissionCheckService.checkPermission.mockResolvedValue(false);\n+\n+      vi.mocked(prisma.team.findUnique).mockResolvedValue({\n+        id: 50,\n+        parentId: 100,\n+        slug: \"test-team\",\n+        metadata: {},\n+        rrTimestampBasis: RRTimestampBasis.CREATED_AT,\n+      } as any);\n+\n+      await expect(\n+        updateHandler({\n+          ctx: { user },\n+          input,\n+        })\n+      ).rejects.toMatchObject({\n+        code: \"UNAUTHORIZED\",\n+      });\n+\n+      expect(prisma.team.update).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"should throw UNAUTHORIZED when user has no id\", async () => {\n+      const userWithoutId = {\n+        id: undefined,\n+        organizationId: 100,\n+      } as unknown as NonNullable<TrpcSessionUser>;\n+\n+      const input: TUpdateInputSchema = {\n+        id: 50,\n+        name: \"Updated Team\",\n+      };\n+\n+      vi.mocked(prisma.team.findUnique).mockResolvedValue({\n+        id: 50,\n+        parentId: 100,\n+        slug: \"test-team\",\n+        metadata: {},\n+        rrTimestampBasis: RRTimestampBasis.CREATED_AT,\n+      } as any);\n+\n+      await expect(\n+        updateHandler({\n+          ctx: { user: userWithoutId },\n+          input,\n+        })\n+      ).rejects.toMatchObject({\n+        code: \"UNAUTHORIZED\",\n+      });\n+\n+      expect(mockPermissionCheckService.checkPermission).not.toHaveBeenCalled();\n+      expect(prisma.team.update).not.toHaveBeenCalled();\n+    });\n+  });\n+\n+  describe(\"Team Not Found\", () => {\n+    const user: NonNullable<TrpcSessionUser> = {\n+      id: 1,\n+      organizationId: 100,\n+    } as NonNullable<TrpcSessionUser>;\n+\n+    it(\"should throw NOT_FOUND when team does not exist\", async () => {\n+      const input: TUpdateInputSchema = {\n+        id: 999,\n+        name: \"Non-existent Team\",\n+      };\n+\n+      vi.mocked(prisma.team.findUnique).mockResolvedValue(null);\n+\n+      await expect(\n+        updateHandler({\n+          ctx: { user },\n+          input,\n+        })\n+      ).rejects.toMatchObject({\n+        code: \"NOT_FOUND\",\n+        message: \"Team not found.\",\n+      });\n+\n+      // Should not check permissions if team doesn't exist\n+      expect(mockPermissionCheckService.checkPermission).not.toHaveBeenCalled();\n+    });\n+  });\n+});\ndiff --git a/packages/trpc/server/routers/viewer/teams/update.handler.ts b/packages/trpc/server/routers/viewer/teams/update.handler.ts\nindex 55022aad5aeb59..43fa3859940f52 100644\n--- a/packages/trpc/server/routers/viewer/teams/update.handler.ts\n+++ b/packages/trpc/server/routers/viewer/teams/update.handler.ts\n@@ -23,20 +23,35 @@ type UpdateOptions = {\n };\n \n export const updateHandler = async ({ ctx, input }: UpdateOptions) => {\n-  const isOrgAdmin = ctx.user?.organization?.isOrgAdmin;\n+  const prevTeam = await prisma.team.findUnique({\n+    where: {\n+      id: input.id,\n+    },\n+    select: {\n+      id: true,\n+      parentId: true,\n+      slug: true,\n+      metadata: true,\n+      rrTimestampBasis: true,\n+    },\n+  });\n \n-  if (!isOrgAdmin) {\n-    const permissionCheckService = new PermissionCheckService();\n-    const hasTeamUpdatePermission = await permissionCheckService.checkPermission({\n-      userId: ctx.user?.id || 0,\n-      teamId: input.id,\n-      permission: \"team.update\",\n-      fallbackRoles: [MembershipRole.OWNER, MembershipRole.ADMIN],\n-    });\n+  if (!prevTeam) throw new TRPCError({ code: \"NOT_FOUND\", message: \"Team not found.\" });\n \n-    if (!hasTeamUpdatePermission) {\n-      throw new TRPCError({ code: \"UNAUTHORIZED\" });\n-    }\n+  if (!ctx.user?.id) {\n+    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n+  }\n+\n+  const permissionCheckService = new PermissionCheckService();\n+  const hasTeamUpdatePermission = await permissionCheckService.checkPermission({\n+    userId: ctx.user.id,\n+    teamId: input.id,\n+    permission: \"team.update\",\n+    fallbackRoles: [MembershipRole.OWNER, MembershipRole.ADMIN],\n+  });\n+\n+  if (!hasTeamUpdatePermission) {\n+    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n   }\n \n   if (input.slug) {\n@@ -52,14 +67,6 @@ export const updateHandler = async ({ ctx, input }: UpdateOptions) => {\n     }\n   }\n \n-  const prevTeam = await prisma.team.findUnique({\n-    where: {\n-      id: input.id,\n-    },\n-  });\n-\n-  if (!prevTeam) throw new TRPCError({ code: \"NOT_FOUND\", message: \"Team not found.\" });\n-\n   if (input.bookingLimits) {\n     const isValid = validateIntervalLimitOrder(input.bookingLimits);\n     if (!isValid)\n"}
{"instance_id": "calcom__cal.com.main.25330", "repo": "calcom/cal.com", "base_commit": "0af77be1272bc5b64961e639fe0ee20b040d2abd", "head_commit": "d1092c3b5badde359c4786f21b7eb33bea4a8c19", "title": "fix: filter on invites", "merged_at": "2025-11-21T18:34:05Z", "html_url": "https://github.com/calcom/cal.com/pull/25330", "test_files": ["packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts"], "code_files": ["packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts"], "total_changes": 213, "num_files": 2, "pull_number": 25330, "patch": "diff --git a/packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts b/packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts\nindex 04a71d338012b2..d1952ee36e3263 100644\n--- a/packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts\n+++ b/packages/trpc/server/routers/viewer/teams/inviteMember/inviteMemberUtils.test.ts\n@@ -1,4 +1,4 @@\n-import { describe, it, vi, expect } from \"vitest\";\n+import { describe, it, vi, expect, beforeEach } from \"vitest\";\n \n import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n@@ -16,11 +16,21 @@ import {\n   canBeInvited,\n   getAutoJoinStatus,\n   checkInputEmailIsValid,\n+  createMemberships,\n } from \"./utils\";\n \n+const { mockCreateMany } = vi.hoisted(() => {\n+  const mockCreateManyFn = vi.fn();\n+  return { mockCreateMany: mockCreateManyFn };\n+});\n+\n vi.mock(\"@calcom/prisma\", () => {\n   return {\n-    prisma: vi.fn(),\n+    prisma: {\n+      membership: {\n+        createMany: mockCreateMany,\n+      },\n+    },\n   };\n });\n \n@@ -37,6 +47,27 @@ vi.mock(\"@calcom/features/pbac/services/permission-check.service\", () => {\n   };\n });\n \n+vi.mock(\"@calcom/lib/logger\", () => {\n+  const mockSubLogger = {\n+    debug: vi.fn(),\n+    error: vi.fn(),\n+    log: vi.fn(),\n+    warn: vi.fn(),\n+    info: vi.fn(),\n+    getSubLogger: vi.fn(() => mockSubLogger),\n+  };\n+  return {\n+    default: {\n+      getSubLogger: vi.fn(() => mockSubLogger),\n+      error: vi.fn(),\n+      debug: vi.fn(),\n+      log: vi.fn(),\n+      warn: vi.fn(),\n+      info: vi.fn(),\n+    },\n+  };\n+});\n+\n const mockedRegularTeam: TeamWithParent = {\n   id: 1,\n   name: \"Team A\",\n@@ -609,6 +640,178 @@ describe(\"Invite Member Utils\", () => {\n       });\n     });\n   });\n+\n+  describe(\"createMemberships - Privilege Escalation Prevention\", () => {\n+    beforeEach(() => {\n+      mockCreateMany.mockClear();\n+      mockCreateMany.mockResolvedValue({ count: 0 });\n+    });\n+\n+    it(\"should NOT escalate privilege when attacker has OWNER role in unrelated team\", async () => {\n+      const attackerTeamId = 999; // Attacker's personal team\n+      const victimTeamId = 100; // Victim team being invited to\n+      const victimOrgId = 200; // Parent organization of victim team\n+\n+      const attacker: UserWithMembership & {\n+        newRole: MembershipRole;\n+        needToCreateOrgMembership: boolean | null;\n+      } = {\n+        ...mockUser,\n+        id: 1,\n+        email: \"attacker@example.com\",\n+        username: \"attacker\",\n+        teams: [\n+          // Attacker controls this - OWNER role in their personal team (first in array)\n+          { teamId: attackerTeamId, userId: 1, accepted: true, role: MembershipRole.OWNER },\n+          // Some other unrelated membership\n+          { teamId: 50, userId: 1, accepted: true, role: MembershipRole.MEMBER },\n+        ],\n+        newRole: MembershipRole.MEMBER, // Inviter wants to invite as MEMBER\n+        needToCreateOrgMembership: true,\n+      };\n+\n+      await createMemberships({\n+        teamId: victimTeamId,\n+        language: \"en\",\n+        invitees: [attacker],\n+        parentId: victimOrgId,\n+        accepted: false,\n+      });\n+\n+      // Verify createMany was called\n+      expect(mockCreateMany).toHaveBeenCalledTimes(1);\n+\n+      // Get the data that was passed to createMany\n+      const callArgs = mockCreateMany.mock.calls[0][0];\n+      const createdMemberships = callArgs.data;\n+\n+      // Should create 2 memberships: one for team, one for org\n+      expect(createdMemberships).toHaveLength(2);\n+\n+      // Check team membership - should be MEMBER (inviter's choice), NOT OWNER\n+      const teamMembership = createdMemberships.find((m: any) => m.teamId === victimTeamId);\n+      expect(teamMembership).toBeDefined();\n+      expect(teamMembership.role).toBe(MembershipRole.MEMBER);\n+      expect(teamMembership.userId).toBe(attacker.id);\n+      expect(teamMembership.accepted).toBe(false);\n+\n+      // Check org membership\n+      const orgMembership = createdMemberships.find((m: any) => m.teamId === victimOrgId);\n+      expect(orgMembership).toBeDefined();\n+      expect(orgMembership.role).toBe(MembershipRole.MEMBER);\n+    });\n+\n+    it(\"should preserve ADMIN role when user is already ADMIN in parent organization\", async () => {\n+      const teamId = 100;\n+      const parentOrgId = 200;\n+\n+      const existingAdmin: UserWithMembership & {\n+        newRole: MembershipRole;\n+        needToCreateOrgMembership: boolean | null;\n+      } = {\n+        ...mockUser,\n+        id: 2,\n+        email: \"admin@example.com\",\n+        username: \"admin\",\n+        teams: [\n+          // User is already ADMIN in the parent org\n+          { teamId: parentOrgId, userId: 2, accepted: true, role: MembershipRole.ADMIN },\n+        ],\n+        newRole: MembershipRole.MEMBER, // Inviter wants MEMBER, but should preserve ADMIN\n+        needToCreateOrgMembership: false, // Already has org membership\n+      };\n+\n+      await createMemberships({\n+        teamId,\n+        language: \"en\",\n+        invitees: [existingAdmin],\n+        parentId: parentOrgId,\n+        accepted: true,\n+      });\n+\n+      const callArgs = mockCreateMany.mock.calls[0][0];\n+      const createdMemberships = callArgs.data;\n+\n+      // Should only create team membership (org membership already exists)\n+      expect(createdMemberships).toHaveLength(1);\n+\n+      // Should preserve ADMIN role since user is ADMIN in parent org\n+      const teamMembership = createdMemberships.find((m: any) => m.teamId === teamId);\n+      expect(teamMembership.role).toBe(MembershipRole.ADMIN);\n+    });\n+\n+    it(\"should use inviter's role when user has no membership in parent organization\", async () => {\n+      const teamId = 100;\n+      const parentOrgId = 200;\n+      const unrelatedTeamId = 999;\n+\n+      const user: UserWithMembership & {\n+        newRole: MembershipRole;\n+        needToCreateOrgMembership: boolean | null;\n+      } = {\n+        ...mockUser,\n+        id: 3,\n+        email: \"user@example.com\",\n+        username: \"user\",\n+        teams: [\n+          // User has OWNER in unrelated team, but NOT in parent org\n+          { teamId: unrelatedTeamId, userId: 3, accepted: true, role: MembershipRole.OWNER },\n+        ],\n+        newRole: MembershipRole.MEMBER,\n+        needToCreateOrgMembership: true,\n+      };\n+\n+      await createMemberships({\n+        teamId,\n+        language: \"en\",\n+        invitees: [user],\n+        parentId: parentOrgId,\n+        accepted: false,\n+      });\n+\n+      const callArgs = mockCreateMany.mock.calls[0][0];\n+      const createdMemberships = callArgs.data;\n+\n+      const teamMembership = createdMemberships.find((m: any) => m.teamId === teamId);\n+      // Should use inviter's chosen role (MEMBER), not OWNER from unrelated team\n+      expect(teamMembership.role).toBe(MembershipRole.MEMBER);\n+    });\n+\n+    it(\"should use inviter's role when inviting to team without parent organization\", async () => {\n+      const teamId = 100;\n+\n+      const user: UserWithMembership & {\n+        newRole: MembershipRole;\n+        needToCreateOrgMembership: boolean | null;\n+      } = {\n+        ...mockUser,\n+        id: 4,\n+        email: \"user2@example.com\",\n+        username: \"user2\",\n+        teams: [\n+          // User has OWNER in unrelated team\n+          { teamId: 999, userId: 4, accepted: true, role: MembershipRole.OWNER },\n+        ],\n+        newRole: MembershipRole.MEMBER,\n+        needToCreateOrgMembership: null,\n+      };\n+\n+      await createMemberships({\n+        teamId,\n+        language: \"en\",\n+        invitees: [user],\n+        parentId: null, // No parent org\n+        accepted: false,\n+      });\n+\n+      const callArgs = mockCreateMany.mock.calls[0][0];\n+      const createdMemberships = callArgs.data;\n+\n+      expect(createdMemberships).toHaveLength(1);\n+      // Should use inviter's chosen role when no parentId\n+      expect(createdMemberships[0].role).toBe(MembershipRole.MEMBER);\n+    });\n+  });\n });\n function getSampleProfile({ organizationId }: { organizationId?: number } = {}): {\n   id: number;\ndiff --git a/packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts b/packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts\nindex d00bf42f9c0333..0bf2ae50705264 100644\n--- a/packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts\n+++ b/packages/trpc/server/routers/viewer/teams/inviteMember/utils.ts\n@@ -5,11 +5,11 @@ import { getOrgFullOrigin } from \"@calcom/ee/organizations/lib/orgDomains\";\n import { sendTeamInviteEmail } from \"@calcom/emails/organization-email-service\";\n import { checkAdminOrOwner } from \"@calcom/features/auth/lib/checkAdminOrOwner\";\n import { updateNewTeamMemberEventTypes } from \"@calcom/features/ee/teams/lib/queries\";\n+import { OnboardingPathService } from \"@calcom/features/onboarding/lib/onboarding-path.service\";\n import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\n import { createAProfileForAnExistingUser } from \"@calcom/features/profile/lib/createAProfileForAnExistingUser\";\n import { ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n-import { OnboardingPathService } from \"@calcom/features/onboarding/lib/onboarding-path.service\";\n import { DEFAULT_SCHEDULE, getAvailabilityFromSchedule } from \"@calcom/lib/availability\";\n import { ENABLE_PROFILE_SWITCHER, WEBAPP_URL } from \"@calcom/lib/constants\";\n import logger from \"@calcom/lib/logger\";\n@@ -437,7 +437,9 @@ export async function createMemberships({\n   try {\n     await prisma.membership.createMany({\n       data: invitees.flatMap((invitee) => {\n-        const organizationRole = invitee?.teams?.[0]?.role;\n+        const organizationRole = parentId\n+          ? invitee?.teams?.find((membership) => membership.teamId === parentId)?.role\n+          : undefined;\n         const data = [];\n         const createdAt = new Date();\n         // membership for the team\n"}
{"instance_id": "calcom__cal.com.main.25326", "repo": "calcom/cal.com", "base_commit": "44311f51badd99513e0774500444da72d2230658", "head_commit": "e34a4d2cefad9a3997ef4a59bc743464649d020b", "title": "chore: improve membership check", "merged_at": "2025-11-21T17:34:15Z", "html_url": "https://github.com/calcom/cal.com/pull/25326", "test_files": ["packages/features/pbac/services/__tests__/role-management.factory.test.ts"], "code_files": ["packages/features/pbac/services/legacy-role-manager.service.ts", "packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts"], "total_changes": 78, "num_files": 3, "pull_number": 25326, "patch": "diff --git a/packages/features/pbac/services/__tests__/role-management.factory.test.ts b/packages/features/pbac/services/__tests__/role-management.factory.test.ts\nindex 669ad39345b884..0cdf1109c44a0e 100644\n--- a/packages/features/pbac/services/__tests__/role-management.factory.test.ts\n+++ b/packages/features/pbac/services/__tests__/role-management.factory.test.ts\n@@ -1,7 +1,7 @@\n import { vi, describe, it, expect, beforeEach } from \"vitest\";\n \n import { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\n-import { isOrganisationAdmin } from \"@calcom/lib/server/queries/organisations\";\n+import { isOrganisationAdmin, isOrganisationOwner } from \"@calcom/lib/server/queries/organisations\";\n import { prisma } from \"@calcom/prisma\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n \n@@ -26,6 +26,7 @@ vi.mock(\"@calcom/prisma\", () => ({\n }));\n vi.mock(\"@calcom/lib/server/queries/organisations\", () => ({\n   isOrganisationAdmin: vi.fn(),\n+  isOrganisationOwner: vi.fn(),\n }));\n \n describe(\"RoleManagementFactory\", () => {\n@@ -407,6 +408,33 @@ describe(\"RoleManagementFactory\", () => {\n           )\n         );\n       });\n+\n+      it(\"should prevent changing admin to owner\", async () => {\n+        vi.mocked(isOrganisationAdmin).mockResolvedValue({\n+          id: membershipId,\n+          userId,\n+          teamId: organizationId,\n+          role: MembershipRole.ADMIN,\n+          accepted: true,\n+          disableImpersonation: false,\n+          createdAt: new Date(),\n+          updatedAt: new Date(),\n+          customRoleId: null,\n+        });\n+        vi.mocked(isOrganisationOwner).mockResolvedValue(false);\n+        const manager = await factory.createRoleManager(organizationId);\n+        await expect(\n+          manager.checkPermissionToChangeRole(\n+            userId,\n+            organizationId,\n+            \"org\",\n+            membershipId,\n+            MembershipRole.OWNER\n+          )\n+        ).rejects.toThrow(\n+          new RoleManagementError(\"Only owners can update this role\", RoleManagementErrorCode.UNAUTHORIZED)\n+        );\n+      });\n     });\n \n     describe(\"assignRole\", () => {\ndiff --git a/packages/features/pbac/services/legacy-role-manager.service.ts b/packages/features/pbac/services/legacy-role-manager.service.ts\nindex 14e0c807cedb3c..c4c8e3ef308b9b 100644\n--- a/packages/features/pbac/services/legacy-role-manager.service.ts\n+++ b/packages/features/pbac/services/legacy-role-manager.service.ts\n@@ -1,5 +1,5 @@\n import { isTeamOwner } from \"@calcom/features/ee/teams/lib/queries\";\n-import { isOrganisationAdmin } from \"@calcom/lib/server/queries/organisations\";\n+import { isOrganisationAdmin, isOrganisationOwner } from \"@calcom/lib/server/queries/organisations\";\n import { prisma } from \"@calcom/prisma\";\n import type { Membership } from \"@calcom/prisma/client\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n@@ -73,6 +73,7 @@ export class LegacyRoleManager implements IRoleManager {\n     newRole?: MembershipRole | string\n   ): Promise<void> {\n     let hasPermission = false;\n+    const isOwnerChange = newRole === MembershipRole.OWNER;\n     if (scope === \"team\") {\n       const team = await prisma.membership.findFirst({\n         where: {\n@@ -84,13 +85,16 @@ export class LegacyRoleManager implements IRoleManager {\n       });\n       hasPermission = !!team;\n     } else {\n-      hasPermission = !!(await isOrganisationAdmin(userId, targetId));\n+      hasPermission =\n+        newRole === MembershipRole.OWNER\n+          ? !!(await isOrganisationOwner(userId, targetId))\n+          : !!(await isOrganisationAdmin(userId, targetId));\n     }\n \n     // Only OWNER/ADMIN can update role\n     if (!hasPermission) {\n       throw new RoleManagementError(\n-        \"Only owners or admin can update roles\",\n+        isOwnerChange ? \"Only owners can update this role\" : \"Only owners or admin can update roles\",\n         RoleManagementErrorCode.UNAUTHORIZED\n       );\n     }\n@@ -112,7 +116,7 @@ export class LegacyRoleManager implements IRoleManager {\n     organizationId: number,\n     role: MembershipRole | string,\n     // Used in other implementation\n-     \n+\n     _membershipId: number\n   ): Promise<void> {\n     await prisma.membership.update({\n@@ -129,7 +133,7 @@ export class LegacyRoleManager implements IRoleManager {\n   }\n \n   // Used in other implementation\n-   \n+\n   async getAllRoles(_organizationId: number): Promise<{ id: string; name: string }[]> {\n     return [\n       { id: MembershipRole.OWNER, name: \"Owner\" },\n@@ -139,7 +143,7 @@ export class LegacyRoleManager implements IRoleManager {\n   }\n \n   // Used in other implementation\n-   \n+\n   async getTeamRoles(_teamId: number): Promise<{ id: string; name: string }[]> {\n     return [\n       { id: MembershipRole.OWNER, name: \"Owner\" },\ndiff --git a/packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts b/packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts\nindex 049781a3c6e381..d30ebbecb0d2ca 100644\n--- a/packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts\n+++ b/packages/trpc/server/routers/viewer/organizations/updateUser.handler.ts\n@@ -43,19 +43,6 @@ export const updateUserHandler = async ({ ctx, input }: UpdateUserOptions) => {\n   if (!organizationId)\n     throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"You must be a member of an organizaiton\" });\n \n-  const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n-\n-  try {\n-    await roleManager.checkPermissionToChangeRole(userId, organizationId, \"org\");\n-  } catch (error) {\n-    if (error instanceof RoleManagementError) {\n-      throw new TRPCError({ code: \"UNAUTHORIZED\", message: error.message });\n-    }\n-    throw error;\n-  }\n-\n-  await ensureOrganizationIsReviewed(organizationId);\n-\n   // Is requested user a member of the organization?\n   const requestedMember = await prisma.membership.findFirst({\n     where: {\n@@ -96,6 +83,25 @@ export const updateUserHandler = async ({ ctx, input }: UpdateUserOptions) => {\n   if (!requestedMember)\n     throw new TRPCError({ code: \"UNAUTHORIZED\", message: \"User does not belong to your organization\" });\n \n+  const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n+\n+  try {\n+    await roleManager.checkPermissionToChangeRole(\n+      userId,\n+      organizationId,\n+      \"org\",\n+      requestedMember.id,\n+      input.role\n+    );\n+  } catch (error) {\n+    if (error instanceof RoleManagementError) {\n+      throw new TRPCError({ code: \"UNAUTHORIZED\", message: error.message });\n+    }\n+    throw error;\n+  }\n+\n+  await ensureOrganizationIsReviewed(organizationId);\n+\n   const hasUsernameUpdated = input.username !== requestedMember.user.profiles[0]?.username;\n \n   if (input.username && hasUsernameUpdated && user.profile.organization?.slug) {\n"}
{"instance_id": "calcom__cal.com.main.25325", "repo": "calcom/cal.com", "base_commit": "0af6354954b8e71b139a91f44f3b5c7b8d6454f2", "head_commit": "f9eda1c0a57d91274cfbb2f680b763da74805db7", "title": "fix: toggleEnabled handler", "merged_at": "2025-11-21T16:15:04Z", "html_url": "https://github.com/calcom/cal.com/pull/25325", "test_files": ["packages/trpc/server/routers/viewer/delegationCredential/toggleEnabled.handler.test.ts"], "code_files": ["packages/trpc/server/routers/viewer/delegationCredential/toggleEnabled.handler.ts"], "total_changes": 161, "num_files": 2, "pull_number": 25325, "patch": "diff --git a/packages/trpc/server/routers/viewer/delegationCredential/toggleEnabled.handler.test.ts b/packages/trpc/server/routers/viewer/delegationCredential/toggleEnabled.handler.test.ts\nnew file mode 100644\nindex 00000000000000..af1ecc37066172\n--- /dev/null\n+++ b/packages/trpc/server/routers/viewer/delegationCredential/toggleEnabled.handler.test.ts\n@@ -0,0 +1,153 @@\n+import { describe, it, beforeEach, vi, expect } from \"vitest\";\n+\n+import { DelegationCredentialRepository } from \"@calcom/features/delegation-credentials/repositories/DelegationCredentialRepository\";\n+\n+import { toggleDelegationCredentialEnabled } from \"./toggleEnabled.handler\";\n+\n+// Mock the repository\n+vi.mock(\"@calcom/features/delegation-credentials/repositories/DelegationCredentialRepository\", () => ({\n+  DelegationCredentialRepository: {\n+    findById: vi.fn(),\n+    updateById: vi.fn(),\n+    findByIdIncludeSensitiveServiceAccountKey: vi.fn(),\n+  },\n+}));\n+\n+// Mock other dependencies\n+vi.mock(\"@calcom/app-store/delegationCredential\", () => ({\n+  checkIfSuccessfullyConfiguredInWorkspace: vi.fn().mockResolvedValue(true),\n+}));\n+\n+vi.mock(\"@calcom/emails/integration-email-service\", () => ({\n+  sendDelegationCredentialDisabledEmail: vi.fn(),\n+}));\n+\n+vi.mock(\"./getAffectedMembersForDisable.handler\", () => ({\n+  getAffectedMembersForDisable: vi.fn().mockResolvedValue([]),\n+}));\n+\n+vi.mock(\"./utils\", () => ({\n+  ensureNoServiceAccountKey: vi.fn((credential) => credential),\n+}));\n+\n+describe(\"toggleDelegationCredentialEnabled - Security Fix\", () => {\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+  });\n+\n+  it(\"should prevent users without organizationId from accessing any credentials\", async () => {\n+    const userWithoutOrg = {\n+      id: 1,\n+      email: \"user@example.com\",\n+      organizationId: null,\n+    };\n+\n+    const input = {\n+      id: \"any-credential\",\n+      enabled: true,\n+    };\n+\n+    const mockCredential = {\n+      id: \"any-credential\",\n+      organizationId: 1,\n+      enabled: false,\n+      workspacePlatform: { slug: \"google\" },\n+    };\n+\n+    vi.mocked(DelegationCredentialRepository.findById).mockResolvedValue(mockCredential);\n+\n+    await expect(\n+      toggleDelegationCredentialEnabled(userWithoutOrg, input)\n+    ).rejects.toThrow(\"You must be part of an organization to toggle a delegation credential\");\n+\n+    expect(DelegationCredentialRepository.updateById).not.toHaveBeenCalled();\n+  });\n+\n+  it(\"should prevent cross-organization access\", async () => {\n+    const userFromOrg1 = {\n+      id: 1,\n+      email: \"user@org1.com\",\n+      organizationId: 1,\n+    };\n+\n+    const input = {\n+      id: \"org2-credential\",\n+      enabled: false,\n+    };\n+\n+    const org2Credential = {\n+      id: \"org2-credential\",\n+      organizationId: 2, // Different organization\n+      enabled: true,\n+      workspacePlatform: { slug: \"google\" },\n+    };\n+\n+    vi.mocked(DelegationCredentialRepository.findById).mockResolvedValue(org2Credential);\n+\n+    await expect(\n+      toggleDelegationCredentialEnabled(userFromOrg1, input)\n+    ).rejects.toThrow(\"Delegation credential not found\");\n+\n+    expect(DelegationCredentialRepository.updateById).not.toHaveBeenCalled();\n+  });\n+\n+  it(\"should allow same-organization access\", async () => {\n+    const userFromOrg1 = {\n+      id: 1,\n+      email: \"admin@org1.com\",\n+      organizationId: 1,\n+    };\n+\n+    const input = {\n+      id: \"org1-credential\",\n+      enabled: false,\n+    };\n+\n+    const org1Credential = {\n+      id: \"org1-credential\",\n+      organizationId: 1, // Same organization\n+      enabled: true,\n+      workspacePlatform: { slug: \"google\" },\n+    };\n+\n+    const updatedCredential = {\n+      ...org1Credential,\n+      enabled: false,\n+      lastDisabledAt: new Date(),\n+    };\n+\n+    vi.mocked(DelegationCredentialRepository.findById).mockResolvedValue(org1Credential);\n+    vi.mocked(DelegationCredentialRepository.updateById).mockResolvedValue(updatedCredential);\n+\n+    const result = await toggleDelegationCredentialEnabled(userFromOrg1, input);\n+\n+    expect(result).toEqual(updatedCredential);\n+    expect(DelegationCredentialRepository.updateById).toHaveBeenCalledWith({\n+      id: \"org1-credential\",\n+      data: {\n+        enabled: false,\n+        lastEnabledAt: undefined,\n+        lastDisabledAt: expect.any(Date),\n+      },\n+    });\n+  });\n+\n+  it(\"should handle nonexistent credentials\", async () => {\n+    const user = {\n+      id: 1,\n+      email: \"user@org1.com\",\n+      organizationId: 1,\n+    };\n+\n+    const input = {\n+      id: \"nonexistent-credential\",\n+      enabled: true,\n+    };\n+\n+    vi.mocked(DelegationCredentialRepository.findById).mockResolvedValue(null);\n+\n+    await expect(\n+      toggleDelegationCredentialEnabled(user, input)\n+    ).rejects.toThrow(\"Delegation credential not found\");\n+  });\n+});\n\\ No newline at end of file\ndiff --git a/packages/trpc/server/routers/viewer/delegationCredential/toggleEnabled.handler.ts b/packages/trpc/server/routers/viewer/delegationCredential/toggleEnabled.handler.ts\nindex a66712d4933896..a5b45b52cb6c3e 100644\n--- a/packages/trpc/server/routers/viewer/delegationCredential/toggleEnabled.handler.ts\n+++ b/packages/trpc/server/routers/viewer/delegationCredential/toggleEnabled.handler.ts\n@@ -53,6 +53,14 @@ export async function toggleDelegationCredentialEnabled(\n     throw new Error(\"Delegation credential not found\");\n   }\n \n+  if (!loggedInUser.organizationId) {\n+    throw new Error(\"You must be part of an organization to toggle a delegation credential\");\n+  }\n+\n+  if (currentDelegationCredential.organizationId !== loggedInUser.organizationId) {\n+    throw new Error(\"Delegation credential not found\");\n+  }\n+\n   const shouldBeEnabled = input.enabled;\n \n   if (shouldBeEnabled === currentDelegationCredential.enabled) {\n"}
{"instance_id": "calcom__cal.com.main.25323", "repo": "calcom/cal.com", "base_commit": "6499243a42c565c444b6b86f8c288413b5ac5a7c", "head_commit": "55c9bc490b83eb699c0761e16f451eaf5b6cea7e", "title": "fix: refactor handler for global apps", "merged_at": "2025-11-21T15:51:23Z", "html_url": "https://github.com/calcom/cal.com/pull/25323", "test_files": ["packages/app-store/utils.test.ts", "packages/trpc/server/routers/viewer/apps/appById.handler.test.ts"], "code_files": ["packages/app-store/utils.ts", "packages/trpc/server/routers/viewer/apps/appById.handler.ts"], "total_changes": 395, "num_files": 4, "pull_number": 25323, "patch": "diff --git a/packages/app-store/utils.test.ts b/packages/app-store/utils.test.ts\nnew file mode 100644\nindex 00000000000000..e2dd98931d15a0\n--- /dev/null\n+++ b/packages/app-store/utils.test.ts\n@@ -0,0 +1,140 @@\n+import { describe, it, expect } from \"vitest\";\n+\n+import type { App } from \"@calcom/types/App\";\n+import type { CredentialForCalendarService } from \"@calcom/types/Credential\";\n+\n+import { sanitizeAppForViewer } from \"./utils\";\n+import type { CredentialDataWithTeamName, LocationOption } from \"./utils\";\n+\n+describe(\"sanitizeAppForViewer\", () => {\n+  it(\"should remove key, credential, and credentials properties\", () => {\n+    const mockCredential: CredentialDataWithTeamName = {\n+      id: 1,\n+      type: \"daily_video\",\n+      key: { api_key: \"secret-api-key\" },\n+      userId: 1,\n+      user: { email: \"test@example.com\" },\n+      teamId: null,\n+      appId: \"daily-video\",\n+      invalid: false,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+      team: null,\n+    };\n+\n+    const mockApp: App & {\n+      credential: CredentialDataWithTeamName | null;\n+      credentials: CredentialDataWithTeamName[];\n+      locationOption: LocationOption | null;\n+    } = {\n+      type: \"daily_video\",\n+      name: \"Daily Video\",\n+      description: \"Video conferencing\",\n+      variant: \"conferencing\",\n+      slug: \"daily-video\",\n+      categories: [\"conferencing\"],\n+      logo: \"/logo.png\",\n+      publisher: \"Daily\",\n+      url: \"https://daily.co\",\n+      email: \"support@daily.co\",\n+      key: { api_key: \"secret-global-api-key\" },\n+      credential: mockCredential,\n+      credentials: [mockCredential],\n+      locationOption: {\n+        value: \"integrations:daily_video\",\n+        label: \"Daily Video\",\n+      },\n+    };\n+\n+    const sanitized = sanitizeAppForViewer(mockApp);\n+\n+    // Should not have key, credential, or credentials\n+    expect(sanitized).not.toHaveProperty(\"key\");\n+    expect(sanitized).not.toHaveProperty(\"credential\");\n+    expect(sanitized).not.toHaveProperty(\"credentials\");\n+\n+    // Should have all other properties\n+    expect(sanitized).toHaveProperty(\"type\", \"daily_video\");\n+    expect(sanitized).toHaveProperty(\"name\", \"Daily Video\");\n+    expect(sanitized).toHaveProperty(\"slug\", \"daily-video\");\n+    expect(sanitized).toHaveProperty(\"locationOption\");\n+    expect(sanitized.locationOption).toEqual({\n+      value: \"integrations:daily_video\",\n+      label: \"Daily Video\",\n+    });\n+  });\n+\n+  it(\"should handle apps without credential or credentials\", () => {\n+    const mockApp: App & {\n+      credential?: CredentialDataWithTeamName | null;\n+      credentials?: CredentialDataWithTeamName[];\n+      locationOption?: LocationOption | null;\n+    } = {\n+      type: \"zoom_video\",\n+      name: \"Zoom\",\n+      description: \"Video conferencing\",\n+      variant: \"conferencing\",\n+      slug: \"zoom\",\n+      categories: [\"conferencing\"],\n+      logo: \"/logo.png\",\n+      publisher: \"Zoom\",\n+      url: \"https://zoom.us\",\n+      email: \"support@zoom.us\",\n+      key: { api_key: \"secret-key\" },\n+    };\n+\n+    const sanitized = sanitizeAppForViewer(mockApp);\n+\n+    expect(sanitized).not.toHaveProperty(\"key\");\n+    expect(sanitized).not.toHaveProperty(\"credential\");\n+    expect(sanitized).not.toHaveProperty(\"credentials\");\n+    expect(sanitized).toHaveProperty(\"slug\", \"zoom\");\n+  });\n+\n+  it(\"should preserve all non-sensitive properties\", () => {\n+    const mockApp: App & {\n+      credential: CredentialDataWithTeamName | null;\n+      credentials: CredentialDataWithTeamName[];\n+      locationOption: LocationOption | null;\n+    } = {\n+      type: \"stripe_payment\",\n+      name: \"Stripe\",\n+      description: \"Payment processing\",\n+      variant: \"payment\",\n+      slug: \"stripe\",\n+      categories: [\"payment\"],\n+      logo: \"/logo.png\",\n+      publisher: \"Stripe\",\n+      url: \"https://stripe.com\",\n+      email: \"support@stripe.com\",\n+      verified: true,\n+      trending: true,\n+      rating: 4.5,\n+      reviews: 1000,\n+      isGlobal: false,\n+      key: { api_key: \"sk_live_secret\" },\n+      credential: null,\n+      credentials: [],\n+      locationOption: null,\n+      appData: {\n+        location: {\n+          type: \"integrations:stripe\",\n+          label: \"Stripe\",\n+          linkType: \"dynamic\",\n+        },\n+      },\n+    };\n+\n+    const sanitized = sanitizeAppForViewer(mockApp);\n+\n+    expect(sanitized).not.toHaveProperty(\"key\");\n+    expect(sanitized).not.toHaveProperty(\"credential\");\n+    expect(sanitized).not.toHaveProperty(\"credentials\");\n+    expect(sanitized.verified).toBe(true);\n+    expect(sanitized.trending).toBe(true);\n+    expect(sanitized.rating).toBe(4.5);\n+    expect(sanitized.reviews).toBe(1000);\n+    expect(sanitized.appData).toBeDefined();\n+  });\n+});\ndiff --git a/packages/app-store/utils.ts b/packages/app-store/utils.ts\nindex f0675f49958fbe..78a9b0a4f5906c 100644\n--- a/packages/app-store/utils.ts\n+++ b/packages/app-store/utils.ts\n@@ -57,7 +57,7 @@ function getApps(credentials: CredentialDataWithTeamName[], filterOnCredentials?\n       const credential = {\n         id: 0,\n         type: appMeta.type,\n-         \n+\n         key: appMeta.key!,\n         userId: 0,\n         user: { email: \"\" },\n@@ -174,4 +174,15 @@ export const defaultVideoAppCategories: AppCategories[] = [\n   \"video\",\n ];\n \n+export function sanitizeAppForViewer<\n+  T extends App & {\n+    credential?: CredentialDataWithTeamName | null;\n+    credentials?: CredentialDataWithTeamName[];\n+    locationOption?: LocationOption | null;\n+  }\n+>(app: T): Omit<T, \"key\" | \"credential\" | \"credentials\"> {\n+  const { key: _, credential: _1, credentials: _2, ...sanitizedApp } = app;\n+  return sanitizedApp;\n+}\n+\n export default getApps;\ndiff --git a/packages/trpc/server/routers/viewer/apps/appById.handler.test.ts b/packages/trpc/server/routers/viewer/apps/appById.handler.test.ts\nnew file mode 100644\nindex 00000000000000..29704af7fcd0d4\n--- /dev/null\n+++ b/packages/trpc/server/routers/viewer/apps/appById.handler.test.ts\n@@ -0,0 +1,235 @@\n+import { describe, it, expect, vi, beforeEach } from \"vitest\";\n+\n+import { TRPCError } from \"@trpc/server\";\n+\n+import type { CredentialForCalendarService } from \"@calcom/types/Credential\";\n+\n+import { appByIdHandler } from \"./appById.handler\";\n+import type { TAppByIdInputSchema } from \"./appById.schema\";\n+\n+// Mock the dependencies\n+vi.mock(\"@calcom/app-store/delegationCredential\", () => ({\n+  getUsersCredentialsIncludeServiceAccountKey: vi.fn(),\n+}));\n+\n+vi.mock(\"@calcom/app-store/utils\", () => ({\n+  default: vi.fn(),\n+  sanitizeAppForViewer: vi.fn((app) => {\n+    const { key: _, credential: _1, credentials: _2, ...sanitized } = app;\n+    return sanitized;\n+  }),\n+}));\n+\n+import { getUsersCredentialsIncludeServiceAccountKey } from \"@calcom/app-store/delegationCredential\";\n+import getApps, { sanitizeAppForViewer } from \"@calcom/app-store/utils\";\n+\n+import type { CredentialDataWithTeamName, LocationOption } from \"@calcom/app-store/utils\";\n+import type { App } from \"@calcom/types/App\";\n+\n+describe(\"appByIdHandler\", () => {\n+  const mockUser = {\n+    id: 1,\n+    email: \"test@example.com\",\n+    username: \"testuser\",\n+    name: \"Test User\",\n+  };\n+\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+  });\n+\n+  it(\"should not expose key field for globally installed apps\", async () => {\n+    const secretApiKey = \"secret-daily-api-key-12345\";\n+    const mockCredential: CredentialDataWithTeamName = {\n+      id: 0,\n+      type: \"daily_video\",\n+      key: { apikey: secretApiKey },\n+      userId: 0,\n+      user: { email: \"\" },\n+      teamId: null,\n+      appId: \"daily-video\",\n+      invalid: false,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+      team: {\n+        name: \"Default\",\n+      },\n+    };\n+\n+    const mockApp: App & {\n+      credential: CredentialDataWithTeamName | null;\n+      credentials: CredentialDataWithTeamName[];\n+      locationOption: LocationOption | null;\n+    } = {\n+      type: \"daily_video\",\n+      name: \"Cal Video\",\n+      description: \"Video conferencing\",\n+      variant: \"conferencing\",\n+      slug: \"daily-video\",\n+      categories: [\"conferencing\"],\n+      logo: \"icon.svg\",\n+      publisher: \"Cal.com\",\n+      url: \"https://daily.co\",\n+      email: \"help@cal.com\",\n+      isGlobal: true,\n+      // This is the sensitive key that should NOT be exposed\n+      key: { apikey: secretApiKey },\n+      credential: mockCredential,\n+      credentials: [mockCredential],\n+      locationOption: {\n+        value: \"integrations:daily\",\n+        label: \"Cal Video\",\n+      },\n+      appData: {\n+        location: {\n+          linkType: \"dynamic\",\n+          type: \"integrations:daily\",\n+          label: \"Cal Video\",\n+        },\n+      },\n+    };\n+\n+    vi.mocked(getUsersCredentialsIncludeServiceAccountKey).mockResolvedValue([]);\n+    vi.mocked(getApps).mockReturnValue([mockApp]);\n+\n+    const result = await appByIdHandler({\n+      ctx: { user: mockUser },\n+      input: { appId: \"daily-video\" } as TAppByIdInputSchema,\n+    });\n+\n+    // Verify that key is NOT in the response\n+    expect(result).not.toHaveProperty(\"key\");\n+    expect(result).not.toHaveProperty(\"credential\");\n+    expect(result).not.toHaveProperty(\"credentials\");\n+\n+    // Verify that other properties are preserved\n+    expect(result).toHaveProperty(\"slug\", \"daily-video\");\n+    expect(result).toHaveProperty(\"name\", \"Cal Video\");\n+    expect(result).toHaveProperty(\"isGlobal\", true);\n+    expect(result).toHaveProperty(\"locationOption\");\n+    expect(result).toHaveProperty(\"isInstalled\", 1);\n+\n+    // Verify sanitizeAppForViewer was called\n+    expect(sanitizeAppForViewer).toHaveBeenCalledWith(mockApp);\n+  });\n+\n+  it(\"should throw BAD_REQUEST when app is not found\", async () => {\n+    vi.mocked(getUsersCredentialsIncludeServiceAccountKey).mockResolvedValue([]);\n+    vi.mocked(getApps).mockReturnValue([]);\n+\n+    await expect(\n+      appByIdHandler({\n+        ctx: { user: mockUser },\n+        input: { appId: \"non-existent-app\" } as TAppByIdInputSchema,\n+      })\n+    ).rejects.toThrow(TRPCError);\n+\n+    await expect(\n+      appByIdHandler({\n+        ctx: { user: mockUser },\n+        input: { appId: \"non-existent-app\" } as TAppByIdInputSchema,\n+      })\n+    ).rejects.toThrow(\"Could not find app non-existent-app\");\n+  });\n+\n+  it(\"should preserve all non-sensitive properties\", async () => {\n+    const mockApp: App & {\n+      credential: CredentialDataWithTeamName | null;\n+      credentials: CredentialDataWithTeamName[];\n+      locationOption: LocationOption | null;\n+    } = {\n+      type: \"zoom_video\",\n+      name: \"Zoom\",\n+      description: \"Video conferencing\",\n+      variant: \"conferencing\",\n+      slug: \"zoom\",\n+      categories: [\"conferencing\"],\n+      logo: \"icon.svg\",\n+      publisher: \"Zoom\",\n+      url: \"https://zoom.us\",\n+      email: \"support@zoom.us\",\n+      isGlobal: false,\n+      verified: true,\n+      trending: true,\n+      rating: 4.5,\n+      reviews: 1000,\n+      key: { api_key: \"secret-zoom-key\" },\n+      credential: null,\n+      credentials: [],\n+      locationOption: null,\n+    };\n+\n+    vi.mocked(getUsersCredentialsIncludeServiceAccountKey).mockResolvedValue([]);\n+    vi.mocked(getApps).mockReturnValue([mockApp]);\n+\n+    const result = await appByIdHandler({\n+      ctx: { user: mockUser },\n+      input: { appId: \"zoom\" } as TAppByIdInputSchema,\n+    });\n+\n+    // Verify sensitive fields are removed\n+    expect(result).not.toHaveProperty(\"key\");\n+    expect(result).not.toHaveProperty(\"credential\");\n+    expect(result).not.toHaveProperty(\"credentials\");\n+\n+    // Verify non-sensitive fields are preserved\n+    expect(result).toHaveProperty(\"slug\", \"zoom\");\n+    expect(result).toHaveProperty(\"name\", \"Zoom\");\n+    expect(result).toHaveProperty(\"verified\", true);\n+    expect(result).toHaveProperty(\"trending\", true);\n+    expect(result).toHaveProperty(\"rating\", 4.5);\n+    expect(result).toHaveProperty(\"reviews\", 1000);\n+    expect(result).toHaveProperty(\"isInstalled\", 0);\n+  });\n+\n+  it(\"should correctly set isInstalled based on credentials length\", async () => {\n+    const mockCredential: CredentialDataWithTeamName = {\n+      id: 1,\n+      type: \"google_calendar\",\n+      key: { access_token: \"token\" },\n+      userId: 1,\n+      user: { email: \"test@example.com\" },\n+      teamId: null,\n+      appId: \"google-calendar\",\n+      invalid: false,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+      team: null,\n+    };\n+\n+    const mockApp: App & {\n+      credential: CredentialDataWithTeamName | null;\n+      credentials: CredentialDataWithTeamName[];\n+      locationOption: LocationOption | null;\n+    } = {\n+      type: \"google_calendar\",\n+      name: \"Google Calendar\",\n+      description: \"Calendar integration\",\n+      variant: \"calendar\",\n+      slug: \"google-calendar\",\n+      categories: [\"calendar\"],\n+      logo: \"icon.svg\",\n+      publisher: \"Google\",\n+      url: \"https://google.com\",\n+      email: \"support@google.com\",\n+      key: { api_key: \"secret-key\" },\n+      credential: mockCredential,\n+      credentials: [mockCredential],\n+      locationOption: null,\n+    };\n+\n+    vi.mocked(getUsersCredentialsIncludeServiceAccountKey).mockResolvedValue([]);\n+    vi.mocked(getApps).mockReturnValue([mockApp]);\n+\n+    const result = await appByIdHandler({\n+      ctx: { user: mockUser },\n+      input: { appId: \"google-calendar\" } as TAppByIdInputSchema,\n+    });\n+\n+    expect(result.isInstalled).toBe(1);\n+    expect(result).not.toHaveProperty(\"key\");\n+  });\n+});\n+\ndiff --git a/packages/trpc/server/routers/viewer/apps/appById.handler.ts b/packages/trpc/server/routers/viewer/apps/appById.handler.ts\nindex 3737db59cffd8f..bf14841871271d 100644\n--- a/packages/trpc/server/routers/viewer/apps/appById.handler.ts\n+++ b/packages/trpc/server/routers/viewer/apps/appById.handler.ts\n@@ -1,5 +1,5 @@\n import { getUsersCredentialsIncludeServiceAccountKey } from \"@calcom/app-store/delegationCredential\";\n-import getApps from \"@calcom/app-store/utils\";\n+import getApps, { sanitizeAppForViewer } from \"@calcom/app-store/utils\";\n import type { TrpcSessionUser } from \"@calcom/trpc/server/types\";\n \n import { TRPCError } from \"@trpc/server\";\n@@ -24,10 +24,9 @@ export const appByIdHandler = async ({ ctx, input }: AppByIdOptions) => {\n     throw new TRPCError({ code: \"BAD_REQUEST\", message: `Could not find app ${appId}` });\n   }\n \n-   \n-  const { credential: _, credentials: _1, ...app } = appFromDb;\n+  const safeApp = sanitizeAppForViewer(appFromDb);\n   return {\n     isInstalled: appFromDb.credentials.length,\n-    ...app,\n+    ...safeApp,\n   };\n };\n"}
{"instance_id": "calcom__cal.com.main.25321", "repo": "calcom/cal.com", "base_commit": "6499243a42c565c444b6b86f8c288413b5ac5a7c", "head_commit": "16f3ebdb0f536d2707b70e60c44df84bf4906f6a", "title": "fix: Remove hosts - verify event type belongs to event type", "merged_at": "2025-11-21T15:26:23Z", "html_url": "https://github.com/calcom/cal.com/pull/25321", "test_files": ["packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.test.ts"], "code_files": ["packages/features/membership/repositories/MembershipRepository.ts", "packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts"], "total_changes": 376, "num_files": 3, "pull_number": 25321, "patch": "diff --git a/packages/features/membership/repositories/MembershipRepository.ts b/packages/features/membership/repositories/MembershipRepository.ts\nindex b016ea5bec2190..2975224066f362 100644\n--- a/packages/features/membership/repositories/MembershipRepository.ts\n+++ b/packages/features/membership/repositories/MembershipRepository.ts\n@@ -134,6 +134,22 @@ export class MembershipRepository {\n     });\n   }\n \n+  static async findAcceptedMembershipsByUserIdsInTeam({\n+    userIds,\n+    teamId,\n+  }: {\n+    userIds: number[];\n+    teamId: number;\n+  }) {\n+    return prisma.membership.findMany({\n+      where: {\n+        userId: { in: userIds },\n+        accepted: true,\n+        teamId,\n+      },\n+    });\n+  }\n+\n   static async createMany(data: IMembership[]) {\n     return await prisma.membership.createMany({\n       data: data.map((item) => ({\ndiff --git a/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.test.ts b/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.test.ts\nnew file mode 100644\nindex 00000000000000..b7c5c85e07394e\n--- /dev/null\n+++ b/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.test.ts\n@@ -0,0 +1,346 @@\n+/* eslint-disable @typescript-eslint/no-explicit-any */\n+import { describe, it, beforeEach, vi, expect } from \"vitest\";\n+\n+import { MembershipRepository } from \"@calcom/features/membership/repositories/MembershipRepository\";\n+import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\n+import prisma from \"@calcom/prisma\";\n+\n+import type { TrpcSessionUser } from \"../../../types\";\n+import removeHostsFromEventTypesHandler from \"./removeHostsFromEventTypes.handler\";\n+\n+vi.mock(\"@calcom/prisma\", () => ({\n+  default: {\n+    host: {\n+      deleteMany: vi.fn(),\n+    },\n+  },\n+}));\n+\n+vi.mock(\"@calcom/features/pbac/services/permission-check.service\", () => ({\n+  PermissionCheckService: vi.fn(),\n+}));\n+\n+vi.mock(\"@calcom/features/membership/repositories/MembershipRepository\", () => ({\n+  MembershipRepository: {\n+    findAcceptedMembershipsByUserIdsInTeam: vi.fn(),\n+  },\n+}));\n+\n+describe(\"removeHostsFromEventTypesHandler\", () => {\n+  const mockUser = {\n+    id: 1,\n+    name: \"Test User\",\n+  } as NonNullable<TrpcSessionUser>;\n+\n+  const mockInput = {\n+    userIds: [101, 102],\n+    eventTypeIds: [201, 202],\n+    teamId: 300,\n+  };\n+\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+  });\n+\n+  it(\"throws UNAUTHORIZED if user does not have eventType.update permission\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(false);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    await expect(\n+      removeHostsFromEventTypesHandler({\n+        ctx: { user: mockUser },\n+        input: mockInput,\n+      })\n+    ).rejects.toMatchObject({\n+      code: \"UNAUTHORIZED\",\n+    });\n+\n+    expect(mockCheckPermission).toHaveBeenCalledWith({\n+      userId: mockUser.id,\n+      teamId: mockInput.teamId,\n+      permission: \"eventType.update\",\n+      fallbackRoles: [\"OWNER\", \"ADMIN\"],\n+    });\n+\n+    expect(MembershipRepository.findAcceptedMembershipsByUserIdsInTeam).not.toHaveBeenCalled();\n+    expect(prisma.host.deleteMany).not.toHaveBeenCalled();\n+  });\n+\n+  it(\"deletes hosts when user has permission and all users are team members\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Mock that all userIds are valid team members\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 101 },\n+      { userId: 102 },\n+    ]);\n+\n+    const mockDeleteResult = { count: 3 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: mockInput,\n+    });\n+\n+    expect(result).toEqual(mockDeleteResult);\n+\n+    expect(mockCheckPermission).toHaveBeenCalledWith({\n+      userId: mockUser.id,\n+      teamId: mockInput.teamId,\n+      permission: \"eventType.update\",\n+      fallbackRoles: [\"OWNER\", \"ADMIN\"],\n+    });\n+\n+    expect(MembershipRepository.findAcceptedMembershipsByUserIdsInTeam).toHaveBeenCalledWith({\n+      userIds: mockInput.userIds,\n+      teamId: mockInput.teamId,\n+    });\n+\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: mockInput.eventTypeIds,\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: mockInput.userIds,\n+        },\n+      },\n+    });\n+  });\n+\n+  it(\"only removes hosts for userIds that are team members (filters out non-members)\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Mock that only userId 101 is a team member, 102 is not\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 101 },\n+    ]);\n+\n+    const mockDeleteResult = { count: 1 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: mockInput,\n+    });\n+\n+    expect(result).toEqual(mockDeleteResult);\n+\n+    expect(MembershipRepository.findAcceptedMembershipsByUserIdsInTeam).toHaveBeenCalledWith({\n+      userIds: mockInput.userIds,\n+      teamId: mockInput.teamId,\n+    });\n+\n+    // Should only delete for userId 101, not 102\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: mockInput.eventTypeIds,\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: [101], // Only 101, not 102\n+        },\n+      },\n+    });\n+  });\n+\n+  it(\"handles empty userIds array\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Empty array means no memberships to validate\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([]);\n+\n+    const mockDeleteResult = { count: 0 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const emptyUsersInput = {\n+      ...mockInput,\n+      userIds: [],\n+    };\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: emptyUsersInput,\n+    });\n+\n+    expect(result).toEqual(mockDeleteResult);\n+\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: mockInput.eventTypeIds,\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: [],\n+        },\n+      },\n+    });\n+  });\n+\n+  it(\"handles empty eventTypeIds array\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Mock that all userIds are valid team members\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 101 },\n+      { userId: 102 },\n+    ]);\n+\n+    const mockDeleteResult = { count: 0 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const emptyEventTypesInput = {\n+      ...mockInput,\n+      eventTypeIds: [],\n+    };\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: emptyEventTypesInput,\n+    });\n+\n+    expect(result).toEqual(mockDeleteResult);\n+\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: [],\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: mockInput.userIds,\n+        },\n+      },\n+    });\n+  });\n+\n+  it(\"returns count of 0 when no hosts match the criteria\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Mock that all userIds are valid team members\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 101 },\n+      { userId: 102 },\n+    ]);\n+\n+    const mockDeleteResult = { count: 0 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: mockInput,\n+    });\n+\n+    expect(result.count).toBe(0);\n+  });\n+\n+  it(\"returns count of 0 when userId is a team member but not a host on the specified event types\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // User 999 is a valid team member\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 999 },\n+    ]);\n+\n+    // But they're not a host on any of the event types\n+    const mockDeleteResult = { count: 0 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const nonHostInput = {\n+      ...mockInput,\n+      userIds: [999],\n+    };\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: nonHostInput,\n+    });\n+\n+    expect(result.count).toBe(0);\n+\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: mockInput.eventTypeIds,\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: [999],\n+        },\n+      },\n+    });\n+  });\n+\n+  it(\"returns count of 0 when event types do not belong to the specified team\", async () => {\n+    const mockCheckPermission = vi.fn().mockResolvedValue(true);\n+    (PermissionCheckService as any).mockImplementation(() => ({\n+      checkPermission: mockCheckPermission,\n+    }));\n+\n+    // Mock that all userIds are valid team members\n+    (MembershipRepository.findAcceptedMembershipsByUserIdsInTeam as any).mockResolvedValue([\n+      { userId: 101 },\n+      { userId: 102 },\n+    ]);\n+\n+    // Event types belong to a different team, so no hosts should be deleted\n+    const mockDeleteResult = { count: 0 };\n+    (prisma.host.deleteMany as any).mockResolvedValue(mockDeleteResult);\n+\n+    const result = await removeHostsFromEventTypesHandler({\n+      ctx: { user: mockUser },\n+      input: mockInput,\n+    });\n+\n+    expect(result.count).toBe(0);\n+\n+    // Verify the query includes the teamId check\n+    expect(prisma.host.deleteMany).toHaveBeenCalledWith({\n+      where: {\n+        eventTypeId: {\n+          in: mockInput.eventTypeIds,\n+        },\n+        eventType: {\n+          teamId: mockInput.teamId,\n+        },\n+        userId: {\n+          in: mockInput.userIds,\n+        },\n+      },\n+    });\n+  });\n+});\ndiff --git a/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts b/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts\nindex e819766fee8d44..ba0a7add791387 100644\n--- a/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts\n+++ b/packages/trpc/server/routers/viewer/teams/removeHostsFromEventTypes.handler.ts\n@@ -1,3 +1,4 @@\n+import { MembershipRepository } from \"@calcom/features/membership/repositories/MembershipRepository\";\n import { PermissionCheckService } from \"@calcom/features/pbac/services/permission-check.service\";\n import prisma from \"@calcom/prisma\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n@@ -28,13 +29,24 @@ export async function removeHostsFromEventTypesHandler({ ctx, input }: RemoveHos\n   // check if user has permission to update event types\n   if (!hasEventTypeUpdatePermission) throw new TRPCError({ code: \"UNAUTHORIZED\" });\n \n+  // verify that all userIds are members of the team\n+  const teamMemberIds = await MembershipRepository.findAcceptedMembershipsByUserIdsInTeam({\n+    userIds,\n+    teamId,\n+  });\n+\n+  const filteredUserIds = teamMemberIds.map((teamMember) => teamMember.userId);\n+\n   return await prisma.host.deleteMany({\n     where: {\n       eventTypeId: {\n         in: eventTypeIds,\n       },\n+      eventType: {\n+        teamId: teamId,\n+      },\n       userId: {\n-        in: userIds,\n+        in: filteredUserIds,\n       },\n     },\n   });\n"}
{"instance_id": "calcom__cal.com.main.25315", "repo": "calcom/cal.com", "base_commit": "6499243a42c565c444b6b86f8c288413b5ac5a7c", "head_commit": "db5d90c3b1833000f3e7e80b4d1b1d76471603c5", "title": "fix: access service class for editLocationHandler", "merged_at": "2025-11-21T16:13:06Z", "html_url": "https://github.com/calcom/cal.com/pull/25315", "test_files": ["packages/features/credentials/services/CredentialAccessService.test.ts"], "code_files": ["packages/features/credentials/services/CredentialAccessService.ts", "packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts"], "total_changes": 468, "num_files": 3, "pull_number": 25315, "patch": "diff --git a/packages/features/credentials/services/CredentialAccessService.test.ts b/packages/features/credentials/services/CredentialAccessService.test.ts\nnew file mode 100644\nindex 00000000000000..69852b0d4e31aa\n--- /dev/null\n+++ b/packages/features/credentials/services/CredentialAccessService.test.ts\n@@ -0,0 +1,320 @@\n+import { describe, expect, test, vi, beforeEach } from \"vitest\";\n+\n+import { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\n+import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n+import { HttpError } from \"@calcom/lib/http-error\";\n+import { prisma } from \"@calcom/prisma\";\n+\n+import { CredentialAccessService } from \"./CredentialAccessService\";\n+\n+vi.mock(\"@calcom/prisma\", () => {\n+  return {\n+    prisma: {\n+      user: {\n+        findUnique: vi.fn(),\n+      },\n+    },\n+  };\n+});\n+\n+vi.mock(\"@calcom/features/credentials/repositories/CredentialRepository\", () => {\n+  return {\n+    CredentialRepository: {\n+      findFirstByIdWithKeyAndUser: vi.fn(),\n+    },\n+  };\n+});\n+\n+vi.mock(\"@calcom/features/users/repositories/UserRepository\", () => {\n+  return {\n+    UserRepository: vi.fn().mockImplementation(() => ({\n+      getUserOrganizationAndTeams: vi.fn(),\n+    })),\n+  };\n+});\n+\n+describe(\"CredentialAccessService\", () => {\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+  });\n+\n+  test(\"should allow access when credential belongs to logged-in user\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: loggedInUserId,\n+      teamId: null,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: { email: \"user@example.com\" },\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+\n+  test(\"should allow access when credential belongs to booking owner\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: bookingOwnerId,\n+      teamId: null,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: { email: \"owner@example.com\" },\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+\n+  test(\"should allow access when credential belongs to team the logged-in user belongs to\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+    const teamId = 50;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: null,\n+      teamId: teamId,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: null,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const mockUserRepo = {\n+      getUserOrganizationAndTeams: vi.fn().mockResolvedValue({\n+        organizationId: null,\n+        teams: [{ teamId: teamId }],\n+      }),\n+    };\n+\n+    vi.mocked(UserRepository).mockImplementation(() => mockUserRepo as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+\n+  test(\"should allow access when credential belongs to team the booking owner belongs to\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+    const teamId = 50;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: null,\n+      teamId: teamId,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: null,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const mockUserRepo = {\n+      getUserOrganizationAndTeams: vi\n+        .fn()\n+        .mockResolvedValueOnce({\n+          organizationId: null,\n+          teams: [],\n+        })\n+        .mockResolvedValueOnce({\n+          organizationId: null,\n+          teams: [{ teamId: teamId }],\n+        }),\n+    };\n+\n+    vi.mocked(UserRepository).mockImplementation(() => mockUserRepo as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+\n+  test(\"should allow access when credential belongs to organization the logged-in user belongs to\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+    const orgId = 50;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: null,\n+      teamId: orgId,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: null,\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const mockUserRepo = {\n+      getUserOrganizationAndTeams: vi.fn().mockResolvedValue({\n+        organizationId: orgId,\n+        teams: [],\n+      }),\n+    };\n+\n+    vi.mocked(UserRepository).mockImplementation(() => mockUserRepo as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+\n+  test(\"should throw NOT_FOUND when credential does not exist\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue(null);\n+\n+    const service = new CredentialAccessService();\n+    const error = await service\n+      .ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+      .catch((e) => e);\n+\n+    expect(error).toBeInstanceOf(HttpError);\n+    expect(error.statusCode).toBe(404);\n+    expect(error.message).toBe(\"Credential not found\");\n+  });\n+\n+  test(\"should throw FORBIDDEN when credential is not accessible\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = 200;\n+    const otherUserId = 300;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: otherUserId,\n+      teamId: null,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: { email: \"other@example.com\" },\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const mockUserRepo = {\n+      getUserOrganizationAndTeams: vi\n+        .fn()\n+        .mockResolvedValueOnce({\n+          organizationId: null,\n+          teams: [],\n+        })\n+        .mockResolvedValueOnce({\n+          organizationId: null,\n+          teams: [],\n+        }),\n+    };\n+\n+    vi.mocked(UserRepository).mockImplementation(() => mockUserRepo as any);\n+\n+    const service = new CredentialAccessService();\n+    const error = await service\n+      .ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+      .catch((e) => e);\n+\n+    expect(error).toBeInstanceOf(HttpError);\n+    expect(error.statusCode).toBe(403);\n+    expect(error.message).toBe(\"You do not have access to this credential\");\n+  });\n+\n+  test(\"should handle null bookingOwnerId\", async () => {\n+    const credentialId = 1;\n+    const loggedInUserId = 100;\n+    const bookingOwnerId = null;\n+\n+    vi.mocked(CredentialRepository.findFirstByIdWithKeyAndUser).mockResolvedValue({\n+      id: credentialId,\n+      userId: loggedInUserId,\n+      teamId: null,\n+      type: \"zoom_video\",\n+      appId: \"zoom\",\n+      key: {},\n+      invalid: false,\n+      user: { email: \"user@example.com\" },\n+      delegatedTo: null,\n+      delegatedToId: null,\n+      delegationCredentialId: null,\n+    } as any);\n+\n+    const service = new CredentialAccessService();\n+    await expect(\n+      service.ensureAccessible({\n+        credentialId,\n+        loggedInUserId,\n+        bookingOwnerId,\n+      })\n+    ).resolves.not.toThrow();\n+  });\n+});\ndiff --git a/packages/features/credentials/services/CredentialAccessService.ts b/packages/features/credentials/services/CredentialAccessService.ts\nnew file mode 100644\nindex 00000000000000..8b4c21d83f2999\n--- /dev/null\n+++ b/packages/features/credentials/services/CredentialAccessService.ts\n@@ -0,0 +1,130 @@\n+import { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\n+import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n+import { HttpError } from \"@calcom/lib/http-error\";\n+import type { PrismaClient } from \"@calcom/prisma\";\n+import { prisma } from \"@calcom/prisma\";\n+\n+type CredentialAccessInput = {\n+  credentialId: number;\n+  loggedInUserId: number;\n+  bookingOwnerId: number | null;\n+};\n+\n+type UserTeamsData = {\n+  organizationId: number | null;\n+  teams: Array<{ teamId: number }>;\n+} | null;\n+\n+export class CredentialAccessService {\n+  private readonly userRepository: UserRepository;\n+\n+  constructor(private readonly prismaClient: PrismaClient = prisma) {\n+    this.userRepository = new UserRepository(this.prismaClient);\n+  }\n+\n+  /**\n+   * Ensures that a credential is accessible by the logged-in user or booking owner.\n+   */\n+  async ensureAccessible(input: CredentialAccessInput): Promise<void> {\n+    const credential = await this.checkCredentialExists(input.credentialId);\n+\n+    if (this.checkUserOwnership(credential, input.loggedInUserId)) {\n+      return;\n+    }\n+\n+    if (this.checkBookingOwnerOwnership(credential, input.bookingOwnerId)) {\n+      return;\n+    }\n+\n+    await this.checkTeamAccess(credential, input.loggedInUserId, input.bookingOwnerId);\n+  }\n+\n+  private async checkCredentialExists(credentialId: number) {\n+    const credential = await CredentialRepository.findFirstByIdWithKeyAndUser({\n+      id: credentialId,\n+    });\n+\n+    if (!credential) {\n+      throw new HttpError({\n+        statusCode: 404,\n+        message: \"Credential not found\",\n+      });\n+    }\n+\n+    return credential;\n+  }\n+\n+  private checkUserOwnership(\n+    credential: Awaited<ReturnType<typeof CredentialRepository.findFirstByIdWithKeyAndUser>>,\n+    loggedInUserId: number\n+  ): boolean {\n+    return credential?.userId === loggedInUserId;\n+  }\n+\n+  private checkBookingOwnerOwnership(\n+    credential: Awaited<ReturnType<typeof CredentialRepository.findFirstByIdWithKeyAndUser>>,\n+    bookingOwnerId: number | null\n+  ): boolean {\n+    return bookingOwnerId !== null && credential?.userId === bookingOwnerId;\n+  }\n+\n+  private async checkTeamAccess(\n+    credential: NonNullable<Awaited<ReturnType<typeof CredentialRepository.findFirstByIdWithKeyAndUser>>>,\n+    loggedInUserId: number,\n+    bookingOwnerId: number | null\n+  ): Promise<void> {\n+    if (!credential.teamId) {\n+      this.throwForbiddenError();\n+    }\n+\n+    const [loggedInUserTeams, bookingOwnerTeams] = await this.getUserTeamsData(\n+      loggedInUserId,\n+      bookingOwnerId\n+    );\n+\n+    if (this.hasTeamAccess(credential.teamId, loggedInUserTeams)) {\n+      return;\n+    }\n+\n+    if (this.hasTeamAccess(credential.teamId, bookingOwnerTeams)) {\n+      return;\n+    }\n+\n+    this.throwForbiddenError();\n+  }\n+\n+  private async getUserTeamsData(\n+    loggedInUserId: number,\n+    bookingOwnerId: number | null\n+  ): Promise<[UserTeamsData, UserTeamsData]> {\n+    return Promise.all([\n+      this.userRepository.getUserOrganizationAndTeams({ userId: loggedInUserId }),\n+      bookingOwnerId\n+        ? this.userRepository.getUserOrganizationAndTeams({ userId: bookingOwnerId })\n+        : Promise.resolve(null),\n+    ]);\n+  }\n+\n+  private hasTeamAccess(teamId: number, userTeams: UserTeamsData): boolean {\n+    if (!userTeams) {\n+      return false;\n+    }\n+\n+    const teamIds = this.getTeamIdsForUser(userTeams);\n+    return teamIds.includes(teamId);\n+  }\n+\n+  private getTeamIdsForUser(userTeams: NonNullable<UserTeamsData>): number[] {\n+    return [\n+      ...(userTeams.organizationId ? [userTeams.organizationId] : []),\n+      ...(userTeams.teams || []).map((t) => t.teamId),\n+    ];\n+  }\n+\n+  private throwForbiddenError(): never {\n+    throw new HttpError({\n+      statusCode: 403,\n+      message: \"You do not have access to this credential\",\n+    });\n+  }\n+}\ndiff --git a/packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts b/packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts\nindex 52f840d0953e60..203947232ac773 100644\n--- a/packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts\n+++ b/packages/trpc/server/routers/viewer/bookings/editLocation.handler.ts\n@@ -7,6 +7,7 @@ import { sendLocationChangeEmailsAndSMS } from \"@calcom/emails/email-manager\";\n import EventManager from \"@calcom/features/bookings/lib/EventManager\";\n import { BookingRepository } from \"@calcom/features/bookings/repositories/BookingRepository\";\n import { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\n+import { CredentialAccessService } from \"@calcom/features/credentials/services/CredentialAccessService\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n import { getVideoCallUrlFromCalEvent } from \"@calcom/lib/CalEventParser\";\n import { buildCalEventFromBooking } from \"@calcom/lib/buildCalEventFromBooking\";\n@@ -125,15 +126,26 @@ async function updateBookingLocationInDb({\n async function getAllCredentialsIncludeServiceAccountKey({\n   user,\n   conferenceCredentialId,\n+  bookingOwnerId,\n }: {\n   user: { id: number; email: string };\n   conferenceCredentialId: number | null;\n+  bookingOwnerId: number | null;\n }) {\n   const credentials = await getUsersCredentialsIncludeServiceAccountKey(user);\n \n   let conferenceCredential;\n \n   if (conferenceCredentialId) {\n+    // Validate that the credential is accessible before fetching it\n+    const credentialAccessService = new CredentialAccessService();\n+    await credentialAccessService.ensureAccessible({\n+      credentialId: conferenceCredentialId,\n+      loggedInUserId: user.id,\n+      bookingOwnerId,\n+    });\n+\n+    // Now fetch the credential with the key\n     conferenceCredential = await CredentialRepository.findFirstByIdWithKeyAndUser({\n       id: conferenceCredentialId,\n     });\n@@ -266,7 +278,11 @@ export async function editLocationHandler({ ctx, input }: EditLocationOptions) {\n \n   const eventManager = new EventManager({\n     ...ctx.user,\n-    credentials: await getAllCredentialsIncludeServiceAccountKey({ user: ctx.user, conferenceCredentialId }),\n+    credentials: await getAllCredentialsIncludeServiceAccountKey({\n+      user: ctx.user,\n+      conferenceCredentialId,\n+      bookingOwnerId: booking.userId,\n+    }),\n   });\n \n   const updatedResult = await updateLocationInConnectedAppForBooking({\n"}
{"instance_id": "calcom__cal.com.main.25314", "repo": "calcom/cal.com", "base_commit": "3c8215add3f250b44d98700795dc40ade280ecbb", "head_commit": "c0ab1158758952723701d467a4036898fb99d1cd", "title": "fix: Improve add users to org", "merged_at": "2025-11-21T15:18:41Z", "html_url": "https://github.com/calcom/cal.com/pull/25314", "test_files": ["packages/features/ee/dsync/lib/handleUserEvents.test.ts"], "code_files": ["packages/features/ee/dsync/lib/handleUserEvents.ts"], "total_changes": 436, "num_files": 2, "pull_number": 25314, "patch": "diff --git a/packages/features/ee/dsync/lib/handleUserEvents.test.ts b/packages/features/ee/dsync/lib/handleUserEvents.test.ts\nnew file mode 100644\nindex 00000000000000..fd4cf4eae5421b\n--- /dev/null\n+++ b/packages/features/ee/dsync/lib/handleUserEvents.test.ts\n@@ -0,0 +1,433 @@\n+import prismock from \"../../../../../tests/libs/__mocks__/prisma\";\n+\n+import type { DirectorySyncEvent } from \"@boxyhq/saml-jackson\";\n+import { describe, expect, it, vi, beforeEach } from \"vitest\";\n+\n+import { IdentityProvider, MembershipRole } from \"@calcom/prisma/enums\";\n+\n+import handleUserEvents from \"./handleUserEvents\";\n+\n+vi.mock(\"@calcom/lib/logger\", () => ({\n+  default: {\n+    getSubLogger: () => ({\n+      debug: vi.fn(),\n+      error: vi.fn(),\n+      warn: vi.fn(),\n+    }),\n+  },\n+}));\n+\n+vi.mock(\"@calcom/lib/server/i18n\", () => ({\n+  getTranslation: vi.fn().mockResolvedValue((key: string) => key),\n+}));\n+\n+vi.mock(\"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\", () => ({\n+  getTeamOrThrow: vi.fn(),\n+  sendExistingUserTeamInviteEmails: vi.fn(),\n+  sendSignupToOrganizationEmail: vi.fn(),\n+}));\n+\n+vi.mock(\"./assignValueToUser\", () => ({\n+  assignValueToUserInOrgBulk: vi.fn(),\n+}));\n+\n+vi.mock(\"./users/createUsersAndConnectToOrg\", () => ({\n+  default: vi.fn(),\n+}));\n+\n+vi.mock(\"./users/inviteExistingUserToOrg\", () => ({\n+  default: vi.fn().mockResolvedValue({\n+    id: 1,\n+    username: \"testuser\",\n+    email: \"test@example.com\",\n+  }),\n+}));\n+\n+vi.mock(\"./removeUserFromOrg\", () => ({\n+  default: vi.fn(),\n+}));\n+\n+vi.mock(\"@calcom/features/users/repositories/UserRepository\", () => ({\n+  UserRepository: vi.fn().mockImplementation(() => ({\n+    isAMemberOfOrganization: vi.fn().mockResolvedValue(false),\n+  })),\n+}));\n+\n+async function createMockOrganization({ id, name, slug }: { id: number; name: string; slug: string }) {\n+  return prismock.team.create({\n+    data: {\n+      id,\n+      name,\n+      slug,\n+      isOrganization: true,\n+    },\n+  });\n+}\n+\n+async function createMockUser({ email, organizationId }: { email: string; organizationId: number | null }) {\n+  return prismock.user.create({\n+    data: {\n+      email,\n+      username: email.split(\"@\")[0],\n+      organizationId,\n+      completedOnboarding: true,\n+      identityProvider: IdentityProvider.CAL,\n+      locale: \"en\",\n+    },\n+  });\n+}\n+\n+async function createMockMembership({\n+  userId,\n+  teamId,\n+  role = MembershipRole.MEMBER,\n+}: {\n+  userId: number;\n+  teamId: number;\n+  role?: MembershipRole;\n+}) {\n+  return prismock.membership.create({\n+    data: {\n+      userId,\n+      teamId,\n+      role,\n+      accepted: true,\n+      disableImpersonation: false,\n+    },\n+  });\n+}\n+\n+describe(\"handleUserEvents\", () => {\n+  const directoryId = \"test-directory-id\";\n+  const organizationId = 1001;\n+  const organizationName = \"Test Organization\";\n+  const organizationSlug = \"test-org\";\n+\n+  beforeEach(async () => {\n+    vi.clearAllMocks();\n+\n+    await createMockOrganization({\n+      id: organizationId,\n+      name: organizationName,\n+      slug: organizationSlug,\n+    });\n+\n+    const { getTeamOrThrow } = await import(\"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\");\n+    vi.mocked(getTeamOrThrow).mockResolvedValue({\n+      id: organizationId,\n+      name: organizationName,\n+      slug: organizationSlug,\n+      isOrganization: true,\n+      parent: null,\n+      parentId: null,\n+      metadata: null,\n+    } as Awaited<ReturnType<typeof getTeamOrThrow>>);\n+  });\n+\n+  describe(\"Cross-tenant hijack prevention\", () => {\n+    it(\"should throw an error when user belongs to a different organization\", async () => {\n+      const userEmail = \"user@example.com\";\n+      const differentOrgId = 2002;\n+\n+      await createMockOrganization({\n+        id: differentOrgId,\n+        name: \"Different Organization\",\n+        slug: \"different-org\",\n+      });\n+\n+      await createMockUser({\n+        email: userEmail,\n+        organizationId: 9999,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.created\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      await expect(handleUserEvents(event, organizationId)).rejects.toThrow(\n+        \"User belongs to another organization.\"\n+      );\n+    });\n+\n+    it(\"should succeed when user belongs to the correct organization\", async () => {\n+      const userEmail = \"user@example.com\";\n+\n+      const user = await createMockUser({\n+        email: userEmail,\n+        organizationId: organizationId,\n+      });\n+\n+      await createMockMembership({\n+        userId: user.id,\n+        teamId: organizationId,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.created\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      const { UserRepository } = await import(\"@calcom/features/users/repositories/UserRepository\");\n+      vi.mocked(UserRepository).mockImplementation(\n+        () =>\n+          ({\n+            isAMemberOfOrganization: vi.fn().mockResolvedValue(true),\n+          } as unknown as InstanceType<typeof UserRepository>)\n+      );\n+\n+      await expect(handleUserEvents(event, organizationId)).resolves.not.toThrow();\n+    });\n+\n+    it(\"should pass when user has no organizationId (allow existing user to be added to an org)\", async () => {\n+      const userEmail = \"legacy@example.com\";\n+\n+      await createMockUser({\n+        email: userEmail,\n+        organizationId: null,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.created\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Legacy\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      await expect(handleUserEvents(event, organizationId)).resolves.toBeUndefined();\n+    });\n+\n+    it(\"should succeed when user does not exist yet (new user creation)\", async () => {\n+      const userEmail = \"newuser@example.com\";\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.created\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"New\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      const createUsersAndConnectToOrg = (await import(\"./users/createUsersAndConnectToOrg\")).default;\n+      vi.mocked(createUsersAndConnectToOrg).mockResolvedValue(undefined);\n+\n+      await expect(handleUserEvents(event, organizationId)).resolves.not.toThrow();\n+\n+      expect(createUsersAndConnectToOrg).toHaveBeenCalledWith({\n+        createUsersAndConnectToOrgProps: {\n+          emailsToCreate: [userEmail],\n+          identityProvider: IdentityProvider.CAL,\n+          identityProviderId: null,\n+        },\n+        org: expect.objectContaining({\n+          id: organizationId,\n+          name: organizationName,\n+        }),\n+      });\n+    });\n+  });\n+\n+  describe(\"User activation and deactivation\", () => {\n+    it(\"should invite existing user when active is true and user is not a member\", async () => {\n+      const userEmail = \"user@example.com\";\n+\n+      await createMockUser({\n+        email: userEmail,\n+        organizationId: organizationId,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.updated\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      const { UserRepository } = await import(\"@calcom/features/users/repositories/UserRepository\");\n+      vi.mocked(UserRepository).mockImplementation(\n+        () =>\n+          ({\n+            isAMemberOfOrganization: vi.fn().mockResolvedValue(false),\n+          } as unknown as InstanceType<typeof UserRepository>)\n+      );\n+\n+      const inviteExistingUserToOrg = (await import(\"./users/inviteExistingUserToOrg\")).default;\n+      const sendExistingUserTeamInviteEmails = (\n+        await import(\"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\")\n+      ).sendExistingUserTeamInviteEmails;\n+\n+      await handleUserEvents(event, organizationId);\n+\n+      expect(inviteExistingUserToOrg).toHaveBeenCalled();\n+      expect(sendExistingUserTeamInviteEmails).toHaveBeenCalled();\n+    });\n+\n+    it(\"should remove user from organization when active is false\", async () => {\n+      const userEmail = \"user@example.com\";\n+\n+      const user = await createMockUser({\n+        email: userEmail,\n+        organizationId: organizationId,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.updated\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: false,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      const removeUserFromOrg = (await import(\"./removeUserFromOrg\")).default;\n+\n+      await handleUserEvents(event, organizationId);\n+\n+      expect(removeUserFromOrg).toHaveBeenCalledWith({\n+        userId: user.id,\n+        orgId: organizationId,\n+      });\n+    });\n+\n+    it(\"should sync custom attributes when user is already a member and active\", async () => {\n+      const userEmail = \"user@example.com\";\n+\n+      const user = await createMockUser({\n+        email: userEmail,\n+        organizationId: organizationId,\n+      });\n+\n+      await createMockMembership({\n+        userId: user.id,\n+        teamId: organizationId,\n+      });\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.updated\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [\"custom:enterprise\"],\n+            \"custom:enterprise\": {\n+              department: \"Engineering\",\n+            },\n+          },\n+        },\n+      };\n+\n+      const { UserRepository } = await import(\"@calcom/features/users/repositories/UserRepository\");\n+      vi.mocked(UserRepository).mockImplementation(\n+        () =>\n+          ({\n+            isAMemberOfOrganization: vi.fn().mockResolvedValue(true),\n+          } as unknown as InstanceType<typeof UserRepository>)\n+      );\n+\n+      const { assignValueToUserInOrgBulk } = await import(\"./assignValueToUser\");\n+\n+      await handleUserEvents(event, organizationId);\n+\n+      expect(assignValueToUserInOrgBulk).toHaveBeenCalledWith({\n+        orgId: organizationId,\n+        userId: user.id,\n+        attributeLabelToValueMap: {\n+          department: \"Engineering\",\n+        },\n+        updater: {\n+          dsyncId: directoryId,\n+        },\n+      });\n+    });\n+  });\n+\n+  describe(\"Error handling\", () => {\n+    it(\"should throw an error when organization is not found\", async () => {\n+      const userEmail = \"user@example.com\";\n+      const nonExistentOrgId = 9999;\n+\n+      const event: DirectorySyncEvent = {\n+        event: \"user.created\",\n+        tenant: \"test-tenant\",\n+        directory_id: directoryId,\n+        data: {\n+          id: \"user-123\",\n+          email: userEmail,\n+          first_name: \"Test\",\n+          last_name: \"User\",\n+          active: true,\n+          raw: {\n+            schemas: [],\n+          },\n+        },\n+      };\n+\n+      const { getTeamOrThrow } = await import(\"@calcom/trpc/server/routers/viewer/teams/inviteMember/utils\");\n+      vi.mocked(getTeamOrThrow).mockResolvedValue(\n+        null as unknown as Awaited<ReturnType<typeof getTeamOrThrow>>\n+      );\n+\n+      await expect(handleUserEvents(event, nonExistentOrgId)).rejects.toThrow(\"Org not found\");\n+    });\n+  });\n+});\ndiff --git a/packages/features/ee/dsync/lib/handleUserEvents.ts b/packages/features/ee/dsync/lib/handleUserEvents.ts\nindex bee2c1fe67343a..d117a2fadd42af 100644\n--- a/packages/features/ee/dsync/lib/handleUserEvents.ts\n+++ b/packages/features/ee/dsync/lib/handleUserEvents.ts\n@@ -78,6 +78,9 @@ const handleUserEvents = async (event: DirectorySyncEvent, organizationId: numbe\n   }\n \n   if (user) {\n+    if (user.organizationId && user.organizationId !== org.id) {\n+      throw new Error(\"User belongs to another organization.\");\n+    }\n     if (eventData.active) {\n       if (await new UserRepository(prisma).isAMemberOfOrganization({ user, organizationId })) {\n         await syncCustomAttributesToUser({\n"}
{"instance_id": "calcom__cal.com.main.25312", "repo": "calcom/cal.com", "base_commit": "1578dee6223806d7b70d6cbb721e8cae9a3406d7", "head_commit": "072374d5c337647547b6eb5804cf9b80814df85f", "title": "fix: break circular dependency between reminderScheduler and credit-service", "merged_at": "2025-11-24T08:00:58Z", "html_url": "https://github.com/calcom/cal.com/pull/25312", "test_files": ["packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts"], "code_files": ["packages/features/ee/billing/credit-service.ts", "packages/features/ee/workflows/lib/reminders/reminderScheduler.ts", "packages/features/ee/workflows/repositories/WorkflowReminderRepository.ts"], "total_changes": 234, "num_files": 4, "pull_number": 25312, "patch": "diff --git a/packages/features/ee/billing/credit-service.ts b/packages/features/ee/billing/credit-service.ts\nindex 864114c4e355e5..8b8b78819f5a6e 100644\n--- a/packages/features/ee/billing/credit-service.ts\n+++ b/packages/features/ee/billing/credit-service.ts\n@@ -605,11 +605,15 @@ export class CreditService {\n             \"@calcom/features/ee/workflows/lib/reminders/reminderScheduler\"\n           );\n           promises.push(\n-            cancelScheduledMessagesAndScheduleEmails({ teamId: result.teamId, userId: result.userId }).catch(\n-              (error) => {\n-                log.error(\"Failed to cancel scheduled messages\", error, { result });\n-              }\n-            )\n+            cancelScheduledMessagesAndScheduleEmails({\n+              teamId: result.teamId,\n+              userIdsWithNoCredits: await this._getUserIdsWithoutCredits({\n+                teamId: result.teamId ?? null,\n+                userId: result.userId ?? null,\n+              }),\n+            }).catch((error) => {\n+              log.error(\"Failed to cancel scheduled messages\", error, { result });\n+            })\n           );\n         }\n \n@@ -826,4 +830,34 @@ export class CreditService {\n       };\n     });\n   }\n+\n+  private async _getUserIdsWithoutCredits({\n+    teamId,\n+    userId,\n+  }: {\n+    teamId: number | null;\n+    userId: number | null;\n+  }) {\n+    let userIdsWithNoCredits: number[] = userId ? [userId] : [];\n+    if (teamId) {\n+      const teamMembers = await prisma.membership.findMany({\n+        where: {\n+          teamId,\n+          accepted: true,\n+        },\n+      });\n+\n+      userIdsWithNoCredits = (\n+        await Promise.all(\n+          teamMembers.map(async (member) => {\n+            const hasCredits = await this.hasAvailableCredits({ userId: member.userId });\n+            return { userId: member.userId, hasCredits };\n+          })\n+        )\n+      )\n+        .filter(({ hasCredits }) => !hasCredits)\n+        .map(({ userId }) => userId);\n+    }\n+    return userIdsWithNoCredits;\n+  }\n }\ndiff --git a/packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts b/packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts\nindex aa8549db6aa9b7..fbd3c98b0241e9 100644\n--- a/packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts\n+++ b/packages/features/ee/workflows/lib/reminders/reminderScheduler.test.ts\n@@ -34,8 +34,6 @@ describe(\"reminderScheduler\", () => {\n \n   describe(\"cancelScheduledMessagesAndScheduleEmails\", () => {\n     it(\"should cancel SMS messages and schedule emails for team\", async () => {\n-      prismaMock.membership.findMany.mockResolvedValue([]);\n-\n       const mockScheduledMessages = [\n         {\n           id: 1,\n@@ -63,7 +61,7 @@ describe(\"reminderScheduler\", () => {\n \n       prismaMock.workflowReminder.updateMany.mockResolvedValue({ count: 1 });\n \n-      await cancelScheduledMessagesAndScheduleEmails({ teamId: 10 });\n+      await cancelScheduledMessagesAndScheduleEmails({ teamId: 10, userIdsWithNoCredits: [1, 2, 3] });\n \n       expect(twilioProvider.cancelSMS).toHaveBeenCalledWith(\"sms-123\");\n \n@@ -76,12 +74,13 @@ describe(\"reminderScheduler\", () => {\n       );\n \n       const callArgs = prismaMock.workflowReminder.findMany.mock.calls[0][0];\n-      expect(callArgs.where.workflowStep.workflow.OR).toEqual([{ userId: { in: [] } }, { teamId: 10 }]);\n+      expect(callArgs.where.workflowStep.workflow.OR).toEqual([\n+        { userId: { in: [1, 2, 3] } },\n+        { teamId: 10 },\n+      ]);\n     });\n \n     it(\"should cancel SMS messages and schedule emails for user\", async () => {\n-      prismaMock.membership.findMany.mockResolvedValue([]);\n-\n       const mockScheduledMessages = [\n         {\n           id: 1,\n@@ -109,7 +108,7 @@ describe(\"reminderScheduler\", () => {\n \n       prismaMock.workflowReminder.updateMany.mockResolvedValue({ count: 1 });\n \n-      await cancelScheduledMessagesAndScheduleEmails({ userId: 11 });\n+      await cancelScheduledMessagesAndScheduleEmails({ userIdsWithNoCredits: [11] });\n \n       const callArgs = prismaMock.workflowReminder.findMany.mock.calls[0][0];\n       expect(callArgs.where.workflowStep.workflow.OR).toEqual([{ userId: { in: [11] } }]);\ndiff --git a/packages/features/ee/workflows/lib/reminders/reminderScheduler.ts b/packages/features/ee/workflows/lib/reminders/reminderScheduler.ts\nindex 8ddd80a8343693..63c47a4971861b 100644\n--- a/packages/features/ee/workflows/lib/reminders/reminderScheduler.ts\n+++ b/packages/features/ee/workflows/lib/reminders/reminderScheduler.ts\n@@ -11,14 +11,14 @@ import * as twilio from \"@calcom/features/ee/workflows/lib/reminders/providers/t\n import type { Workflow, WorkflowStep } from \"@calcom/features/ee/workflows/lib/types\";\n import { getSubmitterEmail } from \"@calcom/features/tasker/tasks/triggerFormSubmittedNoEvent/formSubmissionValidation\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n-import { checkSMSRateLimit } from \"@calcom/lib/smsLockState\";\n import { SENDER_NAME } from \"@calcom/lib/constants\";\n import { formatCalEventExtended } from \"@calcom/lib/formatCalendarEvent\";\n import { withReporting } from \"@calcom/lib/sentryWrapper\";\n import { getTranslation } from \"@calcom/lib/server/i18n\";\n+import { checkSMSRateLimit } from \"@calcom/lib/smsLockState\";\n import prisma from \"@calcom/prisma\";\n import { SchedulingType } from \"@calcom/prisma/enums\";\n-import { WorkflowActions, WorkflowMethods, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\n+import { WorkflowActions, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\n import type { CalendarEvent } from \"@calcom/types/Calendar\";\n \n import { scheduleAIPhoneCall } from \"./aiPhoneCallManager\";\n@@ -288,86 +288,18 @@ const _sendCancelledReminders = async (args: SendCancelledRemindersArgs) => {\n \n const _cancelScheduledMessagesAndScheduleEmails = async ({\n   teamId,\n-  userId,\n+  userIdsWithNoCredits,\n }: {\n   teamId?: number | null;\n-  userId?: number | null;\n+  userIdsWithNoCredits: number[];\n }) => {\n-  const { CreditService } = await import(\"@calcom/features/ee/billing/credit-service\");\n-\n-  let userIdsWithNoCredits: number[] = userId ? [userId] : [];\n-\n-  if (teamId) {\n-    const teamMembers = await prisma.membership.findMany({\n-      where: {\n-        teamId,\n-        accepted: true,\n-      },\n-    });\n-\n-    const creditService = new CreditService();\n-\n-    userIdsWithNoCredits = (\n-      await Promise.all(\n-        teamMembers.map(async (member) => {\n-          const hasCredits = await creditService.hasAvailableCredits({ userId: member.userId });\n-          return { userId: member.userId, hasCredits };\n-        })\n-      )\n-    )\n-      .filter(({ hasCredits }) => !hasCredits)\n-      .map(({ userId }) => userId);\n-  }\n+  const { WorkflowReminderRepository } = await import(\n+    \"@calcom/features/ee/workflows/repositories/WorkflowReminderRepository\"\n+  );\n \n-  const scheduledMessages = await prisma.workflowReminder.findMany({\n-    where: {\n-      workflowStep: {\n-        workflow: {\n-          OR: [\n-            {\n-              userId: {\n-                in: userIdsWithNoCredits,\n-              },\n-            },\n-            ...(teamId ? [{ teamId }] : []),\n-          ],\n-        },\n-      },\n-      scheduled: true,\n-      OR: [{ cancelled: false }, { cancelled: null }],\n-      referenceId: {\n-        not: null,\n-      },\n-      method: {\n-        in: [WorkflowMethods.SMS, WorkflowMethods.WHATSAPP],\n-      },\n-    },\n-    select: {\n-      referenceId: true,\n-      workflowStep: {\n-        select: {\n-          action: true,\n-        },\n-      },\n-      scheduledDate: true,\n-      uuid: true,\n-      id: true,\n-      booking: {\n-        select: {\n-          attendees: {\n-            select: {\n-              email: true,\n-              locale: true,\n-            },\n-          },\n-          user: {\n-            select: {\n-              email: true,\n-            },\n-          },\n-        },\n-      },\n-    },\n+  const scheduledMessages = await WorkflowReminderRepository.findScheduledMessagesToCancel({\n+    teamId,\n+    userIdsWithNoCredits,\n   });\n \n   await Promise.allSettled(scheduledMessages.map((msg) => twilio.cancelSMS(msg.referenceId ?? \"\")));\n@@ -393,16 +325,8 @@ const _cancelScheduledMessagesAndScheduleEmails = async ({\n     })\n   );\n \n-  await prisma.workflowReminder.updateMany({\n-    where: {\n-      id: {\n-        in: scheduledMessages.map((msg) => msg.id),\n-      },\n-    },\n-    data: {\n-      method: WorkflowMethods.EMAIL,\n-      referenceId: null,\n-    },\n+  await WorkflowReminderRepository.updateRemindersToEmail({\n+    reminderIds: scheduledMessages.map((msg) => msg.id),\n   });\n };\n // Export functions wrapped with withReporting\ndiff --git a/packages/features/ee/workflows/repositories/WorkflowReminderRepository.ts b/packages/features/ee/workflows/repositories/WorkflowReminderRepository.ts\nnew file mode 100644\nindex 00000000000000..60d6727d2c1b2d\n--- /dev/null\n+++ b/packages/features/ee/workflows/repositories/WorkflowReminderRepository.ts\n@@ -0,0 +1,77 @@\n+import { prisma } from \"@calcom/prisma\";\n+import { WorkflowMethods } from \"@calcom/prisma/enums\";\n+\n+export class WorkflowReminderRepository {\n+  static async findScheduledMessagesToCancel({\n+    teamId,\n+    userIdsWithNoCredits,\n+  }: {\n+    teamId?: number | null;\n+    userIdsWithNoCredits: number[];\n+  }) {\n+    return await prisma.workflowReminder.findMany({\n+      where: {\n+        workflowStep: {\n+          workflow: {\n+            OR: [\n+              {\n+                userId: {\n+                  in: userIdsWithNoCredits,\n+                },\n+              },\n+              ...(teamId ? [{ teamId }] : []),\n+            ],\n+          },\n+        },\n+        scheduled: true,\n+        OR: [{ cancelled: false }, { cancelled: null }],\n+        referenceId: {\n+          not: null,\n+        },\n+        method: {\n+          in: [WorkflowMethods.SMS, WorkflowMethods.WHATSAPP],\n+        },\n+      },\n+      select: {\n+        referenceId: true,\n+        workflowStep: {\n+          select: {\n+            action: true,\n+          },\n+        },\n+        scheduledDate: true,\n+        uuid: true,\n+        id: true,\n+        booking: {\n+          select: {\n+            attendees: {\n+              select: {\n+                email: true,\n+                locale: true,\n+              },\n+            },\n+            user: {\n+              select: {\n+                email: true,\n+              },\n+            },\n+          },\n+        },\n+      },\n+    });\n+  }\n+\n+  static async updateRemindersToEmail({ reminderIds }: { reminderIds: number[] }): Promise<void> {\n+    await prisma.workflowReminder.updateMany({\n+      where: {\n+        id: {\n+          in: reminderIds,\n+        },\n+      },\n+      data: {\n+        method: WorkflowMethods.EMAIL,\n+        referenceId: null,\n+      },\n+    });\n+  }\n+}\n"}
{"instance_id": "calcom__cal.com.main.25310", "repo": "calcom/cal.com", "base_commit": "8b652613dd48c929b76d0d77f97dae474eee110b", "head_commit": "47900cdf6f7f8ceb62a88816eb3c79e9504ee704", "title": "fix: improve overlapping events with dynamic offsets and widths", "merged_at": "2025-11-24T12:01:05Z", "html_url": "https://github.com/calcom/cal.com/pull/25310", "test_files": ["packages/features/calendars/weeklyview/utils/overlap.test.ts"], "code_files": ["apps/web/app/(use-page-wrapper)/settings/(admin-layout)/admin/playground/weekly-calendar/page.tsx", "packages/features/calendars/weeklyview/components/Calendar.tsx", "packages/features/calendars/weeklyview/components/DateValues/index.tsx", "packages/features/calendars/weeklyview/components/currentTime/index.tsx", "packages/features/calendars/weeklyview/components/grid/index.tsx", "packages/features/calendars/weeklyview/components/verticalLines/index.tsx", "packages/features/calendars/weeklyview/utils/overlap.ts"], "total_changes": 605, "num_files": 8, "pull_number": 25310, "patch": "diff --git a/apps/web/app/(use-page-wrapper)/settings/(admin-layout)/admin/playground/weekly-calendar/page.tsx b/apps/web/app/(use-page-wrapper)/settings/(admin-layout)/admin/playground/weekly-calendar/page.tsx\nindex b172faae3093b5..9e3b3f08a8cf03 100644\n--- a/apps/web/app/(use-page-wrapper)/settings/(admin-layout)/admin/playground/weekly-calendar/page.tsx\n+++ b/apps/web/app/(use-page-wrapper)/settings/(admin-layout)/admin/playground/weekly-calendar/page.tsx\n@@ -5,17 +5,23 @@ import { useState } from \"react\";\n import dayjs from \"@calcom/dayjs\";\n import { Calendar } from \"@calcom/features/calendars/weeklyview\";\n import type { CalendarEvent } from \"@calcom/features/calendars/weeklyview/types/events\";\n-import type { CalendarComponentProps } from \"@calcom/features/calendars/weeklyview/types/state\";\n+import type { CalendarComponentProps, Hours } from \"@calcom/features/calendars/weeklyview/types/state\";\n \n const makeDate = (dayOffset: number, hour: number, minute: number = 0) => {\n   return dayjs(\"2025-01-06\").add(dayOffset, \"day\").hour(hour).minute(minute).second(0).toDate();\n };\n \n-const getBaseProps = (events: CalendarEvent[]): CalendarComponentProps => ({\n+const getBaseProps = ({\n+  events,\n+  startHour = 6,\n+}: {\n+  events: CalendarEvent[];\n+  startHour?: Hours;\n+}): CalendarComponentProps => ({\n   startDate: dayjs(\"2025-01-06\").toDate(), // Monday\n   endDate: dayjs(\"2025-01-12\").toDate(), // Sunday\n   events,\n-  startHour: 6,\n+  startHour,\n   endHour: 18,\n   gridCellsPerHour: 4,\n   timezone: \"UTC\",\n@@ -23,6 +29,7 @@ const getBaseProps = (events: CalendarEvent[]): CalendarComponentProps => ({\n   showBorder: false,\n   hideHeader: true,\n   borderColor: \"subtle\",\n+  scrollToCurrentTime: false,\n });\n \n type Scenario = {\n@@ -31,6 +38,7 @@ type Scenario = {\n   description: string;\n   expected: string;\n   events: CalendarEvent[];\n+  startHour: Hours;\n };\n \n const scenarios: Scenario[] = [\n@@ -39,7 +47,8 @@ const scenarios: Scenario[] = [\n     title: \"Two Overlapping Events\",\n     description: \"Two events with overlapping time ranges on the same day\",\n     expected:\n-      \"Second event should be offset 8% to the right, both 80% width. Hover should bring event to front.\",\n+      \"First event 80% width at left edge (0%), second event 50% width aligned to right edge (49.5% offset). Events spread across full width for maximum visual distinction. Hover should bring event to front.\",\n+    startHour: 9,\n     events: [\n       {\n         id: 1,\n@@ -62,7 +71,8 @@ const scenarios: Scenario[] = [\n     title: \"Three Overlapping Events (Cascading)\",\n     description: \"Three events that overlap, creating a cascading effect\",\n     expected:\n-      \"Events should cascade with offsets 0%, 8%, 16%. Z-index should increment. Hover brings any to top.\",\n+      \"Events spread across full width with variable widths (55%, ~42%, 33%). Offsets: 0%, ~35%, 66.5% (last event aligned to right edge). Right edges evenly distributed for maximum scatter. Z-index should increment. Hover brings any to top.\",\n+    startHour: 9,\n     events: [\n       {\n         id: 3,\n@@ -91,7 +101,8 @@ const scenarios: Scenario[] = [\n     id: \"non-overlapping\",\n     title: \"Non-Overlapping Events\",\n     description: \"Events that don't overlap should not cascade\",\n-    expected: \"Both events at 0% offset (separate groups), no cascade. Both should be 80% width.\",\n+    expected: \"Both events at 0% offset (separate groups), no cascade. Both should be 100% width.\",\n+    startHour: 9,\n     events: [\n       {\n         id: 6,\n@@ -113,7 +124,9 @@ const scenarios: Scenario[] = [\n     id: \"same-start-time\",\n     title: \"Same Start Time, Different Durations\",\n     description: \"Multiple events starting at the same time with varying lengths\",\n-    expected: \"Longest event first (base of cascade), shorter ones offset 8%, 16%. All start at 10:00.\",\n+    expected:\n+      \"Longest event first (base of cascade), spread across full width with variable widths (55%, ~42%, 33%). Last event aligned to right edge. All start at 10:00.\",\n+    startHour: 9,\n     events: [\n       {\n         id: 8,\n@@ -139,16 +152,18 @@ const scenarios: Scenario[] = [\n     ],\n   },\n   {\n-    id: \"chain-overlaps\",\n-    title: \"Chain Overlaps (A\u2192B\u2192C)\",\n-    description: \"Events where A overlaps B, and B overlaps C\",\n-    expected: \"Single overlap group with cascading offsets 0%, 8%, 16%.\",\n+    id: \"four-overlapping\",\n+    title: \"Four Overlapping Events\",\n+    description: \"Four events that overlap simultaneously\",\n+    expected:\n+      \"Events spread across full width with variable widths (40%, ~33%, ~28%, 25%). Last event aligned to right edge. Right edges evenly distributed for maximum scatter.\",\n+    startHour: 9,\n     events: [\n       {\n         id: 11,\n         title: \"Event A\",\n         start: makeDate(4, 10, 0),\n-        end: makeDate(4, 11, 0),\n+        end: makeDate(4, 12, 0),\n         options: { status: \"ACCEPTED\", color: \"#3b82f6\" },\n       },\n       {\n@@ -162,9 +177,16 @@ const scenarios: Scenario[] = [\n         id: 13,\n         title: \"Event C\",\n         start: makeDate(4, 11, 0),\n-        end: makeDate(4, 12, 0),\n+        end: makeDate(4, 12, 30),\n         options: { status: \"ACCEPTED\", color: \"#10b981\" },\n       },\n+      {\n+        id: 50,\n+        title: \"Event D\",\n+        start: makeDate(4, 11, 15),\n+        end: makeDate(4, 12, 15),\n+        options: { status: \"PENDING\", color: \"#8b5cf6\" },\n+      },\n     ],\n   },\n   {\n@@ -173,6 +195,7 @@ const scenarios: Scenario[] = [\n     description: \"A very busy day with many overlapping events\",\n     expected:\n       \"Visually tight stack with multiple cascading levels. Right edge should not overflow. Hover should still work.\",\n+    startHour: 8,\n     events: [\n       {\n         id: 14,\n@@ -327,7 +350,9 @@ const scenarios: Scenario[] = [\n     id: \"touching-events\",\n     title: \"Touching Events (Edge Case)\",\n     description: \"Events that touch exactly at boundaries\",\n-    expected: \"Separate groups; no cascade; both at 0% offset. Events touching at 11:00 should not overlap.\",\n+    expected:\n+      \"Separate groups; no cascade; both at 0% offset. Both should be 100% width. Events touching at 11:00 should not overlap.\",\n+    startHour: 9,\n     events: [\n       {\n         id: 25,\n@@ -351,6 +376,7 @@ const scenarios: Scenario[] = [\n     description: \"Events with different booking statuses\",\n     expected:\n       \"Visual styling should differ by status (ACCEPTED, PENDING, CANCELLED). Cascade should still work.\",\n+    startHour: 13,\n     events: [\n       {\n         id: 27,\n@@ -381,6 +407,7 @@ const scenarios: Scenario[] = [\n     description: \"Events with different durations to test layout logic (eventDuration > 30 changes flex-col)\",\n     expected:\n       \"Events \u226430min show horizontal layout (title and time inline). Events >30min show vertical layout (title and time stacked).\",\n+    startHour: 8,\n     events: [\n       {\n         id: 40,\n@@ -465,7 +492,7 @@ function ScenarioCard({ scenario }: { scenario: Scenario }) {\n       </div>\n \n       <div className=\"h-[600px] overflow-hidden rounded border\">\n-        <Calendar {...getBaseProps(scenario.events)} />\n+        <Calendar {...getBaseProps({ events: scenario.events, startHour: scenario.startHour })} />\n       </div>\n \n       <button\ndiff --git a/packages/features/calendars/weeklyview/components/Calendar.tsx b/packages/features/calendars/weeklyview/components/Calendar.tsx\nindex 5b45f5081c9ac5..450e47e53bae59 100644\n--- a/packages/features/calendars/weeklyview/components/Calendar.tsx\n+++ b/packages/features/calendars/weeklyview/components/Calendar.tsx\n@@ -34,6 +34,7 @@ function CalendarInner(props: CalendarComponentProps) {\n   const showBackgroundPattern = useCalendarStore((state) => state.showBackgroundPattern);\n   const showBorder = useCalendarStore((state) => state.showBorder ?? true);\n   const borderColor = useCalendarStore((state) => state.borderColor ?? \"default\");\n+  const scrollToCurrentTime = useCalendarStore((state) => state.scrollToCurrentTime ?? true);\n \n   const days = useMemo(() => getDaysBetweenDates(startDate, endDate), [startDate, endDate]);\n \n@@ -74,7 +75,7 @@ function CalendarInner(props: CalendarComponentProps) {\n               borderColor={borderColor}\n             />\n             <div className=\"relative flex flex-auto\">\n-              <CurrentTime timezone={timezone} />\n+              <CurrentTime timezone={timezone} scrollToCurrentTime={scrollToCurrentTime} />\n               <div\n                 className={classNames(\n                   \"bg-default dark:bg-muted ring-muted sticky left-0 z-10 w-16 flex-none ring-1\",\ndiff --git a/packages/features/calendars/weeklyview/components/DateValues/index.tsx b/packages/features/calendars/weeklyview/components/DateValues/index.tsx\nindex e7e2c6e71263e6..3cd232f13f1612 100644\n--- a/packages/features/calendars/weeklyview/components/DateValues/index.tsx\n+++ b/packages/features/calendars/weeklyview/components/DateValues/index.tsx\n@@ -52,7 +52,7 @@ export function DateValues({ showBorder, borderColor, days, containerNavRef }: P\n     <div\n       ref={containerNavRef}\n       className={classNames(\n-        \"bg-default dark:bg-default sticky top-[var(--calendar-dates-sticky-offset,0px)] z-[80] flex-none border-b sm:pr-8\",\n+        \"bg-default dark:bg-default sticky top-[var(--calendar-dates-sticky-offset,0px)] z-[80] flex-none border-b\",\n         borderColor === \"subtle\" ? \"border-b-subtle\" : \"border-b-default\",\n         showBorder && (borderColor === \"subtle\" ? \"border-r-subtle border-r\" : \"border-r-default border-r\")\n       )}>\ndiff --git a/packages/features/calendars/weeklyview/components/currentTime/index.tsx b/packages/features/calendars/weeklyview/components/currentTime/index.tsx\nindex f8e1d78ba8abe1..533a907b9c6753 100644\n--- a/packages/features/calendars/weeklyview/components/currentTime/index.tsx\n+++ b/packages/features/calendars/weeklyview/components/currentTime/index.tsx\n@@ -11,7 +11,13 @@ function calculateMinutesFromStart(startHour: number, currentHour: number, curre\n   return currentMinuteOfDay - startMinute;\n }\n \n-export function CurrentTime({ timezone }: { timezone: string }) {\n+export function CurrentTime({\n+  timezone,\n+  scrollToCurrentTime = true,\n+}: {\n+  timezone: string;\n+  scrollToCurrentTime?: boolean;\n+}) {\n   const { timeFormat } = useTimePreferences();\n   const currentTimeRef = useRef<HTMLDivElement>(null);\n   const [scrolledIntoView, setScrolledIntoView] = useState(false);\n@@ -36,14 +42,14 @@ export function CurrentTime({ timezone }: { timezone: string }) {\n     const minutesFromStart = calculateMinutesFromStart(startHour, currentHour, currentMinute);\n     setCurrentTimePos(minutesFromStart);\n \n-    if (!currentTimeRef.current || scrolledIntoView) return;\n+    if (!scrollToCurrentTime || !currentTimeRef.current || scrolledIntoView) return;\n     // Within a small timeout so element has time to render.\n     setTimeout(() => {\n       // Doesn't seem to cause any issue. Put it under condition if needed\n       currentTimeRef?.current?.scrollIntoView({ block: \"center\" });\n       setScrolledIntoView(true);\n     }, 100);\n-  }, [startHour, endHour, scrolledIntoView, timezone]);\n+  }, [startHour, endHour, scrolledIntoView, timezone, scrollToCurrentTime]);\n \n   return (\n     <div\ndiff --git a/packages/features/calendars/weeklyview/components/grid/index.tsx b/packages/features/calendars/weeklyview/components/grid/index.tsx\nindex 682e84f26d2707..deeacef8e49cb7 100644\n--- a/packages/features/calendars/weeklyview/components/grid/index.tsx\n+++ b/packages/features/calendars/weeklyview/components/grid/index.tsx\n@@ -14,7 +14,7 @@ export const SchedulerColumns = React.forwardRef<HTMLOListElement, Props>(functi\n   return (\n     <ol\n       ref={ref}\n-      className=\"scheduler-grid-row-template col-start-1 col-end-2 row-start-1 grid auto-cols-auto text-[0px] sm:pr-8\"\n+      className=\"scheduler-grid-row-template col-start-1 col-end-2 row-start-1 grid auto-cols-auto text-[0px]\"\n       style={{ marginTop: offsetHeight || \"var(--gridDefaultSize)\", zIndex }}\n       data-gridstopsperday={gridStopsPerDay}>\n       {children}\ndiff --git a/packages/features/calendars/weeklyview/components/verticalLines/index.tsx b/packages/features/calendars/weeklyview/components/verticalLines/index.tsx\nindex b021bdb0f40886..8bc5577655d448 100644\n--- a/packages/features/calendars/weeklyview/components/verticalLines/index.tsx\n+++ b/packages/features/calendars/weeklyview/components/verticalLines/index.tsx\n@@ -19,7 +19,7 @@ export const VerticalLines = ({ days, borderColor }: { days: dayjs.Dayjs[]; bord\n   return (\n     <div\n       className={classNames(\n-        \"pointer-events-none relative z-[60] col-start-1 col-end-2 row-start-1 grid auto-cols-auto grid-rows-1 divide-x sm:pr-8\",\n+        \"pointer-events-none relative z-[60] col-start-1 col-end-2 row-start-1 grid auto-cols-auto grid-rows-1 divide-x\",\n         borderColor === \"subtle\" ? \"divide-subtle\" : \"divide-default\"\n       )}\n       dir={direction}\ndiff --git a/packages/features/calendars/weeklyview/utils/overlap.test.ts b/packages/features/calendars/weeklyview/utils/overlap.test.ts\nindex 78fbc0bd9bd42b..d062e46869fb31 100644\n--- a/packages/features/calendars/weeklyview/utils/overlap.test.ts\n+++ b/packages/features/calendars/weeklyview/utils/overlap.test.ts\n@@ -1,20 +1,30 @@\n import { describe, expect, it } from \"vitest\";\n \n import type { CalendarEvent } from \"../types/events\";\n-import {\n-  buildOverlapGroups,\n-  calculateEventLayouts,\n-  createLayoutMap,\n-  sortEvents,\n-} from \"./overlap\";\n+import { buildOverlapGroups, calculateEventLayouts, createLayoutMap, sortEvents } from \"./overlap\";\n \n describe(\"overlap utility\", () => {\n   describe(\"sortEvents\", () => {\n     it(\"should sort events by start time ascending\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T09:00:00\"), end: new Date(\"2024-01-01T10:00:00\") },\n-        { id: 3, title: \"Event 3\", start: new Date(\"2024-01-01T11:00:00\"), end: new Date(\"2024-01-01T12:00:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T09:00:00\"),\n+          end: new Date(\"2024-01-01T10:00:00\"),\n+        },\n+        {\n+          id: 3,\n+          title: \"Event 3\",\n+          start: new Date(\"2024-01-01T11:00:00\"),\n+          end: new Date(\"2024-01-01T12:00:00\"),\n+        },\n       ];\n \n       const sorted = sortEvents(events);\n@@ -26,9 +36,24 @@ describe(\"overlap utility\", () => {\n \n     it(\"should sort events with same start time by end time descending (longer first)\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T12:00:00\") },\n-        { id: 3, title: \"Event 3\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T10:30:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T12:00:00\"),\n+        },\n+        {\n+          id: 3,\n+          title: \"Event 3\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T10:30:00\"),\n+        },\n       ];\n \n       const sorted = sortEvents(events);\n@@ -40,8 +65,18 @@ describe(\"overlap utility\", () => {\n \n     it(\"should not mutate the original array\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T09:00:00\"), end: new Date(\"2024-01-01T10:00:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T09:00:00\"),\n+          end: new Date(\"2024-01-01T10:00:00\"),\n+        },\n       ];\n \n       const originalFirstId = events[0].id;\n@@ -59,7 +94,12 @@ describe(\"overlap utility\", () => {\n \n     it(\"should return single group for single event\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n       ];\n \n       const groups = buildOverlapGroups(events);\n@@ -71,8 +111,18 @@ describe(\"overlap utility\", () => {\n \n     it(\"should group two overlapping events together\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T10:30:00\"), end: new Date(\"2024-01-01T11:30:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T10:30:00\"),\n+          end: new Date(\"2024-01-01T11:30:00\"),\n+        },\n       ];\n \n       const sorted = sortEvents(events);\n@@ -86,8 +136,18 @@ describe(\"overlap utility\", () => {\n \n     it(\"should separate non-overlapping events into different groups\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T11:00:00\"), end: new Date(\"2024-01-01T12:00:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T11:00:00\"),\n+          end: new Date(\"2024-01-01T12:00:00\"),\n+        },\n       ];\n \n       const sorted = sortEvents(events);\n@@ -102,9 +162,24 @@ describe(\"overlap utility\", () => {\n \n     it(\"should handle chain overlaps (A overlaps B, B overlaps C)\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T10:30:00\"), end: new Date(\"2024-01-01T11:30:00\") },\n-        { id: 3, title: \"Event 3\", start: new Date(\"2024-01-01T11:00:00\"), end: new Date(\"2024-01-01T12:00:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T10:30:00\"),\n+          end: new Date(\"2024-01-01T11:30:00\"),\n+        },\n+        {\n+          id: 3,\n+          title: \"Event 3\",\n+          start: new Date(\"2024-01-01T11:00:00\"),\n+          end: new Date(\"2024-01-01T12:00:00\"),\n+        },\n       ];\n \n       const sorted = sortEvents(events);\n@@ -119,10 +194,30 @@ describe(\"overlap utility\", () => {\n \n     it(\"should handle multiple separate overlap groups\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T09:00:00\"), end: new Date(\"2024-01-01T10:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T09:30:00\"), end: new Date(\"2024-01-01T10:30:00\") },\n-        { id: 3, title: \"Event 3\", start: new Date(\"2024-01-01T11:00:00\"), end: new Date(\"2024-01-01T12:00:00\") },\n-        { id: 4, title: \"Event 4\", start: new Date(\"2024-01-01T11:30:00\"), end: new Date(\"2024-01-01T12:30:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T09:00:00\"),\n+          end: new Date(\"2024-01-01T10:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T09:30:00\"),\n+          end: new Date(\"2024-01-01T10:30:00\"),\n+        },\n+        {\n+          id: 3,\n+          title: \"Event 3\",\n+          start: new Date(\"2024-01-01T11:00:00\"),\n+          end: new Date(\"2024-01-01T12:00:00\"),\n+        },\n+        {\n+          id: 4,\n+          title: \"Event 4\",\n+          start: new Date(\"2024-01-01T11:30:00\"),\n+          end: new Date(\"2024-01-01T12:30:00\"),\n+        },\n       ];\n \n       const sorted = sortEvents(events);\n@@ -139,9 +234,24 @@ describe(\"overlap utility\", () => {\n \n     it(\"should handle events that start at the same time\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T12:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 3, title: \"Event 3\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T10:30:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T12:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 3,\n+          title: \"Event 3\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T10:30:00\"),\n+        },\n       ];\n \n       const sorted = sortEvents(events);\n@@ -155,7 +265,12 @@ describe(\"overlap utility\", () => {\n   describe(\"calculateEventLayouts\", () => {\n     it(\"should calculate layout for single event\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n       ];\n \n       const layouts = calculateEventLayouts(events);\n@@ -163,7 +278,7 @@ describe(\"overlap utility\", () => {\n       expect(layouts).toHaveLength(1);\n       expect(layouts[0].event.id).toBe(1);\n       expect(layouts[0].leftOffsetPercent).toBe(0);\n-      expect(layouts[0].widthPercent).toBe(80);\n+      expect(layouts[0].widthPercent).toBe(99.5);\n       expect(layouts[0].baseZIndex).toBe(60);\n       expect(layouts[0].groupIndex).toBe(0);\n       expect(layouts[0].indexInGroup).toBe(0);\n@@ -171,80 +286,118 @@ describe(\"overlap utility\", () => {\n \n     it(\"should calculate cascading layout for two overlapping events\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T10:30:00\"), end: new Date(\"2024-01-01T11:30:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T10:30:00\"),\n+          end: new Date(\"2024-01-01T11:30:00\"),\n+        },\n       ];\n \n       const layouts = calculateEventLayouts(events);\n \n       expect(layouts).toHaveLength(2);\n-      \n+\n       expect(layouts[0].event.id).toBe(1);\n       expect(layouts[0].leftOffsetPercent).toBe(0);\n       expect(layouts[0].widthPercent).toBe(80);\n       expect(layouts[0].baseZIndex).toBe(60);\n-      \n+\n       expect(layouts[1].event.id).toBe(2);\n-      expect(layouts[1].leftOffsetPercent).toBe(8);\n-      expect(layouts[1].widthPercent).toBe(80);\n+      expect(layouts[1].leftOffsetPercent).toBe(49.5);\n+      expect(layouts[1].widthPercent).toBe(50);\n       expect(layouts[1].baseZIndex).toBe(61);\n     });\n \n     it(\"should calculate cascading layout for three overlapping events\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T10:30:00\"), end: new Date(\"2024-01-01T11:30:00\") },\n-        { id: 3, title: \"Event 3\", start: new Date(\"2024-01-01T11:00:00\"), end: new Date(\"2024-01-01T12:00:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T10:30:00\"),\n+          end: new Date(\"2024-01-01T11:30:00\"),\n+        },\n+        {\n+          id: 3,\n+          title: \"Event 3\",\n+          start: new Date(\"2024-01-01T11:00:00\"),\n+          end: new Date(\"2024-01-01T12:00:00\"),\n+        },\n       ];\n \n       const layouts = calculateEventLayouts(events);\n \n       expect(layouts).toHaveLength(3);\n-      \n+\n       expect(layouts[0].leftOffsetPercent).toBe(0);\n-      expect(layouts[1].leftOffsetPercent).toBe(8);\n-      expect(layouts[2].leftOffsetPercent).toBe(16);\n-      \n+      expect(layouts[1].leftOffsetPercent).toBeCloseTo(35.315, 1);\n+      expect(layouts[2].leftOffsetPercent).toBe(66.5);\n+\n       expect(layouts[0].baseZIndex).toBe(60);\n       expect(layouts[1].baseZIndex).toBe(61);\n       expect(layouts[2].baseZIndex).toBe(62);\n     });\n \n-    it(\"should respect custom configuration\", () => {\n+    it(\"should respect custom baseZIndex configuration\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T10:30:00\"), end: new Date(\"2024-01-01T11:30:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T10:30:00\"),\n+          end: new Date(\"2024-01-01T11:30:00\"),\n+        },\n       ];\n \n       const layouts = calculateEventLayouts(events, {\n-        baseWidthPercent: 70,\n-        offsetStepPercent: 10,\n         baseZIndex: 50,\n       });\n \n-      expect(layouts[0].widthPercent).toBe(70);\n-      expect(layouts[0].leftOffsetPercent).toBe(0);\n       expect(layouts[0].baseZIndex).toBe(50);\n-      \n-      expect(layouts[1].widthPercent).toBe(70);\n-      expect(layouts[1].leftOffsetPercent).toBe(10);\n       expect(layouts[1].baseZIndex).toBe(51);\n     });\n \n     it(\"should handle non-overlapping events in separate groups\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T11:00:00\"), end: new Date(\"2024-01-01T12:00:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T11:00:00\"),\n+          end: new Date(\"2024-01-01T12:00:00\"),\n+        },\n       ];\n \n       const layouts = calculateEventLayouts(events);\n \n       expect(layouts).toHaveLength(2);\n-      \n+\n       expect(layouts[0].groupIndex).toBe(0);\n       expect(layouts[0].indexInGroup).toBe(0);\n       expect(layouts[0].leftOffsetPercent).toBe(0);\n-      \n+\n       expect(layouts[1].groupIndex).toBe(1);\n       expect(layouts[1].indexInGroup).toBe(0);\n       expect(layouts[1].leftOffsetPercent).toBe(0);\n@@ -252,17 +405,72 @@ describe(\"overlap utility\", () => {\n \n     it(\"should prevent overflow with many overlapping events (dense scenario)\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T09:00:00\"), end: new Date(\"2024-01-01T09:30:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T09:15:00\"), end: new Date(\"2024-01-01T10:00:00\") },\n-        { id: 3, title: \"Event 3\", start: new Date(\"2024-01-01T09:45:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 4, title: \"Event 4\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T10:30:00\") },\n-        { id: 5, title: \"Event 5\", start: new Date(\"2024-01-01T10:15:00\"), end: new Date(\"2024-01-01T11:30:00\") },\n-        { id: 6, title: \"Event 6\", start: new Date(\"2024-01-01T11:00:00\"), end: new Date(\"2024-01-01T12:00:00\") },\n-        { id: 7, title: \"Event 7\", start: new Date(\"2024-01-01T11:30:00\"), end: new Date(\"2024-01-01T12:30:00\") },\n-        { id: 8, title: \"Event 8\", start: new Date(\"2024-01-01T12:00:00\"), end: new Date(\"2024-01-01T13:30:00\") },\n-        { id: 9, title: \"Event 9\", start: new Date(\"2024-01-01T12:30:00\"), end: new Date(\"2024-01-01T13:00:00\") },\n-        { id: 10, title: \"Event 10\", start: new Date(\"2024-01-01T13:00:00\"), end: new Date(\"2024-01-01T14:00:00\") },\n-        { id: 11, title: \"Event 11\", start: new Date(\"2024-01-01T13:15:00\"), end: new Date(\"2024-01-01T14:00:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T09:00:00\"),\n+          end: new Date(\"2024-01-01T09:30:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T09:15:00\"),\n+          end: new Date(\"2024-01-01T10:00:00\"),\n+        },\n+        {\n+          id: 3,\n+          title: \"Event 3\",\n+          start: new Date(\"2024-01-01T09:45:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 4,\n+          title: \"Event 4\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T10:30:00\"),\n+        },\n+        {\n+          id: 5,\n+          title: \"Event 5\",\n+          start: new Date(\"2024-01-01T10:15:00\"),\n+          end: new Date(\"2024-01-01T11:30:00\"),\n+        },\n+        {\n+          id: 6,\n+          title: \"Event 6\",\n+          start: new Date(\"2024-01-01T11:00:00\"),\n+          end: new Date(\"2024-01-01T12:00:00\"),\n+        },\n+        {\n+          id: 7,\n+          title: \"Event 7\",\n+          start: new Date(\"2024-01-01T11:30:00\"),\n+          end: new Date(\"2024-01-01T12:30:00\"),\n+        },\n+        {\n+          id: 8,\n+          title: \"Event 8\",\n+          start: new Date(\"2024-01-01T12:00:00\"),\n+          end: new Date(\"2024-01-01T13:30:00\"),\n+        },\n+        {\n+          id: 9,\n+          title: \"Event 9\",\n+          start: new Date(\"2024-01-01T12:30:00\"),\n+          end: new Date(\"2024-01-01T13:00:00\"),\n+        },\n+        {\n+          id: 10,\n+          title: \"Event 10\",\n+          start: new Date(\"2024-01-01T13:00:00\"),\n+          end: new Date(\"2024-01-01T14:00:00\"),\n+        },\n+        {\n+          id: 11,\n+          title: \"Event 11\",\n+          start: new Date(\"2024-01-01T13:15:00\"),\n+          end: new Date(\"2024-01-01T14:00:00\"),\n+        },\n       ];\n \n       const layouts = calculateEventLayouts(events);\n@@ -279,14 +487,14 @@ describe(\"overlap utility\", () => {\n       const events: CalendarEvent[] = Array.from({ length: 21 }, (_, i) => ({\n         id: i + 1,\n         title: `Event ${i + 1}`,\n-        start: new Date(`2024-01-01T09:${String(i * 2).padStart(2, '0')}:00`),\n-        end: new Date(`2024-01-01T10:${String(i * 2).padStart(2, '0')}:00`),\n+        start: new Date(`2024-01-01T09:${String(i * 2).padStart(2, \"0\")}:00`),\n+        end: new Date(`2024-01-01T10:${String(i * 2).padStart(2, \"0\")}:00`),\n       }));\n \n       const layouts = calculateEventLayouts(events);\n \n       expect(layouts).toHaveLength(21);\n-      \n+\n       layouts.forEach((layout) => {\n         const totalWidth = layout.leftOffsetPercent + layout.widthPercent;\n         expect(totalWidth).toBeLessThanOrEqual(100 - 0.5);\n@@ -300,17 +508,17 @@ describe(\"overlap utility\", () => {\n       const events: CalendarEvent[] = Array.from({ length: 12 }, (_, i) => ({\n         id: i + 1,\n         title: `Event ${i + 1}`,\n-        start: new Date(`2024-01-01T10:${String(i * 5).padStart(2, '0')}:00`),\n-        end: new Date(`2024-01-01T11:${String(i * 5).padStart(2, '0')}:00`),\n+        start: new Date(`2024-01-01T10:${String(i * 5).padStart(2, \"0\")}:00`),\n+        end: new Date(`2024-01-01T11:${String(i * 5).padStart(2, \"0\")}:00`),\n       }));\n \n       const layouts = calculateEventLayouts(events);\n \n       expect(layouts).toHaveLength(12);\n-      \n+\n       layouts.forEach((layout, index) => {\n         expect(layout.leftOffsetPercent + layout.widthPercent).toBeLessThanOrEqual(100);\n-        \n+\n         if (index > 0) {\n           expect(layout.leftOffsetPercent).toBeGreaterThan(layouts[index - 1].leftOffsetPercent);\n         }\n@@ -320,30 +528,55 @@ describe(\"overlap utility\", () => {\n       expect(lastLayout.leftOffsetPercent + lastLayout.widthPercent).toBeLessThanOrEqual(100);\n     });\n \n-    it(\"should maintain full width for small overlap groups\", () => {\n+    it(\"should use dynamic width for three overlapping events\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T10:30:00\"), end: new Date(\"2024-01-01T11:30:00\") },\n-        { id: 3, title: \"Event 3\", start: new Date(\"2024-01-01T11:00:00\"), end: new Date(\"2024-01-01T12:00:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T10:30:00\"),\n+          end: new Date(\"2024-01-01T11:30:00\"),\n+        },\n+        {\n+          id: 3,\n+          title: \"Event 3\",\n+          start: new Date(\"2024-01-01T11:00:00\"),\n+          end: new Date(\"2024-01-01T12:00:00\"),\n+        },\n       ];\n \n       const layouts = calculateEventLayouts(events);\n \n-      expect(layouts[0].widthPercent).toBe(80);\n-      expect(layouts[1].widthPercent).toBe(80);\n-      expect(layouts[2].widthPercent).toBe(80);\n-      \n+      expect(layouts[0].widthPercent).toBe(55);\n+      expect(layouts[1].widthPercent).toBeCloseTo(41.9, 0);\n+      expect(layouts[2].widthPercent).toBe(33);\n+\n       expect(layouts[0].leftOffsetPercent).toBe(0);\n-      expect(layouts[1].leftOffsetPercent).toBe(8);\n-      expect(layouts[2].leftOffsetPercent).toBe(16);\n+      expect(layouts[1].leftOffsetPercent).toBeCloseTo(35.315, 1);\n+      expect(layouts[2].leftOffsetPercent).toBe(66.5);\n     });\n   });\n \n   describe(\"createLayoutMap\", () => {\n     it(\"should create a map from event ID to layout\", () => {\n       const events: CalendarEvent[] = [\n-        { id: 1, title: \"Event 1\", start: new Date(\"2024-01-01T10:00:00\"), end: new Date(\"2024-01-01T11:00:00\") },\n-        { id: 2, title: \"Event 2\", start: new Date(\"2024-01-01T10:30:00\"), end: new Date(\"2024-01-01T11:30:00\") },\n+        {\n+          id: 1,\n+          title: \"Event 1\",\n+          start: new Date(\"2024-01-01T10:00:00\"),\n+          end: new Date(\"2024-01-01T11:00:00\"),\n+        },\n+        {\n+          id: 2,\n+          title: \"Event 2\",\n+          start: new Date(\"2024-01-01T10:30:00\"),\n+          end: new Date(\"2024-01-01T11:30:00\"),\n+        },\n       ];\n \n       const layouts = calculateEventLayouts(events);\n@@ -353,7 +586,9 @@ describe(\"overlap utility\", () => {\n       expect(map.get(1)?.event.id).toBe(1);\n       expect(map.get(2)?.event.id).toBe(2);\n       expect(map.get(1)?.leftOffsetPercent).toBe(0);\n-      expect(map.get(2)?.leftOffsetPercent).toBe(8);\n+      expect(map.get(2)?.leftOffsetPercent).toBe(49.5);\n+      expect(map.get(1)?.widthPercent).toBe(80);\n+      expect(map.get(2)?.widthPercent).toBe(50);\n     });\n \n     it(\"should handle empty layouts\", () => {\ndiff --git a/packages/features/calendars/weeklyview/utils/overlap.ts b/packages/features/calendars/weeklyview/utils/overlap.ts\nindex c473222cb13783..db092ff249d489 100644\n--- a/packages/features/calendars/weeklyview/utils/overlap.ts\n+++ b/packages/features/calendars/weeklyview/utils/overlap.ts\n@@ -3,10 +3,10 @@ import dayjs from \"@calcom/dayjs\";\n import type { CalendarEvent } from \"../types/events\";\n \n export interface OverlapLayoutConfig {\n-  baseWidthPercent?: number;\n-  offsetStepPercent?: number;\n   baseZIndex?: number;\n   safetyMarginPercent?: number;\n+  minWidthPercent?: number;\n+  curveExponent?: number;\n }\n \n export interface EventLayout {\n@@ -19,12 +19,60 @@ export interface EventLayout {\n }\n \n const DEFAULT_CONFIG: Required<OverlapLayoutConfig> = {\n-  baseWidthPercent: 80,\n-  offsetStepPercent: 8,\n   baseZIndex: 60,\n   safetyMarginPercent: 0.5,\n+  minWidthPercent: 25,\n+  curveExponent: 1.3,\n };\n \n+/**\n+ * Calculates variable widths for each event in a cascade based on position\n+ * Leftmost (longest) events get more width, rightmost (shortest) get less width\n+ * Uses anchor points for 2-4 events and smooth easing curve for 5+ events\n+ * \n+ * @param groupSize - Number of overlapping events in the group\n+ * @param minWidthPercent - Minimum width to maintain readability (default 25%)\n+ * @param curveExponent - Easing curve exponent for width distribution (default 1.3)\n+ * @returns Array of width percentages, one for each position in the cascade\n+ */\n+function calculateVariableWidths(\n+  groupSize: number,\n+  minWidthPercent: number,\n+  curveExponent: number\n+): number[] {\n+  if (groupSize <= 1) {\n+    return [100]; // Single event gets full width (100%)\n+  }\n+  \n+  // Define anchor points for first and last widths based on group size\n+  let wFirst: number;\n+  let wLast: number;\n+  \n+  if (groupSize === 2) {\n+    wFirst = 80;\n+    wLast = 50;\n+  } else if (groupSize === 3) {\n+    wFirst = 55;\n+    wLast = 33;\n+  } else if (groupSize === 4) {\n+    wFirst = 40;\n+    wLast = 25;\n+  } else {\n+    wFirst = Math.max(30, 40 - 3 * (groupSize - 4));\n+    wLast = minWidthPercent;\n+  }\n+  \n+  const widths: number[] = [];\n+  for (let i = 0; i < groupSize; i++) {\n+    const t = groupSize > 1 ? i / (groupSize - 1) : 0;\n+    const easedT = Math.pow(1 - t, curveExponent);\n+    const width = wLast + (wFirst - wLast) * easedT;\n+    widths.push(Math.max(minWidthPercent, width));\n+  }\n+  \n+  return widths;\n+}\n+\n /**\n  * Rounds a number to 3 decimal places using standard rounding\n  */\n@@ -95,14 +143,13 @@ export function buildOverlapGroups(sortedEvents: CalendarEvent[]): CalendarEvent\n \n /**\n  * Calculates layout information for all events including position and z-index\n- * Dynamically adjusts offset step to prevent overflow when many events overlap\n- * Uses safety margin and floor rounding to guarantee no overflow even with CSS box model effects\n+ * Uses variable widths and spreads events across full width with last event aligned to right edge\n  */\n export function calculateEventLayouts(\n   events: CalendarEvent[],\n   config: OverlapLayoutConfig = {}\n ): EventLayout[] {\n-  const { baseWidthPercent, offsetStepPercent, baseZIndex, safetyMarginPercent } = {\n+  const { baseZIndex, safetyMarginPercent, minWidthPercent, curveExponent } = {\n     ...DEFAULT_CONFIG,\n     ...config,\n   };\n@@ -114,30 +161,43 @@ export function calculateEventLayouts(\n \n   groups.forEach((group, groupIndex) => {\n     const groupSize = group.length;\n-    const allowedOffsetSpace = Math.max(0, 100 - baseWidthPercent - safetyMarginPercent);\n-    const stepUsed = Math.min(\n-      offsetStepPercent,\n-      allowedOffsetSpace / Math.max(1, groupSize - 1)\n-    );\n-\n-    group.forEach((event, indexInGroup) => {\n-      const leftRaw = indexInGroup * stepUsed;\n-      const left = round3(leftRaw);\n-      \n-      const maxWidthCap = 100 - left - safetyMarginPercent;\n-      const widthCap = Math.min(baseWidthPercent, maxWidthCap);\n-      \n-      const width = floor3(Math.max(0, widthCap));\n-\n+    \n+    const widths = calculateVariableWidths(groupSize, minWidthPercent, curveExponent);\n+    const Rmax = 100 - safetyMarginPercent;\n+    \n+    if (groupSize === 1) {\n+      const width = floor3(Math.min(widths[0], Rmax));\n       layouts.push({\n-        event,\n-        leftOffsetPercent: left,\n+        event: group[0],\n+        leftOffsetPercent: 0,\n         widthPercent: width,\n-        baseZIndex: baseZIndex + indexInGroup,\n+        baseZIndex: baseZIndex,\n         groupIndex,\n-        indexInGroup,\n+        indexInGroup: 0,\n       });\n-    });\n+    } else {\n+      const Rmin = widths[0];\n+      \n+      group.forEach((event, indexInGroup) => {\n+        const t = indexInGroup / (groupSize - 1);\n+        const ri = Rmin + (Rmax - Rmin) * t;\n+        const leftRaw = ri - widths[indexInGroup];\n+        const left = round3(leftRaw);\n+        \n+        const maxWidthCap = Rmax - left;\n+        const widthCap = Math.min(widths[indexInGroup], maxWidthCap);\n+        const width = floor3(Math.max(0, widthCap));\n+\n+        layouts.push({\n+          event,\n+          leftOffsetPercent: left,\n+          widthPercent: width,\n+          baseZIndex: baseZIndex + indexInGroup,\n+          groupIndex,\n+          indexInGroup,\n+        });\n+      });\n+    }\n   });\n \n   return layouts;\n"}
{"instance_id": "calcom__cal.com.main.25291", "repo": "calcom/cal.com", "base_commit": "1578dee6223806d7b70d6cbb721e8cae9a3406d7", "head_commit": "1f453db4980de963bfe0e078ebd95a0394aa61c3", "title": "feat: Ensure teams with conflicting slugs owned by the user are migrated(handled in backend, frontend already had this restriction)", "merged_at": "2025-11-22T09:07:28Z", "html_url": "https://github.com/calcom/cal.com/pull/25291", "test_files": ["packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts", "packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts"], "code_files": ["packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts", "packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts", "packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts", "packages/features/ee/teams/repositories/TeamRepository.ts", "packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts"], "total_changes": 377, "num_files": 7, "pull_number": 25291, "patch": "diff --git a/packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts b/packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts\nindex 362f39fae50fd8..aec24735655b78 100644\n--- a/packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts\n+++ b/packages/features/ee/organizations/lib/service/onboarding/BaseOnboardingService.ts\n@@ -9,6 +9,7 @@ import {\n   setupDomain,\n } from \"@calcom/features/ee/organizations/lib/server/orgCreationUtils\";\n import { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\n+import { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n import { DEFAULT_SCHEDULE, getAvailabilityFromSchedule } from \"@calcom/lib/availability\";\n import { WEBAPP_URL } from \"@calcom/lib/constants\";\n@@ -143,8 +144,52 @@ export abstract class BaseOnboardingService implements IOrganizationOnboardingSe\n     return organizationOnboarding;\n   }\n \n-  protected filterTeamsAndInvites(teams: TeamInput[] = [], invitedMembers: InvitedMemberInput[] = []) {\n-    const teamsData = teams\n+  private async ensureConflictingSlugTeamIsMigrated(\n+    orgSlug: string,\n+    teams: TeamInput[] = []\n+  ): Promise<TeamInput[]> {\n+    const teamRepository = new TeamRepository(prisma);\n+    const ownedTeams = await teamRepository.findOwnedTeamsByUserId({ userId: this.user.id });\n+\n+    const conflictingTeam = ownedTeams.find((team) => team.slug === orgSlug);\n+\n+    if (!conflictingTeam) {\n+      return teams;\n+    }\n+\n+    const existingTeam = teams.find((t) => t.id === conflictingTeam.id);\n+\n+    if (existingTeam) {\n+      if (existingTeam.isBeingMigrated) {\n+        return teams;\n+      }\n+\n+      return teams.map((team) =>\n+        team.id === conflictingTeam.id\n+          ? { ...team, isBeingMigrated: true }\n+          : team\n+      );\n+    }\n+\n+    return [\n+      ...teams,\n+      {\n+        id: conflictingTeam.id,\n+        name: conflictingTeam.name,\n+        isBeingMigrated: true,\n+        slug: conflictingTeam.slug,\n+      },\n+    ];\n+  }\n+\n+  protected async buildTeamsAndInvites(\n+    orgSlug: string,\n+    teams: TeamInput[] = [],\n+    invitedMembers: InvitedMemberInput[] = []\n+  ) {\n+    const enrichedTeams = await this.ensureConflictingSlugTeamIsMigrated(orgSlug, teams);\n+\n+    const teamsData = enrichedTeams\n       .filter((team) => team.name.trim().length > 0)\n       .map((team) => ({\n         id: team.id === -1 ? -1 : team.id,\ndiff --git a/packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts b/packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts\nindex f8f059f4c0176c..3b63e0167f48b6 100644\n--- a/packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts\n+++ b/packages/features/ee/organizations/lib/service/onboarding/BillingEnabledOrgOnboardingService.ts\n@@ -43,7 +43,11 @@ export class BillingEnabledOrgOnboardingService extends BaseOnboardingService {\n       })\n     );\n \n-    const { teamsData, invitedMembersData } = this.filterTeamsAndInvites(input.teams, input.invitedMembers);\n+    const { teamsData, invitedMembersData } = await this.buildTeamsAndInvites(\n+      input.slug,\n+      input.teams,\n+      input.invitedMembers\n+    );\n \n     log.debug(\n       \"BillingEnabledOrgOnboardingService - After filterTeamsAndInvites\",\ndiff --git a/packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts b/packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts\nindex 4a85d589ca617b..d87bcf822b2d1c 100644\n--- a/packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts\n+++ b/packages/features/ee/organizations/lib/service/onboarding/SelfHostedOnboardingService.ts\n@@ -28,7 +28,7 @@ const teamsSchema = orgOnboardingTeamsSchema;\n /**\n  * Handles organization onboarding when billing is disabled (self-hosted admin flow).\n  *\n- * Flow:\n+* Flow:\n  * 1. Create onboarding record\n  * 2. Store teams/invites in database\n  * 3. Immediately create organization, teams, and invite members\n@@ -46,8 +46,12 @@ export class SelfHostedOrganizationOnboardingService extends BaseOnboardingServi\n       })\n     );\n \n-    // Step 1: Filter and normalize teams/invites\n-    const { teamsData, invitedMembersData } = this.filterTeamsAndInvites(input.teams, input.invitedMembers);\n+    // Step 1: Build and validate teams/invites (includes conflict slug detection)\n+    const { teamsData, invitedMembersData } = await this.buildTeamsAndInvites(\n+      input.slug,\n+      input.teams,\n+      input.invitedMembers\n+    );\n \n     // Step 2: Create onboarding record with ALL data at once\n     const organizationOnboarding = await this.createOnboardingRecord({\ndiff --git a/packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts b/packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts\nindex 96d02fe588d4e0..6823792acf7866 100644\n--- a/packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts\n+++ b/packages/features/ee/organizations/lib/service/onboarding/__tests__/BaseOnboardingService.test.ts\n@@ -1,24 +1,35 @@\n-import { describe, expect, it } from \"vitest\";\n+import { describe, expect, it, vi } from \"vitest\";\n \n+import type { User } from \"@calcom/prisma/client\";\n import { UserPermissionRole } from \"@calcom/prisma/enums\";\n \n+vi.mock(\"@calcom/features/ee/teams/repositories/TeamRepository\", () => ({\n+  TeamRepository: class {\n+    constructor() {}\n+    findOwnedTeamsByUserId(_: { userId: number }) {\n+      return Promise.resolve([]);\n+    }\n+  },\n+}));\n+\n import { BaseOnboardingService } from \"../BaseOnboardingService\";\n-import type { CreateOnboardingIntentInput } from \"../types\";\n+import type { CreateOnboardingIntentInput, OnboardingIntentResult } from \"../types\";\n \n class TestableBaseOnboardingService extends BaseOnboardingService {\n-  async createOnboardingIntent(input: CreateOnboardingIntentInput): Promise<any> {\n+  async createOnboardingIntent(_input: CreateOnboardingIntentInput): Promise<OnboardingIntentResult> {\n     throw new Error(\"Not implemented\");\n   }\n \n-  public testFilterTeamsAndInvites(\n+  public async testBuildTeamsAndInvites(\n+    orgSlug: string,\n     teams: CreateOnboardingIntentInput[\"teams\"],\n     invitedMembers: CreateOnboardingIntentInput[\"invitedMembers\"]\n   ) {\n-    return this.filterTeamsAndInvites(teams, invitedMembers);\n+    return this.buildTeamsAndInvites(orgSlug, teams, invitedMembers);\n   }\n }\n \n-const mockUser = {\n+const mockUser: Pick<User, \"id\" | \"email\" | \"role\" | \"name\"> = {\n   id: 1,\n   email: \"user@example.com\",\n   role: UserPermissionRole.USER,\n@@ -26,9 +37,9 @@ const mockUser = {\n };\n \n describe(\"BaseOnboardingService\", () => {\n-  describe(\"filterTeamsAndInvites\", () => {\n-    it(\"should filter out invites with empty emails\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+  describe(\"buildTeamsAndInvites\", () => {\n+    it(\"should filter out invites with empty emails\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const invites = [\n         { email: \"valid@example.com\", teamName: \"Marketing\", role: \"MEMBER\" },\n@@ -37,7 +48,7 @@ describe(\"BaseOnboardingService\", () => {\n         { email: \"another@example.com\", teamName: \"Design\", role: \"MEMBER\" },\n       ];\n \n-      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n+      const { invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", [], invites);\n \n       expect(invitedMembersData).toHaveLength(2);\n       expect(invitedMembersData).toEqual([\n@@ -58,8 +69,8 @@ describe(\"BaseOnboardingService\", () => {\n       ]);\n     });\n \n-    it(\"should preserve all fields from invites including role\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should preserve all fields from invites including role\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const invites = [\n         {\n@@ -78,7 +89,7 @@ describe(\"BaseOnboardingService\", () => {\n         },\n       ];\n \n-      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n+      const { invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", [], invites);\n \n       expect(invitedMembersData).toEqual([\n         {\n@@ -98,15 +109,15 @@ describe(\"BaseOnboardingService\", () => {\n       ]);\n     });\n \n-    it(\"should handle invites without optional fields\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should handle invites without optional fields\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const invites = [\n         { email: \"minimal@example.com\" },\n         { email: \"withteam@example.com\", teamName: \"Sales\" },\n       ];\n \n-      const { invitedMembersData } = service.testFilterTeamsAndInvites([], invites);\n+      const { invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", [], invites);\n \n       expect(invitedMembersData).toEqual([\n         {\n@@ -126,8 +137,8 @@ describe(\"BaseOnboardingService\", () => {\n       ]);\n     });\n \n-    it(\"should filter out teams with empty names\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should filter out teams with empty names\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const teams = [\n         { id: 1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n@@ -136,7 +147,7 @@ describe(\"BaseOnboardingService\", () => {\n         { id: 4, name: \"Engineering\", isBeingMigrated: true, slug: \"eng\" },\n       ];\n \n-      const { teamsData } = service.testFilterTeamsAndInvites(teams, []);\n+      const { teamsData } = await service.testBuildTeamsAndInvites(\"test-org\", teams, []);\n \n       expect(teamsData).toHaveLength(2);\n       expect(teamsData).toEqual([\n@@ -145,15 +156,15 @@ describe(\"BaseOnboardingService\", () => {\n       ]);\n     });\n \n-    it(\"should preserve team properties including migration status\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should preserve team properties including migration status\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const teams = [\n         { id: -1, name: \"New Team\", isBeingMigrated: false, slug: null },\n         { id: 42, name: \"Existing Team\", isBeingMigrated: true, slug: \"existing-team\" },\n       ];\n \n-      const { teamsData } = service.testFilterTeamsAndInvites(teams, []);\n+      const { teamsData } = await service.testBuildTeamsAndInvites(\"test-org\", teams, []);\n \n       expect(teamsData).toEqual([\n         { id: -1, name: \"New Team\", isBeingMigrated: false, slug: null },\n@@ -161,26 +172,26 @@ describe(\"BaseOnboardingService\", () => {\n       ]);\n     });\n \n-    it(\"should handle empty teams and invites arrays\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should handle empty teams and invites arrays\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n-      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites([], []);\n+      const { teamsData, invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", [], []);\n \n       expect(teamsData).toEqual([]);\n       expect(invitedMembersData).toEqual([]);\n     });\n \n-    it(\"should handle undefined teams and invites\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should handle undefined teams and invites\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n-      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(undefined, undefined);\n+      const { teamsData, invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", undefined, undefined);\n \n       expect(teamsData).toEqual([]);\n       expect(invitedMembersData).toEqual([]);\n     });\n \n-    it(\"should preserve invites with teamId=-1 for new teams\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should preserve invites with teamId=-1 for new teams\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const teams = [\n         { id: -1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n@@ -192,7 +203,7 @@ describe(\"BaseOnboardingService\", () => {\n         { email: \"user2@example.com\", teamId: -1, teamName: \"Sales\", role: \"ADMIN\" },\n       ];\n \n-      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(teams, invites);\n+      const { teamsData, invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", teams, invites);\n \n       expect(teamsData).toHaveLength(2);\n       expect(invitedMembersData).toHaveLength(2);\n@@ -202,8 +213,8 @@ describe(\"BaseOnboardingService\", () => {\n       expect(invitedMembersData[1].role).toBe(\"ADMIN\");\n     });\n \n-    it(\"should handle mixed scenarios with both org-level and team-specific invites\", () => {\n-      const service = new TestableBaseOnboardingService(mockUser as any);\n+    it(\"should handle mixed scenarios with both org-level and team-specific invites\", async () => {\n+      const service = new TestableBaseOnboardingService(mockUser);\n \n       const teams = [\n         { id: -1, name: \"Marketing\", isBeingMigrated: false, slug: null },\n@@ -216,7 +227,7 @@ describe(\"BaseOnboardingService\", () => {\n         { email: \"eng@example.com\", teamName: \"Engineering\", teamId: 42, role: \"ADMIN\" },\n       ];\n \n-      const { teamsData, invitedMembersData } = service.testFilterTeamsAndInvites(teams, invites);\n+      const { teamsData, invitedMembersData } = await service.testBuildTeamsAndInvites(\"test-org\", teams, invites);\n \n       expect(teamsData).toHaveLength(2);\n       expect(invitedMembersData).toHaveLength(3);\ndiff --git a/packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts b/packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts\nindex 1879a9c539c108..d1e878627b6dcd 100644\n--- a/packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts\n+++ b/packages/features/ee/organizations/lib/service/onboarding/__tests__/BillingEnabledOrgOnboardingService.test.ts\n@@ -223,6 +223,181 @@ describe(\"BillingEnabledOrgOnboardingService\", () => {\n       });\n     });\n \n+    it(\"should automatically migrate team with conflicting slug\", async () => {\n+      // Create a team owned by the user with the same slug as the org\n+      const conflictingTeam = await prismock.team.create({\n+        data: {\n+          id: 100,\n+          name: \"Test Org Team\",\n+          slug: \"test-org\", // Same as mockInput.slug\n+        },\n+      });\n+\n+      await prismock.membership.create({\n+        data: {\n+          userId: mockUser.id,\n+          teamId: conflictingTeam.id,\n+          role: MembershipRole.OWNER,\n+          accepted: true,\n+        },\n+      });\n+\n+      const inputWithoutConflictingTeam = {\n+        ...mockInput,\n+        teams: [{ id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null }],\n+      };\n+\n+      await service.createOnboardingIntent(inputWithoutConflictingTeam);\n+\n+      // Verify the conflicting team was automatically added to migration\n+      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teams: expect.arrayContaining([\n+            { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n+            { id: 100, name: \"Test Org Team\", isBeingMigrated: true, slug: \"test-org\" },\n+          ]),\n+        })\n+      );\n+    });\n+\n+    it(\"should mark existing team for migration if slug conflicts\", async () => {\n+      // Create a team owned by the user with the same slug as the org\n+      const conflictingTeam = await prismock.team.create({\n+        data: {\n+          id: 100,\n+          name: \"Test Org Team\",\n+          slug: \"test-org\", // Same as mockInput.slug\n+        },\n+      });\n+\n+      await prismock.membership.create({\n+        data: {\n+          userId: mockUser.id,\n+          teamId: conflictingTeam.id,\n+          role: MembershipRole.OWNER,\n+          accepted: true,\n+        },\n+      });\n+\n+      const inputWithConflictingTeamNotMigrated = {\n+        ...mockInput,\n+        teams: [\n+          { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n+          { id: 100, name: \"Test Org Team\", isBeingMigrated: false, slug: \"test-org\" },\n+        ],\n+      };\n+\n+      await service.createOnboardingIntent(inputWithConflictingTeamNotMigrated);\n+\n+      // Verify the conflicting team was marked for migration\n+      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teams: expect.arrayContaining([\n+            { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n+            { id: 100, name: \"Test Org Team\", isBeingMigrated: true, slug: \"test-org\" },\n+          ]),\n+        })\n+      );\n+    });\n+\n+    it(\"should not duplicate team if already marked for migration with conflicting slug\", async () => {\n+      // Create a team owned by the user with the same slug as the org\n+      const conflictingTeam = await prismock.team.create({\n+        data: {\n+          id: 100,\n+          name: \"Test Org Team\",\n+          slug: \"test-org\", // Same as mockInput.slug\n+        },\n+      });\n+\n+      await prismock.membership.create({\n+        data: {\n+          userId: mockUser.id,\n+          teamId: conflictingTeam.id,\n+          role: MembershipRole.OWNER,\n+          accepted: true,\n+        },\n+      });\n+\n+      const inputWithConflictingTeamAlreadyMigrated = {\n+        ...mockInput,\n+        teams: [\n+          { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n+          { id: 100, name: \"Test Org Team\", isBeingMigrated: true, slug: \"test-org\" },\n+        ],\n+      };\n+\n+      await service.createOnboardingIntent(inputWithConflictingTeamAlreadyMigrated);\n+\n+      // Verify no duplication occurred\n+      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teams: [\n+            { id: -1, name: \"Engineering\", isBeingMigrated: false, slug: null },\n+            { id: 100, name: \"Test Org Team\", isBeingMigrated: true, slug: \"test-org\" },\n+          ],\n+        })\n+      );\n+    });\n+\n+    it(\"should not migrate team with non-conflicting slug\", async () => {\n+      // Create a team owned by the user with a different slug\n+      const nonConflictingTeam = await prismock.team.create({\n+        data: {\n+          id: 100,\n+          name: \"Different Team\",\n+          slug: \"different-team\",\n+        },\n+      });\n+\n+      await prismock.membership.create({\n+        data: {\n+          userId: mockUser.id,\n+          teamId: nonConflictingTeam.id,\n+          role: MembershipRole.OWNER,\n+          accepted: true,\n+        },\n+      });\n+\n+      await service.createOnboardingIntent(mockInput);\n+\n+      // Verify the non-conflicting team was NOT added\n+      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teams: mockInput.teams,\n+        })\n+      );\n+    });\n+\n+    it(\"should only migrate teams where user is OWNER or ADMIN\", async () => {\n+      // Create a team with conflicting slug but user is only a MEMBER\n+      const teamAsMember = await prismock.team.create({\n+        data: {\n+          id: 100,\n+          name: \"Team As Member\",\n+          slug: \"test-org\",\n+        },\n+      });\n+\n+      await prismock.membership.create({\n+        data: {\n+          userId: mockUser.id,\n+          teamId: teamAsMember.id,\n+          role: MembershipRole.MEMBER,\n+          accepted: true,\n+        },\n+      });\n+\n+      await service.createOnboardingIntent(mockInput);\n+\n+      // Verify the team was NOT migrated (user isn't owner/admin)\n+      expect(mockPaymentService.createOrganizationOnboarding).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          teams: mockInput.teams,\n+        })\n+      );\n+    });\n+\n     it(\"should immediately create organization when admin creates org for self\", async () => {\n       vi.spyOn(constants, \"IS_SELF_HOSTED\", \"get\").mockReturnValue(false);\n \ndiff --git a/packages/features/ee/teams/repositories/TeamRepository.ts b/packages/features/ee/teams/repositories/TeamRepository.ts\nindex 293c5a375bb35b..3dc3c99f066906 100644\n--- a/packages/features/ee/teams/repositories/TeamRepository.ts\n+++ b/packages/features/ee/teams/repositories/TeamRepository.ts\n@@ -333,6 +333,35 @@ export class TeamRepository {\n       }));\n   }\n \n+  /**\n+   * Get teams where the user is an OWNER or ADMIN (excludes organizations)\n+   */\n+  async findOwnedTeamsByUserId({ userId }: { userId: number }) {\n+    const memberships = await this.prismaClient.membership.findMany({\n+      where: {\n+        userId: userId,\n+        accepted: true,\n+        role: {\n+          in: [MembershipRole.OWNER, MembershipRole.ADMIN],\n+        },\n+      },\n+      include: {\n+        team: {\n+          select: {\n+            id: true,\n+            name: true,\n+            slug: true,\n+            isOrganization: true,\n+          },\n+        },\n+      },\n+    });\n+\n+    return memberships\n+      .filter((mmship) => !mmship.team.isOrganization)\n+      .map((mmship) => mmship.team);\n+  }\n+\n   async findTeamWithOrganizationSettings(teamId: number) {\n     return await this.prismaClient.team.findUnique({\n       where: { id: teamId },\ndiff --git a/packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts b/packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts\nindex ca7e53d22e5335..03df2789559deb 100644\n--- a/packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts\n+++ b/packages/trpc/server/routers/viewer/teams/listOwnedTeams.handler.ts\n@@ -1,5 +1,5 @@\n+import { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\n import { prisma } from \"@calcom/prisma\";\n-import { MembershipRole } from \"@calcom/prisma/enums\";\n \n import type { TrpcSessionUser } from \"../../../types\";\n \n@@ -10,29 +10,6 @@ type ListOptions = {\n };\n \n export const listOwnedTeamsHandler = async ({ ctx }: ListOptions) => {\n-  const user = await prisma.user.findUnique({\n-    where: {\n-      id: ctx.user.id,\n-    },\n-    select: {\n-      id: true,\n-      teams: {\n-        where: {\n-          accepted: true,\n-          role: {\n-            in: [MembershipRole.OWNER, MembershipRole.ADMIN],\n-          },\n-        },\n-        select: {\n-          team: true,\n-        },\n-      },\n-    },\n-  });\n-\n-  return user?.teams\n-    ?.filter((m) => {\n-      return !m.team.isOrganization;\n-    })\n-    ?.map(({ team }) => team);\n+  const teamRepository = new TeamRepository(prisma);\n+  return await teamRepository.findOwnedTeamsByUserId({ userId: ctx.user.id });\n };\n"}
{"instance_id": "calcom__cal.com.main.25278", "repo": "calcom/cal.com", "base_commit": "dd7f108f08536221a4fc12c900455b192e40ed16", "head_commit": "7d504abf3823ac5718e07835da558f93e845a913", "title": "chore: No more clientside markdown when importing Checkbox", "merged_at": "2025-11-19T18:40:37Z", "html_url": "https://github.com/calcom/cal.com/pull/25278", "test_files": ["packages/ui/components/form/checkbox/Checkbox.test.tsx"], "code_files": ["packages/ui/components/form/checkbox/Checkbox.tsx"], "total_changes": 5, "num_files": 2, "pull_number": 25278, "patch": "diff --git a/packages/ui/components/form/checkbox/Checkbox.test.tsx b/packages/ui/components/form/checkbox/Checkbox.test.tsx\nindex 28bc926568f065..2d0fe1b55f4fbe 100644\n--- a/packages/ui/components/form/checkbox/Checkbox.test.tsx\n+++ b/packages/ui/components/form/checkbox/Checkbox.test.tsx\n@@ -1,4 +1,3 @@\n-/* eslint-disable playwright/missing-playwright-await */\n import { render, fireEvent } from \"@testing-library/react\";\n import React from \"react\";\n import { vi } from \"vitest\";\ndiff --git a/packages/ui/components/form/checkbox/Checkbox.tsx b/packages/ui/components/form/checkbox/Checkbox.tsx\nindex b509bbd2cedd1c..4224e1dd6f54a6 100644\n--- a/packages/ui/components/form/checkbox/Checkbox.tsx\n+++ b/packages/ui/components/form/checkbox/Checkbox.tsx\n@@ -2,8 +2,6 @@ import * as CheckboxPrimitive from \"@radix-ui/react-checkbox\";\n import { useId } from \"@radix-ui/react-id\";\n import type { InputHTMLAttributes } from \"react\";\n import React, { forwardRef } from \"react\";\n-\n-import { markdownToSafeHTML } from \"@calcom/lib/markdownToSafeHTML\";\n import classNames from \"@calcom/ui/classNames\";\n \n import { Icon } from \"../../icon\";\n@@ -100,7 +98,7 @@ const CheckboxField = forwardRef<HTMLInputElement, Props>(\n                       rest.descriptionClassName\n                     )}\n                     dangerouslySetInnerHTML={{\n-                      __html: markdownToSafeHTML(descriptionAsSafeHtml),\n+                      __html: descriptionAsSafeHtml,\n                     }}\n                   />\n                 ) : (\n"}
{"instance_id": "calcom__cal.com.main.25259", "repo": "calcom/cal.com", "base_commit": "81224f324ada684cd47a6be44388447b12dea1f2", "head_commit": "3127f5f09c5077e82d280767d5823026a23b3c70", "title": "fix: OOO days not correctly blocked", "merged_at": "2025-11-25T20:14:05Z", "html_url": "https://github.com/calcom/cal.com/pull/25259", "test_files": ["packages/features/schedules/lib/slots.test.ts"], "code_files": ["packages/features/schedules/lib/slots.ts"], "total_changes": 61, "num_files": 2, "pull_number": 25259, "patch": "diff --git a/packages/features/schedules/lib/slots.test.ts b/packages/features/schedules/lib/slots.test.ts\nindex 35a32a6a1c48cb..1b6c5d56ca19be 100644\n--- a/packages/features/schedules/lib/slots.test.ts\n+++ b/packages/features/schedules/lib/slots.test.ts\n@@ -840,4 +840,60 @@ describe(\"Tests the date-range slot logic with showOptimizedSlots\", () => {\n \n     vi.useRealTimers();\n   });\n+\n+  it(\"should mark slots as away when OOO is on next day and availability extends past midnight\", async () => {\n+    // This test reproduces the bug where:\n+    // - Day 1 has availability from 00:00 to 23:59\n+    // - Day 2 is marked as OOO\n+    // - Slots generated after midnight are not marked as away\n+\n+    vi.setSystemTime(dayjs.utc(\"2025-11-17T00:00:00Z\").toDate());\n+\n+    const day1Start = dayjs.utc(\"2025-11-17T00:00:00Z\");\n+    const day2End = dayjs.utc(\"2025-11-18T23:59:59Z\");\n+\n+    // OOO data for Day 2 (2025-11-18)\n+    const datesOutOfOffice = {\n+      \"2025-11-18\": {\n+        fromUser: { id: 1, displayName: \"Test User\" },\n+        toUser: null,\n+        reason: \"Out of office\",\n+        emoji: \"\ud83c\udfd6\ufe0f\",\n+      },\n+    };\n+\n+    const slots = getSlots({\n+      inviteeDate: day1Start,\n+      frequency: 15,\n+      minimumBookingNotice: 0,\n+      eventLength: 15,\n+      dateRanges: [\n+        {\n+          start: day1Start,\n+          end: day2End,\n+        },\n+      ],\n+      datesOutOfOffice,\n+    });\n+\n+    // Filter slots by day\n+    const day1Slots = slots.filter((slot) => slot.time.format(\"YYYY-MM-DD\") === \"2025-11-17\");\n+    const day2Slots = slots.filter((slot) => slot.time.format(\"YYYY-MM-DD\") === \"2025-11-18\");\n+\n+    // Day 1 slots should NOT be marked as away\n+    day1Slots.forEach((slot) => {\n+      expect(slot.away).toBeUndefined();\n+    });\n+\n+    expect(day2Slots.length).toBeGreaterThan(0);\n+    \n+    // Day 2 slots should be marked as away\n+    day2Slots.forEach((slot) => {\n+      expect(slot.away).toBe(true);\n+      expect(slot.reason).toBe(\"Out of office\");\n+      expect(slot.emoji).toBe(\"\ud83c\udfd6\ufe0f\");\n+    });\n+\n+    vi.useRealTimers();\n+  });\n });\ndiff --git a/packages/features/schedules/lib/slots.ts b/packages/features/schedules/lib/slots.ts\nindex 22c1c1c7df388e..3dc027aafc1e52 100644\n--- a/packages/features/schedules/lib/slots.ts\n+++ b/packages/features/schedules/lib/slots.ts\n@@ -122,7 +122,6 @@ function buildSlotsWithDateRanges({\n   const slotBoundaries = new Map<number, true>();\n \n   orderedDateRanges.forEach((range) => {\n-    const dateYYYYMMDD = range.start.format(\"YYYY-MM-DD\");\n \n     let slotStartTime = range.start.utc().isAfter(startTimeWithMinNotice)\n       ? range.start\n@@ -182,8 +181,8 @@ function buildSlotsWithDateRanges({\n       }\n \n       slotBoundaries.set(slotStartTime.valueOf(), true);\n-\n-      const dateOutOfOfficeExists = datesOutOfOffice?.[dateYYYYMMDD];\n+      const slotDateYYYYMMDD = slotStartTime.format(\"YYYY-MM-DD\");\n+      const dateOutOfOfficeExists = datesOutOfOffice?.[slotDateYYYYMMDD];\n       let slotData: {\n         time: Dayjs;\n         userIds?: number[];\n"}
{"instance_id": "calcom__cal.com.main.25200", "repo": "calcom/cal.com", "base_commit": "f2b2b6e491cbb850a917a50c6a0cb3850ffd156a", "head_commit": "8615d607433bbdfd2071e2ce59501172ac137a8c", "title": "fix: prevent calendar credentials from leaking into video adapter calls", "merged_at": "2025-11-26T00:04:21Z", "html_url": "https://github.com/calcom/cal.com/pull/25200", "test_files": ["packages/features/bookings/lib/EventManager.test.ts"], "code_files": ["packages/features/bookings/lib/EventManager.ts"], "total_changes": 235, "num_files": 2, "pull_number": 25200, "patch": "diff --git a/packages/features/bookings/lib/EventManager.test.ts b/packages/features/bookings/lib/EventManager.test.ts\nindex d334b12fee8f8e..a45fc81a1790e1 100644\n--- a/packages/features/bookings/lib/EventManager.test.ts\n+++ b/packages/features/bookings/lib/EventManager.test.ts\n@@ -2,6 +2,7 @@ import { prisma } from \"@calcom/prisma/__mocks__/prisma\";\n \n import { describe, expect, it, vi, beforeEach } from \"vitest\";\n \n+import { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\n import { symmetricDecrypt } from \"@calcom/lib/crypto\";\n import type { DestinationCalendar } from \"@calcom/prisma/client\";\n import type { CredentialForCalendarService } from \"@calcom/types/Credential\";\n@@ -16,7 +17,14 @@ vi.mock(\"@calcom/lib/crypto\", () => ({\n   symmetricDecrypt: vi.fn(),\n }));\n \n+vi.mock(\"@calcom/features/credentials/repositories/CredentialRepository\", () => ({\n+  CredentialRepository: {\n+    findCredentialForCalendarServiceById: vi.fn(),\n+  },\n+}));\n+\n const mockedSymmetricDecrypt = vi.mocked(symmetricDecrypt);\n+const mockedCredentialRepository = vi.mocked(CredentialRepository);\n \n function buildCalDAVCredential(data: {\n   id: number;\n@@ -57,6 +65,46 @@ function buildDestinationCalendar(data: {\n   };\n }\n \n+function buildCalendarCredential(data: {\n+  id: number;\n+  type?: string;\n+  userId?: number;\n+  delegatedToId?: string | null;\n+}): CredentialForCalendarService {\n+  return {\n+    id: data.id,\n+    type: data.type || \"google_calendar\",\n+    key: {},\n+    userId: data.userId || 1,\n+    user: { email: \"test@example.com\" },\n+    teamId: null,\n+    appId: \"google-calendar\",\n+    invalid: false,\n+    delegatedTo: null,\n+    delegationCredentialId: null,\n+    delegatedToId: data.delegatedToId || null,\n+  };\n+}\n+\n+function buildVideoCredential(data: {\n+  id: number;\n+  type?: string;\n+  userId?: number;\n+}): CredentialForCalendarService {\n+  return {\n+    id: data.id,\n+    type: data.type || \"zoom_video\",\n+    key: {},\n+    userId: data.userId || 1,\n+    user: { email: \"test@example.com\" },\n+    teamId: null,\n+    appId: \"zoom\",\n+    invalid: false,\n+    delegatedTo: null,\n+    delegationCredentialId: null,\n+  };\n+}\n+\n describe(\"EventManager CalDAV credential validation\", () => {\n   let eventManager: EventManager;\n \n@@ -456,3 +504,102 @@ describe(\"EventManager CalDAV credential validation\", () => {\n     });\n   });\n });\n+\n+describe(\"EventManager credential lookup methods\", () => {\n+  let eventManager: EventManager;\n+\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+  });\n+\n+  describe(\"getVideoCredential\", () => {\n+    it(\"returns a cached credential when credentialId matches\", async () => {\n+      const videoCredential = buildVideoCredential({ id: 42, type: \"zoom_video\" });\n+      eventManager = new EventManager({\n+        credentials: [videoCredential],\n+        destinationCalendar: null,\n+      });\n+\n+      const result = await (eventManager as any).getVideoCredential(42, \"zoom_video\");\n+\n+      expect(result).toMatchObject({ id: 42, type: \"zoom_video\" });\n+      expect(mockedCredentialRepository.findCredentialForCalendarServiceById).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"fetches credential from repository when not cached locally\", async () => {\n+      const dbCredential = buildVideoCredential({ id: 7, type: \"zoom_video\" });\n+      eventManager = new EventManager({\n+        credentials: [],\n+        destinationCalendar: null,\n+      });\n+      mockedCredentialRepository.findCredentialForCalendarServiceById.mockResolvedValue(dbCredential as any);\n+\n+      const result = await (eventManager as any).getVideoCredential(7, \"zoom_video\");\n+\n+      expect(result).toEqual(dbCredential);\n+      expect(mockedCredentialRepository.findCredentialForCalendarServiceById).toHaveBeenCalledWith({ id: 7 });\n+    });\n+\n+    it(\"falls back to credential type when credentialId is missing\", async () => {\n+      const zoomCredential = buildVideoCredential({ id: 1, type: \"zoom_video\" });\n+      eventManager = new EventManager({\n+        credentials: [zoomCredential],\n+        destinationCalendar: null,\n+      });\n+\n+      const result = await (eventManager as any).getVideoCredential(null, \"zoom_video\");\n+\n+      expect(result).toMatchObject({ type: \"zoom_video\" });\n+      expect(mockedCredentialRepository.findCredentialForCalendarServiceById).not.toHaveBeenCalled();\n+    });\n+  });\n+\n+  describe(\"getCalendarCredential\", () => {\n+    it(\"prefers delegation credentials when delegationCredentialId is provided\", async () => {\n+      const delegatedCredential = buildCalendarCredential({\n+        id: 10,\n+        delegatedToId: \"delegation-123\",\n+      });\n+      eventManager = new EventManager({\n+        credentials: [delegatedCredential],\n+        destinationCalendar: null,\n+      });\n+\n+      const result = await (eventManager as any).getCalendarCredential(\n+        99,\n+        \"google_calendar\",\n+        \"delegation-123\"\n+      );\n+\n+      expect(result).toMatchObject({ id: 10, delegatedToId: \"delegation-123\" });\n+      expect(mockedCredentialRepository.findCredentialForCalendarServiceById).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"fetches credential from repository when local cache misses\", async () => {\n+      const dbCredential = buildCalendarCredential({ id: 5, type: \"google_calendar\" });\n+      eventManager = new EventManager({\n+        credentials: [],\n+        destinationCalendar: null,\n+      });\n+      mockedCredentialRepository.findCredentialForCalendarServiceById.mockResolvedValue(dbCredential as any);\n+\n+      const result = await (eventManager as any).getCalendarCredential(5, \"google_calendar\");\n+\n+      expect(result).toEqual(dbCredential);\n+      expect(mockedCredentialRepository.findCredentialForCalendarServiceById).toHaveBeenCalledWith({ id: 5 });\n+    });\n+\n+    it(\"falls back to matching credential type when credentialId is absent\", async () => {\n+      const calendarCredential = buildCalendarCredential({ id: 22, type: \"google_calendar\" });\n+      eventManager = new EventManager({\n+        credentials: [calendarCredential],\n+        destinationCalendar: null,\n+      });\n+\n+      const result = await (eventManager as any).getCalendarCredential(null, \"google_calendar\");\n+\n+      expect(result).toMatchObject({ id: 22, type: \"google_calendar\" });\n+      expect(mockedCredentialRepository.findCredentialForCalendarServiceById).not.toHaveBeenCalled();\n+    });\n+  });\n+});\ndiff --git a/packages/features/bookings/lib/EventManager.ts b/packages/features/bookings/lib/EventManager.ts\nindex eda5cf027ea801..4fcffc7e7eeae7 100644\n--- a/packages/features/bookings/lib/EventManager.ts\n+++ b/packages/features/bookings/lib/EventManager.ts\n@@ -509,9 +509,8 @@ export default class EventManager {\n         ? reference.thirdPartyRecurringEventId\n         : reference.uid;\n \n-    const calendarCredential = await this.getCredentialAndWarnIfNotFound(\n+    const calendarCredential = await this.getCalendarCredential(\n       credentialId,\n-      this.calendarCredentials,\n       credentialType,\n       reference.delegationCredentialId\n     );\n@@ -530,51 +529,72 @@ export default class EventManager {\n     log.debug(\"deleteVideoEventForBookingReference\", safeStringify({ bookingVideoReference: reference }));\n     const { uid: bookingRefUid, credentialId } = reference;\n \n-    const videoCredential = await this.getCredentialAndWarnIfNotFound(\n-      credentialId,\n-      this.videoCredentials,\n-      reference.type\n-    );\n+    const videoCredential = await this.getVideoCredential(credentialId, reference.type);\n \n     if (videoCredential) {\n       await deleteMeeting(videoCredential, bookingRefUid);\n     }\n   }\n \n-  private async getCredentialAndWarnIfNotFound(\n+  private async getVideoCredential(\n+    credentialId: number | null | undefined,\n+    type: string\n+  ): Promise<CredentialForCalendarService | null | undefined> {\n+    const credential = this.videoCredentials.find((cred) => cred.id === credentialId);\n+    if (credential) {\n+      return credential;\n+    }\n+\n+    const foundCredential =\n+      typeof credentialId === \"number\" && credentialId > 0\n+        ? await CredentialRepository.findCredentialForCalendarServiceById({ id: credentialId })\n+        : // Fallback for zero or nullish credentialId which could be the case of Global App e.g. dailyVideo\n+          this.videoCredentials.find((cred) => cred.type === type) || null;\n+\n+    if (!foundCredential) {\n+      log.error(\n+        \"getVideoCredential: Could not find video credential\",\n+        safeStringify({\n+          credentialId,\n+          type,\n+          videoCredentialIds: this.videoCredentials.map((cred) => cred.id),\n+        })\n+      );\n+    }\n+\n+    return foundCredential;\n+  }\n+\n+  private async getCalendarCredential(\n     credentialId: number | null | undefined,\n-    credentials: CredentialForCalendarService[],\n     type: string,\n     delegationCredentialId?: string | null\n-  ) {\n+  ): Promise<CredentialForCalendarService | null | undefined> {\n     if (delegationCredentialId) {\n       return this.calendarCredentials.find((cred) => cred.delegatedToId === delegationCredentialId);\n     }\n-    const credential = credentials.find((cred) => cred.id === credentialId);\n+    const credential = this.calendarCredentials.find((cred) => cred.id === credentialId);\n     if (credential) {\n       return credential;\n-    } else {\n-      const credential =\n-        typeof credentialId === \"number\" && credentialId > 0\n-          ? await CredentialRepository.findCredentialForCalendarServiceById({ id: credentialId })\n-          : // Fallback for zero or nullish credentialId which could be the case of Global App e.g. dailyVideo\n-            this.videoCredentials.find((cred) => cred.type === type) ||\n-            this.calendarCredentials.find((cred) => cred.type === type) ||\n-            null;\n-\n-      if (!credential) {\n-        log.error(\n-          \"getCredentialAndWarnIfNotFound: Could not find credential\",\n-          safeStringify({\n-            credentialId,\n-            type,\n-            videoCredentials: this.videoCredentials,\n-          })\n-        );\n-      }\n+    }\n \n-      return credential;\n+    const foundCredential =\n+      typeof credentialId === \"number\" && credentialId > 0\n+        ? await CredentialRepository.findCredentialForCalendarServiceById({ id: credentialId })\n+        : this.calendarCredentials.find((cred) => cred.type === type) || null;\n+\n+    if (!foundCredential) {\n+      log.error(\n+        \"getCalendarCredential: Could not find calendar credential\",\n+        safeStringify({\n+          credentialId,\n+          type,\n+          calendarCredentialIds: this.calendarCredentials.map((cred) => cred.id),\n+        })\n+      );\n     }\n+\n+    return foundCredential;\n   }\n \n   /**\n@@ -994,7 +1014,7 @@ export default class EventManager {\n    * @private\n    */\n \n-  private getVideoCredential(event: CalendarEvent): CredentialForCalendarService | undefined {\n+  private getVideoCredentialByCalendarEvent(event: CalendarEvent): CredentialForCalendarService | undefined {\n     if (!event.location) {\n       return undefined;\n     }\n@@ -1038,7 +1058,7 @@ export default class EventManager {\n    * @private\n    */\n   private async createVideoEvent(event: CalendarEvent) {\n-    const credential = this.getVideoCredential(event);\n+    const credential = this.getVideoCredentialByCalendarEvent(event);\n     if (credential) {\n       return createMeeting(credential, event);\n     } else {\n@@ -1198,7 +1218,7 @@ export default class EventManager {\n    * @private\n    */\n   private async updateVideoEvent(event: CalendarEvent, booking: PartialBooking) {\n-    const credential = this.getVideoCredential(event);\n+    const credential = this.getVideoCredentialByCalendarEvent(event);\n \n     if (credential) {\n       const bookingRef = booking ? booking.references.filter((ref) => ref.type === credential.type)[0] : null;\n"}
{"instance_id": "calcom__cal.com.main.25148", "repo": "calcom/cal.com", "base_commit": "38738c1a3a9cb10c898904c3985b59d85cfdd2bb", "head_commit": "add037715824f1a1657fb4bc8ce23105efa5c8ab", "title": "fix: NextJS does not support non-ascii in NextResponse headers", "merged_at": "2025-11-14T01:27:17Z", "html_url": "https://github.com/calcom/cal.com/pull/25148", "test_files": ["apps/web/middleware.test.ts"], "code_files": ["apps/web/middleware.ts"], "total_changes": 96, "num_files": 2, "pull_number": 25148, "patch": "diff --git a/apps/web/middleware.test.ts b/apps/web/middleware.test.ts\nindex 38edcd5ec43c2a..c76e731b259aa8 100644\n--- a/apps/web/middleware.test.ts\n+++ b/apps/web/middleware.test.ts\n@@ -1,6 +1,6 @@\n // Import mocked functions\n import { get as edgeConfigGet } from \"@vercel/edge-config\";\n-import { NextRequest } from \"next/server\";\n+import { NextRequest, NextResponse } from \"next/server\";\n import type { Mock } from \"vitest\";\n import { describe, it, expect, vi, beforeEach, afterEach } from \"vitest\";\n \n@@ -405,6 +405,56 @@ describe(\"Middleware Integration Tests\", () => {\n     });\n   });\n \n+  describe(\"Header sanitization\", () => {\n+    it(\"sanitizes non-ASCII request header values to prevent Vercel Runtime Malformed Response Header\", async () => {\n+      const spy = vi.spyOn(NextResponse, \"next\");\n+\n+      const req = createTestRequest({\n+        url: `${WEBAPP_URL}/team/test`,\n+        // Next.js will translate request overrides into x-middleware-request-* headers internally\n+        headers: {\n+          \"cf-region\": \"S\u00e3o Paulo\", // contains non-ASCII \"\u00e3\"\n+        },\n+      });\n+\n+      const res = await callMiddleware(req);\n+      expectStatus(res, 200);\n+\n+      // Assert that middleware forwarded sanitized ASCII-only value\n+      const initArg = (spy as unknown as Mock).mock.calls.at(-1)?.[0] as {\n+        request?: { headers?: Headers };\n+      };\n+      expect(initArg?.request?.headers).toBeDefined();\n+\n+      const forwarded = initArg?.request?.headers as Headers;\n+      expect(forwarded.get(\"cf-region\")).toBe(\"Sao Paulo\");\n+\n+      spy.mockRestore();\n+    });\n+\n+    it(\"strips non-ASCII bytes in mojibake values (e.g., 'S\u00c3\u00a3o Paulo' -> 'So Paulo')\", async () => {\n+      const spy = vi.spyOn(NextResponse, \"next\");\n+\n+      const req = createTestRequest({\n+        url: `${WEBAPP_URL}/team/test`,\n+        headers: {\n+          \"cf-region\": \"S\u00c3\u00a3o Paulo\", // mojibake for \"S\u00e3o Paulo\"; includes non-ASCII bytes\n+        },\n+      });\n+\n+      const res = await callMiddleware(req);\n+      expectStatus(res, 200);\n+\n+      const initArg = (spy as unknown as Mock).mock.calls.at(-1)?.[0] as {\n+        request?: { headers?: Headers };\n+      };\n+      const forwarded = initArg?.request?.headers as Headers;\n+      expect(forwarded.get(\"cf-region\")).toBe(\"So Paulo\");\n+\n+      spy.mockRestore();\n+    });\n+  });\n+\n   describe(\"Multiple Features\", () => {\n \n     it(\"should handle embed route with routing forms rewrite\", async () => {\ndiff --git a/apps/web/middleware.ts b/apps/web/middleware.ts\nindex 007ba7311fcf17..433909f7d78a75 100644\n--- a/apps/web/middleware.ts\n+++ b/apps/web/middleware.ts\n@@ -85,6 +85,48 @@ export function checkPostMethod(req: NextRequest) {\n   return null;\n }\n \n+// Vercel/Edge rejects non\u2011ASCII header values (see: https://github.com/vercel/next.js/issues/85631)\n+const isAscii = (s: string) => {\n+  for (let i = 0; i < s.length; i++) if (s.charCodeAt(i) > 0x7f) return false;\n+  return true;\n+};\n+const stripNonAscii = (s: string) => {\n+  let out = \"\";\n+  for (let i = 0; i < s.length; i++) if (s.charCodeAt(i) <= 0x7f) out += s[i];\n+  return out;\n+};\n+const sanitizeRequestHeaders = (headers: Iterable<[string, string]>): Headers => {\n+  const out = new Headers();\n+  for (const [name, raw] of Array.from(headers)) {\n+    if (!isAscii(name)) continue;\n+    let value = raw;\n+    if (!isAscii(value)) {\n+      // Heuristic: if the string contains common mojibake markers (\u00c3: 0xC3, \u00c2: 0xC2),\n+      // prefer a simple strip (avoids introducing spurious ASCII letters like 'A').\n+      let hasMojibakeMarker = false;\n+      for (let i = 0; i < value.length; i++) {\n+        const code = value.charCodeAt(i);\n+        if (code === 0xc3 || code === 0xc2) {\n+          hasMojibakeMarker = true;\n+          break;\n+        }\n+      }\n+\n+      if (hasMojibakeMarker) {\n+        value = stripNonAscii(value);\n+      } else {\n+        try {\n+          value = stripNonAscii(value.normalize(\"NFKD\"));\n+        } catch {\n+          value = stripNonAscii(value);\n+        }\n+      }\n+    }\n+    if (value) out.set(name, value);\n+  }\n+  return out;\n+};\n+\n const isPagePathRequest = (url: URL) => {\n   const isNonPagePathPrefix = /^\\/(?:_next|api)\\//;\n   const isFile = /\\..*$/;\n@@ -145,7 +187,7 @@ const middleware = async (req: NextRequest): Promise<NextResponse<unknown>> => {\n \n   const res = NextResponse.next({\n     request: {\n-      headers: requestHeaders,\n+      headers: sanitizeRequestHeaders(requestHeaders),\n     },\n   });\n \n"}
{"instance_id": "calcom__cal.com.main.25128", "repo": "calcom/cal.com", "base_commit": "9e10dfd77b9f7d301d7512c010514de11201e82b", "head_commit": "94be63f2f9f49623dc3d46368c183ec504e79565", "title": "feat: normalize routing form identifier field with URL-safe format", "merged_at": "2025-11-18T05:54:34Z", "html_url": "https://github.com/calcom/cal.com/pull/25128", "test_files": ["packages/lib/getValidRhfFieldName.test.ts"], "code_files": ["apps/web/app/(use-page-wrapper)/apps/routing-forms/[...pages]/FormEdit.tsx", "packages/app-store/routing-forms/playwright/tests/basic.e2e.ts", "packages/lib/getValidRhfFieldName.ts"], "total_changes": 70, "num_files": 5, "pull_number": 25128, "patch": "diff --git a/apps/web/app/(use-page-wrapper)/apps/routing-forms/[...pages]/FormEdit.tsx b/apps/web/app/(use-page-wrapper)/apps/routing-forms/[...pages]/FormEdit.tsx\nindex 2939aedd26e320..c193242b71088d 100644\n--- a/apps/web/app/(use-page-wrapper)/apps/routing-forms/[...pages]/FormEdit.tsx\n+++ b/apps/web/app/(use-page-wrapper)/apps/routing-forms/[...pages]/FormEdit.tsx\n@@ -8,6 +8,7 @@ import { v4 as uuidv4 } from \"uuid\";\n \n import { FieldTypes } from \"@calcom/app-store/routing-forms/lib/FieldTypes\";\n import type { RoutingFormWithResponseCount } from \"@calcom/app-store/routing-forms/types/types\";\n+import { getFieldIdentifier } from \"@calcom/features/form-builder/utils/getFieldIdentifier\";\n import { useLocale } from \"@calcom/lib/hooks/useLocale\";\n import classNames from \"@calcom/ui/classNames\";\n import { Button } from \"@calcom/ui/components/button\";\n@@ -102,14 +103,25 @@ function Field({\n               required\n               {...hookForm.register(`${hookFieldNamespace}.label`)}\n               onChange={(e) => {\n-                hookForm.setValue(`${hookFieldNamespace}.label`, e.target.value, { shouldDirty: true });\n+                const newLabel = e.target.value;\n+                // Use label from useWatch which is guaranteed to be the previous value\n+                // since useWatch updates reactively (after re-render), not synchronously\n+                const previousLabel = label || \"\";\n+                hookForm.setValue(`${hookFieldNamespace}.label`, newLabel, { shouldDirty: true });\n+                const currentIdentifier = hookForm.getValues(`${hookFieldNamespace}.identifier`);\n+                // Only auto-update identifier if it was auto-generated from the previous label\n+                // This preserves manual identifier changes\n+                const isIdentifierGeneratedFromPreviousLabel = currentIdentifier === getFieldIdentifier(previousLabel);\n+                if (!currentIdentifier || isIdentifierGeneratedFromPreviousLabel) {\n+                  hookForm.setValue(`${hookFieldNamespace}.identifier`, getFieldIdentifier(newLabel), { shouldDirty: true });\n+                }\n               }}\n             />\n           </div>\n           <div className=\"mb-3 w-full\">\n             <TextField\n               disabled={!!router}\n-              label=\"Identifier\"\n+              label={t(\"identifier_url_parameter\")}\n               name={`${hookFieldNamespace}.identifier`}\n               required\n               placeholder={t(\"identifies_name_field\")}\ndiff --git a/apps/web/public/static/locales/en/common.json b/apps/web/public/static/locales/en/common.json\nindex bd4fab2bfe4eb9..ea829758bbe819 100644\n--- a/apps/web/public/static/locales/en/common.json\n+++ b/apps/web/public/static/locales/en/common.json\n@@ -2286,6 +2286,7 @@\n   \"responses_collection_waiting_description\": \"Wait for some time for responses to be collected. You can go and submit the form yourself as well.\",\n   \"this_is_what_your_users_would_see\": \"This is what your users would see\",\n   \"identifies_name_field\": \"Identifies field by this name.\",\n+  \"identifier_url_parameter\": \"Identifier (URL Parameter, i.e.: &what-is-your-name=john-doe)\",\n   \"add_1_option_per_line\": \"Add 1 option per line\",\n   \"select_a_router\": \"Select a router\",\n   \"add_a_new_route\": \"Add a new Route\",\ndiff --git a/packages/app-store/routing-forms/playwright/tests/basic.e2e.ts b/packages/app-store/routing-forms/playwright/tests/basic.e2e.ts\nindex 76b58a5e26db1f..f69b052b15bf58 100644\n--- a/packages/app-store/routing-forms/playwright/tests/basic.e2e.ts\n+++ b/packages/app-store/routing-forms/playwright/tests/basic.e2e.ts\n@@ -271,21 +271,21 @@ test.describe(\"Routing Forms\", () => {\n         label: \"Test Field\",\n       });\n       const queryString =\n-        \"firstField=456&Test Field Number=456&Test Field Single Selection=456&Test Field Multiple Selection=456&Test Field Multiple Selection=789&Test Field Phone=456&Test Field Email=456@example.com\";\n+        \"firstField=456&Test-Field-Number=456&Test-Field-Single-Selection=456&Test-Field-Multiple-Selection=456&Test-Field-Multiple-Selection=789&Test-Field-Phone=456&Test-Field-Email=456@example.com\";\n \n       await gotoRoutingLink({ page, queryString });\n \n-      await page.fill('[data-testid=\"form-field-Test Field Long Text\"]', \"manual-fill\");\n+      await page.fill('[data-testid=\"form-field-Test-Field-Long-Text\"]', \"manual-fill\");\n \n       await expect(page.locator('[data-testid=\"form-field-firstField\"]')).toHaveValue(\"456\");\n-      await expect(page.locator('[data-testid=\"form-field-Test Field Number\"]')).toHaveValue(\"456\");\n+      await expect(page.locator('[data-testid=\"form-field-Test-Field-Number\"]')).toHaveValue(\"456\");\n \n       // TODO: Verify select and multiselect has prefilled values.\n-      // expect(await page.locator(`[data-testid=\"form-field-Test Field Select\"]`).inputValue()).toBe(\"456\");\n-      // expect(await page.locator(`[data-testid=\"form-field-Test Field MultiSelect\"]`).inputValue()).toBe(\"456\");\n+      // expect(await page.locator(`[data-testid=\"form-field-Test-Field-Select\"]`).inputValue()).toBe(\"456\");\n+      // expect(await page.locator(`[data-testid=\"form-field-Test-Field-MultiSelect\"]`).inputValue()).toBe(\"456\");\n \n-      await expect(page.locator('[data-testid=\"form-field-Test Field Phone\"]')).toHaveValue(\"456\");\n-      await expect(page.locator('[data-testid=\"form-field-Test Field Email\"]')).toHaveValue(\n+      await expect(page.locator('[data-testid=\"form-field-Test-Field-Phone\"]')).toHaveValue(\"456\");\n+      await expect(page.locator('[data-testid=\"form-field-Test-Field-Email\"]')).toHaveValue(\n         \"456@example.com\"\n       );\n \n@@ -300,12 +300,12 @@ test.describe(\"Routing Forms\", () => {\n       expect(url.searchParams.get(\"firstField\")).toBe(\"456\");\n \n       // All other params come from prefill URL\n-      expect(url.searchParams.get(\"Test Field Number\")).toBe(\"456\");\n-      expect(url.searchParams.get(\"Test Field Long Text\")).toBe(\"manual-fill\");\n-      expect(url.searchParams.get(\"Test Field Multiple Selection\")).toBe(\"456\");\n-      expect(url.searchParams.getAll(\"Test Field Multiple Selection\")).toMatchObject([\"456\", \"789\"]);\n-      expect(url.searchParams.get(\"Test Field Phone\")).toBe(\"456\");\n-      expect(url.searchParams.get(\"Test Field Email\")).toBe(\"456@example.com\");\n+      expect(url.searchParams.get(\"Test-Field-Number\")).toBe(\"456\");\n+      expect(url.searchParams.get(\"Test-Field-Long-Text\")).toBe(\"manual-fill\");\n+      expect(url.searchParams.get(\"Test-Field-Multiple-Selection\")).toBe(\"456\");\n+      expect(url.searchParams.getAll(\"Test-Field-Multiple-Selection\")).toMatchObject([\"456\", \"789\"]);\n+      expect(url.searchParams.get(\"Test-Field-Phone\")).toBe(\"456\");\n+      expect(url.searchParams.get(\"Test-Field-Email\")).toBe(\"456@example.com\");\n     });\n \n     // TODO: How to install the app just once?\ndiff --git a/packages/lib/getValidRhfFieldName.test.ts b/packages/lib/getValidRhfFieldName.test.ts\nindex 77319cea240598..01c6b113fc9b76 100644\n--- a/packages/lib/getValidRhfFieldName.test.ts\n+++ b/packages/lib/getValidRhfFieldName.test.ts\n@@ -16,11 +16,11 @@ describe(\"getValidRhfFieldName\", () => {\n   });\n \n   // So that user can freely add spaces and any other character iteratively and it gets converted to - and he can add more characters.\n-  // We don't really care about a hyphen in the end\n-  it(\"should not remove dashes from start and end.\", () => {\n-    expect(getValidRhfFieldName(\"hello-there-\")).toEqual(\"hello-there-\");\n+  // Trailing dashes are removed to ensure valid field names\n+  it(\"should remove trailing dashes but keep leading dashes.\", () => {\n+    expect(getValidRhfFieldName(\"hello-there-\")).toEqual(\"hello-there\");\n     expect(getValidRhfFieldName(\"-hello-there\")).toEqual(\"-hello-there\");\n-    expect(getValidRhfFieldName(\"$hello-there-\")).toEqual(\"-hello-there-\");\n+    expect(getValidRhfFieldName(\"$hello-there-\")).toEqual(\"-hello-there\");\n   });\n \n   it(\"should not remove underscore from start and end.\", () => {\n@@ -31,7 +31,8 @@ describe(\"getValidRhfFieldName\", () => {\n \n   it(\"should remove unicode and emoji characters\", () => {\n     expect(getValidRhfFieldName(\"Hello \ud83d\udcda\ud83d\udd6f\ufe0f\u00ae\ufe0f There\")).toEqual(\"Hello---------There\");\n-    expect(getValidRhfFieldName(\"\ud83d\udcda\ud83d\udd6f\ufe0f\u00ae\ufe0f\")).toEqual(\"-------\");\n+    // When all characters are emojis/special chars, they become dashes which are then removed\n+    expect(getValidRhfFieldName(\"\ud83d\udcda\ud83d\udd6f\ufe0f\u00ae\ufe0f\")).toEqual(\"\");\n   });\n \n   it(\"should keep numbers as is\", () => {\n@@ -39,4 +40,18 @@ describe(\"getValidRhfFieldName\", () => {\n     expect(getValidRhfFieldName(\"321hello there123\")).toEqual(\"321hello-there123\");\n     expect(getValidRhfFieldName(\"hello$there\")).toEqual(\"hello-there\");\n   });\n+\n+  it(\"should not modify system field names\", () => {\n+    // System fields should remain unchanged as they don't contain invalid characters or trailing dashes\n+    expect(getValidRhfFieldName(\"name\")).toEqual(\"name\");\n+    expect(getValidRhfFieldName(\"email\")).toEqual(\"email\");\n+    expect(getValidRhfFieldName(\"location\")).toEqual(\"location\");\n+    expect(getValidRhfFieldName(\"title\")).toEqual(\"title\");\n+    expect(getValidRhfFieldName(\"notes\")).toEqual(\"notes\");\n+    expect(getValidRhfFieldName(\"guests\")).toEqual(\"guests\");\n+    expect(getValidRhfFieldName(\"rescheduleReason\")).toEqual(\"rescheduleReason\");\n+    expect(getValidRhfFieldName(\"smsReminderNumber\")).toEqual(\"smsReminderNumber\");\n+    expect(getValidRhfFieldName(\"attendeePhoneNumber\")).toEqual(\"attendeePhoneNumber\");\n+    expect(getValidRhfFieldName(\"aiAgentCallPhoneNumber\")).toEqual(\"aiAgentCallPhoneNumber\");\n+  });\n });\ndiff --git a/packages/lib/getValidRhfFieldName.ts b/packages/lib/getValidRhfFieldName.ts\nindex bb2a38fe2cf547..0749441a6409ea 100644\n--- a/packages/lib/getValidRhfFieldName.ts\n+++ b/packages/lib/getValidRhfFieldName.ts\n@@ -1,5 +1,5 @@\n export const getValidRhfFieldName = (fieldName: string) => {\n   // Remember that any transformation that you do here would run on System Field names as well. So, be careful and avoiding doing anything here that would modify the SystemField names.\n   // e.g. SystemField name currently have uppercases in them. So, no need to lowercase unless absolutely needed.\n-  return fieldName.replace(/[^a-zA-Z0-9-_]/g, \"-\");\n+  return fieldName.replace(/[^a-zA-Z0-9-_]/g, \"-\").replace(/-+$/, \"\");\n };\n"}
{"instance_id": "calcom__cal.com.main.25106", "repo": "calcom/cal.com", "base_commit": "d6f6be7d50c480a08f85ec3423200726e76a7d43", "head_commit": "35a6b94f3c3f295300977e4111967c01b3613c2f", "title": "fix: made show all columns work correctly", "merged_at": "2025-11-15T22:01:01Z", "html_url": "https://github.com/calcom/cal.com/pull/25106", "test_files": ["packages/features/data-table/components/filters/ColumnVisibilityButton.test.tsx"], "code_files": ["packages/features/data-table/components/filters/ColumnVisibilityButton.tsx"], "total_changes": 57, "num_files": 2, "pull_number": 25106, "patch": "diff --git a/packages/features/data-table/components/filters/ColumnVisibilityButton.test.tsx b/packages/features/data-table/components/filters/ColumnVisibilityButton.test.tsx\nnew file mode 100644\nindex 00000000000000..cc701932175331\n--- /dev/null\n+++ b/packages/features/data-table/components/filters/ColumnVisibilityButton.test.tsx\n@@ -0,0 +1,55 @@\n+import { useEffect, useMemo } from \"react\";\n+import { render, screen, fireEvent, waitFor } from \"@testing-library/react\";\n+import { vi } from \"vitest\";\n+import { useReactTable, getCoreRowModel, type Table, type Column } from \"@tanstack/react-table\";\n+\n+import { ColumnVisibilityButton } from \"./ColumnVisibilityButton\";\n+\n+let tableRef: Table<{ a: number; b: number; c: number }> | null = null;\n+\n+const TestWrapper = () => {\n+  const data = useMemo(() => [{ a: 1, b: 2, c: 3 }], []);\n+  const columns = useMemo(\n+    () => [\n+      { accessorKey: \"a\", header: \"A\" },\n+      { accessorKey: \"b\", header: \"B\", enableHiding: true },\n+      { accessorKey: \"c\", header: \"C\", enableHiding: true },\n+    ],\n+    []\n+  );\n+\n+  const table = useReactTable({\n+    data,\n+    columns,\n+    getCoreRowModel: getCoreRowModel(),\n+    initialState: { columnVisibility: { b: false, c: false } },\n+  });\n+\n+  useEffect(() => {\n+    tableRef = table;\n+  }, [table]);\n+\n+  return <ColumnVisibilityButton table={table} />;\n+}\n+\n+describe(\"ColumnVisibilityButton\", () => {\n+  beforeEach(() => {\n+    vi.clearAllMocks();\n+    tableRef = null;\n+  });\n+\n+  it(\"show_all_columns sets all columns visible\", async () => {\n+    render(<TestWrapper />);\n+\n+    fireEvent.click(screen.getByText(\"display\"));\n+\n+    const showAll = await screen.findByText(\"show_all_columns\");\n+    fireEvent.click(showAll);\n+\n+    await waitFor(() => {\n+      expect(tableRef).not.toBeNull();\n+      const allVisible = tableRef!.getAllLeafColumns().every((col: Column<{ a: number; b: number; c: number }, unknown>) => col.getIsVisible());\n+      expect(allVisible).toBe(true);\n+    });\n+  });\n+});\ndiff --git a/packages/features/data-table/components/filters/ColumnVisibilityButton.tsx b/packages/features/data-table/components/filters/ColumnVisibilityButton.tsx\nindex c25894b97f47b9..fc71d0e33e7cd5 100644\n--- a/packages/features/data-table/components/filters/ColumnVisibilityButton.tsx\n+++ b/packages/features/data-table/components/filters/ColumnVisibilityButton.tsx\n@@ -78,7 +78,7 @@ function ColumnVisibilityButtonComponent<TData>(\n           <CommandGroup>\n             <CommandItem\n               onSelect={() => {\n-                allColumns.forEach((column) => column.toggleVisibility(true));\n+                table.toggleAllColumnsVisible(true);\n               }}\n               className={classNames(\n                 buttonClasses({ color: \"secondary\" }),\n"}
{"instance_id": "calcom__cal.com.main.25092", "repo": "calcom/cal.com", "base_commit": "06055729692e4e6df0f1684d94158b75ac7c02bb", "head_commit": "c176be26df30ba98d0841bd4316a58397666b277", "title": "feat: distributed tracing - 3", "merged_at": "2025-12-04T05:51:26Z", "html_url": "https://github.com/calcom/cal.com/pull/25092", "test_files": ["packages/lib/server/getServerErrorFromUnknown.test.ts"], "code_files": ["packages/features/bookings/Booker/components/BookEventForm/BookEventForm.tsx", "packages/features/bookings/Booker/components/hooks/useBookings.ts", "packages/features/bookings/lib/service/RegularBookingService.ts", "packages/lib/server/defaultResponder.ts", "packages/lib/server/getServerErrorFromUnknown.ts"], "total_changes": 234, "num_files": 7, "pull_number": 25092, "patch": "diff --git a/apps/web/public/static/locales/en/common.json b/apps/web/public/static/locales/en/common.json\nindex 8e6eb108fa222e..5abae24f01eb62 100644\n--- a/apps/web/public/static/locales/en/common.json\n+++ b/apps/web/public/static/locales/en/common.json\n@@ -32,6 +32,7 @@\n   \"verify_email_change_success_toast\": \"Updated your email to {{email}}\",\n   \"verify_email_change_failure_toast\": \"Failed to update email.\",\n   \"change_of_email\": \"Verify your new {{appName}} email address\",\n+  \"trace_reference_id\": \"Trace reference ID\",\n   \"change_of_email_toast\": \"We have sent a verification link to {{email}}. We will update your email address once you click this link.\",\n   \"copy_somewhere_safe\": \"Save this API key somewhere safe. You will not be able to view it again.\",\n   \"verify_email_email_body\": \"Please verify your email address by clicking the button below.\",\ndiff --git a/packages/features/bookings/Booker/components/BookEventForm/BookEventForm.tsx b/packages/features/bookings/Booker/components/BookEventForm/BookEventForm.tsx\nindex a9abddc0cb7b0c..49c10637082c67 100644\n--- a/packages/features/bookings/Booker/components/BookEventForm/BookEventForm.tsx\n+++ b/packages/features/bookings/Booker/components/BookEventForm/BookEventForm.tsx\n@@ -323,6 +323,12 @@ const getError = ({\n   return error?.message ? (\n     <>\n       {responseVercelIdHeader ?? \"\"} {t(messageKey, { date, count })}\n+      {error.data?.traceId && (\n+        <div className=\"text-subtle mt-2 text-xs\">\n+          <span className=\"font-medium\">{t(\"trace_reference_id\")}:</span>\n+          <code className=\"ml-1 select-all break-all font-mono\">{error.data.traceId}</code>\n+        </div>\n+      )}\n     </>\n   ) : (\n     <>{t(\"can_you_try_again\")}</>\ndiff --git a/packages/features/bookings/Booker/components/hooks/useBookings.ts b/packages/features/bookings/Booker/components/hooks/useBookings.ts\nindex 37095979b7bf8e..80877bdcfee917 100644\n--- a/packages/features/bookings/Booker/components/hooks/useBookings.ts\n+++ b/packages/features/bookings/Booker/components/hooks/useBookings.ts\n@@ -400,6 +400,7 @@ export const useBookings = ({ event, hashedLink, bookingForm, metadata, isBookin\n \n       const error = err as Error & {\n         data: { rescheduleUid: string; startTime: string; attendees: string[] };\n+        traceId?: string;\n       };\n \n       if (error.message === ErrorCode.BookerLimitExceededReschedule && error.data?.rescheduleUid) {\n@@ -521,6 +522,11 @@ export const useBookings = ({ event, hashedLink, bookingForm, metadata, isBookin\n             : event?.data?.forwardParamsSuccessRedirect,\n       });\n     },\n+    onError: (err, _, ctx) => {\n+      console.error(\"Error creating recurring booking\", err);\n+      // eslint-disable-next-line @calcom/eslint/no-scroll-into-view-embed -- It is only called when user takes an action in embed\n+      bookerFormErrorRef && bookerFormErrorRef.current?.scrollIntoView({ behavior: \"smooth\" });\n+    },\n   });\n \n   const handleBookEvent = useHandleBookEvent({\ndiff --git a/packages/features/bookings/lib/service/RegularBookingService.ts b/packages/features/bookings/lib/service/RegularBookingService.ts\nindex 9201950b05ea74..9b1de598fbc04c 100644\n--- a/packages/features/bookings/lib/service/RegularBookingService.ts\n+++ b/packages/features/bookings/lib/service/RegularBookingService.ts\n@@ -580,7 +580,6 @@ async function handler(\n       throw new HttpError({\n         statusCode: 400,\n         message: \"email_verification_required\",\n-        data: { traceId: traceContext.traceId },\n       });\n     }\n \n@@ -590,7 +589,6 @@ async function handler(\n       throw new HttpError({\n         statusCode: 400,\n         message: \"invalid_verification_code\",\n-        data: { traceId: traceContext.traceId },\n       });\n     }\n   }\n@@ -608,14 +606,12 @@ async function handler(\n     throw new HttpError({\n       statusCode: 404,\n       message: \"event_type_not_found\",\n-      data: { traceId: traceContext.traceId },\n     });\n \n   if (eventType.seatsPerTimeSlot && eventType.recurringEvent) {\n     throw new HttpError({\n       statusCode: 400,\n       message: \"recurring_event_seats_error\",\n-      data: { traceId: traceContext.traceId },\n     });\n   }\n \n@@ -757,7 +753,6 @@ async function handler(\n       throw new HttpError({\n         statusCode: 400,\n         message: \"Missing routingFormResponseId\",\n-        data: { traceId: traceContext.traceId },\n       });\n     }\n     routingFormResponse = await deps.prismaClient.app_RoutingForms_FormResponse.findUnique({\n@@ -1858,7 +1853,6 @@ async function handler(\n       throw new HttpError({\n         statusCode: 409,\n         message: ErrorCode.BookingConflict,\n-        data: { traceId: traceContext.traceId },\n       });\n     }\n     throw err;\n@@ -2105,7 +2099,6 @@ async function handler(\n       const error = {\n         errorCode: \"BookingCreatingMeetingFailed\",\n         message: \"Booking failed\",\n-        data: { traceId: traceContext.traceId },\n       };\n \n       tracingLogger.error(\n@@ -2329,7 +2322,6 @@ async function handler(\n       throw new HttpError({\n         statusCode: 400,\n         message: \"Missing payment credentials\",\n-        data: { traceId: traceContext.traceId },\n       });\n     }\n \ndiff --git a/packages/lib/server/defaultResponder.ts b/packages/lib/server/defaultResponder.ts\nindex 454a1e767395da..f28e9b064d2637 100644\n--- a/packages/lib/server/defaultResponder.ts\n+++ b/packages/lib/server/defaultResponder.ts\n@@ -61,7 +61,7 @@ export function defaultResponder<T>(\n         const statusCode = getHTTPStatusCodeFromError(err);\n         error = new HttpError({ statusCode, message: err.message });\n       } else {\n-        error = getServerErrorFromUnknown(err);\n+        error = getServerErrorFromUnknown(tracedError);\n       }\n       // we don't want to report Bad Request errors to Sentry / console\n       if (!(error.statusCode >= 400 && error.statusCode < 500)) {\ndiff --git a/packages/lib/server/getServerErrorFromUnknown.test.ts b/packages/lib/server/getServerErrorFromUnknown.test.ts\nindex 10996e37e4abf3..b922312b0b61df 100644\n--- a/packages/lib/server/getServerErrorFromUnknown.test.ts\n+++ b/packages/lib/server/getServerErrorFromUnknown.test.ts\n@@ -1,9 +1,14 @@\n+import { Prisma } from \"@calcom/prisma/client\";\n import { describe, expect, test } from \"vitest\";\n+import { ZodError } from \"zod\";\n \n import { ErrorCode } from \"@calcom/lib/errorCodes\";\n import { ErrorWithCode } from \"@calcom/lib/errors\";\n \n+import { TRPCError } from \"@trpc/server\";\n+\n import { HttpError } from \"../http-error\";\n+import { TracedError } from \"../tracing/error\";\n import { getServerErrorFromUnknown } from \"./getServerErrorFromUnknown\";\n \n const test400Codes = [\n@@ -113,6 +118,135 @@ describe(\"getServerErrorFromUnknown\", () => {\n   });\n });\n \n+describe(\"TracedError handling\", () => {\n+  test(\"should extract traceId and tracedData from TracedError\", () => {\n+    const originalError = new Error(\"Original error message\");\n+    const tracedData = { userId: \"123\", operation: \"booking\" };\n+    const traceContext = {\n+      traceId: \"trace_abc123\",\n+      spanId: \"span_123\",\n+      operation: \"test_operation\",\n+    };\n+\n+    const tracedError = new TracedError(originalError, traceContext, tracedData);\n+\n+    const result = getServerErrorFromUnknown(tracedError);\n+\n+    expect(result.statusCode).toBe(500);\n+    expect(result.message).toBe(\"Original error message\");\n+    expect(result.data).toEqual({ ...tracedData, traceId: traceContext.traceId });\n+  });\n+\n+  test(\"should handle TracedError wrapping ErrorWithCode\", () => {\n+    const originalError = new ErrorWithCode(ErrorCode.BookingNotFound, \"Booking not found\");\n+    const tracedData = { bookingId: \"456\" };\n+    const traceContext = {\n+      traceId: \"trace_def456\",\n+      spanId: \"span_456\",\n+      operation: \"booking_lookup\",\n+    };\n+\n+    const tracedError = new TracedError(originalError, traceContext, tracedData);\n+\n+    const result = getServerErrorFromUnknown(tracedError);\n+\n+    expect(result.statusCode).toBe(404);\n+    expect(result.message).toBe(\"Booking not found\");\n+    expect(result.data).toEqual({ ...tracedData, traceId: traceContext.traceId });\n+  });\n+});\n+\n+describe(\"TRPCError handling\", () => {\n+  test(\"should handle TRPCError with BAD_REQUEST\", () => {\n+    const trpcError = new TRPCError({\n+      code: \"BAD_REQUEST\",\n+      message: \"Invalid input data\",\n+    });\n+\n+    const result = getServerErrorFromUnknown(trpcError);\n+\n+    expect(result.statusCode).toBe(400);\n+    expect(result.message).toBe(\"Invalid input data\");\n+    expect(result.data).toBeUndefined();\n+  });\n+\n+  test(\"should handle TracedError wrapping TRPCError\", () => {\n+    const trpcError = new TRPCError({\n+      code: \"NOT_FOUND\",\n+      message: \"Resource not found\",\n+    });\n+    const tracedData = { resourceId: \"789\" };\n+    const traceContext = {\n+      traceId: \"trace_trpc123\",\n+      spanId: \"span_trpc123\",\n+      operation: \"resource_lookup\",\n+    };\n+\n+    const tracedError = new TracedError(trpcError, traceContext, tracedData);\n+\n+    const result = getServerErrorFromUnknown(tracedError);\n+\n+    expect(result.statusCode).toBe(404);\n+    expect(result.message).toBe(\"Resource not found\");\n+    expect(result.data).toEqual({ ...tracedData, traceId: traceContext.traceId });\n+  });\n+});\n+\n+describe(\"ZodError handling\", () => {\n+  test(\"should handle ZodError with validation issues\", () => {\n+    const zodError = new ZodError([\n+      {\n+        code: \"invalid_type\",\n+        expected: \"string\",\n+        received: \"number\",\n+        path: [\"name\"],\n+        message: \"Expected string, received number\",\n+      },\n+    ]);\n+\n+    const result = getServerErrorFromUnknown(zodError);\n+\n+    expect(result.statusCode).toBe(400);\n+    expect(result.message).toBe(\"invalid_type in 'name': Expected string, received number\");\n+    expect(result.cause).toBe(zodError);\n+  });\n+});\n+\n+describe(\"Prisma error handling\", () => {\n+  test(\"should handle Prisma P2025 error (record not found)\", () => {\n+    const prismaError = new Error(\"Record to delete does not exist.\") as any;\n+    prismaError.code = \"P2025\";\n+    prismaError.clientVersion = \"5.0.0\";\n+    Object.setPrototypeOf(prismaError, Prisma.PrismaClientKnownRequestError.prototype);\n+\n+    const result = getServerErrorFromUnknown(prismaError);\n+\n+    expect(result.statusCode).toBe(404);\n+    expect(result.message).toBe(\"Record to delete does not exist.\");\n+    expect(result.cause).toBe(prismaError);\n+  });\n+\n+  test(\"should handle other Prisma errors as 400\", () => {\n+    const prismaError = new Error(\"Foreign key constraint failed\") as any;\n+    prismaError.code = \"P2003\";\n+    prismaError.clientVersion = \"5.0.0\";\n+    Object.setPrototypeOf(prismaError, Prisma.PrismaClientKnownRequestError.prototype);\n+\n+    const result = getServerErrorFromUnknown(prismaError);\n+\n+    expect(result.statusCode).toBe(400);\n+    expect(result.message).toBe(\"Foreign key constraint failed\");\n+  });\n+});\n+\n+test(\"should handle unknown type fallback\", () => {\n+  const result = getServerErrorFromUnknown({ someProperty: \"value\" });\n+\n+  expect(result.statusCode).toBe(500);\n+  expect(result.message).toBe(\"Unhandled error of type 'object'. Please reach out for our customer support.\");\n+  expect(result.data).toBeUndefined();\n+});\n+\n test400Codes.forEach((errorCode) => {\n   test(`${errorCode} should return 400 Bad Request`, () => {\n     const error = new ErrorWithCode(errorCode, `Test message for ${errorCode}`);\ndiff --git a/packages/lib/server/getServerErrorFromUnknown.ts b/packages/lib/server/getServerErrorFromUnknown.ts\nindex 197e7bd07613f2..41ba8e0451bd7d 100644\n--- a/packages/lib/server/getServerErrorFromUnknown.ts\n+++ b/packages/lib/server/getServerErrorFromUnknown.ts\n@@ -5,9 +5,13 @@ import { ErrorCode } from \"@calcom/lib/errorCodes\";\n import { ErrorWithCode } from \"@calcom/lib/errors\";\n import { Prisma } from \"@calcom/prisma/client\";\n \n+import { TRPCError } from \"@trpc/server\";\n+import { getHTTPStatusCodeFromError } from \"@trpc/server/http\";\n+\n import { HttpError } from \"../http-error\";\n import { redactError } from \"../redactError\";\n import { stripeInvalidRequestErrorSchema } from \"../stripe-error\";\n+import { TracedError } from \"../tracing/error\";\n \n function hasName(cause: unknown): cause is { name: string } {\n   return !!cause && typeof cause === \"object\" && \"name\" in cause;\n@@ -40,61 +44,85 @@ function parseZodErrorIssues(issues: ZodIssue[]): string {\n  * For client-side code, use getErrorFromUnknown from @calcom/lib/errors instead.\n  */\n export function getServerErrorFromUnknown(cause: unknown): HttpError {\n+  let traceId: string | undefined;\n+  let tracedData: Record<string, unknown> | undefined;\n+\n+  if (cause instanceof TracedError) {\n+    traceId = cause.traceId;\n+    tracedData = cause.data;\n+    cause = cause.originalError;\n+  }\n+\n+  if (cause instanceof TRPCError) {\n+    const statusCode = getHTTPStatusCodeFromError(cause);\n+    return new HttpError({\n+      statusCode,\n+      message: cause.message,\n+      cause,\n+      data: traceId ? { ...tracedData, traceId } : undefined,\n+    });\n+  }\n   if (isZodError(cause)) {\n     return new HttpError({\n       statusCode: 400,\n       message: parseZodErrorIssues(cause.issues),\n       cause,\n+      data: traceId ? { ...tracedData, traceId } : undefined,\n     });\n   }\n   if (cause instanceof SyntaxError) {\n     return new HttpError({\n       statusCode: 500,\n       message: \"Unexpected error, please reach out for our customer support.\",\n+      cause,\n+      data: traceId ? { ...tracedData, traceId } : undefined,\n     });\n   }\n   if (isPrismaError(cause)) {\n-    return getServerErrorFromPrismaError(cause);\n+    return getServerErrorFromPrismaError(cause, traceId, tracedData);\n   }\n   const parsedStripeError = stripeInvalidRequestErrorSchema.safeParse(cause);\n   if (parsedStripeError.success) {\n-    return getHttpError({ statusCode: 400, cause: parsedStripeError.data });\n+    const stripeErrorObj = new Error(parsedStripeError.data.message || \"Stripe error\");\n+    stripeErrorObj.name = parsedStripeError.data.type || \"StripeInvalidRequestError\";\n+    return getHttpError({ statusCode: 400, cause: stripeErrorObj, traceId, tracedData });\n   }\n   if (cause instanceof ErrorWithCode) {\n     const statusCode = getHttpStatusCode(cause);\n     return new HttpError({\n       statusCode,\n       message: cause.message ?? \"\",\n-      data: cause.data,\n+      data: traceId ? { ...cause.data, ...tracedData, traceId } : cause.data,\n       cause,\n     });\n   }\n   if (cause instanceof HttpError) {\n-    const redactedCause = redactError(cause);\n-    return {\n-      ...redactedCause,\n-      name: cause.name,\n+    const originalData = cause.data;\n+    return new HttpError({\n+      statusCode: cause.statusCode,\n       message: cause.message ?? \"\",\n       cause: cause.cause,\n       url: cause.url,\n-      statusCode: cause.statusCode,\n       method: cause.method,\n-    };\n+      data: traceId ? { ...originalData, ...tracedData, traceId } : originalData,\n+    });\n   }\n   if (cause instanceof Error) {\n     const statusCode = getHttpStatusCode(cause);\n-    return getHttpError({ statusCode, cause });\n+    return getHttpError({ statusCode, cause, traceId, tracedData });\n   }\n   if (typeof cause === \"string\") {\n     return new HttpError({\n       statusCode: 500,\n       message: cause,\n+      data: traceId ? { ...tracedData, traceId } : undefined,\n     });\n   }\n \n   return new HttpError({\n     statusCode: 500,\n     message: `Unhandled error of type '${typeof cause}'. Please reach out for our customer support.`,\n+    data: traceId ? { ...tracedData, traceId } : tracedData,\n   });\n }\n \n@@ -152,14 +180,33 @@ export function getHttpStatusCode(cause: Error | ErrorWithCode): number {\n   }\n }\n \n-function getHttpError<T extends Error>({ statusCode, cause }: { statusCode: number; cause: T }) {\n+function getHttpError<T extends Error>({\n+  statusCode,\n+  cause,\n+  traceId,\n+  tracedData,\n+}: {\n+  statusCode: number;\n+  cause: T;\n+  traceId?: string;\n+  tracedData?: Record<string, unknown>;\n+}) {\n   const redacted = redactError(cause);\n-  return new HttpError({ statusCode, message: redacted.message, cause: redacted });\n+  return new HttpError({\n+    statusCode,\n+    message: redacted.message,\n+    cause: redacted,\n+    data: traceId ? { ...tracedData, traceId } : undefined,\n+  });\n }\n \n-function getServerErrorFromPrismaError(cause: Prisma.PrismaClientKnownRequestError) {\n+function getServerErrorFromPrismaError(\n+  cause: Prisma.PrismaClientKnownRequestError,\n+  traceId?: string,\n+  tracedData?: Record<string, unknown>\n+) {\n   if (cause.code === \"P2025\") {\n-    return getHttpError({ statusCode: 404, cause });\n+    return getHttpError({ statusCode: 404, cause, traceId, tracedData });\n   }\n-  return getHttpError({ statusCode: 400, cause });\n+  return getHttpError({ statusCode: 400, cause, traceId, tracedData });\n }\n"}
{"instance_id": "calcom__cal.com.main.25091", "repo": "calcom/cal.com", "base_commit": "e6e67848b3e350e61ba0bd5752e687e335993092", "head_commit": "d8adaae70d774ecff476ab8b86695665a363220f", "title": "refactor: optimize credit-service imports with lazy loading", "merged_at": "2025-11-12T15:40:51Z", "html_url": "https://github.com/calcom/cal.com/pull/25091", "test_files": ["packages/features/ee/billing/credit-service.test.ts"], "code_files": ["packages/features/ee/billing/credit-service.ts"], "total_changes": 47, "num_files": 2, "pull_number": 25091, "patch": "diff --git a/packages/features/ee/billing/credit-service.test.ts b/packages/features/ee/billing/credit-service.test.ts\nindex b10ff0f493e504..6dfd55ca8268e7 100644\n--- a/packages/features/ee/billing/credit-service.test.ts\n+++ b/packages/features/ee/billing/credit-service.test.ts\n@@ -101,6 +101,20 @@ vi.mock(\"../workflows/lib/reminders/reminderScheduler\", () => ({\n vi.mock(\"@calcom/lib/getOrgIdFromMemberOrTeamId\", () => ({\n   default: vi.fn().mockResolvedValue(null),\n }));\n+vi.mock(\"@calcom/features/ee/billing/stripe-billing-service\", () => {\n+  return {\n+    StripeBillingService: vi.fn().mockImplementation(() => ({\n+      getPrice: async (priceId: string) => {\n+        const stripe = (await import(\"@calcom/features/ee/payments/server/stripe\")).default;\n+        return stripe.prices.retrieve(priceId);\n+      },\n+      checkoutSessionIsPaid: vi.fn(),\n+      handleSubscriptionCancel: vi.fn(),\n+      handleSubscriptionCreation: vi.fn(),\n+      handleSubscriptionUpdate: vi.fn(),\n+    })),\n+  };\n+});\n \n const creditService = new CreditService();\n \ndiff --git a/packages/features/ee/billing/credit-service.ts b/packages/features/ee/billing/credit-service.ts\nindex b3620092331e13..8fa19b40dac6df 100644\n--- a/packages/features/ee/billing/credit-service.ts\n+++ b/packages/features/ee/billing/credit-service.ts\n@@ -1,19 +1,11 @@\n import type { TFunction } from \"i18next\";\n \n import dayjs from \"@calcom/dayjs\";\n-import {\n-  sendCreditBalanceLimitReachedEmails,\n-  sendCreditBalanceLowWarningEmails,\n-} from \"@calcom/emails/billing-email-service\";\n-import { StripeBillingService } from \"@calcom/features/ee/billing/stripe-billing-service\";\n-import { InternalTeamBilling } from \"@calcom/features/ee/billing/teams/internal-team-billing\";\n import { TeamRepository } from \"@calcom/features/ee/teams/repositories/TeamRepository\";\n-import { cancelScheduledMessagesAndScheduleEmails } from \"@calcom/features/ee/workflows/lib/reminders/reminderScheduler\";\n import { MembershipRepository } from \"@calcom/features/membership/repositories/MembershipRepository\";\n import { IS_SMS_CREDITS_ENABLED } from \"@calcom/lib/constants\";\n import getOrgIdFromMemberOrTeamId from \"@calcom/lib/getOrgIdFromMemberOrTeamId\";\n import logger from \"@calcom/lib/logger\";\n-import { getTranslation } from \"@calcom/lib/server/i18n\";\n import { CreditsRepository } from \"@calcom/lib/server/repository/credits\";\n import { prisma, type PrismaTransaction } from \"@calcom/prisma\";\n import { CreditUsageType, CreditType } from \"@calcom/prisma/enums\";\n@@ -474,9 +466,9 @@ export class CreditService {\n       const { totalMonthlyCredits } = await this._getAllCreditsForTeam({ teamId, tx });\n       warningLimit = totalMonthlyCredits * 0.2;\n     } else if (userId) {\n-      const billingService = new StripeBillingService();\n-      const teamMonthlyPrice = await billingService.getPrice(process.env.STRIPE_TEAM_MONTHLY_PRICE_ID || \"\");\n-      const pricePerSeat = teamMonthlyPrice.unit_amount ?? 0;\n+      const billing = (await import(\"@calcom/features/ee/billing\")).default;\n+      const teamMonthlyPrice = await billing.getPrice(process.env.STRIPE_TEAM_MONTHLY_PRICE_ID || \"\");\n+      const pricePerSeat = teamMonthlyPrice?.unit_amount ?? 0;\n       warningLimit = (pricePerSeat / 2) * 0.2;\n     }\n \n@@ -495,6 +487,8 @@ export class CreditService {\n         return null; // user has limit already reached or team has already reached limit this month\n       }\n \n+      const { getTranslation } = await import(\"@calcom/lib/server/i18n\");\n+\n       const teamWithAdmins = creditBalance?.team\n         ? {\n             ...creditBalance.team,\n@@ -591,6 +585,10 @@ export class CreditService {\n \n     try {\n       if (result.type === \"LIMIT_REACHED\") {\n+        const { sendCreditBalanceLimitReachedEmails } = await import(\n+          \"@calcom/emails/billing-email-service\"\n+        );\n+\n         const promises: Promise<unknown>[] = [\n           sendCreditBalanceLimitReachedEmails({\n             team: result.team,\n@@ -602,6 +600,9 @@ export class CreditService {\n         ];\n \n         if (!result.creditFor || result.creditFor === CreditUsageType.SMS) {\n+          const { cancelScheduledMessagesAndScheduleEmails } = await import(\n+            \"@calcom/features/ee/workflows/lib/reminders/reminderScheduler\"\n+          );\n           promises.push(\n             cancelScheduledMessagesAndScheduleEmails({ teamId: result.teamId, userId: result.userId }).catch(\n               (error) => {\n@@ -613,6 +614,7 @@ export class CreditService {\n \n         await Promise.all(promises);\n       } else if (result.type === \"WARNING\") {\n+        const { sendCreditBalanceLowWarningEmails } = await import(\"@calcom/emails/billing-email-service\");\n         await sendCreditBalanceLowWarningEmails({\n           balance: result.balance,\n           team: result.team,\n@@ -653,6 +655,7 @@ export class CreditService {\n \n     if (!team) return 0;\n \n+    const { InternalTeamBilling } = await import(\"@calcom/features/ee/billing/teams/internal-team-billing\");\n     const teamBillingService = new InternalTeamBilling(team);\n     const subscriptionStatus = await teamBillingService.getSubscriptionStatus();\n \n@@ -668,7 +671,7 @@ export class CreditService {\n       return activeMembers * creditsPerSeat;\n     }\n \n-    const billingService = new StripeBillingService();\n+    const billing = (await import(\"@calcom/features/ee/billing\")).default;\n     const priceId = process.env.STRIPE_TEAM_MONTHLY_PRICE_ID;\n \n     if (!priceId) {\n@@ -676,7 +679,11 @@ export class CreditService {\n       return 0;\n     }\n \n-    const monthlyPrice = await billingService.getPrice(priceId);\n+    const monthlyPrice = await billing.getPrice(priceId);\n+    if (!monthlyPrice) {\n+      log.warn(\"Failed to retrieve monthly price\", { teamId, priceId });\n+      return 0;\n+    }\n     const pricePerSeat = monthlyPrice.unit_amount ?? 0;\n     const creditsPerSeat = pricePerSeat * 0.5;\n \n"}
