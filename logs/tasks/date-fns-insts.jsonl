{"repo": "date-fns/date-fns", "pull_number": 3869, "instance_id": "date-fns__date-fns-3869", "issue_numbers": [], "base_commit": "ce317863848601202c7292d1b41c6cae706093dc", "patch": "diff --git a/package-lock.json b/package-lock.json\nindex aaeff73a90..cc3138fb57 100644\n--- a/package-lock.json\n+++ b/package-lock.json\n@@ -14,6 +14,7 @@\n         \"@babel/preset-env\": \"^7.22.10\",\n         \"@babel/preset-typescript\": \"^7.22.5\",\n         \"@date-fns/docs\": \"^0.29.0\",\n+        \"@date-fns/tz\": \"^0.3.3\",\n         \"@date-fns/utc\": \"^1.2.0\",\n         \"@octokit/core\": \"^3.2.5\",\n         \"@size-limit/esbuild\": \"^11.0.1\",\n@@ -1913,6 +1914,12 @@\n         \"date-fns-docs\": \"bin.js\"\n       }\n     },\n+    \"node_modules/@date-fns/tz\": {\n+      \"version\": \"0.3.3\",\n+      \"resolved\": \"https://registry.npmjs.org/@date-fns/tz/-/tz-0.3.3.tgz\",\n+      \"integrity\": \"sha512-M9PpuG2r3mC9/vEnG8EgtWQw8Yu8eJKwv5+47g4OpcGKds3h1YbPr8z6wK2JcY5koFNUmibHvwodJ1NT8mERiQ==\",\n+      \"dev\": true\n+    },\n     \"node_modules/@date-fns/utc\": {\n       \"version\": \"1.2.0\",\n       \"resolved\": \"https://registry.npmjs.org/@date-fns/utc/-/utc-1.2.0.tgz\",\ndiff --git a/package.json b/package.json\nindex 3c322e3b13..0b7552b3c9 100644\n--- a/package.json\n+++ b/package.json\n@@ -6093,6 +6093,7 @@\n     \"@babel/preset-env\": \"^7.22.10\",\n     \"@babel/preset-typescript\": \"^7.22.5\",\n     \"@date-fns/docs\": \"^0.29.0\",\n+    \"@date-fns/tz\": \"^0.3.3\",\n     \"@date-fns/utc\": \"^1.2.0\",\n     \"@octokit/core\": \"^3.2.5\",\n     \"@size-limit/esbuild\": \"^11.0.1\",\ndiff --git a/src/_lib/normalizeDates/index.ts b/src/_lib/normalizeDates/index.ts\nnew file mode 100644\nindex 0000000000..d5afbfcc64\n--- /dev/null\n+++ b/src/_lib/normalizeDates/index.ts\n@@ -0,0 +1,30 @@\n+import { constructFrom } from \"../../constructFrom\";\n+import { type DateFns } from \"../../types.js\";\n+\n+export function normalizeDates(\n+  context: DateFns.ContextFn<Date> | undefined,\n+  ...dates: [DateFns.Arg, DateFns.Arg, DateFns.Arg]\n+): [Date, Date, Date];\n+\n+export function normalizeDates(\n+  context: DateFns.ContextFn<Date> | undefined,\n+  ...dates: [DateFns.Arg, DateFns.Arg]\n+): [Date, Date];\n+\n+export function normalizeDates(\n+  context: DateFns.ContextFn<Date> | undefined,\n+  ...dates: DateFns.Arg[]\n+): Date[];\n+\n+export function normalizeDates(\n+  context: DateFns.ContextFn<Date> | undefined,\n+  ...dates: DateFns.Arg[]\n+) {\n+  const normalize =\n+    context ||\n+    constructFrom.bind(\n+      null,\n+      dates.find((date) => typeof date === \"object\"),\n+    );\n+  return dates.map(normalize);\n+}\ndiff --git a/src/_lib/normalizeInterval/index.ts b/src/_lib/normalizeInterval/index.ts\nnew file mode 100644\nindex 0000000000..1f484908d5\n--- /dev/null\n+++ b/src/_lib/normalizeInterval/index.ts\n@@ -0,0 +1,10 @@\n+import type { Interval, NormalizedInterval, DateFns } from \"../../types.js\";\n+import { normalizeDates } from \"../normalizeDates/index.js\";\n+\n+export function normalizeInterval(\n+  context: DateFns.ContextFn<Date> | undefined,\n+  interval: Interval,\n+): NormalizedInterval<Date> {\n+  const [start, end] = normalizeDates(context, interval.start, interval.end);\n+  return { start, end };\n+}\ndiff --git a/src/add/index.ts b/src/add/index.ts\nindex 9fce4900a0..c14204d13c 100644\n--- a/src/add/index.ts\n+++ b/src/add/index.ts\n@@ -2,32 +2,28 @@ import { addDays } from \"../addDays/index.js\";\n import { addMonths } from \"../addMonths/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n import { toDate } from \"../toDate/index.js\";\n-import type { Duration } from \"../types.js\";\n+import type { DateFns, Duration } from \"../types.js\";\n+\n+/**\n+ * The {@link add} function options.\n+ */\n+export interface AddOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name add\n  * @category Common Helpers\n- * @summary Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.\n+ * @summary Add the specified years, months, weeks, days, hours, minutes, and seconds to the given date.\n  *\n  * @description\n- * Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.\n+ * Add the specified years, months, weeks, days, hours, minutes, and seconds to the given date.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n- * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be added.\n- *\n- * | Key            | Description                        |\n- * |----------------|------------------------------------|\n- * | years          | Amount of years to be added        |\n- * | months         | Amount of months to be added       |\n- * | weeks          | Amount of weeks to be added        |\n- * | days           | Amount of days to be added         |\n- * | hours          | Amount of hours to be added        |\n- * | minutes        | Amount of minutes to be added      |\n- * | seconds        | Amount of seconds to be added      |\n- *\n- * All values default to 0\n+ * @param duration - The object with years, months, weeks, days, hours, minutes, and seconds to be added.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the seconds added\n  *\n@@ -38,16 +34,17 @@ import type { Duration } from \"../types.js\";\n  *   months: 9,\n  *   weeks: 1,\n  *   days: 7,\n- *   hours: 5,\\\\-7\n+ *   hours: 5,\n  *   minutes: 9,\n  *   seconds: 30,\n  * })\n  * //=> Thu Jun 15 2017 15:29:20\n  */\n-export function add<DateType extends Date>(\n+export function add<DateType extends Date, ResultDate extends Date = DateType>(\n   date: DateType | number | string,\n   duration: Duration,\n-): DateType {\n+  options?: AddOptions<ResultDate> | undefined,\n+): ResultDate {\n   const {\n     years = 0,\n     months = 0,\n@@ -59,7 +56,7 @@ export function add<DateType extends Date>(\n   } = duration;\n \n   // Add years and months\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const dateWithMonths =\n     months || years ? addMonths(_date, months + years * 12) : _date;\n \n@@ -67,11 +64,10 @@ export function add<DateType extends Date>(\n   const dateWithDays =\n     days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;\n \n-  // Add days, hours, minutes and seconds\n+  // Add days, hours, minutes, and seconds\n   const minutesToAdd = minutes + hours * 60;\n   const secondsToAdd = seconds + minutesToAdd * 60;\n   const msToAdd = secondsToAdd * 1000;\n-  const finalDate = constructFrom(date, dateWithDays.getTime() + msToAdd);\n \n-  return finalDate;\n+  return constructFrom(options?.in || date, +dateWithDays + msToAdd);\n }\ndiff --git a/src/addBusinessDays/index.ts b/src/addBusinessDays/index.ts\nindex ee1b39578c..17d9d50fb0 100644\n--- a/src/addBusinessDays/index.ts\n+++ b/src/addBusinessDays/index.ts\n@@ -3,6 +3,12 @@ import { isSaturday } from \"../isSaturday/index.js\";\n import { isSunday } from \"../isSunday/index.js\";\n import { isWeekend } from \"../isWeekend/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+/**\n+ * The {@link addBusinessDays} function options.\n+ */\n+export interface AddBusinessDaysOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addBusinessDays\n@@ -13,9 +19,11 @@ import { toDate } from \"../toDate/index.js\";\n  * Add the specified number of business days (mon - fri) to the given date, ignoring weekends.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of business days to be added.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the business days added\n  *\n@@ -24,14 +32,18 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = addBusinessDays(new Date(2014, 8, 1), 10)\n  * //=> Mon Sep 15 2014 00:00:00 (skipped weekend days)\n  */\n-export function addBusinessDays<DateType extends Date>(\n+export function addBusinessDays<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  const _date = toDate(date);\n-  const startedOnWeekend = isWeekend(_date);\n+  options?: AddBusinessDaysOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n+  const startedOnWeekend = isWeekend(_date, options);\n \n-  if (isNaN(amount)) return constructFrom(date, NaN);\n+  if (isNaN(amount)) return constructFrom(options?.in, NaN);\n \n   const hours = _date.getHours();\n   const sign = amount < 0 ? -1 : 1;\n@@ -45,17 +57,19 @@ export function addBusinessDays<DateType extends Date>(\n   // Loops over remaining days\n   while (restDays > 0) {\n     _date.setDate(_date.getDate() + sign);\n-    if (!isWeekend(_date)) restDays -= 1;\n+    if (!isWeekend(_date, options)) restDays -= 1;\n   }\n \n   // If the date is a weekend day and we reduce a dividable of\n   // 5 from it, we land on a weekend date.\n   // To counter this, we add days accordingly to land on the next business day\n-  if (startedOnWeekend && isWeekend(_date) && amount !== 0) {\n+  if (startedOnWeekend && isWeekend(_date, options) && amount !== 0) {\n     // If we're reducing days, we want to add days until we land on a weekday\n     // If we're adding days we want to reduce days until we land on a weekday\n-    if (isSaturday(_date)) _date.setDate(_date.getDate() + (sign < 0 ? 2 : -1));\n-    if (isSunday(_date)) _date.setDate(_date.getDate() + (sign < 0 ? 1 : -2));\n+    if (isSaturday(_date, options))\n+      _date.setDate(_date.getDate() + (sign < 0 ? 2 : -1));\n+    if (isSunday(_date, options))\n+      _date.setDate(_date.getDate() + (sign < 0 ? 1 : -2));\n   }\n \n   // Restore hours to avoid DST lag\ndiff --git a/src/addDays/index.ts b/src/addDays/index.ts\nindex 1b8020f5f8..cc19cd36a0 100644\n--- a/src/addDays/index.ts\n+++ b/src/addDays/index.ts\n@@ -1,5 +1,12 @@\n-import { toDate } from \"../toDate/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n+import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link addDays} function options.\n+ */\n+export interface AddDaysOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addDays\n@@ -10,9 +17,11 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * Add the specified number of days to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of days to be added.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the days added\n  *\n@@ -21,16 +30,20 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * const result = addDays(new Date(2014, 8, 1), 10)\n  * //=> Thu Sep 11 2014 00:00:00\n  */\n-export function addDays<DateType extends Date>(\n+export function addDays<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  const _date = toDate(date);\n-  if (isNaN(amount)) return constructFrom(date, NaN);\n-  if (!amount) {\n-    // If 0 days, no-op to avoid changing times in the hour before end of DST\n-    return _date;\n-  }\n+  options?: AddDaysOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n+  if (isNaN(amount)) return constructFrom(options?.in || date, NaN);\n+\n+  // If 0 days, no-op to avoid changing times in the hour before end of DST\n+  if (!amount) return _date;\n+\n   _date.setDate(_date.getDate() + amount);\n   return _date;\n }\ndiff --git a/src/addHours/index.ts b/src/addHours/index.ts\nindex 63d40c3d34..91cd51d02c 100644\n--- a/src/addHours/index.ts\n+++ b/src/addHours/index.ts\n@@ -1,5 +1,12 @@\n import { addMilliseconds } from \"../addMilliseconds/index.js\";\n import { millisecondsInHour } from \"../constants/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link addHours} function options.\n+ */\n+export interface AddHoursOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addHours\n@@ -10,9 +17,11 @@ import { millisecondsInHour } from \"../constants/index.js\";\n  * Add the specified number of hours to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n- * @param amount - The amount of hours to be added.\n+ * @param amount - The amount of hours to be added\n+ * @param options - An object with options\n  *\n  * @returns The new date with the hours added\n  *\n@@ -21,9 +30,13 @@ import { millisecondsInHour } from \"../constants/index.js\";\n  * const result = addHours(new Date(2014, 6, 10, 23, 0), 2)\n  * //=> Fri Jul 11 2014 01:00:00\n  */\n-export function addHours<DateType extends Date>(\n+export function addHours<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addMilliseconds(date, amount * millisecondsInHour);\n+  options?: AddHoursOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addMilliseconds(date, amount * millisecondsInHour, options);\n }\ndiff --git a/src/addISOWeekYears/index.ts b/src/addISOWeekYears/index.ts\nindex 61d8e7b1e8..7595a48786 100644\n--- a/src/addISOWeekYears/index.ts\n+++ b/src/addISOWeekYears/index.ts\n@@ -1,5 +1,12 @@\n import { getISOWeekYear } from \"../getISOWeekYear/index.js\";\n import { setISOWeekYear } from \"../setISOWeekYear/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link addISOWeekYears} function options.\n+ */\n+export interface AddISOWeekYearsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addISOWeekYears\n@@ -15,17 +22,22 @@ import { setISOWeekYear } from \"../setISOWeekYear/index.js\";\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of ISO week-numbering years to be added.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the ISO week-numbering years added\n  *\n  * @example\n  * // Add 5 ISO week-numbering years to 2 July 2010:\n  * const result = addISOWeekYears(new Date(2010, 6, 2), 5)\n- * //=> Fri Jn 26 2015 00:00:00\n+ * //=> Fri Jun 26 2015 00:00:00\n  */\n-export function addISOWeekYears<DateType extends Date>(\n+export function addISOWeekYears<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return setISOWeekYear(date, getISOWeekYear(date) + amount);\n+  options?: AddISOWeekYearsOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return setISOWeekYear(date, getISOWeekYear(date, options) + amount, options);\n }\ndiff --git a/src/addMilliseconds/index.ts b/src/addMilliseconds/index.ts\nindex 0b3fe131ac..12f169e157 100644\n--- a/src/addMilliseconds/index.ts\n+++ b/src/addMilliseconds/index.ts\n@@ -1,5 +1,11 @@\n-import { toDate } from \"../toDate/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n+import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+/**\n+ * The {@link addMilliseconds} function options.\n+ */\n+export interface AddMillisecondsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addMilliseconds\n@@ -10,9 +16,11 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * Add the specified number of milliseconds to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of milliseconds to be added.\n+ * @param options - The options object\n  *\n  * @returns The new date with the milliseconds added\n  *\n@@ -21,10 +29,13 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)\n  * //=> Thu Jul 10 2014 12:45:30.750\n  */\n-export function addMilliseconds<DateType extends Date>(\n+export function addMilliseconds<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  const timestamp = +toDate(date);\n-  return constructFrom(date, timestamp + amount);\n+  options?: AddMillisecondsOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return constructFrom(options?.in || date, +toDate(date) + amount);\n }\ndiff --git a/src/addMinutes/index.ts b/src/addMinutes/index.ts\nindex 0b6a0e81b9..609504431d 100644\n--- a/src/addMinutes/index.ts\n+++ b/src/addMinutes/index.ts\n@@ -1,5 +1,12 @@\n-import { addMilliseconds } from \"../addMilliseconds/index.js\";\n+import { toDate } from \"../toDate/index.js\";\n import { millisecondsInMinute } from \"../constants/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link addMinutes} function options.\n+ */\n+export interface AddMinutesOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addMinutes\n@@ -10,9 +17,11 @@ import { millisecondsInMinute } from \"../constants/index.js\";\n  * Add the specified number of minutes to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of minutes to be added.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the minutes added\n  *\n@@ -21,9 +30,15 @@ import { millisecondsInMinute } from \"../constants/index.js\";\n  * const result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)\n  * //=> Thu Jul 10 2014 12:30:00\n  */\n-export function addMinutes<DateType extends Date>(\n+export function addMinutes<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addMilliseconds(date, amount * millisecondsInMinute);\n+  options?: AddMinutesOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n+  _date.setTime(_date.getTime() + amount * millisecondsInMinute);\n+  return _date;\n }\ndiff --git a/src/addMonths/index.ts b/src/addMonths/index.ts\nindex 955ea0ac1f..8a864da624 100644\n--- a/src/addMonths/index.ts\n+++ b/src/addMonths/index.ts\n@@ -1,5 +1,12 @@\n-import { toDate } from \"../toDate/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n+import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link addMonths} function options.\n+ */\n+export interface AddMonthsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addMonths\n@@ -10,9 +17,11 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * Add the specified number of months to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of months to be added.\n+ * @param options - The options object\n  *\n  * @returns The new date with the months added\n  *\n@@ -25,12 +34,16 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * const result = addMonths(new Date(2023, 0, 30), 1)\n  * //=> Tue Feb 28 2023 00:00:00\n  */\n-export function addMonths<DateType extends Date>(\n+export function addMonths<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  const _date = toDate(date);\n-  if (isNaN(amount)) return constructFrom(date, NaN);\n+  options?: AddMonthsOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n+  if (isNaN(amount)) return constructFrom(options?.in || date, NaN);\n   if (!amount) {\n     // If 0 months, no-op to avoid changing times in the hour before end of DST\n     return _date;\n@@ -45,7 +58,7 @@ export function addMonths<DateType extends Date>(\n   // we'll default to the end of the desired month by adding 1 to the desired\n   // month and using a date of 0 to back up one day to the end of the desired\n   // month.\n-  const endOfDesiredMonth = constructFrom(date, _date.getTime());\n+  const endOfDesiredMonth = constructFrom(options?.in || date, _date.getTime());\n   endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);\n   const daysInMonth = endOfDesiredMonth.getDate();\n   if (dayOfMonth >= daysInMonth) {\ndiff --git a/src/addQuarters/index.ts b/src/addQuarters/index.ts\nindex a39c3fcc7f..e00c503f74 100644\n--- a/src/addQuarters/index.ts\n+++ b/src/addQuarters/index.ts\n@@ -1,4 +1,11 @@\n import { addMonths } from \"../addMonths/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link addQuarters} function options.\n+ */\n+export interface AddQuartersOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addQuarters\n@@ -9,21 +16,26 @@ import { addMonths } from \"../addMonths/index.js\";\n  * Add the specified number of year quarters to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of quarters to be added.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the quarters added\n  *\n  * @example\n  * // Add 1 quarter to 1 September 2014:\n  * const result = addQuarters(new Date(2014, 8, 1), 1)\n- * //=> Mon Dec 01 2014 00:00:00\n+ * //=; Mon Dec 01 2014 00:00:00\n  */\n-export function addQuarters<DateType extends Date>(\n+export function addQuarters<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  const months = amount * 3;\n-  return addMonths(date, months);\n+  options?: AddQuartersOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addMonths(date, amount * 3, options);\n }\ndiff --git a/src/addSeconds/index.ts b/src/addSeconds/index.ts\nindex 4a43168a38..ffc5c658a4 100644\n--- a/src/addSeconds/index.ts\n+++ b/src/addSeconds/index.ts\n@@ -1,4 +1,11 @@\n import { addMilliseconds } from \"../addMilliseconds/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link addSeconds} function options.\n+ */\n+export interface AddSecondsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addSeconds\n@@ -9,9 +16,11 @@ import { addMilliseconds } from \"../addMilliseconds/index.js\";\n  * Add the specified number of seconds to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of seconds to be added.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the seconds added\n  *\n@@ -20,9 +29,13 @@ import { addMilliseconds } from \"../addMilliseconds/index.js\";\n  * const result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)\n  * //=> Thu Jul 10 2014 12:45:30\n  */\n-export function addSeconds<DateType extends Date>(\n+export function addSeconds<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addMilliseconds(date, amount * 1000);\n+  options?: AddSecondsOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addMilliseconds(date, amount * 1000, options);\n }\ndiff --git a/src/addWeeks/index.ts b/src/addWeeks/index.ts\nindex 4b76dfd26d..9e3bf220de 100644\n--- a/src/addWeeks/index.ts\n+++ b/src/addWeeks/index.ts\n@@ -1,4 +1,11 @@\n import { addDays } from \"../addDays/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link addWeeks} function options.\n+ */\n+export interface AddWeeksOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addWeeks\n@@ -6,12 +13,14 @@ import { addDays } from \"../addDays/index.js\";\n  * @summary Add the specified number of weeks to the given date.\n  *\n  * @description\n- * Add the specified number of week to the given date.\n+ * Add the specified number of weeks to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of weeks to be added.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the weeks added\n  *\n@@ -20,10 +29,13 @@ import { addDays } from \"../addDays/index.js\";\n  * const result = addWeeks(new Date(2014, 8, 1), 4)\n  * //=> Mon Sep 29 2014 00:00:00\n  */\n-export function addWeeks<DateType extends Date>(\n+export function addWeeks<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  const days = amount * 7;\n-  return addDays(date, days);\n+  options?: AddWeeksOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addDays(date, amount * 7, options);\n }\ndiff --git a/src/addYears/index.ts b/src/addYears/index.ts\nindex 1253072dce..59b006bc76 100644\n--- a/src/addYears/index.ts\n+++ b/src/addYears/index.ts\n@@ -1,4 +1,11 @@\n import { addMonths } from \"../addMonths/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link addYears} function options.\n+ */\n+export interface AddYearsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name addYears\n@@ -9,9 +16,11 @@ import { addMonths } from \"../addMonths/index.js\";\n  * Add the specified number of years to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of years to be added.\n+ * @param options - The options\n  *\n  * @returns The new date with the years added\n  *\n@@ -20,9 +29,13 @@ import { addMonths } from \"../addMonths/index.js\";\n  * const result = addYears(new Date(2014, 8, 1), 5)\n  * //=> Sun Sep 01 2019 00:00:00\n  */\n-export function addYears<DateType extends Date>(\n+export function addYears<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addMonths(date, amount * 12);\n+  options?: AddYearsOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addMonths(date, amount * 12, options);\n }\ndiff --git a/src/areIntervalsOverlapping/index.ts b/src/areIntervalsOverlapping/index.ts\nindex d86a26ac75..24cde1f1c9 100644\n--- a/src/areIntervalsOverlapping/index.ts\n+++ b/src/areIntervalsOverlapping/index.ts\n@@ -1,10 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n-import type { Interval } from \"../types.js\";\n+import type { DateFns, Interval } from \"../types.js\";\n \n /**\n  * The {@link areIntervalsOverlapping} function options.\n  */\n-export interface AreIntervalsOverlappingOptions {\n+export interface AreIntervalsOverlappingOptions\n+  extends DateFns.ContextOptions<Date> {\n   /** Whether the comparison is inclusive or not */\n   inclusive?: boolean;\n }\n@@ -51,13 +52,6 @@ export interface AreIntervalsOverlappingOptions {\n  * // Using the inclusive option:\n  * areIntervalsOverlapping(\n  *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n- *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) }\n- * )\n- * //=> false\n- *\n- * @example\n- * areIntervalsOverlapping(\n- *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n  *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) },\n  *   { inclusive: true }\n  * )\n@@ -69,12 +63,12 @@ export function areIntervalsOverlapping(\n   options?: AreIntervalsOverlappingOptions,\n ): boolean {\n   const [leftStartTime, leftEndTime] = [\n-    +toDate(intervalLeft.start),\n-    +toDate(intervalLeft.end),\n+    +toDate(intervalLeft.start, options?.in),\n+    +toDate(intervalLeft.end, options?.in),\n   ].sort((a, b) => a - b);\n   const [rightStartTime, rightEndTime] = [\n-    +toDate(intervalRight.start),\n-    +toDate(intervalRight.end),\n+    +toDate(intervalRight.start, options?.in),\n+    +toDate(intervalRight.end, options?.in),\n   ].sort((a, b) => a - b);\n \n   if (options?.inclusive)\ndiff --git a/src/clamp/index.ts b/src/clamp/index.ts\nindex ed5dcf25e9..48f5e1bd5a 100644\n--- a/src/clamp/index.ts\n+++ b/src/clamp/index.ts\n@@ -1,11 +1,39 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { max } from \"../max/index.js\";\n import { min } from \"../min/index.js\";\n-import type { Interval } from \"../types.js\";\n+import type { DateFns, Interval } from \"../types.js\";\n+\n+/**\n+ * The {@link clamp} function options.\n+ */\n+export interface ClampOptions<ContextDate extends Date = Date>\n+  extends DateFns.ContextOptions<ContextDate> {}\n+\n+/**\n+ * The {@link clamp} function result type. It resolves the proper data type.\n+ * It uses the first argument date object type, starting from the date argument,\n+ * then the start interval date, and finally the end interval date. If\n+ * a context function is passed, it uses the context function return type.\n+ */\n+export type ClampResult<\n+  DateType extends DateFns.Arg,\n+  IntervalType extends Interval,\n+  Options extends ClampOptions | undefined,\n+> =\n+  Options extends ClampOptions<infer DateType extends Date>\n+    ? DateType\n+    : DateType extends Date\n+      ? DateType\n+      : IntervalType[\"start\"] extends Date\n+        ? IntervalType[\"start\"]\n+        : IntervalType[\"end\"] extends Date\n+          ? IntervalType[\"end\"]\n+          : Date;\n \n /**\n  * @name clamp\n  * @category Interval Helpers\n- * @summary Return a date bounded by the start and the end of the given interval\n+ * @summary Return a date bounded by the start and the end of the given interval.\n  *\n  * @description\n  * Clamps a date to the lower bound with the start of the interval and the upper\n@@ -15,24 +43,43 @@ import type { Interval } from \"../types.js\";\n  * - When the date is greater than the end of the interval, the end is returned.\n  * - Otherwise the date is returned.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - Date argument type.\n+ * @typeParam IntervalType - Interval argument type.\n+ * @typeParam Options - Options type.\n  *\n  * @param date - The date to be bounded\n  * @param interval - The interval to bound to\n+ * @param options - An object with options\n  *\n  * @returns The date bounded by the start and the end of the interval\n  *\n  * @example\n- * // What is Mar, 21, 2021 bounded to an interval starting at Mar, 22, 2021 and ending at Apr, 01, 2021\n+ * // What is Mar 21, 2021 bounded to an interval starting at Mar 22, 2021 and ending at Apr 01, 2021\n  * const result = clamp(new Date(2021, 2, 21), {\n  *   start: new Date(2021, 2, 22),\n  *   end: new Date(2021, 3, 1),\n  * })\n  * //=> Mon Mar 22 2021 00:00:00\n  */\n-export function clamp<DateType extends Date>(\n-  date: DateType | number | string,\n-  interval: Interval,\n-): DateType | Date {\n-  return min([max([date, interval.start]), interval.end]);\n+export function clamp<\n+  DateType extends DateFns.Arg,\n+  IntervalType extends Interval,\n+  Options extends ClampOptions | undefined = undefined,\n+>(\n+  date: DateType,\n+  interval: IntervalType,\n+  options?: Options,\n+): ClampResult<DateType, IntervalType, Options> {\n+  const [date_, start, end] = normalizeDates(\n+    options?.in,\n+    date,\n+    interval.start,\n+    interval.end,\n+  );\n+\n+  return min([max([date_, start], options), end], options) as ClampResult<\n+    DateType,\n+    IntervalType,\n+    Options\n+  >;\n }\ndiff --git a/src/closestIndexTo/index.ts b/src/closestIndexTo/index.ts\nindex 586565857a..52933e76d8 100644\n--- a/src/closestIndexTo/index.ts\n+++ b/src/closestIndexTo/index.ts\n@@ -1,4 +1,5 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n \n /**\n  * @name closestIndexTo\n@@ -8,8 +9,6 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Return an index of the closest date from the array comparing to the given date.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n  * @param dateToCompare - The date to compare with\n  * @param dates - The array to search\n  *\n@@ -26,28 +25,29 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = closestIndexTo(dateToCompare, datesArray)\n  * //=> 1\n  */\n-export function closestIndexTo<DateType extends Date>(\n-  dateToCompare: DateType | number | string,\n-  dates: Array<DateType | number | string>,\n+export function closestIndexTo(\n+  dateToCompare: DateFns.Arg,\n+  dates: DateFns.Arg[],\n ): number | undefined {\n-  const date = toDate(dateToCompare);\n-\n-  if (isNaN(Number(date))) return NaN;\n+  // [TODO] It would be better to return -1 here rather than undefined, as this\n+  // is how JS behaves, but it would be a breaking change, so we need\n+  // to consider it for v4.\n+  const timeToCompare = +toDate(dateToCompare);\n \n-  const timeToCompare = date.getTime();\n+  if (isNaN(timeToCompare)) return NaN;\n \n   let result: number | undefined;\n   let minDistance: number;\n-  dates.forEach(function (dirtyDate, index) {\n-    const currentDate = toDate(dirtyDate);\n+  dates.forEach((date, index) => {\n+    const date_ = toDate(date);\n \n-    if (isNaN(Number(currentDate))) {\n+    if (isNaN(+date_)) {\n       result = NaN;\n       minDistance = NaN;\n       return;\n     }\n \n-    const distance = Math.abs(timeToCompare - currentDate.getTime());\n+    const distance = Math.abs(timeToCompare - +date_);\n     if (result == null || distance < minDistance) {\n       result = index;\n       minDistance = distance;\ndiff --git a/src/closestTo/index.ts b/src/closestTo/index.ts\nindex bf87e632d3..4bffb5c81b 100644\n--- a/src/closestTo/index.ts\n+++ b/src/closestTo/index.ts\n@@ -1,5 +1,32 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n+import { closestIndexTo } from \"../closestIndexTo/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link closestTo} function options.\n+ */\n+export interface ClosestToOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n+\n+/**\n+ * The {@link closestTo} function result type. It resolves the proper data type.\n+ * It uses the first argument date object type, starting from the date argument,\n+ * then the start interval date, and finally the end interval date. If\n+ * a context function is passed, it uses the context function return type.\n+ */\n+export type ClosestToResult<\n+  DateToCompare extends DateFns.Arg,\n+  DatesType extends DateFns.Arg[],\n+  Options extends ClosestToOptions | undefined,\n+> =\n+  Options extends ClosestToOptions<infer DateType extends Date>\n+    ? DateType\n+    : DateToCompare extends Date\n+      ? DateToCompare\n+      : DatesType extends DateFns.Arg<infer DateType>[]\n+        ? DateType\n+        : Date;\n \n /**\n  * @name closestTo\n@@ -9,7 +36,9 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Return a date from the array closest to the given date.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateToCompare - Date to compare argument type.\n+ * @typeParam DatesType - Dates array argument type.\n+ * @typeParam Options - Options type.\n  *\n  * @param dateToCompare - The date to compare with\n  * @param dates - The array to search\n@@ -25,33 +54,30 @@ import { toDate } from \"../toDate/index.js\";\n  * ])\n  * //=> Tue Jan 01 2030 00:00:00\n  */\n-export function closestTo<DateType extends Date>(\n-  dateToCompare: DateType | number | string,\n-  dates: Array<DateType | number | string>,\n-): DateType | undefined {\n-  const date = toDate(dateToCompare);\n-\n-  if (isNaN(Number(date))) return constructFrom(dateToCompare, NaN);\n-\n-  const timeToCompare = date.getTime();\n-\n-  let result: DateType | undefined;\n-  let minDistance: number;\n-  dates.forEach((dirtyDate) => {\n-    const currentDate = toDate(dirtyDate);\n+export function closestTo<\n+  DateToCompare extends DateFns.Arg,\n+  DatesType extends DateFns.Arg[],\n+  Options extends ClosestToOptions | undefined = undefined,\n+>(\n+  dateToCompare: DateToCompare,\n+  dates: DatesType,\n+  options?: Options | undefined,\n+): ClosestToResult<DateToCompare, DatesType, Options> | undefined {\n+  const [dateToCompare_, ...dates_] = normalizeDates(\n+    options?.in,\n+    dateToCompare,\n+    ...dates,\n+  );\n \n-    if (isNaN(Number(currentDate))) {\n-      result = constructFrom(dateToCompare, NaN);\n-      minDistance = NaN;\n-      return;\n-    }\n+  const index = closestIndexTo(dateToCompare_, dates_);\n \n-    const distance = Math.abs(timeToCompare - currentDate.getTime());\n-    if (result == null || distance < minDistance) {\n-      result = currentDate;\n-      minDistance = distance;\n-    }\n-  });\n+  if (typeof index === \"number\" && isNaN(index))\n+    return constructFrom(dateToCompare_, NaN) as ClosestToResult<\n+      DateToCompare,\n+      DatesType,\n+      Options\n+    >;\n \n-  return result;\n+  if (index !== undefined)\n+    return dates_[index] as ClosestToResult<DateToCompare, DatesType, Options>;\n }\ndiff --git a/src/compareAsc/index.ts b/src/compareAsc/index.ts\nindex 0060bec257..398a192dab 100644\n--- a/src/compareAsc/index.ts\n+++ b/src/compareAsc/index.ts\n@@ -34,21 +34,15 @@ import { toDate } from \"../toDate/index.js\";\n  * //   Sun Jul 02 1995 00:00:00\n  * // ]\n  */\n-export function compareAsc<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function compareAsc(\n+  dateLeft: Date | number | string,\n+  dateRight: Date | number | string,\n ): number {\n-  const _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n+  const diff = +toDate(dateLeft) - +toDate(dateRight);\n \n-  const diff = _dateLeft.getTime() - _dateRight.getTime();\n+  if (diff < 0) return -1;\n+  else if (diff > 0) return 1;\n \n-  if (diff < 0) {\n-    return -1;\n-  } else if (diff > 0) {\n-    return 1;\n-    // Return 0 if diff is 0; return NaN if diff is NaN\n-  } else {\n-    return diff;\n-  }\n+  // Return 0 if diff is 0; return NaN if diff is NaN\n+  return diff;\n }\ndiff --git a/src/compareDesc/index.ts b/src/compareDesc/index.ts\nindex 861a7d7b20..912d724e5b 100644\n--- a/src/compareDesc/index.ts\n+++ b/src/compareDesc/index.ts\n@@ -38,17 +38,11 @@ export function compareDesc<DateType extends Date>(\n   dateLeft: DateType | number | string,\n   dateRight: DateType | number | string,\n ): number {\n-  const _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n+  const diff = +toDate(dateLeft) - +toDate(dateRight);\n \n-  const diff = _dateLeft.getTime() - _dateRight.getTime();\n+  if (diff > 0) return -1;\n+  else if (diff < 0) return 1;\n \n-  if (diff > 0) {\n-    return -1;\n-  } else if (diff < 0) {\n-    return 1;\n-    // Return 0 if diff is 0; return NaN if diff is NaN\n-  } else {\n-    return diff;\n-  }\n+  // Return 0 if diff is 0; return NaN if diff is NaN\n+  return diff;\n }\ndiff --git a/src/constants/index.ts b/src/constants/index.ts\nindex b46dab73e2..1d007f3778 100644\n--- a/src/constants/index.ts\n+++ b/src/constants/index.ts\n@@ -201,3 +201,16 @@ export const secondsInMonth = secondsInYear / 12;\n  * @summary Seconds in 1 quarter.\n  */\n export const secondsInQuarter = secondsInMonth * 3;\n+\n+/**\n+ * @constant\n+ * @name constructFromSymbol\n+ * @summary Symbol enabling Date extensions to inherit properties from the reference date.\n+ *\n+ * The symbol is used to enable the `constructFrom` function to construct a date\n+ * using a reference date and a value. It allows to transfer extra properties\n+ * from the reference date to the new date. It's useful for extensions like\n+ * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as\n+ * a constructor argument.\n+ */\n+export const constructFromSymbol = Symbol.for(\"constructDateFrom\");\ndiff --git a/src/constructFrom/index.ts b/src/constructFrom/index.ts\nindex 9649d1b7a0..7e52c173af 100644\n--- a/src/constructFrom/index.ts\n+++ b/src/constructFrom/index.ts\n@@ -1,4 +1,9 @@\n-import type { GenericDateConstructor } from \"../types.js\";\n+import { constructFromSymbol } from \"../constants/index.js\";\n+import type {\n+  ConstructableDate,\n+  DateFns,\n+  GenericDateConstructor,\n+} from \"../types.js\";\n \n /**\n  * @name constructFrom\n@@ -12,6 +17,11 @@ import type { GenericDateConstructor } from \"../types.js\";\n  *\n  * It defaults to `Date` if the passed reference date is a number or a string.\n  *\n+ * Starting from v3.7.0, it allows to construct a date using `[Symbol.for(\"constructDateFrom\")]`\n+ * enabling to transfer extra properties from the reference date to the new date.\n+ * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n+ * that accept a time zone as a constructor argument.\n+ *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n  *\n  * @param date - The reference date to take constructor from\n@@ -30,13 +40,20 @@ import type { GenericDateConstructor } from \"../types.js\";\n  *   );\n  * }\n  */\n-export function constructFrom<DateType extends Date>(\n-  date: DateType | number | string,\n+export function constructFrom<\n+  DateType extends Date | ConstructableDate,\n+  ResultDate extends Date = DateType,\n+>(\n+  date: DateType | number | string | DateFns.ContextFn<ResultDate> | undefined,\n   value: Date | number | string,\n-): DateType {\n-  if (date instanceof Date) {\n-    return new (date.constructor as GenericDateConstructor<DateType>)(value);\n-  } else {\n-    return new Date(value) as DateType;\n-  }\n+): ResultDate {\n+  if (typeof date === \"function\") return date(value);\n+\n+  if (typeof date === \"object\" && constructFromSymbol in date)\n+    return date[constructFromSymbol](value);\n+\n+  if (date instanceof Date)\n+    return new (date.constructor as GenericDateConstructor<ResultDate>)(value);\n+\n+  return new Date(value) as ResultDate;\n }\ndiff --git a/src/constructNow/index.ts b/src/constructNow/index.ts\nindex a248a027b8..b2165ff721 100644\n--- a/src/constructNow/index.ts\n+++ b/src/constructNow/index.ts\n@@ -1,4 +1,5 @@\n import { constructFrom } from \"../constructFrom/index.js\";\n+import { type DateFns } from \"../types.js\";\n \n /**\n  * @name constructNow\n@@ -30,8 +31,11 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  *   return isSameDay(date, constructNow(date));\n  * }\n  */\n-export function constructNow<DateType extends Date>(\n-  date: DateType | number | string,\n-): DateType {\n+export function constructNow<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n+  date: DateType | number | string | DateFns.ContextFn<ResultDate> | undefined,\n+): ResultDate {\n   return constructFrom(date, Date.now());\n }\ndiff --git a/src/daysToWeeks/index.ts b/src/daysToWeeks/index.ts\nindex 05446b816f..f2b7c44fb4 100644\n--- a/src/daysToWeeks/index.ts\n+++ b/src/daysToWeeks/index.ts\n@@ -25,8 +25,7 @@ import { daysInWeek } from \"../constants/index.js\";\n  * //=> 1\n  */\n export function daysToWeeks(days: number): number {\n-  const weeks = days / daysInWeek;\n-  const result = Math.trunc(weeks);\n+  const result = Math.trunc(days / daysInWeek);\n   // Prevent negative zero\n   return result === 0 ? 0 : result;\n }\ndiff --git a/src/differenceInBusinessDays/index.ts b/src/differenceInBusinessDays/index.ts\nindex 5f6478870b..841d26b937 100644\n--- a/src/differenceInBusinessDays/index.ts\n+++ b/src/differenceInBusinessDays/index.ts\n@@ -3,7 +3,14 @@ import { differenceInCalendarDays } from \"../differenceInCalendarDays/index.js\";\n import { isSameDay } from \"../isSameDay/index.js\";\n import { isValid } from \"../isValid/index.js\";\n import { isWeekend } from \"../isWeekend/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInBusinessDays} function options.\n+ */\n+export interface DifferenceInBusinessDaysOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInBusinessDays\n@@ -16,10 +23,9 @@ import { toDate } from \"../toDate/index.js\";\n  * Like `differenceInCalendarDays`, the function removes the times from\n  * the dates before calculating the difference.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - An object with options\n  *\n  * @returns The number of business days\n  *\n@@ -56,28 +62,31 @@ import { toDate } from \"../toDate/index.js\";\n  * )\n  * //=> 0\n  */\n-export function differenceInBusinessDays<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInBusinessDays(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInBusinessDaysOptions | undefined,\n ): number {\n-  const _dateLeft = toDate(dateLeft);\n-  let _dateRight = toDate(dateRight);\n-\n-  if (!isValid(_dateLeft) || !isValid(_dateRight)) return NaN;\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n \n-  const calendarDifference = differenceInCalendarDays(_dateLeft, _dateRight);\n-  const sign = calendarDifference < 0 ? -1 : 1;\n+  if (!isValid(laterDate_) || !isValid(earlierDate_)) return NaN;\n \n-  const weeks = Math.trunc(calendarDifference / 7);\n+  const diff = differenceInCalendarDays(laterDate_, earlierDate_);\n+  const sign = diff < 0 ? -1 : 1;\n+  const weeks = Math.trunc(diff / 7);\n \n   let result = weeks * 5;\n-  _dateRight = addDays(_dateRight, weeks * 7);\n+  let movingDate = addDays(earlierDate_, weeks * 7);\n \n   // the loop below will run at most 6 times to account for the remaining days that don't makeup a full week\n-  while (!isSameDay(_dateLeft, _dateRight)) {\n+  while (!isSameDay(laterDate_, movingDate)) {\n     // sign is used to account for both negative and positive differences\n-    result += isWeekend(_dateRight) ? 0 : sign;\n-    _dateRight = addDays(_dateRight, sign);\n+    result += isWeekend(movingDate, options) ? 0 : sign;\n+    movingDate = addDays(movingDate, sign);\n   }\n \n   // Prevent negative zero\ndiff --git a/src/differenceInCalendarDays/index.ts b/src/differenceInCalendarDays/index.ts\nindex 8fc82ed853..1d2fe3b17f 100644\n--- a/src/differenceInCalendarDays/index.ts\n+++ b/src/differenceInCalendarDays/index.ts\n@@ -1,6 +1,14 @@\n+import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { millisecondsInDay } from \"../constants/index.js\";\n import { startOfDay } from \"../startOfDay/index.js\";\n-import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInCalendarDays} function options.\n+ */\n+export interface DifferenceInCalendarDaysOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInCalendarDays\n@@ -11,10 +19,9 @@ import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMill\n  * Get the number of calendar days between the given dates. This means that the times are removed\n  * from the dates and then the difference in days is calculated.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - The options object\n  *\n  * @returns The number of calendar days\n  *\n@@ -34,20 +41,27 @@ import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMill\n  * )\n  * //=> 1\n  */\n-export function differenceInCalendarDays<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInCalendarDays(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInCalendarDaysOptions | undefined,\n ): number {\n-  const startOfDayLeft = startOfDay(dateLeft);\n-  const startOfDayRight = startOfDay(dateRight);\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+\n+  const laterStartOfDay = startOfDay(laterDate_);\n+  const earlierStartOfDay = startOfDay(earlierDate_);\n \n-  const timestampLeft =\n-    +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft);\n-  const timestampRight =\n-    +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight);\n+  const laterTimestamp =\n+    +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);\n+  const earlierTimestamp =\n+    +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);\n \n   // Round the number of days to the nearest integer because the number of\n   // milliseconds in a day is not constant (e.g. it's different in the week of\n   // the daylight saving time clock shift).\n-  return Math.round((timestampLeft - timestampRight) / millisecondsInDay);\n+  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);\n }\ndiff --git a/src/differenceInCalendarISOWeekYears/index.ts b/src/differenceInCalendarISOWeekYears/index.ts\nindex 7c38fc3589..8c9bced98b 100644\n--- a/src/differenceInCalendarISOWeekYears/index.ts\n+++ b/src/differenceInCalendarISOWeekYears/index.ts\n@@ -1,4 +1,12 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { getISOWeekYear } from \"../getISOWeekYear/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInCalendarISOWeekYears} function options.\n+ */\n+export interface DifferenceInCalendarISOWeekYearsOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInCalendarISOWeekYears\n@@ -10,10 +18,9 @@ import { getISOWeekYear } from \"../getISOWeekYear/index.js\";\n  *\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - An object with options\n  *\n  * @returns The number of calendar ISO week-numbering years\n  *\n@@ -25,9 +32,17 @@ import { getISOWeekYear } from \"../getISOWeekYear/index.js\";\n  * )\n  * //=> 2\n  */\n-export function differenceInCalendarISOWeekYears<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInCalendarISOWeekYears(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInCalendarISOWeekYearsOptions | undefined,\n ): number {\n-  return getISOWeekYear(dateLeft) - getISOWeekYear(dateRight);\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+  return (\n+    getISOWeekYear(laterDate_, options) - getISOWeekYear(earlierDate_, options)\n+  );\n }\ndiff --git a/src/differenceInCalendarISOWeeks/index.ts b/src/differenceInCalendarISOWeeks/index.ts\nindex 1e4234e1e9..189ea0170b 100644\n--- a/src/differenceInCalendarISOWeeks/index.ts\n+++ b/src/differenceInCalendarISOWeeks/index.ts\n@@ -1,6 +1,14 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { millisecondsInWeek } from \"../constants/index.js\";\n import { startOfISOWeek } from \"../startOfISOWeek/index.js\";\n import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInCalendarISOWeeks} function options.\n+ */\n+export interface DifferenceInCalendarISOWeeksOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInCalendarISOWeeks\n@@ -12,10 +20,9 @@ import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMill\n  *\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - An object with options\n  *\n  * @returns The number of calendar ISO weeks\n  *\n@@ -23,16 +30,23 @@ import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMill\n  * // How many calendar ISO weeks are between 6 July 2014 and 21 July 2014?\n  * const result = differenceInCalendarISOWeeks(\n  *   new Date(2014, 6, 21),\n- *   new Date(2014, 6, 6)\n- * )\n+ *   new Date(2014, 6, 6),\n+ * );\n  * //=> 3\n  */\n-export function differenceInCalendarISOWeeks<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInCalendarISOWeeks(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInCalendarISOWeeksOptions | undefined,\n ): number {\n-  const startOfISOWeekLeft = startOfISOWeek(dateLeft);\n-  const startOfISOWeekRight = startOfISOWeek(dateRight);\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+\n+  const startOfISOWeekLeft = startOfISOWeek(laterDate_);\n+  const startOfISOWeekRight = startOfISOWeek(earlierDate_);\n \n   const timestampLeft =\n     +startOfISOWeekLeft - getTimezoneOffsetInMilliseconds(startOfISOWeekLeft);\ndiff --git a/src/differenceInCalendarMonths/index.ts b/src/differenceInCalendarMonths/index.ts\nindex 45f2dcb050..f70b62ca5d 100644\n--- a/src/differenceInCalendarMonths/index.ts\n+++ b/src/differenceInCalendarMonths/index.ts\n@@ -1,4 +1,11 @@\n-import { toDate } from \"../toDate/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInCalendarMonths} function options.\n+ */\n+export interface DifferenceInCalendarMonthsOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInCalendarMonths\n@@ -8,10 +15,9 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Get the number of calendar months between the given dates.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - An object with options\n  *\n  * @returns The number of calendar months\n  *\n@@ -23,15 +29,19 @@ import { toDate } from \"../toDate/index.js\";\n  * )\n  * //=> 8\n  */\n-export function differenceInCalendarMonths<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInCalendarMonths(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInCalendarMonthsOptions | undefined,\n ): number {\n-  const _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n \n-  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();\n-  const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();\n+  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();\n+  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();\n \n-  return yearDiff * 12 + monthDiff;\n+  return yearsDiff * 12 + monthsDiff;\n }\ndiff --git a/src/differenceInCalendarQuarters/index.ts b/src/differenceInCalendarQuarters/index.ts\nindex b38ae8402a..83d6754910 100644\n--- a/src/differenceInCalendarQuarters/index.ts\n+++ b/src/differenceInCalendarQuarters/index.ts\n@@ -1,5 +1,12 @@\n import { getQuarter } from \"../getQuarter/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInCalendarQuarters} function options.\n+ */\n+export interface DifferenceInCalendarQuartersOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInCalendarQuarters\n@@ -9,11 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Get the number of calendar quarters between the given dates.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - An object with options\n  *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n-\n  * @returns The number of calendar quarters\n  *\n  * @example\n@@ -24,15 +30,19 @@ import { toDate } from \"../toDate/index.js\";\n  * )\n  * //=> 3\n  */\n-export function differenceInCalendarQuarters<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInCalendarQuarters(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInCalendarQuartersOptions | undefined,\n ): number {\n-  const _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n \n-  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();\n-  const quarterDiff = getQuarter(_dateLeft) - getQuarter(_dateRight);\n+  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();\n+  const quartersDiff = getQuarter(laterDate_) - getQuarter(earlierDate_);\n \n-  return yearDiff * 4 + quarterDiff;\n+  return yearsDiff * 4 + quartersDiff;\n }\ndiff --git a/src/differenceInCalendarWeeks/index.ts b/src/differenceInCalendarWeeks/index.ts\nindex 8cc4508389..fee91bd54c 100644\n--- a/src/differenceInCalendarWeeks/index.ts\n+++ b/src/differenceInCalendarWeeks/index.ts\n@@ -1,14 +1,17 @@\n+import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { millisecondsInWeek } from \"../constants/index.js\";\n import { startOfWeek } from \"../startOfWeek/index.js\";\n import type { LocalizedOptions, WeekOptions } from \"../types.js\";\n-import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\n+import { type DateFns } from \"../types.js\";\n \n /**\n  * The {@link differenceInCalendarWeeks} function options.\n  */\n export interface DifferenceInCalendarWeeksOptions\n   extends LocalizedOptions<\"options\">,\n-    WeekOptions {}\n+    WeekOptions,\n+    DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInCalendarWeeks\n@@ -18,10 +21,8 @@ export interface DifferenceInCalendarWeeksOptions\n  * @description\n  * Get the number of calendar weeks between the given dates.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n  * @param options - An object with options.\n  *\n  * @returns The number of calendar weeks\n@@ -44,21 +45,24 @@ export interface DifferenceInCalendarWeeksOptions\n  * )\n  * //=> 2\n  */\n-export function differenceInCalendarWeeks<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n-  options?: DifferenceInCalendarWeeksOptions,\n+export function differenceInCalendarWeeks(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInCalendarWeeksOptions | undefined,\n ): number {\n-  const startOfWeekLeft = startOfWeek(dateLeft, options);\n-  const startOfWeekRight = startOfWeek(dateRight, options);\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+\n+  const laterStartOfWeek = startOfWeek(laterDate_, options);\n+  const earlierStartOfWeek = startOfWeek(earlierDate_, options);\n \n-  const timestampLeft =\n-    +startOfWeekLeft - getTimezoneOffsetInMilliseconds(startOfWeekLeft);\n-  const timestampRight =\n-    +startOfWeekRight - getTimezoneOffsetInMilliseconds(startOfWeekRight);\n+  const laterTimestamp =\n+    +laterStartOfWeek - getTimezoneOffsetInMilliseconds(laterStartOfWeek);\n+  const earlierTimestamp =\n+    +earlierStartOfWeek - getTimezoneOffsetInMilliseconds(earlierStartOfWeek);\n \n-  // Round the number of days to the nearest integer because the number of\n-  // milliseconds in a days is not constant (e.g. it's different in the week of\n-  // the daylight saving time clock shift).\n-  return Math.round((timestampLeft - timestampRight) / millisecondsInWeek);\n+  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInWeek);\n }\ndiff --git a/src/differenceInCalendarYears/index.ts b/src/differenceInCalendarYears/index.ts\nindex 654ff2be43..4ab47a1ce1 100644\n--- a/src/differenceInCalendarYears/index.ts\n+++ b/src/differenceInCalendarYears/index.ts\n@@ -1,4 +1,11 @@\n-import { toDate } from \"../toDate/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInCalendarYears} function options.\n+ */\n+export interface DifferenceInCalendarYearsOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInCalendarYears\n@@ -8,10 +15,9 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Get the number of calendar years between the given dates.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - An object with options\n \n  * @returns The number of calendar years\n  *\n@@ -20,15 +26,18 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = differenceInCalendarYears(\n  *   new Date(2015, 1, 11),\n  *   new Date(2013, 11, 31)\n- * )\n+ * );\n  * //=> 2\n  */\n-export function differenceInCalendarYears<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInCalendarYears(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInCalendarYearsOptions | undefined,\n ): number {\n-  const _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n-\n-  return _dateLeft.getFullYear() - _dateRight.getFullYear();\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+  return laterDate_.getFullYear() - earlierDate_.getFullYear();\n }\ndiff --git a/src/differenceInDays/index.ts b/src/differenceInDays/index.ts\nindex 8ed056b66a..35624c54e9 100644\n--- a/src/differenceInDays/index.ts\n+++ b/src/differenceInDays/index.ts\n@@ -1,5 +1,11 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { differenceInCalendarDays } from \"../differenceInCalendarDays/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInDays} function options.\n+ */\n+export interface DifferenceInDaysOptions extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInDays\n@@ -17,10 +23,9 @@ import { toDate } from \"../toDate/index.js\";\n  * To ignore DST and only measure exact 24-hour periods, use this instead:\n  * `Math.trunc(differenceInHours(dateLeft, dateRight)/24)|0`.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - An object with options\n  *\n  * @returns The number of full days according to the local timezone\n  *\n@@ -55,23 +60,30 @@ import { toDate } from \"../toDate/index.js\";\n  * )\n  * //=> 92\n  */\n-export function differenceInDays<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInDays(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInDaysOptions | undefined,\n ): number {\n-  const _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n \n-  const sign = compareLocalAsc(_dateLeft, _dateRight);\n-  const difference = Math.abs(differenceInCalendarDays(_dateLeft, _dateRight));\n+  const sign = compareLocalAsc(laterDate_, earlierDate_);\n+  const difference = Math.abs(\n+    differenceInCalendarDays(laterDate_, earlierDate_),\n+  );\n \n-  _dateLeft.setDate(_dateLeft.getDate() - sign * difference);\n+  laterDate_.setDate(laterDate_.getDate() - sign * difference);\n \n   // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full\n   // If so, result must be decreased by 1 in absolute value\n   const isLastDayNotFull = Number(\n-    compareLocalAsc(_dateLeft, _dateRight) === -sign,\n+    compareLocalAsc(laterDate_, earlierDate_) === -sign,\n   );\n+\n   const result = sign * (difference - isLastDayNotFull);\n   // Prevent negative zero\n   return result === 0 ? 0 : result;\n@@ -81,25 +93,19 @@ export function differenceInDays<DateType extends Date>(\n // for accurate equality comparisons of UTC timestamps that end up\n // having the same representation in local time, e.g. one hour before\n // DST ends vs. the instant that DST ends.\n-function compareLocalAsc<DateType extends Date>(\n-  dateLeft: DateType,\n-  dateRight: DateType,\n-): number {\n+function compareLocalAsc(laterDate: Date, earlierDate: Date): number {\n   const diff =\n-    dateLeft.getFullYear() - dateRight.getFullYear() ||\n-    dateLeft.getMonth() - dateRight.getMonth() ||\n-    dateLeft.getDate() - dateRight.getDate() ||\n-    dateLeft.getHours() - dateRight.getHours() ||\n-    dateLeft.getMinutes() - dateRight.getMinutes() ||\n-    dateLeft.getSeconds() - dateRight.getSeconds() ||\n-    dateLeft.getMilliseconds() - dateRight.getMilliseconds();\n+    laterDate.getFullYear() - earlierDate.getFullYear() ||\n+    laterDate.getMonth() - earlierDate.getMonth() ||\n+    laterDate.getDate() - earlierDate.getDate() ||\n+    laterDate.getHours() - earlierDate.getHours() ||\n+    laterDate.getMinutes() - earlierDate.getMinutes() ||\n+    laterDate.getSeconds() - earlierDate.getSeconds() ||\n+    laterDate.getMilliseconds() - earlierDate.getMilliseconds();\n+\n+  if (diff < 0) return -1;\n+  if (diff > 0) return 1;\n \n-  if (diff < 0) {\n-    return -1;\n-  } else if (diff > 0) {\n-    return 1;\n-    // Return 0 if diff is 0; return NaN if diff is NaN\n-  } else {\n-    return diff;\n-  }\n+  // Return 0 if diff is 0; return NaN if diff is NaN\n+  return diff;\n }\ndiff --git a/src/differenceInHours/index.ts b/src/differenceInHours/index.ts\nindex be9c33073d..fa78e64457 100644\n--- a/src/differenceInHours/index.ts\n+++ b/src/differenceInHours/index.ts\n@@ -1,12 +1,14 @@\n import { getRoundingMethod } from \"../_lib/getRoundingMethod/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { millisecondsInHour } from \"../constants/index.js\";\n-import { differenceInMilliseconds } from \"../differenceInMilliseconds/index.js\";\n-import type { RoundingOptions } from \"../types.js\";\n+import type { DateFns, RoundingOptions } from \"../types.js\";\n \n /**\n  * The {@link differenceInHours} function options.\n  */\n-export interface DifferenceInHoursOptions extends RoundingOptions {}\n+export interface DifferenceInHoursOptions\n+  extends RoundingOptions,\n+    DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInHours\n@@ -16,10 +18,8 @@ export interface DifferenceInHoursOptions extends RoundingOptions {}\n  * @description\n  * Get the number of hours between the given dates.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n  * @param options - An object with options.\n  *\n  * @returns The number of hours\n@@ -32,12 +32,16 @@ export interface DifferenceInHoursOptions extends RoundingOptions {}\n  * )\n  * //=> 12\n  */\n-export function differenceInHours<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInHours(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n   options?: DifferenceInHoursOptions,\n ): number {\n-  const diff =\n-    differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+  const diff = (+laterDate_ - +earlierDate_) / millisecondsInHour;\n   return getRoundingMethod(options?.roundingMethod)(diff);\n }\ndiff --git a/src/differenceInISOWeekYears/index.ts b/src/differenceInISOWeekYears/index.ts\nindex 564a6ae61e..d1b4aa7cf9 100644\n--- a/src/differenceInISOWeekYears/index.ts\n+++ b/src/differenceInISOWeekYears/index.ts\n@@ -1,7 +1,14 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { compareAsc } from \"../compareAsc/index.js\";\n import { differenceInCalendarISOWeekYears } from \"../differenceInCalendarISOWeekYears/index.js\";\n import { subISOWeekYears } from \"../subISOWeekYears/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInISOWeekYears} function options.\n+ */\n+export interface DifferenceInISOWeekYearsOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInISOWeekYears\n@@ -13,10 +20,9 @@ import { toDate } from \"../toDate/index.js\";\n  *\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - The options\n  *\n  * @returns The number of full ISO week-numbering years\n  *\n@@ -26,28 +32,31 @@ import { toDate } from \"../toDate/index.js\";\n  *   new Date(2012, 0, 1),\n  *   new Date(2010, 0, 1)\n  * )\n- * //=> 1\n+ * // => 1\n  */\n-export function differenceInISOWeekYears<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInISOWeekYears(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInISOWeekYearsOptions | undefined,\n ): number {\n-  let _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n \n-  const sign = compareAsc(_dateLeft, _dateRight);\n-  const difference = Math.abs(\n-    differenceInCalendarISOWeekYears(_dateLeft, _dateRight),\n+  const sign = compareAsc(laterDate_, earlierDate_);\n+  const diff = Math.abs(\n+    differenceInCalendarISOWeekYears(laterDate_, earlierDate_, options),\n   );\n-  _dateLeft = subISOWeekYears(_dateLeft, sign * difference);\n \n-  // Math.abs(diff in full ISO years - diff in calendar ISO years) === 1\n-  // if last calendar ISO year is not full\n-  // If so, result must be decreased by 1 in absolute value\n+  const adjustedDate = subISOWeekYears(laterDate_, sign * diff, options);\n+\n   const isLastISOWeekYearNotFull = Number(\n-    compareAsc(_dateLeft, _dateRight) === -sign,\n+    compareAsc(adjustedDate, earlierDate_) === -sign,\n   );\n-  const result = sign * (difference - isLastISOWeekYearNotFull);\n+  const result = sign * (diff - isLastISOWeekYearNotFull);\n+\n   // Prevent negative zero\n   return result === 0 ? 0 : result;\n }\ndiff --git a/src/differenceInMilliseconds/index.ts b/src/differenceInMilliseconds/index.ts\nindex 6a4a98c688..32414f0707 100644\n--- a/src/differenceInMilliseconds/index.ts\n+++ b/src/differenceInMilliseconds/index.ts\n@@ -1,4 +1,5 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n \n /**\n  * @name differenceInMilliseconds\n@@ -8,10 +9,8 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Get the number of milliseconds between the given dates.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n  *\n  * @returns The number of milliseconds\n  *\n@@ -24,9 +23,9 @@ import { toDate } from \"../toDate/index.js\";\n  * )\n  * //=> 1100\n  */\n-export function differenceInMilliseconds<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInMilliseconds(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n ): number {\n-  return +toDate(dateLeft) - +toDate(dateRight);\n+  return +toDate(laterDate) - +toDate(earlierDate);\n }\ndiff --git a/src/differenceInMinutes/index.ts b/src/differenceInMinutes/index.ts\nindex 298ea80162..364b54de87 100644\n--- a/src/differenceInMinutes/index.ts\n+++ b/src/differenceInMinutes/index.ts\n@@ -1,7 +1,7 @@\n import { getRoundingMethod } from \"../_lib/getRoundingMethod/index.js\";\n import { millisecondsInMinute } from \"../constants/index.js\";\n import { differenceInMilliseconds } from \"../differenceInMilliseconds/index.js\";\n-import type { RoundingOptions } from \"../types.js\";\n+import type { DateFns, RoundingOptions } from \"../types.js\";\n \n /**\n  * The {@link differenceInMinutes} function options.\n@@ -16,8 +16,6 @@ export interface DifferenceInMinutesOptions extends RoundingOptions {}\n  * @description\n  * Get the signed number of full (rounded towards 0) minutes between the given dates.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n  * @param dateLeft - The later date\n  * @param dateRight - The earlier date\n  * @param options - An object with options.\n@@ -40,9 +38,9 @@ export interface DifferenceInMinutesOptions extends RoundingOptions {}\n  * )\n  * //=> -1\n  */\n-export function differenceInMinutes<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInMinutes(\n+  dateLeft: DateFns.Arg,\n+  dateRight: DateFns.Arg,\n   options?: DifferenceInMinutesOptions,\n ): number {\n   const diff =\ndiff --git a/src/differenceInMonths/index.ts b/src/differenceInMonths/index.ts\nindex 654db8f738..c4aa549105 100644\n--- a/src/differenceInMonths/index.ts\n+++ b/src/differenceInMonths/index.ts\n@@ -1,20 +1,23 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { compareAsc } from \"../compareAsc/index.js\";\n import { differenceInCalendarMonths } from \"../differenceInCalendarMonths/index.js\";\n import { isLastDayOfMonth } from \"../isLastDayOfMonth/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInMonths} function options.\n+ */\n+export interface DifferenceInMonthsOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInMonths\n  * @category Month Helpers\n  * @summary Get the number of full months between the given dates.\n  *\n- * @description\n- * Get the number of full months between the given dates using trunc as a default rounding method.\n- *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - An object with options\n  *\n  * @returns The number of full months\n  *\n@@ -23,47 +26,40 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))\n  * //=> 7\n  */\n-export function differenceInMonths<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInMonths(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInMonthsOptions | undefined,\n ): number {\n-  const _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n+  const [laterDate_, workingLaterDate, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    laterDate,\n+    earlierDate,\n+  );\n \n-  const sign = compareAsc(_dateLeft, _dateRight);\n+  const sign = compareAsc(workingLaterDate, earlierDate_);\n   const difference = Math.abs(\n-    differenceInCalendarMonths(_dateLeft, _dateRight),\n+    differenceInCalendarMonths(workingLaterDate, earlierDate_),\n   );\n-  let result;\n \n-  // Check for the difference of less than month\n-  if (difference < 1) {\n-    result = 0;\n-  } else {\n-    if (_dateLeft.getMonth() === 1 && _dateLeft.getDate() > 27) {\n-      // This will check if the date is end of Feb and assign a higher end of month date\n-      // to compare it with Jan\n-      _dateLeft.setDate(30);\n-    }\n+  if (difference < 1) return 0;\n \n-    _dateLeft.setMonth(_dateLeft.getMonth() - sign * difference);\n+  if (workingLaterDate.getMonth() === 1 && workingLaterDate.getDate() > 27)\n+    workingLaterDate.setDate(30);\n \n-    // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full\n-    // If so, result must be decreased by 1 in absolute value\n-    let isLastMonthNotFull = compareAsc(_dateLeft, _dateRight) === -sign;\n+  workingLaterDate.setMonth(workingLaterDate.getMonth() - sign * difference);\n \n-    // Check for cases of one full calendar month\n-    if (\n-      isLastDayOfMonth(toDate(dateLeft)) &&\n-      difference === 1 &&\n-      compareAsc(dateLeft, _dateRight) === 1\n-    ) {\n-      isLastMonthNotFull = false;\n-    }\n+  let isLastMonthNotFull = compareAsc(workingLaterDate, earlierDate_) === -sign;\n \n-    result = sign * (difference - Number(isLastMonthNotFull));\n+  if (\n+    isLastDayOfMonth(laterDate_) &&\n+    difference === 1 &&\n+    compareAsc(laterDate_, earlierDate_) === 1\n+  ) {\n+    isLastMonthNotFull = false;\n   }\n \n-  // Prevent negative zero\n+  const result = sign * (difference - +isLastMonthNotFull);\n   return result === 0 ? 0 : result;\n }\ndiff --git a/src/differenceInQuarters/index.ts b/src/differenceInQuarters/index.ts\nindex a4df7756d0..995d7293bc 100644\n--- a/src/differenceInQuarters/index.ts\n+++ b/src/differenceInQuarters/index.ts\n@@ -1,11 +1,13 @@\n import { getRoundingMethod } from \"../_lib/getRoundingMethod/index.js\";\n import { differenceInMonths } from \"../differenceInMonths/index.js\";\n-import type { RoundingOptions } from \"../types.js\";\n+import type { DateFns, RoundingOptions } from \"../types.js\";\n \n /**\n  * The {@link differenceInQuarters} function options.\n  */\n-export interface DifferenceInQuartersOptions extends RoundingOptions {}\n+export interface DifferenceInQuartersOptions\n+  extends RoundingOptions,\n+    DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInQuarters\n@@ -15,10 +17,8 @@ export interface DifferenceInQuartersOptions extends RoundingOptions {}\n  * @description\n  * Get the number of quarters between the given dates.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n  * @param options - An object with options.\n  *\n  * @returns The number of full quarters\n@@ -28,11 +28,11 @@ export interface DifferenceInQuartersOptions extends RoundingOptions {}\n  * const result = differenceInQuarters(new Date(2014, 6, 2), new Date(2013, 11, 31))\n  * //=> 2\n  */\n-export function differenceInQuarters<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n-  options?: DifferenceInQuartersOptions,\n+export function differenceInQuarters(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInQuartersOptions | undefined,\n ): number {\n-  const diff = differenceInMonths(dateLeft, dateRight) / 3;\n+  const diff = differenceInMonths(laterDate, earlierDate, options) / 3;\n   return getRoundingMethod(options?.roundingMethod)(diff);\n }\ndiff --git a/src/differenceInSeconds/index.ts b/src/differenceInSeconds/index.ts\nindex f338ebb641..92e01fcd64 100644\n--- a/src/differenceInSeconds/index.ts\n+++ b/src/differenceInSeconds/index.ts\n@@ -1,6 +1,6 @@\n import { getRoundingMethod } from \"../_lib/getRoundingMethod/index.js\";\n import { differenceInMilliseconds } from \"../differenceInMilliseconds/index.js\";\n-import type { RoundingOptions } from \"../types.js\";\n+import type { DateFns, RoundingOptions } from \"../types.js\";\n \n /**\n  * The {@link differenceInSeconds} function options.\n@@ -15,10 +15,8 @@ export interface DifferenceInSecondsOptions extends RoundingOptions {}\n  * @description\n  * Get the number of seconds between the given dates.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n  * @param options - An object with options.\n  *\n  * @returns The number of seconds\n@@ -32,11 +30,11 @@ export interface DifferenceInSecondsOptions extends RoundingOptions {}\n  * )\n  * //=> 12\n  */\n-export function differenceInSeconds<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInSeconds(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n   options?: DifferenceInSecondsOptions,\n ): number {\n-  const diff = differenceInMilliseconds(dateLeft, dateRight) / 1000;\n+  const diff = differenceInMilliseconds(laterDate, earlierDate) / 1000;\n   return getRoundingMethod(options?.roundingMethod)(diff);\n }\ndiff --git a/src/differenceInWeeks/index.ts b/src/differenceInWeeks/index.ts\nindex 55c392fdbe..93bd2992e8 100644\n--- a/src/differenceInWeeks/index.ts\n+++ b/src/differenceInWeeks/index.ts\n@@ -1,11 +1,13 @@\n import { getRoundingMethod } from \"../_lib/getRoundingMethod/index.js\";\n import { differenceInDays } from \"../differenceInDays/index.js\";\n-import type { RoundingOptions } from \"../types.js\";\n+import type { DateFns, RoundingOptions } from \"../types.js\";\n \n /**\n  * The {@link differenceInWeeks} function options.\n  */\n-export interface DifferenceInWeeksOptions extends RoundingOptions {}\n+export interface DifferenceInWeeksOptions\n+  extends RoundingOptions,\n+    DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInWeeks\n@@ -23,10 +25,8 @@ export interface DifferenceInWeeksOptions extends RoundingOptions {}\n  * To ignore DST and only measure exact 7*24-hour periods, use this instead:\n  * `Math.trunc(differenceInHours(dateLeft, dateRight)/(7*24))|0`.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n  * @param options - An object with options\n  *\n  * @returns The number of full weeks\n@@ -49,11 +49,11 @@ export interface DifferenceInWeeksOptions extends RoundingOptions {}\n  * )\n  * //=> 8\n  */\n-export function differenceInWeeks<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n-  options?: DifferenceInWeeksOptions,\n+export function differenceInWeeks(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInWeeksOptions | undefined,\n ): number {\n-  const diff = differenceInDays(dateLeft, dateRight) / 7;\n+  const diff = differenceInDays(laterDate, earlierDate, options) / 7;\n   return getRoundingMethod(options?.roundingMethod)(diff);\n }\ndiff --git a/src/differenceInYears/index.ts b/src/differenceInYears/index.ts\nindex 277b233cbb..5303d0a4e1 100644\n--- a/src/differenceInYears/index.ts\n+++ b/src/differenceInYears/index.ts\n@@ -1,6 +1,13 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { compareAsc } from \"../compareAsc/index.js\";\n import { differenceInCalendarYears } from \"../differenceInCalendarYears/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link differenceInYears} function options.\n+ */\n+export interface DifferenceInYearsOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name differenceInYears\n@@ -10,10 +17,9 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Get the number of full years between the given dates.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The later date\n- * @param dateRight - The earlier date\n+ * @param laterDate - The later date\n+ * @param earlierDate - The earlier date\n+ * @param options - An object with options\n  *\n  * @returns The number of full years\n  *\n@@ -22,25 +28,39 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))\n  * //=> 1\n  */\n-export function differenceInYears<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function differenceInYears(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: DifferenceInYearsOptions | undefined,\n ): number {\n-  const _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+\n+  // -1 if the left date is earlier than the right date\n+  // 2023-12-31 - 2024-01-01 = -1\n+  const sign = compareAsc(laterDate_, earlierDate_);\n+\n+  // First calculate the difference in calendar years\n+  // 2024-01-01 - 2023-12-31 = 1 year\n+  const diff = Math.abs(differenceInCalendarYears(laterDate_, earlierDate_));\n \n-  const sign = compareAsc(_dateLeft, _dateRight);\n-  const difference = Math.abs(differenceInCalendarYears(_dateLeft, _dateRight));\n+  // Now we need to calculate if the difference is full. To do that we set\n+  // both dates to the same year and check if the both date's month and day\n+  // form a full year.\n+  laterDate_.setFullYear(1584);\n+  earlierDate_.setFullYear(1584);\n \n-  // Set both dates to a valid leap year for accurate comparison when dealing\n-  // with leap days\n-  _dateLeft.setFullYear(1584);\n-  _dateRight.setFullYear(1584);\n+  // For it to be true, when the later date is indeed later than the earlier date\n+  // (2026-02-01 - 2023-12-10 = 3 years), the difference is full if\n+  // the normalized later date is also later than the normalized earlier date.\n+  // In our example, 1584-02-01 is earlier than 1584-12-10, so the difference\n+  // is partial, hence we need to subtract 1 from the difference 3 - 1 = 2.\n+  const partial = compareAsc(laterDate_, earlierDate_) === -sign;\n \n-  // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full\n-  // If so, result must be decreased by 1 in absolute value\n-  const isLastYearNotFull = compareAsc(_dateLeft, _dateRight) === -sign;\n-  const result = sign * (difference - +isLastYearNotFull);\n+  const result = sign * (diff - +partial);\n \n   // Prevent negative zero\n   return result === 0 ? 0 : result;\ndiff --git a/src/eachDayOfInterval/index.ts b/src/eachDayOfInterval/index.ts\nindex 706adc1c25..f872dddd25 100644\n--- a/src/eachDayOfInterval/index.ts\n+++ b/src/eachDayOfInterval/index.ts\n@@ -1,10 +1,32 @@\n-import { toDate } from \"../toDate/index.js\";\n-import type { Interval, StepOptions } from \"../types.js\";\n+import { normalizeInterval } from \"../_lib/normalizeInterval/index.js\";\n+import { constructFrom } from \"../constructFrom/index.js\";\n+import type { DateFns, Interval, StepOptions } from \"../types.js\";\n \n /**\n  * The {@link eachDayOfInterval} function options.\n  */\n-export interface EachDayOfIntervalOptions extends StepOptions {}\n+export interface EachDayOfIntervalOptions<DateType extends Date = Date>\n+  extends StepOptions,\n+    DateFns.ContextOptions<DateType> {}\n+\n+/**\n+ * The {@link eachDayOfInterval} function result type. It resolves the proper data type.\n+ * It uses the first argument date object type, starting from the date argument,\n+ * then the start interval date, and finally the end interval date. If\n+ * a context function is passed, it uses the context function return type.\n+ */\n+export type EachDayOfIntervalResult<\n+  IntervalType extends Interval,\n+  Options extends EachDayOfIntervalOptions | undefined,\n+> = Array<\n+  Options extends EachDayOfIntervalOptions<infer DateType>\n+    ? DateType\n+    : IntervalType[\"start\"] extends Date\n+      ? IntervalType[\"start\"]\n+      : IntervalType[\"end\"] extends Date\n+        ? IntervalType[\"end\"]\n+        : Date\n+>;\n \n /**\n  * @name eachDayOfInterval\n@@ -14,7 +36,8 @@ export interface EachDayOfIntervalOptions extends StepOptions {}\n  * @description\n  * Return the array of dates within the specified time interval.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam IntervalType - Interval type.\n+ * @typeParam Options - Options type.\n  *\n  * @param interval - The interval.\n  * @param options - An object with options.\n@@ -35,17 +58,19 @@ export interface EachDayOfIntervalOptions extends StepOptions {}\n  * //   Fri Oct 10 2014 00:00:00\n  * // ]\n  */\n-export function eachDayOfInterval<DateType extends Date>(\n-  interval: Interval<DateType>,\n-  options?: EachDayOfIntervalOptions,\n-): DateType[] {\n-  const startDate = toDate(interval.start);\n-  const endDate = toDate(interval.end);\n+export function eachDayOfInterval<\n+  IntervalType extends Interval,\n+  Options extends EachDayOfIntervalOptions | undefined = undefined,\n+>(\n+  interval: IntervalType,\n+  options?: Options,\n+): EachDayOfIntervalResult<IntervalType, Options> {\n+  const { start, end } = normalizeInterval(options?.in, interval);\n \n-  let reversed = +startDate > +endDate;\n-  const endTime = reversed ? +startDate : +endDate;\n-  const currentDate = reversed ? endDate : startDate;\n-  currentDate.setHours(0, 0, 0, 0);\n+  let reversed = +start > +end;\n+  const endTime = reversed ? +start : +end;\n+  const date = reversed ? end : start;\n+  date.setHours(0, 0, 0, 0);\n \n   let step = options?.step ?? 1;\n   if (!step) return [];\n@@ -54,12 +79,12 @@ export function eachDayOfInterval<DateType extends Date>(\n     reversed = !reversed;\n   }\n \n-  const dates = [];\n+  const dates: EachDayOfIntervalResult<IntervalType, Options> = [];\n \n-  while (+currentDate <= endTime) {\n-    dates.push(toDate(currentDate));\n-    currentDate.setDate(currentDate.getDate() + step);\n-    currentDate.setHours(0, 0, 0, 0);\n+  while (+date <= endTime) {\n+    dates.push(constructFrom(start, date));\n+    date.setDate(date.getDate() + step);\n+    date.setHours(0, 0, 0, 0);\n   }\n \n   return reversed ? dates.reverse() : dates;\ndiff --git a/src/eachHourOfInterval/index.ts b/src/eachHourOfInterval/index.ts\nindex 8eb3e93aef..967d9c3996 100644\n--- a/src/eachHourOfInterval/index.ts\n+++ b/src/eachHourOfInterval/index.ts\n@@ -1,11 +1,30 @@\n-import { addHours } from \"../addHours/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n-import type { Interval, StepOptions } from \"../types.js\";\n+import { normalizeInterval } from \"../_lib/normalizeInterval/index.js\";\n+import { constructFrom } from \"../constructFrom/index.js\";\n+import type { DateFns, Interval, StepOptions } from \"../types.js\";\n \n /**\n  * The {@link eachHourOfInterval} function options.\n  */\n-export interface EachHourOfIntervalOptions extends StepOptions {}\n+export interface EachHourOfIntervalOptions<DateType extends Date = Date>\n+  extends StepOptions,\n+    DateFns.ContextOptions<DateType> {}\n+\n+/**\n+ * The {@link eachHourOfInterval} function result type.\n+ * Resolves to the appropriate date type based on inputs.\n+ */\n+export type EachHourOfIntervalResult<\n+  IntervalType extends Interval,\n+  Options extends EachHourOfIntervalOptions | undefined,\n+> = Array<\n+  Options extends EachHourOfIntervalOptions<infer DateType>\n+    ? DateType\n+    : IntervalType[\"start\"] extends Date\n+      ? IntervalType[\"start\"]\n+      : IntervalType[\"end\"] extends Date\n+        ? IntervalType[\"end\"]\n+        : Date\n+>;\n \n /**\n  * @name eachHourOfInterval\n@@ -15,7 +34,8 @@ export interface EachHourOfIntervalOptions extends StepOptions {}\n  * @description\n  * Return the array of hours within the specified time interval.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam IntervalType - Interval type.\n+ * @typeParam Options - Options type.\n  *\n  * @param interval - The interval.\n  * @param options - An object with options.\n@@ -27,7 +47,7 @@ export interface EachHourOfIntervalOptions extends StepOptions {}\n  * const result = eachHourOfInterval({\n  *   start: new Date(2014, 9, 6, 12),\n  *   end: new Date(2014, 9, 6, 15)\n- * })\n+ * });\n  * //=> [\n  * //   Mon Oct 06 2014 12:00:00,\n  * //   Mon Oct 06 2014 13:00:00,\n@@ -35,17 +55,19 @@ export interface EachHourOfIntervalOptions extends StepOptions {}\n  * //   Mon Oct 06 2014 15:00:00\n  * // ]\n  */\n-export function eachHourOfInterval<DateType extends Date>(\n-  interval: Interval<DateType>,\n-  options?: EachHourOfIntervalOptions,\n-): DateType[] {\n-  const startDate = toDate(interval.start);\n-  const endDate = toDate(interval.end);\n+export function eachHourOfInterval<\n+  IntervalType extends Interval,\n+  Options extends EachHourOfIntervalOptions | undefined = undefined,\n+>(\n+  interval: IntervalType,\n+  options?: Options,\n+): EachHourOfIntervalResult<IntervalType, Options> {\n+  const { start, end } = normalizeInterval(options?.in, interval);\n \n-  let reversed = +startDate > +endDate;\n-  const endTime = reversed ? +startDate : +endDate;\n-  let currentDate = reversed ? endDate : startDate;\n-  currentDate.setMinutes(0, 0, 0);\n+  let reversed = +start > +end;\n+  const endTime = reversed ? +start : +end;\n+  const date = reversed ? end : start;\n+  date.setMinutes(0, 0, 0);\n \n   let step = options?.step ?? 1;\n   if (!step) return [];\n@@ -54,11 +76,11 @@ export function eachHourOfInterval<DateType extends Date>(\n     reversed = !reversed;\n   }\n \n-  const dates = [];\n+  const dates: EachHourOfIntervalResult<IntervalType, Options> = [];\n \n-  while (+currentDate <= endTime) {\n-    dates.push(toDate(currentDate));\n-    currentDate = addHours(currentDate, step);\n+  while (+date <= endTime) {\n+    dates.push(constructFrom(start, date));\n+    date.setHours(date.getHours() + step);\n   }\n \n   return reversed ? dates.reverse() : dates;\ndiff --git a/src/eachMinuteOfInterval/index.ts b/src/eachMinuteOfInterval/index.ts\nindex 2481d8b534..4834f816ab 100644\n--- a/src/eachMinuteOfInterval/index.ts\n+++ b/src/eachMinuteOfInterval/index.ts\n@@ -1,12 +1,33 @@\n+import { normalizeInterval } from \"../_lib/normalizeInterval/index.js\";\n import { addMinutes } from \"../addMinutes/index.js\";\n-import { startOfMinute } from \"../startOfMinute/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n-import type { Interval, StepOptions } from \"../types.js\";\n+import { constructFrom } from \"../constructFrom/index.js\";\n+import type { DateFns, Interval, StepOptions } from \"../types.js\";\n \n /**\n  * The {@link eachMinuteOfInterval} function options.\n  */\n-export interface EachMinuteOfIntervalOptions extends StepOptions {}\n+export interface EachMinuteOfIntervalOptions<DateType extends Date = Date>\n+  extends StepOptions,\n+    DateFns.ContextOptions<DateType> {}\n+\n+/**\n+ * The {@link eachMinuteOfInterval} function result type. It resolves the proper data type.\n+ * It uses the first argument date object type, starting from the date argument,\n+ * then the start interval date, and finally the end interval date. If\n+ * a context function is passed, it uses the context function return type.\n+ */\n+export type EachMinuteOfIntervalResult<\n+  IntervalType extends Interval,\n+  Options extends EachMinuteOfIntervalOptions | undefined,\n+> = Array<\n+  Options extends EachMinuteOfIntervalOptions<infer DateType>\n+    ? DateType\n+    : IntervalType[\"start\"] extends Date\n+      ? IntervalType[\"start\"]\n+      : IntervalType[\"end\"] extends Date\n+        ? IntervalType[\"end\"]\n+        : Date\n+>;\n \n /**\n  * @name eachMinuteOfInterval\n@@ -16,7 +37,8 @@ export interface EachMinuteOfIntervalOptions extends StepOptions {}\n  * @description\n  * Returns the array of minutes within the specified time interval.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam IntervalType - Interval type.\n+ * @typeParam Options - Options type.\n  *\n  * @param interval - The interval.\n  * @param options - An object with options.\n@@ -36,16 +58,20 @@ export interface EachMinuteOfIntervalOptions extends StepOptions {}\n  * //   Wed Oct 14 2014 13:03:00\n  * // ]\n  */\n-export function eachMinuteOfInterval<DateType extends Date>(\n-  interval: Interval<DateType>,\n-  options?: EachMinuteOfIntervalOptions,\n-): DateType[] {\n-  const startDate = startOfMinute(toDate(interval.start));\n-  const endDate = toDate(interval.end);\n+export function eachMinuteOfInterval<\n+  IntervalType extends Interval,\n+  Options extends EachMinuteOfIntervalOptions | undefined = undefined,\n+>(\n+  interval: IntervalType,\n+  options?: Options,\n+): EachMinuteOfIntervalResult<IntervalType, Options> {\n+  const { start, end } = normalizeInterval(options?.in, interval);\n+  // Set to the start of the minute\n+  start.setSeconds(0, 0);\n \n-  let reversed = +startDate > +endDate;\n-  const endTime = reversed ? +startDate : +endDate;\n-  let currentDate = reversed ? endDate : startDate;\n+  let reversed = +start > +end;\n+  const endTime = reversed ? +start : +end;\n+  let date = reversed ? end : start;\n \n   let step = options?.step ?? 1;\n   if (!step) return [];\n@@ -54,11 +80,11 @@ export function eachMinuteOfInterval<DateType extends Date>(\n     reversed = !reversed;\n   }\n \n-  const dates = [];\n+  const dates: EachMinuteOfIntervalResult<IntervalType, Options> = [];\n \n-  while (+currentDate <= endTime) {\n-    dates.push(toDate(currentDate));\n-    currentDate = addMinutes(currentDate, step);\n+  while (+date <= endTime) {\n+    dates.push(constructFrom(start, date));\n+    date = addMinutes(date, step);\n   }\n \n   return reversed ? dates.reverse() : dates;\ndiff --git a/src/eachMonthOfInterval/index.ts b/src/eachMonthOfInterval/index.ts\nindex a2711e26d5..2633c996a8 100644\n--- a/src/eachMonthOfInterval/index.ts\n+++ b/src/eachMonthOfInterval/index.ts\n@@ -1,10 +1,29 @@\n-import { toDate } from \"../toDate/index.js\";\n-import type { Interval, StepOptions } from \"../types.js\";\n+import { normalizeInterval } from \"../_lib/normalizeInterval/index.js\";\n+import { constructFrom } from \"../constructFrom/index.js\";\n+import type { DateFns, Interval, StepOptions } from \"../types.js\";\n \n /**\n  * The {@link eachMonthOfInterval} function options.\n  */\n-export interface EachMonthOfIntervalOptions extends StepOptions {}\n+export interface EachMonthOfIntervalOptions<DateType extends Date = Date>\n+  extends StepOptions,\n+    DateFns.ContextOptions<DateType> {}\n+\n+/**\n+ * The {@link eachMonthOfInterval} function result type. It resolves the proper data type.\n+ */\n+export type EachMonthOfIntervalResult<\n+  IntervalType extends Interval,\n+  Options extends EachMonthOfIntervalOptions | undefined,\n+> = Array<\n+  Options extends EachMonthOfIntervalOptions<infer DateType>\n+    ? DateType\n+    : IntervalType[\"start\"] extends Date\n+      ? IntervalType[\"start\"]\n+      : IntervalType[\"end\"] extends Date\n+        ? IntervalType[\"end\"]\n+        : Date\n+>;\n \n /**\n  * @name eachMonthOfInterval\n@@ -14,9 +33,11 @@ export interface EachMonthOfIntervalOptions extends StepOptions {}\n  * @description\n  * Return the array of months within the specified time interval.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam IntervalType - Interval type.\n+ * @typeParam Options - Options type.\n  *\n- * @param interval - The interval\n+ * @param interval - The interval.\n+ * @param options - An object with options.\n  *\n  * @returns The array with starts of months from the month of the interval start to the month of the interval end\n  *\n@@ -36,18 +57,20 @@ export interface EachMonthOfIntervalOptions extends StepOptions {}\n  * //   Fri Aug 01 2014 00:00:00\n  * // ]\n  */\n-export function eachMonthOfInterval<DateType extends Date>(\n-  interval: Interval<DateType>,\n-  options?: EachMonthOfIntervalOptions,\n-): DateType[] {\n-  const startDate = toDate(interval.start);\n-  const endDate = toDate(interval.end);\n+export function eachMonthOfInterval<\n+  IntervalType extends Interval,\n+  Options extends EachMonthOfIntervalOptions | undefined = undefined,\n+>(\n+  interval: IntervalType,\n+  options?: Options,\n+): EachMonthOfIntervalResult<IntervalType, Options> {\n+  const { start, end } = normalizeInterval(options?.in, interval);\n \n-  let reversed = +startDate > +endDate;\n-  const endTime = reversed ? +startDate : +endDate;\n-  const currentDate = reversed ? endDate : startDate;\n-  currentDate.setHours(0, 0, 0, 0);\n-  currentDate.setDate(1);\n+  let reversed = +start > +end;\n+  const endTime = reversed ? +start : +end;\n+  const date = reversed ? end : start;\n+  date.setHours(0, 0, 0, 0);\n+  date.setDate(1);\n \n   let step = options?.step ?? 1;\n   if (!step) return [];\n@@ -56,11 +79,11 @@ export function eachMonthOfInterval<DateType extends Date>(\n     reversed = !reversed;\n   }\n \n-  const dates = [];\n+  const dates: EachMonthOfIntervalResult<IntervalType, Options> = [];\n \n-  while (+currentDate <= endTime) {\n-    dates.push(toDate(currentDate));\n-    currentDate.setMonth(currentDate.getMonth() + step);\n+  while (+date <= endTime) {\n+    dates.push(constructFrom(start, date));\n+    date.setMonth(date.getMonth() + step);\n   }\n \n   return reversed ? dates.reverse() : dates;\ndiff --git a/src/eachQuarterOfInterval/index.ts b/src/eachQuarterOfInterval/index.ts\nindex 3e47083f80..c34bce5062 100644\n--- a/src/eachQuarterOfInterval/index.ts\n+++ b/src/eachQuarterOfInterval/index.ts\n@@ -1,12 +1,34 @@\n import { addQuarters } from \"../addQuarters/index.js\";\n+import { normalizeInterval } from \"../_lib/normalizeInterval/index.js\";\n import { startOfQuarter } from \"../startOfQuarter/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n-import type { Interval, StepOptions } from \"../types.js\";\n+import { constructFrom } from \"../constructFrom/index.js\";\n+import type { DateFns, Interval, StepOptions } from \"../types.js\";\n \n /**\n  * The {@link eachQuarterOfInterval} function options.\n  */\n-export interface EachQuarterOfIntervalOptions extends StepOptions {}\n+export interface EachQuarterOfIntervalOptions<DateType extends Date = Date>\n+  extends StepOptions,\n+    DateFns.ContextOptions<DateType> {}\n+\n+/**\n+ * The {@link eachQuarterOfInterval} function result type. It resolves the proper data type.\n+ * It uses the first argument date object type, starting from the date argument,\n+ * then the start interval date, and finally the end interval date. If\n+ * a context function is passed, it uses the context function return type.\n+ */\n+export type EachQuarterOfIntervalResult<\n+  IntervalType extends Interval,\n+  Options extends EachQuarterOfIntervalOptions | undefined,\n+> = Array<\n+  Options extends EachQuarterOfIntervalOptions<infer DateType>\n+    ? DateType\n+    : IntervalType[\"start\"] extends Date\n+      ? IntervalType[\"start\"]\n+      : IntervalType[\"end\"] extends Date\n+        ? IntervalType[\"end\"]\n+        : Date\n+>;\n \n /**\n  * @name eachQuarterOfInterval\n@@ -16,9 +38,11 @@ export interface EachQuarterOfIntervalOptions extends StepOptions {}\n  * @description\n  * Return the array of quarters within the specified time interval.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam IntervalType - Interval type.\n+ * @typeParam Options - Options type.\n  *\n  * @param interval - The interval\n+ * @param options - An object with options\n  *\n  * @returns The array with starts of quarters from the quarter of the interval start to the quarter of the interval end\n  *\n@@ -26,7 +50,7 @@ export interface EachQuarterOfIntervalOptions extends StepOptions {}\n  * // Each quarter within interval 6 February 2014 - 10 August 2014:\n  * const result = eachQuarterOfInterval({\n  *   start: new Date(2014, 1, 6),\n- *   end: new Date(2014, 7, 10)\n+ *   end: new Date(2014, 7, 10),\n  * })\n  * //=> [\n  * //   Wed Jan 01 2014 00:00:00,\n@@ -34,20 +58,18 @@ export interface EachQuarterOfIntervalOptions extends StepOptions {}\n  * //   Tue Jul 01 2014 00:00:00,\n  * // ]\n  */\n-export function eachQuarterOfInterval<DateType extends Date>(\n-  interval: Interval<DateType>,\n-  options?: EachQuarterOfIntervalOptions,\n-): DateType[] {\n-  const startDate = toDate(interval.start);\n-  const endDate = toDate(interval.end);\n+export function eachQuarterOfInterval<\n+  IntervalType extends Interval,\n+  Options extends EachQuarterOfIntervalOptions | undefined = undefined,\n+>(\n+  interval: IntervalType,\n+  options?: Options,\n+): EachQuarterOfIntervalResult<IntervalType, Options> {\n+  const { start, end } = normalizeInterval(options?.in, interval);\n \n-  let reversed = +startDate > +endDate;\n-  const endTime = reversed\n-    ? +startOfQuarter(startDate)\n-    : +startOfQuarter(endDate);\n-  let currentDate = reversed\n-    ? startOfQuarter(endDate)\n-    : startOfQuarter(startDate);\n+  let reversed = +start > +end;\n+  const endTime = reversed ? +startOfQuarter(start) : +startOfQuarter(end);\n+  let date = reversed ? startOfQuarter(end) : startOfQuarter(start);\n \n   let step = options?.step ?? 1;\n   if (!step) return [];\n@@ -56,11 +78,11 @@ export function eachQuarterOfInterval<DateType extends Date>(\n     reversed = !reversed;\n   }\n \n-  const dates = [];\n+  const dates: EachQuarterOfIntervalResult<IntervalType, Options> = [];\n \n-  while (+currentDate <= endTime) {\n-    dates.push(toDate(currentDate));\n-    currentDate = addQuarters(currentDate, step);\n+  while (+date <= endTime) {\n+    dates.push(constructFrom(start, date));\n+    date = addQuarters(date, step);\n   }\n \n   return reversed ? dates.reverse() : dates;\ndiff --git a/src/eachWeekOfInterval/index.ts b/src/eachWeekOfInterval/index.ts\nindex d381930b8d..9ffa9f1295 100644\n--- a/src/eachWeekOfInterval/index.ts\n+++ b/src/eachWeekOfInterval/index.ts\n@@ -1,7 +1,9 @@\n+import { normalizeInterval } from \"../_lib/normalizeInterval/index.js\";\n import { addWeeks } from \"../addWeeks/index.js\";\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { startOfWeek } from \"../startOfWeek/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n import type {\n+  DateFns,\n   Interval,\n   LocalizedOptions,\n   StepOptions,\n@@ -11,10 +13,29 @@ import type {\n /**\n  * The {@link eachWeekOfInterval} function options.\n  */\n-export interface EachWeekOfIntervalOptions\n+export interface EachWeekOfIntervalOptions<DateType extends Date = Date>\n   extends StepOptions,\n     WeekOptions,\n-    LocalizedOptions<\"options\"> {}\n+    LocalizedOptions<\"options\">,\n+    DateFns.ContextOptions<DateType> {}\n+\n+/**\n+ * The {@link eachWeekOfInterval} function result type. It resolves the proper data type.\n+ * It uses the first argument date object type, starting from the interval start date,\n+ * then the end interval date. If a context function is passed, it uses the context function return type.\n+ */\n+export type EachWeekOfIntervalResult<\n+  IntervalType extends Interval,\n+  Options extends EachWeekOfIntervalOptions | undefined,\n+> = Array<\n+  Options extends EachWeekOfIntervalOptions<infer DateType>\n+    ? DateType\n+    : IntervalType[\"start\"] extends Date\n+      ? IntervalType[\"start\"]\n+      : IntervalType[\"end\"] extends Date\n+        ? IntervalType[\"end\"]\n+        : Date\n+>;\n \n /**\n  * @name eachWeekOfInterval\n@@ -24,8 +45,6 @@ export interface EachWeekOfIntervalOptions\n  * @description\n  * Return the array of weeks within the specified time interval.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n  * @param interval - The interval.\n  * @param options - An object with options.\n  *\n@@ -48,22 +67,23 @@ export interface EachWeekOfIntervalOptions\n  * //   Sun Nov 23 2014 00:00:00\n  * // ]\n  */\n-export function eachWeekOfInterval<DateType extends Date>(\n-  interval: Interval<DateType>,\n-  options?: EachWeekOfIntervalOptions,\n-): DateType[] {\n-  const startDate = toDate(interval.start);\n-  const endDate = toDate(interval.end);\n+export function eachWeekOfInterval<\n+  IntervalType extends Interval,\n+  Options extends EachWeekOfIntervalOptions | undefined = undefined,\n+>(\n+  interval: IntervalType,\n+  options?: Options,\n+): EachWeekOfIntervalResult<IntervalType, Options> {\n+  const { start, end } = normalizeInterval(options?.in, interval);\n \n-  let reversed = +startDate > +endDate;\n+  let reversed = +start > +end;\n   const startDateWeek = reversed\n-    ? startOfWeek(endDate, options)\n-    : startOfWeek(startDate, options);\n+    ? startOfWeek(end, options)\n+    : startOfWeek(start, options);\n   const endDateWeek = reversed\n-    ? startOfWeek(startDate, options)\n-    : startOfWeek(endDate, options);\n+    ? startOfWeek(start, options)\n+    : startOfWeek(end, options);\n \n-  // Some timezones switch DST at midnight, making start of day unreliable in these timezones, 3pm is a safe bet\n   startDateWeek.setHours(15);\n   endDateWeek.setHours(15);\n \n@@ -77,11 +97,11 @@ export function eachWeekOfInterval<DateType extends Date>(\n     reversed = !reversed;\n   }\n \n-  const dates = [];\n+  const dates: EachWeekOfIntervalResult<IntervalType, Options> = [];\n \n   while (+currentDate <= endTime) {\n     currentDate.setHours(0);\n-    dates.push(toDate(currentDate));\n+    dates.push(constructFrom(start, currentDate));\n     currentDate = addWeeks(currentDate, step);\n     currentDate.setHours(15);\n   }\ndiff --git a/src/eachWeekendOfInterval/index.ts b/src/eachWeekendOfInterval/index.ts\nindex d7351f7db8..6c9723cda1 100644\n--- a/src/eachWeekendOfInterval/index.ts\n+++ b/src/eachWeekendOfInterval/index.ts\n@@ -1,6 +1,30 @@\n+import { normalizeInterval } from \"../_lib/normalizeInterval/index.js\";\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { eachDayOfInterval } from \"../eachDayOfInterval/index.js\";\n import { isWeekend } from \"../isWeekend/index.js\";\n-import type { Interval } from \"../types.js\";\n+import type { DateFns, Interval } from \"../types.js\";\n+\n+/**\n+ * The {@link eachWeekendOfInterval} function options.\n+ */\n+export interface EachWeekendOfIntervalOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n+\n+/**\n+ * The {@link eachWeekendOfInterval} function result type.\n+ */\n+export type EachWeekendOfIntervalResult<\n+  IntervalType extends Interval,\n+  Options extends EachWeekendOfIntervalOptions | undefined,\n+> = Array<\n+  Options extends EachWeekendOfIntervalOptions<infer DateType>\n+    ? DateType\n+    : IntervalType[\"start\"] extends Date\n+      ? IntervalType[\"start\"]\n+      : IntervalType[\"end\"] extends Date\n+        ? IntervalType[\"end\"]\n+        : Date\n+>;\n \n /**\n  * @name eachWeekendOfInterval\n@@ -10,9 +34,11 @@ import type { Interval } from \"../types.js\";\n  * @description\n  * Get all the Saturdays and Sundays in the given date interval.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam IntervalType - Interval type.\n+ * @typeParam Options - Options type.\n  *\n  * @param interval - The given interval\n+ * @param options - An object with options\n  *\n  * @returns An array containing all the Saturdays and Sundays\n  *\n@@ -29,15 +55,20 @@ import type { Interval } from \"../types.js\";\n  * //   Sun Sep 30 2018 00:00:00\n  * // ]\n  */\n-export function eachWeekendOfInterval<DateType extends Date>(\n-  interval: Interval<DateType>,\n-): DateType[] {\n-  const dateInterval = eachDayOfInterval(interval);\n-  const weekends = [];\n+export function eachWeekendOfInterval<\n+  IntervalType extends Interval,\n+  Options extends EachWeekendOfIntervalOptions | undefined = undefined,\n+>(\n+  interval: IntervalType,\n+  options?: Options,\n+): EachWeekendOfIntervalResult<IntervalType, Options> {\n+  const { start, end } = normalizeInterval(options?.in, interval);\n+  const dateInterval = eachDayOfInterval({ start, end }, options);\n+  const weekends: EachWeekendOfIntervalResult<IntervalType, Options> = [];\n   let index = 0;\n   while (index < dateInterval.length) {\n     const date = dateInterval[index++];\n-    if (isWeekend(date)) weekends.push(date);\n+    if (isWeekend(date)) weekends.push(constructFrom(start, date));\n   }\n   return weekends;\n }\ndiff --git a/src/eachWeekendOfMonth/index.ts b/src/eachWeekendOfMonth/index.ts\nindex 724bbbea54..38df4c3ca1 100644\n--- a/src/eachWeekendOfMonth/index.ts\n+++ b/src/eachWeekendOfMonth/index.ts\n@@ -1,6 +1,13 @@\n import { eachWeekendOfInterval } from \"../eachWeekendOfInterval/index.js\";\n import { endOfMonth } from \"../endOfMonth/index.js\";\n import { startOfMonth } from \"../startOfMonth/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link eachWeekendOfMonth} function options.\n+ */\n+export interface EachWeekendOfMonthOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name eachWeekendOfMonth\n@@ -11,8 +18,10 @@ import { startOfMonth } from \"../startOfMonth/index.js\";\n  * Get all the Saturdays and Sundays in the given month.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The given month\n+ * @param options - An object with options\n  *\n  * @returns An array containing all the Saturdays and Sundays\n  *\n@@ -30,10 +39,14 @@ import { startOfMonth } from \"../startOfMonth/index.js\";\n  * //   Sun Feb 27 2022 00:00:00\n  * // ]\n  */\n-export function eachWeekendOfMonth<DateType extends Date>(\n-  date: DateType,\n-): DateType[] {\n-  const start = startOfMonth(date);\n-  const end = endOfMonth(date);\n-  return eachWeekendOfInterval({ start, end });\n+export function eachWeekendOfMonth<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n+  date: DateFns.Arg<DateType>,\n+  options?: EachWeekendOfMonthOptions<ResultDate>,\n+): ResultDate[] {\n+  const start = startOfMonth(date, options);\n+  const end = endOfMonth(date, options);\n+  return eachWeekendOfInterval({ start, end }, options);\n }\ndiff --git a/src/eachWeekendOfYear/index.ts b/src/eachWeekendOfYear/index.ts\nindex a7b776436a..a0bc5e7838 100644\n--- a/src/eachWeekendOfYear/index.ts\n+++ b/src/eachWeekendOfYear/index.ts\n@@ -1,6 +1,13 @@\n import { eachWeekendOfInterval } from \"../eachWeekendOfInterval/index.js\";\n import { endOfYear } from \"../endOfYear/index.js\";\n import { startOfYear } from \"../startOfYear/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link eachWeekendOfYear} function options.\n+ */\n+export interface EachWeekendOfYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name eachWeekendOfYear\n@@ -11,8 +18,10 @@ import { startOfYear } from \"../startOfYear/index.js\";\n  * Get all the Saturdays and Sundays in the year.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The given year\n+ * @param options - An object with options\n  *\n  * @returns An array containing all the Saturdays and Sundays\n  *\n@@ -27,10 +36,14 @@ import { startOfYear } from \"../startOfYear/index.js\";\n  * // ]\n  * ]\n  */\n-export function eachWeekendOfYear<DateType extends Date>(\n-  date: DateType | number | string,\n-): DateType[] {\n-  const start = startOfYear(date);\n-  const end = endOfYear(date);\n-  return eachWeekendOfInterval({ start, end });\n+export function eachWeekendOfYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n+  date: DateFns.Arg<DateType>,\n+  options?: EachWeekendOfYearOptions<ResultDate>,\n+): ResultDate[] {\n+  const start = startOfYear(date, options);\n+  const end = endOfYear(date, options);\n+  return eachWeekendOfInterval({ start, end }, options);\n }\ndiff --git a/src/eachYearOfInterval/index.ts b/src/eachYearOfInterval/index.ts\nindex ac4eb4004e..4329df34df 100644\n--- a/src/eachYearOfInterval/index.ts\n+++ b/src/eachYearOfInterval/index.ts\n@@ -1,10 +1,32 @@\n-import { toDate } from \"../toDate/index.js\";\n-import type { Interval, StepOptions } from \"../types.js\";\n+import { normalizeInterval } from \"../_lib/normalizeInterval/index.js\";\n+import { constructFrom } from \"../constructFrom/index.js\";\n+import type { DateFns, Interval, StepOptions } from \"../types.js\";\n \n /**\n  * The {@link eachYearOfInterval} function options.\n  */\n-export interface EachYearOfIntervalOptions extends StepOptions {}\n+export interface EachYearOfIntervalOptions<DateType extends Date = Date>\n+  extends StepOptions,\n+    DateFns.ContextOptions<DateType> {}\n+\n+/**\n+ * The {@link eachYearOfInterval} function result type. It resolves the proper data type.\n+ * It uses the first argument date object type, starting from the date argument,\n+ * then the start interval date, and finally the end interval date. If\n+ * a context function is passed, it uses the context function return type.\n+ */\n+export type EachYearOfIntervalResult<\n+  IntervalType extends Interval,\n+  Options extends EachYearOfIntervalOptions | undefined,\n+> = Array<\n+  Options extends EachYearOfIntervalOptions<infer DateType>\n+    ? DateType\n+    : IntervalType[\"start\"] extends Date\n+      ? IntervalType[\"start\"]\n+      : IntervalType[\"end\"] extends Date\n+        ? IntervalType[\"end\"]\n+        : Date\n+>;\n \n /**\n  * @name eachYearOfInterval\n@@ -14,9 +36,11 @@ export interface EachYearOfIntervalOptions extends StepOptions {}\n  * @description\n  * Return the array of yearly timestamps within the specified time interval.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam IntervalType - Interval type.\n+ * @typeParam Options - Options type.\n  *\n  * @param interval - The interval.\n+ * @param options - An object with options.\n  *\n  * @returns The array with starts of yearly timestamps from the month of the interval start to the month of the interval end\n  *\n@@ -33,18 +57,20 @@ export interface EachYearOfIntervalOptions extends StepOptions {}\n  * //   Sun Jan 01 2017 00:00:00\n  * // ]\n  */\n-export function eachYearOfInterval<DateType extends Date>(\n-  interval: Interval<DateType>,\n-  options?: EachYearOfIntervalOptions,\n-): DateType[] {\n-  const startDate = toDate(interval.start);\n-  const endDate = toDate(interval.end);\n+export function eachYearOfInterval<\n+  IntervalType extends Interval,\n+  Options extends EachYearOfIntervalOptions | undefined = undefined,\n+>(\n+  interval: IntervalType,\n+  options?: Options,\n+): EachYearOfIntervalResult<IntervalType, Options> {\n+  const { start, end } = normalizeInterval(options?.in, interval);\n \n-  let reversed = +startDate > +endDate;\n-  const endTime = reversed ? +startDate : +endDate;\n-  const currentDate = reversed ? endDate : startDate;\n-  currentDate.setHours(0, 0, 0, 0);\n-  currentDate.setMonth(0, 1);\n+  let reversed = +start > +end;\n+  const endTime = reversed ? +start : +end;\n+  const date = reversed ? end : start;\n+  date.setHours(0, 0, 0, 0);\n+  date.setMonth(0, 1);\n \n   let step = options?.step ?? 1;\n   if (!step) return [];\n@@ -53,11 +79,11 @@ export function eachYearOfInterval<DateType extends Date>(\n     reversed = !reversed;\n   }\n \n-  const dates = [];\n+  const dates: EachYearOfIntervalResult<IntervalType, Options> = [];\n \n-  while (+currentDate <= endTime) {\n-    dates.push(toDate(currentDate));\n-    currentDate.setFullYear(currentDate.getFullYear() + step);\n+  while (+date <= endTime) {\n+    dates.push(constructFrom(start, date));\n+    date.setFullYear(date.getFullYear() + step);\n   }\n \n   return reversed ? dates.reverse() : dates;\ndiff --git a/src/endOfDay/index.ts b/src/endOfDay/index.ts\nindex 50886723b8..775c7a58db 100644\n--- a/src/endOfDay/index.ts\n+++ b/src/endOfDay/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfDay} function options.\n+ */\n+export interface EndOfDayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfDay\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The end of a day\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Tue Sep 02 2014 23:59:59.999\n  */\n-export function endOfDay<DateType extends Date>(\n+export function endOfDay<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: EndOfDayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setHours(23, 59, 59, 999);\n   return _date;\n }\ndiff --git a/src/endOfDecade/index.ts b/src/endOfDecade/index.ts\nindex 1b13b6983c..cb7a96fdd1 100644\n--- a/src/endOfDecade/index.ts\n+++ b/src/endOfDecade/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfDecade} function options.\n+ */\n+export interface EndOfDecadeOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfDecade\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Return the end of a decade for the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The end of a decade\n  *\n@@ -19,13 +28,17 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = endOfDecade(new Date(1984, 4, 12, 00, 00, 00))\n  * //=> Dec 31 1989 23:59:59.999\n  */\n-export function endOfDecade<DateType extends Date>(\n+export function endOfDecade<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n+  options?: EndOfDecadeOptions<ResultDate> | undefined,\n+): ResultDate {\n   // TODO: Switch to more technical definition in of decades that start with 1\n   // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking\n   // change, so it can only be done in 4.0.\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const year = _date.getFullYear();\n   const decade = 9 + Math.floor(year / 10) * 10;\n   _date.setFullYear(decade, 11, 31);\ndiff --git a/src/endOfHour/index.ts b/src/endOfHour/index.ts\nindex 3204f8c0b7..ee21d3b529 100644\n--- a/src/endOfHour/index.ts\n+++ b/src/endOfHour/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfHour} function options.\n+ */\n+export interface EndOfHourOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfHour\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The end of an hour\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = endOfHour(new Date(2014, 8, 2, 11, 55))\n  * //=> Tue Sep 02 2014 11:59:59.999\n  */\n-export function endOfHour<DateType extends Date>(\n+export function endOfHour<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: EndOfHourOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setMinutes(59, 59, 999);\n   return _date;\n }\ndiff --git a/src/endOfISOWeek/index.ts b/src/endOfISOWeek/index.ts\nindex 837fd660ed..453b26f00b 100644\n--- a/src/endOfISOWeek/index.ts\n+++ b/src/endOfISOWeek/index.ts\n@@ -1,4 +1,11 @@\n import { endOfWeek } from \"../endOfWeek/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfISOWeek} function options.\n+ */\n+export interface EndOfISOWeekOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfISOWeek\n@@ -12,8 +19,10 @@ import { endOfWeek } from \"../endOfWeek/index.js\";\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The end of an ISO week\n  *\n@@ -22,8 +31,12 @@ import { endOfWeek } from \"../endOfWeek/index.js\";\n  * const result = endOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Sun Sep 07 2014 23:59:59.999\n  */\n-export function endOfISOWeek<DateType extends Date>(\n+export function endOfISOWeek<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return endOfWeek(date, { weekStartsOn: 1 });\n+  options?: EndOfISOWeekOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return endOfWeek(date, { ...options, weekStartsOn: 1 });\n }\ndiff --git a/src/endOfISOWeekYear/index.ts b/src/endOfISOWeekYear/index.ts\nindex 9902c1f20f..d540f01f22 100644\n--- a/src/endOfISOWeekYear/index.ts\n+++ b/src/endOfISOWeekYear/index.ts\n@@ -1,6 +1,13 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { getISOWeekYear } from \"../getISOWeekYear/index.js\";\n import { startOfISOWeek } from \"../startOfISOWeek/index.js\";\n-import { constructFrom } from \"../constructFrom/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfISOWeekYear} function options.\n+ */\n+export interface EndOfISOWeekYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfISOWeekYear\n@@ -15,8 +22,10 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The original date\n+ * @param options - The options\n  *\n  * @returns The end of an ISO week-numbering year\n  *\n@@ -25,14 +34,18 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * const result = endOfISOWeekYear(new Date(2005, 6, 2))\n  * //=> Sun Jan 01 2006 23:59:59.999\n  */\n-export function endOfISOWeekYear<DateType extends Date>(\n+export function endOfISOWeekYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const year = getISOWeekYear(date);\n-  const fourthOfJanuaryOfNextYear = constructFrom(date, 0);\n+  options?: EndOfISOWeekYearOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const year = getISOWeekYear(date, options);\n+  const fourthOfJanuaryOfNextYear = constructFrom(options?.in || date, 0);\n   fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);\n   fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);\n-  const _date = startOfISOWeek(fourthOfJanuaryOfNextYear);\n+  const _date = startOfISOWeek(fourthOfJanuaryOfNextYear, options);\n   _date.setMilliseconds(_date.getMilliseconds() - 1);\n   return _date;\n }\ndiff --git a/src/endOfMinute/index.ts b/src/endOfMinute/index.ts\nindex 5e1ebef0ef..72636e5fcd 100644\n--- a/src/endOfMinute/index.ts\n+++ b/src/endOfMinute/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfMinute} function options.\n+ */\n+export interface EndOfMinuteOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfMinute\n@@ -7,11 +14,13 @@ import { toDate } from \"../toDate/index.js\";\n  *\n  * @description\n  * Return the end of a minute for the given date.\n- * The result will be in the local timezone.\n+ * The result will be in the local timezone or the provided context.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The end of a minute\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = endOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))\n  * //=> Mon Dec 01 2014 22:15:59.999\n  */\n-export function endOfMinute<DateType extends Date>(\n+export function endOfMinute<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: EndOfMinuteOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setSeconds(59, 999);\n   return _date;\n }\ndiff --git a/src/endOfMonth/index.ts b/src/endOfMonth/index.ts\nindex d94e3e804e..11589ccacc 100644\n--- a/src/endOfMonth/index.ts\n+++ b/src/endOfMonth/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfMonth} function options.\n+ */\n+export interface EndOfMonthOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfMonth\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The end of a month\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Tue Sep 30 2014 23:59:59.999\n  */\n-export function endOfMonth<DateType extends Date>(\n+export function endOfMonth<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: EndOfMonthOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   const month = _date.getMonth();\n   _date.setFullYear(_date.getFullYear(), month + 1, 0);\n   _date.setHours(23, 59, 59, 999);\ndiff --git a/src/endOfQuarter/index.ts b/src/endOfQuarter/index.ts\nindex 4c987db0b8..447866c237 100644\n--- a/src/endOfQuarter/index.ts\n+++ b/src/endOfQuarter/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfQuarter} function options.\n+ */\n+export interface EndOfQuarterOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfQuarter\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The end of a quarter\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = endOfQuarter(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Tue Sep 30 2014 23:59:59.999\n  */\n-export function endOfQuarter<DateType extends Date>(\n+export function endOfQuarter<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: EndOfQuarterOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   const currentMonth = _date.getMonth();\n   const month = currentMonth - (currentMonth % 3) + 3;\n   _date.setMonth(month, 0);\ndiff --git a/src/endOfSecond/index.ts b/src/endOfSecond/index.ts\nindex ffd734e847..bd4f891b60 100644\n--- a/src/endOfSecond/index.ts\n+++ b/src/endOfSecond/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfSecond} function options.\n+ */\n+export interface EndOfSecondOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfSecond\n@@ -7,11 +14,13 @@ import { toDate } from \"../toDate/index.js\";\n  *\n  * @description\n  * Return the end of a second for the given date.\n- * The result will be in the local timezone.\n+ * The result will be in the local timezone if no `in` option is specified.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The end of a second\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = endOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))\n  * //=> Mon Dec 01 2014 22:15:45.999\n  */\n-export function endOfSecond<DateType extends Date>(\n+export function endOfSecond<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: EndOfSecondOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setMilliseconds(999);\n   return _date;\n }\ndiff --git a/src/endOfToday/index.ts b/src/endOfToday/index.ts\nindex 678835daf9..93571ccd16 100644\n--- a/src/endOfToday/index.ts\n+++ b/src/endOfToday/index.ts\n@@ -1,4 +1,11 @@\n import { endOfDay } from \"../endOfDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfToday} function options.\n+ */\n+export interface EndOfTodayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfToday\n@@ -10,6 +17,9 @@ import { endOfDay } from \"../endOfDay/index.js\";\n  * Return the end of today.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n+ *\n+ * @param options - The options\n  *\n  * @returns The end of today\n  *\n@@ -18,6 +28,8 @@ import { endOfDay } from \"../endOfDay/index.js\";\n  * const result = endOfToday()\n  * //=> Mon Oct 6 2014 23:59:59.999\n  */\n-export function endOfToday(): Date {\n-  return endOfDay(Date.now());\n+export function endOfToday<ResultDate extends Date = Date>(\n+  options?: EndOfTodayOptions<ResultDate>,\n+): ResultDate {\n+  return endOfDay(Date.now(), options);\n }\ndiff --git a/src/endOfTomorrow/index.ts b/src/endOfTomorrow/index.ts\nindex df3e59fe20..9a57bbcf73 100644\n--- a/src/endOfTomorrow/index.ts\n+++ b/src/endOfTomorrow/index.ts\n@@ -1,3 +1,12 @@\n+import { constructNow } from \"../constructNow/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfTomorrow} function options.\n+ */\n+export interface EndOfTomorrowOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n+\n /**\n  * @name endOfTomorrow\n  * @category Day Helpers\n@@ -8,7 +17,9 @@\n  * Return the end of tomorrow.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n+ * @param options - The options\n  * @returns The end of tomorrow\n  *\n  * @example\n@@ -16,14 +27,17 @@\n  * const result = endOfTomorrow()\n  * //=> Tue Oct 7 2014 23:59:59.999\n  */\n-export function endOfTomorrow(): Date {\n-  const now = new Date();\n+export function endOfTomorrow<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(options?: EndOfTomorrowOptions<ResultDate> | undefined): ResultDate {\n+  const now = constructNow(options?.in);\n   const year = now.getFullYear();\n   const month = now.getMonth();\n   const day = now.getDate();\n \n-  const date = new Date(0);\n+  const date = constructNow(options?.in);\n   date.setFullYear(year, month, day + 1);\n   date.setHours(23, 59, 59, 999);\n-  return date;\n+  return options?.in ? options.in(date) : (date as ResultDate);\n }\ndiff --git a/src/endOfWeek/index.ts b/src/endOfWeek/index.ts\nindex 3021f3a113..21d9e16f52 100644\n--- a/src/endOfWeek/index.ts\n+++ b/src/endOfWeek/index.ts\n@@ -1,13 +1,15 @@\n+import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n import { toDate } from \"../toDate/index.js\";\n import type { LocalizedOptions, WeekOptions } from \"../types.js\";\n-import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n+import { type DateFns } from \"../types.js\";\n \n /**\n  * The {@link endOfWeek} function options.\n  */\n-export interface EndOfWeekOptions\n+export interface EndOfWeekOptions<DateType extends Date = Date>\n   extends WeekOptions,\n-    LocalizedOptions<\"options\"> {}\n+    LocalizedOptions<\"options\">,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfWeek\n@@ -19,6 +21,7 @@ export interface EndOfWeekOptions\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n  * @param options - An object with options\n@@ -35,10 +38,13 @@ export interface EndOfWeekOptions\n  * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })\n  * //=> Sun Sep 07 2014 23:59:59.999\n  */\n-export function endOfWeek<DateType extends Date>(\n+export function endOfWeek<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-  options?: EndOfWeekOptions,\n-): DateType {\n+  options?: EndOfWeekOptions<ResultDate>,\n+): ResultDate {\n   const defaultOptions = getDefaultOptions();\n   const weekStartsOn =\n     options?.weekStartsOn ??\n@@ -47,7 +53,7 @@ export function endOfWeek<DateType extends Date>(\n     defaultOptions.locale?.options?.weekStartsOn ??\n     0;\n \n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const day = _date.getDay();\n   const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);\n \ndiff --git a/src/endOfYear/index.ts b/src/endOfYear/index.ts\nindex 9e00d49dfe..bbe316d66b 100644\n--- a/src/endOfYear/index.ts\n+++ b/src/endOfYear/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfYear} function options.\n+ */\n+export interface EndOfYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name endOfYear\n@@ -10,20 +17,26 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - The options\n  *\n  * @returns The end of a year\n  *\n  * @example\n  * // The end of a year for 2 September 2014 11:55:00:\n- * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))\n+ * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Wed Dec 31 2014 23:59:59.999\n  */\n-export function endOfYear<DateType extends Date>(\n+export function endOfYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: EndOfYearOptions<ResultDate>,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   const year = _date.getFullYear();\n   _date.setFullYear(year + 1, 0, 0);\n   _date.setHours(23, 59, 59, 999);\ndiff --git a/src/endOfYesterday/index.ts b/src/endOfYesterday/index.ts\nindex 7b272e7a73..7cd0de907e 100644\n--- a/src/endOfYesterday/index.ts\n+++ b/src/endOfYesterday/index.ts\n@@ -1,3 +1,13 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n+import { constructNow } from \"../constructNow/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link endOfYesterday} function options.\n+ */\n+export interface EndOfYesterdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n+\n /**\n  * @name endOfYesterday\n  * @category Day Helpers\n@@ -8,6 +18,7 @@\n  * Return the end of yesterday.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @returns The end of yesterday\n  *\n@@ -16,14 +27,13 @@\n  * const result = endOfYesterday()\n  * //=> Sun Oct 5 2014 23:59:59.999\n  */\n-export function endOfYesterday(): Date {\n-  const now = new Date();\n-  const year = now.getFullYear();\n-  const month = now.getMonth();\n-  const day = now.getDate();\n-\n-  const date = new Date(0);\n-  date.setFullYear(year, month, day - 1);\n+export function endOfYesterday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(options?: EndOfYesterdayOptions<ResultDate> | undefined): ResultDate {\n+  const now = constructNow(options?.in);\n+  const date = constructFrom(options?.in, 0);\n+  date.setFullYear(now.getFullYear(), now.getMonth(), now.getDate() - 1);\n   date.setHours(23, 59, 59, 999);\n   return date;\n }\ndiff --git a/src/formatDistance/index.ts b/src/formatDistance/index.ts\nindex 60d083f80f..8cb287b220 100644\n--- a/src/formatDistance/index.ts\n+++ b/src/formatDistance/index.ts\n@@ -1,18 +1,19 @@\n+import { defaultLocale } from \"../_lib/defaultLocale/index.js\";\n+import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n+import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { compareAsc } from \"../compareAsc/index.js\";\n import { minutesInDay, minutesInMonth } from \"../constants/index.js\";\n import { differenceInMonths } from \"../differenceInMonths/index.js\";\n import { differenceInSeconds } from \"../differenceInSeconds/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n-import type { LocalizedOptions } from \"../types.js\";\n-import { defaultLocale } from \"../_lib/defaultLocale/index.js\";\n-import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n-import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\n+import type { DateFns, LocalizedOptions } from \"../types.js\";\n \n /**\n  * The {@link formatDistance} function options.\n  */\n export interface FormatDistanceOptions\n-  extends LocalizedOptions<\"formatDistance\"> {\n+  extends LocalizedOptions<\"formatDistance\">,\n+    DateFns.ContextOptions<Date> {\n   /** Distances less than a minute are more detailed */\n   includeSeconds?: boolean;\n   /** Add \"X ago\"/\"in X\" in the locale language */\n@@ -56,10 +57,8 @@ export interface FormatDistanceOptions\n  * | 40 secs ... 60 secs    | less than a minute   |\n  * | 60 secs ... 90 secs    | 1 minute             |\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param date - The date\n- * @param baseDate - The date to compare with\n+ * @param laterDate - The date\n+ * @param earlierDate - The date to compare with\n  * @param options - An object with options\n  *\n  * @returns The distance in words\n@@ -99,41 +98,33 @@ export interface FormatDistanceOptions\n  * })\n  * //=> 'pli ol 1 jaro'\n  */\n-\n-export function formatDistance<DateType extends Date>(\n-  date: DateType | number | string,\n-  baseDate: DateType | number | string,\n+export function formatDistance(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n   options?: FormatDistanceOptions,\n ): string {\n   const defaultOptions = getDefaultOptions();\n   const locale = options?.locale ?? defaultOptions.locale ?? defaultLocale;\n   const minutesInAlmostTwoDays = 2520;\n \n-  const comparison = compareAsc(date, baseDate);\n+  const comparison = compareAsc(laterDate, earlierDate);\n \n-  if (isNaN(comparison)) {\n-    throw new RangeError(\"Invalid time value\");\n-  }\n+  if (isNaN(comparison)) throw new RangeError(\"Invalid time value\");\n \n   const localizeOptions = Object.assign({}, options, {\n     addSuffix: options?.addSuffix,\n     comparison: comparison as -1 | 0 | 1,\n   });\n \n-  let dateLeft;\n-  let dateRight;\n-  if (comparison > 0) {\n-    dateLeft = toDate(baseDate);\n-    dateRight = toDate(date);\n-  } else {\n-    dateLeft = toDate(date);\n-    dateRight = toDate(baseDate);\n-  }\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    ...(comparison > 0 ? [earlierDate, laterDate] : [laterDate, earlierDate]),\n+  );\n \n-  const seconds = differenceInSeconds(dateRight, dateLeft);\n+  const seconds = differenceInSeconds(earlierDate_, laterDate_);\n   const offsetInSeconds =\n-    (getTimezoneOffsetInMilliseconds(dateRight) -\n-      getTimezoneOffsetInMilliseconds(dateLeft)) /\n+    (getTimezoneOffsetInMilliseconds(earlierDate_) -\n+      getTimezoneOffsetInMilliseconds(laterDate_)) /\n     1000;\n   const minutes = Math.round((seconds - offsetInSeconds) / 60);\n   let months;\n@@ -190,7 +181,7 @@ export function formatDistance<DateType extends Date>(\n     return locale.formatDistance(\"aboutXMonths\", months, localizeOptions);\n   }\n \n-  months = differenceInMonths(dateRight, dateLeft);\n+  months = differenceInMonths(earlierDate_, laterDate_);\n \n   // 2 months up to 12 months\n   if (months < 12) {\ndiff --git a/src/formatDistanceStrict/index.ts b/src/formatDistanceStrict/index.ts\nindex 202528c9ce..11bee64726 100644\n--- a/src/formatDistanceStrict/index.ts\n+++ b/src/formatDistanceStrict/index.ts\n@@ -2,6 +2,7 @@ import { defaultLocale } from \"../_lib/defaultLocale/index.js\";\n import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n import { getRoundingMethod } from \"../_lib/getRoundingMethod/index.js\";\n import { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { compareAsc } from \"../compareAsc/index.js\";\n import {\n   millisecondsInMinute,\n@@ -9,15 +10,15 @@ import {\n   minutesInMonth,\n   minutesInYear,\n } from \"../constants/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n-import type { LocalizedOptions, RoundingOptions } from \"../types.js\";\n+import type { DateFns, LocalizedOptions, RoundingOptions } from \"../types.js\";\n \n /**\n  * The {@link formatDistanceStrict} function options.\n  */\n export interface FormatDistanceStrictOptions\n   extends LocalizedOptions<\"formatDistance\">,\n-    RoundingOptions {\n+    RoundingOptions,\n+    DateFns.ContextOptions<Date> {\n   /** Add \"X ago\"/\"in X\" in the locale language */\n   addSuffix?: boolean;\n   /** If specified, will force the unit */\n@@ -54,10 +55,8 @@ export type FormatDistanceStrictUnit =\n  * | 1 ... 11 months        | [1..11] months      |\n  * | 1 ... N years          | [1..N]  years       |\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param date - The date\n- * @param baseDate - The date to compare with\n+ * @param laterDate - The date\n+ * @param earlierDate - The date to compare with\n  * @param options - An object with options\n  *\n  * @returns The distance in words\n@@ -115,15 +114,15 @@ export type FormatDistanceStrictUnit =\n  * //=> '1 jaro'\n  */\n \n-export function formatDistanceStrict<DateType extends Date>(\n-  date: DateType | number | string,\n-  baseDate: DateType | number | string,\n+export function formatDistanceStrict(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n   options?: FormatDistanceStrictOptions,\n ): string {\n   const defaultOptions = getDefaultOptions();\n   const locale = options?.locale ?? defaultOptions.locale ?? defaultLocale;\n \n-  const comparison = compareAsc(date, baseDate);\n+  const comparison = compareAsc(laterDate, earlierDate);\n \n   if (isNaN(comparison)) {\n     throw new RangeError(\"Invalid time value\");\n@@ -134,24 +133,19 @@ export function formatDistanceStrict<DateType extends Date>(\n     comparison: comparison as -1 | 0 | 1,\n   });\n \n-  let dateLeft;\n-  let dateRight;\n-  if (comparison > 0) {\n-    dateLeft = toDate(baseDate);\n-    dateRight = toDate(date);\n-  } else {\n-    dateLeft = toDate(date);\n-    dateRight = toDate(baseDate);\n-  }\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    ...(comparison > 0 ? [earlierDate, laterDate] : [laterDate, earlierDate]),\n+  );\n \n   const roundingMethod = getRoundingMethod(options?.roundingMethod ?? \"round\");\n \n-  const milliseconds = dateRight.getTime() - dateLeft.getTime();\n+  const milliseconds = earlierDate_.getTime() - laterDate_.getTime();\n   const minutes = milliseconds / millisecondsInMinute;\n \n   const timezoneOffset =\n-    getTimezoneOffsetInMilliseconds(dateRight) -\n-    getTimezoneOffsetInMilliseconds(dateLeft);\n+    getTimezoneOffsetInMilliseconds(earlierDate_) -\n+    getTimezoneOffsetInMilliseconds(laterDate_);\n \n   // Use DST-normalized difference in minutes for years, months and days;\n   // use regular difference in minutes for hours, minutes and seconds.\ndiff --git a/src/formatDistanceToNow/index.ts b/src/formatDistanceToNow/index.ts\nindex a73aa6c5b6..8566619670 100644\n--- a/src/formatDistanceToNow/index.ts\n+++ b/src/formatDistanceToNow/index.ts\n@@ -1,11 +1,14 @@\n import { constructNow } from \"../constructNow/index.js\";\n import type { FormatDistanceOptions } from \"../formatDistance/index.js\";\n import { formatDistance } from \"../formatDistance/index.js\";\n+import { type DateFns } from \"../types.js\";\n \n /**\n  * The {@link formatDistanceToNow} function options.\n  */\n-export interface FormatDistanceToNowOptions extends FormatDistanceOptions {}\n+export interface FormatDistanceToNowOptions\n+  extends FormatDistanceOptions,\n+    DateFns.ContextOptions<Date> {}\n \n /**\n  * @name formatDistanceToNow\n@@ -45,8 +48,6 @@ export interface FormatDistanceToNowOptions extends FormatDistanceOptions {}\n  * | 40 secs ... 60 secs | less than a minute   |\n  * | 60 secs ... 90 secs | 1 minute             |\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n  * @param date - The given date\n  * @param options - The object with options\n  *\n@@ -90,8 +91,8 @@ export interface FormatDistanceToNowOptions extends FormatDistanceOptions {}\n  * )\n  * //=> 'pli ol 1 jaro'\n  */\n-export function formatDistanceToNow<DateType extends Date>(\n-  date: DateType | number | string,\n+export function formatDistanceToNow(\n+  date: DateFns.Arg,\n   options?: FormatDistanceToNowOptions,\n ): string {\n   return formatDistance(date, constructNow(date), options);\ndiff --git a/src/formatDistanceToNowStrict/index.ts b/src/formatDistanceToNowStrict/index.ts\nindex 4199e012b0..e156320833 100644\n--- a/src/formatDistanceToNowStrict/index.ts\n+++ b/src/formatDistanceToNowStrict/index.ts\n@@ -1,12 +1,14 @@\n+import { constructNow } from \"../constructNow/index.js\";\n import type { FormatDistanceStrictOptions } from \"../formatDistanceStrict/index.js\";\n import { formatDistanceStrict } from \"../formatDistanceStrict/index.js\";\n-import { constructNow } from \"../constructNow/index.js\";\n+import { type DateFns } from \"../types.js\";\n \n /**\n  * The {@link formatDistanceToNowStrict} function options.\n  */\n export interface FormatDistanceToNowStrictOptions\n-  extends FormatDistanceStrictOptions {}\n+  extends FormatDistanceStrictOptions,\n+    DateFns.ContextOptions<Date> {}\n \n /**\n  * @name formatDistanceToNowStrict\n@@ -28,8 +30,6 @@ export interface FormatDistanceToNowStrictOptions\n  * | 1 ... 11 months        | [1..11] months      |\n  * | 1 ... N years          | [1..N]  years       |\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n  * @param date - The given date\n  * @param options - An object with options.\n  *\n@@ -81,8 +81,8 @@ export interface FormatDistanceToNowStrictOptions\n  * )\n  * //=> '1 jaro'\n  */\n-export function formatDistanceToNowStrict<DateType extends Date>(\n-  date: DateType | number | string,\n+export function formatDistanceToNowStrict(\n+  date: DateFns.Arg,\n   options?: FormatDistanceToNowStrictOptions,\n ): string {\n   return formatDistanceStrict(date, constructNow(date), options);\ndiff --git a/src/fromUnixTime/index.ts b/src/fromUnixTime/index.ts\nindex 6cdf37d4d3..3ab3cadf50 100644\n--- a/src/fromUnixTime/index.ts\n+++ b/src/fromUnixTime/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link fromUnixTime} function options.\n+ */\n+export interface FromUnixTimeOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name fromUnixTime\n@@ -9,6 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Create a date from a Unix timestamp (in seconds). Decimal values will be discarded.\n  *\n  * @param unixTime - The given Unix timestamp (in seconds)\n+ * @param options - An object with options. Allows to pass a context.\n+ *\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @returns The date\n  *\n@@ -17,6 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = fromUnixTime(1330515905)\n  * //=> Wed Feb 29 2012 11:45:05\n  */\n-export function fromUnixTime(unixTime: number): Date {\n-  return toDate(unixTime * 1000);\n+export function fromUnixTime<DateType extends Date = Date>(\n+  unixTime: number,\n+  options?: FromUnixTimeOptions<DateType> | undefined,\n+): DateType {\n+  return toDate(unixTime * 1000, options?.in);\n }\ndiff --git a/src/getDate/index.ts b/src/getDate/index.ts\nindex 08811f8f96..3534ad9f6c 100644\n--- a/src/getDate/index.ts\n+++ b/src/getDate/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getDate} function options.\n+ */\n+export interface GetDateOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getDate\n@@ -11,6 +18,7 @@ import { toDate } from \"../toDate/index.js\";\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n  *\n  * @param date - The given date\n+ * @param options - An object with options.\n  *\n  * @returns The day of month\n  *\n@@ -19,10 +27,12 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getDate(new Date(2012, 1, 29))\n  * //=> 29\n  */\n-export function getDate<DateType extends Date>(\n+export function getDate<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n+  options?: GetDateOptions<ResultDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n-  const dayOfMonth = _date.getDate();\n-  return dayOfMonth;\n+  return toDate(date, options?.in).getDate();\n }\ndiff --git a/src/getDay/index.ts b/src/getDay/index.ts\nindex 8d9e034b6e..92af9dcc0f 100644\n--- a/src/getDay/index.ts\n+++ b/src/getDay/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getDay} function options.\n+ */\n+export interface GetDayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getDay\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Get the day of the week of the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n+ * @param options - The options\n  *\n  * @returns The day of week, 0 represents Sunday\n  *\n@@ -19,10 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getDay(new Date(2012, 1, 29))\n  * //=> 3\n  */\n-export function getDay<DateType extends Date>(\n+export function getDay<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetDayOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n-  const day = _date.getDay();\n-  return day;\n+  return toDate(date, options?.in).getDay();\n }\ndiff --git a/src/getDayOfYear/index.ts b/src/getDayOfYear/index.ts\nindex 87349a4329..ae5fa0f57a 100644\n--- a/src/getDayOfYear/index.ts\n+++ b/src/getDayOfYear/index.ts\n@@ -1,6 +1,13 @@\n import { differenceInCalendarDays } from \"../differenceInCalendarDays/index.js\";\n import { startOfYear } from \"../startOfYear/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getDayOfYear} function options.\n+ */\n+export interface GetDayOfYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getDayOfYear\n@@ -11,8 +18,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Get the day of the year of the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n+ * @param options - The options\n  *\n  * @returns The day of year\n  *\n@@ -21,10 +30,11 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getDayOfYear(new Date(2014, 6, 2))\n  * //=> 183\n  */\n-export function getDayOfYear<DateType extends Date>(\n+export function getDayOfYear<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetDayOfYearOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const diff = differenceInCalendarDays(_date, startOfYear(_date));\n   const dayOfYear = diff + 1;\n   return dayOfYear;\ndiff --git a/src/getDaysInMonth/index.ts b/src/getDaysInMonth/index.ts\nindex 18c4aec4e9..037641fffa 100644\n--- a/src/getDaysInMonth/index.ts\n+++ b/src/getDaysInMonth/index.ts\n@@ -1,5 +1,12 @@\n-import { toDate } from \"../toDate/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n+import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getDaysInMonth} function options.\n+ */\n+export interface GetDaysInMonthOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getDaysInMonth\n@@ -7,11 +14,12 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * @summary Get the number of days in a month of the given date.\n  *\n  * @description\n- * Get the number of days in a month of the given date.\n+ * Get the number of days in a month of the given date, considering the context if provided.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n  *\n  * @param date - The given date\n+ * @param options - An object with options\n  *\n  * @returns The number of days in a month\n  *\n@@ -20,13 +28,14 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * const result = getDaysInMonth(new Date(2000, 1))\n  * //=> 29\n  */\n-export function getDaysInMonth<DateType extends Date>(\n+export function getDaysInMonth<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetDaysInMonthOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const year = _date.getFullYear();\n   const monthIndex = _date.getMonth();\n-  const lastDayOfMonth = constructFrom(date, 0);\n+  const lastDayOfMonth = constructFrom(_date, 0);\n   lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);\n   lastDayOfMonth.setHours(0, 0, 0, 0);\n   return lastDayOfMonth.getDate();\ndiff --git a/src/getDaysInYear/index.ts b/src/getDaysInYear/index.ts\nindex cd3388c99f..ed55ad693b 100644\n--- a/src/getDaysInYear/index.ts\n+++ b/src/getDaysInYear/index.ts\n@@ -1,5 +1,12 @@\n import { isLeapYear } from \"../isLeapYear/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getDaysInYear} function options.\n+ */\n+export interface GetDaysInYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getDaysInYear\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Get the number of days in a year of the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n+ * @param options - An object with options\n  *\n  * @returns The number of days in a year\n  *\n@@ -20,14 +29,11 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getDaysInYear(new Date(2012, 0, 1))\n  * //=> 366\n  */\n-export function getDaysInYear<DateType extends Date>(\n+export function getDaysInYear<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetDaysInYearOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n-\n-  if (String(new Date(_date)) === \"Invalid Date\") {\n-    return NaN;\n-  }\n-\n+  const _date = toDate(date, options?.in);\n+  if (Number.isNaN(+_date)) return NaN;\n   return isLeapYear(_date) ? 366 : 365;\n }\ndiff --git a/src/getDecade/index.ts b/src/getDecade/index.ts\nindex a06eca8812..ee16f591ec 100644\n--- a/src/getDecade/index.ts\n+++ b/src/getDecade/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getDecade} function options.\n+ */\n+export interface GetDecadeOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getDecade\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Get the decade of the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n+ * @param options - An object with options\n  *\n  * @returns The year of decade\n  *\n@@ -19,13 +28,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getDecade(new Date(1942, 10, 27))\n  * //=> 1940\n  */\n-export function getDecade<DateType extends Date>(\n+export function getDecade<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetDecadeOptions<ContextDate> | undefined,\n ): number {\n   // TODO: Switch to more technical definition in of decades that start with 1\n   // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking\n   // change, so it can only be done in 4.0.\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const year = _date.getFullYear();\n   const decade = Math.floor(year / 10) * 10;\n   return decade;\ndiff --git a/src/getHours/index.ts b/src/getHours/index.ts\nindex 330595c470..7f0e73778d 100644\n--- a/src/getHours/index.ts\n+++ b/src/getHours/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getHours} function options.\n+ */\n+export interface GetHoursOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getHours\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Get the hours of the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n+ * @param options - An object with options\n  *\n  * @returns The hours\n  *\n@@ -19,10 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getHours(new Date(2012, 1, 29, 11, 45))\n  * //=> 11\n  */\n-export function getHours<DateType extends Date>(\n+export function getHours<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetHoursOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n-  const hours = _date.getHours();\n-  return hours;\n+  return toDate(date, options?.in).getHours();\n }\ndiff --git a/src/getISODay/index.ts b/src/getISODay/index.ts\nindex 9f1a722d73..9a00ec4de0 100644\n--- a/src/getISODay/index.ts\n+++ b/src/getISODay/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getISODay} function options.\n+ */\n+export interface GetISODayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getISODay\n@@ -12,8 +19,10 @@ import { toDate } from \"../toDate/index.js\";\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n+ * @param options - An object with options\n  *\n  * @returns The day of ISO week\n  *\n@@ -22,15 +31,10 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getISODay(new Date(2012, 1, 26))\n  * //=> 7\n  */\n-export function getISODay<DateType extends Date>(\n+export function getISODay<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetISODayOptions<ContextDate>,\n ): number {\n-  const _date = toDate(date);\n-  let day = _date.getDay();\n-\n-  if (day === 0) {\n-    day = 7;\n-  }\n-\n-  return day;\n+  const day = toDate(date, options?.in).getDay();\n+  return day === 0 ? 7 : day;\n }\ndiff --git a/src/getISOWeek/index.ts b/src/getISOWeek/index.ts\nindex aef0f261fb..54ca7ab1c4 100644\n--- a/src/getISOWeek/index.ts\n+++ b/src/getISOWeek/index.ts\n@@ -2,6 +2,13 @@ import { millisecondsInWeek } from \"../constants/index.js\";\n import { startOfISOWeek } from \"../startOfISOWeek/index.js\";\n import { startOfISOWeekYear } from \"../startOfISOWeekYear/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getISOWeek} function options.\n+ */\n+export interface GetISOWeekOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getISOWeek\n@@ -16,6 +23,7 @@ import { toDate } from \"../toDate/index.js\";\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n  *\n  * @param date - The given date\n+ * @param options - The options\n  *\n  * @returns The ISO week\n  *\n@@ -24,10 +32,11 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getISOWeek(new Date(2005, 0, 2))\n  * //=> 53\n  */\n-export function getISOWeek<DateType extends Date>(\n+export function getISOWeek<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetISOWeekOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);\n \n   // Round the number of weeks to the nearest integer because the number of\ndiff --git a/src/getISOWeekYear/index.ts b/src/getISOWeekYear/index.ts\nindex adf2fd5723..edc5f2e9fe 100644\n--- a/src/getISOWeekYear/index.ts\n+++ b/src/getISOWeekYear/index.ts\n@@ -1,6 +1,13 @@\n import { constructFrom } from \"../constructFrom/index.js\";\n import { startOfISOWeek } from \"../startOfISOWeek/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getISOWeekYear} function options.\n+ */\n+export interface GetISOWeekYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getISOWeekYear\n@@ -14,6 +21,7 @@ import { toDate } from \"../toDate/index.js\";\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n  *\n@@ -24,18 +32,19 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getISOWeekYear(new Date(2005, 0, 2))\n  * //=> 2004\n  */\n-export function getISOWeekYear<DateType extends Date>(\n+export function getISOWeekYear<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetISOWeekYearOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const year = _date.getFullYear();\n \n-  const fourthOfJanuaryOfNextYear = constructFrom(date, 0);\n+  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);\n   fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);\n   fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);\n   const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);\n \n-  const fourthOfJanuaryOfThisYear = constructFrom(date, 0);\n+  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);\n   fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);\n   fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);\n   const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);\ndiff --git a/src/getISOWeeksInYear/index.ts b/src/getISOWeeksInYear/index.ts\nindex 7b3ae8e1f9..0e5bae1798 100644\n--- a/src/getISOWeeksInYear/index.ts\n+++ b/src/getISOWeeksInYear/index.ts\n@@ -1,6 +1,13 @@\n import { addWeeks } from \"../addWeeks/index.js\";\n import { millisecondsInWeek } from \"../constants/index.js\";\n import { startOfISOWeekYear } from \"../startOfISOWeekYear/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getISOWeeksInYear} function options.\n+ */\n+export interface GetISOWeeksInYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getISOWeeksInYear\n@@ -12,9 +19,10 @@ import { startOfISOWeekYear } from \"../startOfISOWeekYear/index.js\";\n  *\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  * @param date - The given date\n+ * @param options - An object with options\n  *\n  * @returns The number of ISO weeks in a year\n  *\n@@ -23,10 +31,14 @@ import { startOfISOWeekYear } from \"../startOfISOWeekYear/index.js\";\n  * const result = getISOWeeksInYear(new Date(2015, 1, 11))\n  * //=> 53\n  */\n-export function getISOWeeksInYear<DateType extends Date>(\n+export function getISOWeeksInYear<\n+  DateType extends Date,\n+  ContextDate extends Date,\n+>(\n   date: DateType | number | string,\n+  options?: GetISOWeeksInYearOptions<ContextDate> | undefined,\n ): number {\n-  const thisYear = startOfISOWeekYear(date);\n+  const thisYear = startOfISOWeekYear(date, options);\n   const nextYear = startOfISOWeekYear(addWeeks(thisYear, 60));\n   const diff = +nextYear - +thisYear;\n \ndiff --git a/src/getMilliseconds/index.ts b/src/getMilliseconds/index.ts\nindex c680c2d7be..98d3034601 100644\n--- a/src/getMilliseconds/index.ts\n+++ b/src/getMilliseconds/index.ts\n@@ -22,7 +22,5 @@ import { toDate } from \"../toDate/index.js\";\n export function getMilliseconds<DateType extends Date>(\n   date: DateType | number | string,\n ): number {\n-  const _date = toDate(date);\n-  const milliseconds = _date.getMilliseconds();\n-  return milliseconds;\n+  return toDate(date).getMilliseconds();\n }\ndiff --git a/src/getMinutes/index.ts b/src/getMinutes/index.ts\nindex aeb1d4a048..7b8ed6847c 100644\n--- a/src/getMinutes/index.ts\n+++ b/src/getMinutes/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getMinutes} function options.\n+ */\n+export interface GetMinutesOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getMinutes\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Get the minutes of the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n+ * @param options - The options\n  *\n  * @returns The minutes\n  *\n@@ -19,10 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))\n  * //=> 45\n  */\n-export function getMinutes<DateType extends Date>(\n+export function getMinutes<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetMinutesOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n-  const minutes = _date.getMinutes();\n-  return minutes;\n+  return toDate(date, options?.in).getMinutes();\n }\ndiff --git a/src/getMonth/index.ts b/src/getMonth/index.ts\nindex d70db95e61..403d1c31ac 100644\n--- a/src/getMonth/index.ts\n+++ b/src/getMonth/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getMonth} function options.\n+ */\n+export interface GetMonthOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getMonth\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Get the month of the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n+ * @param options - An object with options\n  *\n  * @returns The month index (0-11)\n  *\n@@ -19,10 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getMonth(new Date(2012, 1, 29))\n  * //=> 1\n  */\n-export function getMonth<DateType extends Date>(\n+export function getMonth<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetMonthOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n-  const month = _date.getMonth();\n-  return month;\n+  return toDate(date, options?.in).getMonth();\n }\ndiff --git a/src/getOverlappingDaysInIntervals/index.ts b/src/getOverlappingDaysInIntervals/index.ts\nindex b0fef9c084..644c9ef1e0 100644\n--- a/src/getOverlappingDaysInIntervals/index.ts\n+++ b/src/getOverlappingDaysInIntervals/index.ts\n@@ -16,10 +16,9 @@ import type { Interval } from \"../types.js\";\n  * Two equal 0-length intervals will result in 0. Two equal 1ms intervals will\n  * result in 1.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n  * @param intervalLeft - The first interval to compare.\n  * @param intervalRight - The second interval to compare.\n+ * @param options - An object with options\n  *\n  * @returns The number of days that overlap in two time intervals\n  *\n@@ -40,9 +39,9 @@ import type { Interval } from \"../types.js\";\n  * //=> 0\n  */\n \n-export function getOverlappingDaysInIntervals<DateType extends Date>(\n-  intervalLeft: Interval<DateType>,\n-  intervalRight: Interval<DateType>,\n+export function getOverlappingDaysInIntervals(\n+  intervalLeft: Interval,\n+  intervalRight: Interval,\n ): number {\n   const [leftStart, leftEnd] = [\n     +toDate(intervalLeft.start),\ndiff --git a/src/getQuarter/index.ts b/src/getQuarter/index.ts\nindex a783dc9c43..8af7efeaf0 100644\n--- a/src/getQuarter/index.ts\n+++ b/src/getQuarter/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getQuarter} function options.\n+ */\n+export interface GetQuarterOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getQuarter\n@@ -9,20 +16,23 @@ import { toDate } from \"../toDate/index.js\";\n  * Get the year quarter of the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n+ * @param options - An object with options\n  *\n  * @returns The quarter\n  *\n  * @example\n  * // Which quarter is 2 July 2014?\n- * const result = getQuarter(new Date(2014, 6, 2))\n+ * const result = getQuarter(new Date(2014, 6, 2));\n  * //=> 3\n  */\n-export function getQuarter<DateType extends Date>(\n+export function getQuarter<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetQuarterOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const quarter = Math.trunc(_date.getMonth() / 3) + 1;\n   return quarter;\n }\ndiff --git a/src/getSeconds/index.ts b/src/getSeconds/index.ts\nindex 9b8199b31d..191469cf4b 100644\n--- a/src/getSeconds/index.ts\n+++ b/src/getSeconds/index.ts\n@@ -22,7 +22,5 @@ import { toDate } from \"../toDate/index.js\";\n export function getSeconds<DateType extends Date>(\n   date: DateType | number | string,\n ): number {\n-  const _date = toDate(date);\n-  const seconds = _date.getSeconds();\n-  return seconds;\n+  return toDate(date).getSeconds();\n }\ndiff --git a/src/getTime/index.ts b/src/getTime/index.ts\nindex fc39fb26bd..ef344e5115 100644\n--- a/src/getTime/index.ts\n+++ b/src/getTime/index.ts\n@@ -22,7 +22,5 @@ import { toDate } from \"../toDate/index.js\";\n export function getTime<DateType extends Date>(\n   date: DateType | number | string,\n ): number {\n-  const _date = toDate(date);\n-  const timestamp = _date.getTime();\n-  return timestamp;\n+  return +toDate(date);\n }\ndiff --git a/src/getWeek/index.ts b/src/getWeek/index.ts\nindex 1dcbb5f639..9931349d4c 100644\n--- a/src/getWeek/index.ts\n+++ b/src/getWeek/index.ts\n@@ -3,6 +3,7 @@ import { startOfWeek } from \"../startOfWeek/index.js\";\n import { startOfWeekYear } from \"../startOfWeekYear/index.js\";\n import { toDate } from \"../toDate/index.js\";\n import type {\n+  DateFns,\n   FirstWeekContainsDateOptions,\n   LocalizedOptions,\n   WeekOptions,\n@@ -11,10 +12,11 @@ import type {\n /**\n  * The {@link getWeek} function options.\n  */\n-export interface GetWeekOptions\n+export interface GetWeekOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\">,\n     WeekOptions,\n-    FirstWeekContainsDateOptions {}\n+    FirstWeekContainsDateOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getWeek\n@@ -52,12 +54,11 @@ export interface GetWeekOptions\n  * })\n  * //=> 53\n  */\n-\n-export function getWeek<DateType extends Date>(\n+export function getWeek<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n-  options?: GetWeekOptions,\n+  options?: GetWeekOptions<ContextDate> | undefined,\n ): number {\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);\n \n   // Round the number of weeks to the nearest integer because the number of\ndiff --git a/src/getWeekOfMonth/index.ts b/src/getWeekOfMonth/index.ts\nindex b274bbcbe3..5638e40489 100644\n--- a/src/getWeekOfMonth/index.ts\n+++ b/src/getWeekOfMonth/index.ts\n@@ -1,15 +1,17 @@\n+import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n import { getDate } from \"../getDate/index.js\";\n import { getDay } from \"../getDay/index.js\";\n import { startOfMonth } from \"../startOfMonth/index.js\";\n-import type { LocalizedOptions, WeekOptions } from \"../types.js\";\n-import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n+import { toDate } from \"../toDate/index.js\";\n+import type { DateFns, LocalizedOptions, WeekOptions } from \"../types.js\";\n \n /**\n  * The {@link getWeekOfMonth} function options.\n  */\n-export interface GetWeekOfMonthOptions\n+export interface GetWeekOfMonthOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\">,\n-    WeekOptions {}\n+    WeekOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getWeekOfMonth\n@@ -20,6 +22,7 @@ export interface GetWeekOfMonthOptions\n  * Get the week of the month of the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n  * @param options - An object with options.\n@@ -31,9 +34,9 @@ export interface GetWeekOfMonthOptions\n  * const result = getWeekOfMonth(new Date(2017, 10, 9))\n  * //=> 2\n  */\n-export function getWeekOfMonth<DateType extends Date>(\n+export function getWeekOfMonth<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n-  options?: GetWeekOfMonthOptions,\n+  options?: GetWeekOfMonthOptions<ContextDate>,\n ): number {\n   const defaultOptions = getDefaultOptions();\n   const weekStartsOn =\n@@ -43,10 +46,10 @@ export function getWeekOfMonth<DateType extends Date>(\n     defaultOptions.locale?.options?.weekStartsOn ??\n     0;\n \n-  const currentDayOfMonth = getDate(date);\n+  const currentDayOfMonth = getDate(toDate(date, options?.in));\n   if (isNaN(currentDayOfMonth)) return NaN;\n \n-  const startWeekDay = getDay(startOfMonth(date));\n+  const startWeekDay = getDay(startOfMonth(date, options));\n \n   let lastDayOfFirstWeek = weekStartsOn - startWeekDay;\n   if (lastDayOfFirstWeek <= 0) lastDayOfFirstWeek += 7;\ndiff --git a/src/getWeekYear/index.ts b/src/getWeekYear/index.ts\nindex c9459775d1..99fc00a662 100644\n--- a/src/getWeekYear/index.ts\n+++ b/src/getWeekYear/index.ts\n@@ -1,20 +1,22 @@\n+import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n import { startOfWeek } from \"../startOfWeek/index.js\";\n import { toDate } from \"../toDate/index.js\";\n import type {\n+  DateFns,\n   FirstWeekContainsDateOptions,\n   LocalizedOptions,\n   WeekOptions,\n } from \"../types.js\";\n-import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n \n /**\n  * The {@link getWeekYear} function options.\n  */\n-export interface GetWeekYearOptions\n+export interface GetWeekYearOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\">,\n     WeekOptions,\n-    FirstWeekContainsDateOptions {}\n+    FirstWeekContainsDateOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getWeekYear\n@@ -52,11 +54,11 @@ export interface GetWeekYearOptions\n  * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })\n  * //=> 2004\n  */\n-export function getWeekYear<DateType extends Date>(\n+export function getWeekYear<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n-  options?: GetWeekYearOptions,\n+  options?: GetWeekYearOptions<ContextDate>,\n ): number {\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const year = _date.getFullYear();\n \n   const defaultOptions = getDefaultOptions();\n@@ -67,19 +69,19 @@ export function getWeekYear<DateType extends Date>(\n     defaultOptions.locale?.options?.firstWeekContainsDate ??\n     1;\n \n-  const firstWeekOfNextYear = constructFrom(date, 0);\n+  const firstWeekOfNextYear = constructFrom(options?.in || date, 0);\n   firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);\n   firstWeekOfNextYear.setHours(0, 0, 0, 0);\n   const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);\n \n-  const firstWeekOfThisYear = constructFrom(date, 0);\n+  const firstWeekOfThisYear = constructFrom(options?.in || date, 0);\n   firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);\n   firstWeekOfThisYear.setHours(0, 0, 0, 0);\n   const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);\n \n-  if (_date.getTime() >= startOfNextYear.getTime()) {\n+  if (+_date >= +startOfNextYear) {\n     return year + 1;\n-  } else if (_date.getTime() >= startOfThisYear.getTime()) {\n+  } else if (+_date >= +startOfThisYear) {\n     return year;\n   } else {\n     return year - 1;\ndiff --git a/src/getWeeksInMonth/index.ts b/src/getWeeksInMonth/index.ts\nindex fe0c4df797..3cfbd2ef4b 100644\n--- a/src/getWeeksInMonth/index.ts\n+++ b/src/getWeeksInMonth/index.ts\n@@ -1,14 +1,16 @@\n import { differenceInCalendarWeeks } from \"../differenceInCalendarWeeks/index.js\";\n import { lastDayOfMonth } from \"../lastDayOfMonth/index.js\";\n import { startOfMonth } from \"../startOfMonth/index.js\";\n-import type { LocalizedOptions, WeekOptions } from \"../types.js\";\n+import { toDate } from \"../toDate/index.js\";\n+import type { LocalizedOptions, WeekOptions, DateFns } from \"../types.js\";\n \n /**\n  * The {@link getWeeksInMonth} function options.\n  */\n-export interface GetWeeksInMonthOptions\n+export interface GetWeeksInMonthOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\">,\n-    WeekOptions {}\n+    WeekOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getWeeksInMonth\n@@ -36,14 +38,18 @@ export interface GetWeeksInMonthOptions\n  * const result = getWeeksInMonth(new Date(2017, 6, 5), { weekStartsOn: 1 })\n  * //=> 6\n  */\n-export function getWeeksInMonth<DateType extends Date>(\n+export function getWeeksInMonth<\n+  DateType extends Date,\n+  ContextDate extends Date,\n+>(\n   date: DateType | number | string,\n-  options?: GetWeeksInMonthOptions,\n+  options?: GetWeeksInMonthOptions<ContextDate> | undefined,\n ): number {\n+  const contextDate = toDate(date, options?.in);\n   return (\n     differenceInCalendarWeeks(\n-      lastDayOfMonth(date),\n-      startOfMonth(date),\n+      lastDayOfMonth(contextDate, options),\n+      startOfMonth(contextDate, options),\n       options,\n     ) + 1\n   );\ndiff --git a/src/getYear/index.ts b/src/getYear/index.ts\nindex d3cca2386f..85186b4f38 100644\n--- a/src/getYear/index.ts\n+++ b/src/getYear/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link getYear} function options.\n+ */\n+export interface GetYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name getYear\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Get the year of the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The given date\n+ * @param options - An object with options\n  *\n  * @returns The year\n  *\n@@ -19,8 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = getYear(new Date(2014, 6, 2))\n  * //=> 2014\n  */\n-export function getYear<DateType extends Date>(\n+export function getYear<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: GetYearOptions<ContextDate> | undefined,\n ): number {\n-  return toDate(date).getFullYear();\n+  return toDate(date, options?.in).getFullYear();\n }\ndiff --git a/src/interval/index.ts b/src/interval/index.ts\nindex b1d764d681..a34642cbd4 100644\n--- a/src/interval/index.ts\n+++ b/src/interval/index.ts\n@@ -1,14 +1,35 @@\n-import { toDate } from \"../toDate/index.js\";\n-import type { NormalizedInterval } from \"../types.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n+import type { DateFns, NormalizedInterval } from \"../types.js\";\n \n /**\n  * The {@link interval} function options.\n  */\n-export interface IntervalOptions {\n+export interface IntervalOptions<ContextDate extends Date = Date>\n+  extends DateFns.ContextOptions<ContextDate> {\n   /** Asserts that the interval is positive (start is after the end). */\n   assertPositive?: boolean;\n }\n \n+/**\n+ * The {@link interval} function result type. It resolves the proper data type.\n+ * It uses the first argument date object type, starting from the start argument,\n+ * then the end interval date. If a context function is passed, it uses the context\n+ * function return type.\n+ */\n+export type IntervalResult<\n+  StartDate extends DateFns.Arg,\n+  EndDate extends DateFns.Arg,\n+  Options extends IntervalOptions | undefined = undefined,\n+> = NormalizedInterval<\n+  Options extends IntervalOptions<infer DateType extends Date>\n+    ? DateType\n+    : StartDate extends Date\n+      ? StartDate\n+      : EndDate extends Date\n+        ? EndDate\n+        : Date\n+>;\n+\n /**\n  * @name interval\n  * @category Interval Helpers\n@@ -17,7 +38,9 @@ export interface IntervalOptions {\n  * @description\n  * Creates a normalized interval object and validates its values. If the interval is invalid, an exception is thrown.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam StartDate - Start date type.\n+ * @typeParam EndDate - End date type.\n+ * @typeParam Options - Options type.\n  *\n  * @param start - The start of the interval.\n  * @param end - The end of the interval.\n@@ -29,19 +52,26 @@ export interface IntervalOptions {\n  *\n  * @returns The normalized and validated interval object.\n  */\n-export function interval<DateType extends Date>(\n-  start: DateType | number | string,\n-  end: DateType | number | string,\n-  options?: IntervalOptions,\n-): NormalizedInterval<DateType> {\n-  const _start = toDate(start);\n-  if (isNaN(+_start)) throw new TypeError(\"Start date is invalid\");\n+export function interval<\n+  StartDate extends DateFns.Arg,\n+  EndDate extends DateFns.Arg,\n+  Options extends IntervalOptions | undefined = undefined,\n+>(\n+  start: StartDate,\n+  end: EndDate,\n+  options?: Options,\n+): IntervalResult<StartDate, EndDate, Options> {\n+  const [_start, _end] = normalizeDates(options?.in, start, end);\n \n-  const _end = toDate(end);\n+  if (isNaN(+_start)) throw new TypeError(\"Start date is invalid\");\n   if (isNaN(+_end)) throw new TypeError(\"End date is invalid\");\n \n   if (options?.assertPositive && +_start > +_end)\n     throw new TypeError(\"End date must be after start date\");\n \n-  return { start: _start, end: _end };\n+  return { start: _start, end: _end } as IntervalResult<\n+    StartDate,\n+    EndDate,\n+    Options\n+  >;\n }\ndiff --git a/src/intervalToDuration/index.ts b/src/intervalToDuration/index.ts\nindex 093843945e..bc40a06410 100644\n--- a/src/intervalToDuration/index.ts\n+++ b/src/intervalToDuration/index.ts\n@@ -1,3 +1,4 @@\n+import { normalizeInterval } from \"../_lib/normalizeInterval/index.js\";\n import { add } from \"../add/index.js\";\n import { differenceInDays } from \"../differenceInDays/index.js\";\n import { differenceInHours } from \"../differenceInHours/index.js\";\n@@ -5,8 +6,13 @@ import { differenceInMinutes } from \"../differenceInMinutes/index.js\";\n import { differenceInMonths } from \"../differenceInMonths/index.js\";\n import { differenceInSeconds } from \"../differenceInSeconds/index.js\";\n import { differenceInYears } from \"../differenceInYears/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n-import type { Duration, Interval } from \"../types.js\";\n+import type { DateFns, Duration, Interval } from \"../types.js\";\n+\n+/**\n+ * The {@link intervalToDuration} function options.\n+ */\n+export interface IntervalToDurationOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name intervalToDuration\n@@ -14,11 +20,10 @@ import type { Duration, Interval } from \"../types.js\";\n  * @summary Convert interval to duration\n  *\n  * @description\n- * Convert a interval object to a duration object.\n- *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * Convert an interval object to a duration object.\n  *\n  * @param interval - The interval to convert to duration\n+ * @param options - The context options\n  *\n  * @returns The duration object\n  *\n@@ -27,42 +32,36 @@ import type { Duration, Interval } from \"../types.js\";\n  * intervalToDuration({\n  *   start: new Date(1929, 0, 15, 12, 0, 0),\n  *   end: new Date(1968, 3, 4, 19, 5, 0)\n- * })\n- * // => { years: 39, months: 2, days: 20, hours: 7, minutes: 5, seconds: 0 }\n+ * });\n+ * //=> { years: 39, months: 2, days: 20, hours: 7, minutes: 5, seconds: 0 }\n  */\n-export function intervalToDuration<DateType extends Date>(\n-  interval: Interval<DateType>,\n+export function intervalToDuration(\n+  interval: Interval,\n+  options?: IntervalToDurationOptions | undefined,\n ): Duration {\n-  const start = toDate(interval.start);\n-  const end = toDate(interval.end);\n-\n+  const { start, end } = normalizeInterval(options?.in, interval);\n   const duration: Duration = {};\n \n   const years = differenceInYears(end, start);\n   if (years) duration.years = years;\n \n   const remainingMonths = add(start, { years: duration.years });\n-\n   const months = differenceInMonths(end, remainingMonths);\n   if (months) duration.months = months;\n \n   const remainingDays = add(remainingMonths, { months: duration.months });\n-\n   const days = differenceInDays(end, remainingDays);\n   if (days) duration.days = days;\n \n   const remainingHours = add(remainingDays, { days: duration.days });\n-\n   const hours = differenceInHours(end, remainingHours);\n   if (hours) duration.hours = hours;\n \n   const remainingMinutes = add(remainingHours, { hours: duration.hours });\n-\n   const minutes = differenceInMinutes(end, remainingMinutes);\n   if (minutes) duration.minutes = minutes;\n \n   const remainingSeconds = add(remainingMinutes, { minutes: duration.minutes });\n-\n   const seconds = differenceInSeconds(end, remainingSeconds);\n   if (seconds) duration.seconds = seconds;\n \ndiff --git a/src/intlFormatDistance/index.ts b/src/intlFormatDistance/index.ts\nindex 005a735e0c..a1539697bb 100644\n--- a/src/intlFormatDistance/index.ts\n+++ b/src/intlFormatDistance/index.ts\n@@ -1,3 +1,4 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import {\n   secondsInDay,\n   secondsInHour,\n@@ -15,14 +16,14 @@ import { differenceInCalendarYears } from \"../differenceInCalendarYears/index.js\n import { differenceInHours } from \"../differenceInHours/index.js\";\n import { differenceInMinutes } from \"../differenceInMinutes/index.js\";\n import { differenceInSeconds } from \"../differenceInSeconds/index.js\";\n-import { toDate } from \"../toDate/index.js\";\n import type { DateFns } from \"../types.js\";\n \n /**\n  * The {@link intlFormatDistance} function options.\n  */\n export interface IntlFormatDistanceOptions\n-  extends Intl.RelativeTimeFormatOptions {\n+  extends Intl.RelativeTimeFormatOptions,\n+    DateFns.ContextOptions<Date> {\n   /** Force the distance unit */\n   unit?: IntlFormatDistanceUnit;\n   /** The locales to use (see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument) */\n@@ -76,8 +77,8 @@ export type IntlFormatDistanceUnit =\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n  *\n- * @param date - The date\n- * @param baseDate - The date to compare with.\n+ * @param laterDate - The date\n+ * @param earlierDate - The date to compare with.\n  * @param options - An object with options.\n  * See MDN for details [Locale identification and negotiation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locale_identification_and_negotiation)\n  * The narrow one could be similar to the short one for some locales.\n@@ -143,76 +144,80 @@ export type IntlFormatDistanceUnit =\n  * )\n  * //=> 'in 2 yr'\n  */\n-export function intlFormatDistance<DateType extends Date>(\n-  date: DateType | number | string,\n-  baseDate: DateType | number | string,\n+export function intlFormatDistance(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n   options?: IntlFormatDistanceOptions,\n ): string {\n   let value: number = 0;\n   let unit: Intl.RelativeTimeFormatUnit;\n-  const dateLeft = toDate(date);\n-  const dateRight = toDate(baseDate);\n+\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n \n   if (!options?.unit) {\n     // Get the unit based on diffInSeconds calculations if no unit is specified\n-    const diffInSeconds = differenceInSeconds(dateLeft, dateRight); // The smallest unit\n+    const diffInSeconds = differenceInSeconds(laterDate_, earlierDate_); // The smallest unit\n \n     if (Math.abs(diffInSeconds) < secondsInMinute) {\n-      value = differenceInSeconds(dateLeft, dateRight);\n+      value = differenceInSeconds(laterDate_, earlierDate_);\n       unit = \"second\";\n     } else if (Math.abs(diffInSeconds) < secondsInHour) {\n-      value = differenceInMinutes(dateLeft, dateRight);\n+      value = differenceInMinutes(laterDate_, earlierDate_);\n       unit = \"minute\";\n     } else if (\n       Math.abs(diffInSeconds) < secondsInDay &&\n-      Math.abs(differenceInCalendarDays(dateLeft, dateRight)) < 1\n+      Math.abs(differenceInCalendarDays(laterDate_, earlierDate_)) < 1\n     ) {\n-      value = differenceInHours(dateLeft, dateRight);\n+      value = differenceInHours(laterDate_, earlierDate_);\n       unit = \"hour\";\n     } else if (\n       Math.abs(diffInSeconds) < secondsInWeek &&\n-      (value = differenceInCalendarDays(dateLeft, dateRight)) &&\n+      (value = differenceInCalendarDays(laterDate_, earlierDate_)) &&\n       Math.abs(value) < 7\n     ) {\n       unit = \"day\";\n     } else if (Math.abs(diffInSeconds) < secondsInMonth) {\n-      value = differenceInCalendarWeeks(dateLeft, dateRight);\n+      value = differenceInCalendarWeeks(laterDate_, earlierDate_);\n       unit = \"week\";\n     } else if (Math.abs(diffInSeconds) < secondsInQuarter) {\n-      value = differenceInCalendarMonths(dateLeft, dateRight);\n+      value = differenceInCalendarMonths(laterDate_, earlierDate_);\n       unit = \"month\";\n     } else if (Math.abs(diffInSeconds) < secondsInYear) {\n-      if (differenceInCalendarQuarters(dateLeft, dateRight) < 4) {\n+      if (differenceInCalendarQuarters(laterDate_, earlierDate_) < 4) {\n         // To filter out cases that are less than a year but match 4 quarters\n-        value = differenceInCalendarQuarters(dateLeft, dateRight);\n+        value = differenceInCalendarQuarters(laterDate_, earlierDate_);\n         unit = \"quarter\";\n       } else {\n-        value = differenceInCalendarYears(dateLeft, dateRight);\n+        value = differenceInCalendarYears(laterDate_, earlierDate_);\n         unit = \"year\";\n       }\n     } else {\n-      value = differenceInCalendarYears(dateLeft, dateRight);\n+      value = differenceInCalendarYears(laterDate_, earlierDate_);\n       unit = \"year\";\n     }\n   } else {\n     // Get the value if unit is specified\n     unit = options?.unit;\n     if (unit === \"second\") {\n-      value = differenceInSeconds(dateLeft, dateRight);\n+      value = differenceInSeconds(laterDate_, earlierDate_);\n     } else if (unit === \"minute\") {\n-      value = differenceInMinutes(dateLeft, dateRight);\n+      value = differenceInMinutes(laterDate_, earlierDate_);\n     } else if (unit === \"hour\") {\n-      value = differenceInHours(dateLeft, dateRight);\n+      value = differenceInHours(laterDate_, earlierDate_);\n     } else if (unit === \"day\") {\n-      value = differenceInCalendarDays(dateLeft, dateRight);\n+      value = differenceInCalendarDays(laterDate_, earlierDate_);\n     } else if (unit === \"week\") {\n-      value = differenceInCalendarWeeks(dateLeft, dateRight);\n+      value = differenceInCalendarWeeks(laterDate_, earlierDate_);\n     } else if (unit === \"month\") {\n-      value = differenceInCalendarMonths(dateLeft, dateRight);\n+      value = differenceInCalendarMonths(laterDate_, earlierDate_);\n     } else if (unit === \"quarter\") {\n-      value = differenceInCalendarQuarters(dateLeft, dateRight);\n+      value = differenceInCalendarQuarters(laterDate_, earlierDate_);\n     } else if (unit === \"year\") {\n-      value = differenceInCalendarYears(dateLeft, dateRight);\n+      value = differenceInCalendarYears(laterDate_, earlierDate_);\n     }\n   }\n \ndiff --git a/src/isAfter/index.ts b/src/isAfter/index.ts\nindex eb79d8b6d3..d17add0b9d 100644\n--- a/src/isAfter/index.ts\n+++ b/src/isAfter/index.ts\n@@ -24,7 +24,5 @@ export function isAfter<DateType extends Date>(\n   date: DateType | number | string,\n   dateToCompare: DateType | number | string,\n ): boolean {\n-  const _date = toDate(date);\n-  const _dateToCompare = toDate(dateToCompare);\n-  return _date.getTime() > _dateToCompare.getTime();\n+  return +toDate(date) > +toDate(dateToCompare);\n }\ndiff --git a/src/isBefore/index.ts b/src/isBefore/index.ts\nindex b670c870e2..2aac0239a2 100644\n--- a/src/isBefore/index.ts\n+++ b/src/isBefore/index.ts\n@@ -24,7 +24,5 @@ export function isBefore<DateType extends Date>(\n   date: DateType | number | string,\n   dateToCompare: DateType | number | string,\n ): boolean {\n-  const _date = toDate(date);\n-  const _dateToCompare = toDate(dateToCompare);\n-  return +_date < +_dateToCompare;\n+  return +toDate(date) < +toDate(dateToCompare);\n }\ndiff --git a/src/isEqual/index.ts b/src/isEqual/index.ts\nindex 11d0a1dd02..89ca588723 100644\n--- a/src/isEqual/index.ts\n+++ b/src/isEqual/index.ts\n@@ -27,7 +27,5 @@ export function isEqual<DateType extends Date>(\n   leftDate: DateType | number | string,\n   rightDate: DateType | number | string,\n ): boolean {\n-  const _dateLeft = toDate(leftDate);\n-  const _dateRight = toDate(rightDate);\n-  return +_dateLeft === +_dateRight;\n+  return +toDate(leftDate) === +toDate(rightDate);\n }\ndiff --git a/src/isFirstDayOfMonth/index.ts b/src/isFirstDayOfMonth/index.ts\nindex 50fcaa5123..ccfc6f1c34 100644\n--- a/src/isFirstDayOfMonth/index.ts\n+++ b/src/isFirstDayOfMonth/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isFirstDayOfMonth} function options.\n+ */\n+export interface IsFirstDayOfMonthOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isFirstDayOfMonth\n@@ -8,10 +15,12 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Is the given date the first day of a month?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n-\n+ * @param options - An object with options\n+ *\n  * @returns The date is the first day of a month\n  *\n  * @example\n@@ -19,8 +28,12 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isFirstDayOfMonth(new Date(2014, 8, 1))\n  * //=> true\n  */\n-export function isFirstDayOfMonth<DateType extends Date>(\n+export function isFirstDayOfMonth<\n+  DateType extends Date,\n+  ContextDate extends Date,\n+>(\n   date: DateType | number | string,\n+  options?: IsFirstDayOfMonthOptions<ContextDate> | undefined,\n ): boolean {\n-  return toDate(date).getDate() === 1;\n+  return toDate(date, options?.in).getDate() === 1;\n }\ndiff --git a/src/isFriday/index.ts b/src/isFriday/index.ts\nindex 2c02e6b6b5..4c8b857678 100644\n--- a/src/isFriday/index.ts\n+++ b/src/isFriday/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isFriday} function options.\n+ */\n+export interface IsFridayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isFriday\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Is the given date Friday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is Friday\n  *\n@@ -19,8 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isFriday(new Date(2014, 8, 26))\n  * //=> true\n  */\n-export function isFriday<DateType extends Date>(\n+export function isFriday<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsFridayOptions<ContextDate> | undefined,\n ): boolean {\n-  return toDate(date).getDay() === 5;\n+  return toDate(date, options?.in).getDay() === 5;\n }\ndiff --git a/src/isLastDayOfMonth/index.ts b/src/isLastDayOfMonth/index.ts\nindex 96b37535b9..3b57e1d804 100644\n--- a/src/isLastDayOfMonth/index.ts\n+++ b/src/isLastDayOfMonth/index.ts\n@@ -1,6 +1,10 @@\n import { endOfDay } from \"../endOfDay/index.js\";\n import { endOfMonth } from \"../endOfMonth/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+export interface IsLastDayOfMonthOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isLastDayOfMonth\n@@ -11,9 +15,11 @@ import { toDate } from \"../toDate/index.js\";\n  * Is the given date the last day of a month?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n-\n+ * @param options - An object with options\n+ *\n  * @returns The date is the last day of a month\n  *\n  * @example\n@@ -21,9 +27,13 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isLastDayOfMonth(new Date(2014, 1, 28))\n  * //=> true\n  */\n-export function isLastDayOfMonth<DateType extends Date>(\n+export function isLastDayOfMonth<\n+  DateType extends Date,\n+  ContextDate extends Date,\n+>(\n   date: DateType | number | string,\n+  options?: IsLastDayOfMonthOptions<ContextDate> | undefined,\n ): boolean {\n-  const _date = toDate(date);\n-  return +endOfDay(_date) === +endOfMonth(_date);\n+  const _date = toDate(date, options?.in);\n+  return +endOfDay(_date, options) === +endOfMonth(_date, options);\n }\ndiff --git a/src/isLeapYear/index.ts b/src/isLeapYear/index.ts\nindex c4d3b3e77c..c8d59f2d90 100644\n--- a/src/isLeapYear/index.ts\n+++ b/src/isLeapYear/index.ts\n@@ -1,4 +1,8 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+export interface IsLeapYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isLeapYear\n@@ -9,8 +13,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Is the given date in the leap year?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - The options object\n  *\n  * @returns The date is in the leap year\n  *\n@@ -19,10 +25,11 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isLeapYear(new Date(2012, 8, 1))\n  * //=> true\n  */\n-export function isLeapYear<DateType extends Date>(\n+export function isLeapYear<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsLeapYearOptions<ContextDate> | undefined,\n ): boolean {\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const year = _date.getFullYear();\n   return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);\n }\ndiff --git a/src/isMonday/index.ts b/src/isMonday/index.ts\nindex 69f5df236f..2a634f25aa 100644\n--- a/src/isMonday/index.ts\n+++ b/src/isMonday/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isMonday} function options.\n+ */\n+export interface IsMondayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isMonday\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Is the given date Monday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is Monday\n  *\n@@ -19,8 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isMonday(new Date(2014, 8, 22))\n  * //=> true\n  */\n-export function isMonday<DateType extends Date>(\n+export function isMonday<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsMondayOptions<ContextDate> | undefined,\n ): boolean {\n-  return toDate(date).getDay() === 1;\n+  return toDate(date, options?.in).getDay() === 1;\n }\ndiff --git a/src/isSameDay/index.ts b/src/isSameDay/index.ts\nindex a03b4bb697..9dd37216d8 100644\n--- a/src/isSameDay/index.ts\n+++ b/src/isSameDay/index.ts\n@@ -1,4 +1,11 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { startOfDay } from \"../startOfDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isSameDay} function options.\n+ */\n+export interface IsSameDayOptions extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name isSameDay\n@@ -8,11 +15,10 @@ import { startOfDay } from \"../startOfDay/index.js\";\n  * @description\n  * Are the given dates in the same day (and year and month)?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @param laterDate - The first date to check\n+ * @param earlierDate - The second date to check\n+ * @param options - An object with options\n  *\n- * @param dateLeft - The first date to check\n- * @param dateRight - The second date to check\n-\n  * @returns The dates are in the same day (and year and month)\n  *\n  * @example\n@@ -30,12 +36,15 @@ import { startOfDay } from \"../startOfDay/index.js\";\n  * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))\n  * //=> false\n  */\n-export function isSameDay<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function isSameDay(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: IsSameDayOptions | undefined,\n ): boolean {\n-  const dateLeftStartOfDay = startOfDay(dateLeft);\n-  const dateRightStartOfDay = startOfDay(dateRight);\n-\n-  return +dateLeftStartOfDay === +dateRightStartOfDay;\n+  const [dateLeft_, dateRight_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+  return +startOfDay(dateLeft_) === +startOfDay(dateRight_);\n }\ndiff --git a/src/isSameHour/index.ts b/src/isSameHour/index.ts\nindex 5476a09caf..2d98656ac2 100644\n--- a/src/isSameHour/index.ts\n+++ b/src/isSameHour/index.ts\n@@ -1,4 +1,11 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { startOfHour } from \"../startOfHour/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isSameHour} function options.\n+ */\n+export interface IsSameHourOptions extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name isSameHour\n@@ -8,10 +15,9 @@ import { startOfHour } from \"../startOfHour/index.js\";\n  * @description\n  * Are the given dates in the same hour (and same day)?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n  * @param dateLeft - The first date to check\n  * @param dateRight - The second date to check\n+ * @param options - An object with options\n  *\n  * @returns The dates are in the same hour (and same day)\n  *\n@@ -25,12 +31,15 @@ import { startOfHour } from \"../startOfHour/index.js\";\n  * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 5, 6, 0))\n  * //=> false\n  */\n-export function isSameHour<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function isSameHour(\n+  dateLeft: DateFns.Arg,\n+  dateRight: DateFns.Arg,\n+  options?: IsSameHourOptions | undefined,\n ): boolean {\n-  const dateLeftStartOfHour = startOfHour(dateLeft);\n-  const dateRightStartOfHour = startOfHour(dateRight);\n-\n-  return +dateLeftStartOfHour === +dateRightStartOfHour;\n+  const [dateLeft_, dateRight_] = normalizeDates(\n+    options?.in,\n+    dateLeft,\n+    dateRight,\n+  );\n+  return +startOfHour(dateLeft_) === +startOfHour(dateRight_);\n }\ndiff --git a/src/isSameISOWeek/index.ts b/src/isSameISOWeek/index.ts\nindex 3e04f6b390..5070256985 100644\n--- a/src/isSameISOWeek/index.ts\n+++ b/src/isSameISOWeek/index.ts\n@@ -1,4 +1,10 @@\n import { isSameWeek } from \"../isSameWeek/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isSameISOWeek} function options.\n+ */\n+export interface IsSameISOWeekOptions extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name isSameISOWeek\n@@ -10,10 +16,9 @@ import { isSameWeek } from \"../isSameWeek/index.js\";\n  *\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The first date to check\n- * @param dateRight - The second date to check\n+ * @param laterDate - The first date to check\n+ * @param earlierDate - The second date to check\n+ * @param options - An object with options\n  *\n  * @returns The dates are in the same ISO week (and year)\n  *\n@@ -27,9 +32,10 @@ import { isSameWeek } from \"../isSameWeek/index.js\";\n  * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2015, 8, 1))\n  * //=> false\n  */\n-export function isSameISOWeek<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function isSameISOWeek(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: IsSameISOWeekOptions | undefined,\n ): boolean {\n-  return isSameWeek(dateLeft, dateRight, { weekStartsOn: 1 });\n+  return isSameWeek(laterDate, earlierDate, { ...options, weekStartsOn: 1 });\n }\ndiff --git a/src/isSameISOWeekYear/index.ts b/src/isSameISOWeekYear/index.ts\nindex 13b4d72f55..41191dd9cf 100644\n--- a/src/isSameISOWeekYear/index.ts\n+++ b/src/isSameISOWeekYear/index.ts\n@@ -1,4 +1,12 @@\n import { startOfISOWeekYear } from \"../startOfISOWeekYear/index.js\";\n+import { type DateFns } from \"../types.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n+\n+/**\n+ * The {@link isSameISOWeekYear} function options.\n+ */\n+export interface IsSameISOWeekYearOptions\n+  extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name isSameISOWeekYear\n@@ -10,10 +18,9 @@ import { startOfISOWeekYear } from \"../startOfISOWeekYear/index.js\";\n  *\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The first date to check\n- * @param dateRight - The second date to check\n+ * @param laterDate - The first date to check\n+ * @param earlierDate - The second date to check\n+ * @param options - An object with options\n  *\n  * @returns The dates are in the same ISO week-numbering year\n  *\n@@ -22,12 +29,15 @@ import { startOfISOWeekYear } from \"../startOfISOWeekYear/index.js\";\n  * const result = isSameISOWeekYear(new Date(2003, 11, 29), new Date(2005, 0, 2))\n  * //=> true\n  */\n-export function isSameISOWeekYear<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function isSameISOWeekYear(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: IsSameISOWeekYearOptions | undefined,\n ): boolean {\n-  const dateLeftStartOfYear = startOfISOWeekYear(dateLeft);\n-  const dateRightStartOfYear = startOfISOWeekYear(dateRight);\n-\n-  return +dateLeftStartOfYear === +dateRightStartOfYear;\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+  return +startOfISOWeekYear(laterDate_) === +startOfISOWeekYear(earlierDate_);\n }\ndiff --git a/src/isSameMinute/index.ts b/src/isSameMinute/index.ts\nindex 310ddc228b..23140d40aa 100644\n--- a/src/isSameMinute/index.ts\n+++ b/src/isSameMinute/index.ts\n@@ -1,4 +1,5 @@\n import { startOfMinute } from \"../startOfMinute/index.js\";\n+import { type DateFns } from \"../types.js\";\n \n /**\n  * @name isSameMinute\n@@ -8,10 +9,8 @@ import { startOfMinute } from \"../startOfMinute/index.js\";\n  * @description\n  * Are the given dates in the same minute (and hour and day)?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The first date to check\n- * @param dateRight - The second date to check\n+ * @param laterDate - The first date to check\n+ * @param earlierDate - The second date to check\n  *\n  * @returns The dates are in the same minute (and hour and day)\n  *\n@@ -31,12 +30,9 @@ import { startOfMinute } from \"../startOfMinute/index.js\";\n  * )\n  * //=> false\n  */\n-export function isSameMinute<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function isSameMinute(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n ): boolean {\n-  const dateLeftStartOfMinute = startOfMinute(dateLeft);\n-  const dateRightStartOfMinute = startOfMinute(dateRight);\n-\n-  return +dateLeftStartOfMinute === +dateRightStartOfMinute;\n+  return +startOfMinute(laterDate) === +startOfMinute(earlierDate);\n }\ndiff --git a/src/isSameMonth/index.ts b/src/isSameMonth/index.ts\nindex 693617f3c7..829015b2dc 100644\n--- a/src/isSameMonth/index.ts\n+++ b/src/isSameMonth/index.ts\n@@ -1,4 +1,10 @@\n-import { toDate } from \"../toDate/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isSameMonth} function options.\n+ */\n+export interface IsSameMonthOptions extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name isSameMonth\n@@ -8,10 +14,9 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Are the given dates in the same month (and year)?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The first date to check\n- * @param dateRight - The second date to check\n+ * @param laterDate - The first date to check\n+ * @param earlierDate - The second date to check\n+ * @param options - An object with options\n  *\n  * @returns The dates are in the same month (and year)\n  *\n@@ -25,14 +30,18 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))\n  * //=> false\n  */\n-export function isSameMonth<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function isSameMonth(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: IsSameMonthOptions | undefined,\n ): boolean {\n-  const _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n   return (\n-    _dateLeft.getFullYear() === _dateRight.getFullYear() &&\n-    _dateLeft.getMonth() === _dateRight.getMonth()\n+    laterDate_.getFullYear() === earlierDate_.getFullYear() &&\n+    laterDate_.getMonth() === earlierDate_.getMonth()\n   );\n }\ndiff --git a/src/isSameQuarter/index.ts b/src/isSameQuarter/index.ts\nindex 4722b6cef1..acbd3526b9 100644\n--- a/src/isSameQuarter/index.ts\n+++ b/src/isSameQuarter/index.ts\n@@ -1,4 +1,11 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { startOfQuarter } from \"../startOfQuarter/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isSameQuarter} function options.\n+ */\n+export interface IsSameQuarterOptions extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name isSameQuarter\n@@ -8,11 +15,10 @@ import { startOfQuarter } from \"../startOfQuarter/index.js\";\n  * @description\n  * Are the given dates in the same quarter (and year)?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @param laterDate - The first date to check\n+ * @param earlierDate - The second date to check\n+ * @param options - An object with options\n  *\n- * @param dateLeft - The first date to check\n- * @param dateRight - The second date to check\n-\n  * @returns The dates are in the same quarter (and year)\n  *\n  * @example\n@@ -25,12 +31,15 @@ import { startOfQuarter } from \"../startOfQuarter/index.js\";\n  * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2015, 0, 1))\n  * //=> false\n  */\n-export function isSameQuarter<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function isSameQuarter(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: IsSameQuarterOptions | undefined,\n ): boolean {\n-  const dateLeftStartOfQuarter = startOfQuarter(dateLeft);\n-  const dateRightStartOfQuarter = startOfQuarter(dateRight);\n-\n-  return +dateLeftStartOfQuarter === +dateRightStartOfQuarter;\n+  const [dateLeft_, dateRight_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+  return +startOfQuarter(dateLeft_) === +startOfQuarter(dateRight_);\n }\ndiff --git a/src/isSameSecond/index.ts b/src/isSameSecond/index.ts\nindex 07b8d0182f..7163b408a9 100644\n--- a/src/isSameSecond/index.ts\n+++ b/src/isSameSecond/index.ts\n@@ -1,4 +1,5 @@\n import { startOfSecond } from \"../startOfSecond/index.js\";\n+import { type DateFns } from \"../types.js\";\n \n /**\n  * @name isSameSecond\n@@ -8,10 +9,8 @@ import { startOfSecond } from \"../startOfSecond/index.js\";\n  * @description\n  * Are the given dates in the same second (and hour and day)?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The first date to check\n- * @param dateRight - The second date to check\n+ * @param laterDate - The first date to check\n+ * @param earlierDate - The second date to check\n  *\n  * @returns The dates are in the same second (and hour and day)\n  *\n@@ -39,12 +38,9 @@ import { startOfSecond } from \"../startOfSecond/index.js\";\n  * )\n  * //=> false\n  */\n-export function isSameSecond<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function isSameSecond(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n ): boolean {\n-  const dateLeftStartOfSecond = startOfSecond(dateLeft);\n-  const dateRightStartOfSecond = startOfSecond(dateRight);\n-\n-  return +dateLeftStartOfSecond === +dateRightStartOfSecond;\n+  return +startOfSecond(laterDate) === +startOfSecond(earlierDate);\n }\ndiff --git a/src/isSameWeek/index.ts b/src/isSameWeek/index.ts\nindex 12d28826e1..9714bf0564 100644\n--- a/src/isSameWeek/index.ts\n+++ b/src/isSameWeek/index.ts\n@@ -1,12 +1,15 @@\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n import { startOfWeek } from \"../startOfWeek/index.js\";\n import type { LocalizedOptions, WeekOptions } from \"../types.js\";\n+import { type DateFns } from \"../types.js\";\n \n /**\n  * The {@link isSameWeek} function options.\n  */\n export interface IsSameWeekOptions\n   extends WeekOptions,\n-    LocalizedOptions<\"options\"> {}\n+    LocalizedOptions<\"options\">,\n+    DateFns.ContextOptions<Date> {}\n \n /**\n  * @name isSameWeek\n@@ -16,10 +19,8 @@ export interface IsSameWeekOptions\n  * @description\n  * Are the given dates in the same week (and month and year)?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The first date to check\n- * @param dateRight - The second date to check\n+ * @param laterDate - The first date to check\n+ * @param earlierDate - The second date to check\n  * @param options - An object with options\n  *\n  * @returns The dates are in the same week (and month and year)\n@@ -42,13 +43,17 @@ export interface IsSameWeekOptions\n  * const result = isSameWeek(new Date(2014, 0, 1), new Date(2015, 0, 1))\n  * //=> false\n  */\n-export function isSameWeek<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function isSameWeek(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n   options?: IsSameWeekOptions,\n ): boolean {\n-  const dateLeftStartOfWeek = startOfWeek(dateLeft, options);\n-  const dateRightStartOfWeek = startOfWeek(dateRight, options);\n-\n-  return +dateLeftStartOfWeek === +dateRightStartOfWeek;\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+  return (\n+    +startOfWeek(laterDate_, options) === +startOfWeek(earlierDate_, options)\n+  );\n }\ndiff --git a/src/isSameYear/index.ts b/src/isSameYear/index.ts\nindex 64ae8b91b7..6950327750 100644\n--- a/src/isSameYear/index.ts\n+++ b/src/isSameYear/index.ts\n@@ -1,4 +1,10 @@\n-import { toDate } from \"../toDate/index.js\";\n+import { normalizeDates } from \"../_lib/normalizeDates/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isSameYear} function options.\n+ */\n+export interface IsSameYearOptions extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name isSameYear\n@@ -8,10 +14,9 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Are the given dates in the same year?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n- * @param dateLeft - The first date to check\n- * @param dateRight - The second date to check\n+ * @param laterDate - The first date to check\n+ * @param earlierDate - The second date to check\n+ * @param options - An object with options\n  *\n  * @returns The dates are in the same year\n  *\n@@ -20,11 +25,15 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))\n  * //=> true\n  */\n-export function isSameYear<DateType extends Date>(\n-  dateLeft: DateType | number | string,\n-  dateRight: DateType | number | string,\n+export function isSameYear(\n+  laterDate: DateFns.Arg,\n+  earlierDate: DateFns.Arg,\n+  options?: IsSameYearOptions | undefined,\n ): boolean {\n-  const _dateLeft = toDate(dateLeft);\n-  const _dateRight = toDate(dateRight);\n-  return _dateLeft.getFullYear() === _dateRight.getFullYear();\n+  const [laterDate_, earlierDate_] = normalizeDates(\n+    options?.in,\n+    laterDate,\n+    earlierDate,\n+  );\n+  return laterDate_.getFullYear() === earlierDate_.getFullYear();\n }\ndiff --git a/src/isSaturday/index.ts b/src/isSaturday/index.ts\nindex fd0e9d8551..684f7417fa 100644\n--- a/src/isSaturday/index.ts\n+++ b/src/isSaturday/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isSaturday} function options.\n+ */\n+export interface IsSaturdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isSaturday\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Is the given date Saturday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is Saturday\n  *\n@@ -19,8 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isSaturday(new Date(2014, 8, 27))\n  * //=> true\n  */\n-export function isSaturday<DateType extends Date>(\n+export function isSaturday<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsSaturdayOptions<ContextDate> | undefined,\n ): boolean {\n-  return toDate(date).getDay() === 6;\n+  return toDate(date, options?.in).getDay() === 6;\n }\ndiff --git a/src/isSunday/index.ts b/src/isSunday/index.ts\nindex a59aaaa760..0a40f429d6 100644\n--- a/src/isSunday/index.ts\n+++ b/src/isSunday/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isSunday} function options.\n+ */\n+export interface IsSundayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isSunday\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Is the given date Sunday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - The options object\n  *\n  * @returns The date is Sunday\n  *\n@@ -19,8 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isSunday(new Date(2014, 8, 21))\n  * //=> true\n  */\n-export function isSunday<DateType extends Date>(\n+export function isSunday<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsSundayOptions<ContextDate> | undefined,\n ): boolean {\n-  return toDate(date).getDay() === 0;\n+  return toDate(date, options?.in).getDay() === 0;\n }\ndiff --git a/src/isThisHour/index.ts b/src/isThisHour/index.ts\nindex 5e5f2dc8be..352eb5b1ab 100644\n--- a/src/isThisHour/index.ts\n+++ b/src/isThisHour/index.ts\n@@ -1,5 +1,13 @@\n import { constructNow } from \"../constructNow/index.js\";\n import { isSameHour } from \"../isSameHour/index.js\";\n+import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isThisHour} function options.\n+ */\n+export interface IsThisHourOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isThisHour\n@@ -11,8 +19,10 @@ import { isSameHour } from \"../isSameHour/index.js\";\n  * Is the given date in the same hour as the current date?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is in this hour\n  *\n@@ -22,8 +32,12 @@ import { isSameHour } from \"../isSameHour/index.js\";\n  * const result = isThisHour(new Date(2014, 8, 25, 18))\n  * //=> true\n  */\n-export function isThisHour<DateType extends Date>(\n+export function isThisHour<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsThisHourOptions<ContextDate>,\n ): boolean {\n-  return isSameHour(date, constructNow(date));\n+  return isSameHour(\n+    toDate(date, options?.in),\n+    constructNow(options?.in || date),\n+  );\n }\ndiff --git a/src/isThisISOWeek/index.ts b/src/isThisISOWeek/index.ts\nindex b555caf703..aa1be21b69 100644\n--- a/src/isThisISOWeek/index.ts\n+++ b/src/isThisISOWeek/index.ts\n@@ -1,5 +1,13 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { constructNow } from \"../constructNow/index.js\";\n import { isSameISOWeek } from \"../isSameISOWeek/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isThisISOWeek} function options.\n+ */\n+export interface IsThisISOWeekOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isThisISOWeek\n@@ -12,9 +20,11 @@ import { isSameISOWeek } from \"../isSameISOWeek/index.js\";\n  *\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is in this ISO week\n  *\n@@ -23,9 +33,12 @@ import { isSameISOWeek } from \"../isSameISOWeek/index.js\";\n  * const result = isThisISOWeek(new Date(2014, 8, 22))\n  * //=> true\n  */\n-\n-export function isThisISOWeek<DateType extends Date>(\n+export function isThisISOWeek<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsThisISOWeekOptions<ContextDate> | undefined,\n ): boolean {\n-  return isSameISOWeek(date, constructNow(date));\n+  return isSameISOWeek(\n+    constructFrom(options?.in || date, date),\n+    constructNow(options?.in || date),\n+  );\n }\ndiff --git a/src/isThisMonth/index.ts b/src/isThisMonth/index.ts\nindex 67cd021b41..5e613dcc84 100644\n--- a/src/isThisMonth/index.ts\n+++ b/src/isThisMonth/index.ts\n@@ -1,5 +1,13 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { constructNow } from \"../constructNow/index.js\";\n import { isSameMonth } from \"../isSameMonth/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isThisMonth} function options.\n+ */\n+export interface IsThisMonthOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isThisMonth\n@@ -11,8 +19,10 @@ import { isSameMonth } from \"../isSameMonth/index.js\";\n  * Is the given date in the same month as the current date?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is in this month\n  *\n@@ -21,9 +31,12 @@ import { isSameMonth } from \"../isSameMonth/index.js\";\n  * const result = isThisMonth(new Date(2014, 8, 15))\n  * //=> true\n  */\n-\n-export function isThisMonth<DateType extends Date>(\n+export function isThisMonth<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsThisMonthOptions<ContextDate> | undefined,\n ): boolean {\n-  return isSameMonth(date, constructNow(date));\n+  return isSameMonth(\n+    constructFrom(options?.in || date, date),\n+    constructNow(options?.in || date),\n+  );\n }\ndiff --git a/src/isThisQuarter/index.ts b/src/isThisQuarter/index.ts\nindex 1e8beb94c2..ddc4080209 100644\n--- a/src/isThisQuarter/index.ts\n+++ b/src/isThisQuarter/index.ts\n@@ -1,5 +1,13 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { constructNow } from \"../constructNow/index.js\";\n import { isSameQuarter } from \"../isSameQuarter/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isThisQuarter} function options.\n+ */\n+export interface IsThisQuarterOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isThisQuarter\n@@ -11,8 +19,10 @@ import { isSameQuarter } from \"../isSameQuarter/index.js\";\n  * Is the given date in the same quarter as the current date?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is in this quarter\n  *\n@@ -21,8 +31,12 @@ import { isSameQuarter } from \"../isSameQuarter/index.js\";\n  * const result = isThisQuarter(new Date(2014, 6, 2))\n  * //=> true\n  */\n-export function isThisQuarter<DateType extends Date>(\n+export function isThisQuarter<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsThisQuarterOptions<ContextDate>,\n ): boolean {\n-  return isSameQuarter(date, constructNow(date));\n+  return isSameQuarter(\n+    constructFrom(options?.in || date, date),\n+    constructNow(options?.in || date),\n+  );\n }\ndiff --git a/src/isThisWeek/index.ts b/src/isThisWeek/index.ts\nindex 52a194348f..4103966055 100644\n--- a/src/isThisWeek/index.ts\n+++ b/src/isThisWeek/index.ts\n@@ -1,13 +1,15 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { constructNow } from \"../constructNow/index.js\";\n import { isSameWeek } from \"../isSameWeek/index.js\";\n-import type { LocalizedOptions, WeekOptions } from \"../types.js\";\n+import type { LocalizedOptions, WeekOptions, DateFns } from \"../types.js\";\n \n /**\n  * The {@link isThisWeek} function options.\n  */\n-export interface IsThisWeekOptions\n+export interface IsThisWeekOptions<DateType extends Date = Date>\n   extends WeekOptions,\n-    LocalizedOptions<\"options\"> {}\n+    LocalizedOptions<\"options\">,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isThisWeek\n@@ -18,7 +20,8 @@ export interface IsThisWeekOptions\n  * @description\n  * Is the given date in the same week as the current date?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n  * @param options - The object with options\n@@ -36,9 +39,13 @@ export interface IsThisWeekOptions\n  * const result = isThisWeek(new Date(2014, 8, 21), { weekStartsOn: 1 })\n  * //=> false\n  */\n-export function isThisWeek<DateType extends Date>(\n+export function isThisWeek<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n-  options?: IsThisWeekOptions,\n+  options?: IsThisWeekOptions<ContextDate>,\n ): boolean {\n-  return isSameWeek(date, constructNow(date), options);\n+  return isSameWeek(\n+    constructFrom(options?.in || date, date),\n+    constructNow(options?.in || date),\n+    options,\n+  );\n }\ndiff --git a/src/isThisYear/index.ts b/src/isThisYear/index.ts\nindex c723a298bf..bc20491e12 100644\n--- a/src/isThisYear/index.ts\n+++ b/src/isThisYear/index.ts\n@@ -1,5 +1,13 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { constructNow } from \"../constructNow/index.js\";\n import { isSameYear } from \"../isSameYear/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isThisYear} function options.\n+ */\n+export interface IsThisYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isThisYear\n@@ -13,6 +21,7 @@ import { isSameYear } from \"../isSameYear/index.js\";\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is in this year\n  *\n@@ -21,8 +30,12 @@ import { isSameYear } from \"../isSameYear/index.js\";\n  * const result = isThisYear(new Date(2014, 6, 2))\n  * //=> true\n  */\n-export function isThisYear<DateType extends Date>(\n+export function isThisYear<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsThisYearOptions<ContextDate> | undefined,\n ): boolean {\n-  return isSameYear(date, constructNow(date));\n+  return isSameYear(\n+    constructFrom(options?.in || date, date),\n+    constructNow(options?.in || date),\n+  );\n }\ndiff --git a/src/isThursday/index.ts b/src/isThursday/index.ts\nindex 6da48b95a0..c277cf9f2f 100644\n--- a/src/isThursday/index.ts\n+++ b/src/isThursday/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isThursday} function options.\n+ */\n+export interface IsThursdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isThursday\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Is the given date Thursday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is Thursday\n  *\n@@ -19,8 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isThursday(new Date(2014, 8, 25))\n  * //=> true\n  */\n-export function isThursday<DateType extends Date>(\n+export function isThursday<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsThursdayOptions<ContextDate> | undefined,\n ): boolean {\n-  return toDate(date).getDay() === 4;\n+  return toDate(date, options?.in).getDay() === 4;\n }\ndiff --git a/src/isToday/index.ts b/src/isToday/index.ts\nindex 57e524b2a9..a97c58ff2c 100644\n--- a/src/isToday/index.ts\n+++ b/src/isToday/index.ts\n@@ -1,5 +1,13 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { constructNow } from \"../constructNow/index.js\";\n import { isSameDay } from \"../isSameDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isToday} function options.\n+ */\n+export interface IsTodayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isToday\n@@ -11,8 +19,10 @@ import { isSameDay } from \"../isSameDay/index.js\";\n  * Is the given date today?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is today\n  *\n@@ -21,8 +31,12 @@ import { isSameDay } from \"../isSameDay/index.js\";\n  * const result = isToday(new Date(2014, 9, 6, 14, 0))\n  * //=> true\n  */\n-export function isToday<DateType extends Date>(\n+export function isToday<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsTodayOptions<ContextDate> | undefined,\n ): boolean {\n-  return isSameDay(date, constructNow(date));\n+  return isSameDay(\n+    constructFrom(options?.in || date, date),\n+    constructNow(options?.in || date),\n+  );\n }\ndiff --git a/src/isTomorrow/index.ts b/src/isTomorrow/index.ts\nindex 91927f524a..a251f40e82 100644\n--- a/src/isTomorrow/index.ts\n+++ b/src/isTomorrow/index.ts\n@@ -1,6 +1,13 @@\n import { addDays } from \"../addDays/index.js\";\n import { constructNow } from \"../constructNow/index.js\";\n import { isSameDay } from \"../isSameDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isTomorrow} function options.\n+ */\n+export interface IsTomorrowOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isTomorrow\n@@ -12,8 +19,10 @@ import { isSameDay } from \"../isSameDay/index.js\";\n  * Is the given date tomorrow?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is tomorrow\n  *\n@@ -22,8 +31,13 @@ import { isSameDay } from \"../isSameDay/index.js\";\n  * const result = isTomorrow(new Date(2014, 9, 7, 14, 0))\n  * //=> true\n  */\n-export function isTomorrow<DateType extends Date>(\n+export function isTomorrow<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsTomorrowOptions<ContextDate> | undefined,\n ): boolean {\n-  return isSameDay(date, addDays(constructNow(date), 1));\n+  return isSameDay(\n+    date,\n+    addDays(constructNow(options?.in || date), 1),\n+    options,\n+  );\n }\ndiff --git a/src/isTuesday/index.ts b/src/isTuesday/index.ts\nindex b10beea259..f8f23bdd21 100644\n--- a/src/isTuesday/index.ts\n+++ b/src/isTuesday/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isTuesday} function options.\n+ */\n+export interface IsTuesdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isTuesday\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Is the given date Tuesday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is Tuesday\n  *\n@@ -19,8 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isTuesday(new Date(2014, 8, 23))\n  * //=> true\n  */\n-export function isTuesday<DateType extends Date>(\n+export function isTuesday<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsTuesdayOptions<ContextDate> | undefined,\n ): boolean {\n-  return toDate(date).getDay() === 2;\n+  return toDate(date, options?.in).getDay() === 2;\n }\ndiff --git a/src/isValid/index.ts b/src/isValid/index.ts\nindex 3da52becc1..4ea8d3c68f 100644\n--- a/src/isValid/index.ts\n+++ b/src/isValid/index.ts\n@@ -35,9 +35,5 @@ import { toDate } from \"../toDate/index.js\";\n  * //=> false\n  */\n export function isValid(date: unknown): boolean {\n-  if (!isDate(date) && typeof date !== \"number\") {\n-    return false;\n-  }\n-  const _date = toDate(date);\n-  return !isNaN(Number(_date));\n+  return !((!isDate(date) && typeof date !== \"number\") || isNaN(+toDate(date)));\n }\ndiff --git a/src/isWednesday/index.ts b/src/isWednesday/index.ts\nindex 09fba97801..7a517dd381 100644\n--- a/src/isWednesday/index.ts\n+++ b/src/isWednesday/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isWednesday} function options.\n+ */\n+export interface IsWednesdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isWednesday\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Is the given date Wednesday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is Wednesday\n  *\n@@ -19,8 +28,9 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isWednesday(new Date(2014, 8, 24))\n  * //=> true\n  */\n-export function isWednesday<DateType extends Date>(\n+export function isWednesday<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsWednesdayOptions<ContextDate> | undefined,\n ): boolean {\n-  return toDate(date).getDay() === 3;\n+  return toDate(date, options?.in).getDay() === 3;\n }\ndiff --git a/src/isWeekend/index.ts b/src/isWeekend/index.ts\nindex 76cef50201..362039295d 100644\n--- a/src/isWeekend/index.ts\n+++ b/src/isWeekend/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isWeekend} function options.\n+ */\n+export interface IsWeekendOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isWeekend\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Does the given date fall on a weekend? A weekend is either Saturday (`6`) or Sunday (`0`).\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date falls on a weekend\n  *\n@@ -19,9 +28,10 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = isWeekend(new Date(2014, 9, 5))\n  * //=> true\n  */\n-export function isWeekend<DateType extends Date>(\n+export function isWeekend<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsWeekendOptions<ContextDate> | undefined,\n ): boolean {\n-  const day = toDate(date).getDay();\n+  const day = toDate(date, options?.in).getDay();\n   return day === 0 || day === 6;\n }\ndiff --git a/src/isWithinInterval/index.ts b/src/isWithinInterval/index.ts\nindex 2452708204..fca93658bf 100644\n--- a/src/isWithinInterval/index.ts\n+++ b/src/isWithinInterval/index.ts\n@@ -1,5 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n import type { Interval } from \"../types.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isWithinInterval} function options.\n+ */\n+export interface IsWithinIntervalOptions extends DateFns.ContextOptions<Date> {}\n \n /**\n  * @name isWithinInterval\n@@ -9,10 +15,9 @@ import type { Interval } from \"../types.js\";\n  * @description\n  * Is the given date within the interval? (Including start and end.)\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n- *\n  * @param date - The date to check\n  * @param interval - The interval to check\n+ * @param options - An object with options\n  *\n  * @returns The date is within the interval\n  *\n@@ -22,7 +27,7 @@ import type { Interval } from \"../types.js\";\n  *   start: new Date(2014, 0, 1),\n  *   end: new Date(2014, 0, 7)\n  * })\n- * //=> true\n+ * // => true\n  *\n  * @example\n  * // For the date outside of the interval:\n@@ -30,26 +35,27 @@ import type { Interval } from \"../types.js\";\n  *   start: new Date(2014, 0, 1),\n  *   end: new Date(2014, 0, 7)\n  * })\n- * //=> false\n+ * // => false\n  *\n  * @example\n- * // For date equal to interval start:\n+ * // For date equal to the interval start:\n  * isWithinInterval(date, { start, end: date })\n  * // => true\n  *\n  * @example\n- * // For date equal to interval end:\n+ * // For date equal to the interval end:\n  * isWithinInterval(date, { start: date, end })\n  * // => true\n  */\n-export function isWithinInterval<DateType extends Date>(\n-  date: DateType | number | string,\n-  interval: Interval<DateType>,\n+export function isWithinInterval(\n+  date: DateFns.Arg,\n+  interval: Interval,\n+  options?: IsWithinIntervalOptions | undefined,\n ): boolean {\n-  const time = +toDate(date);\n+  const time = +toDate(date, options?.in);\n   const [startTime, endTime] = [\n-    +toDate(interval.start),\n-    +toDate(interval.end),\n+    +toDate(interval.start, options?.in),\n+    +toDate(interval.end, options?.in),\n   ].sort((a, b) => a - b);\n \n   return time >= startTime && time <= endTime;\ndiff --git a/src/isYesterday/index.ts b/src/isYesterday/index.ts\nindex 38645ff7ad..4fb5bdcb0f 100644\n--- a/src/isYesterday/index.ts\n+++ b/src/isYesterday/index.ts\n@@ -1,6 +1,14 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { constructNow } from \"../constructNow/index.js\";\n import { isSameDay } from \"../isSameDay/index.js\";\n import { subDays } from \"../subDays/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link isYesterday} function options.\n+ */\n+export interface IsYesterdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name isYesterday\n@@ -12,8 +20,10 @@ import { subDays } from \"../subDays/index.js\";\n  * Is the given date yesterday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ContextDate - The `Date` type of the context function.\n  *\n  * @param date - The date to check\n+ * @param options - An object with options\n  *\n  * @returns The date is yesterday\n  *\n@@ -22,8 +32,12 @@ import { subDays } from \"../subDays/index.js\";\n  * const result = isYesterday(new Date(2014, 9, 5, 14, 0))\n  * //=> true\n  */\n-export function isYesterday<DateType extends Date>(\n+export function isYesterday<DateType extends Date, ContextDate extends Date>(\n   date: DateType | number | string,\n+  options?: IsYesterdayOptions<ContextDate> | undefined,\n ): boolean {\n-  return isSameDay(date, subDays(constructNow(date), 1));\n+  return isSameDay(\n+    constructFrom(options?.in || date, date),\n+    subDays(constructNow(options?.in || date), 1),\n+  );\n }\ndiff --git a/src/lastDayOfDecade/index.ts b/src/lastDayOfDecade/index.ts\nindex fbe6b7108b..f14daace4d 100644\n--- a/src/lastDayOfDecade/index.ts\n+++ b/src/lastDayOfDecade/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link lastDayOfDecade} function options.\n+ */\n+export interface LastDayOfDecadeOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name lastDayOfDecade\n@@ -8,9 +15,11 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Return the last day of a decade for the given date.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type; inferred from arguments or specified by context.\n  *\n  * @param date - The original date\n+ * @param options - The options\n  *\n  * @returns The last day of a decade\n  *\n@@ -19,16 +28,17 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = lastDayOfDecade(new Date(2012, 11, 21, 21, 12, 00))\n  * //=> Wed Dec 31 2019 00:00:00\n  */\n-export function lastDayOfDecade<DateType extends Date>(\n+export function lastDayOfDecade<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  // TODO: Switch to more technical definition in of decades that start with 1\n-  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking\n-  // change, so it can only be done in 4.0.\n-  const _date = toDate(date);\n+  options?: LastDayOfDecadeOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   const year = _date.getFullYear();\n   const decade = 9 + Math.floor(year / 10) * 10;\n   _date.setFullYear(decade + 1, 0, 0);\n   _date.setHours(0, 0, 0, 0);\n-  return _date;\n+  return toDate(_date, options?.in);\n }\ndiff --git a/src/lastDayOfISOWeek/index.ts b/src/lastDayOfISOWeek/index.ts\nindex 8783ae4809..3ecb6bb76a 100644\n--- a/src/lastDayOfISOWeek/index.ts\n+++ b/src/lastDayOfISOWeek/index.ts\n@@ -1,4 +1,11 @@\n import { lastDayOfWeek } from \"../lastDayOfWeek/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link lastDayOfISOWeek} function options.\n+ */\n+export interface LastDayOfISOWeekOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name lastDayOfISOWeek\n@@ -11,9 +18,11 @@ import { lastDayOfWeek } from \"../lastDayOfWeek/index.js\";\n  *\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The Date type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The last day of an ISO week\n  *\n@@ -22,8 +31,12 @@ import { lastDayOfWeek } from \"../lastDayOfWeek/index.js\";\n  * const result = lastDayOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Sun Sep 07 2014 00:00:00\n  */\n-export function lastDayOfISOWeek<DateType extends Date>(\n+export function lastDayOfISOWeek<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return lastDayOfWeek(date, { weekStartsOn: 1 });\n+  options?: LastDayOfISOWeekOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return lastDayOfWeek(date, { ...options, weekStartsOn: 1 });\n }\ndiff --git a/src/lastDayOfISOWeekYear/index.ts b/src/lastDayOfISOWeekYear/index.ts\nindex 811b15fd92..fb66d71f09 100644\n--- a/src/lastDayOfISOWeekYear/index.ts\n+++ b/src/lastDayOfISOWeekYear/index.ts\n@@ -1,6 +1,13 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { getISOWeekYear } from \"../getISOWeekYear/index.js\";\n import { startOfISOWeek } from \"../startOfISOWeek/index.js\";\n-import { constructFrom } from \"../constructFrom/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link lastDayOfISOWeekYear} function options.\n+ */\n+export interface LastDayOfISOWeekYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name lastDayOfISOWeekYear\n@@ -15,8 +22,10 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The end of an ISO week-numbering year\n  *\n@@ -25,14 +34,19 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * const result = lastDayOfISOWeekYear(new Date(2005, 6, 2))\n  * //=> Sun Jan 01 2006 00:00:00\n  */\n-export function lastDayOfISOWeekYear<DateType extends Date>(\n+export function lastDayOfISOWeekYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const year = getISOWeekYear(date);\n-  const fourthOfJanuary = constructFrom(date, 0);\n+  options?: LastDayOfISOWeekYearOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const year = getISOWeekYear(date, options);\n+  const fourthOfJanuary = constructFrom(options?.in || date, 0);\n   fourthOfJanuary.setFullYear(year + 1, 0, 4);\n   fourthOfJanuary.setHours(0, 0, 0, 0);\n-  const _date = startOfISOWeek(fourthOfJanuary);\n-  _date.setDate(_date.getDate() - 1);\n-  return _date;\n+\n+  const date_ = startOfISOWeek(fourthOfJanuary, options);\n+  date_.setDate(date_.getDate() - 1);\n+  return date_;\n }\ndiff --git a/src/lastDayOfMonth/index.ts b/src/lastDayOfMonth/index.ts\nindex 3117ad16c9..eca85985c2 100644\n--- a/src/lastDayOfMonth/index.ts\n+++ b/src/lastDayOfMonth/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link lastDayOfMonth} function options.\n+ */\n+export interface LastDayOfMonthOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name lastDayOfMonth\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The last day of a month\n  *\n@@ -20,12 +29,16 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = lastDayOfMonth(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Tue Sep 30 2014 00:00:00\n  */\n-export function lastDayOfMonth<DateType extends Date>(\n+export function lastDayOfMonth<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: LastDayOfMonthOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   const month = _date.getMonth();\n   _date.setFullYear(_date.getFullYear(), month + 1, 0);\n   _date.setHours(0, 0, 0, 0);\n-  return _date;\n+  return toDate(_date, options?.in) as ResultDate;\n }\ndiff --git a/src/lastDayOfQuarter/index.ts b/src/lastDayOfQuarter/index.ts\nindex 26f76205a4..aa2c9d1796 100644\n--- a/src/lastDayOfQuarter/index.ts\n+++ b/src/lastDayOfQuarter/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link lastDayOfQuarter} function options.\n+ */\n+export interface LastDayOfQuarterOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name lastDayOfQuarter\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - The options\n  *\n  * @returns The last day of a quarter\n  *\n@@ -20,13 +29,17 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = lastDayOfQuarter(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Tue Sep 30 2014 00:00:00\n  */\n-export function lastDayOfQuarter<DateType extends Date>(\n+export function lastDayOfQuarter<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n-  const currentMonth = _date.getMonth();\n+  options?: LastDayOfQuarterOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n+  const currentMonth = date_.getMonth();\n   const month = currentMonth - (currentMonth % 3) + 3;\n-  _date.setMonth(month, 0);\n-  _date.setHours(0, 0, 0, 0);\n-  return _date;\n+  date_.setMonth(month, 0);\n+  date_.setHours(0, 0, 0, 0);\n+  return date_;\n }\ndiff --git a/src/lastDayOfWeek/index.ts b/src/lastDayOfWeek/index.ts\nindex c53d09806f..1674e17eed 100644\n--- a/src/lastDayOfWeek/index.ts\n+++ b/src/lastDayOfWeek/index.ts\n@@ -1,13 +1,14 @@\n import { toDate } from \"../toDate/index.js\";\n-import type { LocalizedOptions, WeekOptions } from \"../types.js\";\n+import type { LocalizedOptions, WeekOptions, DateFns } from \"../types.js\";\n import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n \n /**\n  * The {@link lastDayOfWeek} function options.\n  */\n-export interface LastDayOfWeekOptions\n+export interface LastDayOfWeekOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\">,\n-    WeekOptions {}\n+    WeekOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name lastDayOfWeek\n@@ -16,29 +17,23 @@ export interface LastDayOfWeekOptions\n  *\n  * @description\n  * Return the last day of a week for the given date.\n- * The result will be in the local timezone.\n+ * The result will be in the local timezone unless a context is specified.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n  * @param options - An object with options\n  *\n  * @returns The last day of a week\n- *\n- * @example\n- * // The last day of a week for 2 September 2014 11:55:00:\n- * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0))\n- * //=> Sat Sep 06 2014 00:00:00\n- *\n- * @example\n- * // If the week starts on Monday, the last day of the week for 2 September 2014 11:55:00:\n- * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })\n- * //=> Sun Sep 07 2014 00:00:00\n  */\n-export function lastDayOfWeek<DateType extends Date>(\n+export function lastDayOfWeek<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-  options?: LastDayOfWeekOptions,\n-): DateType {\n+  options?: LastDayOfWeekOptions<ResultDate>,\n+): ResultDate {\n   const defaultOptions = getDefaultOptions();\n   const weekStartsOn =\n     options?.weekStartsOn ??\n@@ -47,11 +42,12 @@ export function lastDayOfWeek<DateType extends Date>(\n     defaultOptions.locale?.options?.weekStartsOn ??\n     0;\n \n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const day = _date.getDay();\n   const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);\n \n   _date.setHours(0, 0, 0, 0);\n   _date.setDate(_date.getDate() + diff);\n+\n   return _date;\n }\ndiff --git a/src/lastDayOfYear/index.ts b/src/lastDayOfYear/index.ts\nindex 414ec9468e..5479c03754 100644\n--- a/src/lastDayOfYear/index.ts\n+++ b/src/lastDayOfYear/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link lastDayOfYear} function options.\n+ */\n+export interface LastDayOfYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name lastDayOfYear\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The last day of a year\n  *\n@@ -20,12 +29,16 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = lastDayOfYear(new Date(2014, 8, 2, 11, 55, 00))\n  * //=> Wed Dec 31 2014 00:00:00\n  */\n-export function lastDayOfYear<DateType extends Date>(\n+export function lastDayOfYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n-  const year = _date.getFullYear();\n-  _date.setFullYear(year + 1, 0, 0);\n-  _date.setHours(0, 0, 0, 0);\n-  return _date;\n+  options?: LastDayOfYearOptions<ResultDate>,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n+  const year = date_.getFullYear();\n+  date_.setFullYear(year + 1, 0, 0);\n+  date_.setHours(0, 0, 0, 0);\n+  return date_;\n }\ndiff --git a/src/lightFormat/index.ts b/src/lightFormat/index.ts\nindex ee76df76f4..db86853082 100644\n--- a/src/lightFormat/index.ts\n+++ b/src/lightFormat/index.ts\n@@ -89,9 +89,9 @@ export function lightFormat<DateType extends Date>(\n   date: DateType | number | string,\n   formatStr: string,\n ): string {\n-  const _date = toDate(date);\n+  const date_ = toDate(date);\n \n-  if (!isValid(_date)) {\n+  if (!isValid(date_)) {\n     throw new RangeError(\"Invalid time value\");\n   }\n \n@@ -114,7 +114,7 @@ export function lightFormat<DateType extends Date>(\n \n       const formatter = lightFormatters[firstCharacter as Token];\n       if (formatter) {\n-        return formatter(_date, substring);\n+        return formatter(date_, substring);\n       }\n \n       if (firstCharacter.match(unescapedLatinCharacterRegExp)) {\n@@ -134,10 +134,6 @@ export function lightFormat<DateType extends Date>(\n \n function cleanEscapedString(input: string) {\n   const matches = input.match(escapedStringRegExp);\n-\n-  if (!matches) {\n-    return input;\n-  }\n-\n+  if (!matches) return input;\n   return matches[1].replace(doubleQuoteRegExp, \"'\");\n }\ndiff --git a/src/max/index.ts b/src/max/index.ts\nindex a3a367f7fa..e51a1b6e9a 100644\n--- a/src/max/index.ts\n+++ b/src/max/index.ts\n@@ -1,4 +1,12 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link max} function options.\n+ */\n+export interface MaxOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name max\n@@ -9,6 +17,7 @@ import { toDate } from \"../toDate/index.js\";\n  * Return the latest of the given dates.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param dates - The dates to compare\n  *\n@@ -24,21 +33,21 @@ import { toDate } from \"../toDate/index.js\";\n  * ])\n  * //=> Sun Jul 02 1995 00:00:00\n  */\n-export function max<DateType extends Date>(\n-  dates: Array<DateType | number | string>,\n-): DateType | Date {\n-  let result: Date | undefined;\n-  dates.forEach(function (dirtyDate) {\n-    const currentDate = toDate(dirtyDate);\n+export function max<DateType extends Date, ResultDate extends Date = DateType>(\n+  dates: DateFns.Arg<DateType>[],\n+  options?: MaxOptions<ResultDate> | undefined,\n+): ResultDate {\n+  let result: ResultDate | undefined;\n+  let context = options?.in;\n+\n+  dates.forEach((date) => {\n+    // Use the first date object as the context function\n+    if (!context && typeof date === \"object\")\n+      context = constructFrom.bind(null, date) as DateFns.ContextFn<ResultDate>;\n \n-    if (\n-      result === undefined ||\n-      result < currentDate ||\n-      isNaN(Number(currentDate))\n-    ) {\n-      result = currentDate;\n-    }\n+    const date_ = toDate(date, context);\n+    if (!result || result < date_ || isNaN(+date_)) result = date_;\n   });\n \n-  return result || new Date(NaN);\n+  return constructFrom(context, result || NaN);\n }\ndiff --git a/src/min/index.ts b/src/min/index.ts\nindex bada2eef1d..5bf40183c8 100644\n--- a/src/min/index.ts\n+++ b/src/min/index.ts\n@@ -1,4 +1,12 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link min} function options.\n+ */\n+export interface MinOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name min\n@@ -9,6 +17,7 @@ import { toDate } from \"../toDate/index.js\";\n  * Returns the earliest of the given dates.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param dates - The dates to compare\n  *\n@@ -24,17 +33,21 @@ import { toDate } from \"../toDate/index.js\";\n  * ])\n  * //=> Wed Feb 11 1987 00:00:00\n  */\n-export function min<DateType extends Date>(\n+export function min<DateType extends Date, ResultDate extends Date = DateType>(\n   dates: Array<DateType | number | string>,\n-): DateType | Date {\n-  let result: Date | undefined;\n+  options?: MinOptions<ResultDate> | undefined,\n+): ResultDate {\n+  let result: ResultDate | undefined;\n+  let context = options?.in;\n+\n+  dates.forEach((date) => {\n+    // Use the first date object as the context function\n+    if (!context && typeof date === \"object\")\n+      context = constructFrom.bind(null, date) as DateFns.ContextFn<ResultDate>;\n \n-  dates.forEach((dirtyDate) => {\n-    const date = toDate(dirtyDate);\n-    if (!result || result > date || isNaN(+date)) {\n-      result = date;\n-    }\n+    const date_ = toDate(date, context);\n+    if (!result || result > date_ || isNaN(+date_)) result = date_;\n   });\n \n-  return result || new Date(NaN);\n+  return constructFrom(context, result || NaN);\n }\ndiff --git a/src/nextDay/index.ts b/src/nextDay/index.ts\nindex 96c034b878..16e9435646 100644\n--- a/src/nextDay/index.ts\n+++ b/src/nextDay/index.ts\n@@ -1,21 +1,26 @@\n import { addDays } from \"../addDays/index.js\";\n import { getDay } from \"../getDay/index.js\";\n-import type { Day } from \"../types.js\";\n+import type { DateFns, Day } from \"../types.js\";\n+\n+/**\n+ * The {@link nextDay} function options.\n+ */\n+export interface NextDayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name nextDay\n  * @category Weekday Helpers\n- * @summary When is the next day of the week?\n- *\n- * @description\n- * When is the next day of the week? 0-6 the day of the week, 0 represents Sunday.\n+ * @summary When is the next day of the week? 0-6 the day of the week, 0 represents Sunday.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to check\n- * @param day - day of the week\n+ * @param day - Day of the week\n+ * @param options - An object with options\n  *\n- * @returns The date is the next day of week\n+ * @returns The date is the next day of the week\n  *\n  * @example\n  * // When is the next Monday after Mar, 20, 2020?\n@@ -27,12 +32,16 @@ import type { Day } from \"../types.js\";\n  * const result = nextDay(new Date(2020, 2, 21), 2)\n  * //=> Tue Mar 24 2020 00:00:00\n  */\n-export function nextDay<DateType extends Date>(\n+export function nextDay<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   day: Day,\n-): DateType {\n-  let delta = day - getDay(date);\n+  options?: NextDayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  let delta = day - getDay(date, options);\n   if (delta <= 0) delta += 7;\n \n-  return addDays(date, delta);\n+  return addDays(date, delta, options);\n }\ndiff --git a/src/nextFriday/index.ts b/src/nextFriday/index.ts\nindex a2afa220b8..75501276a7 100644\n--- a/src/nextFriday/index.ts\n+++ b/src/nextFriday/index.ts\n@@ -1,4 +1,11 @@\n import { nextDay } from \"../nextDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link nextFriday} function options.\n+ */\n+export interface NextFridayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name nextFriday\n@@ -9,8 +16,10 @@ import { nextDay } from \"../nextDay/index.js\";\n  * When is the next Friday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The next Friday\n  *\n@@ -19,8 +28,12 @@ import { nextDay } from \"../nextDay/index.js\";\n  * const result = nextFriday(new Date(2020, 2, 22))\n  * //=> Fri Mar 27 2020 00:00:00\n  */\n-export function nextFriday<DateType extends Date>(\n+export function nextFriday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return nextDay(date, 5);\n+  options?: NextFridayOptions<ResultDate>,\n+): ResultDate {\n+  return nextDay(date, 5, options);\n }\ndiff --git a/src/nextMonday/index.ts b/src/nextMonday/index.ts\nindex 8fbdd090d7..623ca00344 100644\n--- a/src/nextMonday/index.ts\n+++ b/src/nextMonday/index.ts\n@@ -1,4 +1,11 @@\n import { nextDay } from \"../nextDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link nextMonday} function options.\n+ */\n+export interface NextMondayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name nextMonday\n@@ -9,8 +16,10 @@ import { nextDay } from \"../nextDay/index.js\";\n  * When is the next Monday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, returned from the context function if passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The next Monday\n  *\n@@ -19,8 +28,12 @@ import { nextDay } from \"../nextDay/index.js\";\n  * const result = nextMonday(new Date(2020, 2, 22))\n  * //=> Mon Mar 23 2020 00:00:00\n  */\n-export function nextMonday<DateType extends Date>(\n+export function nextMonday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return nextDay(date, 1);\n+  options?: NextMondayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return nextDay(date, 1, options);\n }\ndiff --git a/src/nextSaturday/index.ts b/src/nextSaturday/index.ts\nindex 540816b38c..6f1539a23b 100644\n--- a/src/nextSaturday/index.ts\n+++ b/src/nextSaturday/index.ts\n@@ -1,4 +1,11 @@\n import { nextDay } from \"../nextDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link nextSaturday} function options.\n+ */\n+export interface NextSaturdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name nextSaturday\n@@ -9,8 +16,10 @@ import { nextDay } from \"../nextDay/index.js\";\n  * When is the next Saturday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The next Saturday\n  *\n@@ -19,8 +28,12 @@ import { nextDay } from \"../nextDay/index.js\";\n  * const result = nextSaturday(new Date(2020, 2, 22))\n  * //=> Sat Mar 28 2020 00:00:00\n  */\n-export function nextSaturday<DateType extends Date>(\n+export function nextSaturday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return nextDay(date, 6);\n+  options?: NextSaturdayOptions<ResultDate>,\n+): ResultDate {\n+  return nextDay(date, 6, options);\n }\ndiff --git a/src/nextSunday/index.ts b/src/nextSunday/index.ts\nindex 099745a411..e4afb72f36 100644\n--- a/src/nextSunday/index.ts\n+++ b/src/nextSunday/index.ts\n@@ -1,4 +1,11 @@\n import { nextDay } from \"../nextDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link nextSunday} function options.\n+ */\n+export interface NextSundayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name nextSunday\n@@ -9,18 +16,24 @@ import { nextDay } from \"../nextDay/index.js\";\n  * When is the next Sunday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned if a context is provided.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The next Sunday\n  *\n  * @example\n- * // When is the next Sunday after Mar, 22, 2020?\n+ * // When is the next Sunday after March 22, 2020?\n  * const result = nextSunday(new Date(2020, 2, 22))\n  * //=> Sun Mar 29 2020 00:00:00\n  */\n-export function nextSunday<DateType extends Date>(\n+export function nextSunday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return nextDay(date, 0);\n+  options?: NextSundayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return nextDay(date, 0, options);\n }\ndiff --git a/src/nextThursday/index.ts b/src/nextThursday/index.ts\nindex 0ab091d02c..b50cea1e48 100644\n--- a/src/nextThursday/index.ts\n+++ b/src/nextThursday/index.ts\n@@ -1,4 +1,11 @@\n import { nextDay } from \"../nextDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link nextThursday} function options.\n+ */\n+export interface NextThursdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name nextThursday\n@@ -9,8 +16,10 @@ import { nextDay } from \"../nextDay/index.js\";\n  * When is the next Thursday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The next Thursday\n  *\n@@ -19,8 +28,12 @@ import { nextDay } from \"../nextDay/index.js\";\n  * const result = nextThursday(new Date(2020, 2, 22))\n  * //=> Thur Mar 26 2020 00:00:00\n  */\n-export function nextThursday<DateType extends Date>(\n+export function nextThursday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return nextDay(date, 4);\n+  options?: NextThursdayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return nextDay(date, 4, options);\n }\ndiff --git a/src/nextTuesday/index.ts b/src/nextTuesday/index.ts\nindex 5db5e833bf..4c3068be43 100644\n--- a/src/nextTuesday/index.ts\n+++ b/src/nextTuesday/index.ts\n@@ -1,4 +1,11 @@\n import { nextDay } from \"../nextDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link nextTuesday} function options.\n+ */\n+export interface NextTuesdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name nextTuesday\n@@ -9,8 +16,10 @@ import { nextDay } from \"../nextDay/index.js\";\n  * When is the next Tuesday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The next Tuesday\n  *\n@@ -19,8 +28,12 @@ import { nextDay } from \"../nextDay/index.js\";\n  * const result = nextTuesday(new Date(2020, 2, 22))\n  * //=> Tue Mar 24 2020 00:00:00\n  */\n-export function nextTuesday<DateType extends Date>(\n+export function nextTuesday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return nextDay(date, 2);\n+  options?: NextTuesdayOptions<ResultDate>,\n+): ResultDate {\n+  return nextDay(date, 2, options);\n }\ndiff --git a/src/nextWednesday/index.ts b/src/nextWednesday/index.ts\nindex d6b7f04b84..7db13f5b5d 100644\n--- a/src/nextWednesday/index.ts\n+++ b/src/nextWednesday/index.ts\n@@ -1,4 +1,11 @@\n import { nextDay } from \"../nextDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link nextWednesday} function options.\n+ */\n+export interface NextWednesdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name nextWednesday\n@@ -9,8 +16,10 @@ import { nextDay } from \"../nextDay/index.js\";\n  * When is the next Wednesday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The next Wednesday\n  *\n@@ -19,8 +28,12 @@ import { nextDay } from \"../nextDay/index.js\";\n  * const result = nextWednesday(new Date(2020, 2, 22))\n  * //=> Wed Mar 25 2020 00:00:00\n  */\n-export function nextWednesday<DateType extends Date>(\n+export function nextWednesday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return nextDay(date, 3);\n+  options?: NextWednesdayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return nextDay(date, 3, options);\n }\ndiff --git a/src/parse/_lib/Setter.ts b/src/parse/_lib/Setter.ts\nindex c2e4482de7..49b6baa453 100644\n--- a/src/parse/_lib/Setter.ts\n+++ b/src/parse/_lib/Setter.ts\n@@ -1,5 +1,6 @@\n-import { transpose } from \"../../transpose/index.js\";\n import { constructFrom } from \"../../constructFrom/index.js\";\n+import { transpose } from \"../../transpose/index.js\";\n+import { type DateFns } from \"../../types.js\";\n import type { ParseFlags, ParserOptions } from \"./types.js\";\n \n const TIMEZONE_UNIT_PRIORITY = 10;\n@@ -16,7 +17,7 @@ export abstract class Setter {\n   }\n \n   public abstract set<DateType extends Date>(\n-    utcDate: DateType,\n+    date: DateType,\n     flags: ParseFlags,\n     options: ParserOptions,\n   ): DateType | [DateType, ParseFlags];\n@@ -27,13 +28,13 @@ export class ValueSetter<Value> extends Setter {\n     private value: Value,\n \n     private validateValue: <DateType extends Date>(\n-      utcDate: DateType,\n+      date: DateType,\n       value: Value,\n       options: ParserOptions,\n     ) => boolean,\n \n     private setValue: <DateType extends Date>(\n-      utcDate: DateType,\n+      date: DateType,\n       flags: ParseFlags,\n       value: Value,\n       options: ParserOptions,\n@@ -63,11 +64,21 @@ export class ValueSetter<Value> extends Setter {\n   }\n }\n \n-export class DateToSystemTimezoneSetter extends Setter {\n+export class DateTimezoneSetter extends Setter {\n   priority = TIMEZONE_UNIT_PRIORITY;\n   subPriority = -1;\n+  context: DateFns.ContextFn<Date>;\n+\n+  constructor(\n+    context: DateFns.ContextFn<Date> | undefined,\n+    reference: DateFns.Arg,\n+  ) {\n+    super();\n+    this.context = context || ((date) => constructFrom(reference, date));\n+  }\n+\n   set<DateType extends Date>(date: DateType, flags: ParseFlags): DateType {\n     if (flags.timestampIsSet) return date;\n-    return constructFrom(date, transpose(date, Date));\n+    return constructFrom(date, transpose(date, this.context));\n   }\n }\ndiff --git a/src/parse/index.ts b/src/parse/index.ts\nindex 5f550d2965..910c580c99 100644\n--- a/src/parse/index.ts\n+++ b/src/parse/index.ts\n@@ -1,22 +1,23 @@\n+import { defaultLocale } from \"../_lib/defaultLocale/index.js\";\n+import { longFormatters } from \"../_lib/format/longFormatters/index.js\";\n+import {\n+  isProtectedDayOfYearToken,\n+  isProtectedWeekYearToken,\n+  warnOrThrowProtectedError,\n+} from \"../_lib/protectedTokens/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n import { getDefaultOptions } from \"../getDefaultOptions/index.js\";\n-import { defaultLocale } from \"../_lib/defaultLocale/index.js\";\n import { toDate } from \"../toDate/index.js\";\n import type {\n   AdditionalTokensOptions,\n+  DateFns,\n   FirstWeekContainsDateOptions,\n   LocalizedOptions,\n   WeekOptions,\n } from \"../types.js\";\n-import { longFormatters } from \"../_lib/format/longFormatters/index.js\";\n-import {\n-  isProtectedDayOfYearToken,\n-  isProtectedWeekYearToken,\n-  warnOrThrowProtectedError,\n-} from \"../_lib/protectedTokens/index.js\";\n-import { parsers } from \"./_lib/parsers/index.js\";\n import type { Setter } from \"./_lib/Setter.js\";\n-import { DateToSystemTimezoneSetter } from \"./_lib/Setter.js\";\n+import { DateTimezoneSetter } from \"./_lib/Setter.js\";\n+import { parsers } from \"./_lib/parsers/index.js\";\n import type { ParseFlags, ParserOptions } from \"./_lib/types.js\";\n \n // Rexports of internal for libraries to use.\n@@ -26,11 +27,12 @@ export { longFormatters, parsers };\n /**\n  * The {@link parse} function options.\n  */\n-export interface ParseOptions\n+export interface ParseOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\" | \"match\" | \"formatLong\">,\n     FirstWeekContainsDateOptions,\n     WeekOptions,\n-    AdditionalTokensOptions {}\n+    AdditionalTokensOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n // This RegExp consists of three parts separated by `|`:\n // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token\n@@ -353,12 +355,16 @@ const unescapedLatinCharacterRegExp = /[a-zA-Z]/;\n  * })\n  * //=> Sun Feb 28 2010 00:00:00\n  */\n-export function parse<DateType extends Date>(\n+export function parse<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   dateStr: string,\n   formatStr: string,\n   referenceDate: DateType | number | string,\n-  options?: ParseOptions,\n-): DateType {\n+  options?: ParseOptions<ResultDate>,\n+): ResultDate {\n+  const invalidDate = () => constructFrom(options?.in || referenceDate, NaN);\n   const defaultOptions = getDefaultOptions();\n   const locale = options?.locale ?? defaultOptions.locale ?? defaultLocale;\n \n@@ -376,13 +382,8 @@ export function parse<DateType extends Date>(\n     defaultOptions.locale?.options?.weekStartsOn ??\n     0;\n \n-  if (formatStr === \"\") {\n-    if (dateStr === \"\") {\n-      return toDate(referenceDate);\n-    } else {\n-      return constructFrom(referenceDate, NaN);\n-    }\n-  }\n+  if (!formatStr)\n+    return dateStr ? invalidDate() : toDate(referenceDate, options?.in);\n \n   const subFnOptions: ParserOptions = {\n     firstWeekContainsDate,\n@@ -390,8 +391,11 @@ export function parse<DateType extends Date>(\n     locale,\n   };\n \n-  // If timezone isn't specified, it will be set to the system timezone\n-  const setters: Setter[] = [new DateToSystemTimezoneSetter()];\n+  // If timezone isn't specified, it will try to use the context or\n+  // the reference date and fallback to the system time zone.\n+  const setters: Setter[] = [\n+    new DateTimezoneSetter(options?.in, referenceDate),\n+  ];\n \n   const tokens = formatStr\n     .match(longFormattingTokensRegExp)!\n@@ -453,7 +457,7 @@ export function parse<DateType extends Date>(\n       );\n \n       if (!parseResult) {\n-        return constructFrom(referenceDate, NaN);\n+        return invalidDate();\n       }\n \n       setters.push(parseResult.setter);\n@@ -479,14 +483,14 @@ export function parse<DateType extends Date>(\n       if (dateStr.indexOf(token) === 0) {\n         dateStr = dateStr.slice(token.length);\n       } else {\n-        return constructFrom(referenceDate, NaN);\n+        return invalidDate();\n       }\n     }\n   }\n \n   // Check if the remaining input contains something other than whitespace\n   if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {\n-    return constructFrom(referenceDate, NaN);\n+    return invalidDate();\n   }\n \n   const uniquePrioritySetters = setters\n@@ -500,16 +504,14 @@ export function parse<DateType extends Date>(\n     )\n     .map((setterArray) => setterArray[0]);\n \n-  let date = toDate(referenceDate);\n+  let date = toDate(referenceDate, options?.in);\n \n-  if (isNaN(date.getTime())) {\n-    return constructFrom(referenceDate, NaN);\n-  }\n+  if (isNaN(+date)) return invalidDate();\n \n   const flags: ParseFlags = {};\n   for (const setter of uniquePrioritySetters) {\n     if (!setter.validate(date, subFnOptions)) {\n-      return constructFrom(referenceDate, NaN);\n+      return invalidDate();\n     }\n \n     const result = setter.set(date, flags, subFnOptions);\n@@ -523,7 +525,7 @@ export function parse<DateType extends Date>(\n     }\n   }\n \n-  return constructFrom(referenceDate, date);\n+  return date;\n }\n \n function cleanEscapedString(input: string) {\ndiff --git a/src/parseISO/index.ts b/src/parseISO/index.ts\nindex 371cdd4193..4b89f00836 100644\n--- a/src/parseISO/index.ts\n+++ b/src/parseISO/index.ts\n@@ -1,12 +1,16 @@\n+import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n import {\n   millisecondsInHour,\n   millisecondsInMinute,\n } from \"../constants/index.js\";\n+import { constructFrom } from \"../constructFrom/index.js\";\n \n /**\n  * The {@link parseISO} function options.\n  */\n-export interface ParseISOOptions {\n+export interface ParseISOOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {\n   /** The additional number of digits in the extended year format */\n   additionalDigits?: 0 | 1 | 2;\n }\n@@ -26,6 +30,7 @@ export interface ParseISOOptions {\n  * the values are invalid, it returns Invalid Date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param argument - The value to convert\n  * @param options - An object with options\n@@ -43,7 +48,12 @@ export interface ParseISOOptions {\n  * const result = parseISO('+02014101', { additionalDigits: 1 })\n  * //=> Fri Apr 11 2014 00:00:00\n  */\n-export function parseISO(argument: string, options?: ParseISOOptions): Date {\n+export function parseISO<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(argument: string, options?: ParseISOOptions<ResultDate>): ResultDate {\n+  const invalidDate = () => constructFrom(options?.in, NaN);\n+\n   const additionalDigits = options?.additionalDigits ?? 2;\n   const dateStrings = splitDateString(argument);\n \n@@ -53,49 +63,38 @@ export function parseISO(argument: string, options?: ParseISOOptions): Date {\n     date = parseDate(parseYearResult.restDateString, parseYearResult.year);\n   }\n \n-  if (!date || isNaN(date.getTime())) {\n-    return new Date(NaN);\n-  }\n+  if (!date || isNaN(+date)) return invalidDate();\n \n-  const timestamp = date.getTime();\n+  const timestamp = +date;\n   let time = 0;\n   let offset;\n \n   if (dateStrings.time) {\n     time = parseTime(dateStrings.time);\n-    if (isNaN(time)) {\n-      return new Date(NaN);\n-    }\n+    if (isNaN(time)) return invalidDate();\n   }\n \n   if (dateStrings.timezone) {\n     offset = parseTimezone(dateStrings.timezone);\n-    if (isNaN(offset)) {\n-      return new Date(NaN);\n-    }\n+    if (isNaN(offset)) return invalidDate();\n   } else {\n-    const dirtyDate = new Date(timestamp + time);\n-    // JS parsed string assuming it's in UTC timezone\n-    // but we need it to be parsed in our timezone\n-    // so we use utc values to build date in our timezone.\n-    // Year values from 0 to 99 map to the years 1900 to 1999\n-    // so set year explicitly with setFullYear.\n-    const result = new Date(0);\n+    const tmpDate = new Date(timestamp + time);\n+    const result = toDate(0, options?.in);\n     result.setFullYear(\n-      dirtyDate.getUTCFullYear(),\n-      dirtyDate.getUTCMonth(),\n-      dirtyDate.getUTCDate(),\n+      tmpDate.getUTCFullYear(),\n+      tmpDate.getUTCMonth(),\n+      tmpDate.getUTCDate(),\n     );\n     result.setHours(\n-      dirtyDate.getUTCHours(),\n-      dirtyDate.getUTCMinutes(),\n-      dirtyDate.getUTCSeconds(),\n-      dirtyDate.getUTCMilliseconds(),\n+      tmpDate.getUTCHours(),\n+      tmpDate.getUTCMinutes(),\n+      tmpDate.getUTCSeconds(),\n+      tmpDate.getUTCMilliseconds(),\n     );\n     return result;\n   }\n \n-  return new Date(timestamp + time + offset);\n+  return toDate(timestamp + time + offset, options?.in);\n }\n \n interface DateString {\ndiff --git a/src/parseJSON/index.ts b/src/parseJSON/index.ts\nindex 978eac33ba..bb86e29287 100644\n--- a/src/parseJSON/index.ts\n+++ b/src/parseJSON/index.ts\n@@ -1,9 +1,13 @@\n+import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link parseJSON} function options.\n+ */\n+export interface ParseJSONOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n+\n /**\n- * @name parseJSON\n- * @category Common Helpers\n- * @summary Parse a JSON date string\n- *\n- * @description\n  * Converts a complete ISO date string in UTC time, the typical format for transmitting\n  * a date in JSON, to a JavaScript `Date` instance.\n  *\n@@ -28,27 +32,33 @@\n  *\n  * Any other input type or invalid date strings will return an `Invalid Date`.\n  *\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n+ *\n  * @param dateStr - A fully formed ISO8601 date string to convert\n+ * @param options - An object with options\n  *\n  * @returns The parsed date in the local time zone\n  */\n-export function parseJSON(dateStr: string): Date {\n+export function parseJSON<ResultDate extends Date = Date>(\n+  dateStr: string,\n+  options?: ParseJSONOptions<ResultDate> | undefined,\n+): ResultDate {\n   const parts = dateStr.match(\n     /(\\d{4})-(\\d{2})-(\\d{2})[T ](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{0,7}))?(?:Z|(.)(\\d{2}):?(\\d{2})?)?/,\n   );\n-  if (parts) {\n-    // Group 8 matches the sign\n-    return new Date(\n-      Date.UTC(\n-        +parts[1],\n-        +parts[2] - 1,\n-        +parts[3],\n-        +parts[4] - (+parts[9] || 0) * (parts[8] == \"-\" ? -1 : 1),\n-        +parts[5] - (+parts[10] || 0) * (parts[8] == \"-\" ? -1 : 1),\n-        +parts[6],\n-        +((parts[7] || \"0\") + \"00\").substring(0, 3),\n-      ),\n-    );\n-  }\n-  return new Date(NaN);\n+\n+  if (!parts) return toDate(NaN, options?.in);\n+\n+  return toDate(\n+    Date.UTC(\n+      +parts[1],\n+      +parts[2] - 1,\n+      +parts[3],\n+      +parts[4] - (+parts[9] || 0) * (parts[8] == \"-\" ? -1 : 1),\n+      +parts[5] - (+parts[10] || 0) * (parts[8] == \"-\" ? -1 : 1),\n+      +parts[6],\n+      +((parts[7] || \"0\") + \"00\").substring(0, 3),\n+    ),\n+    options?.in,\n+  );\n }\ndiff --git a/src/previousDay/index.ts b/src/previousDay/index.ts\nindex 8316460a40..ed6b86089c 100755\n--- a/src/previousDay/index.ts\n+++ b/src/previousDay/index.ts\n@@ -1,6 +1,12 @@\n import { getDay } from \"../getDay/index.js\";\n import { subDays } from \"../subDays/index.js\";\n-import type { Day } from \"../types.js\";\n+import type { DateFns, Day } from \"../types.js\";\n+\n+/**\n+ * The {@link previousDay} function options.\n+ */\n+export interface PreviousDayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name previousDay\n@@ -11,9 +17,11 @@ import type { Day } from \"../types.js\";\n  * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to check\n  * @param day - The day of the week\n+ * @param options - An object with options\n  *\n  * @returns The date is the previous day of week\n  *\n@@ -27,12 +35,16 @@ import type { Day } from \"../types.js\";\n  * const result = previousDay(new Date(2020, 2, 21), 2)\n  * //=> Tue Mar 17 2020 00:00:00\n  */\n-export function previousDay<DateType extends Date>(\n+export function previousDay<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   day: Day,\n-): DateType {\n-  let delta = getDay(date) - day;\n+  options?: PreviousDayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  let delta = getDay(date, options) - day;\n   if (delta <= 0) delta += 7;\n \n-  return subDays(date, delta);\n+  return subDays(date, delta, options);\n }\ndiff --git a/src/previousFriday/index.ts b/src/previousFriday/index.ts\nindex 2f0224961d..7b417b87d5 100755\n--- a/src/previousFriday/index.ts\n+++ b/src/previousFriday/index.ts\n@@ -1,4 +1,11 @@\n import { previousDay } from \"../previousDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link previousFriday} function options.\n+ */\n+export interface PreviousFridayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name previousFriday\n@@ -8,9 +15,11 @@ import { previousDay } from \"../previousDay/index.js\";\n  * @description\n  * When is the previous Friday?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - The options\n  *\n  * @returns The previous Friday\n  *\n@@ -19,8 +28,12 @@ import { previousDay } from \"../previousDay/index.js\";\n  * const result = previousFriday(new Date(2021, 5, 19))\n  * //=> Fri June 18 2021 00:00:00\n  */\n-export function previousFriday<DateType extends Date>(\n+export function previousFriday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return previousDay(date, 5);\n+  options?: PreviousFridayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return previousDay(date, 5, options);\n }\ndiff --git a/src/previousMonday/index.ts b/src/previousMonday/index.ts\nindex 2597496ccd..2600c67a0e 100755\n--- a/src/previousMonday/index.ts\n+++ b/src/previousMonday/index.ts\n@@ -1,4 +1,11 @@\n import { previousDay } from \"../previousDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link previousMonday} function options.\n+ */\n+export interface PreviousMondayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name previousMonday\n@@ -9,8 +16,10 @@ import { previousDay } from \"../previousDay/index.js\";\n  * When is the previous Monday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The previous Monday\n  *\n@@ -19,8 +28,12 @@ import { previousDay } from \"../previousDay/index.js\";\n  * const result = previousMonday(new Date(2021, 5, 18))\n  * //=> Mon June 14 2021 00:00:00\n  */\n-export function previousMonday<DateType extends Date>(\n+export function previousMonday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return previousDay(date, 1);\n+  options?: PreviousMondayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return previousDay(date, 1, options);\n }\ndiff --git a/src/previousSaturday/index.ts b/src/previousSaturday/index.ts\nindex ffcf50b65d..815b93f497 100755\n--- a/src/previousSaturday/index.ts\n+++ b/src/previousSaturday/index.ts\n@@ -1,4 +1,11 @@\n import { previousDay } from \"../previousDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link previousSaturday} function options.\n+ */\n+export interface PreviousSaturdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name previousSaturday\n@@ -9,8 +16,10 @@ import { previousDay } from \"../previousDay/index.js\";\n  * When is the previous Saturday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - The options\n  *\n  * @returns The previous Saturday\n  *\n@@ -19,8 +28,12 @@ import { previousDay } from \"../previousDay/index.js\";\n  * const result = previousSaturday(new Date(2021, 5, 20))\n  * //=> Sat June 19 2021 00:00:00\n  */\n-export function previousSaturday<DateType extends Date>(\n+export function previousSaturday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return previousDay(date, 6);\n+  options?: PreviousSaturdayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return previousDay(date, 6, options);\n }\ndiff --git a/src/previousSunday/index.ts b/src/previousSunday/index.ts\nindex 01e9432b8f..e92cf81d2a 100755\n--- a/src/previousSunday/index.ts\n+++ b/src/previousSunday/index.ts\n@@ -1,4 +1,11 @@\n import { previousDay } from \"../previousDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link previousSunday} function options.\n+ */\n+export interface PreviousSundayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name previousSunday\n@@ -9,8 +16,10 @@ import { previousDay } from \"../previousDay/index.js\";\n  * When is the previous Sunday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - The options\n  *\n  * @returns The previous Sunday\n  *\n@@ -19,8 +28,12 @@ import { previousDay } from \"../previousDay/index.js\";\n  * const result = previousSunday(new Date(2021, 5, 21))\n  * //=> Sun June 20 2021 00:00:00\n  */\n-export function previousSunday<DateType extends Date>(\n+export function previousSunday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return previousDay(date, 0);\n+  options?: PreviousSundayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return previousDay(date, 0, options);\n }\ndiff --git a/src/previousThursday/index.ts b/src/previousThursday/index.ts\nindex 5f065cba74..fe870e9e86 100755\n--- a/src/previousThursday/index.ts\n+++ b/src/previousThursday/index.ts\n@@ -1,4 +1,11 @@\n import { previousDay } from \"../previousDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link previousThursday} function options.\n+ */\n+export interface PreviousThursdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name previousThursday\n@@ -9,8 +16,10 @@ import { previousDay } from \"../previousDay/index.js\";\n  * When is the previous Thursday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The previous Thursday\n  *\n@@ -19,8 +28,12 @@ import { previousDay } from \"../previousDay/index.js\";\n  * const result = previousThursday(new Date(2021, 5, 18))\n  * //=> Thu June 17 2021 00:00:00\n  */\n-export function previousThursday<DateType extends Date>(\n+export function previousThursday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return previousDay(date, 4);\n+  options?: PreviousThursdayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return previousDay(date, 4, options);\n }\ndiff --git a/src/previousTuesday/index.ts b/src/previousTuesday/index.ts\nindex 3d4c5ad8e9..e47385748b 100755\n--- a/src/previousTuesday/index.ts\n+++ b/src/previousTuesday/index.ts\n@@ -1,4 +1,11 @@\n import { previousDay } from \"../previousDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link previousTuesday} function options.\n+ */\n+export interface PreviousTuesdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name previousTuesday\n@@ -9,8 +16,10 @@ import { previousDay } from \"../previousDay/index.js\";\n  * When is the previous Tuesday?\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The previous Tuesday\n  *\n@@ -19,8 +28,12 @@ import { previousDay } from \"../previousDay/index.js\";\n  * const result = previousTuesday(new Date(2021, 5, 18))\n  * //=> Tue June 15 2021 00:00:00\n  */\n-export function previousTuesday<DateType extends Date>(\n+export function previousTuesday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return previousDay(date, 2);\n+  options?: PreviousTuesdayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return previousDay(date, 2, options);\n }\ndiff --git a/src/previousWednesday/index.ts b/src/previousWednesday/index.ts\nindex 23bef6b3bf..ef0c0c27b7 100755\n--- a/src/previousWednesday/index.ts\n+++ b/src/previousWednesday/index.ts\n@@ -1,4 +1,11 @@\n import { previousDay } from \"../previousDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link previousWednesday} function options.\n+ */\n+export interface PreviousWednesdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name previousWednesday\n@@ -8,9 +15,11 @@ import { previousDay } from \"../previousDay/index.js\";\n  * @description\n  * When is the previous Wednesday?\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The Date type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to start counting from\n+ * @param options - An object with options\n  *\n  * @returns The previous Wednesday\n  *\n@@ -19,8 +28,12 @@ import { previousDay } from \"../previousDay/index.js\";\n  * const result = previousWednesday(new Date(2021, 5, 18))\n  * //=> Wed June 16 2021 00:00:00\n  */\n-export function previousWednesday<DateType extends Date>(\n+export function previousWednesday<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return previousDay(date, 3);\n+  options?: PreviousWednesdayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return previousDay(date, 3, options);\n }\ndiff --git a/src/roundToNearestHours/index.ts b/src/roundToNearestHours/index.ts\nindex a6ce17ca1b..39ca232b9a 100644\n--- a/src/roundToNearestHours/index.ts\n+++ b/src/roundToNearestHours/index.ts\n@@ -2,6 +2,7 @@ import { getRoundingMethod } from \"../_lib/getRoundingMethod/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n import { toDate } from \"../toDate/index.js\";\n import type {\n+  DateFns,\n   NearestHours,\n   NearestToUnitOptions,\n   RoundingOptions,\n@@ -10,9 +11,10 @@ import type {\n /**\n  * The {@link roundToNearestHours} function options.\n  */\n-export interface RoundToNearestHoursOptions\n+export interface RoundToNearestHoursOptions<DateType extends Date = Date>\n   extends NearestToUnitOptions<NearestHours>,\n-    RoundingOptions {}\n+    RoundingOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name roundToNearestHours\n@@ -24,6 +26,7 @@ export interface RoundToNearestHoursOptions\n  * Rounds up when the given date is exactly between the nearest round hours.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to round\n  * @param options - An object with options.\n@@ -39,13 +42,13 @@ export interface RoundToNearestHoursOptions\n  * // Round 10 July 2014 12:34:56 to nearest half hour:\n  * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 6 })\n  * //=> Thu Jul 10 2014 12:00:00\n-\n+ *\n  * @example\n  * // Round 10 July 2014 12:34:56 to nearest half hour:\n  * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 8 })\n  * //=> Thu Jul 10 2014 16:00:00\n-\n-* @example\n+ *\n+ * @example\n  * // Floor (rounds down) 10 July 2014 12:34:56 to nearest hour:\n  * const result = roundToNearestHours(new Date(2014, 6, 10, 1, 23, 45), { roundingMethod: 'ceil' })\n  * //=> Thu Jul 10 2014 02:00:00\n@@ -55,32 +58,33 @@ export interface RoundToNearestHoursOptions\n  * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { roundingMethod: 'floor', nearestTo: 8 })\n  * //=> Thu Jul 10 2014 08:00:00\n  */\n-export function roundToNearestHours<DateType extends Date>(\n+export function roundToNearestHours<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-  options?: RoundToNearestHoursOptions,\n-): Date {\n+  options?: RoundToNearestHoursOptions<ResultDate>,\n+): ResultDate {\n   const nearestTo = options?.nearestTo ?? 1;\n \n-  if (nearestTo < 1 || nearestTo > 12) return constructFrom(date, NaN);\n+  if (nearestTo < 1 || nearestTo > 12)\n+    return constructFrom(options?.in || date, NaN);\n \n-  const _date = toDate(date);\n-  const fractionalMinutes = _date.getMinutes() / 60;\n-  const fractionalSeconds = _date.getSeconds() / 60 / 60;\n-  const fractionalMilliseconds = _date.getMilliseconds() / 1000 / 60 / 60;\n+  const date_ = toDate(date, options?.in);\n+  const fractionalMinutes = date_.getMinutes() / 60;\n+  const fractionalSeconds = date_.getSeconds() / 60 / 60;\n+  const fractionalMilliseconds = date_.getMilliseconds() / 1000 / 60 / 60;\n   const hours =\n-    _date.getHours() +\n+    date_.getHours() +\n     fractionalMinutes +\n     fractionalSeconds +\n     fractionalMilliseconds;\n \n-  // Unlike the `differenceIn*` functions, the default rounding behavior is `round` and not 'trunc'\n   const method = options?.roundingMethod ?? \"round\";\n   const roundingMethod = getRoundingMethod(method);\n \n-  // nearestTo option does not care daylight savings time\n   const roundedHours = roundingMethod(hours / nearestTo) * nearestTo;\n \n-  const result = constructFrom(date, _date);\n-  result.setHours(roundedHours, 0, 0, 0);\n-  return result;\n+  date_.setHours(roundedHours, 0, 0, 0);\n+  return date_;\n }\ndiff --git a/src/roundToNearestMinutes/index.ts b/src/roundToNearestMinutes/index.ts\nindex b601560246..18d2d3fb5b 100644\n--- a/src/roundToNearestMinutes/index.ts\n+++ b/src/roundToNearestMinutes/index.ts\n@@ -2,6 +2,7 @@ import { getRoundingMethod } from \"../_lib/getRoundingMethod/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n import { toDate } from \"../toDate/index.js\";\n import type {\n+  DateFns,\n   NearestMinutes,\n   NearestToUnitOptions,\n   RoundingOptions,\n@@ -10,9 +11,10 @@ import type {\n /**\n  * The {@link roundToNearestMinutes} function options.\n  */\n-export interface RoundToNearestMinutesOptions\n+export interface RoundToNearestMinutesOptions<DateType extends Date = Date>\n   extends NearestToUnitOptions<NearestMinutes>,\n-    RoundingOptions {}\n+    RoundingOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name roundToNearestMinutes\n@@ -24,6 +26,7 @@ export interface RoundToNearestMinutesOptions\n  * Rounds up when the given date is exactly between the nearest round minutes.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to round\n  * @param options - An object with options.\n@@ -50,27 +53,28 @@ export interface RoundToNearestMinutesOptions\n  * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'ceil', nearestTo: 30 })\n  * //=> Thu Jul 10 2014 12:30:00\n  */\n-export function roundToNearestMinutes<DateType extends Date>(\n+export function roundToNearestMinutes<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-  options?: RoundToNearestMinutesOptions,\n-): DateType {\n+  options?: RoundToNearestMinutesOptions<ResultDate>,\n+): ResultDate {\n   const nearestTo = options?.nearestTo ?? 1;\n \n   if (nearestTo < 1 || nearestTo > 30) return constructFrom(date, NaN);\n \n-  const _date = toDate(date);\n-  const fractionalSeconds = _date.getSeconds() / 60;\n-  const fractionalMilliseconds = _date.getMilliseconds() / 1000 / 60;\n+  const date_ = toDate(date, options?.in);\n+  const fractionalSeconds = date_.getSeconds() / 60;\n+  const fractionalMilliseconds = date_.getMilliseconds() / 1000 / 60;\n   const minutes =\n-    _date.getMinutes() + fractionalSeconds + fractionalMilliseconds;\n+    date_.getMinutes() + fractionalSeconds + fractionalMilliseconds;\n \n-  // Unlike the `differenceIn*` functions, the default rounding behavior is `round` and not 'trunc'\n   const method = options?.roundingMethod ?? \"round\";\n   const roundingMethod = getRoundingMethod(method);\n \n   const roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;\n \n-  const result = constructFrom(date, _date);\n-  result.setMinutes(roundedMinutes, 0, 0);\n-  return result;\n+  date_.setMinutes(roundedMinutes, 0, 0);\n+  return date_;\n }\ndiff --git a/src/set/index.ts b/src/set/index.ts\nindex 4bdba1cf47..b587139bfd 100644\n--- a/src/set/index.ts\n+++ b/src/set/index.ts\n@@ -2,6 +2,13 @@ import { constructFrom } from \"../constructFrom/index.js\";\n import { setMonth } from \"../setMonth/index.js\";\n import { toDate } from \"../toDate/index.js\";\n import type { DateValues } from \"../types.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link set} function options.\n+ */\n+export interface SetOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name set\n@@ -19,9 +26,11 @@ import type { DateValues } from \"../types.js\";\n  * other `setX` functions that date-fns provides if you are concerned about the bundle size.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param values - The date values to be set\n+ * @param options - The options\n  *\n  * @returns The new date with options set\n  *\n@@ -35,45 +44,23 @@ import type { DateValues } from \"../types.js\";\n  * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })\n  * //=> Mon Sep 01 2014 12:23:45\n  */\n-\n-export function set<DateType extends Date>(\n+export function set<DateType extends Date, ResultDate extends Date = DateType>(\n   date: DateType | number | string,\n   values: DateValues,\n-): DateType {\n-  let _date = toDate(date);\n+  options?: SetOptions<ResultDate>,\n+): ResultDate {\n+  let _date = toDate(date, options?.in);\n \n   // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date\n-  if (isNaN(+_date)) {\n-    return constructFrom(date, NaN);\n-  }\n-\n-  if (values.year != null) {\n-    _date.setFullYear(values.year);\n-  }\n-\n-  if (values.month != null) {\n-    _date = setMonth(_date, values.month);\n-  }\n-\n-  if (values.date != null) {\n-    _date.setDate(values.date);\n-  }\n-\n-  if (values.hours != null) {\n-    _date.setHours(values.hours);\n-  }\n-\n-  if (values.minutes != null) {\n-    _date.setMinutes(values.minutes);\n-  }\n-\n-  if (values.seconds != null) {\n-    _date.setSeconds(values.seconds);\n-  }\n+  if (isNaN(+_date)) return constructFrom(options?.in || date, NaN);\n \n-  if (values.milliseconds != null) {\n-    _date.setMilliseconds(values.milliseconds);\n-  }\n+  if (values.year != null) _date.setFullYear(values.year);\n+  if (values.month != null) _date = setMonth(_date, values.month);\n+  if (values.date != null) _date.setDate(values.date);\n+  if (values.hours != null) _date.setHours(values.hours);\n+  if (values.minutes != null) _date.setMinutes(values.minutes);\n+  if (values.seconds != null) _date.setSeconds(values.seconds);\n+  if (values.milliseconds != null) _date.setMilliseconds(values.milliseconds);\n \n   return _date;\n }\ndiff --git a/src/setDate/index.ts b/src/setDate/index.ts\nindex a85a163568..e4162e5ad6 100644\n--- a/src/setDate/index.ts\n+++ b/src/setDate/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setDate} function options.\n+ */\n+export interface SetDateOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setDate\n@@ -8,10 +15,12 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Set the day of the month to the given date.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param dayOfMonth - The day of the month of the new date\n+ * @param options - The options\n  *\n  * @returns The new date with the day of the month set\n  *\n@@ -20,11 +29,15 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setDate(new Date(2014, 8, 1), 30)\n  * //=> Tue Sep 30 2014 00:00:00\n  */\n-export function setDate<DateType extends Date>(\n+export function setDate<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   dayOfMonth: number,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: SetDateOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setDate(dayOfMonth);\n   return _date;\n }\ndiff --git a/src/setDay/index.ts b/src/setDay/index.ts\nindex 1c6a2ef5aa..07994be4b3 100644\n--- a/src/setDay/index.ts\n+++ b/src/setDay/index.ts\n@@ -1,14 +1,15 @@\n+import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n import { addDays } from \"../addDays/index.js\";\n import { toDate } from \"../toDate/index.js\";\n-import type { LocalizedOptions, WeekOptions } from \"../types.js\";\n-import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n+import type { DateFns, LocalizedOptions, WeekOptions } from \"../types.js\";\n \n /**\n  * The {@link setDay} function options.\n  */\n-export interface SetDayOptions\n+export interface SetDayOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\">,\n-    WeekOptions {}\n+    WeekOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setDay\n@@ -19,6 +20,7 @@ export interface SetDayOptions\n  * Set the day of the week to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param day - The day of the week of the new date\n@@ -36,11 +38,14 @@ export interface SetDayOptions\n  * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })\n  * //=> Sun Sep 07 2014 00:00:00\n  */\n-export function setDay<DateType extends Date>(\n+export function setDay<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   day: number,\n-  options?: SetDayOptions,\n-): DateType {\n+  options?: SetDayOptions<ResultDate>,\n+): ResultDate {\n   const defaultOptions = getDefaultOptions();\n   const weekStartsOn =\n     options?.weekStartsOn ??\n@@ -49,8 +54,8 @@ export function setDay<DateType extends Date>(\n     defaultOptions.locale?.options?.weekStartsOn ??\n     0;\n \n-  const _date = toDate(date);\n-  const currentDay = _date.getDay();\n+  const date_ = toDate(date, options?.in);\n+  const currentDay = date_.getDay();\n \n   const remainder = day % 7;\n   const dayIndex = (remainder + 7) % 7;\n@@ -60,5 +65,5 @@ export function setDay<DateType extends Date>(\n     day < 0 || day > 6\n       ? day - ((currentDay + delta) % 7)\n       : ((dayIndex + delta) % 7) - ((currentDay + delta) % 7);\n-  return addDays(_date, diff);\n+  return addDays(date_, diff, options);\n }\ndiff --git a/src/setDayOfYear/index.ts b/src/setDayOfYear/index.ts\nindex 19ac5551e9..8aecd5be98 100644\n--- a/src/setDayOfYear/index.ts\n+++ b/src/setDayOfYear/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setDayOfYear} function options.\n+ */\n+export interface SetDayOfYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setDayOfYear\n@@ -9,9 +16,11 @@ import { toDate } from \"../toDate/index.js\";\n  * Set the day of the year to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param dayOfYear - The day of the year of the new date\n+ * @param options - An object with options\n  *\n  * @returns The new date with the day of the year set\n  *\n@@ -20,12 +29,16 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setDayOfYear(new Date(2014, 6, 2), 2)\n  * //=> Thu Jan 02 2014 00:00:00\n  */\n-export function setDayOfYear<DateType extends Date>(\n+export function setDayOfYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   dayOfYear: number,\n-): DateType {\n-  const _date = toDate(date);\n-  _date.setMonth(0);\n-  _date.setDate(dayOfYear);\n-  return _date;\n+  options?: SetDayOfYearOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n+  date_.setMonth(0);\n+  date_.setDate(dayOfYear);\n+  return date_;\n }\ndiff --git a/src/setDefaultOptions/index.ts b/src/setDefaultOptions/index.ts\nindex 0756a5f6e1..fb1245c4ce 100644\n--- a/src/setDefaultOptions/index.ts\n+++ b/src/setDefaultOptions/index.ts\n@@ -1,8 +1,7 @@\n-import type {\n-  DefaultOptions} from \"../_lib/defaultOptions/index.js\";\n+import type { DefaultOptions } from \"../_lib/defaultOptions/index.js\";\n import {\n   getDefaultOptions,\n-  setDefaultOptions as setInternalDefaultOptions\n+  setDefaultOptions as setInternalDefaultOptions,\n } from \"../_lib/defaultOptions/index.js\";\n \n /**\ndiff --git a/src/setHours/index.ts b/src/setHours/index.ts\nindex 96ffe321a9..fa197ec9f4 100644\n--- a/src/setHours/index.ts\n+++ b/src/setHours/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setHours} function options.\n+ */\n+export interface SetHoursOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setHours\n@@ -9,9 +16,11 @@ import { toDate } from \"../toDate/index.js\";\n  * Set the hours to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param hours - The hours of the new date\n+ * @param options - An object with options\n  *\n  * @returns The new date with the hours set\n  *\n@@ -20,11 +29,15 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)\n  * //=> Mon Sep 01 2014 04:30:00\n  */\n-export function setHours<DateType extends Date>(\n+export function setHours<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   hours: number,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: SetHoursOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setHours(hours);\n   return _date;\n }\ndiff --git a/src/setISODay/index.ts b/src/setISODay/index.ts\nindex 1fb3c315a4..479e314f92 100644\n--- a/src/setISODay/index.ts\n+++ b/src/setISODay/index.ts\n@@ -1,6 +1,13 @@\n import { addDays } from \"../addDays/index.js\";\n import { getISODay } from \"../getISODay/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setISODay} function options.\n+ */\n+export interface SetISODayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setISODay\n@@ -10,12 +17,14 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Set the day of the ISO week to the given date.\n  * ISO week starts with Monday.\n- * 7 is the index of Sunday, 1 is the index of Monday etc.\n+ * 7 is the index of Sunday, 1 is the index of Monday, etc.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param day - The day of the ISO week of the new date\n+ * @param options - An object with options\n  *\n  * @returns The new date with the day of the ISO week set\n  *\n@@ -24,12 +33,16 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setISODay(new Date(2014, 8, 1), 7)\n  * //=> Sun Sep 07 2014 00:00:00\n  */\n-export function setISODay<DateType extends Date>(\n+export function setISODay<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   day: number,\n-): DateType {\n-  const _date = toDate(date);\n-  const currentDay = getISODay(_date);\n+  options?: SetISODayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n+  const currentDay = getISODay(date_, options);\n   const diff = day - currentDay;\n-  return addDays(_date, diff);\n+  return addDays(date_, diff, options);\n }\ndiff --git a/src/setISOWeek/index.ts b/src/setISOWeek/index.ts\nindex baff05da15..c02f1e919f 100644\n--- a/src/setISOWeek/index.ts\n+++ b/src/setISOWeek/index.ts\n@@ -1,5 +1,12 @@\n import { getISOWeek } from \"../getISOWeek/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setISOWeek} function options.\n+ */\n+export interface SetISOWeekOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setISOWeek\n@@ -12,9 +19,11 @@ import { toDate } from \"../toDate/index.js\";\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The `Date` type of the context function.\n  *\n  * @param date - The date to be changed\n  * @param week - The ISO week of the new date\n+ * @param options - An object with options\n  *\n  * @returns The new date with the ISO week set\n  *\n@@ -23,12 +32,16 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setISOWeek(new Date(2004, 7, 7), 53)\n  * //=> Sat Jan 01 2005 00:00:00\n  */\n-export function setISOWeek<DateType extends Date>(\n+export function setISOWeek<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   week: number,\n-): DateType {\n-  const _date = toDate(date);\n-  const diff = getISOWeek(_date) - week;\n+  options?: SetISOWeekOptions<ResultDate>,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n+  const diff = getISOWeek(_date, options) - week;\n   _date.setDate(_date.getDate() - diff * 7);\n   return _date;\n }\ndiff --git a/src/setISOWeekYear/index.ts b/src/setISOWeekYear/index.ts\nindex c3f1494861..5c4c18229c 100644\n--- a/src/setISOWeekYear/index.ts\n+++ b/src/setISOWeekYear/index.ts\n@@ -2,6 +2,13 @@ import { constructFrom } from \"../constructFrom/index.js\";\n import { differenceInCalendarDays } from \"../differenceInCalendarDays/index.js\";\n import { startOfISOWeekYear } from \"../startOfISOWeekYear/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setISOWeekYear} function options.\n+ */\n+export interface SetISOWeekYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setISOWeekYear\n@@ -14,10 +21,12 @@ import { toDate } from \"../toDate/index.js\";\n  *\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param weekYear - The ISO week-numbering year of the new date\n+ * @param options - An object with options\n  *\n  * @returns The new date with the ISO week-numbering year set\n  *\n@@ -26,13 +35,20 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setISOWeekYear(new Date(2008, 11, 29), 2007)\n  * //=> Mon Jan 01 2007 00:00:00\n  */\n-export function setISOWeekYear<DateType extends Date>(\n+export function setISOWeekYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   weekYear: number,\n-): DateType {\n-  let _date = toDate(date);\n-  const diff = differenceInCalendarDays(_date, startOfISOWeekYear(_date));\n-  const fourthOfJanuary = constructFrom(date, 0);\n+  options?: SetISOWeekYearOptions<ResultDate> | undefined,\n+): ResultDate {\n+  let _date = toDate(date, options?.in);\n+  const diff = differenceInCalendarDays(\n+    _date,\n+    startOfISOWeekYear(_date, options),\n+  );\n+  const fourthOfJanuary = constructFrom(options?.in || date, 0);\n   fourthOfJanuary.setFullYear(weekYear, 0, 4);\n   fourthOfJanuary.setHours(0, 0, 0, 0);\n   _date = startOfISOWeekYear(fourthOfJanuary);\ndiff --git a/src/setMilliseconds/index.ts b/src/setMilliseconds/index.ts\nindex 5811e3f333..7e247777a9 100644\n--- a/src/setMilliseconds/index.ts\n+++ b/src/setMilliseconds/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setMilliseconds} function options.\n+ */\n+export interface SetMillisecondsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setMilliseconds\n@@ -9,9 +16,11 @@ import { toDate } from \"../toDate/index.js\";\n  * Set the milliseconds to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param milliseconds - The milliseconds of the new date\n+ * @param options - The options\n  *\n  * @returns The new date with the milliseconds set\n  *\n@@ -20,11 +29,15 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setMilliseconds(new Date(2014, 8, 1, 11, 30, 40, 500), 300)\n  * //=> Mon Sep 01 2014 11:30:40.300\n  */\n-export function setMilliseconds<DateType extends Date>(\n+export function setMilliseconds<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   milliseconds: number,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: SetMillisecondsOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setMilliseconds(milliseconds);\n   return _date;\n }\ndiff --git a/src/setMinutes/index.ts b/src/setMinutes/index.ts\nindex f5b7842722..a19e96a235 100644\n--- a/src/setMinutes/index.ts\n+++ b/src/setMinutes/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setMinutes} function options.\n+ */\n+export interface SetMinutesOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setMinutes\n@@ -8,10 +15,12 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Set the minutes to the given date.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, returned from the context function, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param minutes - The minutes of the new date\n+ * @param options - An object with options\n  *\n  * @returns The new date with the minutes set\n  *\n@@ -20,11 +29,15 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)\n  * //=> Mon Sep 01 2014 11:45:40\n  */\n-export function setMinutes<DateType extends Date>(\n+export function setMinutes<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   minutes: number,\n-): DateType {\n-  const _date = toDate(date);\n-  _date.setMinutes(minutes);\n-  return _date;\n+  options?: SetMinutesOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n+  date_.setMinutes(minutes);\n+  return date_;\n }\ndiff --git a/src/setMonth/index.ts b/src/setMonth/index.ts\nindex 15817d3eb2..95d994b4ed 100644\n--- a/src/setMonth/index.ts\n+++ b/src/setMonth/index.ts\n@@ -1,6 +1,13 @@\n import { constructFrom } from \"../constructFrom/index.js\";\n import { getDaysInMonth } from \"../getDaysInMonth/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setMonth} function options.\n+ */\n+export interface SetMonthOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setMonth\n@@ -10,10 +17,11 @@ import { toDate } from \"../toDate/index.js\";\n  * @description\n  * Set the month to the given date.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).\n  *\n  * @param date - The date to be changed\n  * @param month - The month index to set (0-11)\n+ * @param options - The options\n  *\n  * @returns The new date with the month set\n  *\n@@ -22,20 +30,24 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setMonth(new Date(2014, 8, 1), 1)\n  * //=> Sat Feb 01 2014 00:00:00\n  */\n-export function setMonth<DateType extends Date>(\n+export function setMonth<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   month: number,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: SetMonthOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   const year = _date.getFullYear();\n   const day = _date.getDate();\n \n-  const dateWithDesiredMonth = constructFrom(date, 0);\n-  dateWithDesiredMonth.setFullYear(year, month, 15);\n-  dateWithDesiredMonth.setHours(0, 0, 0, 0);\n-  const daysInMonth = getDaysInMonth(dateWithDesiredMonth);\n-  // Set the last day of the new month\n-  // if the original date was the last day of the longer month\n+  const midMonth = constructFrom(options?.in || date, 0);\n+  midMonth.setFullYear(year, month, 15);\n+  midMonth.setHours(0, 0, 0, 0);\n+  const daysInMonth = getDaysInMonth(midMonth);\n+\n+  // Set the earlier date, allows to wrap Jan 31 to Feb 28\n   _date.setMonth(month, Math.min(day, daysInMonth));\n   return _date;\n }\ndiff --git a/src/setQuarter/index.ts b/src/setQuarter/index.ts\nindex 09d37faf9d..b8214c2018 100644\n--- a/src/setQuarter/index.ts\n+++ b/src/setQuarter/index.ts\n@@ -1,5 +1,12 @@\n import { setMonth } from \"../setMonth/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setQuarter} function options.\n+ */\n+export interface SetQuarterOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setQuarter\n@@ -10,9 +17,11 @@ import { toDate } from \"../toDate/index.js\";\n  * Set the year quarter to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param quarter - The quarter of the new date\n+ * @param options - The options\n  *\n  * @returns The new date with the quarter set\n  *\n@@ -21,12 +30,16 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setQuarter(new Date(2014, 6, 2), 2)\n  * //=> Wed Apr 02 2014 00:00:00\n  */\n-export function setQuarter<DateType extends Date>(\n+export function setQuarter<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   quarter: number,\n-): DateType {\n-  const _date = toDate(date);\n-  const oldQuarter = Math.trunc(_date.getMonth() / 3) + 1;\n+  options?: SetQuarterOptions<ResultDate>,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n+  const oldQuarter = Math.trunc(date_.getMonth() / 3) + 1;\n   const diff = quarter - oldQuarter;\n-  return setMonth(_date, _date.getMonth() + diff * 3);\n+  return setMonth(date_, date_.getMonth() + diff * 3);\n }\ndiff --git a/src/setSeconds/index.ts b/src/setSeconds/index.ts\nindex 636131e6a2..d86a2a2c75 100644\n--- a/src/setSeconds/index.ts\n+++ b/src/setSeconds/index.ts\n@@ -1,17 +1,26 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setSeconds} function options.\n+ */\n+export interface SetSecondsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setSeconds\n  * @category Second Helpers\n- * @summary Set the seconds to the given date.\n+ * @summary Set the seconds to the given date, with context support.\n  *\n  * @description\n- * Set the seconds to the given date.\n+ * Set the seconds to the given date, with an optional context for time zone specification.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param seconds - The seconds of the new date\n+ * @param options - An object with options\n  *\n  * @returns The new date with the seconds set\n  *\n@@ -20,11 +29,15 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)\n  * //=> Mon Sep 01 2014 11:30:45\n  */\n-export function setSeconds<DateType extends Date>(\n+export function setSeconds<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   seconds: number,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: SetSecondsOptions<ResultDate>,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setSeconds(seconds);\n   return _date;\n }\ndiff --git a/src/setWeek/index.ts b/src/setWeek/index.ts\nindex 84408f723e..d843324fdc 100644\n--- a/src/setWeek/index.ts\n+++ b/src/setWeek/index.ts\n@@ -4,15 +4,17 @@ import type {\n   FirstWeekContainsDateOptions,\n   LocalizedOptions,\n   WeekOptions,\n+  DateFns,\n } from \"../types.js\";\n \n /**\n  * The {@link setWeek} function options.\n  */\n-export interface SetWeekOptions\n+export interface SetWeekOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\">,\n     WeekOptions,\n-    FirstWeekContainsDateOptions {}\n+    FirstWeekContainsDateOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setWeek\n@@ -29,6 +31,7 @@ export interface SetWeekOptions\n  * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param week - The week of the new date\n@@ -51,13 +54,16 @@ export interface SetWeekOptions\n  * })\n  * //=> Sun Jan 4 2004 00:00:00\n  */\n-export function setWeek<DateType extends Date>(\n+export function setWeek<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   week: number,\n-  options?: SetWeekOptions,\n-): DateType {\n-  const _date = toDate(date);\n-  const diff = getWeek(_date, options) - week;\n-  _date.setDate(_date.getDate() - diff * 7);\n-  return _date;\n+  options?: SetWeekOptions<ResultDate>,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n+  const diff = getWeek(date_, options) - week;\n+  date_.setDate(date_.getDate() - diff * 7);\n+  return toDate(date_, options?.in);\n }\ndiff --git a/src/setWeekYear/index.ts b/src/setWeekYear/index.ts\nindex 2fedcc233a..8b4612f185 100644\n--- a/src/setWeekYear/index.ts\n+++ b/src/setWeekYear/index.ts\n@@ -1,21 +1,23 @@\n+import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n import { differenceInCalendarDays } from \"../differenceInCalendarDays/index.js\";\n import { startOfWeekYear } from \"../startOfWeekYear/index.js\";\n import { toDate } from \"../toDate/index.js\";\n import type {\n+  DateFns,\n   FirstWeekContainsDateOptions,\n   LocalizedOptions,\n   WeekOptions,\n } from \"../types.js\";\n-import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n \n /**\n  * The {@link setWeekYear} function options.\n  */\n-export interface SetWeekYearOptions\n+export interface SetWeekYearOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\">,\n     WeekOptions,\n-    FirstWeekContainsDateOptions {}\n+    FirstWeekContainsDateOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setWeekYear\n@@ -33,6 +35,7 @@ export interface SetWeekYearOptions\n  * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param weekYear - The local week-numbering year of the new date\n@@ -55,11 +58,14 @@ export interface SetWeekYearOptions\n  * })\n  * //=> Sat Jan 01 2005 00:00:00\n  */\n-export function setWeekYear<DateType extends Date>(\n+export function setWeekYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   weekYear: number,\n-  options?: SetWeekYearOptions,\n-): DateType {\n+  options?: SetWeekYearOptions<ResultDate>,\n+): ResultDate {\n   const defaultOptions = getDefaultOptions();\n   const firstWeekContainsDate =\n     options?.firstWeekContainsDate ??\n@@ -68,12 +74,17 @@ export function setWeekYear<DateType extends Date>(\n     defaultOptions.locale?.options?.firstWeekContainsDate ??\n     1;\n \n-  let _date = toDate(date);\n-  const diff = differenceInCalendarDays(_date, startOfWeekYear(_date, options));\n-  const firstWeek = constructFrom(date, 0);\n+  const diff = differenceInCalendarDays(\n+    toDate(date, options?.in),\n+    startOfWeekYear(date, options),\n+    options,\n+  );\n+\n+  const firstWeek = constructFrom(options?.in || date, 0);\n   firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate);\n   firstWeek.setHours(0, 0, 0, 0);\n-  _date = startOfWeekYear(firstWeek, options);\n-  _date.setDate(_date.getDate() + diff);\n-  return _date;\n+\n+  const date_ = startOfWeekYear(firstWeek, options);\n+  date_.setDate(date_.getDate() + diff);\n+  return date_;\n }\ndiff --git a/src/setYear/index.ts b/src/setYear/index.ts\nindex 981dad10a8..65167c2b8e 100644\n--- a/src/setYear/index.ts\n+++ b/src/setYear/index.ts\n@@ -1,5 +1,12 @@\n import { constructFrom } from \"../constructFrom/index.js\";\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link setYear} function options.\n+ */\n+export interface SetYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name setYear\n@@ -10,9 +17,11 @@ import { toDate } from \"../toDate/index.js\";\n  * Set the year to the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param year - The year of the new date\n+ * @param options - An object with options.\n  *\n  * @returns The new date with the year set\n  *\n@@ -21,17 +30,19 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = setYear(new Date(2014, 8, 1), 2013)\n  * //=> Sun Sep 01 2013 00:00:00\n  */\n-export function setYear<DateType extends Date>(\n+export function setYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   year: number,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: SetYearOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n \n   // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date\n-  if (isNaN(+_date)) {\n-    return constructFrom(date, NaN);\n-  }\n+  if (isNaN(+date_)) return constructFrom(options?.in || date, NaN);\n \n-  _date.setFullYear(year);\n-  return _date;\n+  date_.setFullYear(year);\n+  return date_;\n }\ndiff --git a/src/startOfDay/index.ts b/src/startOfDay/index.ts\nindex 353067e0d2..d03c871ede 100644\n--- a/src/startOfDay/index.ts\n+++ b/src/startOfDay/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfDay} function options.\n+ */\n+export interface StartOfDayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfDay\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - The options\n  *\n  * @returns The start of a day\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Tue Sep 02 2014 00:00:00\n  */\n-export function startOfDay<DateType extends Date>(\n+export function startOfDay<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: StartOfDayOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setHours(0, 0, 0, 0);\n   return _date;\n }\ndiff --git a/src/startOfDecade/index.ts b/src/startOfDecade/index.ts\nindex 69167f895e..ccacb77458 100644\n--- a/src/startOfDecade/index.ts\n+++ b/src/startOfDecade/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfDecade} options.\n+ */\n+export interface StartOfDecadeOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfDecade\n@@ -9,8 +16,10 @@ import { toDate } from \"../toDate/index.js\";\n  * Return the start of a decade for the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The start of a decade\n  *\n@@ -19,13 +28,17 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = startOfDecade(new Date(2015, 9, 21, 00, 00, 00))\n  * //=> Jan 01 2010 00:00:00\n  */\n-export function startOfDecade<DateType extends Date>(\n+export function startOfDecade<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n+  options?: StartOfDecadeOptions<ResultDate> | undefined,\n+): ResultDate {\n   // TODO: Switch to more technical definition in of decades that start with 1\n   // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking\n   // change, so it can only be done in 4.0.\n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const year = _date.getFullYear();\n   const decade = Math.floor(year / 10) * 10;\n   _date.setFullYear(decade, 0, 1);\ndiff --git a/src/startOfHour/index.ts b/src/startOfHour/index.ts\nindex 9935333e8b..28ebca695f 100644\n--- a/src/startOfHour/index.ts\n+++ b/src/startOfHour/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfHour} function options.\n+ */\n+export interface StartOfHourOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfHour\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The start of an hour\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = startOfHour(new Date(2014, 8, 2, 11, 55))\n  * //=> Tue Sep 02 2014 11:00:00\n  */\n-export function startOfHour<DateType extends Date>(\n+export function startOfHour<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: StartOfHourOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setMinutes(0, 0, 0);\n   return _date;\n }\ndiff --git a/src/startOfISOWeek/index.ts b/src/startOfISOWeek/index.ts\nindex 4bec9bb75c..4a00bfb853 100644\n--- a/src/startOfISOWeek/index.ts\n+++ b/src/startOfISOWeek/index.ts\n@@ -1,4 +1,11 @@\n import { startOfWeek } from \"../startOfWeek/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfISOWeek} function options.\n+ */\n+export interface StartOfISOWeekOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfISOWeek\n@@ -12,8 +19,10 @@ import { startOfWeek } from \"../startOfWeek/index.js\";\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The start of an ISO week\n  *\n@@ -22,8 +31,12 @@ import { startOfWeek } from \"../startOfWeek/index.js\";\n  * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Mon Sep 01 2014 00:00:00\n  */\n-export function startOfISOWeek<DateType extends Date>(\n+export function startOfISOWeek<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  return startOfWeek(date, { weekStartsOn: 1 });\n+  options?: StartOfISOWeekOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return startOfWeek(date, { ...options, weekStartsOn: 1 });\n }\ndiff --git a/src/startOfISOWeekYear/index.ts b/src/startOfISOWeekYear/index.ts\nindex 8f5cd52827..e239a3a867 100644\n--- a/src/startOfISOWeekYear/index.ts\n+++ b/src/startOfISOWeekYear/index.ts\n@@ -1,6 +1,13 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { getISOWeekYear } from \"../getISOWeekYear/index.js\";\n import { startOfISOWeek } from \"../startOfISOWeek/index.js\";\n-import { constructFrom } from \"../constructFrom/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfISOWeekYear} function options.\n+ */\n+export interface StartOfISOWeekYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfISOWeekYear\n@@ -15,8 +22,10 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The start of an ISO week-numbering year\n  *\n@@ -25,11 +34,15 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * const result = startOfISOWeekYear(new Date(2005, 6, 2))\n  * //=> Mon Jan 03 2005 00:00:00\n  */\n-export function startOfISOWeekYear<DateType extends Date>(\n+export function startOfISOWeekYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const year = getISOWeekYear(date);\n-  const fourthOfJanuary = constructFrom(date, 0);\n+  options?: StartOfISOWeekYearOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const year = getISOWeekYear(date, options);\n+  const fourthOfJanuary = constructFrom(options?.in || date, 0);\n   fourthOfJanuary.setFullYear(year, 0, 4);\n   fourthOfJanuary.setHours(0, 0, 0, 0);\n   return startOfISOWeek(fourthOfJanuary);\ndiff --git a/src/startOfMinute/index.ts b/src/startOfMinute/index.ts\nindex 7cc60d3c8a..98da71b979 100644\n--- a/src/startOfMinute/index.ts\n+++ b/src/startOfMinute/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfMinute} function options.\n+ */\n+export interface StartOfMinuteOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfMinute\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The start of a minute\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))\n  * //=> Mon Dec 01 2014 22:15:00\n  */\n-export function startOfMinute<DateType extends Date>(\n+export function startOfMinute<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n-  _date.setSeconds(0, 0);\n-  return _date;\n+  options?: StartOfMinuteOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n+  date_.setSeconds(0, 0);\n+  return date_;\n }\ndiff --git a/src/startOfMonth/index.ts b/src/startOfMonth/index.ts\nindex 392629a413..73b09b34de 100644\n--- a/src/startOfMonth/index.ts\n+++ b/src/startOfMonth/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfMonth} function options.\n+ */\n+export interface StartOfMonthOptions<ResultDate extends Date>\n+  extends DateFns.ContextOptions<ResultDate> {}\n \n /**\n  * @name startOfMonth\n@@ -6,12 +13,15 @@ import { toDate } from \"../toDate/index.js\";\n  * @summary Return the start of a month for the given date.\n  *\n  * @description\n- * Return the start of a month for the given date.\n- * The result will be in the local timezone.\n+ * Return the start of a month for the given date. The result will be in the local timezone.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments.\n+ * Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed,\n+ * or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - An object with options\n  *\n  * @returns The start of a month\n  *\n@@ -20,10 +30,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Mon Sep 01 2014 00:00:00\n  */\n-export function startOfMonth<DateType extends Date>(\n+export function startOfMonth<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: StartOfMonthOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   _date.setDate(1);\n   _date.setHours(0, 0, 0, 0);\n   return _date;\ndiff --git a/src/startOfQuarter/index.ts b/src/startOfQuarter/index.ts\nindex 2e5d4a4fef..961864af78 100644\n--- a/src/startOfQuarter/index.ts\n+++ b/src/startOfQuarter/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfQuarter} function options.\n+ */\n+export interface StartOfQuarterOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfQuarter\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - The options\n  *\n  * @returns The start of a quarter\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))\n  * //=> Tue Jul 01 2014 00:00:00\n  */\n-export function startOfQuarter<DateType extends Date>(\n+export function startOfQuarter<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n+  options?: StartOfQuarterOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const _date = toDate(date, options?.in);\n   const currentMonth = _date.getMonth();\n   const month = currentMonth - (currentMonth % 3);\n   _date.setMonth(month, 1);\ndiff --git a/src/startOfSecond/index.ts b/src/startOfSecond/index.ts\nindex b49d00a520..8a9e2a3701 100644\n--- a/src/startOfSecond/index.ts\n+++ b/src/startOfSecond/index.ts\n@@ -1,4 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfSecond} function options.\n+ */\n+export interface StartOfSecondOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfSecond\n@@ -10,8 +17,10 @@ import { toDate } from \"../toDate/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - The options\n  *\n  * @returns The start of a second\n  *\n@@ -20,10 +29,14 @@ import { toDate } from \"../toDate/index.js\";\n  * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))\n  * //=> Mon Dec 01 2014 22:15:45.000\n  */\n-export function startOfSecond<DateType extends Date>(\n+export function startOfSecond<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const _date = toDate(date);\n-  _date.setMilliseconds(0);\n-  return _date;\n+  options?: StartOfSecondOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n+  date_.setMilliseconds(0);\n+  return date_;\n }\ndiff --git a/src/startOfToday/index.ts b/src/startOfToday/index.ts\nindex 445669e4f1..fe6a740d53 100644\n--- a/src/startOfToday/index.ts\n+++ b/src/startOfToday/index.ts\n@@ -1,4 +1,11 @@\n import { startOfDay } from \"../startOfDay/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfToday} function options.\n+ */\n+export interface StartOfTodayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfToday\n@@ -9,6 +16,10 @@ import { startOfDay } from \"../startOfDay/index.js\";\n  * @description\n  * Return the start of today.\n  *\n+ * @typeParam ContextDate - The `Date` type of the context function.\n+ *\n+ * @param options - An object with options\n+ *\n  * @returns The start of today\n  *\n  * @example\n@@ -16,6 +27,8 @@ import { startOfDay } from \"../startOfDay/index.js\";\n  * const result = startOfToday()\n  * //=> Mon Oct 6 2014 00:00:00\n  */\n-export function startOfToday(): Date {\n-  return startOfDay(Date.now());\n+export function startOfToday<ContextDate extends Date>(\n+  options?: StartOfTodayOptions<ContextDate> | undefined,\n+): ContextDate {\n+  return startOfDay(Date.now(), options);\n }\ndiff --git a/src/startOfTomorrow/index.ts b/src/startOfTomorrow/index.ts\nindex abfdaf2e96..eeec7e589f 100644\n--- a/src/startOfTomorrow/index.ts\n+++ b/src/startOfTomorrow/index.ts\n@@ -1,26 +1,42 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n+import { constructNow } from \"../constructNow/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfTomorrow} function options.\n+ */\n+export interface StartOfTomorrowOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n+\n /**\n  * @name startOfTomorrow\n  * @category Day Helpers\n  * @summary Return the start of tomorrow.\n  * @pure false\n  *\n- * @description\n- * Return the start of tomorrow.\n+ * @typeParam ContextDate - The `Date` type of the context function.\n+ *\n+ * @param options - An object with options\n  *\n  * @returns The start of tomorrow\n  *\n+ * @description\n+ * Return the start of tomorrow.\n+ *\n  * @example\n  * // If today is 6 October 2014:\n  * const result = startOfTomorrow()\n  * //=> Tue Oct 7 2014 00:00:00\n  */\n-export function startOfTomorrow(): Date {\n-  const now = new Date();\n+export function startOfTomorrow<ContextDate extends Date>(\n+  options?: StartOfTomorrowOptions<ContextDate> | undefined,\n+): ContextDate {\n+  const now = constructNow(options?.in);\n   const year = now.getFullYear();\n   const month = now.getMonth();\n   const day = now.getDate();\n \n-  const date = new Date(0);\n+  const date = constructFrom(options?.in, 0);\n   date.setFullYear(year, month, day + 1);\n   date.setHours(0, 0, 0, 0);\n   return date;\ndiff --git a/src/startOfWeek/index.ts b/src/startOfWeek/index.ts\nindex 76d28a1ba2..1e6a222cf9 100644\n--- a/src/startOfWeek/index.ts\n+++ b/src/startOfWeek/index.ts\n@@ -1,13 +1,14 @@\n-import { toDate } from \"../toDate/index.js\";\n-import type { LocalizedOptions, WeekOptions } from \"../types.js\";\n import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n+import { toDate } from \"../toDate/index.js\";\n+import type { DateFns, LocalizedOptions, WeekOptions } from \"../types.js\";\n \n /**\n  * The {@link startOfWeek} function options.\n  */\n-export interface StartOfWeekOptions\n+export interface StartOfWeekOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\">,\n-    WeekOptions {}\n+    WeekOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfWeek\n@@ -19,6 +20,7 @@ export interface StartOfWeekOptions\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n  * @param options - An object with options\n@@ -35,10 +37,13 @@ export interface StartOfWeekOptions\n  * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })\n  * //=> Mon Sep 01 2014 00:00:00\n  */\n-export function startOfWeek<DateType extends Date>(\n+export function startOfWeek<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-  options?: StartOfWeekOptions,\n-): DateType {\n+  options?: StartOfWeekOptions<ResultDate>,\n+): ResultDate {\n   const defaultOptions = getDefaultOptions();\n   const weekStartsOn =\n     options?.weekStartsOn ??\n@@ -47,7 +52,7 @@ export function startOfWeek<DateType extends Date>(\n     defaultOptions.locale?.options?.weekStartsOn ??\n     0;\n \n-  const _date = toDate(date);\n+  const _date = toDate(date, options?.in);\n   const day = _date.getDay();\n   const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;\n \ndiff --git a/src/startOfWeekYear/index.ts b/src/startOfWeekYear/index.ts\nindex ad0af94f0d..2a57c7d3fe 100644\n--- a/src/startOfWeekYear/index.ts\n+++ b/src/startOfWeekYear/index.ts\n@@ -1,20 +1,22 @@\n+import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n import { getWeekYear } from \"../getWeekYear/index.js\";\n import { startOfWeek } from \"../startOfWeek/index.js\";\n import type {\n+  DateFns,\n   FirstWeekContainsDateOptions,\n   LocalizedOptions,\n   WeekOptions,\n } from \"../types.js\";\n-import { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n \n /**\n  * The {@link startOfWeekYear} function options.\n  */\n-export interface StartOfWeekYearOptions\n+export interface StartOfWeekYearOptions<DateType extends Date = Date>\n   extends LocalizedOptions<\"options\">,\n     FirstWeekContainsDateOptions,\n-    WeekOptions {}\n+    WeekOptions,\n+    DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfWeekYear\n@@ -31,6 +33,7 @@ export interface StartOfWeekYearOptions\n  * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type.\n  *\n  * @param date - The original date\n  * @param options - An object with options\n@@ -52,10 +55,13 @@ export interface StartOfWeekYearOptions\n  * })\n  * //=> Mon Jan 03 2005 00:00:00\n  */\n-export function startOfWeekYear<DateType extends Date>(\n+export function startOfWeekYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-  options?: StartOfWeekYearOptions,\n-): DateType {\n+  options?: StartOfWeekYearOptions<ResultDate>,\n+): ResultDate {\n   const defaultOptions = getDefaultOptions();\n   const firstWeekContainsDate =\n     options?.firstWeekContainsDate ??\n@@ -65,7 +71,7 @@ export function startOfWeekYear<DateType extends Date>(\n     1;\n \n   const year = getWeekYear(date, options);\n-  const firstWeek = constructFrom(date, 0);\n+  const firstWeek = constructFrom(options?.in || date, 0);\n   firstWeek.setFullYear(year, 0, firstWeekContainsDate);\n   firstWeek.setHours(0, 0, 0, 0);\n   const _date = startOfWeek(firstWeek, options);\ndiff --git a/src/startOfYear/index.ts b/src/startOfYear/index.ts\nindex 973aba2765..135a54be82 100644\n--- a/src/startOfYear/index.ts\n+++ b/src/startOfYear/index.ts\n@@ -1,5 +1,11 @@\n import { toDate } from \"../toDate/index.js\";\n-import { constructFrom } from \"../constructFrom/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfYear} function options.\n+ */\n+export interface StartOfYearOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name startOfYear\n@@ -11,8 +17,10 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * The result will be in the local timezone.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The original date\n+ * @param options - The options\n  *\n  * @returns The start of a year\n  *\n@@ -21,12 +29,15 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))\n  * //=> Wed Jan 01 2014 00:00:00\n  */\n-export function startOfYear<DateType extends Date>(\n+export function startOfYear<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n-): DateType {\n-  const cleanDate = toDate(date);\n-  const _date = constructFrom(date, 0);\n-  _date.setFullYear(cleanDate.getFullYear(), 0, 1);\n-  _date.setHours(0, 0, 0, 0);\n-  return _date;\n+  options?: StartOfYearOptions<ResultDate> | undefined,\n+): ResultDate {\n+  const date_ = toDate(date, options?.in);\n+  date_.setFullYear(date_.getFullYear(), 0, 1);\n+  date_.setHours(0, 0, 0, 0);\n+  return date_;\n }\ndiff --git a/src/startOfYesterday/index.ts b/src/startOfYesterday/index.ts\nindex 81552d5c40..d4b3165180 100644\n--- a/src/startOfYesterday/index.ts\n+++ b/src/startOfYesterday/index.ts\n@@ -1,9 +1,22 @@\n+import { constructNow } from \"../constructNow/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link startOfYesterday} function options.\n+ */\n+export interface StartOfYesterdayOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n+\n /**\n  * @name startOfYesterday\n  * @category Day Helpers\n  * @summary Return the start of yesterday.\n  * @pure false\n  *\n+ * @typeParam ContextDate - The `Date` type of the context function.\n+ *\n+ * @param options - An object with options\n+ *\n  * @description\n  * Return the start of yesterday.\n  *\n@@ -14,13 +27,15 @@\n  * const result = startOfYesterday()\n  * //=> Sun Oct 5 2014 00:00:00\n  */\n-export function startOfYesterday(): Date {\n-  const now = new Date();\n+export function startOfYesterday<ContextDate extends Date>(\n+  options?: StartOfYesterdayOptions<ContextDate> | undefined,\n+): ContextDate {\n+  const now = constructNow(options?.in);\n   const year = now.getFullYear();\n   const month = now.getMonth();\n   const day = now.getDate();\n \n-  const date = new Date(0);\n+  const date = constructNow(options?.in);\n   date.setFullYear(year, month, day - 1);\n   date.setHours(0, 0, 0, 0);\n   return date;\ndiff --git a/src/sub/index.ts b/src/sub/index.ts\nindex 39c3eab8c5..9f79f7eb1b 100644\n--- a/src/sub/index.ts\n+++ b/src/sub/index.ts\n@@ -1,7 +1,13 @@\n+import { constructFrom } from \"../constructFrom/index.js\";\n import { subDays } from \"../subDays/index.js\";\n import { subMonths } from \"../subMonths/index.js\";\n-import type { Duration } from \"../types.js\";\n-import { constructFrom } from \"../constructFrom/index.js\";\n+import type { DateFns, Duration } from \"../types.js\";\n+\n+/**\n+ * The {@link sub} function options.\n+ */\n+export interface SubOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name sub\n@@ -12,9 +18,11 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be subtracted\n+ * @param options - An object with options\n  *\n  * | Key     | Description                        |\n  * |---------|------------------------------------|\n@@ -43,10 +51,11 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * })\n  * //=> Mon Sep 1 2014 10:19:50\n  */\n-export function sub<DateType extends Date>(\n+export function sub<DateType extends Date, ResultDate extends Date = DateType>(\n   date: DateType | number | string,\n   duration: Duration,\n-): DateType {\n+  options?: SubOptions<ResultDate>,\n+): ResultDate {\n   const {\n     years = 0,\n     months = 0,\n@@ -57,17 +66,12 @@ export function sub<DateType extends Date>(\n     seconds = 0,\n   } = duration;\n \n-  // Subtract years and months\n-  const dateWithoutMonths = subMonths(date, months + years * 12);\n-\n-  // Subtract weeks and days\n-  const dateWithoutDays = subDays(dateWithoutMonths, days + weeks * 7);\n+  const withoutMonths = subMonths(date, months + years * 12, options);\n+  const withoutDays = subDays(withoutMonths, days + weeks * 7, options);\n \n-  // Subtract hours, minutes and seconds\n-  const minutestoSub = minutes + hours * 60;\n-  const secondstoSub = seconds + minutestoSub * 60;\n-  const mstoSub = secondstoSub * 1000;\n-  const finalDate = constructFrom(date, dateWithoutDays.getTime() - mstoSub);\n+  const minutesToSub = minutes + hours * 60;\n+  const secondsToSub = seconds + minutesToSub * 60;\n+  const msToSub = secondsToSub * 1000;\n \n-  return finalDate;\n+  return constructFrom(options?.in || date, +withoutDays - msToSub);\n }\ndiff --git a/src/subBusinessDays/index.ts b/src/subBusinessDays/index.ts\nindex 4b597d2638..e5ad4574b0 100644\n--- a/src/subBusinessDays/index.ts\n+++ b/src/subBusinessDays/index.ts\n@@ -1,17 +1,26 @@\n import { addBusinessDays } from \"../addBusinessDays/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link subBusinessDays} function options.\n+ */\n+export interface SubBusinessDaysOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name subBusinessDays\n  * @category Day Helpers\n- * @summary Subtract the specified number of business days (mon - fri) to the given date.\n+ * @summary Subtract the specified number of business days (mon - fri) from the given date.\n  *\n  * @description\n- * Subtract the specified number of business days (mon - fri) to the given date, ignoring weekends.\n+ * Subtract the specified number of business days (mon - fri) from the given date, ignoring weekends.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of business days to be subtracted.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the business days subtracted\n  *\n@@ -20,9 +29,13 @@ import { addBusinessDays } from \"../addBusinessDays/index.js\";\n  * const result = subBusinessDays(new Date(2014, 8, 1), 10)\n  * //=> Mon Aug 18 2014 00:00:00 (skipped weekend days)\n  */\n-export function subBusinessDays<DateType extends Date>(\n+export function subBusinessDays<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addBusinessDays(date, -amount);\n+  options?: SubBusinessDaysOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addBusinessDays(date, -amount, options);\n }\ndiff --git a/src/subDays/index.ts b/src/subDays/index.ts\nindex c15feb9859..52f8158dfc 100644\n--- a/src/subDays/index.ts\n+++ b/src/subDays/index.ts\n@@ -1,17 +1,23 @@\n import { addDays } from \"../addDays/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link subDays} function options.\n+ */\n+export interface SubDaysOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name subDays\n  * @category Day Helpers\n  * @summary Subtract the specified number of days from the given date.\n  *\n- * @description\n- * Subtract the specified number of days from the given date.\n- *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of days to be subtracted.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the days subtracted\n  *\n@@ -20,9 +26,13 @@ import { addDays } from \"../addDays/index.js\";\n  * const result = subDays(new Date(2014, 8, 1), 10)\n  * //=> Fri Aug 22 2014 00:00:00\n  */\n-export function subDays<DateType extends Date>(\n+export function subDays<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addDays(date, -amount);\n+  options?: SubDaysOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addDays(date, -amount, options);\n }\ndiff --git a/src/subHours/index.ts b/src/subHours/index.ts\nindex 246067a60f..2a1c86a501 100644\n--- a/src/subHours/index.ts\n+++ b/src/subHours/index.ts\n@@ -1,4 +1,11 @@\n import { addHours } from \"../addHours/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link subHours} function options.\n+ */\n+export interface SubHoursOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name subHours\n@@ -9,9 +16,11 @@ import { addHours } from \"../addHours/index.js\";\n  * Subtract the specified number of hours from the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of hours to be subtracted.\n+ * @param options - The options\n  *\n  * @returns The new date with the hours subtracted\n  *\n@@ -20,9 +29,13 @@ import { addHours } from \"../addHours/index.js\";\n  * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)\n  * //=> Thu Jul 10 2014 23:00:00\n  */\n-export function subHours<DateType extends Date>(\n+export function subHours<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addHours(date, -amount);\n+  options?: SubHoursOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addHours(date, -amount, options);\n }\ndiff --git a/src/subISOWeekYears/index.ts b/src/subISOWeekYears/index.ts\nindex ab40aaf920..4d3256cd8e 100644\n--- a/src/subISOWeekYears/index.ts\n+++ b/src/subISOWeekYears/index.ts\n@@ -1,4 +1,11 @@\n import { addISOWeekYears } from \"../addISOWeekYears/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link subISOWeekYears} function options.\n+ */\n+export interface SubISOWeekYearsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name subISOWeekYears\n@@ -11,9 +18,11 @@ import { addISOWeekYears } from \"../addISOWeekYears/index.js\";\n  * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of ISO week-numbering years to be subtracted.\n+ * @param options - The options\n  *\n  * @returns The new date with the ISO week-numbering years subtracted\n  *\n@@ -22,9 +31,13 @@ import { addISOWeekYears } from \"../addISOWeekYears/index.js\";\n  * const result = subISOWeekYears(new Date(2014, 8, 1), 5)\n  * //=> Mon Aug 31 2009 00:00:00\n  */\n-export function subISOWeekYears<DateType extends Date>(\n+export function subISOWeekYears<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addISOWeekYears(date, -amount);\n+  options?: SubISOWeekYearsOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addISOWeekYears(date, -amount, options);\n }\ndiff --git a/src/subMilliseconds/index.ts b/src/subMilliseconds/index.ts\nindex 2514432e0b..d024d814e6 100644\n--- a/src/subMilliseconds/index.ts\n+++ b/src/subMilliseconds/index.ts\n@@ -1,28 +1,31 @@\n import { addMilliseconds } from \"../addMilliseconds/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link subMilliseconds} function options.\n+ */\n+export interface SubMillisecondsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n- * @name subMilliseconds\n- * @category Millisecond Helpers\n- * @summary Subtract the specified number of milliseconds from the given date.\n- *\n- * @description\n  * Subtract the specified number of milliseconds from the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of milliseconds to be subtracted.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the milliseconds subtracted\n- *\n- * @example\n- * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:\n- * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)\n- * //=> Thu Jul 10 2014 12:45:29.250\n  */\n-export function subMilliseconds<DateType extends Date>(\n+export function subMilliseconds<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addMilliseconds(date, -amount);\n+  options?: SubMillisecondsOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addMilliseconds(date, -amount, options);\n }\ndiff --git a/src/subMinutes/index.ts b/src/subMinutes/index.ts\nindex f3efc92d68..00564d9cdd 100644\n--- a/src/subMinutes/index.ts\n+++ b/src/subMinutes/index.ts\n@@ -1,4 +1,11 @@\n import { addMinutes } from \"../addMinutes/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link subMinutes} function options.\n+ */\n+export interface SubMinutesOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name subMinutes\n@@ -9,9 +16,11 @@ import { addMinutes } from \"../addMinutes/index.js\";\n  * Subtract the specified number of minutes from the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of minutes to be subtracted.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the minutes subtracted\n  *\n@@ -20,9 +29,13 @@ import { addMinutes } from \"../addMinutes/index.js\";\n  * const result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)\n  * //=> Thu Jul 10 2014 11:30:00\n  */\n-export function subMinutes<DateType extends Date>(\n+export function subMinutes<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addMinutes(date, -amount);\n+  options?: SubMinutesOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addMinutes(date, -amount, options);\n }\ndiff --git a/src/subMonths/index.ts b/src/subMonths/index.ts\nindex 22b1141018..fb0e85655a 100644\n--- a/src/subMonths/index.ts\n+++ b/src/subMonths/index.ts\n@@ -1,4 +1,11 @@\n import { addMonths } from \"../addMonths/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The subMonths function options.\n+ */\n+export interface SubMonthsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name subMonths\n@@ -9,9 +16,11 @@ import { addMonths } from \"../addMonths/index.js\";\n  * Subtract the specified number of months from the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of months to be subtracted.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the months subtracted\n  *\n@@ -20,9 +29,13 @@ import { addMonths } from \"../addMonths/index.js\";\n  * const result = subMonths(new Date(2015, 1, 1), 5)\n  * //=> Mon Sep 01 2014 00:00:00\n  */\n-export function subMonths<DateType extends Date>(\n+export function subMonths<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addMonths(date, -amount);\n+  options?: SubMonthsOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addMonths(date, -amount, options);\n }\ndiff --git a/src/subQuarters/index.ts b/src/subQuarters/index.ts\nindex eaa1458d1b..3fdf4ae1ee 100644\n--- a/src/subQuarters/index.ts\n+++ b/src/subQuarters/index.ts\n@@ -1,4 +1,11 @@\n import { addQuarters } from \"../addQuarters/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link subQuarters} function options.\n+ */\n+export interface SubQuartersOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name subQuarters\n@@ -9,9 +16,11 @@ import { addQuarters } from \"../addQuarters/index.js\";\n  * Subtract the specified number of year quarters from the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of quarters to be subtracted.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the quarters subtracted\n  *\n@@ -20,9 +29,13 @@ import { addQuarters } from \"../addQuarters/index.js\";\n  * const result = subQuarters(new Date(2014, 8, 1), 3)\n  * //=> Sun Dec 01 2013 00:00:00\n  */\n-export function subQuarters<DateType extends Date>(\n+export function subQuarters<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addQuarters(date, -amount);\n+  options?: SubQuartersOptions<ResultDate>,\n+): ResultDate {\n+  return addQuarters(date, -amount, options);\n }\ndiff --git a/src/subSeconds/index.ts b/src/subSeconds/index.ts\nindex 790ca6e49f..abab69c8ce 100644\n--- a/src/subSeconds/index.ts\n+++ b/src/subSeconds/index.ts\n@@ -1,17 +1,21 @@\n import { addSeconds } from \"../addSeconds/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link subSeconds} function options.\n+ */\n+export interface SubSecondsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n- * @name subSeconds\n- * @category Second Helpers\n- * @summary Subtract the specified number of seconds from the given date.\n- *\n- * @description\n  * Subtract the specified number of seconds from the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of seconds to be subtracted.\n+ * @param options - The options\n  *\n  * @returns The new date with the seconds subtracted\n  *\n@@ -20,9 +24,13 @@ import { addSeconds } from \"../addSeconds/index.js\";\n  * const result = subSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)\n  * //=> Thu Jul 10 2014 12:44:30\n  */\n-export function subSeconds<DateType extends Date>(\n+export function subSeconds<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addSeconds(date, -amount);\n+  options?: SubSecondsOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addSeconds(date, -amount, options);\n }\ndiff --git a/src/subWeeks/index.ts b/src/subWeeks/index.ts\nindex f71466bf54..5d1ccc9bbd 100644\n--- a/src/subWeeks/index.ts\n+++ b/src/subWeeks/index.ts\n@@ -1,4 +1,11 @@\n import { addWeeks } from \"../addWeeks/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link subWeeks} function options.\n+ */\n+export interface SubWeeksOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name subWeeks\n@@ -9,9 +16,11 @@ import { addWeeks } from \"../addWeeks/index.js\";\n  * Subtract the specified number of weeks from the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of weeks to be subtracted.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the weeks subtracted\n  *\n@@ -20,9 +29,13 @@ import { addWeeks } from \"../addWeeks/index.js\";\n  * const result = subWeeks(new Date(2014, 8, 1), 4)\n  * //=> Mon Aug 04 2014 00:00:00\n  */\n-export function subWeeks<DateType extends Date>(\n+export function subWeeks<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addWeeks(date, -amount);\n+  options?: SubWeeksOptions<ResultDate> | undefined,\n+): ResultDate {\n+  return addWeeks(date, -amount, options);\n }\ndiff --git a/src/subYears/index.ts b/src/subYears/index.ts\nindex 72f42dcd2a..7d3c747f6a 100644\n--- a/src/subYears/index.ts\n+++ b/src/subYears/index.ts\n@@ -1,4 +1,11 @@\n import { addYears } from \"../addYears/index.js\";\n+import { type DateFns } from \"../types.js\";\n+\n+/**\n+ * The {@link subYears} function options.\n+ */\n+export interface SubYearsOptions<DateType extends Date = Date>\n+  extends DateFns.ContextOptions<DateType> {}\n \n /**\n  * @name subYears\n@@ -9,9 +16,11 @@ import { addYears } from \"../addYears/index.js\";\n  * Subtract the specified number of years from the given date.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n  *\n  * @param date - The date to be changed\n  * @param amount - The amount of years to be subtracted.\n+ * @param options - An object with options\n  *\n  * @returns The new date with the years subtracted\n  *\n@@ -20,9 +29,13 @@ import { addYears } from \"../addYears/index.js\";\n  * const result = subYears(new Date(2014, 8, 1), 5)\n  * //=> Tue Sep 01 2009 00:00:00\n  */\n-export function subYears<DateType extends Date>(\n+export function subYears<\n+  DateType extends Date,\n+  ResultDate extends Date = DateType,\n+>(\n   date: DateType | number | string,\n   amount: number,\n-): DateType {\n-  return addYears(date, -amount);\n+  options?: SubYearsOptions<ResultDate>,\n+): ResultDate {\n+  return addYears(date, -amount, options);\n }\ndiff --git a/src/toDate/index.ts b/src/toDate/index.ts\nindex 8721b1501a..5f8f1a6bae 100644\n--- a/src/toDate/index.ts\n+++ b/src/toDate/index.ts\n@@ -1,4 +1,9 @@\n-import type { GenericDateConstructor } from \"../types.js\";\n+import { constructFromSymbol } from \"../constants/index.js\";\n+import type {\n+  ConstructableDate,\n+  DateFns,\n+  GenericDateConstructor,\n+} from \"../types.js\";\n \n /**\n  * @name toDate\n@@ -14,6 +19,11 @@ import type { GenericDateConstructor } from \"../types.js\";\n  *\n  * If the argument is none of the above, the function returns Invalid Date.\n  *\n+ * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n+ * enabling to transfer extra properties from the reference date to the new date.\n+ * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n+ * that accept a time zone as a constructor argument.\n+ *\n  * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n  *\n  * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n@@ -32,18 +42,27 @@ import type { GenericDateConstructor } from \"../types.js\";\n  * const result = toDate(1392098430000)\n  * //=> Tue Feb 11 2014 11:30:30\n  */\n-export function toDate<DateType extends Date>(\n+export function toDate<\n+  DateType extends Date | ConstructableDate,\n+  ResultDate extends Date = DateType,\n+>(\n   argument: DateType | number | string,\n-): DateType {\n+  context?: DateFns.ContextFn<ResultDate> | undefined,\n+): ResultDate {\n+  // [TODO] Use constructFrom here instead?\n+  if (context) return context(argument);\n+\n   const argStr = Object.prototype.toString.call(argument);\n \n   // Clone the date\n-  if (\n+  if (typeof argument === \"object\" && constructFromSymbol in argument) {\n+    return argument[constructFromSymbol](argument);\n+  } else if (\n     argument instanceof Date ||\n     (typeof argument === \"object\" && argStr === \"[object Date]\")\n   ) {\n     // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n-    return new (argument.constructor as GenericDateConstructor<DateType>)(\n+    return new (argument.constructor as GenericDateConstructor<ResultDate>)(\n       +argument,\n     );\n   } else if (\n@@ -53,9 +72,9 @@ export function toDate<DateType extends Date>(\n     argStr === \"[object String]\"\n   ) {\n     // TODO: Can we get rid of as?\n-    return new Date(argument) as DateType;\n+    return new Date(argument) as ResultDate;\n   } else {\n     // TODO: Can we get rid of as?\n-    return new Date(NaN) as DateType;\n+    return new Date(NaN) as ResultDate;\n   }\n }\ndiff --git a/src/transpose/index.ts b/src/transpose/index.ts\nindex d090d453ff..17296c5e3d 100644\n--- a/src/transpose/index.ts\n+++ b/src/transpose/index.ts\n@@ -1,5 +1,5 @@\n-import type { GenericDateConstructor } from \"../types.js\";\n import { constructFrom } from \"../constructFrom/index.js\";\n+import type { DateFns, GenericDateConstructor } from \"../types.js\";\n \n /**\n  * @name transpose\n@@ -11,10 +11,10 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * to transpose the date in the system time zone to say `UTCDate` or any other\n  * date extension.\n  *\n- * @typeParam DateInputType - The input `Date` type derived from the passed argument.\n- * @typeParam DateOutputType - The output `Date` type derived from the passed constructor.\n+ * @typeParam InputDate - The input `Date` type derived from the passed argument.\n+ * @typeParam ResultDate - The result `Date` type derived from the passed constructor.\n  *\n- * @param fromDate - The date to use values from\n+ * @param date - The date to use values from\n  * @param constructor - The date constructor to use\n  *\n  * @returns Date transposed to the given constructor\n@@ -29,27 +29,31 @@ import { constructFrom } from \"../constructFrom/index.js\";\n  * transpose(date, UTCDate)\n  * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'\n  */\n-export function transpose<\n-  DateInputType extends Date,\n-  DateOutputType extends Date,\n->(\n-  fromDate: DateInputType,\n-  constructor: DateOutputType | GenericDateConstructor<DateOutputType>,\n-): DateOutputType {\n-  const date =\n-    constructor instanceof Date\n-      ? constructFrom(constructor, 0)\n-      : new constructor(0);\n-  date.setFullYear(\n-    fromDate.getFullYear(),\n-    fromDate.getMonth(),\n-    fromDate.getDate(),\n+export function transpose<InputDate extends Date, ResultDate extends Date>(\n+  date: InputDate,\n+  constructor:\n+    | ResultDate\n+    | GenericDateConstructor<ResultDate>\n+    | DateFns.ContextFn<ResultDate>,\n+): ResultDate {\n+  const date_ = isConstructor(constructor)\n+    ? new constructor(0)\n+    : constructFrom(constructor, 0);\n+  date_.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n+  date_.setHours(\n+    date.getHours(),\n+    date.getMinutes(),\n+    date.getSeconds(),\n+    date.getMilliseconds(),\n   );\n-  date.setHours(\n-    fromDate.getHours(),\n-    fromDate.getMinutes(),\n-    fromDate.getSeconds(),\n-    fromDate.getMilliseconds(),\n+  return date_;\n+}\n+\n+function isConstructor(\n+  constructor: unknown,\n+): constructor is GenericDateConstructor {\n+  return (\n+    typeof constructor === \"function\" &&\n+    constructor.prototype?.constructor === constructor\n   );\n-  return date;\n }\ndiff --git a/src/types.ts b/src/types.ts\nindex 9c451be052..ae84a3912f 100644\n--- a/src/types.ts\n+++ b/src/types.ts\n@@ -1,10 +1,22 @@\n /* eslint-disable no-unused-vars */\n \n import type { Locale } from \"./locale/types.js\";\n+import { type constructFromSymbol } from \"./constants/index.js\";\n \n export type * from \"./locale/types.js\";\n export type * from \"./fp/types.js\";\n \n+/**\n+ * Date extension interface that allows to transfer extra properties from\n+ * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n+ * that accept a time zone as a constructor argument.\n+ */\n+export interface ConstructableDate extends Date {\n+  [constructFromSymbol]: <DateType extends Date = Date>(\n+    value: Date | number | string,\n+  ) => DateType;\n+}\n+\n /**\n  * The generic date constructor. Replicates the Date constructor. Used to build\n  * generic functions.\n@@ -83,24 +95,26 @@ export type DurationUnit = keyof Duration;\n /**\n  * An object that combines two dates to represent the time interval.\n  *\n- * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n+ * @typeParam StartDate - The start `Date` type.\n+ * @typeParam EndDate - The end `Date` type.\n  */\n-export interface Interval<DateType extends Date = Date> {\n+export interface Interval<\n+  StartType extends DateFns.Arg = DateFns.Arg,\n+  EndType extends DateFns.Arg = DateFns.Arg,\n+> {\n   /** The start of the interval. */\n-  start: DateType | number | string;\n+  start: StartType;\n   /** The end of the interval. */\n-  end: DateType | number | string;\n+  end: EndType;\n }\n \n /**\n  * A version of {@link Interval} that has both start and end resolved to Date.\n  */\n-export interface NormalizedInterval<DateType extends Date = Date> {\n-  /** The start of the interval. */\n-  start: DateType;\n-  /** The end of the interval. */\n-  end: DateType;\n-}\n+export type NormalizedInterval<DateType extends Date = Date> = Interval<\n+  DateType,\n+  DateType\n+>;\n \n /**\n  * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).\n@@ -310,6 +324,30 @@ export interface NearestToUnitOptions<Unit extends number> {\n  * doesn't belong in the root namespace.\n  */\n export namespace DateFns {\n+  /**\n+   * The argument type.\n+   */\n+  export type Arg<DateType extends Date = Date> = DateType | number | string;\n+\n+  /**\n+   * The context function type. It's used to normalize the input arguments to\n+   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n+   */\n+  export type ContextFn<DateType extends Date> = (\n+    value: Date | number | string,\n+  ) => DateType;\n+\n+  /**\n+   * The context options. Used to build function options.\n+   */\n+  export interface ContextOptions<DateType extends Date = Date> {\n+    /**\n+     * The context to use in the function. It allows to normalize the arguments\n+     * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).\n+     */\n+    in?: ContextFn<DateType> | undefined;\n+  }\n+\n   /**\n    * Type utilities.\n    */\n", "test_patch": "diff --git a/scripts/test/_lib/tz.ts b/scripts/test/_lib/tz.ts\nindex b495ba71b1..28055d5942 100644\n--- a/scripts/test/_lib/tz.ts\n+++ b/scripts/test/_lib/tz.ts\n@@ -3,13 +3,12 @@ import { availableParallelism } from \"node:os\";\n import { promiseQueue } from \"./queue\";\n \n export async function testTimeZone(timeZone: string) {\n-  const { stderr, exitCode } =\n+  try {\n     await $`TZ=${timeZone} bun test ./src/**/test.ts`.quiet();\n-\n-  if (exitCode) {\n-    console.log(stderr.toString());\n+  } catch (err: any) {\n+    console.log(err.stderr.toString());\n     console.log(`\u26d4 Tests for the time zone ${timeZone}`);\n-    process.exit(exitCode);\n+    process.exit(err.exitCode);\n   }\n \n   console.log(`\u2705 Tests for the time zone ${timeZone}`);\ndiff --git a/src/_lib/test/index.ts b/src/_lib/test/index.ts\nindex 0f0b2eac90..373d183be0 100644\n--- a/src/_lib/test/index.ts\n+++ b/src/_lib/test/index.ts\n@@ -1,7 +1,18 @@\n+import { afterEach, beforeEach } from \"vitest\";\n import { addLeadingZeros } from \"../addLeadingZeros/index.js\";\n import { setDefaultOptions } from \"../defaultOptions/index.js\";\n+import sinon from \"sinon\";\n \n-export function assertType<T>(_: T): void {}\n+export function assertType<Type>(_value: Type) {}\n+\n+export namespace assertType {\n+  export type Equal<T, U> =\n+    Exclude<T, U> extends never\n+      ? Exclude<U, T> extends never\n+        ? true\n+        : false\n+      : false;\n+}\n \n export function resetDefaultOptions(): void {\n   setDefaultOptions({});\n@@ -27,3 +38,23 @@ export function generateOffset(originalDate: Date) {\n \n   return offset;\n }\n+\n+export function fakeDate(date: number | Date) {\n+  let clock: sinon.SinonFakeTimers | undefined;\n+\n+  function fakeNow(date: number | Date) {\n+    clock?.restore();\n+    clock = sinon.useFakeTimers(+date);\n+  }\n+\n+  beforeEach(() => {\n+    fakeNow(+date);\n+  });\n+\n+  afterEach(() => {\n+    clock?.restore();\n+    clock = undefined;\n+  });\n+\n+  return { fakeNow };\n+}\ndiff --git a/src/add/test.ts b/src/add/test.ts\nindex 96132e0c79..11ea46d743 100644\n--- a/src/add/test.ts\n+++ b/src/add/test.ts\n@@ -1,6 +1,9 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n-import { add } from \"./index.js\";\n import { getDstTransitions } from \"../../test/dst/tzOffsetTransitions.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { add } from \"./index.js\";\n \n describe(\"add\", () => {\n   it(\"adds the values from the given object\", () => {\n@@ -29,7 +32,7 @@ describe(\"add\", () => {\n     expect(result).toEqual(new Date(2015, 5 /* June */, 15, 15, 29, 20));\n   });\n \n-  it(\"returns same date object when passed empty duration values\", () => {\n+  it(\"returns the same date object when passed empty duration values\", () => {\n     const result = add(new Date(2014, 8 /* Sep */, 1, 10).getTime(), {\n       years: undefined,\n       months: undefined,\n@@ -42,7 +45,7 @@ describe(\"add\", () => {\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 1, 10));\n   });\n \n-  it(\"returns same date object when passed undefined duration values\", () => {\n+  it(\"returns the same date object when passed undefined duration values\", () => {\n     const result = add(new Date(2014, 8 /* Sep */, 1, 10).getTime(), {});\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 1, 10));\n   });\n@@ -60,7 +63,7 @@ describe(\"add\", () => {\n     expect(date).toEqual(new Date(2014, 8 /* Sep */, 1, 10));\n   });\n \n-  it(\"works well if the desired month has fewer days and the provided date is in the last day of a month\", () => {\n+  it(\"works well if the desired month has fewer days and the provided date is on the last day of a month\", () => {\n     const date = new Date(2014, 11 /* Dec */, 31);\n     const result = add(date, { months: 9 });\n     expect(result).toEqual(new Date(2015, 8 /* Sep */, 30));\n@@ -68,11 +71,12 @@ describe(\"add\", () => {\n \n   const dstTransitions = getDstTransitions(2017);\n   const dstOnly = dstTransitions.start && dstTransitions.end ? it : it.skip;\n-  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || process.env.tz;\n+  const tzName =\n+    Intl.DateTimeFormat().resolvedOptions().timeZone || process.env.tz;\n   const HOUR = 1000 * 60 * 60;\n \n   dstOnly(\n-    `works at DST-end boundary in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-end boundary in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = dstTransitions.end;\n       const result = add(date!, { hours: 1 });\n@@ -93,6 +97,47 @@ describe(\"add\", () => {\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     const result = add(new Date(NaN), { hours: 5 });\n-    expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n+    expect(result instanceof Date && isNaN(+result)).toBe(true);\n+  });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = add(Date.now(), { hours: 5 });\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = add(new UTCDate(), { hours: 5 });\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        add(\n+          \"2024-04-10T07:00:00Z\",\n+          { days: 10 },\n+          { in: tz(\"Asia/Singapore\") },\n+        ).toISOString(),\n+      ).toBe(\"2024-04-20T15:00:00.000+08:00\");\n+      expect(\n+        add(\n+          \"2024-04-10T07:00:00Z\",\n+          { days: 10 },\n+          { in: tz(\"America/Los_Angeles\") },\n+        ).toISOString(),\n+      ).toBe(\"2024-04-20T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = add(\n+        \"2014-09-01T00:00:00Z\",\n+        { days: 10 },\n+        { in: tz(\"Asia/Tokyo\") },\n+      );\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n   });\n });\ndiff --git a/src/addBusinessDays/test.ts b/src/addBusinessDays/test.ts\nindex 7d9b988fc0..0e754d84c5 100644\n--- a/src/addBusinessDays/test.ts\n+++ b/src/addBusinessDays/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { addBusinessDays } from \"./index.js\";\n \n describe(\"addBusinessDays\", () => {\n@@ -13,21 +16,27 @@ describe(\"addBusinessDays\", () => {\n   });\n \n   it(\"returns the Monday when 1 day is added on the Friday\", () => {\n-    expect(addBusinessDays(new Date(2020, 0 /* Jan */, 10), 1)).toEqual(// Friday\n-    // Monday\n-    new Date(2020, 0 /* Jan */, 13));\n+    expect(addBusinessDays(new Date(2020, 0 /* Jan */, 10), 1)).toEqual(\n+      // Friday\n+      // Monday\n+      new Date(2020, 0 /* Jan */, 13),\n+    );\n   });\n \n   it(\"returns the Monday when 1 day is added on the Satuday\", () => {\n-    expect(addBusinessDays(new Date(2020, 0 /* Jan */, 11), 1)).toEqual(// Saturday\n-    // Monday\n-    new Date(2020, 0 /* Jan */, 13));\n+    expect(addBusinessDays(new Date(2020, 0 /* Jan */, 11), 1)).toEqual(\n+      // Saturday\n+      // Monday\n+      new Date(2020, 0 /* Jan */, 13),\n+    );\n   });\n \n   it(\"returns the Monday when 1 day is added on the Sunday\", () => {\n-    expect(addBusinessDays(new Date(2020, 0 /* Jan */, 12), 1)).toEqual(// Sunday\n-    // Monday\n-    new Date(2020, 0 /* Jan */, 13));\n+    expect(addBusinessDays(new Date(2020, 0 /* Jan */, 12), 1)).toEqual(\n+      // Sunday\n+      // Monday\n+      new Date(2020, 0 /* Jan */, 13),\n+    );\n   });\n \n   it(\"can handle a large number of business days\", () => {\n@@ -72,4 +81,50 @@ describe(\"addBusinessDays\", () => {\n     const addResultWeekend = addBusinessDays(new Date(2019, 7, 17), 5);\n     expect(addResultWeekend).toEqual(new Date(2019, 7, 23));\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = addBusinessDays(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = addBusinessDays(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        addBusinessDays(\"2024-08-20T15:00:00Z\", 3, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-23T23:00:00.000+08:00\");\n+      expect(\n+        addBusinessDays(\"2024-08-20T16:00:00Z\", 3, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-26T00:00:00.000+08:00\");\n+      expect(\n+        addBusinessDays(new Date(\"2024-08-21T03:00:00Z\"), 3, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-23T23:00:00.000-04:00\");\n+      expect(\n+        addBusinessDays(new Date(\"2024-08-21T04:00:00Z\"), 3, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-26T00:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = addBusinessDays(date, 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/addDays/test.ts b/src/addDays/test.ts\nindex f54be2a3d7..0d15930b62 100644\n--- a/src/addDays/test.ts\n+++ b/src/addDays/test.ts\n@@ -1,6 +1,9 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n-import { addDays } from \"./index.js\";\n import { getDstTransitions } from \"../../test/dst/tzOffsetTransitions.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { addDays } from \"./index.js\";\n \n describe(\"addDays\", () => {\n   it(\"adds the given number of days\", () => {\n@@ -31,7 +34,8 @@ describe(\"addDays\", () => {\n \n   const dstTransitions = getDstTransitions(2017);\n   const dstOnly = dstTransitions.start && dstTransitions.end ? it : it.skip;\n-  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || process.env.tz;\n+  const tzName =\n+    Intl.DateTimeFormat().resolvedOptions().timeZone || process.env.tz;\n   const HOUR = 1000 * 60 * 60;\n   const MINUTE = 1000 * 60;\n   // It's usually 1 hour, but for some timezones, e.g. Australia/Lord_Howe, it is 30 minutes\n@@ -43,7 +47,7 @@ describe(\"addDays\", () => {\n       : NaN;\n \n   dstOnly(\n-    `works at DST-start boundary in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-start boundary in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = dstTransitions.start;\n       const result = addDays(date!, 1);\n@@ -52,7 +56,7 @@ describe(\"addDays\", () => {\n   );\n \n   dstOnly(\n-    `works at DST-start - 30 mins in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-start - 30 mins in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = new Date(dstTransitions.start!.getTime() - 0.5 * HOUR);\n       const result = addDays(date, 1);\n@@ -62,7 +66,7 @@ describe(\"addDays\", () => {\n   );\n \n   dstOnly(\n-    `works at DST-start - 60 mins in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-start - 60 mins in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = new Date(dstTransitions.start!.getTime() - 1 * HOUR);\n       const result = addDays(date, 1);\n@@ -72,7 +76,7 @@ describe(\"addDays\", () => {\n   );\n \n   dstOnly(\n-    `works at DST-end boundary in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-end boundary in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = dstTransitions.end;\n       const result = addDays(date!, 1);\n@@ -81,7 +85,7 @@ describe(\"addDays\", () => {\n   );\n \n   dstOnly(\n-    `works at DST-end - 30 mins in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-end - 30 mins in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = new Date(dstTransitions.end!.getTime() - 0.5 * HOUR);\n       const result = addDays(date, 1);\n@@ -92,7 +96,7 @@ describe(\"addDays\", () => {\n   );\n \n   dstOnly(\n-    `works at DST-end - 60 mins in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-end - 60 mins in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = new Date(dstTransitions.end!.getTime() - 1 * HOUR);\n       const result = addDays(date, 1);\n@@ -103,11 +107,47 @@ describe(\"addDays\", () => {\n   );\n \n   dstOnly(\n-    `doesn't mutate if zero increment is used: ${tz || \"(unknown)\"}`,\n+    `doesn't mutate if zero increment is used: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = new Date(dstTransitions.end!);\n       const result = addDays(date, 0);\n       expect(result).toEqual(date);\n     },\n   );\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = addDays(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = addDays(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        addDays(\"2024-04-10T07:00:00Z\", 10, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-20T15:00:00.000+08:00\");\n+      expect(\n+        addDays(\"2024-04-10T07:00:00Z\", 10, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-20T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = addDays(date, 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/addHours/test.ts b/src/addHours/test.ts\nindex 1f898e9dfe..f2ad50722e 100644\n--- a/src/addHours/test.ts\n+++ b/src/addHours/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { addHours } from \"./index.js\";\n \n describe(\"addHours\", () => {\n@@ -30,4 +33,40 @@ describe(\"addHours\", () => {\n     const result = addHours(new Date(2014, 6 /* Jul */, 10, 23, 0), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = addHours(Date.now(), 2);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = addHours(new UTCDate(), 2);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        addHours(\"2024-04-10T07:00:00Z\", 2, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T17:00:00.000+08:00\");\n+      expect(\n+        addHours(\"2024-04-10T07:00:00Z\", 2, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T02:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = addHours(date, 2, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/addISOWeekYears/test.ts b/src/addISOWeekYears/test.ts\nindex dcad9c3004..4b20bbefe0 100644\n--- a/src/addISOWeekYears/test.ts\n+++ b/src/addISOWeekYears/test.ts\n@@ -1,4 +1,7 @@\n+import { tz, TZDate } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { addISOWeekYears } from \"./index.js\";\n \n describe(\"addISOWeekYears\", () => {\n@@ -41,4 +44,35 @@ describe(\"addISOWeekYears\", () => {\n     const result = addISOWeekYears(new Date(2010, 6 /* Jul */, 2), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = addISOWeekYears(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = addISOWeekYears(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        addISOWeekYears(\"2023-07-01T10:00:00Z\", 1, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-06-29T00:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = addISOWeekYears(date, 5, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/addMilliseconds/test.ts b/src/addMilliseconds/test.ts\nindex c765104d0b..a42be5809b 100644\n--- a/src/addMilliseconds/test.ts\n+++ b/src/addMilliseconds/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { addMilliseconds } from \"./index.js\";\n \n describe(\"addMilliseconds\", () => {\n@@ -36,4 +39,35 @@ describe(\"addMilliseconds\", () => {\n     );\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = addMilliseconds(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = addMilliseconds(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        addMilliseconds(\"2024-04-10T07:00:00Z\", 10, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.010+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2024-04-10T07:00:00Z\");\n+      const result = addMilliseconds(date, 10, {\n+        in: tz(\"Asia/Singapore\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/addMinutes/test.ts b/src/addMinutes/test.ts\nindex 1811d67a53..874b61e60b 100644\n--- a/src/addMinutes/test.ts\n+++ b/src/addMinutes/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { addMinutes } from \"./index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"addMinutes\", () => {\n   it(\"adds the given number of minutes\", () => {\n@@ -30,4 +33,40 @@ describe(\"addMinutes\", () => {\n     const result = addMinutes(new Date(2014, 6 /* Jul */, 10, 12, 0), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = addMinutes(Date.now(), 2);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = addMinutes(new UTCDate(), 2);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        addMinutes(\"2024-04-10T15:00:00Z\", 60, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T23:00:00.000+08:00\");\n+      expect(\n+        addMinutes(\"2024-04-10T15:00:00Z\", 60, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T08:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = addMinutes(date, 2, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/addMonths/test.ts b/src/addMonths/test.ts\nindex ccc04fc3aa..e1efdef761 100644\n--- a/src/addMonths/test.ts\n+++ b/src/addMonths/test.ts\n@@ -1,6 +1,9 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n-import { addMonths } from \"./index.js\";\n import { getDstTransitions } from \"../../test/dst/tzOffsetTransitions.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { addMonths } from \"./index.js\";\n \n describe(\"addMonths\", () => {\n   it(\"adds the given number of months\", () => {\n@@ -48,7 +51,8 @@ describe(\"addMonths\", () => {\n \n   const dstTransitions = getDstTransitions(2017);\n   const dstOnly = dstTransitions.start && dstTransitions.end ? it : it.skip;\n-  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || process.env.tz;\n+  const tzName =\n+    Intl.DateTimeFormat().resolvedOptions().timeZone || process.env.tz;\n   const HOUR = 1000 * 60 * 60;\n   const override = (\n     base: Date,\n@@ -60,16 +64,18 @@ describe(\"addMonths\", () => {\n   ) => new Date(year, month, day, hour, minute);\n \n   dstOnly(\n-    `works at DST-start boundary in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-start boundary in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = dstTransitions.start;\n       const result = addMonths(date!, 2);\n-      expect(result).toEqual(override(date!, date!.getFullYear(), date!.getMonth() + 2));\n+      expect(result).toEqual(\n+        override(date!, date!.getFullYear(), date!.getMonth() + 2),\n+      );\n     },\n   );\n \n   dstOnly(\n-    `works at DST-start - 30 mins in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-start - 30 mins in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = new Date(dstTransitions.start!.getTime() - 0.5 * HOUR);\n       const result = addMonths(date, 2);\n@@ -79,7 +85,7 @@ describe(\"addMonths\", () => {\n   );\n \n   dstOnly(\n-    `works at DST-start - 60 mins in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-start - 60 mins in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = new Date(dstTransitions.start!.getTime() - 1 * HOUR);\n       const result = addMonths(date, 2);\n@@ -89,50 +95,89 @@ describe(\"addMonths\", () => {\n   );\n \n   dstOnly(\n-    `works at DST-end boundary in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-end boundary in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = dstTransitions.end;\n       const result = addMonths(date!, 2);\n-      expect(result).toEqual(override(\n-        date!,\n-        date!.getFullYear() + (date!.getMonth() >= 10 ? 1 : 0),\n-        (date!.getMonth() + 2) % 12, // protect against wrap for Nov.\n-      ));\n+      expect(result).toEqual(\n+        override(\n+          date!,\n+          date!.getFullYear() + (date!.getMonth() >= 10 ? 1 : 0),\n+          (date!.getMonth() + 2) % 12, // protect against wrap for Nov.\n+        ),\n+      );\n     },\n   );\n \n   dstOnly(\n-    `works at DST-end - 30 mins in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-end - 30 mins in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = new Date(dstTransitions.end!.getTime() - 0.5 * HOUR);\n       const result = addMonths(date, 2);\n-      expect(result).toEqual(override(\n-        date,\n-        date.getFullYear() + (date.getMonth() >= 10 ? 1 : 0),\n-        (date.getMonth() + 2) % 12, // protect against wrap for Nov.\n-      ));\n+      expect(result).toEqual(\n+        override(\n+          date,\n+          date.getFullYear() + (date.getMonth() >= 10 ? 1 : 0),\n+          (date.getMonth() + 2) % 12, // protect against wrap for Nov.\n+        ),\n+      );\n     },\n   );\n \n   dstOnly(\n-    `works at DST-end - 60 mins in local timezone: ${tz || \"(unknown)\"}`,\n+    `works at DST-end - 60 mins in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = new Date(dstTransitions.end!.getTime() - 1 * HOUR);\n       const result = addMonths(date, 2);\n-      expect(result).toEqual(override(\n-        date,\n-        date.getFullYear() + (date.getMonth() >= 10 ? 1 : 0),\n-        (date.getMonth() + 2) % 12, // protect against wrap for Nov.\n-      ));\n+      expect(result).toEqual(\n+        override(\n+          date,\n+          date.getFullYear() + (date.getMonth() >= 10 ? 1 : 0),\n+          (date.getMonth() + 2) % 12, // protect against wrap for Nov.\n+        ),\n+      );\n     },\n   );\n \n   dstOnly(\n-    `doesn't mutate if zero increment is used: ${tz || \"(unknown)\"}`,\n+    `doesn't mutate if zero increment is used: ${tzName || \"(unknown)\"}`,\n     () => {\n       const date = new Date(dstTransitions.end!);\n       const result = addMonths(date, 0);\n       expect(result).toEqual(date);\n     },\n   );\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = addMonths(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = addMonths(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = addMonths(date, 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      // Here we add 1 month to 1 Sep 2014 00:00 UTC (which is 1 Sep 2014 09:00 in Tokyo)\n+      // and we expect to get 1 Oct 2014 00:00 UTC (which is 1 Oct 2014 09:00 in Tokyo)\n+      expect(+result).toEqual(+new Date(\"2014-10-01T00:00:00Z\"));\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = addMonths(date, 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/addQuarters/test.ts b/src/addQuarters/test.ts\nindex 5d363be82d..da1e96c2bb 100644\n--- a/src/addQuarters/test.ts\n+++ b/src/addQuarters/test.ts\n@@ -1,5 +1,8 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { addQuarters } from \"./index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"addQuarters\", () => {\n   it(\"adds the given number of quarters\", () => {\n@@ -44,4 +47,35 @@ describe(\"addQuarters\", () => {\n     const result = addQuarters(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = addQuarters(Date.now(), 2);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = addQuarters(new UTCDate(), 2);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        addQuarters(\"2023-03-31T00:00:00Z\", 1, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2023-06-30T20:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2023-09-01T00:00:00Z\");\n+      const result = addQuarters(date, 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/addSeconds/test.ts b/src/addSeconds/test.ts\nindex 095fff5de5..b7960cba8d 100644\n--- a/src/addSeconds/test.ts\n+++ b/src/addSeconds/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { addSeconds } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n \n describe(\"addSeconds\", () => {\n   it(\"adds the given number of seconds\", () => {\n@@ -30,4 +33,34 @@ describe(\"addSeconds\", () => {\n     const result = addSeconds(new Date(2014, 6 /* Jul */, 10, 12, 45, 0), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = addSeconds(Date.now(), 30);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = addSeconds(new UTCDate(), 15);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context and handles timezones correctly\", () => {\n+      expect(\n+        addSeconds(new Date(\"2024-08-18T15:00:00Z\"), 18000, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toEqual(\"2024-08-19T04:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = addSeconds(\"2024-08-18T15:00:00Z\", 30, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/addWeeks/test.ts b/src/addWeeks/test.ts\nindex bb3099378e..ece0813d41 100644\n--- a/src/addWeeks/test.ts\n+++ b/src/addWeeks/test.ts\n@@ -1,5 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n import { addWeeks } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n \n describe(\"addWeeks\", () => {\n   it(\"adds the given number of weeks\", () => {\n@@ -27,4 +29,27 @@ describe(\"addWeeks\", () => {\n     const result = addWeeks(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        addWeeks(\"2024-04-01T15:00:00Z\", 1, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-08T23:00:00.000+08:00\");\n+      expect(\n+        addWeeks(\"2024-04-01T16:00:00Z\", 1, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-09T00:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = addWeeks(new Date(\"2014-09-01T00:00:00Z\"), 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/addYears/test.ts b/src/addYears/test.ts\nindex 2950757b67..901d8e1c89 100644\n--- a/src/addYears/test.ts\n+++ b/src/addYears/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { addYears } from \"./index.js\";\n \n describe(\"addYears\", () => {\n@@ -43,4 +46,34 @@ describe(\"addYears\", () => {\n     const result = addYears(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = addYears(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = addYears(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows specifying the context\", () => {\n+      expect(\n+        addYears(\"2024-04-10T07:00:00Z\", 5, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2029-04-10T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = addYears(\"2014-09-01T00:00:00Z\", 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/areIntervalsOverlapping/test.ts b/src/areIntervalsOverlapping/test.ts\nindex 33e30b5306..0254be7847 100644\n--- a/src/areIntervalsOverlapping/test.ts\n+++ b/src/areIntervalsOverlapping/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import type { DateFns, Interval } from \"../types.js\";\n import { areIntervalsOverlapping } from \"./index.js\";\n \n describe(\"areIntervalsOverlapping\", () => {\n@@ -14,7 +16,7 @@ describe(\"areIntervalsOverlapping\", () => {\n         { start: initialIntervalStart, end: initialIntervalEnd },\n         { start: earlierIntervalStart, end: earlierIntervalEnd },\n       );\n-      expect(!isOverlapping).toBe(true);\n+      expect(isOverlapping).toBe(false);\n     });\n \n     it(\"returns false for a valid non overlapping interval after another interval\", () => {\n@@ -25,7 +27,7 @@ describe(\"areIntervalsOverlapping\", () => {\n         { start: initialIntervalStart, end: initialIntervalEnd },\n         { start: laterIntervalStart, end: laterIntervalEnd },\n       );\n-      expect(!isOverlapping).toBe(true);\n+      expect(isOverlapping).toBe(false);\n     });\n \n     it(\"returns false for a non overlapping same-day interval\", () => {\n@@ -36,24 +38,10 @@ describe(\"areIntervalsOverlapping\", () => {\n         { start: initialIntervalStart, end: initialIntervalEnd },\n         { start: sameDayIntervalStart, end: sameDayIntervalEnd },\n       );\n-      expect(!isOverlapping).toBe(true);\n+      expect(isOverlapping).toBe(false);\n     });\n \n-    it(\"returns false for an interval differing by a few hours\", () => {\n-      const oneDayOverlappingIntervalStart = new Date(2016, 11, 3, 18, 0, 0);\n-      const oneDayOverlappingIntervalEnd = new Date(2016, 11, 14, 13, 0, 0);\n-\n-      const isOverlapping = areIntervalsOverlapping(\n-        { start: initialIntervalStart, end: initialIntervalEnd },\n-        {\n-          start: oneDayOverlappingIntervalStart,\n-          end: oneDayOverlappingIntervalEnd,\n-        },\n-      );\n-      expect(!isOverlapping).toBe(true);\n-    });\n-\n-    it(\"returns false for an interval with the same startDateTime as the initial time intervals's endDateTime\", () => {\n+    it(\"returns false for an interval with the same startDateTime as the initial time interval's endDateTime\", () => {\n       const oneDayOverlapIntervalStart = new Date(2016, 11, 3, 15, 0, 0);\n       const oneDayOverlapIntervalEnd = new Date(2016, 11, 14, 13, 0, 0);\n \n@@ -61,7 +49,7 @@ describe(\"areIntervalsOverlapping\", () => {\n         { start: initialIntervalStart, end: initialIntervalEnd },\n         { start: oneDayOverlapIntervalStart, end: oneDayOverlapIntervalEnd },\n       );\n-      expect(!isOverlapping).toBe(true);\n+      expect(isOverlapping).toBe(false);\n     });\n \n     it(\"returns false for an interval with the same endDateTime as the initial time interval's startDateTime\", () => {\n@@ -72,7 +60,7 @@ describe(\"areIntervalsOverlapping\", () => {\n         { start: initialIntervalStart, end: initialIntervalEnd },\n         { start: oneDayOverlapIntervalStart, end: oneDayOverlapIntervalEnd },\n       );\n-      expect(!isOverlapping).toBe(true);\n+      expect(isOverlapping).toBe(false);\n     });\n   });\n \n@@ -169,29 +157,37 @@ describe(\"areIntervalsOverlapping\", () => {\n     expect(isOverlapping).toBe(true);\n   });\n \n-  describe(\"when the inclusive option is true\", () => {\n-    it(\"returns true for an interval with the same startDateTime as the initial time interval's endDateTime\", () => {\n-      const oneDayOverlapIntervalStart = new Date(2016, 11, 3, 15, 0, 0);\n-      const oneDayOverlapIntervalEnd = new Date(2016, 11, 14, 13, 0, 0);\n-\n-      const isOverlapping = areIntervalsOverlapping(\n-        { start: initialIntervalStart, end: initialIntervalEnd },\n-        { start: oneDayOverlapIntervalStart, end: oneDayOverlapIntervalEnd },\n-        { inclusive: true },\n-      );\n-      expect(isOverlapping).toBe(true);\n-    });\n-\n-    it(\"returns true for an interval with the same endDateTime as the initial time interval's startDateTime\", () => {\n-      const oneDayOverlapIntervalStart = new Date(2016, 10, 3, 15, 0, 0);\n-      const oneDayOverlapIntervalEnd = new Date(2016, 10, 10, 13, 0, 0);\n-\n-      const isOverlapping = areIntervalsOverlapping(\n-        { start: initialIntervalStart, end: initialIntervalEnd },\n-        { start: oneDayOverlapIntervalStart, end: oneDayOverlapIntervalEnd },\n-        { inclusive: true },\n-      );\n-      expect(isOverlapping).toBe(true);\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        areIntervalsOverlapping(\n+          { start: \"2024-04-10T07:00:00Z\", end: \"2024-04-14T07:00:00Z\" },\n+          { start: \"2024-04-14T07:00:00Z\", end: \"2024-04-16T07:00:00Z\" },\n+          {\n+            in: tz(\"America/Los_Angeles\"),\n+            inclusive: true,\n+          },\n+        ),\n+      ).toBe(true);\n+      expect(\n+        areIntervalsOverlapping(\n+          { start: \"2024-04-10T07:00:00Z\", end: \"2024-04-10T15:00:00Z\" },\n+          { start: \"2024-04-10T16:00:00Z\", end: \"2024-04-11T07:00:00Z\" },\n+          {\n+            in: tz(\"America/Los_Angeles\"),\n+          },\n+        ),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: Interval<DateType>,\n+        arg2: Interval<DateType>,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        areIntervalsOverlapping(arg1, arg2, { in: options?.in });\n+      }\n     });\n   });\n \n@@ -201,7 +197,7 @@ describe(\"areIntervalsOverlapping\", () => {\n         { start: new Date(NaN), end: new Date(2016, 10, 3) },\n         { start: new Date(2016, 10, 5), end: new Date(2016, 10, 15) },\n       );\n-      expect(!result).toBe(true);\n+      expect(result).toBe(false);\n     });\n \n     it(\"returns false if the end date of the initial time interval is `Invalid Date`\", () => {\n@@ -209,7 +205,7 @@ describe(\"areIntervalsOverlapping\", () => {\n         { start: new Date(2016, 10, 3), end: new Date(NaN) },\n         { start: new Date(2016, 10, 5), end: new Date(2016, 10, 15) },\n       );\n-      expect(!result).toBe(true);\n+      expect(result).toBe(false);\n     });\n \n     it(\"returns false if the start date of the compared time interval is `Invalid Date`\", () => {\n@@ -217,7 +213,7 @@ describe(\"areIntervalsOverlapping\", () => {\n         { start: new Date(2016, 10, 3), end: new Date(2016, 10, 7) },\n         { start: new Date(NaN), end: new Date(2016, 10, 5) },\n       );\n-      expect(!result).toBe(true);\n+      expect(result).toBe(false);\n     });\n \n     it(\"returns false if the end date of the compared time interval is `Invalid Date`\", () => {\n@@ -225,7 +221,7 @@ describe(\"areIntervalsOverlapping\", () => {\n         { start: new Date(2016, 10, 3), end: new Date(2016, 10, 7) },\n         { start: new Date(2016, 10, 5), end: new Date(NaN) },\n       );\n-      expect(!result).toBe(true);\n+      expect(result).toBe(false);\n     });\n   });\n });\ndiff --git a/src/clamp/test.ts b/src/clamp/test.ts\nindex 72a1852b54..61237d883c 100644\n--- a/src/clamp/test.ts\n+++ b/src/clamp/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { clamp } from \"./index.js\";\n \n describe(\"clamp\", () => {\n@@ -33,4 +36,76 @@ describe(\"clamp\", () => {\n     const result = clamp(date, { start, end });\n     expect(result).toEqual(new Date(2001, 1, 1));\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = clamp(Date.now(), {\n+      start: Date.now() - 1000,\n+      end: Date.now() + 1000,\n+    });\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = clamp(new UTCDate(), {\n+      start: Date.now(),\n+      end: Date.now(),\n+    });\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the first argument date object type\", () => {\n+    const argResult = clamp(new UTCDate(), {\n+      start: new TZDate(),\n+      end: new UTCDate(),\n+    });\n+    expect(argResult).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof argResult>>(true);\n+\n+    const startResult = clamp(Date.now(), {\n+      start: new TZDate(),\n+      end: new UTCDate(),\n+    });\n+    expect(startResult).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate, typeof startResult>>(true);\n+\n+    const endResult = clamp(Date.now(), {\n+      start: Date.now(),\n+      end: new UTCDate(),\n+    });\n+    expect(endResult).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof endResult>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const interval = {\n+        start: \"2024-04-10T07:00:00Z\",\n+        end: \"2024-04-12T07:00:00Z\",\n+      };\n+      expect(\n+        clamp(\"2024-04-11T07:00:00Z\", interval, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-11T00:00:00.000-07:00\");\n+      expect(\n+        clamp(\"2024-04-11T07:00:00Z\", interval, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-11T15:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const interval = {\n+        start: new Date(\"2014-09-01T00:00:00Z\"),\n+        end: new Date(\"2014-09-05T00:00:00Z\"),\n+      };\n+      const result = clamp(interval.start, interval, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/closestTo/test.ts b/src/closestTo/test.ts\nindex e3930d0f0c..36e428a580 100644\n--- a/src/closestTo/test.ts\n+++ b/src/closestTo/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { closestTo } from \"./index.js\";\n \n describe(\"closestTo\", () => {\n@@ -56,4 +59,50 @@ describe(\"closestTo\", () => {\n \n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = closestTo(Date.now(), [Date.now(), Date.now()]);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date | undefined, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument object type\", () => {\n+    const result = closestTo(new UTCDate(), [new TZDate(), Date.now()]);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate | undefined, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the first date object type in the array\", () => {\n+    const result = closestTo(Date.now(), [\n+      \"2024-01-01T00:00:00Z\",\n+      new UTCDate(),\n+    ]);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate | undefined, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the date union when the array contains more than single date object\", () => {\n+    const result = closestTo(Date.now(), [\n+      new Date(),\n+      Date.now(),\n+      \"2024-01-01T00:00:00Z\",\n+      new UTCDate(),\n+    ]);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<UTCDate | Date | undefined, typeof result>>(\n+      true,\n+    );\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"resolves the context date type\", () => {\n+      const result = closestTo(\n+        new Date(\"2014-09-01T00:00:00Z\"),\n+        [new UTCDate()],\n+        { in: tz(\"Asia/Tokyo\") },\n+      );\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate | undefined, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/constructFrom/test.ts b/src/constructFrom/test.ts\nindex 04f5da6af7..5415fe9a81 100644\n--- a/src/constructFrom/test.ts\n+++ b/src/constructFrom/test.ts\n@@ -1,5 +1,9 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n import { constructFrom } from \".\";\n+import { assertType } from \"../_lib/test\";\n+import { type DateFns } from \"../types\";\n \n describe(\"constructFrom\", () => {\n   it(\"should create a new Date instance using the constructor from the reference date\", () => {\n@@ -44,4 +48,45 @@ describe(\"constructFrom\", () => {\n     expect(result instanceof Date).toBe(true);\n     expect(result.getTime()).toEqual(value);\n   });\n+\n+  it(\"allows to pass undefined\", () => {\n+    const value = 1635244800000; // October 26, 2023\n+    const result = constructFrom(undefined, value);\n+    expect(result instanceof Date).toBe(true);\n+    expect(result.getTime()).toEqual(value);\n+  });\n+\n+  it(\"allows to pass a context function as the reference date\", () => {\n+    const value = 1635244800000; // October 26, 2023\n+    const result = constructFrom(tz(\"Asia/Singapore\"), value);\n+    expect(result instanceof TZDate).toBe(true);\n+    expect(result.getTime()).toEqual(value);\n+  });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = constructFrom(Date.now(), Date.now());\n+    expect(result instanceof Date).toBe(true);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = constructFrom(new UTCDate(), Date.now());\n+    expect(result instanceof UTCDate).toBe(true);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the context type if it is passed as the argument\", () => {\n+    const result = constructFrom(tz(\"Asia/Singapore\"), Date.now());\n+    expect(result instanceof TZDate).toBe(true);\n+    assertType<assertType.Equal<TZDate, typeof result>>(true);\n+  });\n+\n+  it(\"doesn't enforce argument and context to be of the same type\", () => {\n+    function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+      arg: DateType | number | string,\n+      options?: DateFns.ContextOptions<ResultDate>,\n+    ) {\n+      constructFrom(options?.in || arg, arg);\n+    }\n+  });\n });\ndiff --git a/src/constructNow/test.ts b/src/constructNow/test.ts\nindex d335e3b364..9237ce8fb4 100644\n--- a/src/constructNow/test.ts\n+++ b/src/constructNow/test.ts\n@@ -1,5 +1,8 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n import { constructNow } from \".\";\n+import { assertType } from \"../_lib/test\";\n \n describe(\"constructNow\", () => {\n   it(\"creates a new Date instance using the constructor from the reference date\", () => {\n@@ -34,4 +37,27 @@ describe(\"constructNow\", () => {\n     expect(+result - Date.now()).toBeLessThan(10); // Give 10 ms of slack\n     expect(result.constructor).toBe(CustomDate);\n   });\n+\n+  it(\"allows to pass undefined\", () => {\n+    const result = constructNow(undefined);\n+    expect(result instanceof Date).toBe(true);\n+  });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = constructNow(Date.now());\n+    expect(result instanceof Date).toBe(true);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = constructNow(new UTCDate());\n+    expect(result instanceof UTCDate).toBe(true);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the context type if it is passed as the argument\", () => {\n+    const result = constructNow(tz(\"Asia/Singapore\"));\n+    expect(result instanceof TZDate).toBe(true);\n+    assertType<assertType.Equal<TZDate, typeof result>>(true);\n+  });\n });\ndiff --git a/src/differenceInBusinessDays/test.ts b/src/differenceInBusinessDays/test.ts\nindex 81c3859f08..851dc782e8 100644\n--- a/src/differenceInBusinessDays/test.ts\n+++ b/src/differenceInBusinessDays/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInBusinessDays } from \"./index.js\";\n \n describe(\"differenceInBusinessDays\", () => {\n@@ -58,6 +60,51 @@ describe(\"differenceInBusinessDays\", () => {\n     expect(result).toBe(135);\n   });\n \n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2025, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 0, 1, \"America/New_York\");\n+    expect(differenceInBusinessDays(dateLeft, dateRight)).toBe(262);\n+    expect(differenceInBusinessDays(dateRight, dateLeft)).toBe(-261);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInBusinessDays(arg1, arg2);\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInBusinessDays(\n+          \"2024-04-10T02:00:00Z\",\n+          \"2024-04-07T02:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(1);\n+      expect(\n+        differenceInBusinessDays(\n+          \"2024-04-10T02:00:00Z\",\n+          \"2024-04-07T02:00:00Z\",\n+          { in: tz(\"Asia/Singapore\") },\n+        ),\n+      ).toBe(2);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ContextDate extends Date>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ContextDate>,\n+      ) {\n+        differenceInBusinessDays(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n+\n   describe(\"edge cases\", () => {\n     it(\"the difference is less than a day, but the given dates are in different calendar days\", () => {\n       const result = differenceInBusinessDays(\ndiff --git a/src/differenceInCalendarDays/test.ts b/src/differenceInCalendarDays/test.ts\nindex 9f6ccc9d6c..8f9ef41697 100644\n--- a/src/differenceInCalendarDays/test.ts\n+++ b/src/differenceInCalendarDays/test.ts\n@@ -1,6 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import { differenceInCalendarDays } from \"./index.js\";\n import { getDstTransitions } from \"../../test/dst/tzOffsetTransitions.js\";\n+import { differenceInCalendarDays } from \"./index.js\";\n \n describe(\"differenceInCalendarDays\", () => {\n   it(\"returns the number of calendar days between the given dates\", () => {\n@@ -108,9 +109,10 @@ describe(\"differenceInCalendarDays\", () => {\n   // `differenceInDays`\n   const dstTransitions = getDstTransitions(2017);\n   const dstOnly = dstTransitions.start && dstTransitions.end ? it : it.skip;\n-  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || process.env.tz;\n+  const tzName =\n+    Intl.DateTimeFormat().resolvedOptions().timeZone || process.env.tz;\n   dstOnly(\n-    `works across DST start & end in local timezone: ${tz || \"(unknown)\"}`,\n+    `works across DST start & end in local timezone: ${tzName || \"(unknown)\"}`,\n     () => {\n       const { start, end } = dstTransitions;\n       const HOUR = 1000 * 60 * 60;\n@@ -213,4 +215,53 @@ describe(\"differenceInCalendarDays\", () => {\n       }\n     },\n   );\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2025, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 0, 1, \"America/New_York\");\n+    expect(differenceInCalendarDays(dateLeft, dateRight)).toBe(366);\n+    expect(differenceInCalendarDays(dateRight, dateLeft)).toBe(-365);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInCalendarDays(arg1, arg2);\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInCalendarDays(\n+          new Date(\"2014-12-12T00:00:00Z\"),\n+          new Date(\"2014-12-02T04:00:00Z\"),\n+          { in: tz(\"Asia/Singapore\") },\n+        ),\n+      ).toBe(10);\n+      expect(\n+        differenceInCalendarDays(\n+          new Date(\"2014-12-12T00:00:00Z\"),\n+          new Date(\"2014-12-02T05:00:00Z\"),\n+          { in: tz(\"Asia/Singapore\") },\n+        ),\n+      ).toBe(10);\n+      expect(\n+        differenceInCalendarDays(\n+          new Date(\"2014-12-12T00:00:00Z\"),\n+          new Date(\"2014-12-02T04:00:00Z\"),\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(10);\n+      expect(\n+        differenceInCalendarDays(\n+          new Date(\"2014-12-12T00:00:00Z\"),\n+          new Date(\"2014-12-02T05:00:00Z\"),\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(9);\n+    });\n+  });\n });\ndiff --git a/src/differenceInCalendarISOWeekYears/test.ts b/src/differenceInCalendarISOWeekYears/test.ts\nindex 08b40b9842..f8f3886ceb 100644\n--- a/src/differenceInCalendarISOWeekYears/test.ts\n+++ b/src/differenceInCalendarISOWeekYears/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInCalendarISOWeekYears } from \"./index.js\";\n \n describe(\"differenceInCalendarISOWeekYears\", () => {\n@@ -108,4 +110,49 @@ describe(\"differenceInCalendarISOWeekYears\", () => {\n     );\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInCalendarISOWeekYears(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2008, 11, 29, \"America/New_York\");\n+    expect(differenceInCalendarISOWeekYears(dateLeft, dateRight)).toBe(15);\n+    expect(differenceInCalendarISOWeekYears(dateRight, dateLeft)).toBe(-14);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInCalendarISOWeekYears(\n+          \"2024-01-01T00:00:00Z\",\n+          \"2022-12-31T00:00:00Z\",\n+          { in: tz(\"Europe/Paris\") },\n+        ),\n+      ).toBe(2);\n+      expect(\n+        differenceInCalendarISOWeekYears(\n+          \"2024-01-01T00:00:00Z\",\n+          \"2022-12-31T00:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(1);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInCalendarISOWeekYears(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInCalendarISOWeeks/test.ts b/src/differenceInCalendarISOWeeks/test.ts\nindex 4b5bd8c08a..5bf0f05806 100644\n--- a/src/differenceInCalendarISOWeeks/test.ts\n+++ b/src/differenceInCalendarISOWeeks/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInCalendarISOWeeks } from \"./index.js\";\n \n describe(\"differenceInCalendarISOWeeks\", () => {\n@@ -101,4 +103,49 @@ describe(\"differenceInCalendarISOWeeks\", () => {\n     const result = differenceInCalendarISOWeeks(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInCalendarISOWeeks(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 8, 2, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 5, 3, \"America/New_York\");\n+    expect(differenceInCalendarISOWeeks(dateLeft, dateRight)).toBe(13);\n+    expect(differenceInCalendarISOWeeks(dateRight, dateLeft)).toBe(-12);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInCalendarISOWeeks(\n+          \"2024-08-19T03:00:00Z\",\n+          \"2024-08-01T00:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(2);\n+      expect(\n+        differenceInCalendarISOWeeks(\n+          \"2024-08-19T04:00:00Z\",\n+          \"2024-08-01T00:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(3);\n+    });\n+\n+    it(\"context doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInCalendarISOWeeks(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInCalendarMonths/test.ts b/src/differenceInCalendarMonths/test.ts\nindex a94c405392..0a25348ac0 100644\n--- a/src/differenceInCalendarMonths/test.ts\n+++ b/src/differenceInCalendarMonths/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInCalendarMonths } from \"./index.js\";\n \n describe(\"differenceInCalendarMonths\", () => {\n@@ -27,7 +29,7 @@ describe(\"differenceInCalendarMonths\", () => {\n   });\n \n   describe(\"edge cases\", () => {\n-    it(\"the difference is less than a month, but the given dates are in different calendar months\", () => {\n+    it(\"returns 1 when dates are in different months but less than a month apart\", () => {\n       const result = differenceInCalendarMonths(\n         new Date(2014, 8 /* Sep */, 1),\n         new Date(2014, 7 /* Aug */, 31),\n@@ -35,7 +37,7 @@ describe(\"differenceInCalendarMonths\", () => {\n       expect(result).toBe(1);\n     });\n \n-    it(\"the same for the swapped dates\", () => {\n+    it(\"returns -1 for swapped dates with a month difference\", () => {\n       const result = differenceInCalendarMonths(\n         new Date(2014, 7 /* Aug */, 31),\n         new Date(2014, 8 /* Sep */, 1),\n@@ -43,7 +45,7 @@ describe(\"differenceInCalendarMonths\", () => {\n       expect(result).toBe(-1);\n     });\n \n-    it(\"the days of months of the given dates are the same\", () => {\n+    it(\"handles same day of month correctly\", () => {\n       const result = differenceInCalendarMonths(\n         new Date(2014, 8 /* Sep */, 6),\n         new Date(2014, 7 /* Aug */, 6),\n@@ -51,7 +53,7 @@ describe(\"differenceInCalendarMonths\", () => {\n       expect(result).toBe(1);\n     });\n \n-    it(\"the given dates are the same\", () => {\n+    it(\"returns 0 when given the same dates\", () => {\n       const result = differenceInCalendarMonths(\n         new Date(2014, 8 /* Sep */, 5, 0, 0),\n         new Date(2014, 8 /* Sep */, 5, 0, 0),\n@@ -59,7 +61,7 @@ describe(\"differenceInCalendarMonths\", () => {\n       expect(result).toBe(0);\n     });\n \n-    it(\"does not return -0 when the given dates are the same\", () => {\n+    it(\"does not return -0 for the same dates\", () => {\n       function isNegativeZero(x: number): boolean {\n         return x === 0 && 1 / x < 0;\n       }\n@@ -90,8 +92,53 @@ describe(\"differenceInCalendarMonths\", () => {\n     expect(isNaN(result)).toBe(true);\n   });\n \n-  it(\"returns NaN if the both dates are `Invalid Date`\", () => {\n+  it(\"returns NaN if both dates are `Invalid Date`\", () => {\n     const result = differenceInCalendarMonths(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2025, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 0, 1, \"America/New_York\");\n+    expect(differenceInCalendarMonths(dateLeft, dateRight)).toBe(12);\n+    expect(differenceInCalendarMonths(dateRight, dateLeft)).toBe(-11);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInCalendarMonths(arg1, arg2);\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInCalendarMonths(\n+          \"2025-08-31T00:00:00Z\",\n+          \"2025-08-01T03:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(1);\n+      expect(\n+        differenceInCalendarMonths(\n+          \"2025-08-31T00:00:00Z\",\n+          \"2025-08-01T04:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(0);\n+    });\n+\n+    it(\"context doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInCalendarMonths(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInCalendarQuarters/test.ts b/src/differenceInCalendarQuarters/test.ts\nindex ae7b45b4e3..759719470e 100644\n--- a/src/differenceInCalendarQuarters/test.ts\n+++ b/src/differenceInCalendarQuarters/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInCalendarQuarters } from \"./index.js\";\n \n describe(\"differenceInCalendarQuarters\", () => {\n@@ -94,4 +96,49 @@ describe(\"differenceInCalendarQuarters\", () => {\n     const result = differenceInCalendarQuarters(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInCalendarQuarters(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 3, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2023, 11, 1, \"America/New_York\");\n+    expect(differenceInCalendarQuarters(dateLeft, dateRight)).toBe(2);\n+    expect(differenceInCalendarQuarters(dateRight, dateLeft)).toBe(-1);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInCalendarQuarters(\n+          \"2024-04-01T03:00:00Z\",\n+          \"2024-01-01T00:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(1);\n+      expect(\n+        differenceInCalendarQuarters(\n+          \"2024-04-01T04:00:00Z\",\n+          \"2024-01-01T00:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(2);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInCalendarQuarters(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInCalendarWeeks/test.ts b/src/differenceInCalendarWeeks/test.ts\nindex 59c00294e0..4ea31b07a2 100644\n--- a/src/differenceInCalendarWeeks/test.ts\n+++ b/src/differenceInCalendarWeeks/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInCalendarWeeks } from \"./index.js\";\n \n describe(\"differenceInCalendarWeeks\", () => {\n@@ -32,7 +34,7 @@ describe(\"differenceInCalendarWeeks\", () => {\n     expect(result).toBe(2);\n   });\n \n-  it(\"`options.weekStartsOn` overwrites the first day of the week specified in locale\", () => {\n+  it(\"options.weekStartsOn overwrites the first day of the week specified in locale\", () => {\n     const result = differenceInCalendarWeeks(\n       new Date(2014, 6 /* Jul */, 8, 18, 0),\n       new Date(2014, 5 /* Jun */, 29, 6, 0),\n@@ -148,4 +150,49 @@ describe(\"differenceInCalendarWeeks\", () => {\n     const result = differenceInCalendarWeeks(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInCalendarWeeks(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 6, 7, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 5, 30, \"America/New_York\");\n+    expect(differenceInCalendarWeeks(dateLeft, dateRight)).toBe(1);\n+    expect(differenceInCalendarWeeks(dateRight, dateLeft)).toBe(0);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInCalendarWeeks(\n+          \"2024-08-18T03:00:00Z\",\n+          \"2024-08-01T00:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(2);\n+      expect(\n+        differenceInCalendarWeeks(\n+          \"2024-08-18T04:00:00Z\",\n+          \"2024-08-01T00:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(3);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInCalendarWeeks(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInCalendarYears/test.ts b/src/differenceInCalendarYears/test.ts\nindex 54649e96ea..17c2e4207b 100644\n--- a/src/differenceInCalendarYears/test.ts\n+++ b/src/differenceInCalendarYears/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInCalendarYears } from \"./index.js\";\n \n describe(\"differenceInCalendarYears\", () => {\n@@ -94,4 +96,49 @@ describe(\"differenceInCalendarYears\", () => {\n     const result = differenceInCalendarYears(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2025, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 0, 1, \"America/New_York\");\n+    expect(differenceInCalendarYears(dateLeft, dateRight)).toBe(1);\n+    expect(differenceInCalendarYears(dateRight, dateLeft)).toBe(0);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInCalendarYears(arg1, arg2);\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInCalendarYears(\n+          \"2026-01-01T04:00:00Z\",\n+          \"2024-01-01T00:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(2);\n+      expect(\n+        differenceInCalendarYears(\n+          \"2026-01-01T05:00:00Z\",\n+          \"2024-01-01T00:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(3);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInCalendarYears(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInDays/test.ts b/src/differenceInDays/test.ts\nindex 137cef8e2c..ee25c4efb0 100644\n--- a/src/differenceInDays/test.ts\n+++ b/src/differenceInDays/test.ts\n@@ -1,6 +1,8 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import { differenceInDays } from \"./index.js\";\n import { getDstTransitions } from \"../../test/dst/tzOffsetTransitions.js\";\n+import { type DateFns } from \"../types.js\";\n+import { differenceInDays } from \"./index.js\";\n \n describe(\"differenceInDays\", () => {\n   it(\"returns the number of full days between the given dates\", () => {\n@@ -204,4 +206,45 @@ describe(\"differenceInDays\", () => {\n     const result = differenceInDays(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2025, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 0, 1, \"America/New_York\");\n+    expect(differenceInDays(dateLeft, dateRight)).toBe(365);\n+    expect(differenceInDays(dateRight, dateLeft)).toBe(-365);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInDays(arg1, arg2);\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInDays(\"2024-01-08T00:00:00Z\", \"2024-01-01T00:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(7);\n+      expect(\n+        differenceInDays(\"2024-01-08T00:00:00Z\", \"2024-01-01T00:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(7);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInDays(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInHours/test.ts b/src/differenceInHours/test.ts\nindex cbbb9cc405..d47d1e0e44 100644\n--- a/src/differenceInHours/test.ts\n+++ b/src/differenceInHours/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInHours } from \"./index.js\";\n \n describe(\"differenceInHours\", () => {\n@@ -146,4 +148,45 @@ describe(\"differenceInHours\", () => {\n     const result = differenceInHours(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInHours(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 5, 7, 8, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 5, 6, 4, \"America/New_York\");\n+    expect(differenceInHours(dateLeft, dateRight)).toBe(16);\n+    expect(differenceInHours(dateRight, dateLeft)).toBe(-16);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInHours(\"2024-08-18T03:00:00Z\", \"2024-08-01T00:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(411);\n+      expect(\n+        differenceInHours(\"2024-08-18T03:00:00Z\", \"2024-08-01T00:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(411);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInHours(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInISOWeekYears/test.ts b/src/differenceInISOWeekYears/test.ts\nindex 854a78cb56..1af19eb4ea 100644\n--- a/src/differenceInISOWeekYears/test.ts\n+++ b/src/differenceInISOWeekYears/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInISOWeekYears } from \"./index.js\";\n \n describe(\"differenceInISOWeekYears\", () => {\n@@ -105,4 +107,49 @@ describe(\"differenceInISOWeekYears\", () => {\n     const result = differenceInISOWeekYears(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInISOWeekYears(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2008, 11, 29, \"America/New_York\");\n+    expect(differenceInISOWeekYears(dateLeft, dateRight)).toBe(14);\n+    expect(differenceInISOWeekYears(dateRight, dateLeft)).toBe(-14);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInISOWeekYears(\n+          \"2024-01-01T00:00:00Z\",\n+          \"2022-01-02T05:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(2);\n+      expect(\n+        differenceInISOWeekYears(\n+          \"2024-01-01T00:00:00Z\",\n+          \"2022-01-02T06:00:00Z\",\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toBe(1);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInISOWeekYears(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInMonths/test.ts b/src/differenceInMonths/test.ts\nindex 7a066e4092..eff73b6d88 100644\n--- a/src/differenceInMonths/test.ts\n+++ b/src/differenceInMonths/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInMonths } from \"./index.js\";\n \n describe(\"differenceInMonths\", () => {\n@@ -138,34 +140,49 @@ describe(\"differenceInMonths\", () => {\n     expect(isNaN(result)).toBe(true);\n   });\n \n-  it(\"returns NaN if the both dates are `Invalid Date`\", () => {\n+  it(\"returns NaN if both dates are `Invalid Date`\", () => {\n     const result = differenceInMonths(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n \n-  describe(\"edge cases\", () => {\n-    it(\"returns the number of full months between the given dates - end of Feb\", () => {\n-      expect(differenceInMonths(\n-        new Date(2012, 1 /* Feb */, 29, 9, 0, 0),\n-        new Date(2012, 1 /* Feb */, 29, 10, 0, 0),\n-      )).toBe(0);\n-      expect(differenceInMonths(\n-        new Date(2012, 1 /* Feb */, 28, 9, 0, 0),\n-        new Date(2012, 1 /* Feb */, 29, 10, 0, 0),\n-      )).toBe(0);\n-      expect(differenceInMonths(\n-        new Date(2012, 1 /* Feb */, 27, 9, 0, 0),\n-        new Date(2012, 1 /* Feb */, 27, 10, 0, 0),\n-      )).toBe(0);\n-      expect(differenceInMonths(\n-        new Date(2012, 1 /* Feb */, 28, 9, 0, 0),\n-        new Date(2012, 1 /* Feb */, 28, 10, 0, 0),\n-      )).toBe(0);\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2025, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 0, 1, \"America/New_York\");\n+    expect(differenceInMonths(dateLeft, dateRight)).toBe(11);\n+    expect(differenceInMonths(dateRight, dateLeft)).toBe(-11);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInMonths(arg1, arg2);\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInMonths(\"2024-03-01T00:00:00Z\", \"2024-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(1);\n+      expect(\n+        differenceInMonths(\"2024-03-01T00:00:00Z\", \"2024-01-01T00:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(2);\n     });\n \n-    expect(differenceInMonths(\n-      new Date(2021, 1 /* Feb */, 28, 7, 23, 7),\n-      new Date(2021, 1 /* Feb */, 28, 7, 38, 18),\n-    )).toBe(0);\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ContextDate extends Date>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ContextDate>,\n+      ) {\n+        differenceInMonths(arg1, arg2, { in: options?.in });\n+      }\n+    });\n   });\n });\ndiff --git a/src/differenceInQuarters/test.ts b/src/differenceInQuarters/test.ts\nindex d83be746e8..2b9e79594d 100644\n--- a/src/differenceInQuarters/test.ts\n+++ b/src/differenceInQuarters/test.ts\n@@ -1,8 +1,10 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n import { differenceInQuarters } from \"./index.js\";\n+import { type DateFns } from \"../types.js\";\n \n describe(\"differenceInQuarters\", () => {\n-  it(\"returns the number of full quarters between the given dates  with `trunc` as a default rounding method\", () => {\n+  it(\"returns the number of full quarters between the given dates with `trunc` as a default rounding method\", () => {\n     const result = differenceInQuarters(\n       new Date(2012, 6 /* Jul */, 2, 5, 0),\n       new Date(2011, 6 /* Jul */, 2, 6, 0),\n@@ -141,8 +143,47 @@ describe(\"differenceInQuarters\", () => {\n     expect(isNaN(result)).toBe(true);\n   });\n \n-  it(\"returns NaN if the both dates are `Invalid Date`\", () => {\n+  it(\"returns NaN if both dates are `Invalid Date`\", () => {\n     const result = differenceInQuarters(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInQuarters(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2022, 3, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2021, 11, 31, \"America/New_York\");\n+    expect(differenceInQuarters(dateLeft, dateRight)).toBe(1);\n+    expect(differenceInQuarters(dateRight, dateLeft)).toBe(-1);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const result = differenceInQuarters(\n+        \"2024-01-10T07:00:00Z\",\n+        \"2023-01-10T07:00:00Z\",\n+        {\n+          in: tz(\"America/Los_Angeles\"),\n+        },\n+      );\n+      expect(result).toBe(4);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInQuarters(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInWeeks/test.ts b/src/differenceInWeeks/test.ts\nindex 74a49ce899..a094d9d126 100644\n--- a/src/differenceInWeeks/test.ts\n+++ b/src/differenceInWeeks/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInWeeks } from \"./index.js\";\n \n describe(\"differenceInWeeks\", () => {\n@@ -146,4 +148,40 @@ describe(\"differenceInWeeks\", () => {\n     const result = differenceInWeeks(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInWeeks(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2025, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 0, 1, \"America/New_York\");\n+    expect(differenceInWeeks(dateLeft, dateRight)).toBe(52);\n+    expect(differenceInWeeks(dateRight, dateLeft)).toBe(-52);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInWeeks(\"2024-01-15T00:00:00Z\", \"2024-01-01T00:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(2);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInWeeks(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/differenceInYears/test.ts b/src/differenceInYears/test.ts\nindex 60786176d2..535d66afb4 100644\n--- a/src/differenceInYears/test.ts\n+++ b/src/differenceInYears/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { differenceInYears } from \"./index.js\";\n \n describe(\"differenceInYears\", () => {\n@@ -136,4 +138,45 @@ describe(\"differenceInYears\", () => {\n     const result = differenceInYears(new Date(NaN), new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2027, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 0, 1, \"America/New_York\");\n+    expect(differenceInYears(dateLeft, dateRight)).toBe(2);\n+    expect(differenceInYears(dateRight, dateLeft)).toBe(-2);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      differenceInYears(arg1, arg2);\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        differenceInYears(\"2025-01-01T00:00:00Z\", \"2024-01-01T00:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(1);\n+      expect(\n+        differenceInYears(\"2025-01-01T00:00:00Z\", \"2024-01-01T00:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(1);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        differenceInYears(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/eachDayOfInterval/test.ts b/src/eachDayOfInterval/test.ts\nindex ebccf93ff5..d5cca05fb8 100644\n--- a/src/eachDayOfInterval/test.ts\n+++ b/src/eachDayOfInterval/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { eachDayOfInterval } from \"./index.js\";\n \n describe(\"eachDayOfInterval\", () => {\n@@ -161,4 +164,97 @@ describe(\"eachDayOfInterval\", () => {\n       expect(result).toEqual([]);\n     });\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = eachDayOfInterval({\n+      start: Date.now(),\n+      end: Date.now(),\n+    });\n+    expect(result[0]).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the start date object type\", () => {\n+    const result = eachDayOfInterval({\n+      start: new TZDate(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the end date object type if the start isn't object\", () => {\n+    const result = eachDayOfInterval({\n+      start: Date.now(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate[], typeof result>>(true);\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2023, 11, 31, 23, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2023, 11, 31, 12, \"America/New_York\");\n+    expect(\n+      eachDayOfInterval({ start: dateLeft, end: dateRight }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2023-12-31T00:00:00.000+08:00\",\n+      \"2024-01-01T00:00:00.000+08:00\",\n+    ]);\n+    expect(\n+      eachDayOfInterval({ start: dateRight, end: dateLeft }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\"2023-12-31T00:00:00.000-05:00\"]);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      eachDayOfInterval({ start, end });\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const interval = {\n+        start: \"2024-04-10T07:00:00Z\",\n+        end: \"2024-04-12T07:00:00Z\",\n+      };\n+      expect(\n+        eachDayOfInterval(interval, { in: tz(\"America/Los_Angeles\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-04-10T00:00:00.000-07:00\",\n+        \"2024-04-11T00:00:00.000-07:00\",\n+        \"2024-04-12T00:00:00.000-07:00\",\n+      ]);\n+      expect(\n+        eachDayOfInterval(interval, { in: tz(\"Asia/Singapore\") }).map((date) =>\n+          date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-04-10T00:00:00.000+08:00\",\n+        \"2024-04-11T00:00:00.000+08:00\",\n+        \"2024-04-12T00:00:00.000+08:00\",\n+      ]);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const interval = {\n+        start: new Date(\"2014-09-01T00:00:00Z\"),\n+        end: new Date(\"2014-09-05T00:00:00Z\"),\n+      };\n+      const result = eachDayOfInterval(interval, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result[0]).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/eachHourOfInterval/test.ts b/src/eachHourOfInterval/test.ts\nindex bd26483922..f001fc2b52 100644\n--- a/src/eachHourOfInterval/test.ts\n+++ b/src/eachHourOfInterval/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { eachHourOfInterval } from \"./index.js\";\n \n describe(\"eachHourOfInterval\", () => {\n@@ -151,4 +154,109 @@ describe(\"eachHourOfInterval\", () => {\n       expect(result).toEqual([]);\n     });\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = eachHourOfInterval({\n+      start: Date.now(),\n+      end: Date.now(),\n+    });\n+    expect(result[0]).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the start date object type\", () => {\n+    const result = eachHourOfInterval({\n+      start: new TZDate(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the end date object type if the start isn't an object\", () => {\n+    const result = eachHourOfInterval({\n+      start: Date.now(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate[], typeof result>>(true);\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 8, 9, 7, \"America/New_York\");\n+    const dateRight = new TZDate(2024, 8, 9, 16, 15, \"Asia/Kolkata\");\n+    expect(\n+      eachHourOfInterval({ start: dateLeft, end: dateRight }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2024-09-09T07:00:00.000-04:00\",\n+      \"2024-09-09T06:00:00.000-04:00\",\n+    ]);\n+    expect(\n+      eachHourOfInterval({ start: dateRight, end: dateLeft }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\"2024-09-09T16:00:00.000+05:30\"]);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      eachHourOfInterval({ start, end });\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const interval = {\n+        start: \"2024-04-10T07:00:00Z\",\n+        end: \"2024-04-10T15:00:00Z\",\n+      };\n+      expect(\n+        eachHourOfInterval(interval, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).map((date) => date.toISOString()),\n+      ).toEqual([\n+        \"2024-04-10T00:00:00.000-07:00\",\n+        \"2024-04-10T01:00:00.000-07:00\",\n+        \"2024-04-10T02:00:00.000-07:00\",\n+        \"2024-04-10T03:00:00.000-07:00\",\n+        \"2024-04-10T04:00:00.000-07:00\",\n+        \"2024-04-10T05:00:00.000-07:00\",\n+        \"2024-04-10T06:00:00.000-07:00\",\n+        \"2024-04-10T07:00:00.000-07:00\",\n+        \"2024-04-10T08:00:00.000-07:00\",\n+      ]);\n+      expect(\n+        eachHourOfInterval(interval, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).map((date) => date.toISOString()),\n+      ).toEqual([\n+        \"2024-04-10T15:00:00.000+08:00\",\n+        \"2024-04-10T16:00:00.000+08:00\",\n+        \"2024-04-10T17:00:00.000+08:00\",\n+        \"2024-04-10T18:00:00.000+08:00\",\n+        \"2024-04-10T19:00:00.000+08:00\",\n+        \"2024-04-10T20:00:00.000+08:00\",\n+        \"2024-04-10T21:00:00.000+08:00\",\n+        \"2024-04-10T22:00:00.000+08:00\",\n+        \"2024-04-10T23:00:00.000+08:00\",\n+      ]);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const interval = {\n+        start: new Date(\"2014-09-01T00:00:00Z\"),\n+        end: new Date(\"2014-09-01T03:00:00Z\"),\n+      };\n+      const result = eachHourOfInterval(interval, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result[0]).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, (typeof result)[0]>>(true);\n+    });\n+  });\n });\ndiff --git a/src/eachMinuteOfInterval/test.ts b/src/eachMinuteOfInterval/test.ts\nindex bed58f56aa..cf27013d03 100644\n--- a/src/eachMinuteOfInterval/test.ts\n+++ b/src/eachMinuteOfInterval/test.ts\n@@ -1,5 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n-\n+import { assertType } from \"../_lib/test/index.js\";\n import { eachMinuteOfInterval } from \"./index.js\";\n \n describe(\"eachMinuteOfInterval\", () => {\n@@ -156,4 +158,113 @@ describe(\"eachMinuteOfInterval\", () => {\n       expect(result).toEqual([]);\n     });\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const interval = {\n+      start: Date.now(),\n+      end: Date.now(),\n+    };\n+    const result = eachMinuteOfInterval(interval);\n+    expect(result[0]).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the start date object type\", () => {\n+    const interval = {\n+      start: new TZDate(\"2024-09-01T00:00:00Z\"),\n+      end: new UTCDate(\"2024-09-01T00:05:00Z\"),\n+    };\n+    const result = eachMinuteOfInterval(interval);\n+    expect(result[0]).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the end date object type if the start isn't object\", () => {\n+    const interval = {\n+      start: Date.now(),\n+      end: new UTCDate(\"2024-09-01T00:00:00Z\"),\n+    };\n+    const result = eachMinuteOfInterval(interval);\n+    expect(result[0]).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate[], typeof result>>(true);\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 8, 9, 6, 40, \"America/New_York\");\n+    const dateRight = new TZDate(2024, 8, 9, 16, 15, \"Asia/Kolkata\");\n+    expect(\n+      eachMinuteOfInterval({ start: dateLeft, end: dateRight }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2024-09-09T06:40:00.000-04:00\",\n+      \"2024-09-09T06:41:00.000-04:00\",\n+      \"2024-09-09T06:42:00.000-04:00\",\n+      \"2024-09-09T06:43:00.000-04:00\",\n+      \"2024-09-09T06:44:00.000-04:00\",\n+      \"2024-09-09T06:45:00.000-04:00\",\n+    ]);\n+    expect(\n+      eachMinuteOfInterval({ start: dateRight, end: dateLeft }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2024-09-09T16:15:00.000+05:30\",\n+      \"2024-09-09T16:14:00.000+05:30\",\n+      \"2024-09-09T16:13:00.000+05:30\",\n+      \"2024-09-09T16:12:00.000+05:30\",\n+      \"2024-09-09T16:11:00.000+05:30\",\n+      \"2024-09-09T16:10:00.000+05:30\",\n+    ]);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      eachMinuteOfInterval({ start, end });\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const interval = {\n+        start: \"2024-04-10T07:00:00Z\",\n+        end: \"2024-04-10T07:03:00Z\",\n+      };\n+      expect(\n+        eachMinuteOfInterval(interval, { in: tz(\"America/Los_Angeles\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-04-10T00:00:00.000-07:00\",\n+        \"2024-04-10T00:01:00.000-07:00\",\n+        \"2024-04-10T00:02:00.000-07:00\",\n+        \"2024-04-10T00:03:00.000-07:00\",\n+      ]);\n+      expect(\n+        eachMinuteOfInterval(interval, { in: tz(\"Asia/Singapore\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-04-10T15:00:00.000+08:00\",\n+        \"2024-04-10T15:01:00.000+08:00\",\n+        \"2024-04-10T15:02:00.000+08:00\",\n+        \"2024-04-10T15:03:00.000+08:00\",\n+      ]);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const interval = {\n+        start: new Date(\"2014-09-01T13:00:00Z\"),\n+        end: new Date(\"2014-09-01T13:02:00Z\"),\n+      };\n+      const result = eachMinuteOfInterval(interval, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result[0]).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/eachMonthOfInterval/test.ts b/src/eachMonthOfInterval/test.ts\nindex 3e92b0c6c5..a00e3eb8cf 100644\n--- a/src/eachMonthOfInterval/test.ts\n+++ b/src/eachMonthOfInterval/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { eachMonthOfInterval } from \"./index.js\";\n \n describe(\"eachMonthOfInterval\", () => {\n@@ -160,4 +163,114 @@ describe(\"eachMonthOfInterval\", () => {\n       expect(result).toEqual([]);\n     });\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = eachMonthOfInterval({\n+      start: Date.now(),\n+      end: Date.now(),\n+    });\n+    expect(result[0]).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the start date object type\", () => {\n+    const result = eachMonthOfInterval({\n+      start: new TZDate(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the end date object type if the start isn't object\", () => {\n+    const result = eachMonthOfInterval({\n+      start: Date.now(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate[], typeof result>>(true);\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 0, 1, 12, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 5, 30, 12, \"America/New_York\");\n+    expect(\n+      eachMonthOfInterval({ start: dateLeft, end: dateRight }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2024-01-01T00:00:00.000+08:00\",\n+      \"2024-02-01T00:00:00.000+08:00\",\n+      \"2024-03-01T00:00:00.000+08:00\",\n+      \"2024-04-01T00:00:00.000+08:00\",\n+      \"2024-05-01T00:00:00.000+08:00\",\n+      \"2024-06-01T00:00:00.000+08:00\",\n+      \"2024-07-01T00:00:00.000+08:00\",\n+    ]);\n+    expect(\n+      eachMonthOfInterval({ start: dateRight, end: dateLeft }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2024-06-01T00:00:00.000-04:00\",\n+      \"2024-05-01T00:00:00.000-04:00\",\n+      \"2024-04-01T00:00:00.000-04:00\",\n+      \"2024-03-01T00:00:00.000-05:00\",\n+      \"2024-02-01T00:00:00.000-05:00\",\n+      \"2024-01-01T00:00:00.000-05:00\",\n+      \"2023-12-01T00:00:00.000-05:00\",\n+    ]);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      eachMonthOfInterval({ start, end });\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const interval = {\n+        start: \"2024-04-10T07:00:00Z\",\n+        end: \"2024-08-12T07:00:00Z\",\n+      };\n+      expect(\n+        eachMonthOfInterval(interval, { in: tz(\"America/Los_Angeles\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-04-01T00:00:00.000-07:00\",\n+        \"2024-05-01T00:00:00.000-07:00\",\n+        \"2024-06-01T00:00:00.000-07:00\",\n+        \"2024-07-01T00:00:00.000-07:00\",\n+        \"2024-08-01T00:00:00.000-07:00\",\n+      ]);\n+      expect(\n+        eachMonthOfInterval(interval, { in: tz(\"Asia/Singapore\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-04-01T00:00:00.000+08:00\",\n+        \"2024-05-01T00:00:00.000+08:00\",\n+        \"2024-06-01T00:00:00.000+08:00\",\n+        \"2024-07-01T00:00:00.000+08:00\",\n+        \"2024-08-01T00:00:00.000+08:00\",\n+      ]);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const interval = {\n+        start: new Date(\"2014-09-01T00:00:00Z\"),\n+        end: new Date(\"2014-09-05T00:00:00Z\"),\n+      };\n+      const result = eachMonthOfInterval(interval, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result[0]).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/eachQuarterOfInterval/test.ts b/src/eachQuarterOfInterval/test.ts\nindex f493909fcb..763ea4b46c 100644\n--- a/src/eachQuarterOfInterval/test.ts\n+++ b/src/eachQuarterOfInterval/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { eachQuarterOfInterval } from \"./index.js\";\n \n describe(\"eachQuarterOfInterval\", () => {\n@@ -102,6 +105,104 @@ describe(\"eachQuarterOfInterval\", () => {\n     expect(result).toEqual([]);\n   });\n \n+  it(\"resolves the date type by default\", () => {\n+    const result = eachQuarterOfInterval({\n+      start: Date.now(),\n+      end: Date.now(),\n+    });\n+    expect(result[0]).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the start date object type\", () => {\n+    const result = eachQuarterOfInterval({\n+      start: new TZDate(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the end date object type if the start isn't object\", () => {\n+    const result = eachQuarterOfInterval({\n+      start: Date.now(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate[], typeof result>>(true);\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 0, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 2, 31, 23, \"America/New_York\");\n+    expect(\n+      eachQuarterOfInterval({ start: dateLeft, end: dateRight }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2024-01-01T00:00:00.000+08:00\",\n+      \"2024-04-01T00:00:00.000+08:00\",\n+    ]);\n+    expect(\n+      eachQuarterOfInterval({ start: dateRight, end: dateLeft }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2024-01-01T00:00:00.000-05:00\",\n+      \"2023-10-01T00:00:00.000-04:00\",\n+    ]);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      eachQuarterOfInterval({ start, end });\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const interval = {\n+        start: \"2024-01-10T07:00:00Z\",\n+        end: \"2024-10-10T07:00:00Z\",\n+      };\n+      expect(\n+        eachQuarterOfInterval(interval, { in: tz(\"America/Los_Angeles\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-01-01T00:00:00.000-08:00\",\n+        \"2024-04-01T00:00:00.000-07:00\",\n+        \"2024-07-01T00:00:00.000-07:00\",\n+        \"2024-10-01T00:00:00.000-07:00\",\n+      ]);\n+      expect(\n+        eachQuarterOfInterval(interval, { in: tz(\"Asia/Singapore\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-01-01T00:00:00.000+08:00\",\n+        \"2024-04-01T00:00:00.000+08:00\",\n+        \"2024-07-01T00:00:00.000+08:00\",\n+        \"2024-10-01T00:00:00.000+08:00\",\n+      ]);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const interval = {\n+        start: new Date(\"2014-01-01T00:00:00Z\"),\n+        end: new Date(\"2014-12-31T23:59:59Z\"),\n+      };\n+      const result = eachQuarterOfInterval(interval, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result[0]).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+    });\n+  });\n+\n   describe(\"options.step\", () => {\n     const interval = {\n       start: new Date(2014, 2 /* Mar */, 6),\ndiff --git a/src/eachWeekOfInterval/test.ts b/src/eachWeekOfInterval/test.ts\nindex 1b7e9f18a7..82e5700850 100644\n--- a/src/eachWeekOfInterval/test.ts\n+++ b/src/eachWeekOfInterval/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { eachWeekOfInterval } from \"./index.js\";\n \n describe(\"eachWeekOfInterval\", () => {\n@@ -131,6 +134,108 @@ describe(\"eachWeekOfInterval\", () => {\n     expect(result).toEqual([]);\n   });\n \n+  it(\"resolves the date type by default\", () => {\n+    const interval = {\n+      start: +new Date(\"2024-01-01T00:00:00Z\"),\n+      end: +new Date(\"2024-12-31T23:59:59Z\"),\n+    };\n+    const result = eachWeekOfInterval(interval);\n+    expect(result[0]).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the start date object type\", () => {\n+    const interval = {\n+      start: new TZDate(2024, 4, 28, 0, \"Asia/Singapore\"),\n+      end: new UTCDate(2024, 4, 28, 0, 0),\n+    };\n+    const result = eachWeekOfInterval(interval);\n+    expect(result[0]).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the end date object type if the start isn't object\", () => {\n+    const result = eachWeekOfInterval({\n+      start: Date.now(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate[], typeof result>>(true);\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2023, 11, 19, 23, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2023, 11, 31, 12, \"America/New_York\");\n+    expect(\n+      eachWeekOfInterval({ start: dateLeft, end: dateRight }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2023-12-17T00:00:00.000+08:00\",\n+      \"2023-12-24T00:00:00.000+08:00\",\n+      \"2023-12-31T00:00:00.000+08:00\",\n+    ]);\n+    expect(\n+      eachWeekOfInterval({ start: dateRight, end: dateLeft }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2023-12-31T00:00:00.000-05:00\",\n+      \"2023-12-24T00:00:00.000-05:00\",\n+      \"2023-12-17T00:00:00.000-05:00\",\n+    ]);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      eachWeekOfInterval({ start, end });\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const interval = {\n+        start: \"2024-04-10T07:00:00Z\",\n+        end: \"2024-04-30T07:00:00Z\",\n+      };\n+      expect(\n+        eachWeekOfInterval(interval, { in: tz(\"America/Los_Angeles\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-04-07T00:00:00.000-07:00\",\n+        \"2024-04-14T00:00:00.000-07:00\",\n+        \"2024-04-21T00:00:00.000-07:00\",\n+        \"2024-04-28T00:00:00.000-07:00\",\n+      ]);\n+      expect(\n+        eachWeekOfInterval(interval, { in: tz(\"Asia/Singapore\") }).map((date) =>\n+          date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-04-07T00:00:00.000+08:00\",\n+        \"2024-04-14T00:00:00.000+08:00\",\n+        \"2024-04-21T00:00:00.000+08:00\",\n+        \"2024-04-28T00:00:00.000+08:00\",\n+      ]);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const interval = {\n+        start: new Date(\"2014-10-06T00:00:00Z\"),\n+        end: new Date(\"2014-11-23T00:00:00Z\"),\n+      };\n+      const result = eachWeekOfInterval(interval, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result[0]).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+    });\n+  });\n+\n   describe(\"options.step\", () => {\n     const interval = {\n       start: new Date(2014, 9 /* Oct */, 6),\ndiff --git a/src/eachWeekendOfInterval/test.ts b/src/eachWeekendOfInterval/test.ts\nindex 742bbfc60f..558a75a481 100644\n--- a/src/eachWeekendOfInterval/test.ts\n+++ b/src/eachWeekendOfInterval/test.ts\n@@ -1,4 +1,8 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { subWeeks } from \"../subWeeks/index.js\";\n import { eachWeekendOfInterval } from \"./index.js\";\n \n describe(\"eachWeekendOfInterval\", () => {\n@@ -64,4 +68,117 @@ describe(\"eachWeekendOfInterval\", () => {\n     });\n     expect(result).toEqual([]);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const interval = {\n+      start: +new Date(\"2024-01-01T00:00:00Z\"),\n+      end: +new Date(\"2024-12-31T23:59:59Z\"),\n+    };\n+    const result = eachWeekendOfInterval(interval);\n+    expect(result[0]).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the start date object type\", () => {\n+    const interval = {\n+      start: new TZDate(2024, 4, 18, 0, \"Asia/Singapore\"),\n+      end: new UTCDate(2024, 4, 28, 0, 0),\n+    };\n+    const result = eachWeekendOfInterval(interval);\n+    expect(result[0]).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the end date object type if the start isn't object\", () => {\n+    const result = eachWeekendOfInterval({\n+      start: +subWeeks(Date.now(), 2),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate[], typeof result>>(true);\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2023, 11, 19, 23, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2023, 11, 31, 12, \"America/New_York\");\n+    expect(\n+      eachWeekendOfInterval({ start: dateLeft, end: dateRight }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2023-12-23T00:00:00.000+08:00\",\n+      \"2023-12-24T00:00:00.000+08:00\",\n+      \"2023-12-30T00:00:00.000+08:00\",\n+      \"2023-12-31T00:00:00.000+08:00\",\n+    ]);\n+    expect(\n+      eachWeekendOfInterval({ start: dateRight, end: dateLeft }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2023-12-31T00:00:00.000-05:00\",\n+      \"2023-12-30T00:00:00.000-05:00\",\n+      \"2023-12-24T00:00:00.000-05:00\",\n+      \"2023-12-23T00:00:00.000-05:00\",\n+    ]);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      eachWeekendOfInterval({ start, end });\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const interval = {\n+        start: \"2024-04-01T00:00:00Z\",\n+        end: \"2024-04-30T23:59:59Z\",\n+      };\n+      expect(\n+        eachWeekendOfInterval(interval, { in: tz(\"America/New_York\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-03-31T00:00:00.000-04:00\",\n+        \"2024-04-06T00:00:00.000-04:00\",\n+        \"2024-04-07T00:00:00.000-04:00\",\n+        \"2024-04-13T00:00:00.000-04:00\",\n+        \"2024-04-14T00:00:00.000-04:00\",\n+        \"2024-04-20T00:00:00.000-04:00\",\n+        \"2024-04-21T00:00:00.000-04:00\",\n+        \"2024-04-27T00:00:00.000-04:00\",\n+        \"2024-04-28T00:00:00.000-04:00\",\n+      ]);\n+      expect(\n+        eachWeekendOfInterval(interval, { in: tz(\"Asia/Singapore\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-04-06T00:00:00.000+08:00\",\n+        \"2024-04-07T00:00:00.000+08:00\",\n+        \"2024-04-13T00:00:00.000+08:00\",\n+        \"2024-04-14T00:00:00.000+08:00\",\n+        \"2024-04-20T00:00:00.000+08:00\",\n+        \"2024-04-21T00:00:00.000+08:00\",\n+        \"2024-04-27T00:00:00.000+08:00\",\n+        \"2024-04-28T00:00:00.000+08:00\",\n+      ]);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const interval = {\n+        start: new Date(\"2024-09-01T00:00:00Z\"),\n+        end: new Date(\"2024-09-30T00:00:00Z\"),\n+      };\n+      const result = eachWeekendOfInterval(interval, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result[0]).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/eachWeekendOfMonth/test.ts b/src/eachWeekendOfMonth/test.ts\nindex c9d4861ebc..79a9254518 100644\n--- a/src/eachWeekendOfMonth/test.ts\n+++ b/src/eachWeekendOfMonth/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { eachWeekendOfMonth } from \"./index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"eachWeekendOfMonth\", () => {\n   it(\"returns all weekends of the given month\", () => {\n@@ -16,8 +19,61 @@ describe(\"eachWeekendOfMonth\", () => {\n     ]);\n   });\n \n-  it(\"returns an empty asrray when the expected year is an Invalid Date\", () => {\n+  it(\"returns an empty array when the expected year is an Invalid Date\", () => {\n     const result = eachWeekendOfMonth(new Date(NaN));\n     expect(result).toEqual([]);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = eachWeekendOfMonth(Date.now());\n+    expect(result[0]).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, (typeof result)[0]>>(true);\n+  });\n+\n+  it(\"resolves the context date type\", () => {\n+    const result = eachWeekendOfMonth(new UTCDate());\n+    expect(result[0]).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, (typeof result)[0]>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        eachWeekendOfMonth(\"2024-04-01T07:00:00Z\", {\n+          in: tz(\"Asia/Tokyo\"),\n+        }).map((date) => date.toISOString()),\n+      ).toEqual([\n+        \"2024-04-06T00:00:00.000+09:00\",\n+        \"2024-04-07T00:00:00.000+09:00\",\n+        \"2024-04-13T00:00:00.000+09:00\",\n+        \"2024-04-14T00:00:00.000+09:00\",\n+        \"2024-04-20T00:00:00.000+09:00\",\n+        \"2024-04-21T00:00:00.000+09:00\",\n+        \"2024-04-27T00:00:00.000+09:00\",\n+        \"2024-04-28T00:00:00.000+09:00\",\n+      ]);\n+      expect(\n+        eachWeekendOfMonth(\"2024-04-01T07:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).map((date) => date.toISOString()),\n+      ).toEqual([\n+        \"2024-04-06T00:00:00.000-04:00\",\n+        \"2024-04-07T00:00:00.000-04:00\",\n+        \"2024-04-13T00:00:00.000-04:00\",\n+        \"2024-04-14T00:00:00.000-04:00\",\n+        \"2024-04-20T00:00:00.000-04:00\",\n+        \"2024-04-21T00:00:00.000-04:00\",\n+        \"2024-04-27T00:00:00.000-04:00\",\n+        \"2024-04-28T00:00:00.000-04:00\",\n+      ]);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = eachWeekendOfMonth(new Date(\"2024-04-01T00:00:00Z\"), {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result[0]).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, (typeof result)[0]>>(true);\n+    });\n+  });\n });\ndiff --git a/src/eachWeekendOfYear/test.ts b/src/eachWeekendOfYear/test.ts\nindex e46598de1a..bc93285798 100644\n--- a/src/eachWeekendOfYear/test.ts\n+++ b/src/eachWeekendOfYear/test.ts\n@@ -1,18 +1,76 @@\n import { describe, expect, it } from \"vitest\";\n import { eachWeekendOfYear } from \"./index.js\";\n import { isWeekend } from \"../isWeekend/index.js\";\n+import { tz, TZDate } from \"@date-fns/tz\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"eachWeekendOfYear\", () => {\n   it(\"returns all weekends of the given year\", () => {\n     const result = eachWeekendOfYear(new Date(2020, 0, 1));\n     expect(result.length).toBe(104);\n-    expect(result.every(isWeekend)).toBe(true);\n+    expect(result.every((date) => isWeekend(date))).toBe(true);\n     expect(result[0]).toEqual(new Date(2020, 0, 4));\n     expect(result[103]).toEqual(new Date(2020, 11, 27));\n   });\n \n-  it(\"returns an empty asrray when the expected year is an Invalid Date\", () => {\n+  it(\"returns an empty array when the given date is `Invalid Date`\", () => {\n     const result = eachWeekendOfYear(new Date(NaN));\n     expect(result).toEqual([]);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = eachWeekendOfYear(Date.now());\n+    expect(result[0]).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, (typeof result)[0]>>(true);\n+  });\n+\n+  it(\"resolves the context date type\", () => {\n+    const result = eachWeekendOfYear(new UTCDate());\n+    expect(result[0]).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, (typeof result)[0]>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        eachWeekendOfYear(\"2024-04-01T07:00:00Z\", {\n+          in: tz(\"Asia/Tokyo\"),\n+        })\n+          .slice(0, 7)\n+          .map((date) => date.toISOString()),\n+      ).toEqual([\n+        \"2024-01-06T00:00:00.000+09:00\",\n+        \"2024-01-07T00:00:00.000+09:00\",\n+        \"2024-01-13T00:00:00.000+09:00\",\n+        \"2024-01-14T00:00:00.000+09:00\",\n+        \"2024-01-20T00:00:00.000+09:00\",\n+        \"2024-01-21T00:00:00.000+09:00\",\n+        \"2024-01-27T00:00:00.000+09:00\",\n+      ]);\n+      expect(\n+        eachWeekendOfYear(\"2024-04-01T07:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        })\n+          .slice(0, 7)\n+          .map((date) => date.toISOString()),\n+      ).toEqual([\n+        \"2024-01-06T00:00:00.000-05:00\",\n+        \"2024-01-07T00:00:00.000-05:00\",\n+        \"2024-01-13T00:00:00.000-05:00\",\n+        \"2024-01-14T00:00:00.000-05:00\",\n+        \"2024-01-20T00:00:00.000-05:00\",\n+        \"2024-01-21T00:00:00.000-05:00\",\n+        \"2024-01-27T00:00:00.000-05:00\",\n+      ]);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = eachWeekendOfYear(new Date(\"2024-01-01T00:00:00Z\"), {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result[0]).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/eachYearOfInterval/test.ts b/src/eachYearOfInterval/test.ts\nindex 1a4dae6d67..9dde24b236 100644\n--- a/src/eachYearOfInterval/test.ts\n+++ b/src/eachYearOfInterval/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { eachYearOfInterval } from \"./index.js\";\n \n describe(\"eachYearOfInterval\", () => {\n@@ -145,4 +148,107 @@ describe(\"eachYearOfInterval\", () => {\n       expect(result).toEqual([]);\n     });\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = eachYearOfInterval({\n+      start: Date.now(),\n+      end: Date.now(),\n+    });\n+    expect(result[0]).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the start date object type\", () => {\n+    const result = eachYearOfInterval({\n+      start: new TZDate(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+  });\n+\n+  it(\"resolves the end date object type if the start isn't object\", () => {\n+    const result = eachYearOfInterval({\n+      start: Date.now(),\n+      end: new UTCDate(),\n+    });\n+    expect(result[0]).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate[], typeof result>>(true);\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 0, 1, 0, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2027, 0, 1, 0, \"America/New_York\");\n+    expect(\n+      eachYearOfInterval({ start: dateLeft, end: dateRight }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2024-01-01T00:00:00.000+08:00\",\n+      \"2025-01-01T00:00:00.000+08:00\",\n+      \"2026-01-01T00:00:00.000+08:00\",\n+      \"2027-01-01T00:00:00.000+08:00\",\n+    ]);\n+    expect(\n+      eachYearOfInterval({ start: dateRight, end: dateLeft }).map((d) =>\n+        d.toISOString(),\n+      ),\n+    ).toEqual([\n+      \"2027-01-01T00:00:00.000-05:00\",\n+      \"2026-01-01T00:00:00.000-05:00\",\n+      \"2025-01-01T00:00:00.000-05:00\",\n+      \"2024-01-01T00:00:00.000-05:00\",\n+      \"2023-01-01T00:00:00.000-05:00\",\n+    ]);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      eachYearOfInterval({ start, end });\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const interval = {\n+        start: \"2024-04-10T07:00:00Z\",\n+        end: \"2027-04-10T07:00:00Z\",\n+      };\n+      expect(\n+        eachYearOfInterval(interval, { in: tz(\"America/Los_Angeles\") }).map(\n+          (date) => date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-01-01T00:00:00.000-08:00\",\n+        \"2025-01-01T00:00:00.000-08:00\",\n+        \"2026-01-01T00:00:00.000-08:00\",\n+        \"2027-01-01T00:00:00.000-08:00\",\n+      ]);\n+      expect(\n+        eachYearOfInterval(interval, { in: tz(\"Asia/Singapore\") }).map((date) =>\n+          date.toISOString(),\n+        ),\n+      ).toEqual([\n+        \"2024-01-01T00:00:00.000+08:00\",\n+        \"2025-01-01T00:00:00.000+08:00\",\n+        \"2026-01-01T00:00:00.000+08:00\",\n+        \"2027-01-01T00:00:00.000+08:00\",\n+      ]);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const interval = {\n+        start: new Date(\"2024-04-10T07:00:00Z\"),\n+        end: new Date(\"2027-04-10T07:00:00Z\"),\n+      };\n+      const result = eachYearOfInterval(interval, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result[0]).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate[], typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfDay/test.ts b/src/endOfDay/test.ts\nindex f9b39d3d67..fffce59790 100644\n--- a/src/endOfDay/test.ts\n+++ b/src/endOfDay/test.ts\n@@ -1,5 +1,8 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n import { endOfDay } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"endOfDay\", () => {\n   it(\"returns the date with the time set to 23:59:59.999\", () => {\n@@ -24,4 +27,40 @@ describe(\"endOfDay\", () => {\n     const result = endOfDay(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfDay(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfDay(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        endOfDay(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T23:59:59.999+08:00\");\n+      expect(\n+        endOfDay(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T23:59:59.999-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = endOfDay(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfDecade/test.ts b/src/endOfDecade/test.ts\nindex b2ec401021..7df2a71657 100644\n--- a/src/endOfDecade/test.ts\n+++ b/src/endOfDecade/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { endOfDecade } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n \n describe(\"endOfDecade\", () => {\n   it(\"returns the date with the time set to 23:59:59.999 and the date set to the last millisecond of a decade\", () => {\n@@ -33,4 +36,40 @@ describe(\"endOfDecade\", () => {\n       new Date(-2001, 11, 31, 23, 59, 59, 999),\n     );\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfDecade(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfDecade(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        endOfDecade(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2029-12-31T23:59:59.999+08:00\");\n+      expect(\n+        endOfDecade(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2029-12-31T23:59:59.999-08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = endOfDecade(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfHour/test.ts b/src/endOfHour/test.ts\nindex d97d0c5bdc..ad238a2226 100644\n--- a/src/endOfHour/test.ts\n+++ b/src/endOfHour/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { endOfHour } from \"./index.js\";\n \n describe(\"endOfHour\", () => {\n@@ -23,4 +26,40 @@ describe(\"endOfHour\", () => {\n     const result = endOfHour(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfHour(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfHour(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        endOfHour(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:59:59.999+08:00\");\n+      expect(\n+        endOfHour(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:59:59.999-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2024-04-10T07:00:00Z\");\n+      const result = endOfHour(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfISOWeek/test.ts b/src/endOfISOWeek/test.ts\nindex 1f50cda19b..b7f3814570 100644\n--- a/src/endOfISOWeek/test.ts\n+++ b/src/endOfISOWeek/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { endOfISOWeek } from \"./index.js\";\n \n describe(\"endOfISOWeek\", () => {\n@@ -24,4 +27,40 @@ describe(\"endOfISOWeek\", () => {\n     const result = endOfISOWeek(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfISOWeek(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfISOWeek(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        endOfISOWeek(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-14T23:59:59.999+08:00\");\n+      expect(\n+        endOfISOWeek(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-14T23:59:59.999-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = endOfISOWeek(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfISOWeekYear/test.ts b/src/endOfISOWeekYear/test.ts\nindex de284fd518..b9e4d9c0de 100644\n--- a/src/endOfISOWeekYear/test.ts\n+++ b/src/endOfISOWeekYear/test.ts\n@@ -1,4 +1,7 @@\n+import { tz, TZDate } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { endOfISOWeekYear } from \"./index.js\";\n \n describe(\"endOfISOWeekYear\", () => {\n@@ -35,4 +38,40 @@ describe(\"endOfISOWeekYear\", () => {\n     const result = endOfISOWeekYear(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfISOWeekYear(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfISOWeekYear(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        endOfISOWeekYear(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-12-29T23:59:59.999+08:00\");\n+      expect(\n+        endOfISOWeekYear(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-12-29T23:59:59.999-05:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2023-01-01T00:00:00Z\");\n+      const result = endOfISOWeekYear(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfMinute/test.ts b/src/endOfMinute/test.ts\nindex df19603783..32d668c0c2 100644\n--- a/src/endOfMinute/test.ts\n+++ b/src/endOfMinute/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { endOfMinute } from \"./index.js\";\n \n describe(\"endOfMinute\", () => {\n@@ -23,4 +26,40 @@ describe(\"endOfMinute\", () => {\n     const result = endOfMinute(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfMinute(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfMinute(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        endOfMinute(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:59.999+08:00\");\n+      expect(\n+        endOfMinute(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:59.999-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = endOfMinute(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfMonth/test.ts b/src/endOfMonth/test.ts\nindex 23938da563..aa7ca2d2aa 100644\n--- a/src/endOfMonth/test.ts\n+++ b/src/endOfMonth/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { endOfMonth } from \"./index.js\";\n \n describe(\"endOfMonth\", () => {\n@@ -38,4 +41,40 @@ describe(\"endOfMonth\", () => {\n     const result = endOfMonth(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfMonth(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfMonth(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        endOfMonth(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-30T23:59:59.999+08:00\");\n+      expect(\n+        endOfMonth(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-30T23:59:59.999-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = endOfMonth(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfQuarter/test.ts b/src/endOfQuarter/test.ts\nindex 6784e5292c..f5de346290 100644\n--- a/src/endOfQuarter/test.ts\n+++ b/src/endOfQuarter/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { endOfQuarter } from \"./index.js\";\n \n describe(\"endOfQuarter\", () => {\n@@ -24,4 +27,40 @@ describe(\"endOfQuarter\", () => {\n     const result = endOfQuarter(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfQuarter(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfQuarter(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        endOfQuarter(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-06-30T23:59:59.999+08:00\");\n+      expect(\n+        endOfQuarter(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-06-30T23:59:59.999-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = endOfQuarter(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfSecond/test.ts b/src/endOfSecond/test.ts\nindex 74bd5978d5..d8dbddd27e 100644\n--- a/src/endOfSecond/test.ts\n+++ b/src/endOfSecond/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { endOfSecond } from \"./index.js\";\n \n describe(\"endOfSecond\", () => {\n@@ -23,4 +26,40 @@ describe(\"endOfSecond\", () => {\n     const result = endOfSecond(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfSecond(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfSecond(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        endOfSecond(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.999+08:00\");\n+      expect(\n+        endOfSecond(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:00.999-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = endOfSecond(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfToday/test.ts b/src/endOfToday/test.ts\nindex e91da62fa6..26ff2e09b9 100644\n--- a/src/endOfToday/test.ts\n+++ b/src/endOfToday/test.ts\n@@ -1,21 +1,45 @@\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n-import sinon from \"sinon\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { describe, expect, it } from \"vitest\";\n+import { assertType, fakeDate } from \"../_lib/test/index.js\";\n import { endOfToday } from \"./index.js\";\n \n describe(\"endOfToday\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(\n-      new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500).getTime(),\n-    );\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  const { fakeNow } = fakeDate(\n+    new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500),\n+  );\n \n   it(\"returns the current date with the time settled to 23:59:59.999\", () => {\n     const result = endOfToday();\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 25, 23, 59, 59, 999));\n   });\n+\n+  it(\"resolves the default date type\", () => {\n+    const result = endOfToday();\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2014-09-25T16:00:00Z\"));\n+      expect(\n+        endOfToday({\n+          in: tz(\"Asia/Tokyo\"),\n+        }).toISOString(),\n+      ).toBe(\"2014-09-26T23:59:59.999+09:00\");\n+      expect(\n+        endOfToday({\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2014-09-25T23:59:59.999-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = endOfToday({\n+        in: tz(\"Asia/Singapore\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfTomorrow/test.ts b/src/endOfTomorrow/test.ts\nindex d57cd3be09..7f46c65508 100644\n--- a/src/endOfTomorrow/test.ts\n+++ b/src/endOfTomorrow/test.ts\n@@ -1,31 +1,58 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import sinon from \"sinon\";\n+import { assertType, fakeDate } from \"../_lib/test/index.js\";\n import { endOfTomorrow } from \"./index.js\";\n \n describe(\"endOfTomorrow\", () => {\n-  it(\"returns tomorrow with the time settled to 23:59:59.999\", () => {\n-    const clock = sinon.useFakeTimers(\n-      new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500).getTime(),\n-    );\n+  const { fakeNow } = fakeDate(\n+    new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500),\n+  );\n \n+  it(\"returns tomorrow with the time settled to 23:59:59.999\", () => {\n     const result = endOfTomorrow();\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 26, 23, 59, 59, 999));\n-\n-    clock.restore();\n   });\n \n   it(\"handles dates before 100 AD\", () => {\n     const now = new Date(0);\n     now.setFullYear(14, 8 /* Sep */, 25);\n     now.setHours(14, 30, 45, 500);\n-    const clock = sinon.useFakeTimers(now.getTime());\n+    fakeNow(+now);\n \n     const expectedResult = new Date(0);\n     expectedResult.setFullYear(14, 8 /* Sep */, 26);\n     expectedResult.setHours(23, 59, 59, 999);\n     const result = endOfTomorrow();\n     expect(result).toEqual(expectedResult);\n+  });\n+\n+  it(\"resolves the default date type\", () => {\n+    const result = endOfTomorrow();\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2014-09-25T16:00:00Z\"));\n+      expect(\n+        endOfTomorrow({\n+          in: tz(\"Asia/Tokyo\"),\n+        }).toISOString(),\n+      ).toBe(\"2014-09-27T23:59:59.999+09:00\");\n+      expect(\n+        endOfTomorrow({\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2014-09-26T23:59:59.999-04:00\");\n+    });\n \n-    clock.restore();\n+    it(\"resolves the context date type\", () => {\n+      const result = endOfTomorrow({\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n   });\n });\ndiff --git a/src/endOfWeek/test.ts b/src/endOfWeek/test.ts\nindex 81d7f4dced..6aca0f82c5 100644\n--- a/src/endOfWeek/test.ts\n+++ b/src/endOfWeek/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { endOfWeek } from \"./index.js\";\n \n describe(\"endOfWeek\", () => {\n@@ -60,7 +63,9 @@ describe(\"endOfWeek\", () => {\n       it(\"it returns the end of a week\", () => {\n         const date = new Date(2014, 9 /* Oct */, 8);\n         const result = endOfWeek(date, { weekStartsOn: 3 });\n-        expect(result).toEqual(new Date(2014, 9 /* Oct */, 14, 23, 59, 59, 999));\n+        expect(result).toEqual(\n+          new Date(2014, 9 /* Oct */, 14, 23, 59, 59, 999),\n+        );\n       });\n     });\n \n@@ -68,7 +73,9 @@ describe(\"endOfWeek\", () => {\n       it(\"it returns the end of a week\", () => {\n         const date = new Date(2014, 9 /* Oct */, 10);\n         const result = endOfWeek(date, { weekStartsOn: 3 });\n-        expect(result).toEqual(new Date(2014, 9 /* Oct */, 14, 23, 59, 59, 999));\n+        expect(result).toEqual(\n+          new Date(2014, 9 /* Oct */, 14, 23, 59, 59, 999),\n+        );\n       });\n     });\n \n@@ -83,4 +90,40 @@ describe(\"endOfWeek\", () => {\n     const result = endOfWeek(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfWeek(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfWeek(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        endOfWeek(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-13T23:59:59.999+08:00\");\n+      expect(\n+        endOfWeek(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-13T23:59:59.999-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = endOfWeek(date, {\n+        in: tz(\"America/Los_Angeles\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfYear/test.ts b/src/endOfYear/test.ts\nindex 5ebe674f74..67b9f5d6d1 100644\n--- a/src/endOfYear/test.ts\n+++ b/src/endOfYear/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { endOfYear } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"endOfYear\", () => {\n   it(\"returns the date with the time set to 23:59:59.999 and the date set to the last day of a year\", () => {\n@@ -24,4 +27,39 @@ describe(\"endOfYear\", () => {\n     const result = endOfYear(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfYear(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = endOfYear(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const result = endOfYear(\"2023-12-31T15:00:00Z\", {\n+        in: tz(\"Asia/Singapore\"),\n+      }).toISOString();\n+      expect(result).toBe(\"2023-12-31T23:59:59.999+08:00\");\n+\n+      const resultLA = endOfYear(\"2023-12-31T15:00:00Z\", {\n+        in: tz(\"America/Los_Angeles\"),\n+      }).toISOString();\n+      expect(resultLA).toBe(\"2023-12-31T23:59:59.999-08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2030-12-31T00:00:00Z\");\n+      const result = endOfYear(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/endOfYesterday/test.ts b/src/endOfYesterday/test.ts\nindex 1aaa358502..97ea09f74a 100644\n--- a/src/endOfYesterday/test.ts\n+++ b/src/endOfYesterday/test.ts\n@@ -1,31 +1,61 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import sinon from \"sinon\";\n+import { assertType, fakeDate } from \"../_lib/test/index.js\";\n import { endOfYesterday } from \"./index.js\";\n \n describe(\"endOfYesterday\", () => {\n-  it(\"returns yesterday with the time settled to 23:59:59.999\", () => {\n-    const clock = sinon.useFakeTimers(\n-      new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500).getTime(),\n-    );\n+  const { fakeNow } = fakeDate(\n+    new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500),\n+  );\n \n+  it(\"returns yesterday with the time settled to 23:59:59.999\", () => {\n     const result = endOfYesterday();\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 24, 23, 59, 59, 999));\n-\n-    clock.restore();\n   });\n \n   it(\"handles dates before 100 AD\", () => {\n     const now = new Date(0);\n     now.setFullYear(14, 8 /* Sep */, 25);\n     now.setHours(14, 30, 45, 500);\n-    const clock = sinon.useFakeTimers(now.getTime());\n+    fakeNow(now);\n \n     const expectedResult = new Date(0);\n     expectedResult.setFullYear(14, 8 /* Sep */, 24);\n     expectedResult.setHours(23, 59, 59, 999);\n     const result = endOfYesterday();\n     expect(result).toEqual(expectedResult);\n+  });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = endOfYesterday();\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2024-08-18T15:00:00Z\"));\n+      expect(endOfYesterday({ in: tz(\"Asia/Singapore\") }).toISOString()).toBe(\n+        \"2024-08-17T23:59:59.999+08:00\",\n+      );\n+      fakeNow(new Date(\"2024-08-18T16:00:00Z\"));\n+      expect(endOfYesterday({ in: tz(\"Asia/Singapore\") }).toISOString()).toBe(\n+        \"2024-08-18T23:59:59.999+08:00\",\n+      );\n+      fakeNow(new Date(\"2024-08-18T03:00:00Z\"));\n+      expect(endOfYesterday({ in: tz(\"America/New_York\") }).toISOString()).toBe(\n+        \"2024-08-16T23:59:59.999-04:00\",\n+      );\n+      fakeNow(new Date(\"2024-08-18T04:00:00Z\"));\n+      expect(endOfYesterday({ in: tz(\"America/New_York\") }).toISOString()).toBe(\n+        \"2024-08-17T23:59:59.999-04:00\",\n+      );\n+    });\n \n-    clock.restore();\n+    it(\"resolves the context date type\", () => {\n+      const result = endOfYesterday({ in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n   });\n });\ndiff --git a/src/formatDistance/test.ts b/src/formatDistance/test.ts\nindex 1a6902eeb9..4868d1c61a 100644\n--- a/src/formatDistance/test.ts\n+++ b/src/formatDistance/test.ts\n@@ -1,3 +1,4 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n import type { FormatDistanceFn } from \"../locale/types.js\";\n import { formatDistance } from \"./index.js\";\n@@ -240,14 +241,51 @@ describe(\"formatDistance\", () => {\n   });\n \n   it(\"throws RangeError if the first date is `Invalid Date`\", () => {\n-    expect(formatDistance.bind(null, new Date(NaN), new Date(1986, 3, 7, 10, 32, 0))).toThrow(RangeError);\n+    expect(\n+      formatDistance.bind(null, new Date(NaN), new Date(1986, 3, 7, 10, 32, 0)),\n+    ).toThrow(RangeError);\n   });\n \n   it(\"throws RangeError if the second date is `Invalid Date`\", () => {\n-    expect(formatDistance.bind(null, new Date(1986, 3, 4, 10, 32, 0), new Date(NaN))).toThrow(RangeError);\n+    expect(\n+      formatDistance.bind(null, new Date(1986, 3, 4, 10, 32, 0), new Date(NaN)),\n+    ).toThrow(RangeError);\n   });\n \n   it(\"throws RangeError if the both dates are `Invalid Date`\", () => {\n-    expect(formatDistance.bind(null, new Date(NaN), new Date(NaN))).toThrow(RangeError);\n+    expect(formatDistance.bind(null, new Date(NaN), new Date(NaN))).toThrow(\n+      RangeError,\n+    );\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2023, 5, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2023, 11, 1, \"America/New_York\");\n+    expect(formatDistance(dateLeft, dateRight)).toEqual(\"6 months\");\n+    expect(formatDistance(dateRight, dateLeft)).toBe(\"6 months\");\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      formatDistance(start, end);\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        formatDistance(\"2024-04-10T07:00:00Z\", \"2024-04-12T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }),\n+      ).toEqual(\"2 days\");\n+      expect(\n+        formatDistance(\"2024-04-10T07:00:00Z\", \"2024-04-12T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toEqual(\"2 days\");\n+    });\n   });\n });\ndiff --git a/src/formatDistanceStrict/test.ts b/src/formatDistanceStrict/test.ts\nindex 41b96ec89d..b30ca51b35 100644\n--- a/src/formatDistanceStrict/test.ts\n+++ b/src/formatDistanceStrict/test.ts\n@@ -1,6 +1,7 @@\n import { describe, expect, it } from \"vitest\";\n import type { FormatDistanceFn } from \"../locale/types.js\";\n import { formatDistanceStrict } from \"./index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n \n describe(\"formatDistanceStrict\", () => {\n   describe(\"seconds\", () => {\n@@ -416,22 +417,59 @@ describe(\"formatDistanceStrict\", () => {\n   });\n \n   it(\"throws `RangeError` if the first date is `Invalid Date`\", () => {\n-    expect(formatDistanceStrict.bind(\n-      null,\n-      new Date(NaN),\n-      new Date(1986, 3, 7, 10, 32, 0),\n-    )).toThrow(RangeError);\n+    expect(\n+      formatDistanceStrict.bind(\n+        null,\n+        new Date(NaN),\n+        new Date(1986, 3, 7, 10, 32, 0),\n+      ),\n+    ).toThrow(RangeError);\n   });\n \n   it(\"throws `RangeError` if the second date is `Invalid Date`\", () => {\n-    expect(formatDistanceStrict.bind(\n-      null,\n-      new Date(1986, 3, 4, 10, 32, 0),\n-      new Date(NaN),\n-    )).toThrow(RangeError);\n+    expect(\n+      formatDistanceStrict.bind(\n+        null,\n+        new Date(1986, 3, 4, 10, 32, 0),\n+        new Date(NaN),\n+      ),\n+    ).toThrow(RangeError);\n   });\n \n   it(\"throws `RangeError` if the both dates are `Invalid Date`\", () => {\n-    expect(formatDistanceStrict.bind(null, new Date(NaN), new Date(NaN))).toThrow(RangeError);\n+    expect(\n+      formatDistanceStrict.bind(null, new Date(NaN), new Date(NaN)),\n+    ).toThrow(RangeError);\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2023, 5, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2023, 11, 1, \"America/New_York\");\n+    expect(formatDistanceStrict(dateLeft, dateRight)).toEqual(\"6 months\");\n+    expect(formatDistanceStrict(dateRight, dateLeft)).toBe(\"6 months\");\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      formatDistanceStrict(start, end);\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        formatDistanceStrict(\"2024-04-10T07:00:00Z\", \"2024-04-12T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }),\n+      ).toEqual(\"2 days\");\n+      expect(\n+        formatDistanceStrict(\"2024-04-10T07:00:00Z\", \"2024-04-12T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toEqual(\"2 days\");\n+    });\n   });\n });\ndiff --git a/src/formatDistanceToNow/test.ts b/src/formatDistanceToNow/test.ts\nindex 4fd119d191..6cbce06a43 100644\n--- a/src/formatDistanceToNow/test.ts\n+++ b/src/formatDistanceToNow/test.ts\n@@ -1,18 +1,11 @@\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n import type { FormatDistanceFn } from \"../locale/types.js\";\n import { formatDistanceToNow } from \"./index.js\";\n \n describe(\"formatDistanceToNow\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(1986, 3, 4, 10, 32, 0).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  fakeDate(new Date(1986, 3, 4, 10, 32, 0));\n \n   describe(\"seconds\", () => {\n     describe(\"when the includeSeconds option is true\", () => {\ndiff --git a/src/formatDistanceToNowStrict/test.ts b/src/formatDistanceToNowStrict/test.ts\nindex b1c04dd828..b1858a18c6 100644\n--- a/src/formatDistanceToNowStrict/test.ts\n+++ b/src/formatDistanceToNowStrict/test.ts\n@@ -1,18 +1,11 @@\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n import type { FormatDistanceFn } from \"../locale/types.js\";\n import { formatDistanceToNowStrict } from \"./index.js\";\n \n describe(\"formatDistanceToNowStrict\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(1986, 3, 4, 10, 32, 0).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  fakeDate(new Date(1986, 3, 4, 10, 32, 0));\n \n   describe(\"seconds\", () => {\n     describe(\"when no unit is set\", () => {\ndiff --git a/src/fromUnixTime/test.ts b/src/fromUnixTime/test.ts\nindex 1887236af3..00a1858938 100644\n--- a/src/fromUnixTime/test.ts\n+++ b/src/fromUnixTime/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { fromUnixTime } from \"./index.js\";\n \n describe(\"fromUnixTime\", () => {\n@@ -11,4 +13,28 @@ describe(\"fromUnixTime\", () => {\n     const result = fromUnixTime(NaN);\n     expect(isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = fromUnixTime(1330515499);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const result = fromUnixTime(1330515499, {\n+        in: tz(\"America/Los_Angeles\"),\n+      });\n+      expect(result.getTime()).toBe(1330515499000);\n+      expect(result).toBeInstanceOf(TZDate);\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = fromUnixTime(1330515499, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/getDate/test.ts b/src/getDate/test.ts\nindex e7255b4a68..7ffc7695c4 100644\n--- a/src/getDate/test.ts\n+++ b/src/getDate/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getDate } from \"./index.js\";\n \n describe(\"getDate\", () => {\n@@ -16,4 +18,24 @@ describe(\"getDate\", () => {\n     const result = getDate(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getDate(new Date(\"2024-08-18T15:00:00Z\"), { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(18);\n+      expect(\n+        getDate(new Date(\"2024-08-18T16:00:00Z\"), { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(19);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getDate(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getDay/test.ts b/src/getDay/test.ts\nindex 13be3b93d1..16f7e0cf21 100644\n--- a/src/getDay/test.ts\n+++ b/src/getDay/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getDay } from \"./index.js\";\n \n describe(\"getDay\", () => {\n@@ -16,4 +18,24 @@ describe(\"getDay\", () => {\n     const result = getDay(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getDay(new Date(\"2023-08-18T15:00:00Z\"), { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(5);\n+      expect(\n+        getDay(new Date(\"2023-08-18T16:00:00Z\"), { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(6);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getDay(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getDayOfYear/test.ts b/src/getDayOfYear/test.ts\nindex 5d5b01d4e7..2b13d6db74 100644\n--- a/src/getDayOfYear/test.ts\n+++ b/src/getDayOfYear/test.ts\n@@ -1,5 +1,7 @@\n import { describe, expect, it } from \"vitest\";\n import { getDayOfYear } from \"./index.js\";\n+import { tz } from \"@date-fns/tz\";\n+import { type DateFns } from \"../types.js\";\n \n describe(\"getDayOfYear\", () => {\n   it(\"returns the day of the year of the given date\", () => {\n@@ -24,4 +26,28 @@ describe(\"getDayOfYear\", () => {\n     const result = getDayOfYear(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getDayOfYear(new Date(\"2014-07-02T00:00:00Z\"), {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(183);\n+      expect(\n+        getDayOfYear(new Date(\"2014-07-02T00:00:00Z\"), {\n+          in: tz(\"America/Los_Angeles\"),\n+        }),\n+      ).toBe(182);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getDayOfYear(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getDaysInMonth/test.ts b/src/getDaysInMonth/test.ts\nindex 9de9cb9212..f24c531979 100644\n--- a/src/getDaysInMonth/test.ts\n+++ b/src/getDaysInMonth/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getDaysInMonth } from \"./index.js\";\n \n describe(\"getDaysInMonth\", () => {\n@@ -30,4 +32,28 @@ describe(\"getDaysInMonth\", () => {\n     const result = getDaysInMonth(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getDaysInMonth(\"2024-02-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(31);\n+      expect(\n+        getDaysInMonth(\"2024-02-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(29);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getDaysInMonth(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getDaysInYear/test.ts b/src/getDaysInYear/test.ts\nindex 178b8ed55d..87f1ffd714 100644\n--- a/src/getDaysInYear/test.ts\n+++ b/src/getDaysInYear/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getDaysInYear } from \"./index.js\";\n \n describe(\"getDaysInYear\", () => {\n@@ -32,4 +34,28 @@ describe(\"getDaysInYear\", () => {\n     const result = getDaysInYear(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getDaysInYear(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }),\n+      ).toBe(366);\n+      expect(\n+        getDaysInYear(\"2023-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }),\n+      ).toBe(365);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getDaysInYear(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getDecade/test.ts b/src/getDecade/test.ts\nindex b1f72de34c..1421d47828 100644\n--- a/src/getDecade/test.ts\n+++ b/src/getDecade/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getDecade } from \"./index.js\";\n \n describe(\"getDecade\", () => {\n@@ -21,4 +23,22 @@ describe(\"getDecade\", () => {\n     expect(getDecade(new Date(2009, 0, 1))).toBe(2000);\n     expect(getDecade(new Date(-2001, 0, 1))).toBe(-2010);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const result = getDecade(\"1971-11-08T07:00:00Z\", {\n+        in: tz(\"America/New_York\"),\n+      });\n+      expect(result).toBe(1970);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getDecade(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getHours/test.ts b/src/getHours/test.ts\nindex 6d4a564eef..4d5dc3566d 100644\n--- a/src/getHours/test.ts\n+++ b/src/getHours/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getHours } from \"./index.js\";\n \n describe(\"getHours\", () => {\n@@ -16,4 +18,24 @@ describe(\"getHours\", () => {\n     const result = getHours(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getHours(\"2023-08-18T15:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(23);\n+      expect(\n+        getHours(\"2023-08-18T15:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(11);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getHours(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getISODay/test.ts b/src/getISODay/test.ts\nindex 8242727a2a..270c7f989d 100644\n--- a/src/getISODay/test.ts\n+++ b/src/getISODay/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getISODay } from \"./index.js\";\n \n describe(\"getISODay\", () => {\n@@ -21,4 +23,28 @@ describe(\"getISODay\", () => {\n     const result = getISODay(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getISODay(new Date(\"2023-08-18T15:00:00Z\"), {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(5);\n+      expect(\n+        getISODay(new Date(\"2023-08-18T16:00:00Z\"), {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(6);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getISODay(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getISOWeek/test.ts b/src/getISOWeek/test.ts\nindex 94972e0ffd..69f130af68 100644\n--- a/src/getISOWeek/test.ts\n+++ b/src/getISOWeek/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getISOWeek } from \"./index.js\";\n \n describe(\"getISOWeek\", () => {\n@@ -51,4 +53,24 @@ describe(\"getISOWeek\", () => {\n     const result = getISOWeek(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getISOWeek(\"2024-08-26T03:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(34);\n+      expect(\n+        getISOWeek(\"2024-08-26T04:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(35);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getISOWeek(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getISOWeekYear/test.ts b/src/getISOWeekYear/test.ts\nindex e2e54e8f2a..e250642f4c 100644\n--- a/src/getISOWeekYear/test.ts\n+++ b/src/getISOWeekYear/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getISOWeekYear } from \"./index.js\";\n \n describe(\"getISOWeekYear\", () => {\n@@ -24,4 +26,38 @@ describe(\"getISOWeekYear\", () => {\n     const result = getISOWeekYear(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getISOWeekYear(\"2023-12-31T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(2023);\n+      expect(\n+        getISOWeekYear(\"2023-12-31T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(2024);\n+      expect(\n+        getISOWeekYear(\"2024-01-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(2023);\n+      expect(\n+        getISOWeekYear(\"2024-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(2024);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getISOWeekYear(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getISOWeeksInYear/test.ts b/src/getISOWeeksInYear/test.ts\nindex 2215a686ca..e796778852 100644\n--- a/src/getISOWeeksInYear/test.ts\n+++ b/src/getISOWeeksInYear/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getISOWeeksInYear } from \"./index.js\";\n \n describe(\"getISOWeeksInYear\", () => {\n@@ -34,4 +36,23 @@ describe(\"getISOWeeksInYear\", () => {\n     expect(getISOWeeksInYear(new Date(-2015, 1 /* Feb */, 11))).toBe(52);\n     expect(getISOWeeksInYear(new Date(385, 1 /* Feb */, 11))).toBe(52);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getISOWeeksInYear(\"2024-01-01T00:00:00Z\", {\n+          in: tz(\"Europe/London\"),\n+        }),\n+      ).toBe(52);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getISOWeeksInYear(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getMinutes/test.ts b/src/getMinutes/test.ts\nindex 889f106a8c..24bc22322e 100644\n--- a/src/getMinutes/test.ts\n+++ b/src/getMinutes/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getMinutes } from \"./index.js\";\n \n describe(\"getMinutes\", () => {\n@@ -16,4 +18,28 @@ describe(\"getMinutes\", () => {\n     const result = getMinutes(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getMinutes(\"2024-04-10T07:45:00Z\", {\n+          in: tz(\"Asia/Kolkata\"),\n+        }),\n+      ).toBe(15);\n+      expect(\n+        getMinutes(\"2024-04-10T07:45:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(45);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getMinutes(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getMonth/test.ts b/src/getMonth/test.ts\nindex b42b7edca0..12e00ddf2f 100644\n--- a/src/getMonth/test.ts\n+++ b/src/getMonth/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getMonth } from \"./index.js\";\n \n describe(\"getMonth\", () => {\n@@ -16,4 +18,30 @@ describe(\"getMonth\", () => {\n     const result = getMonth(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getMonth(\"2024-08-31T15:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(7);\n+      expect(\n+        getMonth(\"2024-08-31T16:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(8);\n+      expect(\n+        getMonth(\"2024-09-01T03:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(7);\n+      expect(\n+        getMonth(\"2024-09-01T04:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(8);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getMonth(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getOverlappingDaysInIntervals/test.ts b/src/getOverlappingDaysInIntervals/test.ts\nindex 8e6df50e3d..1c6c1442cf 100644\n--- a/src/getOverlappingDaysInIntervals/test.ts\n+++ b/src/getOverlappingDaysInIntervals/test.ts\n@@ -1,5 +1,3 @@\n-/* eslint-env mocha */\n-\n import { describe, expect, it } from \"vitest\";\n import { getOverlappingDaysInIntervals } from \"./index.js\";\n \ndiff --git a/src/getQuarter/test.ts b/src/getQuarter/test.ts\nindex 0e13371f1d..b152f67573 100644\n--- a/src/getQuarter/test.ts\n+++ b/src/getQuarter/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getQuarter } from \"./index.js\";\n \n describe(\"getQuarter\", () => {\n@@ -16,4 +18,30 @@ describe(\"getQuarter\", () => {\n     const result = getQuarter(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getQuarter(\"2024-03-31T16:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(2);\n+      expect(\n+        getQuarter(\"2024-03-31T15:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(1);\n+      expect(\n+        getQuarter(\"2024-04-01T04:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(2);\n+      expect(\n+        getQuarter(\"2024-04-01T03:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(1);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getQuarter(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getWeek/test.ts b/src/getWeek/test.ts\nindex bdb0b41d62..19dc6bee4d 100644\n--- a/src/getWeek/test.ts\n+++ b/src/getWeek/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getWeek } from \"./index.js\";\n \n describe(\"getWeek\", () => {\n@@ -53,4 +55,30 @@ describe(\"getWeek\", () => {\n     });\n     expect(result).toBe(53);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getWeek(\"2024-08-24T15:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(34);\n+      expect(\n+        getWeek(\"2024-08-24T16:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(35);\n+      expect(\n+        getWeek(\"2024-08-25T03:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(34);\n+      expect(\n+        getWeek(\"2024-08-25T04:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(35);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getWeek(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getWeekOfMonth/test.ts b/src/getWeekOfMonth/test.ts\nindex 4f35580a37..cc2d97e7d3 100644\n--- a/src/getWeekOfMonth/test.ts\n+++ b/src/getWeekOfMonth/test.ts\n@@ -1,5 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import { getWeekOfMonth } from \"./index.js\";\n+import { getWeekOfMonth, type GetWeekOfMonthOptions } from \"./index.js\";\n \n describe(\"getWeekOfMonth\", () => {\n   it(\"returns the week of the month of the given date\", () => {\n@@ -46,7 +47,7 @@ describe(\"getWeekOfMonth\", () => {\n     expect(result).toBe(6);\n   });\n \n-  it(\"`options.weekStartsOn` overwrites the first day of the week specified in locale\", () => {\n+  it(\"options.weekStartsOn overwrites the first day of the week specified in locale\", () => {\n     const result = getWeekOfMonth(new Date(2017, 10 /* Nov */, 13), {\n       weekStartsOn: 1,\n       locale: {\n@@ -72,4 +73,30 @@ describe(\"getWeekOfMonth\", () => {\n     });\n     expect(result).toBe(1);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getWeekOfMonth(\"2024-08-24T15:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(4);\n+      expect(\n+        getWeekOfMonth(\"2024-08-24T16:00:00Z\", { in: tz(\"Asia/Singapore\") }),\n+      ).toBe(5);\n+      expect(\n+        getWeekOfMonth(\"2024-08-25T03:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(4);\n+      expect(\n+        getWeekOfMonth(\"2024-08-25T04:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(5);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: GetWeekOfMonthOptions<ResultDate>,\n+      ) {\n+        getWeekOfMonth(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getWeekYear/test.ts b/src/getWeekYear/test.ts\nindex 9886d6f4a1..51e705a731 100644\n--- a/src/getWeekYear/test.ts\n+++ b/src/getWeekYear/test.ts\n@@ -1,5 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import { getWeekYear } from \"./index.js\";\n+import { getWeekYear, type GetWeekYearOptions } from \"./index.js\";\n \n describe(\"getWeekYear\", () => {\n   it(\"returns the local week-numbering year of the given date\", () => {\n@@ -46,4 +47,42 @@ describe(\"getWeekYear\", () => {\n     });\n     expect(result).toBe(2004);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getWeekYear(\"2023-12-31T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+          weekStartsOn: 1,\n+        }),\n+      ).toBe(2023);\n+      expect(\n+        getWeekYear(\"2023-12-31T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+          weekStartsOn: 1,\n+        }),\n+      ).toBe(2024);\n+      expect(\n+        getWeekYear(\"2024-01-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+          weekStartsOn: 1,\n+        }),\n+      ).toBe(2023);\n+      expect(\n+        getWeekYear(\"2024-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+          weekStartsOn: 1,\n+        }),\n+      ).toBe(2024);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: GetWeekYearOptions<ResultDate>,\n+      ) {\n+        getWeekYear(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getWeeksInMonth/test.ts b/src/getWeeksInMonth/test.ts\nindex 8f2b204a80..2b7cb0d9ca 100644\n--- a/src/getWeeksInMonth/test.ts\n+++ b/src/getWeeksInMonth/test.ts\n@@ -1,5 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import { getWeeksInMonth } from \"./index.js\";\n+import { getWeeksInMonth, type GetWeeksInMonthOptions } from \"./index.js\";\n \n describe(\"getWeeksInMonth\", () => {\n   it(\"returns the number of calendar weeks the month in the given date spans\", () => {\n@@ -23,7 +24,7 @@ describe(\"getWeeksInMonth\", () => {\n     expect(result).toBe(5);\n   });\n \n-  it(\"`options.weekStartsOn` overwrites the first day of the week specified in locale\", () => {\n+  it(\"options.weekStartsOn overwrites the first day of the week specified in locale\", () => {\n     const result = getWeeksInMonth(new Date(2015, 1 /* Feb */, 8, 18, 0), {\n       weekStartsOn: 1,\n       locale: {\n@@ -50,4 +51,38 @@ describe(\"getWeeksInMonth\", () => {\n     const result = getWeeksInMonth(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getWeeksInMonth(\"2023-12-31T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(6);\n+      expect(\n+        getWeeksInMonth(\"2023-12-31T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(5);\n+      expect(\n+        getWeeksInMonth(\"2024-01-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(6);\n+      expect(\n+        getWeeksInMonth(\"2024-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(5);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: GetWeeksInMonthOptions<ResultDate>,\n+      ) {\n+        getWeeksInMonth(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/getYear/test.ts b/src/getYear/test.ts\nindex c7ae92c010..d43bbf2d2b 100644\n--- a/src/getYear/test.ts\n+++ b/src/getYear/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { getYear } from \"./index.js\";\n \n describe(\"getYear\", () => {\n@@ -16,4 +18,38 @@ describe(\"getYear\", () => {\n     const result = getYear(new Date(NaN));\n     expect(isNaN(result)).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        getYear(\"2023-12-31T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(2023);\n+      expect(\n+        getYear(\"2023-12-31T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(2024);\n+      expect(\n+        getYear(\"2024-01-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(2023);\n+      expect(\n+        getYear(\"2024-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(2024);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        getYear(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/interval/test.ts b/src/interval/test.ts\nindex 31a9258784..1a60070fd2 100644\n--- a/src/interval/test.ts\n+++ b/src/interval/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { interval } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n \n describe(\"Interval\", () => {\n   it(\"exposes start and end\", () => {\n@@ -42,4 +45,40 @@ describe(\"Interval\", () => {\n       assertPositive: true,\n     });\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = interval(Date.now(), Date.now());\n+    expect(result.start).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result.start>>(true);\n+    expect(result.end).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result.end>>(true);\n+  });\n+\n+  it(\"resolves the start date object type\", () => {\n+    const result = interval(new UTCDate(), new TZDate());\n+    expect(result.start).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result.start>>(true);\n+    expect(result.end).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result.end>>(true);\n+  });\n+\n+  it(\"resolves the end date object type if the start isn't object\", () => {\n+    const result = interval(Date.now(), new TZDate());\n+    expect(result.start).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate, typeof result.start>>(true);\n+    expect(result.end).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate, typeof result.end>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"resolves the context date type\", () => {\n+      const result = interval(new UTCDate(), new Date(), {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result.start).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result.start>>(true);\n+      expect(result.end).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result.end>>(true);\n+    });\n+  });\n });\ndiff --git a/src/intervalToDuration/test.ts b/src/intervalToDuration/test.ts\nindex e7c8c4c48f..edc28eb2be 100644\n--- a/src/intervalToDuration/test.ts\n+++ b/src/intervalToDuration/test.ts\n@@ -1,6 +1,8 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import { intervalToDuration } from \"./index.js\";\n import { addMonths } from \"../addMonths/index.js\";\n+import type { DateFns, Interval } from \"../types.js\";\n+import { intervalToDuration } from \"./index.js\";\n \n describe(\"intervalToDuration\", () => {\n   it(\"returns correct duration for arbitrary dates\", () => {\n@@ -72,33 +74,41 @@ describe(\"intervalToDuration\", () => {\n \n   describe(\"edge cases\", () => {\n     it(\"returns correct duration for dates in the end of Feb - issue 2255\", () => {\n-      expect(intervalToDuration({\n-        start: new Date(2012, 1 /* Feb */, 28, 9, 0, 0),\n-        end: new Date(2012, 1 /* Feb */, 29, 10, 0, 0),\n-      })).toEqual({\n+      expect(\n+        intervalToDuration({\n+          start: new Date(2012, 1 /* Feb */, 28, 9, 0, 0),\n+          end: new Date(2012, 1 /* Feb */, 29, 10, 0, 0),\n+        }),\n+      ).toEqual({\n         days: 1,\n         hours: 1,\n       });\n \n-      expect(intervalToDuration({\n-        start: new Date(2012, 1 /* Feb */, 29, 9, 0, 0),\n-        end: new Date(2012, 1 /* Feb */, 29, 10, 0, 0),\n-      })).toEqual({\n+      expect(\n+        intervalToDuration({\n+          start: new Date(2012, 1 /* Feb */, 29, 9, 0, 0),\n+          end: new Date(2012, 1 /* Feb */, 29, 10, 0, 0),\n+        }),\n+      ).toEqual({\n         hours: 1,\n       });\n \n-      expect(intervalToDuration({\n-        start: new Date(2012, 1 /* Feb */, 28, 9, 0, 0),\n-        end: new Date(2012, 1 /* Feb */, 28, 10, 0, 0),\n-      })).toEqual({\n+      expect(\n+        intervalToDuration({\n+          start: new Date(2012, 1 /* Feb */, 28, 9, 0, 0),\n+          end: new Date(2012, 1 /* Feb */, 28, 10, 0, 0),\n+        }),\n+      ).toEqual({\n         hours: 1,\n       });\n \n       // Issue 2261\n-      expect(intervalToDuration({\n-        start: new Date(2021, 1 /* Feb */, 28, 7, 23, 7),\n-        end: new Date(2021, 1 /* Feb */, 28, 7, 38, 18),\n-      })).toEqual({\n+      expect(\n+        intervalToDuration({\n+          start: new Date(2021, 1 /* Feb */, 28, 7, 23, 7),\n+          end: new Date(2021, 1 /* Feb */, 28, 7, 38, 18),\n+        }),\n+      ).toEqual({\n         minutes: 15,\n         seconds: 11,\n       });\n@@ -224,4 +234,68 @@ describe(\"intervalToDuration\", () => {\n       });\n     });\n   });\n+\n+  it(\"normalizes the dates\", () => {\n+    const laterDate = new TZDate(2027, 0, 1, \"Asia/Singapore\");\n+    const earlierDate = new TZDate(2024, 0, 1, \"America/New_York\");\n+    expect(intervalToDuration({ start: laterDate, end: earlierDate })).toEqual({\n+      days: -30,\n+      hours: -11,\n+      months: -11,\n+      years: -2,\n+    });\n+    expect(intervalToDuration({ start: earlierDate, end: laterDate })).toEqual({\n+      days: 30,\n+      hours: 11,\n+      months: 11,\n+      years: 2,\n+    });\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      start: DateType1 | number | string,\n+      end: DateType2 | number | string,\n+    ) {\n+      intervalToDuration({ start, end });\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        intervalToDuration(\n+          {\n+            start: new Date(\"2023-09-03T00:00:00Z\"),\n+            end: new Date(\"2024-09-03T15:00:00Z\"),\n+          },\n+          { in: tz(\"Asia/Singapore\") },\n+        ),\n+      ).toEqual({\n+        years: 1,\n+        hours: 15,\n+      });\n+      expect(\n+        intervalToDuration(\n+          {\n+            start: new Date(\"2023-09-03T00:00:00Z\"),\n+            end: new Date(\"2024-09-03T15:00:00Z\"),\n+          },\n+          { in: tz(\"America/New_York\") },\n+        ),\n+      ).toEqual({\n+        years: 1,\n+        hours: 15,\n+      });\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: Interval<DateType>,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        intervalToDuration(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/intlFormatDistance/test.ts b/src/intlFormatDistance/test.ts\nindex 7b45427983..b1d6d923de 100644\n--- a/src/intlFormatDistance/test.ts\n+++ b/src/intlFormatDistance/test.ts\n@@ -1,3 +1,4 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n import { intlFormatDistance } from \"./index.js\";\n \n@@ -722,73 +723,130 @@ describe(\"intlFormatDistance\", () => {\n \n     describe(\"errors\", () => {\n       it(\"checks the first date\", () => {\n-        expect(intlFormatDistance.bind(\n-          null,\n-          new Date(NaN),\n-          new Date(1986, 3, 4, 10, 30, 0),\n-        )).toThrow(RangeError);\n+        expect(\n+          intlFormatDistance.bind(\n+            null,\n+            new Date(NaN),\n+            new Date(1986, 3, 4, 10, 30, 0),\n+          ),\n+        ).toThrow(RangeError);\n       });\n \n       it(\"checks the second date\", () => {\n-        expect(intlFormatDistance.bind(\n-          null,\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          new Date(NaN),\n-        )).toThrow(RangeError);\n+        expect(\n+          intlFormatDistance.bind(\n+            null,\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            new Date(NaN),\n+          ),\n+        ).toThrow(RangeError);\n       });\n \n       it(\"checks both dates\", () => {\n-        expect(intlFormatDistance.bind(null, new Date(NaN), new Date(NaN))).toThrow(RangeError);\n+        expect(\n+          intlFormatDistance.bind(null, new Date(NaN), new Date(NaN)),\n+        ).toThrow(RangeError);\n       });\n \n       it(\"checks unit\", () => {\n-        expect(intlFormatDistance.bind(\n-          null,\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          // @ts-expect-error - We're testing wrong value\n-          { unit: \"wrongValue\" },\n-        )).toThrow(RangeError);\n+        expect(\n+          intlFormatDistance.bind(\n+            null,\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            // @ts-expect-error - We're testing wrong value\n+            { unit: \"wrongValue\" },\n+          ),\n+        ).toThrow(RangeError);\n       });\n \n       it(\"checks locale\", () => {\n-        expect(intlFormatDistance.bind(\n-          null,\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          { locale: \"wrongValue\" },\n-        )).toThrow(RangeError);\n+        expect(\n+          intlFormatDistance.bind(\n+            null,\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            { locale: \"wrongValue\" },\n+          ),\n+        ).toThrow(RangeError);\n       });\n \n       it(\"checks localeMatcher\", () => {\n-        expect(intlFormatDistance.bind(\n-          null,\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          // @ts-expect-error - We're testing wrong value\n-          { localeMatcher: \"wrongValue\" },\n-        )).toThrow(RangeError);\n+        expect(\n+          intlFormatDistance.bind(\n+            null,\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            // @ts-expect-error - We're testing wrong value\n+            { localeMatcher: \"wrongValue\" },\n+          ),\n+        ).toThrow(RangeError);\n       });\n \n       it(\"checks numeric\", () => {\n-        expect(intlFormatDistance.bind(\n-          null,\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          // @ts-expect-error - We're testing wrong value\n-          { numeric: \"wrongValue\" },\n-        )).toThrow(RangeError);\n+        expect(\n+          intlFormatDistance.bind(\n+            null,\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            // @ts-expect-error - We're testing wrong value\n+            { numeric: \"wrongValue\" },\n+          ),\n+        ).toThrow(RangeError);\n       });\n \n       it(\"checks style\", () => {\n-        expect(intlFormatDistance.bind(\n-          null,\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          new Date(1986, 3, 4, 10, 30, 0),\n-          // @ts-expect-error - We're testing wrong value\n-          { style: \"wrongValue\" },\n-        )).toThrow(RangeError);\n+        expect(\n+          intlFormatDistance.bind(\n+            null,\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            new Date(1986, 3, 4, 10, 30, 0),\n+            // @ts-expect-error - We're testing wrong value\n+            { style: \"wrongValue\" },\n+          ),\n+        ).toThrow(RangeError);\n       });\n     });\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      intlFormatDistance(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(1987, 6, 4, 10, 30, 0, \"Asia/Singapore\");\n+    const dateRight = new TZDate(1986, 3, 4, 10, 30, 0, \"America/New_York\");\n+    expect(intlFormatDistance(dateLeft, dateRight)).toBe(\"next year\");\n+    expect(intlFormatDistance(dateRight, dateLeft)).toBe(\"last year\");\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        intlFormatDistance(\"2024-09-03T00:00:00Z\", \"2024-09-03T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(\"yesterday\");\n+      expect(\n+        intlFormatDistance(\"2024-09-03T00:00:00Z\", \"2024-09-03T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(\"15 hours ago\");\n+      expect(\n+        intlFormatDistance(\"2024-09-03T00:00:00Z\", \"2024-09-03T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(\"yesterday\");\n+      expect(\n+        intlFormatDistance(\"2024-09-03T00:00:00Z\", \"2024-09-03T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(\"3 hours ago\");\n+    });\n+  });\n });\ndiff --git a/src/isFirstDayOfMonth/test.ts b/src/isFirstDayOfMonth/test.ts\nindex 71019aa683..6d576a73df 100644\n--- a/src/isFirstDayOfMonth/test.ts\n+++ b/src/isFirstDayOfMonth/test.ts\n@@ -1,13 +1,15 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n import { isFirstDayOfMonth } from \"./index.js\";\n+import { type DateFns } from \"../types.js\";\n \n describe(\"isFirstDayOfMonth\", () => {\n-  it(\"returns true if the given date is in the last day of month\", () => {\n+  it(\"returns true if the given date is the first day of a month\", () => {\n     const result = isFirstDayOfMonth(new Date(2014, 9 /* Oct */, 1));\n     expect(result).toBe(true);\n   });\n \n-  it(\"returns false if the given date is not in the last day of month\", () => {\n+  it(\"returns false if the given date is not the first day of a month\", () => {\n     const result = isFirstDayOfMonth(new Date(2014, 9 /* Oct */, 2));\n     expect(result).toBe(false);\n   });\n@@ -22,4 +24,38 @@ describe(\"isFirstDayOfMonth\", () => {\n     const result = isFirstDayOfMonth(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isFirstDayOfMonth(\"2024-08-31T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isFirstDayOfMonth(\"2024-08-31T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isFirstDayOfMonth(\"2024-09-01T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isFirstDayOfMonth(\"2024-09-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isFirstDayOfMonth(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isFriday/test.ts b/src/isFriday/test.ts\nindex aa0cfc41a8..10054969c9 100644\n--- a/src/isFriday/test.ts\n+++ b/src/isFriday/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isFriday } from \"./index.js\";\n \n describe(\"isFriday\", () => {\n@@ -21,4 +23,38 @@ describe(\"isFriday\", () => {\n     const result = isFriday(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isFriday(\"2024-08-15T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isFriday(\"2024-08-15T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isFriday(\"2024-08-16T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isFriday(\"2024-08-16T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isFriday(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isFuture/test.ts b/src/isFuture/test.ts\nindex a92798dbe0..db402265eb 100644\n--- a/src/isFuture/test.ts\n+++ b/src/isFuture/test.ts\n@@ -1,16 +1,9 @@\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n-import sinon from \"sinon\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n import { isFuture } from \"./index.js\";\n \n describe(\"isFuture\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(2014, 8 /* Sep */, 25).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  fakeDate(new Date(2014, 8 /* Sep */, 25));\n \n   it(\"returns true if the given date is in the future\", () => {\n     const result = isFuture(new Date(2014, 9 /* Oct */, 31));\ndiff --git a/src/isLastDayOfMonth/test.ts b/src/isLastDayOfMonth/test.ts\nindex 80962ad778..a79bc406f4 100644\n--- a/src/isLastDayOfMonth/test.ts\n+++ b/src/isLastDayOfMonth/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isLastDayOfMonth } from \"./index.js\";\n \n describe(\"isLastDayOfMonth\", () => {\n@@ -22,4 +24,38 @@ describe(\"isLastDayOfMonth\", () => {\n     const result = isLastDayOfMonth(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isLastDayOfMonth(\"2024-09-29T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isLastDayOfMonth(\"2024-09-29T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isLastDayOfMonth(\"2024-08-31T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isLastDayOfMonth(\"2024-08-31T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isLastDayOfMonth(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isLeapYear/test.ts b/src/isLeapYear/test.ts\nindex 42d9bcc5d9..3e3e0dd476 100644\n--- a/src/isLeapYear/test.ts\n+++ b/src/isLeapYear/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isLeapYear } from \"./index.js\";\n \n describe(\"isLeapYear\", () => {\n@@ -32,4 +34,28 @@ describe(\"isLeapYear\", () => {\n     const result = isLeapYear(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isLeapYear(\"2012-01-01T00:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isLeapYear(\"2012-01-01T00:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isLeapYear(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isMatch/test.ts b/src/isMatch/test.ts\nindex 6134e9fffd..921b7d1319 100644\n--- a/src/isMatch/test.ts\n+++ b/src/isMatch/test.ts\n@@ -12,8 +12,10 @@ describe(\"isMatch\", () => {\n   });\n \n   it(\"accepts a date & format with locale\", () => {\n-    expect(isMatch(\"28-a de februaro\", \"do 'de' MMMM\", {\n-      locale: eo,\n-    })).toBe(true);\n+    expect(\n+      isMatch(\"28-a de februaro\", \"do 'de' MMMM\", {\n+        locale: eo,\n+      }),\n+    ).toBe(true);\n   });\n });\ndiff --git a/src/isMonday/test.ts b/src/isMonday/test.ts\nindex df567f2f83..5ac721551c 100644\n--- a/src/isMonday/test.ts\n+++ b/src/isMonday/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isMonday } from \"./index.js\";\n \n describe(\"isMonday\", () => {\n@@ -21,4 +23,38 @@ describe(\"isMonday\", () => {\n     const result = isMonday(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isMonday(\"2024-08-18T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isMonday(\"2024-08-18T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isMonday(\"2024-08-10T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isMonday(\"2024-08-10T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isMonday(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isPast/test.ts b/src/isPast/test.ts\nindex 31650e506d..cb711563e9 100644\n--- a/src/isPast/test.ts\n+++ b/src/isPast/test.ts\n@@ -1,16 +1,9 @@\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n-import sinon from \"sinon\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n import { isPast } from \"./index.js\";\n \n describe(\"isPast\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(2014, 8 /* Sep */, 25).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  fakeDate(new Date(2014, 8 /* Sep */, 25));\n \n   it(\"returns true if the given date is in the past\", () => {\n     const result = isPast(new Date(2014, 6 /* Jul */, 2));\ndiff --git a/src/isSameDay/test.ts b/src/isSameDay/test.ts\nindex ddb102ffa1..474ba4d0bb 100644\n--- a/src/isSameDay/test.ts\n+++ b/src/isSameDay/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isSameDay } from \"./index.js\";\n \n describe(\"isSameDay\", () => {\n@@ -40,4 +42,45 @@ describe(\"isSameDay\", () => {\n     const result = isSameDay(new Date(NaN), new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      isSameDay(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 5, 7, 8, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 5, 6, 4, \"America/New_York\");\n+    expect(isSameDay(dateLeft, dateRight)).toBe(false);\n+    expect(isSameDay(dateRight, dateLeft)).toBe(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isSameDay(\"2024-04-10T07:00:00Z\", \"2024-04-10T15:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isSameDay(\"2024-04-10T07:00:00Z\", \"2024-04-11T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isSameDay(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isSameHour/test.ts b/src/isSameHour/test.ts\nindex 61c71f2cd5..3e00137534 100644\n--- a/src/isSameHour/test.ts\n+++ b/src/isSameHour/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isSameHour } from \"./index.js\";\n \n describe(\"isSameHour\", () => {\n@@ -40,4 +42,45 @@ describe(\"isSameHour\", () => {\n     const result = isSameHour(new Date(NaN), new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      isSameHour(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 8, 9, 7, \"America/New_York\");\n+    const dateRight = new TZDate(2024, 8, 9, 16, 15, \"Asia/Kolkata\");\n+    expect(isSameHour(dateLeft, dateRight)).toBe(false);\n+    expect(isSameHour(dateRight, dateLeft)).toBe(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isSameHour(\"2024-04-10T07:00:00Z\", \"2024-04-10T07:30:00Z\", {\n+          in: tz(\"Asia/Kolkata\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isSameHour(\"2024-04-10T07:30:00Z\", \"2024-04-10T08:00:00Z\", {\n+          in: tz(\"Asia/Kolkata\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isSameHour(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isSameISOWeek/test.ts b/src/isSameISOWeek/test.ts\nindex 19f2ec3e15..50b3673422 100644\n--- a/src/isSameISOWeek/test.ts\n+++ b/src/isSameISOWeek/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isSameISOWeek } from \"./index.js\";\n \n describe(\"isSameISOWeek\", () => {\n@@ -46,4 +48,45 @@ describe(\"isSameISOWeek\", () => {\n     const result = isSameISOWeek(new Date(NaN), new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      isSameISOWeek(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 8, 2, 0, \"America/New_York\");\n+    const dateRight = new TZDate(2024, 8, 9, 4, \"Europe/London\");\n+    expect(isSameISOWeek(dateLeft, dateRight)).toBe(true);\n+    expect(isSameISOWeek(dateRight, dateLeft)).toBe(false);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isSameISOWeek(\"2024-08-19T00:00:00Z\", \"2024-08-19T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isSameISOWeek(\"2024-08-19T00:00:00Z\", \"2024-08-19T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isSameISOWeek(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isSameISOWeekYear/test.ts b/src/isSameISOWeekYear/test.ts\nindex fe1228a1ed..ace285c25d 100644\n--- a/src/isSameISOWeekYear/test.ts\n+++ b/src/isSameISOWeekYear/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isSameISOWeekYear } from \"./index.js\";\n \n describe(\"isSameISOWeekYear\", () => {\n@@ -53,8 +55,59 @@ describe(\"isSameISOWeekYear\", () => {\n     expect(result).toBe(false);\n   });\n \n-  it(\"returns false if the both dates are `Invalid Date`\", () => {\n+  it(\"returns false if both dates are `Invalid Date`\", () => {\n     const result = isSameISOWeekYear(new Date(NaN), new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      isSameISOWeekYear(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2023, 11, 31, 23, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2023, 11, 31, 12, \"America/New_York\");\n+    expect(isSameISOWeekYear(dateLeft, dateRight)).toBe(false);\n+    expect(isSameISOWeekYear(dateRight, dateLeft)).toBe(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isSameISOWeekYear(\"2023-12-31T00:00:00Z\", \"2023-12-31T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isSameISOWeekYear(\"2023-12-31T00:00:00Z\", \"2023-12-31T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isSameISOWeekYear(\"2024-01-01T00:00:00Z\", \"2024-01-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isSameISOWeekYear(\"2024-01-01T00:00:00Z\", \"2024-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isSameISOWeekYear(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isSameMonth/test.ts b/src/isSameMonth/test.ts\nindex ed63b67cbb..16ecdcf208 100644\n--- a/src/isSameMonth/test.ts\n+++ b/src/isSameMonth/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isSameMonth } from \"./index.js\";\n \n describe(\"isSameMonth\", () => {\n@@ -40,4 +42,45 @@ describe(\"isSameMonth\", () => {\n     const result = isSameMonth(new Date(NaN), new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2023, 11, 31, 23, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2023, 11, 31, 12, \"America/New_York\");\n+    expect(isSameMonth(dateLeft, dateRight)).toBe(false);\n+    expect(isSameMonth(dateRight, dateLeft)).toBe(true);\n+  });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      isSameMonth(arg1, arg2);\n+    }\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isSameMonth(\"2014-09-02T15:00:00Z\", \"2014-09-25T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isSameMonth(\"2014-09-02T15:00:00Z\", \"2015-09-02T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isSameMonth(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isSameQuarter/test.ts b/src/isSameQuarter/test.ts\nindex c09fc18f76..4087f256db 100644\n--- a/src/isSameQuarter/test.ts\n+++ b/src/isSameQuarter/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isSameQuarter } from \"./index.js\";\n \n describe(\"isSameQuarter\", () => {\n@@ -46,4 +48,61 @@ describe(\"isSameQuarter\", () => {\n     const result = isSameQuarter(new Date(NaN), new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      isSameQuarter(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 3, 1, \"Asia/Singapore\");\n+    const dateRight = new TZDate(2024, 2, 31, \"America/New_York\");\n+    expect(isSameQuarter(dateLeft, dateRight)).toBe(false);\n+    expect(isSameQuarter(dateRight, dateLeft)).toBe(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isSameQuarter(\"2024-09-30T16:00:00Z\", \"2024-09-31T00:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isSameQuarter(\"2024-09-30T15:00:00Z\", \"2024-09-31T00:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isSameQuarter(\"2024-10-01T04:00:00Z\", \"2024-10-02T00:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isSameQuarter(\"2024-10-01T03:00:00Z\", \"2024-10-02T00:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<\n+        DateType extends Date,\n+        ContextDate extends Date = DateType,\n+      >(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ContextDate>,\n+      ) {\n+        isSameQuarter(arg1, arg2, { in: options?.in });\n+      }\n+      _test(\"2014-02-11T00:00:00.000Z\", \"2014-05-18T00:00:00.000Z\", {\n+        in: tz(\"Asia/Singapore\"),\n+      });\n+    });\n+  });\n });\ndiff --git a/src/isSameWeek/test.ts b/src/isSameWeek/test.ts\nindex 0b7b347ef9..316667e480 100644\n--- a/src/isSameWeek/test.ts\n+++ b/src/isSameWeek/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isSameWeek } from \"./index.js\";\n \n describe(\"isSameWeek\", () => {\n@@ -76,4 +78,48 @@ describe(\"isSameWeek\", () => {\n     const result = isSameWeek(new Date(NaN), new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  it(\"allows dates to be of different types\", () => {\n+    function _test<DateType1 extends Date, DateType2 extends Date>(\n+      arg1: DateType1 | number | string,\n+      arg2: DateType2 | number | string,\n+    ) {\n+      isSameWeek(arg1, arg2);\n+    }\n+  });\n+\n+  it(\"normalizes the dates\", () => {\n+    const dateLeft = new TZDate(2024, 8, 2, 0, \"America/New_York\");\n+    const dateRight = new TZDate(2024, 8, 9, 4, \"Europe/London\");\n+    expect(isSameWeek(dateLeft, dateRight, { weekStartsOn: 1 })).toBe(true);\n+    expect(isSameWeek(dateRight, dateLeft, { weekStartsOn: 1 })).toBe(false);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isSameWeek(\"2024-08-24T15:00:00Z\", \"2024-08-24T18:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isSameWeek(\"2024-08-24T16:00:00Z\", \"2024-08-24T18:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<\n+        DateType extends Date,\n+        ContextDate extends Date = DateType,\n+      >(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ContextDate>,\n+      ) {\n+        isSameWeek(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isSameYear/test.ts b/src/isSameYear/test.ts\nindex df17516a76..c531edd70b 100644\n--- a/src/isSameYear/test.ts\n+++ b/src/isSameYear/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isSameYear } from \"./index.js\";\n \n describe(\"isSameYear\", () => {\n@@ -40,4 +42,29 @@ describe(\"isSameYear\", () => {\n     const result = isSameYear(new Date(NaN), new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isSameYear(\"2023-12-31T15:00:00Z\", \"2023-12-31T21:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isSameYear(\"2023-12-31T16:00:00Z\", \"2024-08-23T00:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isSameYear(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isSaturday/test.ts b/src/isSaturday/test.ts\nindex 1f0cf77371..0ef80acd59 100644\n--- a/src/isSaturday/test.ts\n+++ b/src/isSaturday/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isSaturday } from \"./index.js\";\n \n describe(\"isSaturday\", () => {\n@@ -21,4 +23,38 @@ describe(\"isSaturday\", () => {\n     const result = isSaturday(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isSaturday(\"2024-08-16T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isSaturday(\"2024-08-16T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isSaturday(\"2024-08-17T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isSaturday(\"2024-08-17T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isSaturday(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isSunday/test.ts b/src/isSunday/test.ts\nindex 57ec993145..7993f107e7 100644\n--- a/src/isSunday/test.ts\n+++ b/src/isSunday/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isSunday } from \"./index.js\";\n \n describe(\"isSunday\", () => {\n@@ -21,4 +23,38 @@ describe(\"isSunday\", () => {\n     const result = isSunday(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isSunday(\"2024-08-18T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isSunday(\"2024-08-18T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isSunday(\"2024-08-18T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isSunday(\"2024-08-18T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isSunday(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isThisHour/test.ts b/src/isThisHour/test.ts\nindex 83eb16a779..e97c7d331b 100644\n--- a/src/isThisHour/test.ts\n+++ b/src/isThisHour/test.ts\n@@ -1,19 +1,14 @@\n+import { tz } from \"@date-fns/tz\";\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n+import { type DateFns } from \"../types.js\";\n import { isThisHour } from \"./index.js\";\n \n describe(\"isThisHour\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(\n-      new Date(2014, 8 /* Sep */, 25, 18, 15, 15, 500).getTime(),\n-    );\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  const { fakeNow } = fakeDate(\n+    new Date(2014, 8 /* Sep */, 25, 18, 15, 15, 500),\n+  );\n \n   it(\"returns true if the given date and the current date have the same hour\", () => {\n     const date = new Date(2014, 8 /* Sep */, 25, 18);\n@@ -35,4 +30,24 @@ describe(\"isThisHour\", () => {\n       true,\n     );\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2014-09-25T16:00:00Z\"));\n+      const in30Minutes = Date.now() + 30 * 60 * 1000;\n+      expect(isThisHour(in30Minutes, { in: tz(\"America/Los_Angeles\") })).toBe(\n+        true,\n+      );\n+      expect(isThisHour(in30Minutes, { in: tz(\"Asia/Kolkata\") })).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isThisHour(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isThisISOWeek/test.ts b/src/isThisISOWeek/test.ts\nindex 43259b826f..150eaf2b81 100644\n--- a/src/isThisISOWeek/test.ts\n+++ b/src/isThisISOWeek/test.ts\n@@ -1,17 +1,11 @@\n-import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { tz } from \"@date-fns/tz\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n+import { type DateFns } from \"../types.js\";\n import { isThisISOWeek } from \"./index.js\";\n \n-describe(\"isSameISOWeek\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(2014, 8 /* Sep */, 25).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+describe(\"isThisISOWeek\", () => {\n+  const { fakeNow } = fakeDate(new Date(2014, 8 /* Sep */, 25));\n \n   it(\"returns true if the given date and the current date have the same ISO week\", () => {\n     const date = new Date(2014, 8 /* Sep */, 22);\n@@ -29,8 +23,33 @@ describe(\"isSameISOWeek\", () => {\n   });\n \n   it(\"respects date extensions\", () => {\n-    expect(isThisISOWeek(new UTCDate(+new Date(2014, 8 /* Sep */, 25)))).toBe(\n+    expect(isThisISOWeek(new Date(+new Date(2014, 8 /* Sep */, 25)))).toBe(\n       true,\n     );\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2024-08-20T00:00:00Z\"));\n+      expect(\n+        isThisISOWeek(\"2024-08-19T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isThisISOWeek(\"2024-08-19T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isThisISOWeek(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isThisMinute/test.ts b/src/isThisMinute/test.ts\nindex 3d73a32040..61ff74e57f 100644\n--- a/src/isThisMinute/test.ts\n+++ b/src/isThisMinute/test.ts\n@@ -1,19 +1,10 @@\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n import { isThisMinute } from \"./index.js\";\n \n describe(\"isThisMinute\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(\n-      new Date(2014, 8 /* Sep */, 25, 18, 30, 15, 500).getTime(),\n-    );\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  fakeDate(new Date(2014, 8 /* Sep */, 25, 18, 30, 15, 500));\n \n   it(\"returns true if the given date and the current date have the same minute\", () => {\n     const date = new Date(2014, 8 /* Sep */, 25, 18, 30);\ndiff --git a/src/isThisMonth/test.ts b/src/isThisMonth/test.ts\nindex ee74a95fc8..ccac3ad70d 100644\n--- a/src/isThisMonth/test.ts\n+++ b/src/isThisMonth/test.ts\n@@ -1,17 +1,12 @@\n+import { tz } from \"@date-fns/tz\";\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n+import { type DateFns } from \"../types.js\";\n import { isThisMonth } from \"./index.js\";\n \n describe(\"isThisMonth\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(2014, 8 /* Sep */, 1).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  const { fakeNow } = fakeDate(new Date(2014, 8 /* Sep */, 1));\n \n   it(\"returns true if the given date and the current date have the same month (and year)\", () => {\n     const date = new Date(2014, 8 /* Sep */, 15);\n@@ -33,4 +28,29 @@ describe(\"isThisMonth\", () => {\n       true,\n     );\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2014-09-02T00:00:00Z\"));\n+      expect(\n+        isThisMonth(\"2014-09-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isThisMonth(\"2014-09-01T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isThisMonth(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isThisQuarter/test.ts b/src/isThisQuarter/test.ts\nindex af0d17a5aa..2981e37c47 100644\n--- a/src/isThisQuarter/test.ts\n+++ b/src/isThisQuarter/test.ts\n@@ -1,17 +1,12 @@\n+import { tz } from \"@date-fns/tz\";\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n+import { type DateFns } from \"../types.js\";\n import { isThisQuarter } from \"./index.js\";\n \n describe(\"isThisQuarter\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(2014, 6 /* Jul */, 1).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  const { fakeNow } = fakeDate(new Date(2014, 6 /* Jul */, 1));\n \n   it(\"returns true if the given date and the current date have the same quarter (and year)\", () => {\n     const date = new Date(2014, 6 /* Jul */, 2);\n@@ -33,4 +28,29 @@ describe(\"isThisQuarter\", () => {\n       true,\n     );\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2024-01-02T00:00:00Z\"));\n+      expect(\n+        isThisQuarter(\"2024-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isThisQuarter(\"2024-01-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isThisQuarter(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isThisSecond/test.ts b/src/isThisSecond/test.ts\nindex eb1027f0d2..cb3190002f 100644\n--- a/src/isThisSecond/test.ts\n+++ b/src/isThisSecond/test.ts\n@@ -1,19 +1,10 @@\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n import { isThisSecond } from \"./index.js\";\n \n describe(\"isThisSecond\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(\n-      new Date(2014, 8 /* Sep */, 25, 18, 30, 15, 500).getTime(),\n-    );\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  fakeDate(new Date(2014, 8 /* Sep */, 25, 18, 30, 15, 500));\n \n   it(\"returns true if the given date and the current date have the same second\", () => {\n     const date = new Date(2014, 8 /* Sep */, 25, 18, 30, 15);\ndiff --git a/src/isThisWeek/test.ts b/src/isThisWeek/test.ts\nindex 8bb009ff5a..bb81a02797 100644\n--- a/src/isThisWeek/test.ts\n+++ b/src/isThisWeek/test.ts\n@@ -1,17 +1,12 @@\n+import { tz } from \"@date-fns/tz\";\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n+import { type DateFns } from \"../types.js\";\n import { isThisWeek } from \"./index.js\";\n \n describe(\"isThisWeek\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(2014, 8 /* Sep */, 21).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  const { fakeNow } = fakeDate(new Date(2014, 8 /* Sep */, 21));\n \n   it(\"returns true if the given date and the current date have the same week\", () => {\n     const date = new Date(2014, 8 /* Sep */, 21);\n@@ -38,4 +33,29 @@ describe(\"isThisWeek\", () => {\n       true,\n     );\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows specifying the context\", () => {\n+      fakeNow(new Date(\"2024-08-20T00:00:00Z\"));\n+      expect(\n+        isThisWeek(\"2024-08-18T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isThisWeek(\"2024-08-18T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isThisWeek(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isThisYear/test.ts b/src/isThisYear/test.ts\nindex c8fd2ff2af..460d44ab4d 100644\n--- a/src/isThisYear/test.ts\n+++ b/src/isThisYear/test.ts\n@@ -1,17 +1,12 @@\n+import { tz } from \"@date-fns/tz\";\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n+import { type DateFns } from \"../types.js\";\n import { isThisYear } from \"./index.js\";\n \n describe(\"isThisYear\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(2014, 0 /* Jan */, 1).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  const { fakeNow } = fakeDate(new Date(2014, 0 /* Jan */, 1));\n \n   it(\"returns true if the given date and the current date have the same year\", () => {\n     const date = new Date(2014, 6 /* Jul */, 2);\n@@ -31,4 +26,29 @@ describe(\"isThisYear\", () => {\n   it(\"respects date extensions\", () => {\n     expect(isThisYear(new UTCDate(+new Date(2014, 0 /* Jan */, 1)))).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2024-01-02T00:00:00Z\"));\n+      expect(\n+        isThisYear(\"2024-01-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isThisYear(\"2024-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isThisYear(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isThursday/test.ts b/src/isThursday/test.ts\nindex 99abb1095e..adfe516d04 100644\n--- a/src/isThursday/test.ts\n+++ b/src/isThursday/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isThursday } from \"./index.js\";\n \n describe(\"isThursday\", () => {\n@@ -21,4 +23,24 @@ describe(\"isThursday\", () => {\n     const result = isThursday(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isThursday(\"2024-08-22T03:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(false);\n+      expect(\n+        isThursday(\"2024-08-22T04:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isThursday(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isToday/test.ts b/src/isToday/test.ts\nindex b0dca6a3d4..641d0b7cb0 100644\n--- a/src/isToday/test.ts\n+++ b/src/isToday/test.ts\n@@ -1,17 +1,11 @@\n-import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { tz } from \"@date-fns/tz\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n+import { type DateFns } from \"../types.js\";\n import { isToday } from \"./index.js\";\n \n describe(\"isToday\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(2014, 8 /* Sep */, 25).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  const { fakeNow } = fakeDate(new Date(2014, 8 /* Sep */, 25));\n \n   it(\"returns true if the given date is today\", () => {\n     const result = isToday(new Date(2014, 8 /* Sep */, 25));\n@@ -28,7 +22,24 @@ describe(\"isToday\", () => {\n     expect(result).toBe(true);\n   });\n \n-  it(\"respects date extensions\", () => {\n-    expect(isToday(new UTCDate(+new Date(2014, 8 /* Sep */, 25)))).toBe(true);\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2024-08-18T15:00:00Z\"));\n+      expect(\n+        isToday(\"2024-08-18T04:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(true);\n+      expect(\n+        isToday(\"2024-08-18T03:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isToday(arg, { in: options?.in });\n+      }\n+    });\n   });\n });\ndiff --git a/src/isTomorrow/test.ts b/src/isTomorrow/test.ts\nindex 8117fa7dc1..2c4402aad7 100644\n--- a/src/isTomorrow/test.ts\n+++ b/src/isTomorrow/test.ts\n@@ -1,17 +1,12 @@\n+import { tz } from \"@date-fns/tz\";\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n+import { type DateFns } from \"../types.js\";\n import { isTomorrow } from \"./index.js\";\n \n describe(\"isTomorrow\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(2014, 8 /* Aug */, 25).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  const { fakeNow } = fakeDate(new Date(2014, 8 /* Sep */, 25));\n \n   it(\"returns true if the given date is tomorrow\", () => {\n     const result = isTomorrow(new Date(2014, 8 /* Sep */, 26));\n@@ -33,4 +28,25 @@ describe(\"isTomorrow\", () => {\n       true,\n     );\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2024-08-18T15:00:00Z\"));\n+      expect(\n+        isTomorrow(\"2024-08-19T04:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(true);\n+      expect(\n+        isTomorrow(\"2024-08-19T03:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isTomorrow(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isTuesday/test.ts b/src/isTuesday/test.ts\nindex fe8947498f..44028a881a 100644\n--- a/src/isTuesday/test.ts\n+++ b/src/isTuesday/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isTuesday } from \"./index.js\";\n \n describe(\"isTuesday\", () => {\n@@ -21,4 +23,38 @@ describe(\"isTuesday\", () => {\n     const result = isTuesday(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isTuesday(\"2024-08-19T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isTuesday(\"2024-08-19T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isTuesday(\"2024-08-20T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isTuesday(\"2024-08-20T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isTuesday(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isWednesday/test.ts b/src/isWednesday/test.ts\nindex 4cfecd3a13..765ad65108 100644\n--- a/src/isWednesday/test.ts\n+++ b/src/isWednesday/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isWednesday } from \"./index.js\";\n \n describe(\"isWednesday\", () => {\n@@ -21,4 +23,28 @@ describe(\"isWednesday\", () => {\n     const result = isWednesday(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isWednesday(\"2024-08-21T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isWednesday(\"2024-08-21T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isWednesday(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isWeekend/test.ts b/src/isWeekend/test.ts\nindex 659ca13346..61178d48a5 100644\n--- a/src/isWeekend/test.ts\n+++ b/src/isWeekend/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { type DateFns } from \"../types.js\";\n import { isWeekend } from \"./index.js\";\n \n describe(\"isWeekend\", () => {\n@@ -21,4 +23,38 @@ describe(\"isWeekend\", () => {\n     const result = isWeekend(new Date(NaN));\n     expect(result).toBe(false);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        isWeekend(\"2024-08-18T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isWeekend(\"2024-08-19T01:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isWeekend(\"2024-08-17T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(false);\n+      expect(\n+        isWeekend(\"2024-08-17T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }),\n+      ).toBe(true);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isWeekend(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isWithinInterval/test.ts b/src/isWithinInterval/test.ts\nindex 4adc1e32de..c2accd2b20 100644\n--- a/src/isWithinInterval/test.ts\n+++ b/src/isWithinInterval/test.ts\n@@ -1,4 +1,6 @@\n+import { tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import type { DateFns, Interval } from \"../types.js\";\n import { isWithinInterval } from \"./index.js\";\n \n describe(\"isWithinInterval\", () => {\n@@ -89,4 +91,33 @@ describe(\"isWithinInterval\", () => {\n     });\n     expect(result).toBe(true);\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const interval = {\n+        start: \"2024-04-10T00:00:00+08:00\",\n+        end: \"2024-04-10T23:59:59+08:00\",\n+      };\n+      expect(\n+        isWithinInterval(\"2024-04-09T16:00:00Z\", interval, {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(true);\n+      expect(\n+        isWithinInterval(\"2024-04-09T15:00:00Z\", interval, {\n+          in: tz(\"Asia/Singapore\"),\n+        }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg1: DateType | number | string,\n+        arg2: Interval<DateType>,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isWithinInterval(arg1, arg2, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/isYesterday/test.ts b/src/isYesterday/test.ts\nindex da6596e1ce..9d47518c67 100644\n--- a/src/isYesterday/test.ts\n+++ b/src/isYesterday/test.ts\n@@ -1,17 +1,12 @@\n+import { tz } from \"@date-fns/tz\";\n import { UTCDate } from \"@date-fns/utc\";\n-import sinon from \"sinon\";\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n+import { describe, expect, it } from \"vitest\";\n+import { fakeDate } from \"../_lib/test/index.js\";\n+import { type DateFns } from \"../types.js\";\n import { isYesterday } from \"./index.js\";\n \n describe(\"isYesterday\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(new Date(2014, 8 /* Aug */, 25).getTime());\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  const { fakeNow } = fakeDate(new Date(2014, 8 /* Sep */, 25));\n \n   it(\"returns true if the given date is yesterday\", () => {\n     const result = isYesterday(new Date(2014, 8 /* Sep */, 24));\n@@ -29,8 +24,29 @@ describe(\"isYesterday\", () => {\n   });\n \n   it(\"respects date extensions\", () => {\n-    expect(isYesterday(new UTCDate(+new Date(2014, 8 /* Aug */, 24)))).toBe(\n+    expect(isYesterday(new UTCDate(+new Date(2014, 8 /* Sep */, 24)))).toBe(\n       true,\n     );\n   });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2024-08-18T15:00:00Z\"));\n+      expect(\n+        isYesterday(\"2024-08-17T04:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(true);\n+      expect(\n+        isYesterday(\"2024-08-17T03:00:00Z\", { in: tz(\"America/New_York\") }),\n+      ).toBe(false);\n+    });\n+\n+    it(\"doesn't enforce argument and context to be of the same type\", () => {\n+      function _test<DateType extends Date, ResultDate extends Date = DateType>(\n+        arg: DateType | number | string,\n+        options?: DateFns.ContextOptions<ResultDate>,\n+      ) {\n+        isYesterday(arg, { in: options?.in });\n+      }\n+    });\n+  });\n });\ndiff --git a/src/lastDayOfDecade/test.ts b/src/lastDayOfDecade/test.ts\nindex ba4d9609ea..359f160362 100644\n--- a/src/lastDayOfDecade/test.ts\n+++ b/src/lastDayOfDecade/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { lastDayOfDecade } from \"./index.js\";\n \n describe(\"lastDayOfDecade\", () => {\n@@ -33,4 +36,50 @@ describe(\"lastDayOfDecade\", () => {\n       new Date(-2001, 11, 31),\n     );\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = lastDayOfDecade(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = lastDayOfDecade(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        lastDayOfDecade(\"1999-12-31T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"1999-12-31T00:00:00.000+08:00\");\n+      expect(\n+        lastDayOfDecade(\"1999-12-31T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2009-12-31T00:00:00.000+08:00\");\n+      expect(\n+        lastDayOfDecade(\"2000-01-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"1999-12-31T00:00:00.000-05:00\");\n+      expect(\n+        lastDayOfDecade(\"2000-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2009-12-31T00:00:00.000-05:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2000-01-01T00:00:00Z\");\n+      const result = lastDayOfDecade(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/lastDayOfISOWeek/test.ts b/src/lastDayOfISOWeek/test.ts\nindex 16c6e6520e..fc3d96f657 100644\n--- a/src/lastDayOfISOWeek/test.ts\n+++ b/src/lastDayOfISOWeek/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { lastDayOfISOWeek } from \"./index.js\";\n \n describe(\"lastDayOfISOWeek\", () => {\n@@ -24,4 +27,49 @@ describe(\"lastDayOfISOWeek\", () => {\n     const result = lastDayOfISOWeek(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = lastDayOfISOWeek(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = lastDayOfISOWeek(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        lastDayOfISOWeek(\"2024-09-01T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-09-01T00:00:00.000+08:00\");\n+      expect(\n+        lastDayOfISOWeek(\"2024-09-01T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-09-08T00:00:00.000+08:00\");\n+      expect(\n+        lastDayOfISOWeek(\"2024-09-02T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-09-01T00:00:00.000-04:00\");\n+      expect(\n+        lastDayOfISOWeek(\"2024-09-02T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-09-08T00:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = lastDayOfISOWeek(\"2014-09-02T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/lastDayOfISOWeekYear/test.ts b/src/lastDayOfISOWeekYear/test.ts\nindex 00fcba8583..d541363a47 100644\n--- a/src/lastDayOfISOWeekYear/test.ts\n+++ b/src/lastDayOfISOWeekYear/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { lastDayOfISOWeekYear } from \"./index.js\";\n \n describe(\"lastDayOfISOWeekYear\", () => {\n@@ -35,4 +38,39 @@ describe(\"lastDayOfISOWeekYear\", () => {\n     const result = lastDayOfISOWeekYear(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = lastDayOfISOWeekYear(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = lastDayOfISOWeekYear(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        lastDayOfISOWeekYear(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-12-29T00:00:00.000+08:00\");\n+      expect(\n+        lastDayOfISOWeekYear(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-12-29T00:00:00.000-08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = lastDayOfISOWeekYear(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/lastDayOfMonth/test.ts b/src/lastDayOfMonth/test.ts\nindex 217281227b..76d3661aa2 100644\n--- a/src/lastDayOfMonth/test.ts\n+++ b/src/lastDayOfMonth/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { lastDayOfMonth } from \"./index.js\";\n \n describe(\"lastDayOfMonth\", () => {\n@@ -38,4 +41,30 @@ describe(\"lastDayOfMonth\", () => {\n     const result = lastDayOfMonth(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = lastDayOfMonth(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = lastDayOfMonth(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const date = \"2023-08-18T15:00:00Z\";\n+      const result = lastDayOfMonth(date, { in: tz(\"Asia/Singapore\") });\n+      expect(result.toISOString()).toBe(\"2023-08-31T00:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = lastDayOfMonth(Date.now(), { in: tz(\"Asia/Singapore\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/lastDayOfQuarter/test.ts b/src/lastDayOfQuarter/test.ts\nindex ceb4fecadb..25530061c8 100644\n--- a/src/lastDayOfQuarter/test.ts\n+++ b/src/lastDayOfQuarter/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { lastDayOfQuarter } from \"./index.js\";\n \n describe(\"lastDayOfQuarter\", () => {\n@@ -24,4 +27,39 @@ describe(\"lastDayOfQuarter\", () => {\n     const result = lastDayOfQuarter(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = lastDayOfQuarter(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = lastDayOfQuarter(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        lastDayOfQuarter(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-06-30T00:00:00.000-07:00\");\n+      expect(\n+        lastDayOfQuarter(\"2024-05-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-06-30T00:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = lastDayOfQuarter(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/lastDayOfWeek/test.ts b/src/lastDayOfWeek/test.ts\nindex 465e59e599..2d7dce7d43 100644\n--- a/src/lastDayOfWeek/test.ts\n+++ b/src/lastDayOfWeek/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { lastDayOfWeek } from \"./index.js\";\n \n describe(\"lastDayOfWeek\", () => {\n@@ -24,7 +27,7 @@ describe(\"lastDayOfWeek\", () => {\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 7));\n   });\n \n-  it(\"`options.weekStartsOn` overwrites the first day of the week specified in locale\", () => {\n+  it(\"options.weekStartsOn overwrites the first day of the week specified in locale\", () => {\n     const date = new Date(2014, 8 /* Sep */, 2, 11, 55, 0);\n     const result = lastDayOfWeek(date, {\n       weekStartsOn: 1,\n@@ -83,4 +86,53 @@ describe(\"lastDayOfWeek\", () => {\n     const result = lastDayOfWeek(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = lastDayOfWeek(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = lastDayOfWeek(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        lastDayOfWeek(\"2024-09-01T15:00:00Z\", {\n+          weekStartsOn: 1,\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-09-01T00:00:00.000+08:00\");\n+      expect(\n+        lastDayOfWeek(\"2024-09-01T16:00:00Z\", {\n+          weekStartsOn: 1,\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-09-08T00:00:00.000+08:00\");\n+      expect(\n+        lastDayOfWeek(\"2024-09-02T03:00:00Z\", {\n+          weekStartsOn: 1,\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-09-01T00:00:00.000-04:00\");\n+      expect(\n+        lastDayOfWeek(\"2024-09-02T04:00:00Z\", {\n+          weekStartsOn: 1,\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-09-08T00:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = lastDayOfWeek(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/lastDayOfYear/test.ts b/src/lastDayOfYear/test.ts\nindex 189c037561..c19a52f502 100644\n--- a/src/lastDayOfYear/test.ts\n+++ b/src/lastDayOfYear/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { lastDayOfYear } from \"./index.js\";\n \n describe(\"lastDayOfYear\", () => {\n@@ -24,4 +27,39 @@ describe(\"lastDayOfYear\", () => {\n     const result = lastDayOfYear(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = lastDayOfYear(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = lastDayOfYear(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        lastDayOfYear(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-12-31T00:00:00.000+08:00\");\n+      expect(\n+        lastDayOfYear(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-12-31T00:00:00.000-08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = lastDayOfYear(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/max/test.ts b/src/max/test.ts\nindex 21a7c05a47..dcba5db8c9 100644\n--- a/src/max/test.ts\n+++ b/src/max/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { max } from \"./index.js\";\n \n describe(\"max\", () => {\n@@ -41,4 +44,36 @@ describe(\"max\", () => {\n     const result = max([]);\n     expect(isNaN(+result)).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = max([Date.now()]);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the first date object type in the array\", () => {\n+    const result = max([Date.now(), \"2024-01-01T00:00:00Z\", new UTCDate()]);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the date union when the array contains more than single date object\", () => {\n+    const result = max([\n+      new Date(),\n+      Date.now(),\n+      \"2024-01-01T00:00:00Z\",\n+      new UTCDate(),\n+    ]);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<UTCDate | Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = max([date], { in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/min/test.ts b/src/min/test.ts\nindex e86fa8c714..209f134fa5 100644\n--- a/src/min/test.ts\n+++ b/src/min/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { min } from \"./index.js\";\n \n describe(\"min\", () => {\n@@ -41,4 +44,36 @@ describe(\"min\", () => {\n     const result = min([]);\n     expect(isNaN(+result)).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = min([Date.now()]);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the first date object type in the array\", () => {\n+    const result = min([Date.now(), \"2024-01-01T00:00:00Z\", new UTCDate()]);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the date union when the array contains more than single date object\", () => {\n+    const result = min([\n+      new Date(),\n+      Date.now(),\n+      \"2024-01-01T00:00:00Z\",\n+      new UTCDate(),\n+    ]);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<UTCDate | Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = min([date], { in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/nextDay/test.ts b/src/nextDay/test.ts\nindex c49f95ab27..77ba32d5d2 100644\n--- a/src/nextDay/test.ts\n+++ b/src/nextDay/test.ts\n@@ -1,44 +1,108 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { nextDay } from \"./index.js\";\n \n describe(\"nextDay\", () => {\n   it(\"returns the following Monday given various dates before the same\", () => {\n-    expect(nextDay(new Date(2020, 2 /* Mar */, 20), 1)).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextDay(new Date(2020, 2 /* Mar */, 20), 1)).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n \n-    expect(nextDay(new Date(2020, 2 /* Mar */, 19), 1)).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextDay(new Date(2020, 2 /* Mar */, 19), 1)).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n \n-    expect(nextDay(new Date(2020, 2 /* Mar */, 18), 1)).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextDay(new Date(2020, 2 /* Mar */, 18), 1)).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n \n-    expect(nextDay(new Date(2020, 2 /* Mar */, 17), 1)).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextDay(new Date(2020, 2 /* Mar */, 17), 1)).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n \n-    expect(nextDay(new Date(2020, 2 /* Mar */, 16), 1)).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextDay(new Date(2020, 2 /* Mar */, 16), 1)).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n \n-    expect(nextDay(new Date(2020, 2 /* Mar */, 22), 1)).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextDay(new Date(2020, 2 /* Mar */, 22), 1)).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n \n-    expect(nextDay(new Date(2020, 4 /* May */, 2), 1)).toEqual(new Date(2020, 4 /* May */, 4));\n+    expect(nextDay(new Date(2020, 4 /* May */, 2), 1)).toEqual(\n+      new Date(2020, 4 /* May */, 4),\n+    );\n   });\n \n   it(\"returns the following Tuesday given the Saturday before it\", () => {\n-    expect(nextDay(new Date(2020, 4 /* May */, 2), 2)).toEqual(new Date(2020, 4 /* May */, 5));\n+    expect(nextDay(new Date(2020, 4 /* May */, 2), 2)).toEqual(\n+      new Date(2020, 4 /* May */, 5),\n+    );\n   });\n \n   it(\"returns the following Wednesday given the Saturday before it\", () => {\n-    expect(nextDay(new Date(2020, 4 /* May */, 2), 3)).toEqual(new Date(2020, 4 /* May */, 6));\n+    expect(nextDay(new Date(2020, 4 /* May */, 2), 3)).toEqual(\n+      new Date(2020, 4 /* May */, 6),\n+    );\n   });\n \n   it(\"returns the following Thursday given the Saturday before it\", () => {\n-    expect(nextDay(new Date(2020, 4 /* May */, 2), 4)).toEqual(new Date(2020, 4 /* May */, 7));\n+    expect(nextDay(new Date(2020, 4 /* May */, 2), 4)).toEqual(\n+      new Date(2020, 4 /* May */, 7),\n+    );\n   });\n \n   it(\"returns the following Friday given the Saturday before it\", () => {\n-    expect(nextDay(new Date(2020, 4 /* May */, 2), 5)).toEqual(new Date(2020, 4 /* May */, 8));\n+    expect(nextDay(new Date(2020, 4 /* May */, 2), 5)).toEqual(\n+      new Date(2020, 4 /* May */, 8),\n+    );\n   });\n \n   it(\"returns the following Saturday given the Saturday before it\", () => {\n-    expect(nextDay(new Date(2020, 4 /* May */, 2), 6)).toEqual(new Date(2020, 4 /* May */, 9));\n+    expect(nextDay(new Date(2020, 4 /* May */, 2), 6)).toEqual(\n+      new Date(2020, 4 /* May */, 9),\n+    );\n   });\n \n   it(\"returns next Sunday given the day is Sunday\", () => {\n-    expect(nextDay(new Date(2020, 2 /* Mar */, 22), 0)).toEqual(new Date(2020, 2 /* Mar */, 29));\n+    expect(nextDay(new Date(2020, 2 /* Mar */, 22), 0)).toEqual(\n+      new Date(2020, 2 /* Mar */, 29),\n+    );\n+  });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = nextDay(Date.now(), 3);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = nextDay(new UTCDate(), 3);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        nextDay(\"2024-04-10T07:00:00Z\", 1, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-15T15:00:00.000+08:00\");\n+      expect(\n+        nextDay(\"2024-04-10T07:00:00Z\", 1, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-15T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = nextDay(\"2014-09-01T00:00:00Z\", 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n   });\n });\ndiff --git a/src/nextFriday/test.ts b/src/nextFriday/test.ts\nindex 178a3654c3..b58748fb07 100644\n--- a/src/nextFriday/test.ts\n+++ b/src/nextFriday/test.ts\n@@ -1,24 +1,76 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { nextFriday } from \"./index.js\";\n \n describe(\"nextFriday\", () => {\n   it(\"returns the following Friday given various dates before the same\", () => {\n-    expect(nextFriday(new Date(2020, 4 /* May */, 23))).toEqual(new Date(2020, 4 /* May */, 29));\n+    expect(nextFriday(new Date(2020, 4 /* May */, 23))).toEqual(\n+      new Date(2020, 4 /* May */, 29),\n+    );\n \n-    expect(nextFriday(new Date(2020, 4 /* May */, 22))).toEqual(new Date(2020, 4 /* May */, 29));\n+    expect(nextFriday(new Date(2020, 4 /* May */, 22))).toEqual(\n+      new Date(2020, 4 /* May */, 29),\n+    );\n \n-    expect(nextFriday(new Date(2020, 4 /* May */, 21))).toEqual(new Date(2020, 4 /* May */, 22));\n+    expect(nextFriday(new Date(2020, 4 /* May */, 21))).toEqual(\n+      new Date(2020, 4 /* May */, 22),\n+    );\n \n-    expect(nextFriday(new Date(2020, 4 /* May */, 20))).toEqual(new Date(2020, 4 /* May */, 22));\n+    expect(nextFriday(new Date(2020, 4 /* May */, 20))).toEqual(\n+      new Date(2020, 4 /* May */, 22),\n+    );\n \n-    expect(nextFriday(new Date(2020, 4 /* May */, 19))).toEqual(new Date(2020, 4 /* May */, 22));\n+    expect(nextFriday(new Date(2020, 4 /* May */, 19))).toEqual(\n+      new Date(2020, 4 /* May */, 22),\n+    );\n \n-    expect(nextFriday(new Date(2020, 4 /* May */, 18))).toEqual(new Date(2020, 4 /* May */, 22));\n+    expect(nextFriday(new Date(2020, 4 /* May */, 18))).toEqual(\n+      new Date(2020, 4 /* May */, 22),\n+    );\n \n-    expect(nextFriday(new Date(2020, 4 /* May */, 17))).toEqual(new Date(2020, 4 /* May */, 22));\n+    expect(nextFriday(new Date(2020, 4 /* May */, 17))).toEqual(\n+      new Date(2020, 4 /* May */, 22),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(nextFriday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = nextFriday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = nextFriday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        nextFriday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-12T15:00:00.000+08:00\");\n+      expect(\n+        nextFriday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-12T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = nextFriday(\"2024-04-10T07:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/nextMonday/test.ts b/src/nextMonday/test.ts\nindex 1c72daef52..b726c16e08 100644\n--- a/src/nextMonday/test.ts\n+++ b/src/nextMonday/test.ts\n@@ -1,24 +1,76 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { nextMonday } from \"./index.js\";\n \n describe(\"nextMonday\", () => {\n   it(\"returns the following Monday given various dates before the same\", () => {\n-    expect(nextMonday(new Date(2020, 2 /* Mar */, 23))).toEqual(new Date(2020, 2 /* Mar */, 30));\n+    expect(nextMonday(new Date(2020, 2 /* Mar */, 23))).toEqual(\n+      new Date(2020, 2 /* Mar */, 30),\n+    );\n \n-    expect(nextMonday(new Date(2020, 2 /* Mar */, 22))).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextMonday(new Date(2020, 2 /* Mar */, 22))).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n \n-    expect(nextMonday(new Date(2020, 3 /* Apr */, 11))).toEqual(new Date(2020, 3 /* Apr */, 13));\n+    expect(nextMonday(new Date(2020, 3 /* Apr */, 11))).toEqual(\n+      new Date(2020, 3 /* Apr */, 13),\n+    );\n \n-    expect(nextMonday(new Date(2020, 2 /* Mar */, 20))).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextMonday(new Date(2020, 2 /* Mar */, 20))).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n \n-    expect(nextMonday(new Date(2020, 2 /* Mar */, 19))).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextMonday(new Date(2020, 2 /* Mar */, 19))).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n \n-    expect(nextMonday(new Date(2020, 2 /* Mar */, 18))).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextMonday(new Date(2020, 2 /* Mar */, 18))).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n \n-    expect(nextMonday(new Date(2020, 2 /* Mar */, 17))).toEqual(new Date(2020, 2 /* Mar */, 23));\n+    expect(nextMonday(new Date(2020, 2 /* Mar */, 17))).toEqual(\n+      new Date(2020, 2 /* Mar */, 23),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(nextMonday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = nextMonday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = nextMonday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        nextMonday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-15T15:00:00.000+08:00\");\n+      expect(\n+        nextMonday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Kolkata\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-15T12:30:00.000+05:30\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = nextMonday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/nextSaturday/test.ts b/src/nextSaturday/test.ts\nindex 5b678eb434..459a83b3bb 100644\n--- a/src/nextSaturday/test.ts\n+++ b/src/nextSaturday/test.ts\n@@ -1,24 +1,76 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { nextSaturday } from \"./index.js\";\n \n describe(\"nextSaturday\", () => {\n   it(\"returns the following Saturday given various dates before the same\", () => {\n-    expect(nextSaturday(new Date(2020, 4 /* May */, 23))).toEqual(new Date(2020, 4 /* May */, 30));\n+    expect(nextSaturday(new Date(2020, 4 /* May */, 23))).toEqual(\n+      new Date(2020, 4 /* May */, 30),\n+    );\n \n-    expect(nextSaturday(new Date(2020, 4 /* May */, 22))).toEqual(new Date(2020, 4 /* May */, 23));\n+    expect(nextSaturday(new Date(2020, 4 /* May */, 22))).toEqual(\n+      new Date(2020, 4 /* May */, 23),\n+    );\n \n-    expect(nextSaturday(new Date(2020, 4 /* May */, 21))).toEqual(new Date(2020, 4 /* May */, 23));\n+    expect(nextSaturday(new Date(2020, 4 /* May */, 21))).toEqual(\n+      new Date(2020, 4 /* May */, 23),\n+    );\n \n-    expect(nextSaturday(new Date(2020, 4 /* May */, 20))).toEqual(new Date(2020, 4 /* May */, 23));\n+    expect(nextSaturday(new Date(2020, 4 /* May */, 20))).toEqual(\n+      new Date(2020, 4 /* May */, 23),\n+    );\n \n-    expect(nextSaturday(new Date(2020, 4 /* May */, 19))).toEqual(new Date(2020, 4 /* May */, 23));\n+    expect(nextSaturday(new Date(2020, 4 /* May */, 19))).toEqual(\n+      new Date(2020, 4 /* May */, 23),\n+    );\n \n-    expect(nextSaturday(new Date(2020, 4 /* May */, 18))).toEqual(new Date(2020, 4 /* May */, 23));\n+    expect(nextSaturday(new Date(2020, 4 /* May */, 18))).toEqual(\n+      new Date(2020, 4 /* May */, 23),\n+    );\n \n-    expect(nextSaturday(new Date(2020, 4 /* May */, 17))).toEqual(new Date(2020, 4 /* May */, 23));\n+    expect(nextSaturday(new Date(2020, 4 /* May */, 17))).toEqual(\n+      new Date(2020, 4 /* May */, 23),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(nextSaturday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = nextSaturday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = nextSaturday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        nextSaturday(\"2024-04-10T10:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-13T18:00:00.000+08:00\");\n+      expect(\n+        nextSaturday(\"2024-04-10T16:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-13T12:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = nextSaturday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/nextSunday/test.ts b/src/nextSunday/test.ts\nindex 8fc4d87edc..9ddb5690ce 100644\n--- a/src/nextSunday/test.ts\n+++ b/src/nextSunday/test.ts\n@@ -1,24 +1,70 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { nextSunday } from \"./index.js\";\n \n describe(\"nextSunday\", () => {\n   it(\"returns the following Sunday given various dates before the same\", () => {\n-    expect(nextSunday(new Date(2020, 4 /* May */, 23))).toEqual(new Date(2020, 4 /* May */, 24));\n-\n-    expect(nextSunday(new Date(2020, 4 /* May */, 22))).toEqual(new Date(2020, 4 /* May */, 24));\n-\n-    expect(nextSunday(new Date(2020, 4 /* May */, 21))).toEqual(new Date(2020, 4 /* May */, 24));\n-\n-    expect(nextSunday(new Date(2020, 4 /* May */, 20))).toEqual(new Date(2020, 4 /* May */, 24));\n+    expect(nextSunday(new Date(2020, 4 /* May */, 23))).toEqual(\n+      new Date(2020, 4 /* May */, 24),\n+    );\n+    expect(nextSunday(new Date(2020, 4 /* May */, 22))).toEqual(\n+      new Date(2020, 4 /* May */, 24),\n+    );\n+    expect(nextSunday(new Date(2020, 4 /* May */, 21))).toEqual(\n+      new Date(2020, 4 /* May */, 24),\n+    );\n+    expect(nextSunday(new Date(2020, 4 /* May */, 20))).toEqual(\n+      new Date(2020, 4 /* May */, 24),\n+    );\n+    expect(nextSunday(new Date(2020, 4 /* May */, 19))).toEqual(\n+      new Date(2020, 4 /* May */, 24),\n+    );\n+    expect(nextSunday(new Date(2020, 4 /* May */, 18))).toEqual(\n+      new Date(2020, 4 /* May */, 24),\n+    );\n+    expect(nextSunday(new Date(2020, 4 /* May */, 17))).toEqual(\n+      new Date(2020, 4 /* May */, 24),\n+    );\n+  });\n \n-    expect(nextSunday(new Date(2020, 4 /* May */, 19))).toEqual(new Date(2020, 4 /* May */, 24));\n+  it(\"returns `Invalid Date` if the given date is invalid\", () => {\n+    expect(nextSunday(new Date(NaN)) instanceof Date).toBe(true);\n+  });\n \n-    expect(nextSunday(new Date(2020, 4 /* May */, 18))).toEqual(new Date(2020, 4 /* May */, 24));\n+  it(\"resolves the date type by default\", () => {\n+    const result = nextSunday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n \n-    expect(nextSunday(new Date(2020, 4 /* May */, 17))).toEqual(new Date(2020, 4 /* May */, 24));\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = nextSunday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n   });\n \n-  it(\"returns `Invalid Date` if the given date is invalid\", () => {\n-    expect(nextSunday(new Date(NaN)) instanceof Date).toBe(true);\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        nextSunday(\"2024-04-12T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-14T15:00:00.000+08:00\");\n+      expect(\n+        nextSunday(\"2024-04-12T07:00:00Z\", {\n+          in: tz(\"Asia/Calcutta\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-14T12:30:00.000+05:30\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = nextSunday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n   });\n });\ndiff --git a/src/nextThursday/test.ts b/src/nextThursday/test.ts\nindex 3d6842a7ad..c9392ff811 100644\n--- a/src/nextThursday/test.ts\n+++ b/src/nextThursday/test.ts\n@@ -1,24 +1,76 @@\n+import { tz, TZDate } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { nextThursday } from \"./index.js\";\n \n describe(\"nextThursday\", () => {\n   it(\"returns the following Thursday given various dates before the same\", () => {\n-    expect(nextThursday(new Date(2020, 4 /* May */, 23))).toEqual(new Date(2020, 4 /* May */, 28));\n+    expect(nextThursday(new Date(2020, 4 /* May */, 23))).toEqual(\n+      new Date(2020, 4 /* May */, 28),\n+    );\n \n-    expect(nextThursday(new Date(2020, 4 /* May */, 22))).toEqual(new Date(2020, 4 /* May */, 28));\n+    expect(nextThursday(new Date(2020, 4 /* May */, 22))).toEqual(\n+      new Date(2020, 4 /* May */, 28),\n+    );\n \n-    expect(nextThursday(new Date(2020, 4 /* May */, 21))).toEqual(new Date(2020, 4 /* May */, 28));\n+    expect(nextThursday(new Date(2020, 4 /* May */, 21))).toEqual(\n+      new Date(2020, 4 /* May */, 28),\n+    );\n \n-    expect(nextThursday(new Date(2020, 4 /* May */, 20))).toEqual(new Date(2020, 4 /* May */, 21));\n+    expect(nextThursday(new Date(2020, 4 /* May */, 20))).toEqual(\n+      new Date(2020, 4 /* May */, 21),\n+    );\n \n-    expect(nextThursday(new Date(2020, 4 /* May */, 19))).toEqual(new Date(2020, 4 /* May */, 21));\n+    expect(nextThursday(new Date(2020, 4 /* May */, 19))).toEqual(\n+      new Date(2020, 4 /* May */, 21),\n+    );\n \n-    expect(nextThursday(new Date(2020, 4 /* May */, 18))).toEqual(new Date(2020, 4 /* May */, 21));\n+    expect(nextThursday(new Date(2020, 4 /* May */, 18))).toEqual(\n+      new Date(2020, 4 /* May */, 21),\n+    );\n \n-    expect(nextThursday(new Date(2020, 4 /* May */, 17))).toEqual(new Date(2020, 4 /* May */, 21));\n+    expect(nextThursday(new Date(2020, 4 /* May */, 17))).toEqual(\n+      new Date(2020, 4 /* May */, 21),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(nextThursday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = nextThursday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = nextThursday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        nextThursday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-11T15:00:00.000+08:00\");\n+      expect(\n+        nextThursday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-11T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = nextThursday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/nextTuesday/test.ts b/src/nextTuesday/test.ts\nindex 3ac71a97b7..28df7019a5 100644\n--- a/src/nextTuesday/test.ts\n+++ b/src/nextTuesday/test.ts\n@@ -1,23 +1,76 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { nextTuesday } from \"./index.js\";\n \n describe(\"nextTuesday\", () => {\n   it(\"returns the following Tuesday given various dates before the same\", () => {\n-    expect(nextTuesday(new Date(2020, 2 /* Mar */, 23))).toEqual(new Date(2020, 2 /* Mar */, 24));\n+    expect(nextTuesday(new Date(2020, 2 /* Mar */, 23))).toEqual(\n+      new Date(2020, 2 /* Mar */, 24),\n+    );\n \n-    expect(nextTuesday(new Date(2020, 2 /* Mar */, 22))).toEqual(new Date(2020, 2 /* Mar */, 24));\n+    expect(nextTuesday(new Date(2020, 2 /* Mar */, 22))).toEqual(\n+      new Date(2020, 2 /* Mar */, 24),\n+    );\n \n-    expect(nextTuesday(new Date(2020, 3 /* Apr */, 11))).toEqual(new Date(2020, 3 /* Apr */, 14));\n+    expect(nextTuesday(new Date(2020, 3 /* Apr */, 11))).toEqual(\n+      new Date(2020, 3 /* Apr */, 14),\n+    );\n \n-    expect(nextTuesday(new Date(2020, 2 /* Mar */, 20))).toEqual(new Date(2020, 2 /* Mar */, 24));\n+    expect(nextTuesday(new Date(2020, 2 /* Mar */, 20))).toEqual(\n+      new Date(2020, 2 /* Mar */, 24),\n+    );\n \n-    expect(nextTuesday(new Date(2020, 2 /* Mar */, 19))).toEqual(new Date(2020, 2 /* Mar */, 24));\n+    expect(nextTuesday(new Date(2020, 2 /* Mar */, 19))).toEqual(\n+      new Date(2020, 2 /* Mar */, 24),\n+    );\n \n-    expect(nextTuesday(new Date(2020, 2 /* Mar */, 18))).toEqual(new Date(2020, 2 /* Mar */, 24));\n+    expect(nextTuesday(new Date(2020, 2 /* Mar */, 18))).toEqual(\n+      new Date(2020, 2 /* Mar */, 24),\n+    );\n \n-    expect(nextTuesday(new Date(2020, 2 /* Mar */, 17))).toEqual(new Date(2020, 2 /* Mar */, 24));\n+    expect(nextTuesday(new Date(2020, 2 /* Mar */, 17))).toEqual(\n+      new Date(2020, 2 /* Mar */, 24),\n+    );\n   });\n+\n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(nextTuesday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = nextTuesday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = nextTuesday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        nextTuesday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-16T15:00:00.000+08:00\");\n+      expect(\n+        nextTuesday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-16T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = nextTuesday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/nextWednesday/test.ts b/src/nextWednesday/test.ts\nindex 5c69c3a47a..a1b87569e1 100644\n--- a/src/nextWednesday/test.ts\n+++ b/src/nextWednesday/test.ts\n@@ -1,24 +1,76 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { nextWednesday } from \"./index.js\";\n \n describe(\"nextWednesday\", () => {\n   it(\"returns the following Wednesday given various dates before the same\", () => {\n-    expect(nextWednesday(new Date(2020, 4 /* May */, 23))).toEqual(new Date(2020, 4 /* May */, 27));\n+    expect(nextWednesday(new Date(2020, 4 /* May */, 23))).toEqual(\n+      new Date(2020, 4 /* May */, 27),\n+    );\n \n-    expect(nextWednesday(new Date(2020, 4 /* May */, 22))).toEqual(new Date(2020, 4 /* May */, 27));\n+    expect(nextWednesday(new Date(2020, 4 /* May */, 22))).toEqual(\n+      new Date(2020, 4 /* May */, 27),\n+    );\n \n-    expect(nextWednesday(new Date(2020, 4 /* May */, 21))).toEqual(new Date(2020, 4 /* May */, 27));\n+    expect(nextWednesday(new Date(2020, 4 /* May */, 21))).toEqual(\n+      new Date(2020, 4 /* May */, 27),\n+    );\n \n-    expect(nextWednesday(new Date(2020, 4 /* May */, 20))).toEqual(new Date(2020, 4 /* May */, 27));\n+    expect(nextWednesday(new Date(2020, 4 /* May */, 20))).toEqual(\n+      new Date(2020, 4 /* May */, 27),\n+    );\n \n-    expect(nextWednesday(new Date(2020, 4 /* May */, 19))).toEqual(new Date(2020, 4 /* May */, 20));\n+    expect(nextWednesday(new Date(2020, 4 /* May */, 19))).toEqual(\n+      new Date(2020, 4 /* May */, 20),\n+    );\n \n-    expect(nextWednesday(new Date(2020, 4 /* May */, 18))).toEqual(new Date(2020, 4 /* May */, 20));\n+    expect(nextWednesday(new Date(2020, 4 /* May */, 18))).toEqual(\n+      new Date(2020, 4 /* May */, 20),\n+    );\n \n-    expect(nextWednesday(new Date(2020, 4 /* May */, 17))).toEqual(new Date(2020, 4 /* May */, 20));\n+    expect(nextWednesday(new Date(2020, 4 /* May */, 17))).toEqual(\n+      new Date(2020, 4 /* May */, 20),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(nextWednesday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = nextWednesday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = nextWednesday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        nextWednesday(\"2024-04-07T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.000+08:00\");\n+      expect(\n+        nextWednesday(\"2024-04-07T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = nextWednesday(\"2024-04-07T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/parse/test.ts b/src/parse/test.ts\nindex ad0f6fed1c..8faf66fa27 100644\n--- a/src/parse/test.ts\n+++ b/src/parse/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { parse } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n \n describe(\"parse\", () => {\n   const referenceDate = new Date(1986, 3 /* Apr */, 4, 10, 32, 0, 900);\n@@ -2471,4 +2474,56 @@ describe(\"parse\", () => {\n       expect(result).toEqual(expected);\n     });\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = parse(\n+      \"2018 hello world July 2nd\",\n+      \"yyyy 'hello world' MMMM do\",\n+      Date.now(),\n+    );\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = parse(\n+      \"2018 hello world July 2nd\",\n+      \"yyyy 'hello world' MMMM do\",\n+      new UTCDate(),\n+    );\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        parse(\n+          \"2018 hello world July 2nd\",\n+          \"yyyy 'hello world' MMMM do\",\n+          \"2024-04-07T00:00:00Z\",\n+          { in: tz(\"Asia/Singapore\") },\n+        ).toISOString(),\n+      ).toBe(\"2018-07-02T00:00:00.000+08:00\");\n+      expect(\n+        parse(\n+          \"2018 hello world July 2nd\",\n+          \"yyyy 'hello world' MMMM do\",\n+          \"2024-04-07T00:00:00Z\",\n+          { in: tz(\"America/Los_Angeles\") },\n+        ).toISOString(),\n+      ).toBe(\"2018-07-02T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = parse(\n+        \"2018 hello world July 2nd\",\n+        \"yyyy 'hello world' MMMM do\",\n+        \"2024-04-07T00:00:00Z\",\n+        { in: tz(\"Asia/Tokyo\") },\n+      );\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/parseISO/test.ts b/src/parseISO/test.ts\nindex 11bc2c5f6c..4061d929ff 100644\n--- a/src/parseISO/test.ts\n+++ b/src/parseISO/test.ts\n@@ -1,4 +1,6 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { parseISO } from \"./index.js\";\n \n describe(\"parseISO\", () => {\n@@ -169,7 +171,9 @@ describe(\"parseISO\", () => {\n \n       it(\"parses float seconds\", () => {\n         const result = parseISO(\"2014-02-11T11:30:30.768\");\n-        expect(result).toEqual(new Date(2014, 1 /* Feb */, 11, 11, 30, 30, 768));\n+        expect(result).toEqual(\n+          new Date(2014, 1 /* Feb */, 11, 11, 30, 30, 768),\n+        );\n       });\n \n       it(\"parses , as decimal mark\", () => {\n@@ -359,4 +363,53 @@ describe(\"parseISO\", () => {\n       expect(isNaN(result.getTime())).toBe(true);\n     });\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = parseISO(\"2014-02-11T11:30:30\");\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        parseISO(\"2024-04-10T00:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T08:00:00.000+08:00\");\n+      expect(\n+        parseISO(\"2024-04-10T00:00:00+10:00\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-09T22:00:00.000+08:00\");\n+      expect(\n+        parseISO(\"2024-04-10T00:00:00\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:00.000+08:00\");\n+      expect(\n+        parseISO(\"2024-04-10T00:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-09T17:00:00.000-07:00\");\n+      expect(\n+        parseISO(\"2024-04-10T00:00:00+10:00\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-09T07:00:00.000-07:00\");\n+      expect(\n+        parseISO(\"2024-04-10T00:00:00\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = parseISO(\"2014-02-11T11:30:30\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/parseJSON/test.ts b/src/parseJSON/test.ts\nindex 53adb664d4..638fd21c49 100644\n--- a/src/parseJSON/test.ts\n+++ b/src/parseJSON/test.ts\n@@ -1,6 +1,8 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import { parseJSON } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { format } from \"../format/index.js\";\n+import { parseJSON } from \"./index.js\";\n \n describe(\"parseJSON\", () => {\n   it(\"parses a formatted new Date() back to UTC - issue 2149\", () => {\n@@ -126,4 +128,33 @@ describe(\"parseJSON\", () => {\n     expect(parseJSON(\"invalid\").toString()).toBe(\"Invalid Date\");\n     expect(parseJSON(\"2020-10-10\").toString()).toBe(\"Invalid Date\");\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = parseJSON(\"2024-04-10T07:00:00Z\");\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        parseJSON(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.000+08:00\");\n+      expect(\n+        parseJSON(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Africa/Cairo\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T09:00:00.000+02:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = parseJSON(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/previousDay/test.ts b/src/previousDay/test.ts\nindex 74e43ca847..106de3a934 100755\n--- a/src/previousDay/test.ts\n+++ b/src/previousDay/test.ts\n@@ -1,42 +1,99 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { previousDay } from \"./index.js\";\n \n describe(\"previousDay\", () => {\n   it(\"returns the previous Monday given various dates after the same\", () => {\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 18), 1)).toEqual(new Date(2021, 5 /* Jun */, 14));\n-\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 17), 1)).toEqual(new Date(2021, 5 /* Jun */, 14));\n-\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 14), 1)).toEqual(new Date(2021, 5 /* Jun */, 7));\n-\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 9), 1)).toEqual(new Date(2021, 5 /* Jun */, 7));\n-\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 8), 1)).toEqual(new Date(2021, 5 /* Jun */, 7));\n-\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 7), 1)).toEqual(new Date(2021, 4 /* May */, 31));\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 18), 1)).toEqual(\n+      new Date(2021, 5 /* Jun */, 14),\n+    );\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 17), 1)).toEqual(\n+      new Date(2021, 5 /* Jun */, 14),\n+    );\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 14), 1)).toEqual(\n+      new Date(2021, 5 /* Jun */, 7),\n+    );\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 9), 1)).toEqual(\n+      new Date(2021, 5 /* Jun */, 7),\n+    );\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 8), 1)).toEqual(\n+      new Date(2021, 5 /* Jun */, 7),\n+    );\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 7), 1)).toEqual(\n+      new Date(2021, 4 /* May */, 31),\n+    );\n   });\n \n   it(\"returns the previous Tuesday given the Saturday after it\", () => {\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 26), 2)).toEqual(new Date(2021, 5 /* Jun */, 22));\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 26), 2)).toEqual(\n+      new Date(2021, 5 /* Jun */, 22),\n+    );\n   });\n \n   it(\"returns the previous Wednesday given the Saturday after it\", () => {\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 26), 3)).toEqual(new Date(2021, 5 /* Jun */, 23));\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 26), 3)).toEqual(\n+      new Date(2021, 5 /* Jun */, 23),\n+    );\n   });\n \n   it(\"returns the previous Thursday given the Saturday after it\", () => {\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 26), 4)).toEqual(new Date(2021, 5 /* Jun */, 24));\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 26), 4)).toEqual(\n+      new Date(2021, 5 /* Jun */, 24),\n+    );\n   });\n \n   it(\"returns the previous Friday given the Saturday after it\", () => {\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 26), 5)).toEqual(new Date(2021, 5 /* Jun */, 25));\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 26), 5)).toEqual(\n+      new Date(2021, 5 /* Jun */, 25),\n+    );\n   });\n \n   it(\"returns the previous Saturday given the Saturday after it\", () => {\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 26), 6)).toEqual(new Date(2021, 5 /* Jun */, 19));\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 26), 6)).toEqual(\n+      new Date(2021, 5 /* Jun */, 19),\n+    );\n   });\n \n   it(\"returns the previous Sunday given the day is Sunday\", () => {\n-    expect(previousDay(new Date(2021, 5 /* Jun */, 27), 0)).toEqual(new Date(2021, 5 /* Jun */, 20));\n+    expect(previousDay(new Date(2021, 5 /* Jun */, 27), 0)).toEqual(\n+      new Date(2021, 5 /* Jun */, 20),\n+    );\n+  });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = previousDay(Date.now(), 1);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = previousDay(new UTCDate(), 1);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        previousDay(\"2024-04-10T07:00:00Z\", 1, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-08T15:00:00.000+08:00\");\n+      expect(\n+        previousDay(\"2024-04-10T07:00:00Z\", 1, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-08T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = previousDay(\"2014-09-01T00:00:00Z\", 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n   });\n });\ndiff --git a/src/previousFriday/test.ts b/src/previousFriday/test.ts\nindex e66c48c0ea..dee514d3dc 100755\n--- a/src/previousFriday/test.ts\n+++ b/src/previousFriday/test.ts\n@@ -1,22 +1,72 @@\n+import { tz, TZDate } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { previousFriday } from \"./index.js\";\n \n describe(\"previousFriday\", () => {\n   it(\"returns the previous Friday given various dates after the same\", () => {\n-    expect(previousFriday(new Date(2021, 5 /* Jun */, 5))).toEqual(new Date(2021, 5 /* Jun */, 4));\n+    expect(previousFriday(new Date(2021, 5 /* Jun */, 5))).toEqual(\n+      new Date(2021, 5 /* Jun */, 4),\n+    );\n \n-    expect(previousFriday(new Date(2021, 5 /* Jun */, 6))).toEqual(new Date(2021, 5 /* Jun */, 4));\n+    expect(previousFriday(new Date(2021, 5 /* Jun */, 6))).toEqual(\n+      new Date(2021, 5 /* Jun */, 4),\n+    );\n \n-    expect(previousFriday(new Date(2021, 5 /* Jun */, 11))).toEqual(new Date(2021, 5 /* Jun */, 4));\n+    expect(previousFriday(new Date(2021, 5 /* Jun */, 11))).toEqual(\n+      new Date(2021, 5 /* Jun */, 4),\n+    );\n \n-    expect(previousFriday(new Date(2021, 5 /* Jun */, 14))).toEqual(new Date(2021, 5 /* Jun */, 11));\n+    expect(previousFriday(new Date(2021, 5 /* Jun */, 14))).toEqual(\n+      new Date(2021, 5 /* Jun */, 11),\n+    );\n \n-    expect(previousFriday(new Date(2021, 5 /* Jun */, 15))).toEqual(new Date(2021, 5 /* Jun */, 11));\n+    expect(previousFriday(new Date(2021, 5 /* Jun */, 15))).toEqual(\n+      new Date(2021, 5 /* Jun */, 11),\n+    );\n \n-    expect(previousFriday(new Date(2021, 5 /* Jun */, 24))).toEqual(new Date(2021, 5 /* Jun */, 18));\n+    expect(previousFriday(new Date(2021, 5 /* Jun */, 24))).toEqual(\n+      new Date(2021, 5 /* Jun */, 18),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(previousFriday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = previousFriday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = previousFriday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        previousFriday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-05T15:00:00.000+08:00\");\n+      expect(\n+        previousFriday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-05T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = previousFriday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/previousMonday/test.ts b/src/previousMonday/test.ts\nindex dbfe05d585..051ecc9448 100755\n--- a/src/previousMonday/test.ts\n+++ b/src/previousMonday/test.ts\n@@ -1,22 +1,72 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { previousMonday } from \"./index.js\";\n \n describe(\"previousMonday\", () => {\n   it(\"returns the previous Monday given various dates after the same\", () => {\n-    expect(previousMonday(new Date(2021, 5 /* Jun */, 5))).toEqual(new Date(2021, 4 /* May */, 31));\n+    expect(previousMonday(new Date(2021, 5 /* Jun */, 5))).toEqual(\n+      new Date(2021, 4 /* May */, 31),\n+    );\n \n-    expect(previousMonday(new Date(2021, 5 /* Jun */, 6))).toEqual(new Date(2021, 4 /* May */, 31));\n+    expect(previousMonday(new Date(2021, 5 /* Jun */, 6))).toEqual(\n+      new Date(2021, 4 /* May */, 31),\n+    );\n \n-    expect(previousMonday(new Date(2021, 5 /* Jun */, 7))).toEqual(new Date(2021, 4 /* May */, 31));\n+    expect(previousMonday(new Date(2021, 5 /* Jun */, 7))).toEqual(\n+      new Date(2021, 4 /* May */, 31),\n+    );\n \n-    expect(previousMonday(new Date(2021, 5 /* Jun */, 14))).toEqual(new Date(2021, 5 /* Jun */, 7));\n+    expect(previousMonday(new Date(2021, 5 /* Jun */, 14))).toEqual(\n+      new Date(2021, 5 /* Jun */, 7),\n+    );\n \n-    expect(previousMonday(new Date(2021, 5 /* Jun */, 15))).toEqual(new Date(2021, 5 /* Jun */, 14));\n+    expect(previousMonday(new Date(2021, 5 /* Jun */, 15))).toEqual(\n+      new Date(2021, 5 /* Jun */, 14),\n+    );\n \n-    expect(previousMonday(new Date(2021, 5 /* Jun */, 16))).toEqual(new Date(2021, 5 /* Jun */, 14));\n+    expect(previousMonday(new Date(2021, 5 /* Jun */, 16))).toEqual(\n+      new Date(2021, 5 /* Jun */, 14),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(previousMonday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = previousMonday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = previousMonday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        previousMonday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-08T15:00:00.000+08:00\");\n+      expect(\n+        previousMonday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-08T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = previousMonday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/previousSaturday/test.ts b/src/previousSaturday/test.ts\nindex 26615dfe1e..b4b685f28c 100755\n--- a/src/previousSaturday/test.ts\n+++ b/src/previousSaturday/test.ts\n@@ -1,22 +1,73 @@\n+import { tz, TZDate } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { previousSaturday } from \"./index.js\";\n \n describe(\"previousSaturday\", () => {\n   it(\"returns the previous Saturday given various dates after the same\", () => {\n-    expect(previousSaturday(new Date(2021, 5 /* Jun */, 7))).toEqual(new Date(2021, 5 /* Jun */, 5));\n+    expect(previousSaturday(new Date(2021, 5 /* Jun */, 7))).toEqual(\n+      new Date(2021, 5 /* Jun */, 5),\n+    );\n \n-    expect(previousSaturday(new Date(2021, 5 /* Jun */, 8))).toEqual(new Date(2021, 5 /* Jun */, 5));\n+    expect(previousSaturday(new Date(2021, 5 /* Jun */, 8))).toEqual(\n+      new Date(2021, 5 /* Jun */, 5),\n+    );\n \n-    expect(previousSaturday(new Date(2021, 5 /* Jun */, 12))).toEqual(new Date(2021, 5 /* Jun */, 5));\n+    expect(previousSaturday(new Date(2021, 5 /* Jun */, 12))).toEqual(\n+      new Date(2021, 5 /* Jun */, 5),\n+    );\n \n-    expect(previousSaturday(new Date(2021, 5 /* Jun */, 16))).toEqual(new Date(2021, 5 /* Jun */, 12));\n+    expect(previousSaturday(new Date(2021, 5 /* Jun */, 16))).toEqual(\n+      new Date(2021, 5 /* Jun */, 12),\n+    );\n \n-    expect(previousSaturday(new Date(2021, 5 /* Jun */, 17))).toEqual(new Date(2021, 5 /* Jun */, 12));\n+    expect(previousSaturday(new Date(2021, 5 /* Jun */, 17))).toEqual(\n+      new Date(2021, 5 /* Jun */, 12),\n+    );\n \n-    expect(previousSaturday(new Date(2021, 5 /* Jun */, 24))).toEqual(new Date(2021, 5 /* Jun */, 19));\n+    expect(previousSaturday(new Date(2021, 5 /* Jun */, 24))).toEqual(\n+      new Date(2021, 5 /* Jun */, 19),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n-    expect(previousSaturday(new Date(NaN)) instanceof Date).toBe(true);\n+    const result = previousSaturday(new Date(NaN));\n+    expect(result instanceof Date).toBe(true);\n+  });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = previousSaturday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = previousSaturday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        previousSaturday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-06T15:00:00.000+08:00\");\n+      expect(\n+        previousSaturday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-06T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = previousSaturday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n   });\n });\ndiff --git a/src/previousSunday/test.ts b/src/previousSunday/test.ts\nindex ad07a4d825..048edae170 100755\n--- a/src/previousSunday/test.ts\n+++ b/src/previousSunday/test.ts\n@@ -1,22 +1,72 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { previousSunday } from \"./index.js\";\n \n describe(\"previousSunday\", () => {\n   it(\"returns the previous Sunday given various dates after the same\", () => {\n-    expect(previousSunday(new Date(2021, 5 /* Jun */, 7))).toEqual(new Date(2021, 5 /* Jun */, 6));\n+    expect(previousSunday(new Date(2021, 5 /* Jun */, 7))).toEqual(\n+      new Date(2021, 5 /* Jun */, 6),\n+    );\n \n-    expect(previousSunday(new Date(2021, 5 /* Jun */, 8))).toEqual(new Date(2021, 5 /* Jun */, 6));\n+    expect(previousSunday(new Date(2021, 5 /* Jun */, 8))).toEqual(\n+      new Date(2021, 5 /* Jun */, 6),\n+    );\n \n-    expect(previousSunday(new Date(2021, 5 /* Jun */, 13))).toEqual(new Date(2021, 5 /* Jun */, 6));\n+    expect(previousSunday(new Date(2021, 5 /* Jun */, 13))).toEqual(\n+      new Date(2021, 5 /* Jun */, 6),\n+    );\n \n-    expect(previousSunday(new Date(2021, 5 /* Jun */, 16))).toEqual(new Date(2021, 5 /* Jun */, 13));\n+    expect(previousSunday(new Date(2021, 5 /* Jun */, 16))).toEqual(\n+      new Date(2021, 5 /* Jun */, 13),\n+    );\n \n-    expect(previousSunday(new Date(2021, 5 /* Jun */, 17))).toEqual(new Date(2021, 5 /* Jun */, 13));\n+    expect(previousSunday(new Date(2021, 5 /* Jun */, 17))).toEqual(\n+      new Date(2021, 5 /* Jun */, 13),\n+    );\n \n-    expect(previousSunday(new Date(2021, 5 /* Jun */, 24))).toEqual(new Date(2021, 5 /* Jun */, 20));\n+    expect(previousSunday(new Date(2021, 5 /* Jun */, 24))).toEqual(\n+      new Date(2021, 5 /* Jun */, 20),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(previousSunday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = previousSunday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = previousSunday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        previousSunday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-07T15:00:00.000+08:00\");\n+      expect(\n+        previousSunday(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-07T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = previousSunday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/previousThursday/test.ts b/src/previousThursday/test.ts\nindex 2a9dc6a516..b65264bcb6 100755\n--- a/src/previousThursday/test.ts\n+++ b/src/previousThursday/test.ts\n@@ -1,22 +1,72 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { previousThursday } from \"./index.js\";\n \n describe(\"previousThursday\", () => {\n   it(\"returns the previous Thursday given various dates after the same\", () => {\n-    expect(previousThursday(new Date(2021, 5 /* Jun */, 5))).toEqual(new Date(2021, 5 /* Jun */, 3));\n+    expect(previousThursday(new Date(2021, 5 /* Jun */, 5))).toEqual(\n+      new Date(2021, 5 /* Jun */, 3),\n+    );\n \n-    expect(previousThursday(new Date(2021, 5 /* Jun */, 6))).toEqual(new Date(2021, 5 /* Jun */, 3));\n+    expect(previousThursday(new Date(2021, 5 /* Jun */, 6))).toEqual(\n+      new Date(2021, 5 /* Jun */, 3),\n+    );\n \n-    expect(previousThursday(new Date(2021, 5 /* Jun */, 10))).toEqual(new Date(2021, 5 /* Jun */, 3));\n+    expect(previousThursday(new Date(2021, 5 /* Jun */, 10))).toEqual(\n+      new Date(2021, 5 /* Jun */, 3),\n+    );\n \n-    expect(previousThursday(new Date(2021, 5 /* Jun */, 14))).toEqual(new Date(2021, 5 /* Jun */, 10));\n+    expect(previousThursday(new Date(2021, 5 /* Jun */, 14))).toEqual(\n+      new Date(2021, 5 /* Jun */, 10),\n+    );\n \n-    expect(previousThursday(new Date(2021, 5 /* Jun */, 15))).toEqual(new Date(2021, 5 /* Jun */, 10));\n+    expect(previousThursday(new Date(2021, 5 /* Jun */, 15))).toEqual(\n+      new Date(2021, 5 /* Jun */, 10),\n+    );\n \n-    expect(previousThursday(new Date(2021, 5 /* Jun */, 24))).toEqual(new Date(2021, 5 /* Jun */, 17));\n+    expect(previousThursday(new Date(2021, 5 /* Jun */, 24))).toEqual(\n+      new Date(2021, 5 /* Jun */, 17),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(previousThursday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = previousThursday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = previousThursday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        previousThursday(\"2024-04-12T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-11T15:00:00.000+08:00\");\n+      expect(\n+        previousThursday(\"2024-04-12T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-11T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = previousThursday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/previousTuesday/test.ts b/src/previousTuesday/test.ts\nindex d9bc282292..1d30a13301 100755\n--- a/src/previousTuesday/test.ts\n+++ b/src/previousTuesday/test.ts\n@@ -1,22 +1,72 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { previousTuesday } from \"./index.js\";\n \n describe(\"previousTuesday\", () => {\n   it(\"returns the previous Tuesday given various dates after the same\", () => {\n-    expect(previousTuesday(new Date(2021, 5 /* Jun */, 5))).toEqual(new Date(2021, 5 /* Jun */, 1));\n+    expect(previousTuesday(new Date(2021, 5 /* Jun */, 5))).toEqual(\n+      new Date(2021, 5 /* Jun */, 1),\n+    );\n \n-    expect(previousTuesday(new Date(2021, 5 /* Jun */, 6))).toEqual(new Date(2021, 5 /* Jun */, 1));\n+    expect(previousTuesday(new Date(2021, 5 /* Jun */, 6))).toEqual(\n+      new Date(2021, 5 /* Jun */, 1),\n+    );\n \n-    expect(previousTuesday(new Date(2021, 5 /* Jun */, 8))).toEqual(new Date(2021, 5 /* Jun */, 1));\n+    expect(previousTuesday(new Date(2021, 5 /* Jun */, 8))).toEqual(\n+      new Date(2021, 5 /* Jun */, 1),\n+    );\n \n-    expect(previousTuesday(new Date(2021, 5 /* Jun */, 15))).toEqual(new Date(2021, 5 /* Jun */, 8));\n+    expect(previousTuesday(new Date(2021, 5 /* Jun */, 15))).toEqual(\n+      new Date(2021, 5 /* Jun */, 8),\n+    );\n \n-    expect(previousTuesday(new Date(2021, 5 /* Jun */, 17))).toEqual(new Date(2021, 5 /* Jun */, 15));\n+    expect(previousTuesday(new Date(2021, 5 /* Jun */, 17))).toEqual(\n+      new Date(2021, 5 /* Jun */, 15),\n+    );\n \n-    expect(previousTuesday(new Date(2021, 5 /* Jun */, 18))).toEqual(new Date(2021, 5 /* Jun */, 15));\n+    expect(previousTuesday(new Date(2021, 5 /* Jun */, 18))).toEqual(\n+      new Date(2021, 5 /* Jun */, 15),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n     expect(previousTuesday(new Date(NaN)) instanceof Date).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = previousTuesday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = previousTuesday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        previousTuesday(\"2024-08-21T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-20T00:00:00.000-07:00\");\n+      expect(\n+        previousTuesday(\"2024-08-21T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-20T15:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = previousTuesday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/previousWednesday/test.ts b/src/previousWednesday/test.ts\nindex 5b0b8dbb17..6aa8df78bd 100755\n--- a/src/previousWednesday/test.ts\n+++ b/src/previousWednesday/test.ts\n@@ -1,22 +1,74 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { previousWednesday } from \"./index.js\";\n \n describe(\"previousWednesday\", () => {\n   it(\"returns the previous Wednesday given various dates after the same\", () => {\n-    expect(previousWednesday(new Date(2021, 5 /* Jun */, 5))).toEqual(new Date(2021, 5 /* Jun */, 2));\n+    expect(previousWednesday(new Date(2021, 5 /* Jun */, 5))).toEqual(\n+      new Date(2021, 5 /* Jun */, 2),\n+    );\n \n-    expect(previousWednesday(new Date(2021, 5 /* Jun */, 6))).toEqual(new Date(2021, 5 /* Jun */, 2));\n+    expect(previousWednesday(new Date(2021, 5 /* Jun */, 6))).toEqual(\n+      new Date(2021, 5 /* Jun */, 2),\n+    );\n \n-    expect(previousWednesday(new Date(2021, 5 /* Jun */, 9))).toEqual(new Date(2021, 5 /* Jun */, 2));\n+    expect(previousWednesday(new Date(2021, 5 /* Jun */, 9))).toEqual(\n+      new Date(2021, 5 /* Jun */, 2),\n+    );\n \n-    expect(previousWednesday(new Date(2021, 5 /* Jun */, 17))).toEqual(new Date(2021, 5 /* Jun */, 16));\n+    expect(previousWednesday(new Date(2021, 5 /* Jun */, 17))).toEqual(\n+      new Date(2021, 5 /* Jun */, 16),\n+    );\n \n-    expect(previousWednesday(new Date(2021, 5 /* Jun */, 18))).toEqual(new Date(2021, 5 /* Jun */, 16));\n+    expect(previousWednesday(new Date(2021, 5 /* Jun */, 18))).toEqual(\n+      new Date(2021, 5 /* Jun */, 16),\n+    );\n \n-    expect(previousWednesday(new Date(2021, 5 /* Jun */, 25))).toEqual(new Date(2021, 5 /* Jun */, 23));\n+    expect(previousWednesday(new Date(2021, 5 /* Jun */, 25))).toEqual(\n+      new Date(2021, 5 /* Jun */, 23),\n+    );\n   });\n \n   it(\"returns `Invalid Date` if the given date is invalid\", () => {\n-    expect(previousWednesday(new Date(NaN)) instanceof Date).toBe(true);\n+    const result = previousWednesday(new Date(NaN));\n+    expect(result instanceof Date).toBe(true);\n+    expect(result.toString()).toBe(\"Invalid Date\");\n+  });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = previousWednesday(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = previousWednesday(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        previousWednesday(\"2024-04-11T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:00.000-07:00\");\n+      expect(\n+        previousWednesday(\"2024-04-12T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = previousWednesday(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n   });\n });\ndiff --git a/src/roundToNearestHours/test.ts b/src/roundToNearestHours/test.ts\nindex c25a01f9cb..9311b9ed20 100644\n--- a/src/roundToNearestHours/test.ts\n+++ b/src/roundToNearestHours/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import {\n   roundToNearestHours,\n   type RoundToNearestHoursOptions,\n@@ -23,10 +26,14 @@ describe(\"roundToNearestHours\", () => {\n     expect(roundToNearestHours(makeDate(9, 1), options)).toEqual(makeDate(9));\n \n     // mid-point\n-    expect(roundToNearestHours(makeDate(10, 30), options)).toEqual(makeDate(12));\n+    expect(roundToNearestHours(makeDate(10, 30), options)).toEqual(\n+      makeDate(12),\n+    );\n \n     // high\n-    expect(roundToNearestHours(makeDate(11, 59), options)).toEqual(makeDate(12));\n+    expect(roundToNearestHours(makeDate(11, 59), options)).toEqual(\n+      makeDate(12),\n+    );\n   });\n \n   describe(\"roundingMethod\", () => {\n@@ -34,13 +41,19 @@ describe(\"roundToNearestHours\", () => {\n       const options: RoundToNearestHoursOptions = { roundingMethod: \"trunc\" };\n \n       // low\n-      expect(roundToNearestHours(makeDate(15, 10), options)).toEqual(makeDate(15));\n+      expect(roundToNearestHours(makeDate(15, 10), options)).toEqual(\n+        makeDate(15),\n+      );\n \n       // mid-point\n-      expect(roundToNearestHours(makeDate(15, 30), options)).toEqual(makeDate(15));\n+      expect(roundToNearestHours(makeDate(15, 30), options)).toEqual(\n+        makeDate(15),\n+      );\n \n       // high\n-      expect(roundToNearestHours(makeDate(15, 59), options)).toEqual(makeDate(15));\n+      expect(roundToNearestHours(makeDate(15, 59), options)).toEqual(\n+        makeDate(15),\n+      );\n     });\n \n     it(\"trunc, nearestTo === 3\", () => {\n@@ -53,10 +66,14 @@ describe(\"roundToNearestHours\", () => {\n       expect(roundToNearestHours(makeDate(9), options)).toEqual(makeDate(9));\n \n       // mid-point\n-      expect(roundToNearestHours(makeDate(10, 30), options)).toEqual(makeDate(9));\n+      expect(roundToNearestHours(makeDate(10, 30), options)).toEqual(\n+        makeDate(9),\n+      );\n \n       // high\n-      expect(roundToNearestHours(makeDate(11, 59), options)).toEqual(makeDate(9));\n+      expect(roundToNearestHours(makeDate(11, 59), options)).toEqual(\n+        makeDate(9),\n+      );\n     });\n \n     it(\"floor, nearestTo === 1 (default)\", () => {\n@@ -66,10 +83,14 @@ describe(\"roundToNearestHours\", () => {\n       expect(roundToNearestHours(makeDate(15), options)).toEqual(makeDate(15));\n \n       // mid-point\n-      expect(roundToNearestHours(makeDate(15, 30), options)).toEqual(makeDate(15));\n+      expect(roundToNearestHours(makeDate(15, 30), options)).toEqual(\n+        makeDate(15),\n+      );\n \n       // high\n-      expect(roundToNearestHours(makeDate(15, 59), options)).toEqual(makeDate(15));\n+      expect(roundToNearestHours(makeDate(15, 59), options)).toEqual(\n+        makeDate(15),\n+      );\n     });\n \n     it(\"floor, nearestTo === 3\", () => {\n@@ -82,23 +103,33 @@ describe(\"roundToNearestHours\", () => {\n       expect(roundToNearestHours(makeDate(15), options)).toEqual(makeDate(15));\n \n       // mid-point\n-      expect(roundToNearestHours(makeDate(16, 30), options)).toEqual(makeDate(15));\n+      expect(roundToNearestHours(makeDate(16, 30), options)).toEqual(\n+        makeDate(15),\n+      );\n \n       // high\n-      expect(roundToNearestHours(makeDate(17, 59), options)).toEqual(makeDate(15));\n+      expect(roundToNearestHours(makeDate(17, 59), options)).toEqual(\n+        makeDate(15),\n+      );\n     });\n \n     it(\"ceil, nearestTo === 1 (default)\", () => {\n       const options: RoundToNearestHoursOptions = { roundingMethod: \"ceil\" };\n \n       // low\n-      expect(roundToNearestHours(makeDate(15, 1), options)).toEqual(makeDate(16));\n+      expect(roundToNearestHours(makeDate(15, 1), options)).toEqual(\n+        makeDate(16),\n+      );\n \n       // mid-point\n-      expect(roundToNearestHours(makeDate(15, 30), options)).toEqual(makeDate(16));\n+      expect(roundToNearestHours(makeDate(15, 30), options)).toEqual(\n+        makeDate(16),\n+      );\n \n       // high\n-      expect(roundToNearestHours(makeDate(15, 59), options)).toEqual(makeDate(16));\n+      expect(roundToNearestHours(makeDate(15, 59), options)).toEqual(\n+        makeDate(16),\n+      );\n     });\n \n     it(\"ceil, nearestTo === 3\", () => {\n@@ -108,13 +139,19 @@ describe(\"roundToNearestHours\", () => {\n       };\n \n       // low\n-      expect(roundToNearestHours(makeDate(15, 1), options)).toEqual(makeDate(18));\n+      expect(roundToNearestHours(makeDate(15, 1), options)).toEqual(\n+        makeDate(18),\n+      );\n \n       // mid-point\n-      expect(roundToNearestHours(makeDate(16, 30), options)).toEqual(makeDate(18));\n+      expect(roundToNearestHours(makeDate(16, 30), options)).toEqual(\n+        makeDate(18),\n+      );\n \n       // high\n-      expect(roundToNearestHours(makeDate(17, 59), options)).toEqual(makeDate(18));\n+      expect(roundToNearestHours(makeDate(17, 59), options)).toEqual(\n+        makeDate(18),\n+      );\n     });\n \n     it(\"round, nearestTo === 1 (default)\", () => {\n@@ -124,10 +161,14 @@ describe(\"roundToNearestHours\", () => {\n       expect(roundToNearestHours(makeDate(15), options)).toEqual(makeDate(15));\n \n       // mid-point\n-      expect(roundToNearestHours(makeDate(15, 30), options)).toEqual(makeDate(16));\n+      expect(roundToNearestHours(makeDate(15, 30), options)).toEqual(\n+        makeDate(16),\n+      );\n \n       // high\n-      expect(roundToNearestHours(makeDate(15, 59), options)).toEqual(makeDate(16));\n+      expect(roundToNearestHours(makeDate(15, 59), options)).toEqual(\n+        makeDate(16),\n+      );\n     });\n \n     it(\"round, nearestTo === 3\", () => {\n@@ -140,23 +181,33 @@ describe(\"roundToNearestHours\", () => {\n       expect(roundToNearestHours(makeDate(15), options)).toEqual(makeDate(15));\n \n       // mid-point\n-      expect(roundToNearestHours(makeDate(16, 30), options)).toEqual(makeDate(18));\n+      expect(roundToNearestHours(makeDate(16, 30), options)).toEqual(\n+        makeDate(18),\n+      );\n \n       // high\n-      expect(roundToNearestHours(makeDate(17, 59), options)).toEqual(makeDate(18));\n+      expect(roundToNearestHours(makeDate(17, 59), options)).toEqual(\n+        makeDate(18),\n+      );\n     });\n   });\n \n   describe(\"edge cases\", () => {\n     it(\"rounds up to the next day\", () => {\n-      expect(roundToNearestHours(new Date(2014, 6, 10, 23, 59, 59, 999))).toEqual(new Date(2014, 6, 11));\n+      expect(\n+        roundToNearestHours(new Date(2014, 6, 10, 23, 59, 59, 999)),\n+      ).toEqual(new Date(2014, 6, 11));\n     });\n \n     it(\"ceils correctly with 0 seconds and 1 millisecond\", () => {\n       // \"ceil\" does not round up when exactly o'clock\n-      expect(roundToNearestHours(makeDate(15, 0, 0, 0), { roundingMethod: \"ceil\" })).toEqual(makeDate(15));\n+      expect(\n+        roundToNearestHours(makeDate(15, 0, 0, 0), { roundingMethod: \"ceil\" }),\n+      ).toEqual(makeDate(15));\n \n-      expect(roundToNearestHours(makeDate(15, 0, 0, 1), { roundingMethod: \"ceil\" })).toEqual(makeDate(16));\n+      expect(\n+        roundToNearestHours(makeDate(15, 0, 0, 1), { roundingMethod: \"ceil\" }),\n+      ).toEqual(makeDate(16));\n     });\n   });\n \n@@ -195,6 +246,41 @@ describe(\"roundToNearestHours\", () => {\n       expect(result).toEqual(new Date(2014, 6, 10, 8));\n     });\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = roundToNearestHours(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = roundToNearestHours(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        roundToNearestHours(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.000+08:00\");\n+      expect(\n+        roundToNearestHours(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Kolkata\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T13:00:00.000+05:30\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = roundToNearestHours(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\n \n function makeDate(\ndiff --git a/src/roundToNearestMinutes/test.ts b/src/roundToNearestMinutes/test.ts\nindex bf530de245..93e9cd433d 100644\n--- a/src/roundToNearestMinutes/test.ts\n+++ b/src/roundToNearestMinutes/test.ts\n@@ -3,6 +3,9 @@ import {\n   roundToNearestMinutes,\n   type RoundToNearestMinutesOptions,\n } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n \n describe(\"roundToNearestMinutes\", () => {\n   it(\"rounds given date to the nearest minute by default\", () => {\n@@ -20,13 +23,17 @@ describe(\"roundToNearestMinutes\", () => {\n     const options: RoundToNearestMinutesOptions = { nearestTo: 4 };\n \n     // low\n-    expect(roundToNearestMinutes(makeDate(9, 59), options)).toEqual(makeDate(8));\n+    expect(roundToNearestMinutes(makeDate(9, 59), options)).toEqual(\n+      makeDate(8),\n+    );\n \n     // mid-point\n     expect(roundToNearestMinutes(makeDate(10), options)).toEqual(makeDate(12));\n \n     // high\n-    expect(roundToNearestMinutes(makeDate(10, 30), options)).toEqual(makeDate(12));\n+    expect(roundToNearestMinutes(makeDate(10, 30), options)).toEqual(\n+      makeDate(12),\n+    );\n   });\n \n   describe(\"roundingMethod\", () => {\n@@ -34,13 +41,19 @@ describe(\"roundToNearestMinutes\", () => {\n       const options: RoundToNearestMinutesOptions = { roundingMethod: \"trunc\" };\n \n       // low\n-      expect(roundToNearestMinutes(makeDate(15, 10), options)).toEqual(makeDate(15));\n+      expect(roundToNearestMinutes(makeDate(15, 10), options)).toEqual(\n+        makeDate(15),\n+      );\n \n       // mid-point\n-      expect(roundToNearestMinutes(makeDate(15, 30), options)).toEqual(makeDate(15));\n+      expect(roundToNearestMinutes(makeDate(15, 30), options)).toEqual(\n+        makeDate(15),\n+      );\n \n       // high\n-      expect(roundToNearestMinutes(makeDate(15, 59), options)).toEqual(makeDate(15));\n+      expect(roundToNearestMinutes(makeDate(15, 59), options)).toEqual(\n+        makeDate(15),\n+      );\n     });\n \n     it(\"trunc, nearestTo === 4\", () => {\n@@ -50,26 +63,36 @@ describe(\"roundToNearestMinutes\", () => {\n       };\n \n       // low\n-      expect(roundToNearestMinutes(makeDate(9, 59), options)).toEqual(makeDate(8));\n+      expect(roundToNearestMinutes(makeDate(9, 59), options)).toEqual(\n+        makeDate(8),\n+      );\n \n       // mid-point\n       expect(roundToNearestMinutes(makeDate(10), options)).toEqual(makeDate(8));\n \n       // high\n-      expect(roundToNearestMinutes(makeDate(10, 30), options)).toEqual(makeDate(8));\n+      expect(roundToNearestMinutes(makeDate(10, 30), options)).toEqual(\n+        makeDate(8),\n+      );\n     });\n \n     it(\"floor, nearestTo === 1 (default)\", () => {\n       const options: RoundToNearestMinutesOptions = { roundingMethod: \"floor\" };\n \n       // low\n-      expect(roundToNearestMinutes(makeDate(15, 10), options)).toEqual(makeDate(15));\n+      expect(roundToNearestMinutes(makeDate(15, 10), options)).toEqual(\n+        makeDate(15),\n+      );\n \n       // mid-point\n-      expect(roundToNearestMinutes(makeDate(15, 30), options)).toEqual(makeDate(15));\n+      expect(roundToNearestMinutes(makeDate(15, 30), options)).toEqual(\n+        makeDate(15),\n+      );\n \n       // high\n-      expect(roundToNearestMinutes(makeDate(15, 59), options)).toEqual(makeDate(15));\n+      expect(roundToNearestMinutes(makeDate(15, 59), options)).toEqual(\n+        makeDate(15),\n+      );\n     });\n \n     it(\"floor, nearestTo === 4\", () => {\n@@ -79,26 +102,36 @@ describe(\"roundToNearestMinutes\", () => {\n       };\n \n       // low\n-      expect(roundToNearestMinutes(makeDate(9, 59), options)).toEqual(makeDate(8));\n+      expect(roundToNearestMinutes(makeDate(9, 59), options)).toEqual(\n+        makeDate(8),\n+      );\n \n       // mid-point\n       expect(roundToNearestMinutes(makeDate(10), options)).toEqual(makeDate(8));\n \n       // high\n-      expect(roundToNearestMinutes(makeDate(10, 30), options)).toEqual(makeDate(8));\n+      expect(roundToNearestMinutes(makeDate(10, 30), options)).toEqual(\n+        makeDate(8),\n+      );\n     });\n \n     it(\"ceil, nearestTo === 1 (default)\", () => {\n       const options: RoundToNearestMinutesOptions = { roundingMethod: \"ceil\" };\n \n       // low\n-      expect(roundToNearestMinutes(makeDate(15, 10), options)).toEqual(makeDate(16));\n+      expect(roundToNearestMinutes(makeDate(15, 10), options)).toEqual(\n+        makeDate(16),\n+      );\n \n       // mid-point\n-      expect(roundToNearestMinutes(makeDate(15, 30), options)).toEqual(makeDate(16));\n+      expect(roundToNearestMinutes(makeDate(15, 30), options)).toEqual(\n+        makeDate(16),\n+      );\n \n       // high\n-      expect(roundToNearestMinutes(makeDate(15, 59), options)).toEqual(makeDate(16));\n+      expect(roundToNearestMinutes(makeDate(15, 59), options)).toEqual(\n+        makeDate(16),\n+      );\n     });\n \n     it(\"ceil, nearestTo === 4\", () => {\n@@ -108,26 +141,38 @@ describe(\"roundToNearestMinutes\", () => {\n       };\n \n       // low\n-      expect(roundToNearestMinutes(makeDate(9, 59), options)).toEqual(makeDate(12));\n+      expect(roundToNearestMinutes(makeDate(9, 59), options)).toEqual(\n+        makeDate(12),\n+      );\n \n       // mid-point\n-      expect(roundToNearestMinutes(makeDate(10), options)).toEqual(makeDate(12));\n+      expect(roundToNearestMinutes(makeDate(10), options)).toEqual(\n+        makeDate(12),\n+      );\n \n       // high\n-      expect(roundToNearestMinutes(makeDate(10, 30), options)).toEqual(makeDate(12));\n+      expect(roundToNearestMinutes(makeDate(10, 30), options)).toEqual(\n+        makeDate(12),\n+      );\n     });\n \n     it(\"round, nearestTo === 1 (default)\", () => {\n       const options: RoundToNearestMinutesOptions = { roundingMethod: \"round\" };\n \n       // low\n-      expect(roundToNearestMinutes(makeDate(15, 10), options)).toEqual(makeDate(15));\n+      expect(roundToNearestMinutes(makeDate(15, 10), options)).toEqual(\n+        makeDate(15),\n+      );\n \n       // mid-point\n-      expect(roundToNearestMinutes(makeDate(15, 30), options)).toEqual(makeDate(16));\n+      expect(roundToNearestMinutes(makeDate(15, 30), options)).toEqual(\n+        makeDate(16),\n+      );\n \n       // high\n-      expect(roundToNearestMinutes(makeDate(15, 59), options)).toEqual(makeDate(16));\n+      expect(roundToNearestMinutes(makeDate(15, 59), options)).toEqual(\n+        makeDate(16),\n+      );\n     });\n \n     it(\"round, nearestTo === 4\", () => {\n@@ -137,25 +182,37 @@ describe(\"roundToNearestMinutes\", () => {\n       };\n \n       // low\n-      expect(roundToNearestMinutes(makeDate(9, 59), options)).toEqual(makeDate(8));\n+      expect(roundToNearestMinutes(makeDate(9, 59), options)).toEqual(\n+        makeDate(8),\n+      );\n \n       // mid-point\n-      expect(roundToNearestMinutes(makeDate(10), options)).toEqual(makeDate(12));\n+      expect(roundToNearestMinutes(makeDate(10), options)).toEqual(\n+        makeDate(12),\n+      );\n \n       // high\n-      expect(roundToNearestMinutes(makeDate(10, 30), options)).toEqual(makeDate(12));\n+      expect(roundToNearestMinutes(makeDate(10, 30), options)).toEqual(\n+        makeDate(12),\n+      );\n     });\n   });\n \n   describe(\"edge cases\", () => {\n     it(\"rounds up to the next day\", () => {\n-      expect(roundToNearestMinutes(new Date(2014, 6, 10, 23, 59, 59))).toEqual(new Date(2014, 6, 11));\n+      expect(roundToNearestMinutes(new Date(2014, 6, 10, 23, 59, 59))).toEqual(\n+        new Date(2014, 6, 11),\n+      );\n     });\n \n     it(\"ceils correctly with 0 seconds and 1 millisecond\", () => {\n-      expect(roundToNearestMinutes(makeDate(15, 0, 0), { roundingMethod: \"ceil\" })).toEqual(makeDate(15));\n+      expect(\n+        roundToNearestMinutes(makeDate(15, 0, 0), { roundingMethod: \"ceil\" }),\n+      ).toEqual(makeDate(15));\n \n-      expect(roundToNearestMinutes(makeDate(15, 0, 1), { roundingMethod: \"ceil\" })).toEqual(makeDate(16));\n+      expect(\n+        roundToNearestMinutes(makeDate(15, 0, 1), { roundingMethod: \"ceil\" }),\n+      ).toEqual(makeDate(16));\n     });\n   });\n \n@@ -203,6 +260,41 @@ describe(\"roundToNearestMinutes\", () => {\n     const result = roundToNearestMinutes(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = roundToNearestMinutes(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = roundToNearestMinutes(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        roundToNearestMinutes(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.000+08:00\");\n+      expect(\n+        roundToNearestMinutes(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Kolkata\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T12:30:00.000+05:30\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = roundToNearestMinutes(\"2014-09-01T00:00:00Z\", {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\n \n function makeDate(\ndiff --git a/src/set/test.ts b/src/set/test.ts\nindex af79614f41..09a03e1a80 100644\n--- a/src/set/test.ts\n+++ b/src/set/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { set } from \"./index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"set\", () => {\n   it(\"sets all values\", () => {\n@@ -12,7 +15,9 @@ describe(\"set\", () => {\n       seconds: 12,\n       milliseconds: 12,\n     });\n-    expect(result.toString()).toEqual(new Date(2014, 8 /* Sep */, 20, 12, 12, 12, 12).toString());\n+    expect(result.toString()).toEqual(\n+      new Date(2014, 8 /* Sep */, 20, 12, 12, 12, 12).toString(),\n+    );\n   });\n \n   it(\"sets year\", () => {\n@@ -52,6 +57,44 @@ describe(\"set\", () => {\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 1, 1, 1, 1, 500));\n   });\n \n+  it(\"resolves the date type by default\", () => {\n+    const result = set(Date.now(), { hours: 5 });\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = set(new UTCDate(), { hours: 5 });\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        set(\n+          new Date(\"2024-04-10T07:00:00Z\"),\n+          { year: 2015 },\n+          { in: tz(\"Asia/Singapore\") },\n+        ).toISOString(),\n+      ).toBe(\"2015-04-10T15:00:00.000+08:00\");\n+      expect(\n+        set(\n+          new Date(\"2024-04-10T07:00:00Z\"),\n+          { year: 2015 },\n+          { in: tz(\"America/Los_Angeles\") },\n+        ).toISOString(),\n+      ).toBe(\"2015-04-10T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = set(date, { month: 0 }, { in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n+\n   describe(\"value overflow\", () => {\n     it(\"months overflow into years\", () => {\n       const result = set(new Date(2014, 8 /* Sep */, 1), {\ndiff --git a/src/setDate/test.ts b/src/setDate/test.ts\nindex 9e2159088c..18c3a24552 100644\n--- a/src/setDate/test.ts\n+++ b/src/setDate/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setDate } from \"./index.js\";\n \n describe(\"setDate\", () => {\n@@ -27,4 +30,40 @@ describe(\"setDate\", () => {\n     const result = setDate(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setDate(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setDate(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setDate(\"2024-04-10T07:00:00Z\", 15, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-15T15:00:00.000+08:00\");\n+      expect(\n+        setDate(\"2024-04-10T07:00:00Z\", 20, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-20T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = setDate(date, 15, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setDay/test.ts b/src/setDay/test.ts\nindex 9d7e2def2a..24c34b57a1 100644\n--- a/src/setDay/test.ts\n+++ b/src/setDay/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setDay } from \"./index.js\";\n \n describe(\"setDay\", () => {\n@@ -109,4 +112,39 @@ describe(\"setDay\", () => {\n     const result = setDay(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setDay(Date.now(), 15);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setDay(new UTCDate(), 15);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setDay(\"2024-04-10T07:00:00Z\", 15, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-22T15:00:00.000+08:00\");\n+      expect(\n+        setDay(\"2024-04-10T07:00:00Z\", 15, {\n+          in: tz(\"Asia/Kolkata\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-22T12:30:00.000+05:30\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setDay(\"2014-09-01T00:00:00Z\", 15, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setDayOfYear/test.ts b/src/setDayOfYear/test.ts\nindex 64be3f4575..b6a2da9d55 100644\n--- a/src/setDayOfYear/test.ts\n+++ b/src/setDayOfYear/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setDayOfYear } from \"./index.js\";\n \n describe(\"setDayOfYear\", () => {\n@@ -27,4 +30,39 @@ describe(\"setDayOfYear\", () => {\n     const result = setDayOfYear(new Date(2014, 6 /* Jul */, 2), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setDayOfYear(Date.now(), 123);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setDayOfYear(new UTCDate(), 123);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setDayOfYear(\"2024-04-10T07:00:00Z\", 123, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-05-02T15:00:00.000+08:00\");\n+      expect(\n+        setDayOfYear(\"2024-04-10T07:00:00Z\", 123, {\n+          in: tz(\"Asia/Kolkata\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-05-02T12:30:00.000+05:30\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setDayOfYear(\"2014-09-01T00:00:00Z\", 123, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setHours/test.ts b/src/setHours/test.ts\nindex b9f7c7418e..e6d2de8cd5 100644\n--- a/src/setHours/test.ts\n+++ b/src/setHours/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setHours } from \"./index.js\";\n \n describe(\"setHours\", () => {\n@@ -27,4 +30,39 @@ describe(\"setHours\", () => {\n     const result = setHours(new Date(2014, 8 /* Sep */, 1, 11, 30), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setHours(Date.now(), 16);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setHours(new UTCDate(), 16);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setHours(\"2024-04-10T07:00:00Z\", 16, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T16:00:00.000+08:00\");\n+      expect(\n+        setHours(\"2024-04-10T07:00:00Z\", 16, {\n+          in: tz(\"Asia/Kolkata\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T16:30:00.000+05:30\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setHours(\"2014-09-01T00:00:00Z\", 16, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setISODay/test.ts b/src/setISODay/test.ts\nindex bb65ada15c..b4de2e5e96 100644\n--- a/src/setISODay/test.ts\n+++ b/src/setISODay/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setISODay } from \"./index.js\";\n \n describe(\"setISODay\", () => {\n@@ -12,28 +15,24 @@ describe(\"setISODay\", () => {\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 7));\n   });\n \n-  describe(\"the day index is more than 7\", () => {\n-    it(\"sets the day of the next ISO week\", () => {\n-      const result = setISODay(new Date(2014, 8 /* Sep */, 1), 8);\n-      expect(result).toEqual(new Date(2014, 8 /* Sep */, 8));\n-    });\n+  it(\"sets the day of the next ISO week\", () => {\n+    const result = setISODay(new Date(2014, 8 /* Sep */, 1), 8);\n+    expect(result).toEqual(new Date(2014, 8 /* Sep */, 8));\n+  });\n \n-    it(\"sets the day of another ISO week in the future\", () => {\n-      const result = setISODay(new Date(2014, 8 /* Sep */, 1), 21);\n-      expect(result).toEqual(new Date(2014, 8 /* Sep */, 21));\n-    });\n+  it(\"sets the day of another ISO week in the future\", () => {\n+    const result = setISODay(new Date(2014, 8 /* Sep */, 1), 21);\n+    expect(result).toEqual(new Date(2014, 8 /* Sep */, 21));\n   });\n \n-  describe(\"the day index is less than 1\", () => {\n-    it(\"sets the day of the last ISO week\", () => {\n-      const result = setISODay(new Date(2014, 8 /* Sep */, 1), 0);\n-      expect(result).toEqual(new Date(2014, 7 /* Aug */, 31));\n-    });\n+  it(\"sets the day of the last ISO week\", () => {\n+    const result = setISODay(new Date(2014, 8 /* Sep */, 1), 0);\n+    expect(result).toEqual(new Date(2014, 7 /* Aug */, 31));\n+  });\n \n-    it(\"set the day of another ISO week in the past\", () => {\n-      const result = setISODay(new Date(2014, 8 /* Sep */, 1), -13);\n-      expect(result).toEqual(new Date(2014, 7 /* Aug */, 18));\n-    });\n+  it(\"set the day of another ISO week in the past\", () => {\n+    const result = setISODay(new Date(2014, 8 /* Sep */, 1), -13);\n+    expect(result).toEqual(new Date(2014, 7 /* Aug */, 18));\n   });\n \n   it(\"accepts a timestamp\", () => {\n@@ -56,4 +55,36 @@ describe(\"setISODay\", () => {\n     const result = setISODay(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setISODay(new Date(2014, 8 /* Sep */, 3), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setISODay(new UTCDate(\"2014-09-01T00:00:00Z\"), 3);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const date = \"2024-04-10T07:00:00Z\";\n+      expect(\n+        setISODay(date, 1, { in: tz(\"America/Los_Angeles\") }).toISOString(),\n+      ).toBe(\"2024-04-08T00:00:00.000-07:00\");\n+      expect(setISODay(date, 1, { in: tz(\"Asia/Kolkata\") }).toISOString()).toBe(\n+        \"2024-04-08T12:30:00.000+05:30\",\n+      );\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setISODay(\"2014-09-01T00:00:00Z\", 3, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setISOWeek/test.ts b/src/setISOWeek/test.ts\nindex cf1565f450..4e6f1b8229 100644\n--- a/src/setISOWeek/test.ts\n+++ b/src/setISOWeek/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setISOWeek } from \"./index.js\";\n \n describe(\"setISOWeek\", () => {\n@@ -34,8 +37,43 @@ describe(\"setISOWeek\", () => {\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n \n-  it(\"returns `Invalid Date` if the given amount is NaN\", () => {\n+  it(\"returns `Invalid Date` if the given week is NaN\", () => {\n     const result = setISOWeek(new Date(2004, 7 /* Aug */, 7), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setISOWeek(Date.now(), 15);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setISOWeek(new UTCDate(), 15);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setISOWeek(\"2024-04-10T07:00:00Z\", 15, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.000+08:00\");\n+      expect(\n+        setISOWeek(\"2024-04-10T07:00:00Z\", 15, {\n+          in: tz(\"Asia/Kolkata\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T12:30:00.000+05:30\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setISOWeek(\"2014-09-01T00:00:00Z\", 15, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setISOWeekYear/test.ts b/src/setISOWeekYear/test.ts\nindex 51a136fedd..eae61c771a 100644\n--- a/src/setISOWeekYear/test.ts\n+++ b/src/setISOWeekYear/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setISOWeekYear } from \"./index.js\";\n \n describe(\"setISOWeekYear\", () => {\n@@ -50,4 +53,40 @@ describe(\"setISOWeekYear\", () => {\n     const result = setISOWeekYear(new Date(2008, 11 /* Dec */, 29), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setISOWeekYear(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setISOWeekYear(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setISOWeekYear(\"2024-04-10T07:00:00Z\", 2024, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:00.000+08:00\");\n+      expect(\n+        setISOWeekYear(\"2024-04-10T07:00:00Z\", 2024, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2024-04-10T07:00:00Z\");\n+      const result = setISOWeekYear(date, 2024, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setMilliseconds/test.ts b/src/setMilliseconds/test.ts\nindex 474f4f0c11..1c6fdf9e96 100644\n--- a/src/setMilliseconds/test.ts\n+++ b/src/setMilliseconds/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setMilliseconds } from \"./index.js\";\n \n describe(\"setMilliseconds\", () => {\n@@ -36,4 +39,39 @@ describe(\"setMilliseconds\", () => {\n     );\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setMilliseconds(Date.now(), 123);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setMilliseconds(new UTCDate(), 123);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setMilliseconds(\"2024-04-10T07:00:00Z\", 123, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.123+08:00\");\n+      expect(\n+        setMilliseconds(\"2024-04-10T07:00:00Z\", 123, {\n+          in: tz(\"Asia/Kolkata\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T12:30:00.123+05:30\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setMilliseconds(\"2014-09-01T00:00:00Z\", 123, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setMinutes/test.ts b/src/setMinutes/test.ts\nindex 3fa6191ddb..e2b53dddc4 100644\n--- a/src/setMinutes/test.ts\n+++ b/src/setMinutes/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setMinutes } from \"./index.js\";\n \n describe(\"setMinutes\", () => {\n@@ -30,4 +33,39 @@ describe(\"setMinutes\", () => {\n     const result = setMinutes(new Date(2014, 8 /* Sep */, 1, 11, 30, 40), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setMinutes(Date.now(), 45);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setMinutes(new UTCDate(), 45);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setMinutes(\"2024-04-10T07:00:00Z\", 45, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:45:00.000+08:00\");\n+      expect(\n+        setMinutes(\"2024-04-10T07:00:00Z\", 45, {\n+          in: tz(\"Asia/Kolkata\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T12:45:00.000+05:30\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setMinutes(\"2014-09-01T00:00:00Z\", 45, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setMonth/test.ts b/src/setMonth/test.ts\nindex da8218f688..dd27fe9d39 100644\n--- a/src/setMonth/test.ts\n+++ b/src/setMonth/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setMonth } from \"./index.js\";\n \n describe(\"setMonth\", () => {\n@@ -43,4 +46,39 @@ describe(\"setMonth\", () => {\n     const result = setMonth(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setMonth(Date.now(), 2);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setMonth(new UTCDate(), 2);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setMonth(\"2024-04-10T07:00:00Z\", 2, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-03-10T15:00:00.000+08:00\");\n+      expect(\n+        setMonth(\"2024-04-10T07:00:00Z\", 2, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-03-10T04:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setMonth(\"2014-09-01T00:00:00Z\", 45, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setQuarter/test.ts b/src/setQuarter/test.ts\nindex eeae7b7d93..5e52e67ced 100644\n--- a/src/setQuarter/test.ts\n+++ b/src/setQuarter/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { setQuarter } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"setQuarter\", () => {\n   it(\"sets the quarter of the year\", () => {\n@@ -43,4 +46,39 @@ describe(\"setQuarter\", () => {\n     const result = setQuarter(new Date(2014, 6 /* Jul */, 2), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setQuarter(Date.now(), 2);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setQuarter(new UTCDate(), 2);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setQuarter(\"2024-04-10T07:00:00Z\", 2, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.000+08:00\");\n+      expect(\n+        setQuarter(\"2024-04-10T07:00:00Z\", 2, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T03:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setQuarter(\"2014-09-01T00:00:00Z\", 45, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setSeconds/test.ts b/src/setSeconds/test.ts\nindex 5295f3c4df..685a802ac6 100644\n--- a/src/setSeconds/test.ts\n+++ b/src/setSeconds/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setSeconds } from \"./index.js\";\n \n describe(\"setSeconds\", () => {\n@@ -36,4 +39,39 @@ describe(\"setSeconds\", () => {\n     );\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setSeconds(Date.now(), 45);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setSeconds(new UTCDate(), 45);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setSeconds(\"2024-04-10T07:00:00Z\", 45, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:45.000+08:00\");\n+      expect(\n+        setSeconds(\"2024-04-10T07:00:00Z\", 45, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T03:00:45.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setSeconds(\"2014-09-01T00:00:00Z\", 45, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setWeek/test.ts b/src/setWeek/test.ts\nindex 709c4dcc6d..7a11196d26 100644\n--- a/src/setWeek/test.ts\n+++ b/src/setWeek/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setWeek } from \"./index.js\";\n \n describe(\"setWeek\", () => {\n@@ -60,4 +63,39 @@ describe(\"setWeek\", () => {\n     });\n     expect(result).toEqual(new Date(2004, 0 /* Jan */, 4));\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setWeek(Date.now(), 1);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setWeek(new UTCDate(), 1);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setWeek(\"2024-04-10T07:00:00Z\", 1, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-01-03T15:00:00.000+08:00\");\n+      expect(\n+        setWeek(\"2024-04-10T07:00:00Z\", 1, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-01-03T03:00:00.000-05:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setWeek(\"2014-09-01T00:00:00Z\", 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setWeekYear/test.ts b/src/setWeekYear/test.ts\nindex 9031df9d0c..d8894277e4 100644\n--- a/src/setWeekYear/test.ts\n+++ b/src/setWeekYear/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setWeekYear } from \"./index.js\";\n \n describe(\"setWeekYear\", () => {\n@@ -72,4 +75,39 @@ describe(\"setWeekYear\", () => {\n     });\n     expect(result).toEqual(new Date(2005, 0 /* Jan */, 1));\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setWeekYear(Date.now(), 2020);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setWeekYear(new UTCDate(), 2020);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setWeekYear(\"2024-04-10T07:00:00Z\", 2014, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2014-04-09T00:00:00.000-07:00\");\n+      expect(\n+        setWeekYear(\"2024-04-10T07:00:00Z\", 2016, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2016-04-06T00:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setWeekYear(\"2010-01-02T00:00:00Z\", 2004, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/setYear/test.ts b/src/setYear/test.ts\nindex b0998993d8..82884fc40d 100644\n--- a/src/setYear/test.ts\n+++ b/src/setYear/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { setYear } from \"./index.js\";\n \n describe(\"setYear\", () => {\n@@ -27,4 +30,39 @@ describe(\"setYear\", () => {\n     const result = setYear(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = setYear(Date.now(), 2020);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = setYear(new UTCDate(), 2020);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        setYear(\"2024-04-10T07:00:00Z\", 2014, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2014-04-10T00:00:00.000-07:00\");\n+      expect(\n+        setYear(\"2024-04-10T07:00:00Z\", 2016, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2016-04-10T15:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = setYear(\"2014-09-01T00:00:00Z\", 2010, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfDay/test.ts b/src/startOfDay/test.ts\nindex 46f903ef33..3f768478cb 100644\n--- a/src/startOfDay/test.ts\n+++ b/src/startOfDay/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { startOfDay } from \"./index.js\";\n \n describe(\"startOfDay\", () => {\n@@ -24,4 +27,40 @@ describe(\"startOfDay\", () => {\n     const result = startOfDay(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfDay(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfDay(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfDay(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:00.000+08:00\");\n+      expect(\n+        startOfDay(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = startOfDay(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfDecade/test.ts b/src/startOfDecade/test.ts\nindex 747d08038c..12098358f0 100644\n--- a/src/startOfDecade/test.ts\n+++ b/src/startOfDecade/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { startOfDecade } from \"./index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"startOfDecade\", () => {\n   it(\"returns the date with the time set to 00:00:00 and the date set to the first day of a year\", () => {\n@@ -29,4 +32,40 @@ describe(\"startOfDecade\", () => {\n     expect(startOfDecade(new Date(2009, 0, 1))).toEqual(new Date(2000, 0, 1));\n     expect(startOfDecade(new Date(-2001, 0, 1))).toEqual(new Date(-2010, 0, 1));\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfDecade(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfDecade(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfDecade(\"2024-08-18T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2020-01-01T00:00:00.000+08:00\");\n+      expect(\n+        startOfDecade(\"2024-08-18T17:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2020-01-01T00:00:00.000-05:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = startOfDecade(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfHour/test.ts b/src/startOfHour/test.ts\nindex 4cc5f6fd47..d33415b89c 100644\n--- a/src/startOfHour/test.ts\n+++ b/src/startOfHour/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { startOfHour } from \"./index.js\";\n \n describe(\"startOfHour\", () => {\n@@ -24,4 +27,40 @@ describe(\"startOfHour\", () => {\n     const result = startOfHour(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfHour(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfHour(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfHour(\"2024-04-10T07:30:30Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.000+08:00\");\n+      expect(\n+        startOfHour(\"2024-04-10T07:30:30Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T03:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-02T11:55:00Z\");\n+      const result = startOfHour(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfISOWeek/test.ts b/src/startOfISOWeek/test.ts\nindex be37fb9a3f..3ed513a1cc 100644\n--- a/src/startOfISOWeek/test.ts\n+++ b/src/startOfISOWeek/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { startOfISOWeek } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"startOfISOWeek\", () => {\n   it(\"returns the date with the time set to 00:00:00 and the date set to the first day of an ISO week\", () => {\n@@ -24,4 +27,50 @@ describe(\"startOfISOWeek\", () => {\n     const result = startOfISOWeek(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfISOWeek(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfISOWeek(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfISOWeek(\"2024-08-18T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-12T00:00:00.000+08:00\");\n+      expect(\n+        startOfISOWeek(\"2024-08-18T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-19T00:00:00.000+08:00\");\n+      expect(\n+        startOfISOWeek(\"2024-08-19T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-12T00:00:00.000-04:00\");\n+      expect(\n+        startOfISOWeek(\"2024-08-19T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-19T00:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = startOfISOWeek(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfISOWeekYear/test.ts b/src/startOfISOWeekYear/test.ts\nindex 93f6e1b942..7458fe5579 100644\n--- a/src/startOfISOWeekYear/test.ts\n+++ b/src/startOfISOWeekYear/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { startOfISOWeekYear } from \"./index.js\";\n \n describe(\"startOfISOWeekYear\", () => {\n@@ -40,4 +43,50 @@ describe(\"startOfISOWeekYear\", () => {\n     const result = startOfISOWeekYear(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfISOWeekYear(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfISOWeekYear(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfISOWeekYear(\"2023-12-31T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2023-01-02T00:00:00.000+08:00\");\n+      expect(\n+        startOfISOWeekYear(\"2023-12-31T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-01-01T00:00:00.000+08:00\");\n+      expect(\n+        startOfISOWeekYear(\"2024-01-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2023-01-02T00:00:00.000-05:00\");\n+      expect(\n+        startOfISOWeekYear(\"2024-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-01-01T00:00:00.000-05:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = startOfISOWeekYear(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfMinute/test.ts b/src/startOfMinute/test.ts\nindex 5c18285cb1..2941368e7e 100644\n--- a/src/startOfMinute/test.ts\n+++ b/src/startOfMinute/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { startOfMinute } from \"./index.js\";\n \n describe(\"startOfMinute\", () => {\n@@ -24,4 +27,40 @@ describe(\"startOfMinute\", () => {\n     const result = startOfMinute(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfMinute(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfMinute(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfMinute(\"2024-04-10T07:12:34.567Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:12:00.000+08:00\");\n+      expect(\n+        startOfMinute(\"2024-04-10T07:12:34.567Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T03:12:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = startOfMinute(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfMonth/test.ts b/src/startOfMonth/test.ts\nindex cfc878d8c0..03aa5cb0c1 100644\n--- a/src/startOfMonth/test.ts\n+++ b/src/startOfMonth/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { startOfMonth } from \"./index.js\";\n \n describe(\"startOfMonth\", () => {\n@@ -24,4 +27,41 @@ describe(\"startOfMonth\", () => {\n     const result = startOfMonth(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfMonth(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfMonth(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfMonth(\"2024-08-18T05:00:00Z\", {\n+          in: tz(\"Asia/Hong_Kong\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-01T00:00:00.000+08:00\");\n+\n+      expect(\n+        startOfMonth(\"2024-01-01T19:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-01-01T00:00:00.000-05:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = startOfMonth(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfQuarter/test.ts b/src/startOfQuarter/test.ts\nindex babb56fa24..01b35d0b73 100644\n--- a/src/startOfQuarter/test.ts\n+++ b/src/startOfQuarter/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { startOfQuarter } from \"./index.js\";\n \n describe(\"startOfQuarter\", () => {\n@@ -24,4 +27,33 @@ describe(\"startOfQuarter\", () => {\n     const result = startOfQuarter(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfQuarter(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfQuarter(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      const date = new Date(2022, 1 /* Feb */, 19);\n+      const context = { in: tz(\"America/New_York\") };\n+      const result = startOfQuarter(date, context);\n+      expect(result.toISOString()).toEqual(\"2022-01-01T00:00:00.000-05:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(2022, 1 /* Feb */, 19);\n+      const context = { in: tz(\"America/New_York\") };\n+      const result = startOfQuarter(date, context);\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfSecond/test.ts b/src/startOfSecond/test.ts\nindex b4b5ca9892..8d2643aef0 100644\n--- a/src/startOfSecond/test.ts\n+++ b/src/startOfSecond/test.ts\n@@ -1,4 +1,6 @@\n+import { tz, TZDate } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { startOfSecond } from \"./index.js\";\n \n describe(\"startOfSecond\", () => {\n@@ -24,4 +26,40 @@ describe(\"startOfSecond\", () => {\n     const result = startOfSecond(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfSecond(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfSecond(new TZDate());\n+    expect(result).toBeInstanceOf(TZDate);\n+    assertType<assertType.Equal<TZDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfSecond(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.000+08:00\");\n+      expect(\n+        startOfSecond(\"2024-04-10T07:00:00Z\", {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = startOfSecond(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfToday/test.ts b/src/startOfToday/test.ts\nindex c40d112c4a..f1d450fa02 100644\n--- a/src/startOfToday/test.ts\n+++ b/src/startOfToday/test.ts\n@@ -1,21 +1,48 @@\n-import { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n-import sinon from \"sinon\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { describe, expect, it } from \"vitest\";\n+import { assertType, fakeDate } from \"../_lib/test/index.js\";\n import { startOfToday } from \"./index.js\";\n \n describe(\"startOfToday\", () => {\n-  let clock: sinon.SinonFakeTimers;\n-  beforeEach(() => {\n-    clock = sinon.useFakeTimers(\n-      new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500).getTime(),\n-    );\n-  });\n-\n-  afterEach(() => {\n-    clock.restore();\n-  });\n+  const { fakeNow } = fakeDate(\n+    new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500),\n+  );\n \n   it(\"returns the current date with the time set to 00:00:00\", () => {\n     const result = startOfToday();\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 25));\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfToday();\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2024-08-18T15:00:00Z\"));\n+      expect(startOfToday({ in: tz(\"Asia/Singapore\") }).toISOString()).toBe(\n+        \"2024-08-18T00:00:00.000+08:00\",\n+      );\n+      fakeNow(new Date(\"2024-08-18T16:00:00Z\"));\n+      expect(startOfToday({ in: tz(\"Asia/Singapore\") }).toISOString()).toBe(\n+        \"2024-08-19T00:00:00.000+08:00\",\n+      );\n+      fakeNow(new Date(\"2024-08-18T03:00:00Z\"));\n+      expect(startOfToday({ in: tz(\"America/New_York\") }).toISOString()).toBe(\n+        \"2024-08-17T00:00:00.000-04:00\",\n+      );\n+      fakeNow(new Date(\"2024-08-18T04:00:00Z\"));\n+      expect(startOfToday({ in: tz(\"America/New_York\") }).toISOString()).toBe(\n+        \"2024-08-18T00:00:00.000-04:00\",\n+      );\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = startOfToday({ in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfTomorrow/test.ts b/src/startOfTomorrow/test.ts\nindex ae45727f8a..082341777c 100644\n--- a/src/startOfTomorrow/test.ts\n+++ b/src/startOfTomorrow/test.ts\n@@ -1,31 +1,61 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import sinon from \"sinon\";\n+import { assertType, fakeDate } from \"../_lib/test/index.js\";\n import { startOfTomorrow } from \"./index.js\";\n \n describe(\"startOfTomorrow\", () => {\n-  it(\"returns the start of tomorrow\", () => {\n-    const clock = sinon.useFakeTimers(\n-      new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500).getTime(),\n-    );\n+  const { fakeNow } = fakeDate(\n+    new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500),\n+  );\n \n+  it(\"returns the start of tomorrow\", () => {\n     const result = startOfTomorrow();\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 26));\n-\n-    clock.restore();\n   });\n \n   it(\"handles dates before 100 AD\", () => {\n     const now = new Date(0);\n     now.setFullYear(14, 8 /* Sep */, 25);\n     now.setHours(0, 0, 0, 0);\n-    const clock = sinon.useFakeTimers(now.getTime());\n+    fakeNow(now);\n \n     const expectedResult = new Date(0);\n     expectedResult.setFullYear(14, 8 /* Sep */, 26);\n     expectedResult.setHours(0, 0, 0, 0);\n     const result = startOfTomorrow();\n     expect(result).toEqual(expectedResult);\n+  });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfTomorrow();\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2024-08-18T15:00:00Z\"));\n+      expect(startOfTomorrow({ in: tz(\"Asia/Singapore\") }).toISOString()).toBe(\n+        \"2024-08-19T00:00:00.000+08:00\",\n+      );\n+      fakeNow(new Date(\"2024-08-18T16:00:00Z\"));\n+      expect(startOfTomorrow({ in: tz(\"Asia/Singapore\") }).toISOString()).toBe(\n+        \"2024-08-20T00:00:00.000+08:00\",\n+      );\n+      fakeNow(new Date(\"2024-08-18T03:00:00Z\"));\n+      expect(\n+        startOfTomorrow({ in: tz(\"America/New_York\") }).toISOString(),\n+      ).toBe(\"2024-08-18T00:00:00.000-04:00\");\n+      fakeNow(new Date(\"2024-08-18T04:00:00Z\"));\n+      expect(\n+        startOfTomorrow({ in: tz(\"America/New_York\") }).toISOString(),\n+      ).toBe(\"2024-08-19T00:00:00.000-04:00\");\n+    });\n \n-    clock.restore();\n+    it(\"resolves the context date type\", () => {\n+      const result = startOfTomorrow({ in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n   });\n });\ndiff --git a/src/startOfWeek/test.ts b/src/startOfWeek/test.ts\nindex c2e1674912..a527cbf70f 100644\n--- a/src/startOfWeek/test.ts\n+++ b/src/startOfWeek/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { startOfWeek } from \"./index.js\";\n \n describe(\"startOfWeek\", () => {\n@@ -83,4 +86,50 @@ describe(\"startOfWeek\", () => {\n     const result = startOfWeek(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfWeek(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfWeek(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfWeek(\"2024-08-17T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-11T00:00:00.000+08:00\");\n+      expect(\n+        startOfWeek(\"2024-08-17T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-18T00:00:00.000+08:00\");\n+      expect(\n+        startOfWeek(\"2024-08-18T03:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-11T00:00:00.000-04:00\");\n+      expect(\n+        startOfWeek(\"2024-08-18T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-18T00:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = startOfWeek(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfWeekYear/test.ts b/src/startOfWeekYear/test.ts\nindex 4dd3e0964a..311a9863ba 100644\n--- a/src/startOfWeekYear/test.ts\n+++ b/src/startOfWeekYear/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { startOfWeekYear } from \"./index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"startOfWeekYear\", () => {\n   it(\"returns the date with the time set to 00:00:00 and the date set to the first day of a week year\", () => {\n@@ -57,4 +60,66 @@ describe(\"startOfWeekYear\", () => {\n     });\n     expect(result).toEqual(new Date(2005, 0 /* Jan */, 3, 0, 0, 0, 0));\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfWeekYear(Date.now(), {\n+      weekStartsOn: 1,\n+      firstWeekContainsDate: 4,\n+    });\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfWeekYear(new UTCDate(), {\n+      weekStartsOn: 1,\n+      firstWeekContainsDate: 4,\n+    });\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfWeekYear(\"2023-12-31T15:00:00Z\", {\n+          weekStartsOn: 1,\n+          firstWeekContainsDate: 4,\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2023-01-02T00:00:00.000+08:00\");\n+      expect(\n+        startOfWeekYear(\"2023-12-31T16:00:00Z\", {\n+          weekStartsOn: 1,\n+          firstWeekContainsDate: 4,\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-01-01T00:00:00.000+08:00\");\n+      expect(\n+        startOfWeekYear(\"2024-01-01T04:00:00Z\", {\n+          weekStartsOn: 1,\n+          firstWeekContainsDate: 4,\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2023-01-02T00:00:00.000-05:00\");\n+      expect(\n+        startOfWeekYear(\"2024-01-01T05:00:00Z\", {\n+          weekStartsOn: 1,\n+          firstWeekContainsDate: 4,\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-01-01T00:00:00.000-05:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = startOfWeekYear(date, {\n+        weekStartsOn: 1,\n+        firstWeekContainsDate: 4,\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfYear/test.ts b/src/startOfYear/test.ts\nindex 111f724aec..8c0b497027 100644\n--- a/src/startOfYear/test.ts\n+++ b/src/startOfYear/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { startOfYear } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n \n describe(\"startOfYear\", () => {\n   it(\"returns the date with the time set to 00:00:00 and the date set to the first day of a year\", () => {\n@@ -35,4 +38,50 @@ describe(\"startOfYear\", () => {\n     const result = startOfYear(new Date(NaN));\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfYear(Date.now());\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = startOfYear(new UTCDate());\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        startOfYear(\"2023-12-31T15:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2023-01-01T00:00:00.000+08:00\");\n+      expect(\n+        startOfYear(\"2023-12-31T16:00:00Z\", {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-01-01T00:00:00.000+08:00\");\n+      expect(\n+        startOfYear(\"2024-01-01T04:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2023-01-01T00:00:00.000-05:00\");\n+      expect(\n+        startOfYear(\"2024-01-01T05:00:00Z\", {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-01-01T00:00:00.000-05:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = startOfYear(date, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/startOfYesterday/test.ts b/src/startOfYesterday/test.ts\nindex 3f4aabbebc..0665c522bd 100644\n--- a/src/startOfYesterday/test.ts\n+++ b/src/startOfYesterday/test.ts\n@@ -1,31 +1,61 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n-import sinon from \"sinon\";\n+import { assertType, fakeDate } from \"../_lib/test/index.js\";\n import { startOfYesterday } from \"./index.js\";\n \n describe(\"startOfYesterday\", () => {\n-  it(\"returns the start of yesterday\", () => {\n-    const clock = sinon.useFakeTimers(\n-      new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500).getTime(),\n-    );\n+  const { fakeNow } = fakeDate(\n+    new Date(2014, 8 /* Sep */, 25, 14, 30, 45, 500),\n+  );\n \n+  it(\"returns the start of yesterday\", () => {\n     const result = startOfYesterday();\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 24));\n-\n-    clock.restore();\n   });\n \n   it(\"handles dates before 100 AD\", () => {\n     const now = new Date(0);\n     now.setFullYear(14, 8 /* Sep */, 25);\n     now.setHours(0, 0, 0, 0);\n-    const clock = sinon.useFakeTimers(now.getTime());\n+    fakeNow(now);\n \n     const expectedResult = new Date(0);\n     expectedResult.setFullYear(14, 8 /* Sep */, 24);\n     expectedResult.setHours(0, 0, 0, 0);\n     const result = startOfYesterday();\n     expect(result).toEqual(expectedResult);\n+  });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = startOfYesterday();\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      fakeNow(new Date(\"2024-08-18T15:00:00Z\"));\n+      expect(startOfYesterday({ in: tz(\"Asia/Singapore\") }).toISOString()).toBe(\n+        \"2024-08-17T00:00:00.000+08:00\",\n+      );\n+      fakeNow(new Date(\"2024-08-18T16:00:00Z\"));\n+      expect(startOfYesterday({ in: tz(\"Asia/Singapore\") }).toISOString()).toBe(\n+        \"2024-08-18T00:00:00.000+08:00\",\n+      );\n+      fakeNow(new Date(\"2024-08-18T03:00:00Z\"));\n+      expect(\n+        startOfYesterday({ in: tz(\"America/New_York\") }).toISOString(),\n+      ).toBe(\"2024-08-16T00:00:00.000-04:00\");\n+      fakeNow(new Date(\"2024-08-18T04:00:00Z\"));\n+      expect(\n+        startOfYesterday({ in: tz(\"America/New_York\") }).toISOString(),\n+      ).toBe(\"2024-08-17T00:00:00.000-04:00\");\n+    });\n \n-    clock.restore();\n+    it(\"resolves the context date type\", () => {\n+      const result = startOfYesterday({ in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n   });\n });\ndiff --git a/src/sub/test.ts b/src/sub/test.ts\nindex 3d4cd1b8e2..d1054bbaf8 100644\n--- a/src/sub/test.ts\n+++ b/src/sub/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { sub } from \"./index.js\";\n \n describe(\"sub\", () => {\n@@ -80,4 +83,42 @@ describe(\"sub\", () => {\n     const result = sub(new Date(NaN), { hours: 5 });\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = sub(Date.now(), { days: 5 });\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = sub(new UTCDate(), { days: 5 });\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        sub(\n+          \"2024-04-10T07:00:00Z\",\n+          { days: 5 },\n+          { in: tz(\"Asia/Singapore\") },\n+        ).toISOString(),\n+      ).toBe(\"2024-04-05T15:00:00.000+08:00\");\n+      expect(\n+        sub(\n+          \"2024-04-10T07:00:00Z\",\n+          { days: 5 },\n+          { in: tz(\"America/Los_Angeles\") },\n+        ).toISOString(),\n+      ).toBe(\"2024-04-05T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2024-09-01T00:00:00Z\");\n+      const result = sub(date, { days: 5 }, { in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subBusinessDays/test.ts b/src/subBusinessDays/test.ts\nindex 7ea3f92302..be1b26a735 100644\n--- a/src/subBusinessDays/test.ts\n+++ b/src/subBusinessDays/test.ts\n@@ -1,5 +1,8 @@\n import { describe, expect, it } from \"vitest\";\n import { subBusinessDays } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"subBusinessDays\", () => {\n   it(\"subtract the given number of business days\", () => {\n@@ -40,4 +43,50 @@ describe(\"subBusinessDays\", () => {\n     const result = subBusinessDays(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subBusinessDays(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subBusinessDays(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        subBusinessDays(\"2024-08-20T15:00:00Z\", 3, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-15T23:00:00.000+08:00\");\n+      expect(\n+        subBusinessDays(\"2024-08-20T16:00:00Z\", 3, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-16T00:00:00.000+08:00\");\n+      expect(\n+        subBusinessDays(new Date(\"2024-08-21T03:00:00Z\"), 3, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-15T23:00:00.000-04:00\");\n+      expect(\n+        subBusinessDays(new Date(\"2024-08-21T04:00:00Z\"), 3, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-08-16T00:00:00.000-04:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2014-09-01T00:00:00Z\");\n+      const result = subBusinessDays(date, 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subDays/test.ts b/src/subDays/test.ts\nindex b4f22323fd..6eab672e7d 100644\n--- a/src/subDays/test.ts\n+++ b/src/subDays/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { subDays } from \"./index.js\";\n \n describe(\"subDays\", () => {\n@@ -27,4 +30,38 @@ describe(\"subDays\", () => {\n     const result = subDays(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subDays(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subDays(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        subDays(\"2024-04-10T07:00:00Z\", 10, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-03-31T15:00:00.000+08:00\");\n+      expect(\n+        subDays(\"2024-04-10T07:00:00Z\", 10, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-03-31T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new Date(\"2024-09-01T00:00:00Z\");\n+      const result = subDays(date, 10, { in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subHours/test.ts b/src/subHours/test.ts\nindex ed559d1102..29a0465ea8 100644\n--- a/src/subHours/test.ts\n+++ b/src/subHours/test.ts\n@@ -1,4 +1,7 @@\n+import { tz, TZDate } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { subHours } from \"./index.js\";\n \n describe(\"subHours\", () => {\n@@ -30,4 +33,37 @@ describe(\"subHours\", () => {\n     const result = subHours(new Date(2014, 6 /* Jul */, 11, 1, 0), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subHours(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subHours(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        subHours(\"2024-04-10T07:00:00Z\", 10, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T05:00:00.000+08:00\");\n+      expect(\n+        subHours(\"2024-04-10T07:00:00Z\", 10, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-09T14:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = subHours(new Date(), 1, { in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subISOWeekYears/test.ts b/src/subISOWeekYears/test.ts\nindex b7638f78fd..e8b92ed9a5 100644\n--- a/src/subISOWeekYears/test.ts\n+++ b/src/subISOWeekYears/test.ts\n@@ -1,5 +1,10 @@\n+// subISOWeekYears tests with \"context\" feature\n+\n import { describe, expect, it } from \"vitest\";\n import { subISOWeekYears } from \"./index.js\";\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"subISOWeekYears\", () => {\n   it(\"subtracts the given number of ISO week-numbering years\", () => {\n@@ -41,4 +46,38 @@ describe(\"subISOWeekYears\", () => {\n     const result = subISOWeekYears(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subISOWeekYears(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subISOWeekYears(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        subISOWeekYears(\"2024-01-01T00:00:00Z\", 5, {\n+          in: tz(\"America/New_York\"),\n+        }).toISOString(),\n+      ).toBe(\"2018-12-30T00:00:00.000-05:00\");\n+      expect(\n+        subISOWeekYears(\"2024-01-01T00:00:00Z\", 5, {\n+          in: tz(\"Asia/Tokyo\"),\n+        }).toISOString(),\n+      ).toBe(\"2018-12-31T00:00:00.000+09:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const date = new UTCDate(\"2014-09-01T00:00:00Z\");\n+      const result = subISOWeekYears(date, 5, { in: tz(\"Asia/Tokyo\") });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subMilliseconds/test.ts b/src/subMilliseconds/test.ts\nindex 0e13fffcfb..7facb7fe46 100644\n--- a/src/subMilliseconds/test.ts\n+++ b/src/subMilliseconds/test.ts\n@@ -1,5 +1,8 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n import { describe, expect, it } from \"vitest\";\n import { subMilliseconds } from \"./index.js\";\n+import { assertType } from \"../_lib/test/index.js\";\n+import { UTCDate } from \"@date-fns/utc\";\n \n describe(\"subMilliseconds\", () => {\n   it(\"subtracts the given number of milliseconds\", () => {\n@@ -36,4 +39,34 @@ describe(\"subMilliseconds\", () => {\n     );\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subMilliseconds(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subMilliseconds(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        subMilliseconds(\"2024-04-10T07:00:00Z\", 10, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T14:59:59.990+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = subMilliseconds(\"2014-09-01T00:00:00Z\", 1000, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subMinutes/test.ts b/src/subMinutes/test.ts\nindex cb6e2328d3..49be1759ed 100644\n--- a/src/subMinutes/test.ts\n+++ b/src/subMinutes/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { subMinutes } from \"./index.js\";\n \n describe(\"subMinutes\", () => {\n@@ -30,4 +33,34 @@ describe(\"subMinutes\", () => {\n     const result = subMinutes(new Date(2014, 6 /* Jul */, 10, 12, 0), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subMinutes(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subMinutes(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        subMinutes(\"2024-04-10T07:00:00Z\", 10, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-04-10T15:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = subMinutes(\"2024-08-18T15:00:00Z\", 30, {\n+        in: tz(\"America/New_York\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subMonths/test.ts b/src/subMonths/test.ts\nindex 2142b98117..47ad5b2b8b 100644\n--- a/src/subMonths/test.ts\n+++ b/src/subMonths/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { subMonths } from \"./index.js\";\n \n describe(\"subMonths\", () => {\n@@ -18,7 +21,7 @@ describe(\"subMonths\", () => {\n     expect(date).toEqual(new Date(2014, 8 /* Sep */, 1));\n   });\n \n-  it(\"works well if the desired month has fewer days and the provided date is in the last day of a month\", () => {\n+  it(\"works if the desired month has fewer days and the provided date is in the last day of a month\", () => {\n     const date = new Date(2014, 11 /* Dec */, 31);\n     const result = subMonths(date, 3);\n     expect(result).toEqual(new Date(2014, 8 /* Sep */, 30));\n@@ -44,4 +47,34 @@ describe(\"subMonths\", () => {\n     const result = subMonths(new Date(2015, 1 /* Feb */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subMonths(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subMonths(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        subMonths(\"2024-04-10T07:00:00Z\", 10, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2023-06-10T15:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = subMonths(\"2024-08-18T15:00:00Z\", 30, {\n+        in: tz(\"America/New_York\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subQuarters/test.ts b/src/subQuarters/test.ts\nindex 8f6bfce304..068dc9eb93 100644\n--- a/src/subQuarters/test.ts\n+++ b/src/subQuarters/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { subQuarters } from \"./index.js\";\n \n describe(\"subQuarters\", () => {\n@@ -44,4 +47,34 @@ describe(\"subQuarters\", () => {\n     const result = subQuarters(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subQuarters(Date.now(), 2);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subQuarters(new UTCDate(), 2);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        subQuarters(\"2024-04-10T07:00:00Z\", 2, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2023-10-10T15:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = subQuarters(\"2024-08-18T15:00:00Z\", 2, {\n+        in: tz(\"America/New_York\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subSeconds/test.ts b/src/subSeconds/test.ts\nindex af08808063..221c27c9c0 100644\n--- a/src/subSeconds/test.ts\n+++ b/src/subSeconds/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { subSeconds } from \"./index.js\";\n \n describe(\"subSeconds\", () => {\n@@ -30,4 +33,34 @@ describe(\"subSeconds\", () => {\n     const result = subSeconds(new Date(2014, 6 /* Jul */, 10, 12, 45, 0), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subSeconds(Date.now(), 30);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subSeconds(new UTCDate(), 15);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context and handles timezones correctly\", () => {\n+      expect(\n+        subSeconds(new Date(\"2024-08-18T15:00:00Z\"), 18000, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toEqual(\"2024-08-18T18:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = subSeconds(\"2024-08-18T15:00:00Z\", 30, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subWeeks/test.ts b/src/subWeeks/test.ts\nindex 14488092ce..67e6bace08 100644\n--- a/src/subWeeks/test.ts\n+++ b/src/subWeeks/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { subWeeks } from \"./index.js\";\n \n describe(\"subWeeks\", () => {\n@@ -27,4 +30,39 @@ describe(\"subWeeks\", () => {\n     const result = subWeeks(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subWeeks(Date.now(), 1);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subWeeks(new UTCDate(), 1);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        subWeeks(\"2024-04-01T15:00:00Z\", 1, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-03-25T23:00:00.000+08:00\");\n+      expect(\n+        subWeeks(\"2024-04-01T16:00:00Z\", 1, {\n+          in: tz(\"Asia/Singapore\"),\n+        }).toISOString(),\n+      ).toBe(\"2024-03-26T00:00:00.000+08:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = subWeeks(\"2014-09-01T00:00:00Z\", 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/subYears/test.ts b/src/subYears/test.ts\nindex f7728f0ede..787bcc5095 100644\n--- a/src/subYears/test.ts\n+++ b/src/subYears/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { subYears } from \"./index.js\";\n \n describe(\"subYears\", () => {\n@@ -43,4 +46,34 @@ describe(\"subYears\", () => {\n     const result = subYears(new Date(2014, 8 /* Sep */, 1), NaN);\n     expect(result instanceof Date && isNaN(result.getTime())).toBe(true);\n   });\n+\n+  it(\"resolves the date type by default\", () => {\n+    const result = subYears(Date.now(), 5);\n+    expect(result).toBeInstanceOf(Date);\n+    assertType<assertType.Equal<Date, typeof result>>(true);\n+  });\n+\n+  it(\"resolves the argument type if a date extension is passed\", () => {\n+    const result = subYears(new UTCDate(), 5);\n+    expect(result).toBeInstanceOf(UTCDate);\n+    assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+  });\n+\n+  describe(\"context\", () => {\n+    it(\"allows to specify the context\", () => {\n+      expect(\n+        subYears(\"2024-04-10T07:00:00Z\", 5, {\n+          in: tz(\"America/Los_Angeles\"),\n+        }).toISOString(),\n+      ).toBe(\"2019-04-10T00:00:00.000-07:00\");\n+    });\n+\n+    it(\"resolves the context date type\", () => {\n+      const result = subYears(\"2014-09-01T00:00:00Z\", 1, {\n+        in: tz(\"Asia/Tokyo\"),\n+      });\n+      expect(result).toBeInstanceOf(TZDate);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/toDate/test.ts b/src/toDate/test.ts\nindex af0d4d239c..297ae3c304 100644\n--- a/src/toDate/test.ts\n+++ b/src/toDate/test.ts\n@@ -1,4 +1,7 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { UTCDate } from \"@date-fns/utc\";\n import { describe, expect, it } from \"vitest\";\n+import { assertType } from \"../_lib/test/index.js\";\n import { toDate } from \"./index.js\";\n \n describe(\"toDate\", () => {\n@@ -32,4 +35,24 @@ describe(\"toDate\", () => {\n       expect(isNaN(result.getTime())).toBe(true);\n     });\n   });\n+\n+  describe(\"types\", () => {\n+    it(\"resolves the date type by default\", () => {\n+      const result = toDate(Date.now());\n+      expect(result instanceof Date).toBe(true);\n+      assertType<assertType.Equal<Date, typeof result>>(true);\n+    });\n+\n+    it(\"resolves the argument type if a date extension is passed\", () => {\n+      const result = toDate(new UTCDate());\n+      expect(result instanceof UTCDate).toBe(true);\n+      assertType<assertType.Equal<UTCDate, typeof result>>(true);\n+    });\n+\n+    it(\"resolves the context type if it is passed\", () => {\n+      const result = toDate(new Date(), tz(\"Asia/Singapore\"));\n+      expect(result instanceof TZDate).toBe(true);\n+      assertType<assertType.Equal<TZDate, typeof result>>(true);\n+    });\n+  });\n });\ndiff --git a/src/transpose/test.ts b/src/transpose/test.ts\nnew file mode 100644\nindex 0000000000..d5436c7c01\n--- /dev/null\n+++ b/src/transpose/test.ts\n@@ -0,0 +1,18 @@\n+import { TZDate, tz } from \"@date-fns/tz\";\n+import { describe, expect, it } from \"vitest\";\n+import { transpose } from \"./index.js\";\n+\n+describe(\"transpose\", () => {\n+  it(\"allows to use context function\", () => {\n+    const date = new Date(2022, 6, 10, 12, 34, 56, 789);\n+    const result = transpose(date, tz(\"Asia/Singapore\"));\n+    expect(result instanceof TZDate).toBe(true);\n+    expect(result.getFullYear()).toBe(2022);\n+    expect(result.getMonth()).toBe(6);\n+    expect(result.getDate()).toBe(10);\n+    expect(result.getHours()).toBe(12);\n+    expect(result.getMinutes()).toBe(34);\n+    expect(result.getSeconds()).toBe(56);\n+    expect(result.getMilliseconds()).toBe(789);\n+  });\n+});\n", "problem_statement": "", "hints_text": "", "created_at": "2024-08-18T06:49:59Z"}
