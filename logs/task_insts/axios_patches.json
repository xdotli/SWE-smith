[
  {
    "instance_id": "axios__axios.ef36347f.7206",
    "repo": "axios__axios.ef36347f",
    "base_commit": "ef36347f",
    "patch": "diff --git a/lib/adapters/http.js b/lib/adapters/http.js\nindex 0577bf0..a925be0 100755\n--- a/lib/adapters/http.js\n+++ b/lib/adapters/http.js\n@@ -429,267 +429,4 @@ export default isHttpAdapterSupported && function httpAdapter(config) {\n     } else {\n       options.hostname = parsed.hostname.startsWith(\"[\") ? parsed.hostname.slice(1, -1) : parsed.hostname;\n       options.port = parsed.port;\n-      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n-    }\n-\n-    let transport;\n-    const isHttpsRequest = isHttps.test(options.protocol);\n-    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n-    if (config.transport) {\n-      transport = config.transport;\n-    } else if (config.maxRedirects === 0) {\n-      transport = isHttpsRequest ? https : http;\n-    } else {\n-      if (config.maxRedirects) {\n-        options.maxRedirects = config.maxRedirects;\n-      }\n-      if (config.beforeRedirect) {\n-        options.beforeRedirects.config = config.beforeRedirect;\n-      }\n-      transport = isHttpsRequest ? httpsFollow : httpFollow;\n-    }\n-\n-    if (config.maxBodyLength > -1) {\n-      options.maxBodyLength = config.maxBodyLength;\n-    } else {\n-      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n-      options.maxBodyLength = Infinity;\n-    }\n-\n-    if (config.insecureHTTPParser) {\n-      options.insecureHTTPParser = config.insecureHTTPParser;\n-    }\n-\n-    // Create the request\n-    req = transport.request(options, function handleResponse(res) {\n-      if (req.destroyed) return;\n-\n-      const streams = [res];\n-\n-      const responseLength = +res.headers['content-length'];\n-\n-      if (onDownloadProgress || maxDownloadRate) {\n-        const transformStream = new AxiosTransformStream({\n-          maxRate: utils.toFiniteNumber(maxDownloadRate)\n-        });\n-\n-        onDownloadProgress && transformStream.on('progress', flushOnFinish(\n-          transformStream,\n-          progressEventDecorator(\n-            responseLength,\n-            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)\n-          )\n-        ));\n-\n-        streams.push(transformStream);\n-      }\n-\n-      // decompress the response body transparently if required\n-      let responseStream = res;\n-\n-      // return the last request in case of redirects\n-      const lastRequest = res.req || req;\n-\n-      // if decompress disabled we should not decompress\n-      if (config.decompress !== false && res.headers['content-encoding']) {\n-        // if no content, but headers still say that it is encoded,\n-        // remove the header not confuse downstream operations\n-        if (method === 'HEAD' || res.statusCode === 204) {\n-          delete res.headers['content-encoding'];\n-        }\n-\n-        switch ((res.headers['content-encoding'] || '').toLowerCase()) {\n-        /*eslint default-case:0*/\n-        case 'gzip':\n-        case 'x-gzip':\n-        case 'compress':\n-        case 'x-compress':\n-          // add the unzipper to the body stream processing pipeline\n-          streams.push(zlib.createUnzip(zlibOptions));\n-\n-          // remove the content-encoding in order to not confuse downstream operations\n-          delete res.headers['content-encoding'];\n-          break;\n-        case 'deflate':\n-          streams.push(new ZlibHeaderTransformStream());\n-\n-          // add the unzipper to the body stream processing pipeline\n-          streams.push(zlib.createUnzip(zlibOptions));\n-\n-          // remove the content-encoding in order to not confuse downstream operations\n-          delete res.headers['content-encoding'];\n-          break;\n-        case 'br':\n-          if (isBrotliSupported) {\n-            streams.push(zlib.createBrotliDecompress(brotliOptions));\n-            delete res.headers['content-encoding'];\n-          }\n-        }\n-      }\n-\n-      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n-\n-      const offListeners = stream.finished(responseStream, () => {\n-        offListeners();\n-        onFinished();\n-      });\n-\n-      const response = {\n-        status: res.statusCode,\n-        statusText: res.statusMessage,\n-        headers: new AxiosHeaders(res.headers),\n-        config,\n-        request: lastRequest\n-      };\n-\n-      if (responseType === 'stream') {\n-        response.data = responseStream;\n-        settle(resolve, reject, response);\n-      } else {\n-        const responseBuffer = [];\n-        let totalResponseBytes = 0;\n-\n-        responseStream.on('data', function handleStreamData(chunk) {\n-          responseBuffer.push(chunk);\n-          totalResponseBytes += chunk.length;\n-\n-          // make sure the content length is not over the maxContentLength if specified\n-          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n-            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n-            rejected = true;\n-            responseStream.destroy();\n-            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n-              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n-          }\n-        });\n-\n-        responseStream.on('aborted', function handlerStreamAborted() {\n-          if (rejected) {\n-            return;\n-          }\n-\n-          const err = new AxiosError(\n-            'stream has been aborted',\n-            AxiosError.ERR_BAD_RESPONSE,\n-            config,\n-            lastRequest\n-          );\n-          responseStream.destroy(err);\n-          reject(err);\n-        });\n-\n-        responseStream.on('error', function handleStreamError(err) {\n-          if (req.destroyed) return;\n-          reject(AxiosError.from(err, null, config, lastRequest));\n-        });\n-\n-        responseStream.on('end', function handleStreamEnd() {\n-          try {\n-            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n-            if (responseType !== 'arraybuffer') {\n-              responseData = responseData.toString(responseEncoding);\n-              if (!responseEncoding || responseEncoding === 'utf8') {\n-                responseData = utils.stripBOM(responseData);\n-              }\n-            }\n-            response.data = responseData;\n-          } catch (err) {\n-            return reject(AxiosError.from(err, null, config, response.request, response));\n-          }\n-          settle(resolve, reject, response);\n-        });\n-      }\n-\n-      emitter.once('abort', err => {\n-        if (!responseStream.destroyed) {\n-          responseStream.emit('error', err);\n-          responseStream.destroy();\n-        }\n-      });\n-    });\n-\n-    emitter.once('abort', err => {\n-      reject(err);\n-      req.destroy(err);\n-    });\n-\n-    // Handle errors\n-    req.on('error', function handleRequestError(err) {\n-      // @todo remove\n-      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n-      reject(AxiosError.from(err, null, config, req));\n-    });\n-\n-    // set tcp keep alive to prevent drop connection by peer\n-    req.on('socket', function handleRequestSocket(socket) {\n-      // default interval of sending ack packet is 1 minute\n-      socket.setKeepAlive(true, 1000 * 60);\n-    });\n-\n-    // Handle request timeout\n-    if (config.timeout) {\n-      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n-      const timeout = parseInt(config.timeout, 10);\n-\n-      if (Number.isNaN(timeout)) {\n-        reject(new AxiosError(\n-          'error trying to parse `config.timeout` to int',\n-          AxiosError.ERR_BAD_OPTION_VALUE,\n-          config,\n-          req\n-        ));\n-\n-        return;\n-      }\n-\n-      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n-      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n-      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n-      // And then these socket which be hang up will devouring CPU little by little.\n-      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n-      req.setTimeout(timeout, function handleRequestTimeout() {\n-        if (isDone) return;\n-        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n-        const transitional = config.transitional || transitionalDefaults;\n-        if (config.timeoutErrorMessage) {\n-          timeoutErrorMessage = config.timeoutErrorMessage;\n-        }\n-        reject(new AxiosError(\n-          timeoutErrorMessage,\n-          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n-          config,\n-          req\n-        ));\n-        abort();\n-      });\n-    }\n-\n-\n-    // Send the request\n-    if (utils.isStream(data)) {\n-      let ended = false;\n-      let errored = false;\n-\n-      data.on('end', () => {\n-        ended = true;\n-      });\n-\n-      data.once('error', err => {\n-        errored = true;\n-        req.destroy(err);\n-      });\n-\n-      data.on('close', () => {\n-        if (!ended && !errored) {\n-          abort(new CanceledError('Request stream has been aborted', config, req));\n-        }\n-      });\n-\n-      data.pipe(req);\n-    } else {\n-      req.end(data);\n-    }\n-  });\n-}\n-\n-export const __setProxy = setProxy;\n+      setProxy(options, config.proxy, protocol\n\\ No newline at end of file\n",
    "problem_statement": "",
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": []
  },
  {
    "instance_id": "axios__axios.ef36347f.7202",
    "repo": "axios__axios.ef36347f",
    "base_commit": "ef36347f",
    "patch": "diff --git a/lib/adapters/http.js b/lib/adapters/http.js\nindex 0577bf0..a925be0 100755\n--- a/lib/adapters/http.js\n+++ b/lib/adapters/http.js\n@@ -429,267 +429,4 @@ export default isHttpAdapterSupported && function httpAdapter(config) {\n     } else {\n       options.hostname = parsed.hostname.startsWith(\"[\") ? parsed.hostname.slice(1, -1) : parsed.hostname;\n       options.port = parsed.port;\n-      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n-    }\n-\n-    let transport;\n-    const isHttpsRequest = isHttps.test(options.protocol);\n-    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n-    if (config.transport) {\n-      transport = config.transport;\n-    } else if (config.maxRedirects === 0) {\n-      transport = isHttpsRequest ? https : http;\n-    } else {\n-      if (config.maxRedirects) {\n-        options.maxRedirects = config.maxRedirects;\n-      }\n-      if (config.beforeRedirect) {\n-        options.beforeRedirects.config = config.beforeRedirect;\n-      }\n-      transport = isHttpsRequest ? httpsFollow : httpFollow;\n-    }\n-\n-    if (config.maxBodyLength > -1) {\n-      options.maxBodyLength = config.maxBodyLength;\n-    } else {\n-      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n-      options.maxBodyLength = Infinity;\n-    }\n-\n-    if (config.insecureHTTPParser) {\n-      options.insecureHTTPParser = config.insecureHTTPParser;\n-    }\n-\n-    // Create the request\n-    req = transport.request(options, function handleResponse(res) {\n-      if (req.destroyed) return;\n-\n-      const streams = [res];\n-\n-      const responseLength = +res.headers['content-length'];\n-\n-      if (onDownloadProgress || maxDownloadRate) {\n-        const transformStream = new AxiosTransformStream({\n-          maxRate: utils.toFiniteNumber(maxDownloadRate)\n-        });\n-\n-        onDownloadProgress && transformStream.on('progress', flushOnFinish(\n-          transformStream,\n-          progressEventDecorator(\n-            responseLength,\n-            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)\n-          )\n-        ));\n-\n-        streams.push(transformStream);\n-      }\n-\n-      // decompress the response body transparently if required\n-      let responseStream = res;\n-\n-      // return the last request in case of redirects\n-      const lastRequest = res.req || req;\n-\n-      // if decompress disabled we should not decompress\n-      if (config.decompress !== false && res.headers['content-encoding']) {\n-        // if no content, but headers still say that it is encoded,\n-        // remove the header not confuse downstream operations\n-        if (method === 'HEAD' || res.statusCode === 204) {\n-          delete res.headers['content-encoding'];\n-        }\n-\n-        switch ((res.headers['content-encoding'] || '').toLowerCase()) {\n-        /*eslint default-case:0*/\n-        case 'gzip':\n-        case 'x-gzip':\n-        case 'compress':\n-        case 'x-compress':\n-          // add the unzipper to the body stream processing pipeline\n-          streams.push(zlib.createUnzip(zlibOptions));\n-\n-          // remove the content-encoding in order to not confuse downstream operations\n-          delete res.headers['content-encoding'];\n-          break;\n-        case 'deflate':\n-          streams.push(new ZlibHeaderTransformStream());\n-\n-          // add the unzipper to the body stream processing pipeline\n-          streams.push(zlib.createUnzip(zlibOptions));\n-\n-          // remove the content-encoding in order to not confuse downstream operations\n-          delete res.headers['content-encoding'];\n-          break;\n-        case 'br':\n-          if (isBrotliSupported) {\n-            streams.push(zlib.createBrotliDecompress(brotliOptions));\n-            delete res.headers['content-encoding'];\n-          }\n-        }\n-      }\n-\n-      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n-\n-      const offListeners = stream.finished(responseStream, () => {\n-        offListeners();\n-        onFinished();\n-      });\n-\n-      const response = {\n-        status: res.statusCode,\n-        statusText: res.statusMessage,\n-        headers: new AxiosHeaders(res.headers),\n-        config,\n-        request: lastRequest\n-      };\n-\n-      if (responseType === 'stream') {\n-        response.data = responseStream;\n-        settle(resolve, reject, response);\n-      } else {\n-        const responseBuffer = [];\n-        let totalResponseBytes = 0;\n-\n-        responseStream.on('data', function handleStreamData(chunk) {\n-          responseBuffer.push(chunk);\n-          totalResponseBytes += chunk.length;\n-\n-          // make sure the content length is not over the maxContentLength if specified\n-          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n-            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n-            rejected = true;\n-            responseStream.destroy();\n-            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n-              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n-          }\n-        });\n-\n-        responseStream.on('aborted', function handlerStreamAborted() {\n-          if (rejected) {\n-            return;\n-          }\n-\n-          const err = new AxiosError(\n-            'stream has been aborted',\n-            AxiosError.ERR_BAD_RESPONSE,\n-            config,\n-            lastRequest\n-          );\n-          responseStream.destroy(err);\n-          reject(err);\n-        });\n-\n-        responseStream.on('error', function handleStreamError(err) {\n-          if (req.destroyed) return;\n-          reject(AxiosError.from(err, null, config, lastRequest));\n-        });\n-\n-        responseStream.on('end', function handleStreamEnd() {\n-          try {\n-            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n-            if (responseType !== 'arraybuffer') {\n-              responseData = responseData.toString(responseEncoding);\n-              if (!responseEncoding || responseEncoding === 'utf8') {\n-                responseData = utils.stripBOM(responseData);\n-              }\n-            }\n-            response.data = responseData;\n-          } catch (err) {\n-            return reject(AxiosError.from(err, null, config, response.request, response));\n-          }\n-          settle(resolve, reject, response);\n-        });\n-      }\n-\n-      emitter.once('abort', err => {\n-        if (!responseStream.destroyed) {\n-          responseStream.emit('error', err);\n-          responseStream.destroy();\n-        }\n-      });\n-    });\n-\n-    emitter.once('abort', err => {\n-      reject(err);\n-      req.destroy(err);\n-    });\n-\n-    // Handle errors\n-    req.on('error', function handleRequestError(err) {\n-      // @todo remove\n-      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n-      reject(AxiosError.from(err, null, config, req));\n-    });\n-\n-    // set tcp keep alive to prevent drop connection by peer\n-    req.on('socket', function handleRequestSocket(socket) {\n-      // default interval of sending ack packet is 1 minute\n-      socket.setKeepAlive(true, 1000 * 60);\n-    });\n-\n-    // Handle request timeout\n-    if (config.timeout) {\n-      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n-      const timeout = parseInt(config.timeout, 10);\n-\n-      if (Number.isNaN(timeout)) {\n-        reject(new AxiosError(\n-          'error trying to parse `config.timeout` to int',\n-          AxiosError.ERR_BAD_OPTION_VALUE,\n-          config,\n-          req\n-        ));\n-\n-        return;\n-      }\n-\n-      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n-      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n-      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n-      // And then these socket which be hang up will devouring CPU little by little.\n-      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n-      req.setTimeout(timeout, function handleRequestTimeout() {\n-        if (isDone) return;\n-        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n-        const transitional = config.transitional || transitionalDefaults;\n-        if (config.timeoutErrorMessage) {\n-          timeoutErrorMessage = config.timeoutErrorMessage;\n-        }\n-        reject(new AxiosError(\n-          timeoutErrorMessage,\n-          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n-          config,\n-          req\n-        ));\n-        abort();\n-      });\n-    }\n-\n-\n-    // Send the request\n-    if (utils.isStream(data)) {\n-      let ended = false;\n-      let errored = false;\n-\n-      data.on('end', () => {\n-        ended = true;\n-      });\n-\n-      data.once('error', err => {\n-        errored = true;\n-        req.destroy(err);\n-      });\n-\n-      data.on('close', () => {\n-        if (!ended && !errored) {\n-          abort(new CanceledError('Request stream has been aborted', config, req));\n-        }\n-      });\n-\n-      data.pipe(req);\n-    } else {\n-      req.end(data);\n-    }\n-  });\n-}\n-\n-export const __setProxy = setProxy;\n+      setProxy(options, config.proxy, protocol\n\\ No newline at end of file\n",
    "problem_statement": "",
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": []
  },
  {
    "instance_id": "axios__axios.ef36347f.7229",
    "repo": "axios__axios.ef36347f",
    "base_commit": "ef36347f",
    "patch": "diff --git a/lib/adapters/http.js b/lib/adapters/http.js\nindex 28d3d2bb64..dfa6386d32 100755\n--- a/lib/adapters/http.js\n+++ b/lib/adapters/http.js\n@@ -816,8 +816,6 @@ export default isHttpAdapterSupported && function httpAdapter(config) {\n \n     // Handle errors\n     req.on('error', function handleRequestError(err) {\n-      // @todo remove\n-      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n       reject(AxiosError.from(err, null, config, req));\n     });\n \n",
    "problem_statement": "",
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": []
  }
]