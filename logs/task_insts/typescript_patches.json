[
  {
    "instance_id": "calcom__cal.com.main.25597",
    "repo": "calcom/cal.com",
    "base_commit": "06055729692e4e6df0f1684d94158b75ac7c02bb",
    "bug_patch": "diff --git a/packages/features/CalendarEventBuilder.test.ts b/packages/features/CalendarEventBuilder.test.ts\nindex 4bede68..e5b355a 100644\n--- a/packages/features/CalendarEventBuilder.test.ts\n+++ b/packages/features/CalendarEventBuilder.test.ts\n@@ -486,1425 +486,4 @@ describe(\"CalendarEventBuilder\", () => {\n \n     const event = new CalendarEventBuilder()\n       .withBasicDetails({\n-        bookerUrl: \"https://cal.com/user/test-slug\",\n-        title: \"Test Event\",\n-        startTime: mockStartTime,\n-        endTime: mockEndTime,\n-      })\n-      .withEventType({\n-        slug: \"test-slug\",\n-        id: 123,\n-      })\n-      .withTeam(team)\n-      .build();\n-\n-    expect(event).not.toBeNull();\n-    if (event) {\n-      expect(event.team).toEqual(team);\n-    }\n-  });\n-\n-  it(\"should create an event with recurring event information\", () => {\n-    const recurringEvent = {\n-      count: 5,\n-      freq: 2,\n-      interval: 1,\n-    };\n-\n-    const event = new CalendarEventBuilder()\n-      .withBasicDetails({\n-        bookerUrl: \"https://cal.com/user/test-slug\",\n-        title: \"Test Event\",\n-        startTime: mockStartTime,\n-        endTime: mockEndTime,\n-      })\n-      .withEventType({\n-        slug: \"test-slug\",\n-        id: 123,\n-      })\n-      .withRecurring(recurringEvent)\n-      .build();\n-\n-    expect(event).not.toBeNull();\n-    if (event) {\n-      expect(event.recurringEvent).toEqual(recurringEvent);\n-    }\n-  });\n-\n-  it(\"should create an event with attendee seat ID\", () => {\n-    const event = new CalendarEventBuilder()\n-      .withBasicDetails({\n-        bookerUrl: \"https://cal.com/user/test-slug\",\n-        title: \"Test Event\",\n-        startTime: mockStartTime,\n-        endTime: mockEndTime,\n-      })\n-      .withEventType({\n-        slug: \"test-slug\",\n-        id: 123,\n-      })\n-      .withAttendeeSeatId(\"seat-123\")\n-      .build();\n-\n-    expect(event).not.toBeNull();\n-    if (event) {\n-      expect(event.attendeeSeatId).toBe(\"seat-123\");\n-    }\n-  });\n-\n-  it(\"should create an event with UID\", () => {\n-    const event = new CalendarEventBuilder()\n-      .withBasicDetails({\n-        bookerUrl: \"https://cal.com/user/test-slug\",\n-        title: \"Test Event\",\n-        startTime: mockStartTime,\n-        endTime: mockEndTime,\n-      })\n-      .withEventType({\n-        slug: \"test-slug\",\n-        id: 123,\n-      })\n-      .withUid(\"booking-uid-123\")\n-      .build();\n-\n-    expect(event).not.toBeNull();\n-    if (event) {\n-      expect(event.uid).toBe(\"booking-uid-123\");\n-    }\n-  });\n-\n-  it(\"should create an event with one-time password\", () => {\n-    const event = new CalendarEventBuilder()\n-      .withBasicDetails({\n-        bookerUrl: \"https://cal.com/user/test-slug\",\n-        title: \"Test Event\",\n-        startTime: mockStartTime,\n-        endTime: mockEndTime,\n-      })\n-      .withEventType({\n-        slug: \"test-slug\",\n-        id: 123,\n-      })\n-      .withOneTimePassword(\"otp123\")\n-      .build();\n-\n-    expect(event).not.toBeNull();\n-    if (event) {\n-      expect(event.oneTimePassword).toBe(\"otp123\");\n-    }\n-  });\n-\n-  it(\"should create an event with recurring event ID\", () => {\n-    const event = new CalendarEventBuilder()\n-      .withBasicDetails({\n-        bookerUrl: \"https://cal.com/user/test-slug\",\n-        title: \"Test Event\",\n-        startTime: mockStartTime,\n-        endTime: mockEndTime,\n-      })\n-      .withEventType({\n-        slug: \"test-slug\",\n-        id: 123,\n-      })\n-      .withRecurringEventId(\"recurring-123\")\n-      .build();\n-\n-    expect(event).not.toBeNull();\n-    if (event) {\n-      expect(event.existingRecurringEvent).toEqual({\n-        recurringEventId: \"recurring-123\",\n-      });\n-    }\n-  });\n-\n-  it(\"should create a complete calendar event with all properties\", () => {\n-    const event = new CalendarEventBuilder()\n-      .withBasicDetails({\n-        bookerUrl: \"https://cal.com/user/test-slug\",\n-        title: \"Complete Test Event\",\n-        startTime: mockStartTime,\n-        endTime: mockEndTime,\n-        additionalNotes: \"Complete test notes\",\n-      })\n-      .withEventType({\n-        slug: \"complete-test\",\n-        description: \"Complete test description\",\n-        id: 123,\n-        hideCalendarNotes: true,\n-        hideCalendarEventDetails: false,\n-      })\n-      .withOrganizer({\n-        id: 456,\n-        name: \"John Doe\",\n-        email: \"john@example.com\",\n-        username: \"johndoe\",\n-        timeZone: \"America/New_York\",\n-        language: {\n-          translate: mockTranslate,\n-          locale: \"en\",\n-        },\n-      })\n-      .withAttendees([\n-        {\n-          email: \"attendee@example.com\",\n-          name: \"Attendee\",\n-          timeZone: \"Europe/London\",\n-          language: {\n-            translate: mockTranslate,\n-            locale: \"en\",\n-          },\n-        },\n-      ])\n-      .withMetadataAndResponses({\n-        customInputs: { question1: \"answer1\" },\n-        responses: {\n-          name: { label: \"your_name\", value: \"Owner 1\", isHidden: false },\n-          email: {\n-            label: \"email_address\",\n-            value: \"owner1-dunder@example.com\",\n-            isHidden: false,\n-          },\n-        },\n-      })\n-      .withLocation({\n-        location: \"Conference Room A\",\n-      })\n-      .withDestinationCalendar([\n-        {\n-          id: 1,\n-          integration: \"google_calendar\",\n-          externalId: \"external123\",\n-          primaryEmail: \"primary@example.com\",\n-          userId: 1,\n-          eventTypeId: 123,\n-          credentialId: 1,\n-          createdAt: null,\n-          updatedAt: null,\n-          delegationCredentialId: null,\n-          domainWideDelegationCredentialId: null,\n-        },\n-      ])\n-      .withIdentifiers({\n-        iCalUID: \"ical-123\",\n-        iCalSequence: 2,\n-      })\n-      .withConfirmation({\n-        requiresConfirmation: true,\n-        isConfirmedByDefault: false,\n-      })\n-      .withPlatformVariables({\n-        platformClientId: \"client-123\",\n-      })\n-      .withAppsStatus([\n-        {\n-          appName: \"google-calendar\",\n-          type: \"google_calendar\",\n-          success: 1,\n-          failures: 0,\n-          errors: [],\n-          warnings: [],\n-        },\n-      ])\n-      .withVideoCallData({\n-        type: \"google_meet\",\n-        id: \"123\",\n-        url: \"https://meet.example.com/123\",\n-        password: \"password123\",\n-      })\n-      .withTeam({\n-        name: \"Engineering Team\",\n-        members: [],\n-        id: 101,\n-      })\n-      .withRecurring({\n-        count: 5,\n-        freq: 2,\n-        interval: 1,\n-      })\n-      .withAttendeeSeatId(\"seat-123\")\n-      .withUid(\"booking-uid-123\")\n-      .withOneTimePassword(\"otp123\")\n-      .build();\n-\n-    // Test that all properties are set correctly\n-    expect(event).not.toBeNull();\n-    if (event) {\n-      expect(event.title).toBe(\"Complete Test Event\");\n-      expect(event.type).toBe(\"complete-test\");\n-      expect(event.organizer.name).toBe(\"John Doe\");\n-      expect(event.attendees).toHaveLength(1);\n-      expect(event.location).toBe(\"Conference Room A\");\n-      expect(event.iCalUID).toBe(\"ical-123\");\n-      expect(event.requiresConfirmation).toBe(true);\n-      expect(event.platformClientId).toBe(\"client-123\");\n-      expect(event.appsStatus).toHaveLength(1);\n-      expect(event.videoCallData?.url).toBe(\"https://meet.example.com/123\");\n-      expect(event.team?.name).toBe(\"Engineering Team\");\n-      expect(event.recurringEvent?.count).toBe(5);\n-      expect(event.attendeeSeatId).toBe(\"seat-123\");\n-      expect(event.uid).toBe(\"booking-uid-123\");\n-      expect(event.oneTimePassword).toBe(\"otp123\");\n-    }\n-  });\n-\n-  it(\"should return null when building without required fields\", () => {\n-    const builder = new CalendarEventBuilder();\n-    expect(builder.build()).toBeNull();\n-  });\n-\n-  it(\"should create an event from an existing event\", () => {\n-    const existingEvent = {\n-      title: \"Existing Event\",\n-      startTime: mockStartTime,\n-      endTime: mockEndTime,\n-      type: \"existing-type\",\n-      bookerUrl: \"https://cal.com/user/test-slug\",\n-    };\n-\n-    const event = CalendarEventBuilder.fromEvent(existingEvent)\n-      .withBasicDetails({\n-        bookerUrl: \"https://cal.com/user/test-slug\",\n-        title: \"Updated Event\",\n-        startTime: mockStartTime,\n-        endTime: mockEndTime,\n-      })\n-      .build();\n-\n-    expect(event).not.toBeNull();\n-    if (event) {\n-      expect(event.title).toBe(\"Updated Event\");\n-      expect(event.type).toBe(\"existing-type\");\n-    }\n-  });\n-\n-  it(\"should propagate disableCancelling and disableRescheduling\", () => {\n-    const event = new CalendarEventBuilder()\n-      .withBasicDetails({\n-        bookerUrl: \"https://cal.com/user/test-slug\",\n-        title: \"Test Event\",\n-        startTime: mockStartTime,\n-        endTime: mockEndTime,\n-        additionalNotes: \"Some notes\",\n-      })\n-      .withEventType({\n-        slug: \"test-slug\",\n-        description: \"Test description\",\n-        id: 123,\n-        disableCancelling: true,\n-        disableRescheduling: true,\n-      })\n-      .build();\n-\n-    expect(event).not.toBeNull();\n-    if (event) {\n-      expect(event.disableCancelling).toBe(true);\n-      expect(event.disableRescheduling).toBe(true);\n-    }\n-  });\n-\n-  describe(\"fromBooking\", () => {\n-    it(\"should create a calendar event from a basic booking\", async () => {\n-      const mockBooking = {\n-        uid: \"booking-123\",\n-        metadata: null,\n-        title: \"Test Booking\",\n-        startTime: new Date(mockStartTime),\n-        endTime: new Date(mockEndTime),\n-        description: \"Test booking description\",\n-        location: \"Conference Room A\",\n-        responses: {\n-          name: { label: \"your_name\", value: \"John Doe\" },\n-          email: { label: \"email_address\", value: \"john@example.com\" },\n-        },\n-        customInputs: null,\n-        iCalUID: \"ical-uid-123\",\n-        iCalSequence: 1,\n-        oneTimePassword: null,\n-        attendees: [\n-          {\n-            name: \"Attendee One\",\n-            email: \"attendee1@example.com\",\n-            timeZone: \"America/New_York\",\n-            locale: \"en\",\n-            phoneNumber: null,\n-          },\n-        ],\n-        user: {\n-          id: 1,\n-          name: \"Organizer Name\",\n-          email: \"organizer@example.com\",\n-          username: \"organizer\",\n-          timeZone: \"America/Los_Angeles\",\n-          locale: \"en\",\n-          timeFormat: 12,\n-          destinationCalendar: null,\n-          profiles: [],\n-        },\n-        destinationCalendar: null,\n-        eventType: {\n-          id: 100,\n-          slug: \"test-event\",\n-          title: \"60 minutes\",\n-          description: \"Test event description\",\n-          hideCalendarNotes: false,\n-          hideCalendarEventDetails: false,\n-          hideOrganizerEmail: false,\n-          schedulingType: null,\n-          seatsPerTimeSlot: null,\n-          seatsShowAttendees: false,\n-          seatsShowAvailabilityCount: false,\n-          customReplyToEmail: null,\n-          disableRescheduling: false,\n-          disableCancelling: false,\n-          requiresConfirmation: false,\n-          recurringEvent: null,\n-          bookingFields: [],\n-          metadata: null,\n-          eventName: null,\n-          team: null,\n-          users: [],\n-          hosts: [],\n-          workflows: [],\n-        },\n-        references: [],\n-        seatsReferences: [],\n-      } satisfies BookingForCalEventBuilder;\n-\n-      const eventFromBooking = await CalendarEventBuilder.fromBooking(mockBooking);\n-      const builtEvent = eventFromBooking.build();\n-\n-      expect(builtEvent).not.toBeNull();\n-      if (builtEvent) {\n-        expect(builtEvent.uid).toBe(\"booking-123\");\n-        expect(builtEvent.title).toBe(\"Test Booking\");\n-        expect(builtEvent.startTime).toBe(new Date(mockStartTime).toISOString());\n-        expect(builtEvent.endTime).toBe(new Date(mockEndTime).toISOString());\n-        expect(builtEvent.additionalNotes).toBe(\"Test booking description\");\n-        expect(builtEvent.location).toBe(\"Conference Room A\");\n-        expect(builtEvent.type).toBe(\"test-event\");\n-        expect(builtEvent.eventTypeId).toBe(100);\n-        expect(builtEvent.organizer.name).toBe(\"Organizer Name\");\n-        expect(builtEvent.organizer.email).toBe(\"organizer@example.com\");\n-        expect(builtEvent.attendees).toHaveLength(1);\n-        expect(builtEvent.attendees[0].email).toBe(\"attendee1@example.com\");\n-        expect(builtEvent.iCalUID).toBe(\"ical-uid-123\");\n-        expect(builtEvent.iCalSequence).toBe(1);\n-      }\n-    });\n-\n-    it(\"should create a calendar event from booking with video call data\", async () => {\n-      const mockBooking = {\n-        uid: \"booking-456\",\n-        metadata: null,\n-        title: \"Video Meeting\",\n-        startTime: new Date(mockStartTime),\n-        endTime: new Date(mockEndTime),\n-        description: null,\n-        location: \"integrations:zoom\",\n-        responses: null,\n-        customInputs: null,\n-        iCalUID: null,\n-        iCalSequence: 0,\n-        oneTimePassword: null,\n-        attendees: [\n-          {\n-            name: \"Attendee Two\",\n-            email: \"attendee2@example.com\",\n-            timeZone: \"Europe/London\",\n-            locale: \"en\",\n-            phoneNumber: null,\n-          },\n-        ],\n-        user: {\n-          id: 2,\n-          name: \"Host Name\",\n-          email: \"host@example.com\",\n-          username: \"host\",\n-          timeZone: \"UTC\",\n-          locale: \"en\",\n-          timeFormat: 24,\n-          destinationCalendar: null,\n-          profiles: [],\n-        },\n-        destinationCalendar: null,\n-        eventType: {\n-          id: 200,\n-          title: \"60 minutes\",\n-          slug: \"video-call\",\n-          description: \"Video call event\",\n-          hideCalendarNotes: false,\n-          hideCalendarEventDetails: false,\n-          hideOrganizerEmail: false,\n-          schedulingType: null,\n-          seatsPerTimeSlot: null,\n-          seatsShowAttendees: false,\n-          seatsShowAvailabilityCount: false,\n-          customReplyToEmail: null,\n-          disableRescheduling: false,\n-          disableCancelling: false,\n-          requiresConfirmation: false,\n-          recurringEvent: null,\n-          bookingFields: [],\n-          metadata: null,\n-          eventName: null,\n-          team: null,\n-          users: [],\n-          hosts: [],\n-          workflows: [],\n-        },\n-        references: [\n-          {\n-            type: \"zoom_video\",\n-            uid: \"123423432sdqnwhdh\",\n-            meetingId: \"zoom-123\",\n-            meetingPassword: \"password123\",\n-            meetingUrl: \"https://zoom.us/j/123\",\n-          },\n-        ],\n-        seatsReferences: [],\n-      } satisfies BookingForCalEventBuilder;\n-\n-      const eventFromBooking = await CalendarEventBuilder.fromBooking(mockBooking);\n-      const builtEvent = eventFromBooking.build();\n-\n-      expect(builtEvent).not.toBeNull();\n-      if (builtEvent) {\n-        expect(builtEvent.videoCallData).toBeDefined();\n-        expect(builtEvent.videoCallData?.type).toBe(\"zoom_video\");\n-        expect(builtEvent.videoCallData?.id).toBe(\"zoom-123\");\n-        expect(builtEvent.videoCallData?.password).toBe(\"password123\");\n-        expect(builtEvent.videoCallData?.url).toBe(\"https://zoom.us/j/123\");\n-        expect(builtEvent.appsStatus).toHaveLength(1);\n-        expect(builtEvent.appsStatus?.[0].type).toBe(\"zoom_video\");\n-      }\n-    });\n-\n-    it(\"should create a calendar event from booking with team\", async () => {\n-      // Note: The CalendarEventBuilder filters team members to only include hosts\n-      // whose emails appear in booking.attendees. This simulates a COLLECTIVE event\n-      // where all hosts are assigned to the booking.\n-      const mockBooking = {\n-        uid: \"booking-789\",\n-        metadata: null,\n-        title: \"Team Meeting\",\n-        startTime: new Date(mockStartTime),\n-        endTime: new Date(mockEndTime),\n-        description: \"Team event description\",\n-        location: \"Office\",\n-        responses: null,\n-        customInputs: null,\n-        iCalUID: null,\n-        iCalSequence: 0,\n-        oneTimePassword: null,\n-        attendees: [\n-          {\n-            name: \"Client\",\n-            email: \"client@example.com\",\n-            timeZone: \"America/Chicago\",\n-            locale: \"en\",\n-            phoneNumber: null,\n-          },\n-          {\n-            // Team member host - included in attendees for COLLECTIVE events\n-            name: \"Team Member\",\n-            email: \"member@example.com\",\n-            timeZone: \"America/Los_Angeles\",\n-            locale: \"en\",\n-            phoneNumber: null,\n-          },\n-        ],\n-        user: {\n-          id: 3,\n-          name: \"Team Lead\",\n-          email: \"lead@example.com\",\n-          username: \"lead\",\n-          timeZone: \"America/New_York\",\n-          locale: \"en\",\n-          timeFormat: 12,\n-          destinationCalendar: {\n-            id: 1,\n-            integration: \"google_calendar\",\n-            externalId: \"external-1\",\n-            primaryEmail: \"lead@example.com\",\n-            userId: 3,\n-            eventTypeId: null,\n-            credentialId: 1,\n-            createdAt: null,\n-            updatedAt: null,\n-            delegationCredentialId: null,\n-            domainWideDelegationCredentialId: null,\n-          },\n-          profiles: [],\n-        },\n-        destinationCalendar: null,\n-        eventType: {\n-          title: \"60 minutes\",\n-          id: 300,\n-          slug: \"team-event\",\n-          description: \"Team event\",\n-          hideCalendarNotes: false,\n-          hideCalendarEventDetails: false,\n-          hideOrganizerEmail: false,\n-          schedulingType: \"COLLECTIVE\",\n-          seatsPerTimeSlot: null,\n-          seatsShowAttendees: false,\n-          seatsShowAvailabilityCount: false,\n-          customReplyToEmail: null,\n-          disableRescheduling: false,\n-          disableCancelling: false,\n-          requiresConfirmation: false,\n-          recurringEvent: null,\n-          bookingFields: [],\n-          metadata: null,\n-          eventName: null,\n-          team: {\n-            id: 10,\n-            name: \"Engineering Team\",\n-            parentId: null,\n-            members: [],\n-          },\n-          users: [],\n-          hosts: [\n-            {\n-              userId: 3,\n-              isFixed: true,\n-              user: {\n-                id: 3,\n-                name: \"Team Lead\",\n-                email: \"lead@example.com\",\n-                username: \"lead\",\n-                timeZone: \"America/New_York\",\n-                locale: \"en\",\n-                timeFormat: 12,\n-                destinationCalendar: {\n-                  id: 1,\n-                  integration: \"google_calendar\",\n-                  externalId: \"external-1\",\n-                  primaryEmail: \"lead@example.com\",\n-                  userId: 3,\n-                  eventTypeId: null,\n-                  credentialId: 1,\n-                  createdAt: null,\n-                  updatedAt: null,\n-                  delegationCredentialId: null,\n-                  domainWideDelegationCredentialId: null,\n-                },\n-              },\n-            },\n-            {\n-              userId: 4,\n-              isFixed: false,\n-              user: {\n-                id: 4,\n-                name: \"Team Member\",\n-                email: \"member@example.com\",\n-                username: \"member\",\n-                timeZone: \"America/Los_Angeles\",\n-                locale: \"en\",\n-                timeFormat: 24,\n-                destinationCalendar: {\n-                  id: 2,\n-                  integration: \"google_calendar\",\n-                  externalId: \"external-2\",\n-                  primaryEmail: \"member@example.com\",\n-                  userId: 4,\n-                  eventTypeId: null,\n-                  credentialId: 2,\n-                  createdAt: null,\n-                  updatedAt: null,\n-                  delegationCredentialId: null,\n-                  domainWideDelegationCredentialId: null,\n-                },\n-              },\n-            },\n-          ],\n-          workflows: [],\n-        },\n-        references: [],\n-        seatsReferences: [],\n-      } satisfies BookingForCalEventBuilder;\n-\n-      const eventFromBooking = await CalendarEventBuilder.fromBooking(mockBooking);\n-      const builtEvent = eventFromBooking.build();\n-\n-      expect(builtEvent).not.toBeNull();\n-      if (builtEvent) {\n-        expect(builtEvent.team).toBeDefined();\n-        expect(builtEvent.team?.id).toBe(10);\n-        expect(builtEvent.team?.name).toBe(\"Engineering Team\");\n-        expect(builtEvent.team?.members).toHaveLength(1); // Excludes organizer\n-        expect(builtEvent.team?.members[0].email).toBe(\"member@example.com\");\n-        expect(builtEvent.destinationCalendar).toHaveLength(3); // 2 hosts + 1 user calendar\n-        expect(builtEvent.schedulingType).toBe(\"COLLECTIVE\");\n-      }\n-    });\n-\n-    it(\"should create a calendar event from booking with recurring event\", async () => {\n-      const mockBooking = {\n-        uid: \"booking-recurring\",\n-        metadata: null,\n-        title: \"Recurring Meeting\",\n-        startTime: new Date(mockStartTime),\n-        endTime: new Date(mockEndTime),\n-        description: null,\n-        location: \"Zoom\",\n-        responses: null,\n-        customInputs: null,\n-        iCalUID: null,\n-        iCalSequence: 0,\n-        oneTimePassword: null,\n-        attendees: [\n-          {\n-            name: \"Regular Attendee\",\n-            email: \"regular@example.com\",\n-            timeZone: \"America/New_York\",\n-            locale: \"en\",\n-            phoneNumber: null,\n-          },\n-        ],\n-        user: {\n-          id: 5,\n-          name: \"Recurring Host\",\n-          email: \"recurring@example.com\",\n-          username: \"recurring\",\n-          timeZone: \"America/New_York\",\n-          locale: \"en\",\n-          timeFormat: 12,\n-          destinationCalendar: null,\n-          profiles: [],\n-        },\n-        destinationCalendar: null,\n-        eventType: {\n-          title: \"60 minutes\",\n-          id: 400,\n-          slug: \"recurring-event\",\n-          description: \"Recurring event\",\n-          hideCalendarNotes: false,\n-          hideCalendarEventDetails: false,\n-          hideOrganizerEmail: false,\n-          schedulingType: null,\n-          seatsPerTimeSlot: null,\n-          seatsShowAttendees: false,\n-          seatsShowAvailabilityCount: false,\n-          customReplyToEmail: null,\n-          disableRescheduling: false,\n-          disableCancelling: false,\n-          requiresConfirmation: false,\n-          recurringEvent: { freq: 2, count: 5, interval: 1 },\n-          bookingFields: [],\n-          metadata: null,\n-          eventName: null,\n-          team: null,\n-          users: [],\n-          hosts: [],\n-          workflows: [],\n-        },\n-        references: [],\n-        seatsReferences: [],\n-      } satisfies BookingForCalEventBuilder;\n-\n-      const eventFromBooking = await CalendarEventBuilder.fromBooking(mockBooking);\n-      const builtEvent = eventFromBooking.build();\n-\n-      expect(builtEvent).not.toBeNull();\n-      if (builtEvent) {\n-        expect(builtEvent.recurringEvent).toBeDefined();\n-        expect(builtEvent.recurringEvent?.freq).toBe(2);\n-        expect(builtEvent.recurringEvent?.count).toBe(5);\n-        expect(builtEvent.recurringEvent?.interval).toBe(1);\n-      }\n-    });\n-\n-    it(\"should create a calendar event from booking with seats\", async () => {\n-      const mockBooking = {\n-        uid: \"booking-seats\",\n-        metadata: null,\n-        title: \"Webinar\",\n-        startTime: new Date(mockStartTime),\n-        endTime: new Date(mockEndTime),\n-        description: \"Webinar description\",\n-        location: \"Online\",\n-        responses: {\n-          email: \"seat@example.com\",\n-          name: \"Seat Holder\",\n-        },\n-        customInputs: null,\n-        iCalUID: null,\n-        iCalSequence: 0,\n-        oneTimePassword: null,\n-        attendees: [\n-          {\n-            name: \"Seat Holder\",\n-            email: \"seat@example.com\",\n-            timeZone: \"America/New_York\",\n-            locale: \"en\",\n-            phoneNumber: null,\n-          },\n-        ],\n-        user: {\n-          id: 6,\n-          name: \"Webinar Host\",\n-          email: \"webinar@example.com\",\n-          username: \"webinar\",\n-          timeZone: \"America/New_York\",\n-          locale: \"en\",\n-          timeFormat: 12,\n-          destinationCalendar: null,\n-          profiles: [],\n-        },\n-        destinationCalendar: null,\n-        eventType: {\n-          id: 500,\n-          title: \"60 minutes\",\n-          slug: \"webinar\",\n-          description: \"Webinar event\",\n-          hideCalendarNotes: false,\n-          hideCalendarEventDetails: false,\n-          hideOrganizerEmail: false,\n-          schedulingType: null,\n-          seatsPerTimeSlot: 10,\n-          seatsShowAttendees: true,\n-          seatsShowAvailabilityCount: true,\n-          customReplyToEmail: null,\n-          disableRescheduling: false,\n-          disableCancelling: false,\n-          requiresConfirmation: false,\n-          recurringEvent: null,\n-          bookingFields: [],\n-          metadata: null,\n-          eventName: null,\n-          team: null,\n-          users: [],\n-          hosts: [],\n-          workflows: [],\n-        },\n-        references: [],\n-        seatsReferences: [\n-          {\n-            id: 1,\n-            referenceUid: \"seat-ref-123\",\n-            attendee: {\n-              id: 1,\n-              email: \"seat@example.com\",\n-              phoneNumber: null,\n-            },\n-          },\n-        ],\n-      } satisfies BookingForCalEventBuilder;\n-\n-      const eventFromBooking = await CalendarEventBuilder.fromBooking(mockBooking);\n-      const builtEvent = eventFromBooking.build();\n-\n-      expect(builtEvent).not.toBeNull();\n-      if (builtEvent) {\n-        expect(builtEvent.seatsPerTimeSlot).toBe(10);\n-        expect(builtEvent.seatsShowAttendees).toBe(true);\n-        expect(builtEvent.seatsShowAvailabilityCount).toBe(true);\n-        expect(builtEvent.attendeeSeatId).toBe(\"seat-ref-123\");\n-      }\n-    });\n-\n-    it(\"should create a calendar event from booking with custom inputs and responses\", async () => {\n-      const mockBooking = {\n-        uid: \"booking-custom\",\n-        metadata: null,\n-        title: \"Custom Event\",\n-        startTime: new Date(mockStartTime),\n-        endTime: new Date(mockEndTime),\n-        description: \"Event with custom fields\",\n-        location: \"TBD\",\n-        responses: {\n-          name: { label: \"your_name\", value: \"Custom User\" },\n-          email: { label: \"email_address\", value: \"custom@example.com\" },\n-          customField: { label: \"Custom Question\", value: \"Custom Answer\" },\n-        },\n-        customInputs: { oldField: \"oldValue\" },\n-        iCalUID: \"custom-ical\",\n-        iCalSequence: 2,\n-        oneTimePassword: \"otp-456\",\n-        attendees: [\n-          {\n-            name: \"Custom User\",\n-            email: \"custom@example.com\",\n-            timeZone: \"Europe/Paris\",\n-            locale: \"fr\",\n-            phoneNumber: \"+33123456789\",\n-          },\n-        ],\n-        user: {\n-          id: 7,\n-          name: \"Custom Host\",\n-          email: \"customhost@example.com\",\n-          username: \"customhost\",\n-          timeZone: \"Europe/Paris\",\n-          locale: \"fr\",\n-          timeFormat: 24,\n-          destinationCalendar: null,\n-          profiles: [],\n-        },\n-        destinationCalendar: null,\n-        eventType: {\n-          id: 600,\n-          title: \"60 minutes\",\n-          slug: \"custom-event\",\n-          description: \"Custom event type\",\n-          hideCalendarNotes: true,\n-          hideCalendarEventDetails: true,\n-          hideOrganizerEmail: true,\n-          schedulingType: null,\n-          seatsPerTimeSlot: null,\n-          seatsShowAttendees: false,\n-          seatsShowAvailabilityCount: false,\n-          customReplyToEmail: \"custom-reply@example.com\",\n-          disableRescheduling: true,\n-          disableCancelling: true,\n-          requiresConfirmation: true,\n-          recurringEvent: null,\n-          bookingFields: [\n-            {\n-              name: \"customField\",\n-              type: \"text\",\n-              label: \"Custom Question\",\n-              required: true,\n-            },\n-          ],\n-          metadata: null,\n-          eventName: null,\n-          team: null,\n-          users: [],\n-          hosts: [],\n-          workflows: [],\n-        },\n-        references: [],\n-        seatsReferences: [],\n-      } satisfies BookingForCalEventBuilder;\n-\n-      const eventFromBooking = await CalendarEventBuilder.fromBooking(mockBooking);\n-      const builtEvent = eventFromBooking.build();\n-\n-      expect(builtEvent).not.toBeNull();\n-      if (builtEvent) {\n-        expect(builtEvent.hideCalendarNotes).toBe(true);\n-        expect(builtEvent.hideCalendarEventDetails).toBe(true);\n-        expect(builtEvent.hideOrganizerEmail).toBe(true);\n-        expect(builtEvent.customReplyToEmail).toBe(\"custom-reply@example.com\");\n-        expect(builtEvent.disableRescheduling).toBe(true);\n-        expect(builtEvent.disableCancelling).toBe(true);\n-        expect(builtEvent.requiresConfirmation).toBe(true);\n-        expect(builtEvent.oneTimePassword).toBe(\"otp-456\");\n-        expect(builtEvent.customInputs).toEqual({ oldField: \"oldValue\" });\n-        expect(builtEvent.responses).toBeDefined();\n-      }\n-    });\n-\n-    it(\"should match calendar event built from booking with manually built event\", async () => {\n-      const mockBooking = {\n-        uid: \"booking-match\",\n-        metadata: null,\n-        title: \"Match Test\",\n-        startTime: new Date(mockStartTime),\n-        endTime: new Date(mockEndTime),\n-        description: \"Match test description\",\n-        location: \"Test Location\",\n-        responses: {\n-          name: { label: \"your_name\", value: \"Match User\" },\n-          email: { label: \"email_address\", value: \"match@example.com\" },\n-        },\n-        customInputs: null,\n-        iCalUID: \"match-ical\",\n-        iCalSequence: 1,\n-        oneTimePassword: null,\n-        attendees: [\n-          {\n-            name: \"Match User\",\n-            email: \"match@example.com\",\n-            timeZone: \"America/New_York\",\n-            locale: \"en\",\n-            phoneNumber: null,\n-          },\n-        ],\n-        user: {\n-          id: 8,\n-          name: \"Match Host\",\n-          email: \"matchhost@example.com\",\n-          username: \"matchhost\",\n-          timeZone: \"America/New_York\",\n-          locale: \"en\",\n-          timeFormat: 12,\n-          destinationCalendar: null,\n-          profiles: [],\n-        },\n-        destinationCalendar: null,\n-        eventType: {\n-          id: 700,\n-          title: \"60 minutes\",\n-          slug: \"match-event\",\n-          description: \"Match event type\",\n-          hideCalendarNotes: false,\n-          hideCalendarEventDetails: false,\n-          hideOrganizerEmail: false,\n-          schedulingType: null,\n-          seatsPerTimeSlot: null,\n-          seatsShowAttendees: false,\n-          seatsShowAvailabilityCount: false,\n-          customReplyToEmail: null,\n-          disableRescheduling: false,\n-          disableCancelling: false,\n-          requiresConfirmation: false,\n-          recurringEvent: null,\n-          bookingFields: [],\n-          metadata: null,\n-          eventName: null,\n-          team: null,\n-          users: [],\n-          hosts: [],\n-          workflows: [],\n-        },\n-        references: [],\n-        seatsReferences: [],\n-      } satisfies BookingForCalEventBuilder;\n-\n-      const eventFromBooking = await CalendarEventBuilder.fromBooking(mockBooking);\n-      const builtFromBooking = eventFromBooking.build();\n-\n-      const manualBuilder = new CalendarEventBuilder();\n-      const organizerPerson = {\n-        id: 8,\n-        name: \"Match Host\",\n-        email: \"matchhost@example.com\",\n-        username: \"matchhost\",\n-        timeZone: \"America/New_York\",\n-        language: { translate: mockTranslate, locale: \"en\" },\n-        timeFormat: TimeFormat[\"TWENTY_FOUR_HOUR\"],\n-      };\n-      const attendeePerson = {\n-        name: \"Match User\",\n-        email: \"match@example.com\",\n-        timeZone: \"America/New_York\",\n-        language: { translate: mockTranslate, locale: \"en\" },\n-      };\n-\n-      const manualEvent = manualBuilder\n-        .withBasicDetails({\n-          bookerUrl: \"https://cal.com\",\n-          title: \"Match Test\",\n-          startTime: new Date(mockStartTime).toISOString(),\n-          endTime: new Date(mockEndTime).toISOString(),\n-          additionalNotes: \"Match test description\",\n-        })\n-        .withEventType({\n-          id: 700,\n-          slug: \"match-event\",\n-          description: \"Match event type\",\n-          hideCalendarNotes: false,\n-          hideCalendarEventDetails: false,\n-          hideOrganizerEmail: false,\n-          schedulingType: null,\n-          seatsPerTimeSlot: null,\n-          seatsShowAttendees: false,\n-          seatsShowAvailabilityCount: false,\n-          customReplyToEmail: null,\n-          disableRescheduling: false,\n-          disableCancelling: false,\n-        })\n-        .withOrganizer(organizerPerson)\n-        .withAttendees([attendeePerson])\n-        .withLocation({ location: \"Test Location\" })\n-        .withIdentifiers({ iCalUID: \"match-ical\", iCalSequence: 1 })\n-        .withConfirmation({ requiresConfirmation: false, isConfirmedByDefault: true })\n-        .withUid(\"booking-match\")\n-        .withAppsStatus([])\n-        .build();\n-\n-      expect(builtFromBooking).not.toBeNull();\n-      expect(manualEvent).not.toBeNull();\n-\n-      if (builtFromBooking && manualEvent) {\n-        expect(builtFromBooking.uid).toBe(manualEvent.uid);\n-        expect(builtFromBooking.title).toBe(manualEvent.title);\n-        expect(builtFromBooking.startTime).toBe(manualEvent.startTime);\n-        expect(builtFromBooking.endTime).toBe(manualEvent.endTime);\n-        expect(builtFromBooking.type).toBe(manualEvent.type);\n-        expect(builtFromBooking.eventTypeId).toBe(manualEvent.eventTypeId);\n-        expect(builtFromBooking.location).toBe(manualEvent.location);\n-        expect(builtFromBooking.organizer.email).toBe(manualEvent.organizer.email);\n-        expect(builtFromBooking.attendees[0].email).toBe(manualEvent.attendees[0].email);\n-        expect(builtFromBooking.iCalUID).toBe(manualEvent.iCalUID);\n-        expect(builtFromBooking.iCalSequence).toBe(manualEvent.iCalSequence);\n-      }\n-    });\n-\n-    it(\"should throw error when booking is missing user\", async () => {\n-      const mockBooking = {\n-        uid: \"booking-no-user\",\n-        metadata: null,\n-        title: \"No User\",\n-        startTime: new Date(mockStartTime),\n-        endTime: new Date(mockEndTime),\n-        description: null,\n-        location: null,\n-        responses: null,\n-        customInputs: null,\n-        iCalUID: null,\n-        iCalSequence: 0,\n-        oneTimePassword: null,\n-        attendees: [],\n-        user: null,\n-        destinationCalendar: null,\n-        eventType: {\n-          title: \"60 minutes\",\n-          id: 800,\n-          slug: \"test\",\n-          description: null,\n-          hideCalendarNotes: false,\n-          hideCalendarEventDetails: false,\n-          hideOrganizerEmail: false,\n-          schedulingType: null,\n-          seatsPerTimeSlot: null,\n-          seatsShowAttendees: false,\n-          seatsShowAvailabilityCount: false,\n-          customReplyToEmail: null,\n-          disableRescheduling: false,\n-          disableCancelling: false,\n-          requiresConfirmation: false,\n-          recurringEvent: null,\n-          bookingFields: [],\n-          metadata: null,\n-          eventName: null,\n-          team: null,\n-          users: [],\n-          hosts: [],\n-          workflows: [],\n-        },\n-        references: [],\n-        seatsReferences: [],\n-      } satisfies BookingForCalEventBuilder;\n-\n-      await expect(CalendarEventBuilder.fromBooking(mockBooking)).rejects.toThrow(\n-        \"Booking booking-no-user is missing an organizer\"\n-      );\n-    });\n-\n-    it(\"should throw error when booking is missing eventType\", async () => {\n-      const mockBooking = {\n-        uid: \"booking-no-eventtype\",\n-        metadata: null,\n-        title: \"No EventType\",\n-        startTime: new Date(mockStartTime),\n-        endTime: new Date(mockEndTime),\n-        description: null,\n-        location: null,\n-        responses: null,\n-        customInputs: null,\n-        iCalUID: null,\n-        iCalSequence: 0,\n-        oneTimePassword: null,\n-        attendees: [],\n-        user: {\n-          id: 9,\n-          name: \"User\",\n-          email: \"user@example.com\",\n-          username: \"user\",\n-          timeZone: \"UTC\",\n-          locale: \"en\",\n-          timeFormat: 12,\n-          destinationCalendar: null,\n-          profiles: [],\n-        },\n-        destinationCalendar: null,\n-        eventType: null,\n-        references: [],\n-        seatsReferences: [],\n-      } satisfies BookingForCalEventBuilder;\n-\n-      await expect(CalendarEventBuilder.fromBooking(mockBooking)).rejects.toThrow(\n-        \"Booking booking-no-eventtype is missing eventType\"\n-      );\n-    });\n-\n-    it(\"should create a complete calendar event with all properties using a booking\", async () => {\n-      const startTime = new Date(\"2025-01-01T10:00:00.000Z\");\n-      const endTime = new Date(\"2025-01-01T10:30:00.000Z\");\n-\n-      const mockBooking = {\n-        uid: \"complete-booking-uid\",\n-        metadata: null,\n-        title: \"Complete Team Event\",\n-        startTime,\n-        endTime,\n-        description: \"Complete event description with all properties\",\n-        location: \"Conference Room A\",\n-        responses: {\n-          email: \"complete@example.com\",\n-          name: \"Complete User\",\n-          attendeePhoneNumber: \"+1234567890\",\n-        },\n-        customInputs: { oldCustomField: \"oldValue\" },\n-        iCalUID: \"complete-ical-uid\",\n-        iCalSequence: 3,\n-        oneTimePassword: \"otp-complete\",\n-        attendees: [\n-          {\n-            name: \"Complete User\",\n-            email: \"complete@example.com\",\n-            timeZone: \"America/New_York\",\n-            locale: \"en\",\n-            phoneNumber: \"+1234567890\",\n-          },\n-          {\n-            name: \"Guest User\",\n-            email: \"guest@example.com\",\n-            timeZone: \"Europe/London\",\n-            locale: \"en\",\n-            phoneNumber: null,\n-          },\n-          {\n-            // Team member host - included in attendees for COLLECTIVE events\n-            name: \"Team Member\",\n-            email: \"member@example.com\",\n-            timeZone: \"America/Los_Angeles\",\n-            locale: \"en\",\n-            phoneNumber: null,\n-          },\n-        ],\n-        user: {\n-          id: 100,\n-          name: \"Team Lead\",\n-          email: \"lead@example.com\",\n-          username: \"teamlead\",\n-          timeZone: \"America/New_York\",\n-          locale: \"en\",\n-          timeFormat: 12,\n-          destinationCalendar: {\n-            id: 10,\n-            integration: \"google_calendar\",\n-            externalId: \"lead-calendar-id\",\n-            primaryEmail: \"lead@example.com\",\n-            userId: 100,\n-            eventTypeId: null,\n-            credentialId: 10,\n-            createdAt: null,\n-            updatedAt: null,\n-            delegationCredentialId: null,\n-            domainWideDelegationCredentialId: null,\n-          },\n-          profiles: [{ organizationId: 1 }],\n-        },\n-        destinationCalendar: null,\n-        eventType: {\n-          id: 1000,\n-          slug: \"complete-event\",\n-          title: \"60 minutes\",\n-          description: \"Complete event type description\",\n-          hideCalendarNotes: true,\n-          hideCalendarEventDetails: true,\n-          hideOrganizerEmail: true,\n-          schedulingType: \"COLLECTIVE\",\n-          seatsPerTimeSlot: 20,\n-          seatsShowAttendees: true,\n-          seatsShowAvailabilityCount: true,\n-          customReplyToEmail: \"custom-reply@example.com\",\n-          disableRescheduling: true,\n-          disableCancelling: true,\n-          requiresConfirmation: true,\n-          recurringEvent: { freq: 2, count: 10, interval: 1 },\n-          bookingFields: [\n-            {\n-              name: \"customQuestion\",\n-              type: \"text\",\n-              label: \"Custom Question\",\n-              required: true,\n-            },\n-          ],\n-          metadata: null,\n-          eventName: null,\n-          team: {\n-            id: 50,\n-            name: \"Engineering Team\",\n-            parentId: 1,\n-            members: [],\n-          },\n-          users: [],\n-          hosts: [\n-            {\n-              userId: 100,\n-              isFixed: true,\n-              user: {\n-                id: 100,\n-                name: \"Team Lead\",\n-                email: \"lead@example.com\",\n-                username: \"teamlead\",\n-                timeZone: \"America/New_York\",\n-                locale: \"en\",\n-                timeFormat: 12,\n-                destinationCalendar: {\n-                  id: 10,\n-                  integration: \"google_calendar\",\n-                  externalId: \"lead-calendar-id\",\n-                  primaryEmail: \"lead@example.com\",\n-                  userId: 100,\n-                  eventTypeId: null,\n-                  credentialId: 10,\n-                  createdAt: null,\n-                  updatedAt: null,\n-                  delegationCredentialId: null,\n-                  domainWideDelegationCredentialId: null,\n-                },\n-              },\n-            },\n-            {\n-              userId: 101,\n-              isFixed: false,\n-              user: {\n-                id: 101,\n-                name: \"Team Member\",\n-                email: \"member@example.com\",\n-                username: \"member\",\n-                timeZone: \"America/Los_Angeles\",\n-                locale: \"en\",\n-                timeFormat: 24,\n-                destinationCalendar: {\n-                  id: 11,\n-                  integration: \"google_calendar\",\n-                  externalId: \"member-calendar-id\",\n-                  primaryEmail: \"member@example.com\",\n-                  userId: 101,\n-                  eventTypeId: null,\n-                  credentialId: 11,\n-                  createdAt: null,\n-                  updatedAt: null,\n-                  delegationCredentialId: null,\n-                  domainWideDelegationCredentialId: null,\n-                },\n-              },\n-            },\n-          ],\n-          workflows: [],\n-        },\n-        references: [\n-          {\n-            type: \"google_calendar\",\n-            uid: \"\",\n-            meetingId: \"google-meeting-123\",\n-            meetingPassword: \"google-pass-123\",\n-            meetingUrl: \"https://google.com/j/123456789\",\n-          },\n-          {\n-            type: \"zoom_video\",\n-            uid: \"_e1cj2jap9hll6e319l3jeuii9hn6khi5acpk0gr1dgn66rrd\",\n-            meetingId: \"zoom-meeting-123\",\n-            meetingPassword: \"zoom-pass-123\",\n-            meetingUrl: \"https://zoom.us/j/123456789\",\n-          },\n-        ],\n-        seatsReferences: [\n-          {\n-            id: 1,\n-            referenceUid: \"seat-ref-complete\",\n-            attendee: {\n-              id: 1,\n-              email: \"complete@example.com\",\n-              phoneNumber: \"+1234567890\",\n-            },\n-          },\n-        ],\n-      } satisfies BookingForCalEventBuilder;\n-\n-      const eventFromBooking = await CalendarEventBuilder.fromBooking(mockBooking);\n-      const builtFromBooking = eventFromBooking.build();\n-\n-      expect(builtFromBooking).not.toBeNull();\n-      if (!builtFromBooking) return;\n-\n-      expect(builtFromBooking.uid).toBe(\"complete-booking-uid\");\n-      expect(builtFromBooking.title).toBe(\"Complete Team Event\");\n-      expect(builtFromBooking.startTime).toBe(startTime.toISOString());\n-      expect(builtFromBooking.endTime).toBe(endTime.toISOString());\n-      expect(builtFromBooking.additionalNotes).toBe(\"Complete event description with all properties\");\n-      expect(builtFromBooking.location).toBe(\"Conference Room A\");\n-      expect(builtFromBooking.type).toBe(\"complete-event\");\n-      expect(builtFromBooking.description).toBe(\"Complete event type description\");\n-      expect(builtFromBooking.eventTypeId).toBe(1000);\n-      expect(builtFromBooking.iCalUID).toBe(\"complete-ical-uid\");\n-      expect(builtFromBooking.iCalSequence).toBe(3);\n-      expect(builtFromBooking.oneTimePassword).toBe(\"otp-complete\");\n-\n-      expect(builtFromBooking.hideCalendarNotes).toBe(true);\n-      expect(builtFromBooking.hideCalendarEventDetails).toBe(true);\n-      expect(builtFromBooking.hideOrganizerEmail).toBe(true);\n-      expect(builtFromBooking.customReplyToEmail).toBe(\"custom-reply@example.com\");\n-      expect(builtFromBooking.disableRescheduling).toBe(true);\n-      expect(builtFromBooking.disableCancelling).toBe(true);\n-      expect(builtFromBooking.requiresConfirmation).toBe(true);\n-\n-      expect(builtFromBooking.schedulingType).toBe(\"COLLECTIVE\");\n-      expect(builtFromBooking.seatsPerTimeSlot).toBe(20);\n-      expect(builtFromBooking.seatsShowAttendees).toBe(true);\n-      expect(builtFromBooking.seatsShowAvailabilityCount).toBe(true);\n-      expect(builtFromBooking.attendeeSeatId).toBe(\"seat-ref-complete\");\n-\n-      expect(builtFromBooking.recurringEvent).toBeDefined();\n-      expect(builtFromBooking.recurringEvent?.freq).toBe(2);\n-      expect(builtFromBooking.recurringEvent?.count).toBe(10);\n-      expect(builtFromBooking.recurringEvent?.interval).toBe(1);\n-\n-      expect(builtFromBooking.organizer).toBeDefined();\n-      expect(builtFromBooking.organizer.id).toBe(100);\n-      expect(builtFromBooking.organizer.name).toBe(\"Team Lead\");\n-      expect(builtFromBooking.organizer.email).toBe(\"lead@example.com\");\n-      expect(builtFromBooking.organizer.username).toBe(\"teamlead\");\n-      expect(builtFromBooking.organizer.timeZone).toBe(\"America/New_York\");\n-\n-      expect(builtFromBooking.attendees).toHaveLength(3);\n-      expect(builtFromBooking.attendees[0].name).toBe(\"Complete User\");\n-      expect(builtFromBooking.attendees[0].email).toBe(\"complete@example.com\");\n-      expect(builtFromBooking.attendees[0].timeZone).toBe(\"America/New_York\");\n-      expect(builtFromBooking.attendees[1].name).toBe(\"Guest User\");\n-      expect(builtFromBooking.attendees[1].email).toBe(\"guest@example.com\");\n-      expect(builtFromBooking.attendees[2].name).toBe(\"Team Member\");\n-      expect(builtFromBooking.attendees[2].email).toBe(\"member@example.com\");\n-\n-      expect(builtFromBooking.team).toBeDefined();\n-      expect(builtFromBooking.team?.id).toBe(50);\n-      expect(builtFromBooking.team?.name).toBe(\"Engineering Team\");\n-      expect(builtFromBooking.team?.members).toHaveLength(1);\n-      expect(builtFromBooking.team?.members[0].email).toBe(\"member@example.com\");\n-\n-      expect(builtFromBooking.destinationCalendar).toBeDefined();\n-      expect(builtFromBooking.destinationCalendar).toHaveLength(3); // 2 hosts + 1 user calendar\n-      expect(builtFromBooking.destinationCalendar?.[0].integration).toBe(\"google_calendar\");\n-      expect(builtFromBooking.destinationCalendar?.[1].integration).toBe(\"google_calendar\");\n-      expect(builtFromBooking.destinationCalendar?.[2].integration).toBe(\"google_calendar\");\n-\n-      expect(builtFromBooking.videoCallData).toBeDefined();\n-      expect(builtFromBooking.videoCallData?.type).toBe(\"zoom_video\");\n-      expect(builtFromBooking.videoCallData?.id).toBe(\"zoom-meeting-123\");\n-      expect(builtFromBooking.videoCallData?.password).toBe(\"zoom-pass-123\");\n-      expect(builtFromBooking.videoCallData?.url).toBe(\"https://zoom.us/j/123456789\");\n-\n-      expect(builtFromBooking.appsStatus).toBeDefined();\n-      expect(builtFromBooking.appsStatus).toHaveLength(2);\n-      const zoomVideo = builtFromBooking.appsStatus?.find((app) => app.type === \"zoom_video\");\n-      expect(zoomVideo).toBeDefined();\n-      if (zoomVideo) {\n-        expect(zoomVideo.type).toBe(\"zoom_video\");\n-        expect(zoomVideo.success).toBe(1);\n-        expect(zoomVideo.failures).toBe(0);\n-      }\n-\n-      const googleCalendar = builtFromBooking.appsStatus?.find((app) => app.type === \"google_calendar\");\n-      expect(googleCalendar).toBeDefined();\n-      if (googleCalendar) {\n-        expect(googleCalendar.type).toBe(\"google_calendar\");\n-        expect(googleCalendar.success).toBe(0);\n-        expect(googleCalendar.failures).toBe(1);\n-      }\n-\n-      expect(builtFromBooking.responses).toBeDefined();\n-      expect(builtFromBooking.userFieldsResponses).toBeDefined();\n-      expect(builtFromBooking.customInputs).toEqual({ oldCustomField: \"oldValue\" });\n-\n-      expect(builtFromBooking.bookerUrl).toBe(\"https://cal.com\");\n-    });\n-  });\n-});\n+        bookerUrl: \"https\n\\ No newline at end of file\ndiff --git a/packages/features/CalendarEventBuilder.ts b/packages/features/CalendarEventBuilder.ts\nindex 492b1ae..bdaf102 100644\n--- a/packages/features/CalendarEventBuilder.ts\n+++ b/packages/features/CalendarEventBuilder.ts\n@@ -7,7 +7,7 @@ import { parseRecurringEvent } from \"@calcom/lib/isRecurringEvent\";\n import { getTranslation } from \"@calcom/lib/server/i18n\";\n import { getTimeFormatStringFromUserTimeFormat, type TimeFormat } from \"@calcom/lib/timeFormat\";\n import type { Attendee, BookingSeat, DestinationCalendar, Prisma, User } from \"@calcom/prisma/client\";\n-import { SchedulingType } from \"@calcom/prisma/enums\";\n+import type { SchedulingType } from \"@calcom/prisma/enums\";\n import { bookingResponses as bookingResponsesSchema } from \"@calcom/prisma/zod-utils\";\n import type { CalendarEvent, Person, CalEventResponses, AppsStatus } from \"@calcom/types/Calendar\";\n import type { VideoCallData } from \"@calcom/types/VideoApiAdapter\";\n@@ -226,25 +226,12 @@ export class CalendarEventBuilder {\n \n     // Team & calendars\n     if (eventType.team) {\n-      // We need to get the team members assigned to the booking\n-      // In the DB team members are stored in the Attendee table\n-      const bookingAttendees = booking.attendees;\n-\n-      const hostsToInclude = eventType.hosts.filter((host) =>\n-        bookingAttendees.some((attendee) => attendee.email === host.user.email)\n-      );\n-\n-      const hostsWithoutOrganizerData = hostsToInclude.filter(\n-        (host) => host.user.email !== user.email\n-      );\n-\n       const hostsWithoutOrganizer = await Promise.all(\n-        hostsWithoutOrganizerData.map((host) => _buildPersonFromUser(host.user))\n+        eventType.hosts.filter((h) => h.user.email !== user.email).map((h) => _buildPersonFromUser(h.user))\n       );\n \n       const hostCalendars = [\n-        user.destinationCalendar,\n-        ...hostsWithoutOrganizerData.map((h) => h.user.destinationCalendar).filter(Boolean),\n+        ...eventType.hosts.map((h) => h.user.destinationCalendar).filter(Boolean),\n         user.destinationCalendar,\n       ].filter(Boolean) as NonNullable<DestinationCalendar>[];\n \n@@ -452,95 +439,4 @@ export class CalendarEventBuilder {\n       ...this.event,\n       appsStatus,\n     };\n-    return this;\n-  }\n-\n-  withVideoCallData(videoCallData?: VideoCallData) {\n-    this.event = {\n-      ...this.event,\n-      videoCallData,\n-    };\n-    return this;\n-  }\n-\n-  withTeam(team?: { name: string; members: Person[]; id: number }) {\n-    this.event = {\n-      ...this.event,\n-      team,\n-    };\n-    return this;\n-  }\n-\n-  withRecurring(recurringEvent?: { count: number; freq: number; interval: number }) {\n-    this.event = {\n-      ...this.event,\n-      recurringEvent,\n-    };\n-    return this;\n-  }\n-\n-  withAttendeeSeatId(attendeeSeatId?: string) {\n-    this.event = {\n-      ...this.event,\n-      attendeeSeatId,\n-    };\n-    return this;\n-  }\n-\n-  withUid(uid: string | null) {\n-    this.event = {\n-      ...this.event,\n-      uid,\n-    };\n-    return this;\n-  }\n-\n-  withRecurringEventId(recurringEventId: string) {\n-    this.event = {\n-      ...this.event,\n-      existingRecurringEvent: {\n-        recurringEventId,\n-      },\n-    };\n-    return this;\n-  }\n-\n-  withOneTimePassword(oneTimePassword?: string | null) {\n-    this.event = {\n-      ...this.event,\n-      oneTimePassword,\n-    };\n-    return this;\n-  }\n-\n-  withOrganization(organizationId?: number | null) {\n-    this.event = {\n-      ...this.event,\n-      organizationId,\n-    };\n-    return this;\n-  }\n-\n-  withHashedLink(hashedLink?: string | null) {\n-    this.event = {\n-      ...this.event,\n-      hashedLink,\n-    };\n-    return this;\n-  }\n-\n-  build(): CalendarEvent | null {\n-    // Validate required fields\n-    if (\n-      !this.event.startTime ||\n-      !this.event.endTime ||\n-      !this.event.type ||\n-      !this.event.bookerUrl ||\n-      !this.event.title\n-    ) {\n-      return null;\n-    }\n-\n-    return this.event as CalendarEvent;\n-  }\n-}\n+    return\n\\ No newline at end of file\ndiff --git a/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts b/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts\nindex b11f5d7..9b24bdb 100644\n--- a/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts\n+++ b/packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts\n@@ -2,17 +2,9 @@ import { describe, expect, vi, beforeEach, test } from \"vitest\";\n \n import type { BookingSeatRepository } from \"@calcom/features/bookings/repositories/BookingSeatRepository\";\n import type { WorkflowReminderRepository } from \"@calcom/features/ee/workflows/repositories/WorkflowReminderRepository\";\n-import {\n-  SchedulingType,\n-  TimeUnit,\n-  WorkflowActions,\n-  WorkflowTemplates,\n-  WorkflowTriggerEvents,\n-} from \"@calcom/prisma/enums\";\n+import { WorkflowActions, WorkflowTemplates, WorkflowTriggerEvents } from \"@calcom/prisma/enums\";\n import type { CalendarEvent } from \"@calcom/types/Calendar\";\n \n-import { EmailWorkflowService } from \"./EmailWorkflowService\";\n-\n vi.mock(\"@calcom/emails/workflow-email-service\", () => ({\n   sendCustomWorkflowEmail: vi.fn(),\n }));\n@@ -30,6 +22,8 @@ vi.mock(\"@calcom/prisma\", () => ({\n   prisma: {},\n }));\n \n+import { EmailWorkflowService } from \"./EmailWorkflowService\";\n+\n const mockWorkflowReminderRepository: Pick<WorkflowReminderRepository, \"findByIdIncludeStepAndWorkflow\"> = {\n   findByIdIncludeStepAndWorkflow: vi.fn(),\n };\n@@ -162,223 +156,4 @@ describe(\"EmailWorkflowService\", () => {\n       expect(mockBookingSeatRepository.getByUidIncludeAttendee).toHaveBeenCalledWith(\"seat-123\");\n     });\n   });\n-\n-  describe(\"generateParametersToBuildEmailWorkflowContent - EMAIL_HOST\", () => {\n-    const mockCommonScheduleFunctionParams = {\n-      triggerEvent: WorkflowTriggerEvents.BEFORE_EVENT,\n-      timeSpan: {\n-        time: 24,\n-        timeUnit: TimeUnit.HOUR,\n-      },\n-      workflowStepId: 1,\n-      template: WorkflowTemplates.REMINDER,\n-      userId: 1,\n-      teamId: null,\n-      seatReferenceUid: undefined,\n-      verifiedAt: new Date(),\n-      creditCheckFn: vi.fn().mockResolvedValue(true),\n-    };\n-\n-    const baseMockEvt: Partial<CalendarEvent> = {\n-      uid: \"booking-123\",\n-      bookerUrl: \"https://cal.com\",\n-      title: \"Test Meeting\",\n-      startTime: \"2024-12-01T10:00:00Z\",\n-      endTime: \"2024-12-01T11:00:00Z\",\n-      organizer: {\n-        name: \"Organizer Name\",\n-        email: \"organizer@example.com\",\n-        timeZone: \"UTC\",\n-        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-        language: { locale: \"en\", translate: (() => \"\") as any },\n-        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-        timeFormat: \"h:mma\" as any,\n-      },\n-      attendees: [\n-        {\n-          name: \"Attendee Name\",\n-          email: \"attendee@example.com\",\n-          timeZone: \"UTC\",\n-          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-          language: { locale: \"en\", translate: (() => \"\") as any },\n-        },\n-      ],\n-    };\n-\n-    const mockWorkflowStep = {\n-      id: 1,\n-      action: WorkflowActions.EMAIL_HOST,\n-      verifiedAt: new Date(),\n-      sendTo: null,\n-      template: WorkflowTemplates.REMINDER,\n-      reminderBody: null,\n-      emailSubject: null,\n-      sender: null,\n-      includeCalendarEvent: false,\n-      numberVerificationPending: false,\n-      numberRequired: false,\n-    };\n-\n-    test(\"should send to organizer and team members for ROUND_ROBIN scheduling type\", async () => {\n-      // Note: For ROUND_ROBIN, the CalendarEventBuilder filters team members to only include\n-      // those assigned to the booking. EmailWorkflowService sends to all team members in evt.team.members.\n-      const mockEvt: Partial<CalendarEvent> = {\n-        ...baseMockEvt,\n-        schedulingType: SchedulingType.ROUND_ROBIN,\n-        team: {\n-          id: 1,\n-          name: \"Test Team\",\n-          members: [\n-            {\n-              id: 1,\n-              name: \"Team Member 1\",\n-              email: \"team1@example.com\",\n-              timeZone: \"UTC\",\n-              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-              language: { locale: \"en\", translate: (() => \"\") as any },\n-            },\n-            {\n-              id: 2,\n-              name: \"Team Member 2\",\n-              email: \"team2@example.com\",\n-              timeZone: \"UTC\",\n-              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-              language: { locale: \"en\", translate: (() => \"\") as any },\n-            },\n-          ],\n-        },\n-      };\n-\n-      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n-        evt: mockEvt as CalendarEvent,\n-        workflowStep: mockWorkflowStep,\n-        workflow: { userId: 1 },\n-        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n-        hideBranding: false,\n-      });\n-\n-      // EmailWorkflowService sends to organizer + all team members in evt.team.members\n-      // The filtering of team members happens in CalendarEventBuilder, not here\n-      expect(result.sendTo).toContain(\"organizer@example.com\");\n-      expect(result.sendTo).toContain(\"team1@example.com\");\n-      expect(result.sendTo).toContain(\"team2@example.com\");\n-      expect(result.sendTo.length).toBe(3);\n-    });\n-\n-    test(\"should send to organizer and team members for COLLECTIVE scheduling type\", async () => {\n-      const mockEvt: Partial<CalendarEvent> = {\n-        ...baseMockEvt,\n-        schedulingType: SchedulingType.COLLECTIVE,\n-        team: {\n-          id: 1,\n-          name: \"Test Team\",\n-          members: [\n-            {\n-              id: 1,\n-              name: \"Team Member 1\",\n-              email: \"team1@example.com\",\n-              timeZone: \"UTC\",\n-              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-              language: { locale: \"en\", translate: (() => \"\") as any },\n-            },\n-            {\n-              id: 2,\n-              name: \"Team Member 2\",\n-              email: \"team2@example.com\",\n-              timeZone: \"UTC\",\n-              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-              language: { locale: \"en\", translate: (() => \"\") as any },\n-            },\n-          ],\n-        },\n-      };\n-\n-      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n-        evt: mockEvt as CalendarEvent,\n-        workflowStep: mockWorkflowStep,\n-        workflow: { userId: 1 },\n-        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n-        hideBranding: false,\n-      });\n-\n-      expect(result.sendTo).toContain(\"organizer@example.com\");\n-      expect(result.sendTo).toContain(\"team1@example.com\");\n-      expect(result.sendTo).toContain(\"team2@example.com\");\n-      expect(result.sendTo.length).toBe(3);\n-    });\n-\n-    test(\"should send to organizer only when team is undefined for COLLECTIVE\", async () => {\n-      const mockEvt: Partial<CalendarEvent> = {\n-        ...baseMockEvt,\n-        schedulingType: SchedulingType.COLLECTIVE,\n-        team: undefined,\n-      } as Partial<CalendarEvent>;\n-\n-      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n-        evt: mockEvt as CalendarEvent,\n-        workflowStep: mockWorkflowStep,\n-        workflow: { userId: 1 },\n-        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n-        hideBranding: false,\n-      });\n-\n-      expect(result.sendTo).toEqual([\"organizer@example.com\"]);\n-      expect(result.sendTo.length).toBe(1);\n-    });\n-\n-    test(\"should send to organizer only when team members array is empty for COLLECTIVE\", async () => {\n-      const mockEvt: Partial<CalendarEvent> = {\n-        ...baseMockEvt,\n-        schedulingType: SchedulingType.COLLECTIVE,\n-        team: {\n-          id: 1,\n-          name: \"Test Team\",\n-          members: [],\n-        },\n-      };\n-\n-      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n-        evt: mockEvt as CalendarEvent,\n-        workflowStep: mockWorkflowStep,\n-        workflow: { userId: 1 },\n-        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n-        hideBranding: false,\n-      });\n-\n-      expect(result.sendTo).toEqual([\"organizer@example.com\"]);\n-      expect(result.sendTo.length).toBe(1);\n-    });\n-\n-    test(\"should send to organizer only for other scheduling types (e.g., null)\", async () => {\n-      const mockEvt: Partial<CalendarEvent> = {\n-        ...baseMockEvt,\n-        schedulingType: null,\n-        team: {\n-          id: 1,\n-          name: \"Test Team\",\n-          members: [\n-            {\n-              id: 1,\n-              name: \"Team Member 1\",\n-              email: \"team1@example.com\",\n-              timeZone: \"UTC\",\n-              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-              language: { locale: \"en\", translate: (() => \"\") as any },\n-            },\n-          ],\n-        },\n-      } as Partial<CalendarEvent>;\n-\n-      const result = await emailWorkflowService.generateParametersToBuildEmailWorkflowContent({\n-        evt: mockEvt as CalendarEvent,\n-        workflowStep: mockWorkflowStep,\n-        workflow: { userId: 1 },\n-        commonScheduleFunctionParams: mockCommonScheduleFunctionParams,\n-        hideBranding: false,\n-      });\n-\n-      expect(result.sendTo).toEqual([\"organizer@example.com\"]);\n-      expect(result.sendTo.length).toBe(1);\n-    });\n-  });\n-});\n+});\n\\ No newline at end of file\n",
    "pr_number": 25597,
    "title": "fix: workflow reminder send to all RR hosts.",
    "test_files": [
      "packages/features/CalendarEventBuilder.test.ts",
      "packages/features/ee/workflows/lib/service/EmailWorkflowService.test.ts"
    ],
    "code_files": [
      "packages/features/CalendarEventBuilder.ts"
    ]
  },
  {
    "instance_id": "calcom__cal.com.main.25435",
    "repo": "calcom/cal.com",
    "base_commit": "a23400777a4696afea85e2e07c090665248afbfa",
    "bug_patch": "diff --git a/packages/features/auth/lib/next-auth-options.ts b/packages/features/auth/lib/next-auth-options.ts\nindex e4ee24a..82e8fc7 100644\n--- a/packages/features/auth/lib/next-auth-options.ts\n+++ b/packages/features/auth/lib/next-auth-options.ts\n@@ -15,8 +15,8 @@ import { LicenseKeySingleton } from \"@calcom/ee/common/server/LicenseKeyService\"\n import { CredentialRepository } from \"@calcom/features/credentials/repositories/CredentialRepository\";\n import createUsersAndConnectToOrg from \"@calcom/features/ee/dsync/lib/users/createUsersAndConnectToOrg\";\n import ImpersonationProvider from \"@calcom/features/ee/impersonation/lib/ImpersonationProvider\";\n-import { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\n import { getOrgFullOrigin, subdomainSuffix } from \"@calcom/features/ee/organizations/lib/orgDomains\";\n+import { getOrganizationRepository } from \"@calcom/features/ee/organizations/di/OrganizationRepository.container\";\n import { clientSecretVerifier, hostedCal, isSAMLLoginEnabled } from \"@calcom/features/ee/sso/lib/saml\";\n import { ProfileRepository } from \"@calcom/features/profile/repositories/ProfileRepository\";\n import { UserRepository } from \"@calcom/features/users/repositories/UserRepository\";\n@@ -360,778 +360,4 @@ if (isSAMLLoginEnabled) {\n         const { access_token } = await oauthController.token({\n           code,\n           grant_type: \"authorization_code\",\n-          redirect_uri: `${process.env.NEXTAUTH_URL}`,\n-          client_id: \"dummy\",\n-          client_secret: clientSecretVerifier,\n-        });\n-\n-        if (!access_token) {\n-          return null;\n-        }\n-        // Fetch user info\n-        const userInfo = await oauthController.userInfo(access_token);\n-\n-        if (!userInfo) {\n-          return null;\n-        }\n-\n-        const { id, firstName, lastName } = userInfo;\n-        const email = userInfo.email.toLowerCase();\n-        const userRepo = new UserRepository(prisma);\n-        let user = !email ? undefined : await userRepo.findByEmailAndIncludeProfilesAndPassword({ email });\n-        if (!user) {\n-          const hostedCal = Boolean(HOSTED_CAL_FEATURES);\n-          if (hostedCal && email) {\n-            const domain = getDomainFromEmail(email);\n-            const organizationRepository = getOrganizationRepository();\n-            const org = await organizationRepository.getVerifiedOrganizationByAutoAcceptEmailDomain(domain);\n-            if (org) {\n-              const createUsersAndConnectToOrgProps = {\n-                emailsToCreate: [email],\n-                identityProvider: IdentityProvider.SAML,\n-                identityProviderId: email,\n-              };\n-              await createUsersAndConnectToOrg({\n-                createUsersAndConnectToOrgProps,\n-                org,\n-              });\n-              user = await userRepo.findByEmailAndIncludeProfilesAndPassword({\n-                email: email,\n-              });\n-            }\n-          }\n-          if (!user) throw new Error(ErrorCode.UserNotFound);\n-        }\n-        const [userProfile] = user?.allProfiles ?? [];\n-        return {\n-          id: id as unknown as number,\n-          firstName,\n-          lastName,\n-          email,\n-          name: `${firstName} ${lastName}`.trim(),\n-          email_verified: true,\n-          profile: userProfile,\n-        };\n-      },\n-    })\n-  );\n-}\n-\n-providers.push(\n-  EmailProvider({\n-    type: \"email\",\n-    maxAge: 10 * 60 * 60, // Magic links are valid for 10 min only\n-    // Here we setup the sendVerificationRequest that calls the email template with the identifier (email) and token to verify.\n-    sendVerificationRequest: async (props) => (await import(\"./sendVerificationRequest\")).default(props),\n-  })\n-);\n-\n-function isNumber(n: string) {\n-  return !isNaN(parseFloat(n)) && !isNaN(+n);\n-}\n-\n-const calcomAdapter = CalComAdapter(prisma);\n-\n-const mapIdentityProvider = (providerName: string) => {\n-  switch (providerName) {\n-    case \"saml-idp\":\n-    case \"saml\":\n-      return IdentityProvider.SAML;\n-    default:\n-      return IdentityProvider.GOOGLE;\n-  }\n-};\n-\n-export const getOptions = ({\n-  getDubId,\n-}: {\n-  /** so we can extract the Dub cookie in both pages and app routers */\n-  getDubId: () => string | undefined;\n-}): AuthOptions => ({\n-  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n-  // @ts-ignore\n-  adapter: calcomAdapter,\n-  session: {\n-    strategy: \"jwt\",\n-  },\n-  jwt: {\n-    // decorate the native JWT encode function\n-    // Impl. detail: We don't pass through as this function is called with encode/decode functions.\n-    encode: async ({ token, maxAge, secret }) => {\n-      log.debug(\"jwt:encode\", safeStringify({ token, maxAge }));\n-      if (token?.sub && isNumber(token.sub)) {\n-        const user = await prisma.user.findFirst({\n-          where: { id: Number(token.sub) },\n-          select: { metadata: true },\n-        });\n-        // if no user is found, we still don't want to crash here.\n-        if (user) {\n-          const metadata = userMetadata.parse(user.metadata);\n-          if (metadata?.sessionTimeout) {\n-            maxAge = metadata.sessionTimeout * 60;\n-          }\n-        }\n-      }\n-      return encode({ secret, token, maxAge });\n-    },\n-  },\n-  cookies: defaultCookies(WEBAPP_URL?.startsWith(\"https://\")),\n-  pages: {\n-    signIn: \"/auth/login\",\n-    signOut: \"/auth/logout\",\n-    error: \"/auth/error\", // Error code passed in query string as ?error=\n-    verifyRequest: \"/auth/verify\",\n-    // newUser: \"/auth/new\", // New users will be directed here on first sign in (leave the property out if not of interest)\n-  },\n-  providers,\n-  callbacks: {\n-    async jwt({\n-      // Always available but with a little difference in value\n-      token,\n-      // Available only in case of signIn, signUp or useSession().update call.\n-      trigger,\n-      // Available when useSession().update is called. The value will be the POST data\n-      session,\n-      // Available only in the first call once the user signs in. Not available in subsequent calls\n-      user,\n-      // Available only in the first call once the user signs in. Not available in subsequent calls\n-      account,\n-    }) {\n-      log.debug(\"callbacks:jwt\", safeStringify({ token, user, account, trigger, session }));\n-      // The data available in 'session' depends on what data was supplied in update method call of session\n-      if (trigger === \"update\") {\n-        return {\n-          ...token,\n-          profileId: session?.profileId ?? token.profileId ?? null,\n-          upId: session?.upId ?? token.upId ?? null,\n-          locale: session?.locale ?? token.locale ?? \"en\",\n-          name: session?.name ?? token.name,\n-          username: session?.username ?? token.username,\n-          email: session?.email ?? token.email,\n-        } as JWT;\n-      }\n-      const autoMergeIdentities = async () => {\n-        const existingUser = await prisma.user.findFirst({\n-          where: { email: token.email! },\n-          select: {\n-            id: true,\n-            username: true,\n-            avatarUrl: true,\n-            name: true,\n-            email: true,\n-            role: true,\n-            locale: true,\n-            movedToProfileId: true,\n-            teams: {\n-              include: {\n-                team: {\n-                  select: {\n-                    id: true,\n-                    metadata: true,\n-                  },\n-                },\n-              },\n-            },\n-          },\n-        });\n-\n-        if (!existingUser) {\n-          return token;\n-        }\n-\n-        // Check if the existingUser has any active teams\n-        const belongsToActiveTeam = checkIfUserBelongsToActiveTeam(existingUser);\n-        const { teams: _teams, ...existingUserWithoutTeamsField } = existingUser;\n-        const allProfiles = await ProfileRepository.findAllProfilesForUserIncludingMovedUser(existingUser);\n-        log.debug(\n-          \"callbacks:jwt:autoMergeIdentities\",\n-          safeStringify({\n-            allProfiles,\n-          })\n-        );\n-        const { upId } = determineProfile({ profiles: allProfiles, token });\n-\n-        const profile = await ProfileRepository.findByUpIdWithAuth(upId, existingUser.id);\n-        if (!profile) {\n-          throw new Error(\"Profile not found\");\n-        }\n-\n-        const profileOrg = profile?.organization;\n-        let orgRole: MembershipRole | undefined;\n-        // Get users role of org\n-        if (profileOrg) {\n-          const membership = await prisma.membership.findUnique({\n-            where: {\n-              userId_teamId: {\n-                teamId: profileOrg.id,\n-                userId: existingUser.id,\n-              },\n-            },\n-          });\n-          orgRole = membership?.role;\n-        }\n-\n-        return {\n-          ...existingUserWithoutTeamsField,\n-          ...token,\n-          profileId: profile.id,\n-          upId,\n-          belongsToActiveTeam,\n-          orgAwareUsername: profileOrg ? profile.username : existingUser.username,\n-          // All organizations in the token would be too big to store. It breaks the sessions request.\n-          // So, we just set the currently switched organization only here.\n-          // platform org user don't need profiles nor domains\n-          org:\n-            profileOrg && !profileOrg.isPlatform\n-              ? {\n-                  id: profileOrg.id,\n-                  name: profileOrg.name,\n-                  slug: profileOrg.slug ?? profileOrg.requestedSlug ?? \"\",\n-                  logoUrl: profileOrg.logoUrl,\n-                  fullDomain: getOrgFullOrigin(profileOrg.slug ?? profileOrg.requestedSlug ?? \"\"),\n-                  domainSuffix: subdomainSuffix(),\n-                  role: orgRole as MembershipRole, // It can't be undefined if we have a profileOrg\n-                }\n-              : null,\n-        } as JWT;\n-      };\n-      if (!user) {\n-        return await autoMergeIdentities();\n-      }\n-      if (!account) {\n-        return token;\n-      }\n-      if (account.type === \"credentials\") {\n-        log.debug(\"callbacks:jwt:accountType:credentials\", safeStringify({ account }));\n-        // return token if credentials,saml-idp\n-        if (account.provider === \"saml-idp\") {\n-          return { ...token, upId: user.profile?.upId ?? token.upId ?? null } as JWT;\n-        }\n-        // any other credentials, add user info\n-        return {\n-          ...token,\n-          id: user.id,\n-          name: user.name,\n-          username: user.username,\n-          orgAwareUsername: user?.org ? user.profile?.username : user.username,\n-          email: user.email,\n-          role: user.role,\n-          impersonatedBy: user.impersonatedBy,\n-          belongsToActiveTeam: user?.belongsToActiveTeam,\n-          org: user?.org,\n-          locale: user?.locale,\n-          profileId: user.profile?.id ?? token.profileId ?? null,\n-          upId: user.profile?.upId ?? token.upId ?? null,\n-        } as JWT;\n-      }\n-\n-      // The arguments above are from the provider so we need to look up the\n-      // user based on those values in order to construct a JWT.\n-      if (account.type === \"oauth\") {\n-        log.debug(\"callbacks:jwt:accountType:oauth\", safeStringify({ account }));\n-        if (!account.provider || !account.providerAccountId) {\n-          return { ...token, upId: user.profile?.upId ?? token.upId ?? null } as JWT;\n-        }\n-        const idP = account.provider === \"saml\" ? IdentityProvider.SAML : IdentityProvider.GOOGLE;\n-\n-        const existingUser = await prisma.user.findFirst({\n-          where: {\n-            AND: [\n-              {\n-                identityProvider: idP,\n-              },\n-              {\n-                identityProviderId: account.providerAccountId,\n-              },\n-            ],\n-          },\n-        });\n-\n-        if (!existingUser) {\n-          return await autoMergeIdentities();\n-        }\n-\n-        const grantedScopes = account.scope?.split(\" \") ?? [];\n-        if (\n-          account.provider === \"google\" &&\n-          !(await CredentialRepository.findFirstByAppIdAndUserId({\n-            userId: Number(user.id),\n-            appId: \"google-calendar\",\n-          })) &&\n-          GOOGLE_CALENDAR_SCOPES.every((scope) => grantedScopes.includes(scope))\n-        ) {\n-          // Installing Google Calendar by default\n-          const credentialkey = {\n-            access_token: account.access_token,\n-            refresh_token: account.refresh_token,\n-            id_token: account.id_token,\n-            token_type: account.token_type,\n-            expires_at: account.expires_at,\n-          };\n-          const gcalCredential = await CredentialRepository.create({\n-            userId: Number(user.id),\n-            key: credentialkey,\n-            appId: \"google-calendar\",\n-            type: \"google_calendar\",\n-          });\n-          const gCalService = new GoogleCalendarService({\n-            ...gcalCredential,\n-            user: null,\n-            delegatedTo: null,\n-          });\n-\n-          if (\n-            !(await CredentialRepository.findFirstByUserIdAndType({\n-              userId: Number(user.id),\n-              type: \"google_video\",\n-            }))\n-          ) {\n-            await CredentialRepository.create({\n-              type: \"google_video\",\n-              key: {},\n-              userId: Number(user.id),\n-              appId: \"google-meet\",\n-            });\n-          }\n-\n-          const oAuth2Client = new OAuth2Client(GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET);\n-          oAuth2Client.setCredentials(credentialkey);\n-          const calendar = new calendar_v3.Calendar({\n-            auth: oAuth2Client,\n-          });\n-          const primaryCal = await gCalService.getPrimaryCalendar(calendar);\n-          if (primaryCal?.id) {\n-            await gCalService.createSelectedCalendar({\n-              externalId: primaryCal.id,\n-              userId: Number(user.id),\n-            });\n-          }\n-          await updateProfilePhotoGoogle(oAuth2Client, Number(user.id));\n-        }\n-        const allProfiles = await ProfileRepository.findAllProfilesForUserIncludingMovedUser(existingUser);\n-        const { upId } = determineProfile({ profiles: allProfiles, token });\n-        log.debug(\"callbacks:jwt:accountType:oauth:existingUser\", safeStringify({ existingUser, upId }));\n-        return {\n-          ...token,\n-          upId,\n-          id: existingUser.id,\n-          name: existingUser.name,\n-          username: existingUser.username,\n-          email: existingUser.email,\n-          role: existingUser.role,\n-          impersonatedBy: token.impersonatedBy,\n-          belongsToActiveTeam: token?.belongsToActiveTeam as boolean,\n-          org: token?.org,\n-          orgAwareUsername: token.orgAwareUsername,\n-          locale: existingUser.locale,\n-        } as JWT;\n-      }\n-\n-      if (account.type === \"email\") {\n-        return await autoMergeIdentities();\n-      }\n-\n-      log.info(\n-        \"callbacks:jwt:accountType:unknown\",\n-        safeStringify({ accountType: account.type, accountProvider: account.provider })\n-      );\n-      return token;\n-    },\n-    async session({ session, token, user }) {\n-      log.debug(\"callbacks:session - Session callback called\", safeStringify({ session, token, user }));\n-      const deploymentRepo = new DeploymentRepository(prisma);\n-      const licenseKeyService = await LicenseKeySingleton.getInstance(deploymentRepo);\n-      const hasValidLicense = await licenseKeyService.checkLicense();\n-      const profileId = token.profileId;\n-      const calendsoSession: Session = {\n-        ...session,\n-        profileId,\n-        upId: token.upId || session.upId,\n-        hasValidLicense,\n-        user: {\n-          ...session.user,\n-          id: token.id as number,\n-          name: token.name,\n-          username: token.username as string,\n-          orgAwareUsername: token.orgAwareUsername,\n-          role: token.role as UserPermissionRole,\n-          impersonatedBy: token.impersonatedBy,\n-          belongsToActiveTeam: token?.belongsToActiveTeam as boolean,\n-          org: token?.org,\n-          locale: token.locale,\n-        },\n-      };\n-      return calendsoSession;\n-    },\n-    async signIn(params): Promise<boolean | string> {\n-      const {\n-        /**\n-         * Available when Credentials provider is used - Has the value returned by authorize callback\n-         */\n-        user,\n-        /**\n-         * Available when Credentials provider is used - Has the value submitted as the body of the HTTP POST submission\n-         */\n-        profile,\n-        account,\n-      } = params;\n-\n-      log.debug(\"callbacks:signin\", safeStringify(params));\n-\n-      if (account?.provider === \"email\") {\n-        return true;\n-      }\n-      // In this case we've already verified the credentials in the authorize\n-      // callback so we can sign the user in.\n-      // Only if provider is not saml-idp\n-      if (account?.provider !== \"saml-idp\") {\n-        if (account?.type === \"credentials\") {\n-          return true;\n-        }\n-\n-        if (account?.type !== \"oauth\") {\n-          return false;\n-        }\n-      }\n-      if (!user.email) {\n-        return false;\n-      }\n-\n-      if (!user.name) {\n-        return false;\n-      }\n-      if (account?.provider) {\n-        const idP: IdentityProvider = mapIdentityProvider(account.provider);\n-        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n-        // @ts-ignore-error TODO validate email_verified key on profile\n-        user.email_verified = user.email_verified || !!user.emailVerified || profile.email_verified;\n-\n-        if (!user.email_verified) {\n-          log.error(\"Attention: SAML/Google User email is not verified in the IdP\", safeStringify({ user }));\n-          return \"/auth/error?error=unverified-email\";\n-        }\n-\n-        let existingUser = await prisma.user.findFirst({\n-          include: {\n-            password: {\n-              select: {\n-                hash: true,\n-              },\n-            },\n-            accounts: {\n-              where: {\n-                provider: account.provider,\n-              },\n-            },\n-          },\n-          where: {\n-            identityProvider: idP,\n-            identityProviderId: account.providerAccountId,\n-          },\n-        });\n-\n-        /* --- START FIX LEGACY ISSUE WHERE 'identityProviderId' was accidentally set to userId --- */\n-        if (!existingUser) {\n-          existingUser = await prisma.user.findFirst({\n-            include: {\n-              password: {\n-                select: {\n-                  hash: true,\n-                },\n-              },\n-              accounts: {\n-                where: {\n-                  provider: account.provider,\n-                },\n-              },\n-            },\n-            where: {\n-              identityProvider: idP,\n-              identityProviderId: String(user.id),\n-            },\n-          });\n-          if (existingUser) {\n-            await prisma.user.update({\n-              where: {\n-                id: existingUser?.id,\n-              },\n-              data: {\n-                identityProviderId: account.providerAccountId,\n-              },\n-            });\n-          }\n-        }\n-        /* --- END FIXES LEGACY ISSUE WHERE 'identityProviderId' was accidentally set to userId --- */\n-        if (existingUser) {\n-          // In this case there's an existing user and their email address\n-          // hasn't changed since they last logged in.\n-          if (existingUser.email === user.email) {\n-            try {\n-              // If old user without Account entry we link their google account\n-              if (existingUser.accounts.length === 0) {\n-                const linkAccountWithUserData = AdapterAccountPresenter.fromCalAccount(\n-                  account,\n-                  existingUser.id,\n-                  user.email\n-                );\n-                await calcomAdapter.linkAccount(linkAccountWithUserData);\n-              }\n-            } catch (error) {\n-              if (error instanceof Error) {\n-                log.error(\"Error while linking account of already existing user\", safeStringify(error));\n-              }\n-            }\n-            if (existingUser.twoFactorEnabled && existingUser.identityProvider === idP) {\n-              return loginWithTotp(existingUser.email);\n-            } else {\n-              return true;\n-            }\n-          }\n-\n-          // If the email address doesn't match, check if an account already exists\n-          // with the new email address. If it does, for now we return an error. If\n-          // not, update the email of their account and log them in.\n-          const userWithNewEmail = await prisma.user.findFirst({\n-            where: { email: user.email },\n-          });\n-\n-          if (!userWithNewEmail) {\n-            await prisma.user.update({ where: { id: existingUser.id }, data: { email: user.email } });\n-            if (existingUser.twoFactorEnabled) {\n-              return loginWithTotp(existingUser.email);\n-            } else {\n-              return true;\n-            }\n-          } else {\n-            return \"/auth/error?error=new-email-conflict\";\n-          }\n-        }\n-\n-        // If there's no existing user for this identity provider and id, create\n-        // a new account. If an account already exists with the incoming email\n-        // address return an error for now.\n-\n-        const existingUserWithEmail = await prisma.user.findFirst({\n-          where: {\n-            email: {\n-              equals: user.email,\n-              mode: \"insensitive\",\n-            },\n-          },\n-          include: {\n-            password: {\n-              select: {\n-                hash: true,\n-              },\n-            },\n-          },\n-        });\n-\n-        if (existingUserWithEmail) {\n-          // if self-hosted then we can allow auto-merge of identity providers if email is verified\n-          if (\n-            !hostedCal &&\n-            existingUserWithEmail.emailVerified &&\n-            existingUserWithEmail.identityProvider !== IdentityProvider.CAL\n-          ) {\n-            if (existingUserWithEmail.twoFactorEnabled) {\n-              return loginWithTotp(existingUserWithEmail.email);\n-            } else {\n-              return true;\n-            }\n-          }\n-\n-          // check if user was invited\n-          if (\n-            !existingUserWithEmail.password?.hash &&\n-            !existingUserWithEmail.emailVerified &&\n-            !existingUserWithEmail.username\n-          ) {\n-            await prisma.user.update({\n-              where: {\n-                email: existingUserWithEmail.email,\n-              },\n-              data: {\n-                // update the email to the IdP email\n-                email: user.email,\n-                // Slugify the incoming name and append a few random characters to\n-                // prevent conflicts for users with the same name.\n-                username: getOrgUsernameFromEmail(user.email, getDomainFromEmail(user.email)),\n-                emailVerified: new Date(Date.now()),\n-                name: user.name,\n-                identityProvider: idP,\n-                identityProviderId: account.providerAccountId,\n-              },\n-            });\n-\n-            if (existingUserWithEmail.twoFactorEnabled) {\n-              return loginWithTotp(existingUserWithEmail.email);\n-            } else {\n-              return true;\n-            }\n-          }\n-\n-          // User signs up with email/password and then tries to login with Google/SAML using the same email\n-          if (\n-            existingUserWithEmail.identityProvider === IdentityProvider.CAL &&\n-            (idP === IdentityProvider.GOOGLE || idP === IdentityProvider.SAML)\n-          ) {\n-            await prisma.user.update({\n-              where: { email: existingUserWithEmail.email },\n-              // also update email to the IdP email\n-              data: {\n-                email: user.email.toLowerCase(),\n-                identityProvider: idP,\n-                identityProviderId: account.providerAccountId,\n-              },\n-            });\n-\n-            if (existingUserWithEmail.twoFactorEnabled) {\n-              return loginWithTotp(existingUserWithEmail.email);\n-            } else {\n-              return true;\n-            }\n-          } else if (existingUserWithEmail.identityProvider === IdentityProvider.CAL) {\n-            return `/auth/error?error=wrong-provider&provider=${existingUserWithEmail.identityProvider}`;\n-          } else if (\n-            existingUserWithEmail.identityProvider === IdentityProvider.GOOGLE &&\n-            idP === IdentityProvider.SAML\n-          ) {\n-            await prisma.user.update({\n-              where: { email: existingUserWithEmail.email },\n-              // also update email to the IdP email\n-              data: {\n-                email: user.email.toLowerCase(),\n-                identityProvider: idP,\n-                identityProviderId: account.providerAccountId,\n-              },\n-            });\n-\n-            if (existingUserWithEmail.twoFactorEnabled) {\n-              return loginWithTotp(existingUserWithEmail.email);\n-            } else {\n-              return true;\n-            }\n-          }\n-          return `/auth/error?error=wrong-provider&provider=${existingUserWithEmail.identityProvider}`;\n-        }\n-\n-        // Associate with organization if enabled by flag and idP is Google (for now)\n-        const { orgUsername, orgId } = await checkIfUserShouldBelongToOrg(idP, user.email);\n-\n-        try {\n-          const newUser = await prisma.user.create({\n-            data: {\n-              // Slugify the incoming name and append a few random characters to\n-              // prevent conflicts for users with the same name.\n-              username: orgId ? slugify(orgUsername) : usernameSlug(user.name),\n-              emailVerified: new Date(Date.now()),\n-              name: user.name,\n-              ...(user.image && { avatarUrl: user.image }),\n-              email: user.email,\n-              identityProvider: idP,\n-              identityProviderId: account.providerAccountId,\n-              ...(orgId && {\n-                verified: true,\n-                organization: { connect: { id: orgId } },\n-                teams: {\n-                  create: { role: MembershipRole.MEMBER, accepted: true, team: { connect: { id: orgId } } },\n-                },\n-              }),\n-              creationSource: CreationSource.WEBAPP,\n-            },\n-          });\n-          const linkAccountNewUserData = AdapterAccountPresenter.fromCalAccount(\n-            account,\n-            newUser.id,\n-            user.email\n-          );\n-          await calcomAdapter.linkAccount(linkAccountNewUserData);\n-\n-          if (account.twoFactorEnabled) {\n-            return loginWithTotp(newUser.email);\n-          } else {\n-            return true;\n-          }\n-        } catch (err) {\n-          log.error(\"Error creating a new user\", err);\n-          return `/auth/error?error=user-creation-error`;\n-        }\n-      }\n-\n-      return false;\n-    },\n-    /**\n-     * Used to handle the navigation right after successful login or logout\n-     */\n-    async redirect({ url, baseUrl }) {\n-      // Allows relative callback URLs\n-      if (url.startsWith(\"/\")) return `${baseUrl}${url}`;\n-      // Allows callback URLs on the same domain\n-      else if (new URL(url).hostname === new URL(WEBAPP_URL).hostname) return url;\n-      return baseUrl;\n-    },\n-  },\n-  events: {\n-    async signIn(message) {\n-      /* only run this code if:\n-         - it's a hosted cal account\n-         - DUB_API_KEY is configured\n-         - it's a new user\n-      */\n-      const user = message.user as User & {\n-        username: string;\n-        createdDate: string;\n-      };\n-      // check if the user was created in the last 10 minutes\n-      // this is a workaround \u2013 in the future once we move to use the Account model in the DB\n-      // we should use NextAuth's isNewUser flag instead: https://next-auth.js.org/configuration/events#signin\n-      const isNewUser = new Date(user.createdDate) > new Date(Date.now() - 10 * 60 * 1000);\n-      if ((isENVDev || IS_CALCOM) && isNewUser) {\n-        if (process.env.DUB_API_KEY) {\n-          const clickId = getDubId();\n-          // check if there's a clickId (dub_id) cookie set by @dub/analytics\n-          if (clickId) {\n-            // here we use waitUntil \u2013 meaning this code will run async to not block the main thread\n-            waitUntil(\n-              // if so, send a lead event to Dub\n-              // @see https://d.to/conversions/next-auth\n-              dub.track.lead({\n-                clickId,\n-                eventName: \"Sign Up\",\n-                externalId: user.id.toString(),\n-                customerName: user.name,\n-                customerEmail: user.email,\n-                customerAvatar: user.image,\n-              })\n-            );\n-          }\n-        }\n-      }\n-    },\n-  },\n-});\n-\n-/**\n- * Identifies the profile the user should be logged into.\n- */\n-const determineProfile = ({\n-  token,\n-  profiles,\n-}: {\n-  token: JWT;\n-  profiles: { id: number | null; upId: string }[];\n-}) => {\n-  // If profile switcher is disabled, we can only show the first profile.\n-  if (!ENABLE_PROFILE_SWITCHER) {\n-    return profiles[0];\n-  }\n-\n-  if (token.upId) {\n-    // Otherwise use what's in the token\n-    return { profileId: token.profileId, upId: token.upId as string };\n-  }\n-\n-  // If there is just one profile it has to be the one we want to log into.\n-  return profiles[0];\n-};\n+          redirect_uri: `${process.env.NEXTAUTH_URL}\n\\ No newline at end of file\ndiff --git a/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts b/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts\nindex d5d1cdb..90b90b6 100644\n--- a/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts\n+++ b/packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts\n@@ -16,30 +16,6 @@ describe(\"getOrgUsernameFromEmail\", () => {\n     const result = getOrgUsernameFromEmail(email, autoAcceptEmailDomain);\n     expect(result).toBe(\"john.doe-example\");\n   });\n-\n-  it(\"should generate unique usernames for different emails even with same name\", () => {\n-    const email1 = \"alice@acme.com\";\n-    const email2 = \"alice+work@corp.com\";\n-\n-    const username1 = getOrgUsernameFromEmail(email1, null);\n-    const username2 = getOrgUsernameFromEmail(email2, null);\n-\n-    expect(username1).toBe(\"alice-acme\");\n-    expect(username2).toBe(\"alice-work-corp\");\n-    expect(username1).not.toBe(username2);\n-  });\n-\n-  it(\"should handle email with plus sign correctly\", () => {\n-    const email = \"bob+test@example.com\";\n-    const result = getOrgUsernameFromEmail(email, \"example.com\");\n-    expect(result).toBe(\"bob-test\");\n-  });\n-\n-  it(\"should handle null autoAcceptEmailDomain\", () => {\n-    const email = \"user@company.com\";\n-    const result = getOrgUsernameFromEmail(email, null);\n-    expect(result).toBe(\"user-company\");\n-  });\n });\n \n describe(\"deriveNameFromOrgUsername\", () => {\n@@ -48,4 +24,4 @@ describe(\"deriveNameFromOrgUsername\", () => {\n     const result = deriveNameFromOrgUsername({ username });\n     expect(result).toBe(\"John Doe Example\");\n   });\n-});\n+});\n\\ No newline at end of file\n",
    "pr_number": 25435,
    "title": "fix: signup username collision",
    "test_files": [
      "packages/features/auth/signup/utils/getOrgUsernameFromEmail.test.ts"
    ],
    "code_files": [
      "packages/features/auth/lib/next-auth-options.ts"
    ]
  },
  {
    "instance_id": "calcom__cal.com.main.25502",
    "repo": "calcom/cal.com",
    "base_commit": "41ad0f718dcda69d502b28302571741470672e05",
    "bug_patch": "diff --git a/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts b/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts\nindex 6dfc3ae..361b581 100644\n--- a/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts\n+++ b/packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts\n@@ -12,7 +12,7 @@ import type { CalendarSyncService } from \"@calcom/features/calendar-subscription\n import type { FeaturesRepository } from \"@calcom/features/flags/features.repository\";\n import logger from \"@calcom/lib/logger\";\n import type { ISelectedCalendarRepository } from \"@calcom/lib/server/repository/SelectedCalendarRepository.interface\";\n-import type { SelectedCalendar } from \"@calcom/prisma/client\";\n+import { SelectedCalendar } from \"@calcom/prisma/client\";\n \n const log = logger.getSubLogger({ prefix: [\"CalendarSubscriptionService\"] });\n \n@@ -204,14 +204,9 @@ export class CalendarSubscriptionService {\n    * Subscribe periodically to new calendars\n    */\n   async checkForNewSubscriptions() {\n-    const teamIds = await this.deps.featuresRepository.getTeamsWithFeatureEnabled(\n-      CalendarSubscriptionService.CALENDAR_SUBSCRIPTION_CACHE_FEATURE\n-    );\n-\n     const rows = await this.deps.selectedCalendarRepository.findNextSubscriptionBatch({\n       take: 100,\n       integrations: this.deps.adapterFactory.getProviders(),\n-      teamIds,\n     });\n     log.debug(\"checkForNewSubscriptions\", { count: rows.length });\n     await Promise.allSettled(rows.map(({ id }) => this.subscribe(id)));\n@@ -271,4 +266,4 @@ export class CalendarSubscriptionService {\n         : null,\n     };\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts b/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts\nindex 459b870..6024d56 100644\n--- a/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts\n+++ b/packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts\n@@ -125,8 +125,6 @@ describe(\"CalendarSubscriptionService\", () => {\n     mockFeaturesRepository = {\n       checkIfFeatureIsEnabledGlobally: vi.fn().mockResolvedValue(true),\n       checkIfUserHasFeature: vi.fn().mockResolvedValue(true),\n-      checkIfTeamHasFeature: vi.fn().mockResolvedValue(true),\n-      getTeamsWithFeatureEnabled: vi.fn().mockResolvedValue([1, 2, 3]),\n     };\n \n     mockCalendarCacheEventService = {\n@@ -363,144 +361,4 @@ describe(\"CalendarSubscriptionService\", () => {\n       const calendarWithoutCredential = {\n         ...mockSelectedCalendar,\n         credentialId: null,\n-        delegationCredentialId: null,\n-      };\n-\n-      await service.processEvents(calendarWithoutCredential);\n-\n-      expect(mockAdapter.fetchEvents).not.toHaveBeenCalled();\n-    });\n-  });\n-\n-  describe(\"checkForNewSubscriptions\", () => {\n-    test(\"should process new subscriptions\", async () => {\n-      const subscribeSpy = vi.spyOn(service, \"subscribe\").mockResolvedValue(undefined);\n-\n-      await service.checkForNewSubscriptions();\n-\n-      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n-        \"calendar-subscription-cache\"\n-      );\n-      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n-        take: 100,\n-        integrations: [\"google_calendar\", \"office365_calendar\"],\n-        teamIds: [1, 2, 3],\n-      });\n-      expect(subscribeSpy).toHaveBeenCalledWith(mockSelectedCalendar.id);\n-    });\n-\n-    test(\"should handle mixed cache scenario where some teams have cache enabled and some do not\", async () => {\n-      const calendarWithCache = { ...mockSelectedCalendar, id: \"calendar-with-cache\", userId: 1 };\n-      const calendarWithCache2 = { ...mockSelectedCalendar, id: \"calendar-with-cache-2\", userId: 2 };\n-\n-      mockFeaturesRepository.getTeamsWithFeatureEnabled.mockResolvedValue([10, 20]);\n-\n-      mockSelectedCalendarRepository.findNextSubscriptionBatch.mockResolvedValue([\n-        calendarWithCache,\n-        calendarWithCache2,\n-      ]);\n-\n-      const subscribeSpy = vi.spyOn(service, \"subscribe\").mockResolvedValue(undefined);\n-\n-      await service.checkForNewSubscriptions();\n-\n-      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n-        \"calendar-subscription-cache\"\n-      );\n-      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n-        take: 100,\n-        integrations: [\"google_calendar\", \"office365_calendar\"],\n-        teamIds: [10, 20],\n-      });\n-      expect(subscribeSpy).toHaveBeenCalledTimes(2);\n-      expect(subscribeSpy).toHaveBeenCalledWith(\"calendar-with-cache\");\n-      expect(subscribeSpy).toHaveBeenCalledWith(\"calendar-with-cache-2\");\n-    });\n-\n-    test(\"should only fetch calendars for teams with feature enabled, not entire organization hierarchy\", async () => {\n-      const teamId = 100;\n-      const parentOrgId = 1;\n-\n-      mockFeaturesRepository.getTeamsWithFeatureEnabled.mockResolvedValue([teamId]);\n-\n-      const calendarForTeamMember = { ...mockSelectedCalendar, id: \"team-member-calendar\", userId: 5 };\n-      mockSelectedCalendarRepository.findNextSubscriptionBatch.mockResolvedValue([calendarForTeamMember]);\n-\n-      const subscribeSpy = vi.spyOn(service, \"subscribe\").mockResolvedValue(undefined);\n-\n-      await service.checkForNewSubscriptions();\n-\n-      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n-        \"calendar-subscription-cache\"\n-      );\n-      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n-        take: 100,\n-        integrations: [\"google_calendar\", \"office365_calendar\"],\n-        teamIds: [teamId],\n-      });\n-      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).not.toHaveBeenCalledWith(\n-        expect.objectContaining({\n-          teamIds: expect.arrayContaining([parentOrgId]),\n-        })\n-      );\n-      expect(subscribeSpy).toHaveBeenCalledTimes(1);\n-      expect(subscribeSpy).toHaveBeenCalledWith(\"team-member-calendar\");\n-    });\n-\n-    test(\"should not process any calendars when no teams have the feature enabled\", async () => {\n-      mockFeaturesRepository.getTeamsWithFeatureEnabled.mockResolvedValue([]);\n-\n-      mockSelectedCalendarRepository.findNextSubscriptionBatch.mockResolvedValue([]);\n-\n-      const subscribeSpy = vi.spyOn(service, \"subscribe\").mockResolvedValue(undefined);\n-\n-      await service.checkForNewSubscriptions();\n-\n-      expect(mockFeaturesRepository.getTeamsWithFeatureEnabled).toHaveBeenCalledWith(\n-        \"calendar-subscription-cache\"\n-      );\n-      expect(mockSelectedCalendarRepository.findNextSubscriptionBatch).toHaveBeenCalledWith({\n-        take: 100,\n-        integrations: [\"google_calendar\", \"office365_calendar\"],\n-        teamIds: [],\n-      });\n-      expect(subscribeSpy).not.toHaveBeenCalled();\n-    });\n-  });\n-\n-  describe(\"feature flag methods\", () => {\n-    test(\"isCacheEnabled should check global cache feature\", async () => {\n-      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally.mockResolvedValue(true);\n-\n-      const result = await service.isCacheEnabled();\n-\n-      expect(result).toBe(true);\n-      expect(mockFeaturesRepository.checkIfFeatureIsEnabledGlobally).toHaveBeenCalledWith(\n-        \"calendar-subscription-cache\"\n-      );\n-    });\n-\n-    test(\"isCacheEnabledForUser should check user cache feature\", async () => {\n-      mockFeaturesRepository.checkIfUserHasFeature.mockResolvedValue(true);\n-\n-      const result = await service.isCacheEnabledForUser(1);\n-\n-      expect(result).toBe(true);\n-      expect(mockFeaturesRepository.checkIfUserHasFeature).toHaveBeenCalledWith(\n-        1,\n-        \"calendar-subscription-cache\"\n-      );\n-    });\n-\n-    test(\"isSyncEnabled should check global sync feature\", async () => {\n-      mockFeaturesRepository.checkIfFeatureIsEnabledGlobally.mockResolvedValue(true);\n-\n-      const result = await service.isSyncEnabled();\n-\n-      expect(result).toBe(true);\n-      expect(mockFeaturesRepository.checkIfFeatureIsEnabledGlobally).toHaveBeenCalledWith(\n-        \"calendar-subscription-sync\"\n-      );\n-    });\n-  });\n-});\n+        delegationCredential\n\\ No newline at end of file\ndiff --git a/packages/features/flags/features.repository.interface.ts b/packages/features/flags/features.repository.interface.ts\nindex 782714d..a93934e 100644\n--- a/packages/features/flags/features.repository.interface.ts\n+++ b/packages/features/flags/features.repository.interface.ts\n@@ -4,5 +4,4 @@ export interface IFeaturesRepository {\n   checkIfFeatureIsEnabledGlobally(slug: keyof AppFlags): Promise<boolean>;\n   checkIfUserHasFeature(userId: number, slug: string): Promise<boolean>;\n   checkIfTeamHasFeature(teamId: number, slug: keyof AppFlags): Promise<boolean>;\n-  getTeamsWithFeatureEnabled(slug: keyof AppFlags): Promise<number[]>;\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/features/flags/features.repository.ts b/packages/features/flags/features.repository.ts\nindex 48e3bd0..0b0b23d 100644\n--- a/packages/features/flags/features.repository.ts\n+++ b/packages/features/flags/features.repository.ts\n@@ -351,23 +351,4 @@ export class FeaturesRepository implements IFeaturesRepository {\n       throw err;\n     }\n   }\n-\n-  async getTeamsWithFeatureEnabled(slug: keyof AppFlags): Promise<number[]> {\n-    try {\n-      // If globally disabled, treat as effectively disabled everywhere\n-      const isGloballyEnabled = await this.checkIfFeatureIsEnabledGlobally(slug);\n-      if (!isGloballyEnabled) return [];\n-\n-      const rows = await this.prismaClient.teamFeatures.findMany({\n-        where: { featureId: slug },\n-        select: { teamId: true },\n-        orderBy: { teamId: \"asc\" },\n-      });\n-\n-      return rows.map((r) => r.teamId);\n-    } catch (err) {\n-      captureException(err);\n-      throw err;\n-    }\n-  }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/lib/server/repository/SelectedCalendarRepository.interface.ts b/packages/lib/server/repository/SelectedCalendarRepository.interface.ts\nindex 2d11938..8026cca 100644\n--- a/packages/lib/server/repository/SelectedCalendarRepository.interface.ts\n+++ b/packages/lib/server/repository/SelectedCalendarRepository.interface.ts\n@@ -24,11 +24,9 @@ export interface ISelectedCalendarRepository {\n    */\n   findNextSubscriptionBatch({\n     take,\n-    teamIds,\n     integrations,\n   }: {\n     take: number;\n-    teamIds: number[];\n     integrations?: string[];\n   }): Promise<SelectedCalendar[]>;\n \n@@ -61,4 +59,4 @@ export interface ISelectedCalendarRepository {\n       | \"syncSubscribedAt\"\n     >\n   ): Promise<SelectedCalendar>;\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/lib/server/repository/SelectedCalendarRepository.ts b/packages/lib/server/repository/SelectedCalendarRepository.ts\nindex 716a35e..84bd010 100644\n--- a/packages/lib/server/repository/SelectedCalendarRepository.ts\n+++ b/packages/lib/server/repository/SelectedCalendarRepository.ts\n@@ -15,24 +15,26 @@ export class SelectedCalendarRepository implements ISelectedCalendarRepository {\n     return this.prismaClient.selectedCalendar.findFirst({ where: { channelId } });\n   }\n \n-  async findNextSubscriptionBatch({\n-    take,\n-    teamIds,\n-    integrations,\n-  }: {\n-    take: number;\n-    teamIds: number[];\n-    integrations: string[];\n-  }) {\n+  async findNextSubscriptionBatch({ take, integrations }: { take: number; integrations: string[] }) {\n     return this.prismaClient.selectedCalendar.findMany({\n       where: {\n         integration: { in: integrations },\n         OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: new Date() } }],\n+        // initially we will run subscription only for teams that have\n+        // the feature flags enabled and it should be removed later\n         user: {\n           teams: {\n             some: {\n-              teamId: { in: teamIds },\n-              accepted: true,\n+              team: {\n+                features: {\n+                  some: {\n+                    OR: [\n+                      { featureId: \"calendar-subscription-cache\" },\n+                      { featureId: \"calendar-subscription-sync\" },\n+                    ],\n+                  },\n+                },\n+              },\n             },\n           },\n         },\n@@ -71,4 +73,4 @@ export class SelectedCalendarRepository implements ISelectedCalendarRepository {\n       data,\n     });\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts b/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts\nindex ac1b815..df8c47b 100644\n--- a/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts\n+++ b/packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts\n@@ -116,7 +116,6 @@ describe(\"SelectedCalendarRepository\", () => {\n \n       const result = await repository.findNextSubscriptionBatch({\n         take: 10,\n-        teamIds: [1, 2, 3],\n         integrations: [\"google_calendar\", \"office365_calendar\"],\n       });\n \n@@ -127,8 +126,16 @@ describe(\"SelectedCalendarRepository\", () => {\n           user: {\n             teams: {\n               some: {\n-                teamId: { in: [1, 2, 3] },\n-                accepted: true,\n+                team: {\n+                  features: {\n+                    some: {\n+                      OR: [\n+                        { featureId: \"calendar-subscription-cache\" },\n+                        { featureId: \"calendar-subscription-sync\" },\n+                      ],\n+                    },\n+                  },\n+                },\n               },\n             },\n           },\n@@ -145,7 +152,6 @@ describe(\"SelectedCalendarRepository\", () => {\n \n       const result = await repository.findNextSubscriptionBatch({\n         take: 5,\n-        teamIds: [10, 20],\n         integrations: [],\n       });\n \n@@ -156,8 +162,16 @@ describe(\"SelectedCalendarRepository\", () => {\n           user: {\n             teams: {\n               some: {\n-                teamId: { in: [10, 20] },\n-                accepted: true,\n+                team: {\n+                  features: {\n+                    some: {\n+                      OR: [\n+                        { featureId: \"calendar-subscription-cache\" },\n+                        { featureId: \"calendar-subscription-sync\" },\n+                      ],\n+                    },\n+                  },\n+                },\n               },\n             },\n           },\n@@ -167,35 +181,6 @@ describe(\"SelectedCalendarRepository\", () => {\n \n       expect(result).toEqual(mockCalendars);\n     });\n-\n-    test(\"should handle empty teamIds array\", async () => {\n-      const mockCalendars: SelectedCalendar[] = [];\n-      vi.mocked(mockPrismaClient.selectedCalendar.findMany).mockResolvedValue(mockCalendars);\n-\n-      const result = await repository.findNextSubscriptionBatch({\n-        take: 10,\n-        teamIds: [],\n-        integrations: [\"google_calendar\"],\n-      });\n-\n-      expect(mockPrismaClient.selectedCalendar.findMany).toHaveBeenCalledWith({\n-        where: {\n-          integration: { in: [\"google_calendar\"] },\n-          OR: [{ syncSubscribedAt: null }, { channelExpiration: { lte: expect.any(Date) } }],\n-          user: {\n-            teams: {\n-              some: {\n-                teamId: { in: [] },\n-                accepted: true,\n-              },\n-            },\n-          },\n-        },\n-        take: 10,\n-      });\n-\n-      expect(result).toEqual(mockCalendars);\n-    });\n   });\n \n   describe(\"updateSyncStatus\", () => {\n@@ -320,4 +305,4 @@ describe(\"SelectedCalendarRepository\", () => {\n       expect(result).toEqual(updatedCalendar);\n     });\n   });\n-});\n+});\n\\ No newline at end of file\n",
    "pr_number": 25502,
    "title": "perf: Calendar Cache Improvements",
    "test_files": [
      "packages/features/calendar-subscription/lib/__tests__/CalendarSubscriptionService.test.ts",
      "packages/lib/server/repository/__tests__/SelectedCalendarRepository.test.ts"
    ],
    "code_files": [
      "packages/features/calendar-subscription/lib/CalendarSubscriptionService.ts",
      "packages/features/flags/features.repository.interface.ts",
      "packages/features/flags/features.repository.ts",
      "packages/lib/server/repository/SelectedCalendarRepository.interface.ts",
      "packages/lib/server/repository/SelectedCalendarRepository.ts"
    ]
  },
  {
    "instance_id": "calcom__cal.com.main.25587",
    "repo": "calcom/cal.com",
    "base_commit": "1c3ced5b7040115e0ac1301e8482d49a80881d6c",
    "bug_patch": "diff --git a/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx b/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx\nindex 3cf44ce..3f29aa8 100644\n--- a/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx\n+++ b/apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx\n@@ -5,11 +5,13 @@ import { headers, cookies } from \"next/headers\";\n import { redirect } from \"next/navigation\";\n \n import { getServerSession } from \"@calcom/features/auth/lib/getServerSession\";\n-import { getTeamMemberPermissions } from \"@calcom/features/pbac/lib/team-member-permissions\";\n+import { Resource, CustomAction } from \"@calcom/features/pbac/domain/types/permission-registry\";\n+import { getSpecificPermissions } from \"@calcom/features/pbac/lib/resource-permissions\";\n import { RoleManagementFactory } from \"@calcom/features/pbac/services/role-management.factory\";\n import SettingsHeader from \"@calcom/features/settings/appDir/SettingsHeader\";\n import { PrismaAttributeRepository } from \"@calcom/lib/server/repository/PrismaAttributeRepository\";\n import { prisma } from \"@calcom/prisma\";\n+import { MembershipRole } from \"@calcom/prisma/enums\";\n import { viewerTeamsRouter } from \"@calcom/trpc/server/routers/viewer/teams/_router\";\n \n import { buildLegacyRequest } from \"@lib/buildLegacyCtx\";\n@@ -31,7 +33,7 @@ const getCachedTeamRoles = unstable_cache(\n     try {\n       const roleManager = await RoleManagementFactory.getInstance().createRoleManager(organizationId);\n       return await roleManager.getTeamRoles(teamId);\n-    } catch {\n+    } catch (error) {\n       // PBAC not enabled or error occurred, return empty array\n       return [];\n     }\n@@ -47,7 +49,7 @@ const getCachedTeamAttributes = unstable_cache(\n \n     try {\n       return await attributeRepo.findAllByOrgIdWithOptions({ orgId: organizationId });\n-    } catch {\n+    } catch (error) {\n       return [];\n     }\n   },\n@@ -77,15 +79,65 @@ const Page = async ({ params }: { params: Promise<{ id: string }> }) => {\n   const organizationId = team.parentId || teamId;\n \n   // Load PBAC roles and attributes if available\n-  const [roles, attributes, memberPermissions] = await Promise.all([\n+  const [roles, attributes] = await Promise.all([\n     getCachedTeamRoles(teamId, organizationId),\n     getCachedTeamAttributes(organizationId),\n-    getTeamMemberPermissions({\n-      userId: session.user.id,\n-      team,\n-    }),\n   ]);\n \n+  const fallbackRolesCanListMembers: MembershipRole[] = [MembershipRole.ADMIN, MembershipRole.OWNER];\n+\n+  // If the team is not private we allow members to list other members\n+  if (!team.isPrivate) {\n+    fallbackRolesCanListMembers.push(MembershipRole.MEMBER);\n+  }\n+\n+  // Get specific PBAC permissions for team member actions\n+  const permissions = await getSpecificPermissions({\n+    userId: session.user.id,\n+    teamId: teamId,\n+    resource: Resource.Team,\n+    userRole: team.membership.role,\n+    actions: [\n+      CustomAction.Invite,\n+      CustomAction.ChangeMemberRole,\n+      CustomAction.Remove,\n+      CustomAction.ListMembers,\n+      CustomAction.ListMembersPrivate,\n+      CustomAction.Impersonate,\n+    ],\n+    fallbackRoles: {\n+      [CustomAction.Invite]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.ChangeMemberRole]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.Remove]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.ListMembers]: {\n+        roles: fallbackRolesCanListMembers,\n+      },\n+      [CustomAction.Impersonate]: {\n+        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n+      },\n+      [CustomAction.ListMembersPrivate]: {\n+        roles: fallbackRolesCanListMembers,\n+      },\n+    },\n+  });\n+\n+  // Map specific permissions to member actions\n+  const memberPermissions = {\n+    canListMembers: team.isPrivate\n+      ? permissions[CustomAction.ListMembersPrivate]\n+      : permissions[CustomAction.ListMembers],\n+    canInvite: permissions[CustomAction.Invite],\n+    canChangeMemberRole: permissions[CustomAction.ChangeMemberRole],\n+    canRemove: permissions[CustomAction.Remove],\n+    canImpersonate: permissions[CustomAction.Impersonate],\n+  };\n+\n   const facetedTeamValues = {\n     roles,\n     teams: [team],\n@@ -110,4 +162,4 @@ const Page = async ({ params }: { params: Promise<{ id: string }> }) => {\n   );\n };\n \n-export default Page;\n+export default Page;\n\\ No newline at end of file\ndiff --git a/packages/features/ee/teams/components/EditMemberSheet.test.tsx b/packages/features/ee/teams/components/EditMemberSheet.test.tsx\ndeleted file mode 100644\nindex 77f8e48..0000000\n--- a/packages/features/ee/teams/components/EditMemberSheet.test.tsx\n+++ /dev/null\n@@ -1,327 +0,0 @@\n-import { render } from \"@testing-library/react\";\n-import React, { type ReactNode } from \"react\";\n-import { vi } from \"vitest\";\n-\n-import type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\n-import { MembershipRole } from \"@calcom/prisma/enums\";\n-\n-import { EditMemberSheet } from \"./EditMemberSheet\";\n-import type { State, User } from \"./MemberList\";\n-\n-// Mock dependencies\n-vi.mock(\"@calcom/lib/hooks/useLocale\", () => ({\n-  useLocale: () => ({\n-    t: (key: string) => key,\n-  }),\n-}));\n-\n-vi.mock(\"@calcom/trpc/react\", () => ({\n-  trpc: {\n-    viewer: {\n-      pbac: {\n-        getTeamRoles: {\n-          useQuery: () => ({\n-            data: undefined,\n-            isPending: false,\n-          }),\n-        },\n-      },\n-      teams: {\n-        getUserConnectedApps: {\n-          useQuery: () => ({\n-            data: {},\n-            isPending: false,\n-          }),\n-        },\n-        changeMemberRole: {\n-          useMutation: () => ({\n-            mutate: vi.fn(),\n-            mutateAsync: vi.fn(),\n-          }),\n-        },\n-        listMembers: {\n-          cancel: vi.fn(),\n-          getInfiniteData: vi.fn(),\n-          invalidate: vi.fn(),\n-        },\n-        get: {\n-          setData: vi.fn(),\n-          invalidate: vi.fn(),\n-        },\n-      },\n-    },\n-    useUtils: () => ({\n-      viewer: {\n-        teams: {\n-          listMembers: {\n-            cancel: vi.fn(),\n-            getInfiniteData: vi.fn(),\n-            invalidate: vi.fn(),\n-          },\n-          get: {\n-            setData: vi.fn(),\n-            invalidate: vi.fn(),\n-          },\n-        },\n-      },\n-    }),\n-  },\n-}));\n-\n-const mockSetEditMode = vi.fn();\n-const mockSetMutationLoading = vi.fn();\n-\n-vi.mock(\"@calcom/features/users/components/UserTable/EditSheet/store\", () => ({\n-  useEditMode: vi.fn((selector) => {\n-    const state = {\n-      editMode: false,\n-      setEditMode: mockSetEditMode,\n-      mutationLoading: false,\n-      setMutationLoading: mockSetMutationLoading,\n-    };\n-    if (typeof selector === \"function\") {\n-      return selector(state);\n-    }\n-    return state;\n-  }),\n-}));\n-\n-// Mock SheetFooterControls to verify props\n-let capturedProps: { canChangeMemberRole?: boolean; canEditAttributesForUser?: boolean }[] = [];\n-vi.mock(\"@calcom/features/users/components/UserTable/EditSheet/SheetFooterControls\", () => ({\n-  SheetFooterControls: (props: { canChangeMemberRole?: boolean; canEditAttributesForUser?: boolean }) => {\n-    capturedProps.push(props);\n-    return React.createElement(\"div\", { \"data-testid\": \"sheet-footer-controls\" }, \"SheetFooterControls\");\n-  },\n-}));\n-\n-// Mock other UI components\n-vi.mock(\"@calcom/ui/components/sheet\", () => ({\n-  Sheet: ({ children }: { children: ReactNode }) =>\n-    React.createElement(\"div\", { \"data-testid\": \"sheet\" }, children),\n-  SheetContent: ({ children }: { children: ReactNode }) =>\n-    React.createElement(\"div\", { \"data-testid\": \"sheet-content\" }, children),\n-  SheetHeader: ({ children }: { children: ReactNode }) =>\n-    React.createElement(\"div\", { \"data-testid\": \"sheet-header\" }, children),\n-  SheetBody: ({ children }: { children: ReactNode }) =>\n-    React.createElement(\"div\", { \"data-testid\": \"sheet-body\" }, children),\n-  SheetFooter: ({ children }: { children: ReactNode }) =>\n-    React.createElement(\"div\", { \"data-testid\": \"sheet-footer\" }, children),\n-}));\n-\n-vi.mock(\"@calcom/ui/components/form\", () => ({\n-  Form: ({ children }: { children: ReactNode }) => React.createElement(\"form\", null, children),\n-  ToggleGroup: () => React.createElement(\"div\", { \"data-testid\": \"toggle-group\" }, \"ToggleGroup\"),\n-  Select: () => React.createElement(\"div\", { \"data-testid\": \"select\" }, \"Select\"),\n-}));\n-\n-vi.mock(\"@calcom/ui/components/avatar\", () => ({\n-  Avatar: () => React.createElement(\"div\", { \"data-testid\": \"avatar\" }, \"Avatar\"),\n-}));\n-\n-vi.mock(\"@calcom/ui/components/skeleton\", () => ({\n-  Skeleton: ({ children }: { children: ReactNode }) => React.createElement(\"div\", null, children),\n-  Loader: () => React.createElement(\"div\", { \"data-testid\": \"loader\" }, \"Loading...\"),\n-}));\n-\n-vi.mock(\"@calcom/features/users/components/UserTable/EditSheet/DisplayInfo\", () => ({\n-  DisplayInfo: () => <div data-testid=\"display-info\">DisplayInfo</div>,\n-}));\n-\n-describe(\"EditMemberSheet\", () => {\n-  const mockDispatch = vi.fn();\n-\n-  // Create a minimal mock user that satisfies the User type\n-  const mockUser = {\n-    id: 1,\n-    name: \"Test User\",\n-    email: \"test@example.com\",\n-    username: \"testuser\",\n-    role: MembershipRole.MEMBER,\n-    accepted: true,\n-    avatarUrl: \"\",\n-    bookerUrl: \"https://cal.com\",\n-    lastActiveAt: \"2024-01-01\",\n-    customRoleId: null,\n-  } as User;\n-\n-  const mockState: State = {\n-    editSheet: {\n-      user: mockUser,\n-      showModal: true,\n-    },\n-    deleteMember: {\n-      showModal: false,\n-    },\n-    impersonateMember: {\n-      showModal: false,\n-    },\n-    teamAvailability: {\n-      showModal: false,\n-    },\n-  };\n-\n-  beforeEach(() => {\n-    vi.clearAllMocks();\n-    mockSetEditMode.mockClear();\n-    mockSetMutationLoading.mockClear();\n-    capturedProps = [];\n-  });\n-\n-  describe(\"Fix verification: canChangeMemberRole prop passing\", () => {\n-    it(\"should pass canChangeMemberRole=true to SheetFooterControls when permissions.canChangeMemberRole is true\", () => {\n-      const permissions: MemberPermissions = {\n-        canListMembers: false,\n-        canInvite: false,\n-        canChangeMemberRole: true,\n-        canRemove: false,\n-        canImpersonate: false,\n-      };\n-\n-      render(\n-        <EditMemberSheet\n-          state={mockState}\n-          dispatch={mockDispatch}\n-          currentMember={MembershipRole.OWNER}\n-          teamId={1}\n-          permissions={permissions}\n-        />\n-      );\n-\n-      // Verify SheetFooterControls was called with canChangeMemberRole=true\n-      expect(capturedProps).toContainEqual(\n-        expect.objectContaining({\n-          canChangeMemberRole: true,\n-        })\n-      );\n-    });\n-\n-    it(\"should pass canChangeMemberRole=false to SheetFooterControls when permissions.canChangeMemberRole is false\", () => {\n-      const permissions: MemberPermissions = {\n-        canListMembers: false,\n-        canInvite: false,\n-        canChangeMemberRole: false,\n-        canRemove: false,\n-        canImpersonate: false,\n-      };\n-\n-      render(\n-        <EditMemberSheet\n-          state={mockState}\n-          dispatch={mockDispatch}\n-          currentMember={MembershipRole.OWNER}\n-          teamId={1}\n-          permissions={permissions}\n-        />\n-      );\n-\n-      // Verify SheetFooterControls was called with canChangeMemberRole=false\n-      expect(capturedProps).toContainEqual(\n-        expect.objectContaining({\n-          canChangeMemberRole: false,\n-        })\n-      );\n-    });\n-\n-    it(\"should pass canChangeMemberRole=undefined to SheetFooterControls when permissions is undefined\", () => {\n-      render(\n-        <EditMemberSheet\n-          state={mockState}\n-          dispatch={mockDispatch}\n-          currentMember={MembershipRole.OWNER}\n-          teamId={1}\n-          permissions={undefined}\n-        />\n-      );\n-\n-      // Verify SheetFooterControls was called with canChangeMemberRole=undefined\n-      expect(capturedProps).toContainEqual(\n-        expect.objectContaining({\n-          canChangeMemberRole: undefined,\n-        })\n-      );\n-    });\n-\n-    it(\"should pass canChangeMemberRole=undefined to SheetFooterControls when permissions object exists but canChangeMemberRole is undefined\", () => {\n-      const permissions: Partial<MemberPermissions> = {\n-        canListMembers: true,\n-        canInvite: false,\n-        // canChangeMemberRole is intentionally omitted\n-      };\n-\n-      render(\n-        <EditMemberSheet\n-          state={mockState}\n-          dispatch={mockDispatch}\n-          currentMember={MembershipRole.OWNER}\n-          teamId={1}\n-          permissions={permissions as MemberPermissions}\n-        />\n-      );\n-\n-      // Verify SheetFooterControls was called with canChangeMemberRole=undefined\n-      expect(capturedProps).toContainEqual(\n-        expect.objectContaining({\n-          canChangeMemberRole: undefined,\n-        })\n-      );\n-    });\n-\n-    it(\"should pass canEditAttributesForUser from permissions to SheetFooterControls\", () => {\n-      const permissions: MemberPermissions = {\n-        canListMembers: false,\n-        canInvite: false,\n-        canChangeMemberRole: true,\n-        canRemove: false,\n-        canImpersonate: false,\n-        canEditAttributesForUser: true,\n-      };\n-\n-      render(\n-        <EditMemberSheet\n-          state={mockState}\n-          dispatch={mockDispatch}\n-          currentMember={MembershipRole.OWNER}\n-          teamId={1}\n-          permissions={permissions}\n-        />\n-      );\n-\n-      // Verify SheetFooterControls was called with both props\n-      expect(capturedProps).toContainEqual(\n-        expect.objectContaining({\n-          canChangeMemberRole: true,\n-          canEditAttributesForUser: true,\n-        })\n-      );\n-    });\n-\n-    it(\"should correctly extract canChangeMemberRole from permissions object (verifies fix)\", () => {\n-      // This test specifically verifies the fix where permissions?.canChangeMemberRole\n-      // is now correctly passed to SheetFooterControls\n-      const permissions: MemberPermissions = {\n-        canListMembers: false,\n-        canInvite: false,\n-        canChangeMemberRole: true, // This should be passed to SheetFooterControls\n-        canRemove: false,\n-        canImpersonate: false,\n-      };\n-\n-      render(\n-        <EditMemberSheet\n-          state={mockState}\n-          dispatch={mockDispatch}\n-          currentMember={MembershipRole.OWNER}\n-          teamId={1}\n-          permissions={permissions}\n-        />\n-      );\n-\n-      expect(capturedProps).toContainEqual(\n-        expect.objectContaining({\n-          canChangeMemberRole: true,\n-        })\n-      );\n-    });\n-  });\n-});\ndiff --git a/packages/features/ee/teams/components/EditMemberSheet.tsx b/packages/features/ee/teams/components/EditMemberSheet.tsx\nindex 8611d8d..64ed3a5 100644\n--- a/packages/features/ee/teams/components/EditMemberSheet.tsx\n+++ b/packages/features/ee/teams/components/EditMemberSheet.tsx\n@@ -8,7 +8,6 @@ import { shallow } from \"zustand/shallow\";\n import { DisplayInfo } from \"@calcom/features/users/components/UserTable/EditSheet/DisplayInfo\";\n import { SheetFooterControls } from \"@calcom/features/users/components/UserTable/EditSheet/SheetFooterControls\";\n import { useEditMode } from \"@calcom/features/users/components/UserTable/EditSheet/store\";\n-import type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\n import { useLocale } from \"@calcom/lib/hooks/useLocale\";\n import { MembershipRole } from \"@calcom/prisma/enums\";\n import { trpc } from \"@calcom/trpc/react\";\n@@ -35,13 +34,11 @@ export function EditMemberSheet({\n   dispatch,\n   currentMember,\n   teamId,\n-  permissions,\n }: {\n   state: State;\n   dispatch: Dispatch<Action>;\n   currentMember: MembershipRole;\n   teamId: number;\n-  permissions?: MemberPermissions;\n }) {\n   const { t } = useLocale();\n   const { user } = state.editSheet;\n@@ -280,10 +277,7 @@ export function EditMemberSheet({\n               </div>\n             </SheetBody>\n             <SheetFooter className=\"mt-auto\">\n-              <SheetFooterControls\n-                canChangeMemberRole={permissions?.canChangeMemberRole}\n-                canEditAttributesForUser={permissions?.canEditAttributesForUser}\n-              />\n+              <SheetFooterControls />\n             </SheetFooter>\n           </Form>\n         ) : (\n@@ -292,4 +286,4 @@ export function EditMemberSheet({\n       </SheetContent>\n     </Sheet>\n   );\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/features/ee/teams/components/MemberList.tsx b/packages/features/ee/teams/components/MemberList.tsx\nindex ff1ee16..5e25e5d 100644\n--- a/packages/features/ee/teams/components/MemberList.tsx\n+++ b/packages/features/ee/teams/components/MemberList.tsx\n@@ -446,393 +446,4 @@ function MemberListContent(props: Props) {\n             process.env.NEXT_PUBLIC_TEAM_IMPERSONATION === \"true\";\n           return (\n             <>\n-              {props.team.membership?.accepted && (\n-                <div className=\"flex items-center justify-end\">\n-                  <ButtonGroup combined containerProps={{ className: \"border-default hidden md:flex\" }}>\n-                    {/* TODO: bring availability back. right now its ugly and broken\n-                    <Tooltip\n-                      content={\n-                        user.accepted\n-                          ? t(\"team_view_user_availability\")\n-                          : t(\"team_view_user_availability_disabled\")\n-                      }>\n-                      <Button\n-                        disabled={!user.accepted}\n-                        onClick={() =>\n-                          user.accepted\n-                            ? dispatch({\n-                                type: \"TEAM_AVAILABILITY\",\n-                                payload: {\n-                                  user,\n-                                  showModal: true,\n-                                },\n-                              })\n-                            : null\n-                        }\n-                        color=\"secondary\"\n-                        variant=\"icon\"\n-                        StartIcon=\"clock\"\n-                      />\n-                    </Tooltip> */}\n-                    {!!user.accepted && (\n-                      <Tooltip content={t(\"view_public_page\")}>\n-                        <Button\n-                          target=\"_blank\"\n-                          href={`${user.bookerUrl}/${user.username}`}\n-                          color=\"secondary\"\n-                          className={classNames(!editMode ? \"rounded-r-md\" : \"\")}\n-                          variant=\"icon\"\n-                          StartIcon=\"external-link\"\n-                          disabled={!user.accepted}\n-                        />\n-                      </Tooltip>\n-                    )}\n-                    {editMode && (\n-                      <Dropdown>\n-                        <DropdownMenuTrigger asChild>\n-                          <Button\n-                            className=\"ltr:radix-state-open:rounded-r-(--btn-group-radius) rtl:radix-state-open:rounded-l-(--btn-group-radius)\"\n-                            color=\"secondary\"\n-                            variant=\"icon\"\n-                            StartIcon=\"ellipsis\"\n-                          />\n-                        </DropdownMenuTrigger>\n-                        <DropdownMenuPortal>\n-                          <DropdownMenuContent>\n-                            {canChangeRole ? (\n-                              <DropdownMenuItem>\n-                                <DropdownItem\n-                                  type=\"button\"\n-                                  onClick={() =>\n-                                    dispatch({\n-                                      type: \"EDIT_USER_SHEET\",\n-                                      payload: {\n-                                        user,\n-                                        showModal: true,\n-                                      },\n-                                    })\n-                                  }\n-                                  StartIcon=\"pencil\">\n-                                  {t(\"edit\")}\n-                                </DropdownItem>\n-                              </DropdownMenuItem>\n-                            ) : null}\n-                            {impersonationMode && (\n-                              <>\n-                                <DropdownMenuItem>\n-                                  <DropdownItem\n-                                    type=\"button\"\n-                                    onClick={() =>\n-                                      dispatch({\n-                                        type: \"SET_IMPERSONATE_ID\",\n-                                        payload: {\n-                                          user,\n-                                          showModal: true,\n-                                        },\n-                                      })\n-                                    }\n-                                    StartIcon=\"lock\">\n-                                    {t(\"impersonate\")}\n-                                  </DropdownItem>\n-                                </DropdownMenuItem>\n-                                <DropdownMenuSeparator />\n-                              </>\n-                            )}\n-                            {canResendInvitation && (\n-                              <DropdownMenuItem>\n-                                <DropdownItem\n-                                  type=\"button\"\n-                                  onClick={() => {\n-                                    resendInvitationMutation.mutate({\n-                                      teamId: props.team?.id,\n-                                      email: user.email,\n-                                      language: i18n.language,\n-                                    });\n-                                  }}\n-                                  StartIcon=\"send\">\n-                                  {t(\"resend_invitation\")}\n-                                </DropdownItem>\n-                              </DropdownMenuItem>\n-                            )}\n-                            {canRemove ? (\n-                              <DropdownMenuItem>\n-                                <DropdownItem\n-                                  type=\"button\"\n-                                  onClick={() =>\n-                                    dispatch({\n-                                      type: \"SET_DELETE_ID\",\n-                                      payload: {\n-                                        user,\n-                                        showModal: true,\n-                                      },\n-                                    })\n-                                  }\n-                                  color=\"destructive\"\n-                                  StartIcon=\"user-x\">\n-                                  {t(\"remove\")}\n-                                </DropdownItem>\n-                              </DropdownMenuItem>\n-                            ) : null}\n-                          </DropdownMenuContent>\n-                        </DropdownMenuPortal>\n-                      </Dropdown>\n-                    )}\n-                  </ButtonGroup>\n-                  <div className=\"flex md:hidden\">\n-                    <Dropdown>\n-                      <DropdownMenuTrigger asChild>\n-                        <Button type=\"button\" variant=\"icon\" color=\"minimal\" StartIcon=\"ellipsis\" />\n-                      </DropdownMenuTrigger>\n-                      <DropdownMenuPortal>\n-                        <DropdownMenuContent>\n-                          <DropdownMenuItem className=\"outline-none\">\n-                            <DropdownItem\n-                              disabled={!user.accepted}\n-                              href={!user.accepted ? undefined : `/${user.username}`}\n-                              target=\"_blank\"\n-                              type=\"button\"\n-                              StartIcon=\"external-link\">\n-                              {t(\"view_public_page\")}\n-                            </DropdownItem>\n-                          </DropdownMenuItem>\n-                          {editMode && (\n-                            <>\n-                              <DropdownMenuItem>\n-                                <DropdownItem\n-                                  type=\"button\"\n-                                  onClick={() =>\n-                                    dispatch({\n-                                      type: \"EDIT_USER_SHEET\",\n-                                      payload: {\n-                                        user,\n-                                        showModal: true,\n-                                      },\n-                                    })\n-                                  }\n-                                  StartIcon=\"pencil\">\n-                                  {t(\"edit\")}\n-                                </DropdownItem>\n-                              </DropdownMenuItem>\n-                              <DropdownMenuItem>\n-                                <DropdownItem\n-                                  type=\"button\"\n-                                  color=\"destructive\"\n-                                  onClick={() =>\n-                                    dispatch({\n-                                      type: \"SET_DELETE_ID\",\n-                                      payload: {\n-                                        user,\n-                                        showModal: true,\n-                                      },\n-                                    })\n-                                  }\n-                                  StartIcon=\"user-x\">\n-                                  {t(\"remove\")}\n-                                </DropdownItem>\n-                              </DropdownMenuItem>\n-                            </>\n-                          )}\n-                        </DropdownMenuContent>\n-                      </DropdownMenuPortal>\n-                    </Dropdown>\n-                  </div>\n-                </div>\n-              )}\n-            </>\n-          );\n-        },\n-      },\n-    ];\n-\n-    return cols;\n-  }, [props.isOrgAdminOrOwner, dispatch, totalRowCount, session?.user.id]);\n-  //we must flatten the array of arrays from the useInfiniteQuery hook\n-  const flatData = useMemo(() => data?.pages?.flatMap((page) => page.members) ?? [], [data]) as User[];\n-\n-  const table = useReactTable({\n-    data: flatData,\n-    columns: memorisedColumns,\n-    enableRowSelection: true,\n-    debugTable: true,\n-    manualPagination: true,\n-    initialState: {\n-      columnVisibility: initalColumnVisibility,\n-      columnPinning: {\n-        right: [\"actions\"],\n-      },\n-    },\n-    state: {\n-      columnFilters,\n-      rowSelection,\n-    },\n-    onRowSelectionChange: setRowSelection,\n-    getCoreRowModel: getCoreRowModel(),\n-    getFilteredRowModel: getFilteredRowModel(),\n-    getSortedRowModel: getSortedRowModel(),\n-    getFacetedUniqueValues: (_, columnId) => () => {\n-      if (facetedTeamValues) {\n-        switch (columnId) {\n-          case \"role\": {\n-            // Include both traditional roles and PBAC custom roles\n-            const allRoles = facetedTeamValues.roles.map((role) => ({\n-              label: role.name,\n-              value: role.id,\n-            }));\n-\n-            return convertFacetedValuesToMap(allRoles);\n-          }\n-          default:\n-            return new Map();\n-        }\n-      }\n-      return new Map();\n-    },\n-    getRowId: (row) => `${row.id}`,\n-  });\n-\n-  useFetchMoreOnBottomReached({\n-    tableContainerRef,\n-    hasNextPage,\n-    fetchNextPage,\n-    isFetching,\n-  });\n-\n-  const numberOfSelectedRows = table.getSelectedRowModel().rows.length;\n-\n-  return (\n-    <>\n-      <DataTableWrapper\n-        testId=\"team-member-list-container\"\n-        table={table}\n-        tableContainerRef={tableContainerRef}\n-        isPending={isPending}\n-        enableColumnResizing={true}\n-        paginationMode=\"infinite\"\n-        hasNextPage={hasNextPage}\n-        fetchNextPage={fetchNextPage}\n-        isFetching={isFetching}\n-        totalRowCount={totalRowCount}\n-        ToolbarLeft={\n-          <>\n-            <DataTableToolbar.SearchBar />\n-            <DataTableFilters.ColumnVisibilityButton table={table} />\n-            <DataTableFilters.FilterBar table={table} />\n-          </>\n-        }\n-        ToolbarRight={\n-          <>\n-            <DataTableFilters.ClearFiltersButton />\n-            {props.permissions.canInvite && (\n-              <DataTableToolbar.CTA\n-                type=\"button\"\n-                color=\"primary\"\n-                StartIcon=\"plus\"\n-                onClick={() => { props.setShowMemberInvitationModal(true); posthog.capture(\"teams_add_new_members_button_clicked\") }}\n-                data-testid=\"new-member-button\">\n-                {t(\"add\")}\n-              </DataTableToolbar.CTA>\n-            )}\n-          </>\n-        }>\n-        {numberOfSelectedRows >= 2 && dynamicLinkVisible && (\n-          <DataTableSelectionBar.Root className=\"bottom-[7.3rem]! md:bottom-32!\">\n-            <DynamicLink table={table} domain={domain} />\n-          </DataTableSelectionBar.Root>\n-        )}\n-        {numberOfSelectedRows > 0 && (\n-          <DataTableSelectionBar.Root className=\"bottom-16! justify-center md:w-max\">\n-            <p className=\"text-brand-subtle px-2 text-center text-xs leading-none sm:text-sm sm:font-medium\">\n-              {t(\"number_selected\", { count: numberOfSelectedRows })}\n-            </p>\n-            {numberOfSelectedRows >= 2 && (\n-              <DataTableSelectionBar.Button\n-                color=\"secondary\"\n-                onClick={() => setDynamicLinkVisible(!dynamicLinkVisible)}\n-                icon=\"handshake\">\n-                {t(\"group_meeting\")}\n-              </DataTableSelectionBar.Button>\n-            )}\n-            <EventTypesList table={table} teamId={props.team.id} />\n-            <DeleteBulkTeamMembers\n-              users={table.getSelectedRowModel().flatRows.map((row) => row.original)}\n-              onRemove={() => table.toggleAllPageRowsSelected(false)}\n-              isOrg={checkIsOrg(props.team)}\n-              teamId={props.team.id}\n-            />\n-          </DataTableSelectionBar.Root>\n-        )}\n-      </DataTableWrapper>\n-      {state.deleteMember.showModal && (\n-        <Dialog\n-          open={true}\n-          onOpenChange={(open) =>\n-            !open &&\n-            dispatch({\n-              type: \"CLOSE_MODAL\",\n-            })\n-          }>\n-          <ConfirmationDialogContent\n-            variety=\"danger\"\n-            title={t(\"remove_member\")}\n-            confirmBtnText={t(\"confirm_remove_member\")}\n-            onConfirm={removeMember}>\n-            {t(\"remove_member_confirmation_message\")}\n-          </ConfirmationDialogContent>\n-        </Dialog>\n-      )}\n-\n-      {state.impersonateMember.showModal && state.impersonateMember.user?.username && (\n-        <Dialog\n-          open={true}\n-          onOpenChange={() =>\n-            dispatch({\n-              type: \"CLOSE_MODAL\",\n-            })\n-          }>\n-          <DialogContent type=\"creation\" title={t(\"impersonate\")} description={t(\"impersonation_user_tip\")}>\n-            <form\n-              onSubmit={async (e) => {\n-                e.preventDefault();\n-                await signIn(\"impersonation-auth\", {\n-                  username: state.impersonateMember.user?.email,\n-                  teamId: props.team.id,\n-                });\n-                dispatch({\n-                  type: \"CLOSE_MODAL\",\n-                });\n-              }}>\n-              <DialogFooter showDivider className=\"mt-8\">\n-                <DialogClose color=\"secondary\">{t(\"cancel\")}</DialogClose>\n-                <Button color=\"primary\" type=\"submit\">\n-                  {t(\"impersonate\")}\n-                </Button>\n-              </DialogFooter>\n-            </form>\n-          </DialogContent>\n-        </Dialog>\n-      )}\n-      {state.teamAvailability.showModal && (\n-        <Dialog\n-          open={true}\n-          onOpenChange={() => {\n-            dispatch({\n-              type: \"CLOSE_MODAL\",\n-            });\n-          }}>\n-          <DialogContent type=\"creation\" size=\"md\">\n-            <TeamAvailabilityModal team={props.team} member={state.teamAvailability.user} />\n-          </DialogContent>\n-        </Dialog>\n-      )}\n-      {state.editSheet.showModal && (\n-        <EditMemberSheet\n-          dispatch={dispatch}\n-          state={state}\n-          currentMember={props.team.membership.role}\n-          teamId={props.team.id}\n-          permissions={props.permissions}\n-        />\n-      )}\n-    </>\n-  );\n-}\n+              {props.team.membership?.accepted &&\n\\ No newline at end of file\ndiff --git a/packages/features/pbac/lib/team-member-permissions.ts b/packages/features/pbac/lib/team-member-permissions.ts\ndeleted file mode 100644\nindex ad27cdf..0000000\n--- a/packages/features/pbac/lib/team-member-permissions.ts\n+++ /dev/null\n@@ -1,80 +0,0 @@\n-import type { MemberPermissions } from \"@calcom/features/users/components/UserTable/types\";\n-import { MembershipRole } from \"@calcom/prisma/enums\";\n-\n-import { Resource, CustomAction } from \"../domain/types/permission-registry\";\n-import { getSpecificPermissions } from \"./resource-permissions\";\n-\n-interface TeamWithMembership {\n-  id: number;\n-  isPrivate: boolean;\n-  membership: {\n-    role: MembershipRole;\n-    accepted: boolean;\n-  };\n-}\n-\n-interface GetTeamMemberPermissionsOptions {\n-  userId: number;\n-  team: TeamWithMembership;\n-}\n-\n-/**\n- * Gets team member permissions using PBAC or fallback to role-based permissions.\n- */\n-export async function getTeamMemberPermissions({\n-  userId,\n-  team,\n-}: GetTeamMemberPermissionsOptions): Promise<MemberPermissions> {\n-  // Determine fallback roles for ListMembers based on team privacy\n-  const fallbackRolesCanListMembers: MembershipRole[] = [MembershipRole.ADMIN, MembershipRole.OWNER];\n-  if (!team.isPrivate) {\n-    fallbackRolesCanListMembers.push(MembershipRole.MEMBER);\n-  }\n-\n-  // Get specific PBAC permissions for team member actions\n-  const permissions = await getSpecificPermissions({\n-    userId,\n-    teamId: team.id,\n-    resource: Resource.Team,\n-    userRole: team.membership.role,\n-    actions: [\n-      CustomAction.Invite,\n-      CustomAction.ChangeMemberRole,\n-      CustomAction.Remove,\n-      CustomAction.ListMembers,\n-      CustomAction.ListMembersPrivate,\n-      CustomAction.Impersonate,\n-    ],\n-    fallbackRoles: {\n-      [CustomAction.Invite]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.ChangeMemberRole]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.Remove]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.ListMembers]: {\n-        roles: fallbackRolesCanListMembers,\n-      },\n-      [CustomAction.Impersonate]: {\n-        roles: [MembershipRole.ADMIN, MembershipRole.OWNER],\n-      },\n-      [CustomAction.ListMembersPrivate]: {\n-        roles: fallbackRolesCanListMembers,\n-      },\n-    },\n-  });\n-\n-  // Map specific permissions to member actions\n-  return {\n-    canListMembers: team.isPrivate\n-      ? permissions[CustomAction.ListMembersPrivate]\n-      : permissions[CustomAction.ListMembers],\n-    canInvite: permissions[CustomAction.Invite],\n-    canChangeMemberRole: permissions[CustomAction.ChangeMemberRole],\n-    canRemove: permissions[CustomAction.Remove],\n-    canImpersonate: permissions[CustomAction.Impersonate],\n-  };\n-}\n",
    "pr_number": 25587,
    "title": "fix: unable to edit member as a team owner/admin",
    "test_files": [
      "packages/features/ee/teams/components/EditMemberSheet.test.tsx"
    ],
    "code_files": [
      "apps/web/app/(use-page-wrapper)/settings/(settings-layout)/teams/[id]/members/page.tsx",
      "packages/features/ee/teams/components/EditMemberSheet.tsx",
      "packages/features/ee/teams/components/MemberList.tsx",
      "packages/features/pbac/lib/team-member-permissions.ts"
    ]
  },
  {
    "instance_id": "calcom__cal.com.main.25499",
    "repo": "calcom/cal.com",
    "base_commit": "d00cf329e80ec9d1bb5e1a7587bfb2d31d4339b7",
    "bug_patch": "diff --git a/apps/web/components/apps/routing-forms/TestFormDialog.test.tsx b/apps/web/components/apps/routing-forms/TestFormDialog.test.tsx\nindex be21fbd..0405af6 100644\n--- a/apps/web/components/apps/routing-forms/TestFormDialog.test.tsx\n+++ b/apps/web/components/apps/routing-forms/TestFormDialog.test.tsx\n@@ -452,8 +452,7 @@ describe(\"TestFormDialog\", () => {\n       fireEvent.click(screen.getByText(\"submit\"));\n \n       // Verify the URL shows the substituted value, not the variable\n-      expect(screen.getByTestId(\"test-routing-result\")).toHaveTextContent(\"/team/Sales%20Team/meeting\");\n-      expect(screen.getByTestId(\"test-routing-result\")).not.toHaveTextContent(\"/team/sales-team/meeting\");\n+      expect(screen.getByTestId(\"test-routing-result\")).toHaveTextContent(\"/team/sales-team/meeting\");\n       expect(screen.getByTestId(\"test-routing-result\")).not.toHaveTextContent(\"{name}\");\n     });\n \n@@ -462,27 +461,4 @@ describe(\"TestFormDialog\", () => {\n       mockMatchingRoute({\n         action: {\n           type: \"externalRedirectUrl\",\n-          value: \"https://example.com/user/{name}\",\n-        },\n-      });\n-\n-      render(\n-        <TestFormRenderer\n-          isMobile={true}\n-          testForm={mockRegularTeamForm}\n-          isTestPreviewOpen={true}\n-          setIsTestPreviewOpen={() => {\n-            return;\n-          }}\n-        />\n-      );\n-\n-      fireEvent.change(screen.getByTestId(\"form-field-name\"), { target: { value: \"John Doe\" } });\n-      fireEvent.click(screen.getByText(\"submit\"));\n-\n-      // Verify the URL shows the variable as-is, without substitution\n-      expect(screen.getByTestId(\"test-routing-result\")).toHaveTextContent(\"https://example.com/user/{name}\");\n-      expect(screen.getByTestId(\"test-routing-result\")).not.toHaveTextContent(\"john-doe\");\n-    });\n-  });\n-});\n+          value: \"\n\\ No newline at end of file\ndiff --git a/packages/app-store/routing-forms/__tests__/getEventTypeRedirectUrl.test.ts b/packages/app-store/routing-forms/__tests__/getEventTypeRedirectUrl.test.ts\nindex 7d62794..ee6fc26 100644\n--- a/packages/app-store/routing-forms/__tests__/getEventTypeRedirectUrl.test.ts\n+++ b/packages/app-store/routing-forms/__tests__/getEventTypeRedirectUrl.test.ts\n@@ -91,49 +91,4 @@ describe(\"getAbsoluteEventTypeRedirectUrl\", () => {\n       })\n     ).toThrow(\"eventTypeRedirectUrl must have username or teamSlug\");\n   });\n-\n-  it(\"should use '&' separator when redirect URL already contains query parameters\", () => {\n-    const result = getAbsoluteEventTypeRedirectUrl({\n-      ...defaultParams,\n-      eventTypeRedirectUrl: \"user/event?existing=param\",\n-      allURLSearchParams: new URLSearchParams(\"foo=bar\"),\n-    });\n-    expect(result).toBe(\"https://user.cal.com/user/event?existing=param&foo=bar\");\n-  });\n-\n-  it(\"should merge with '&' when redirect URL already contains multiple query parameters\", () => {\n-    const result = getAbsoluteEventTypeRedirectUrl({\n-      ...defaultParams,\n-      eventTypeRedirectUrl: \"user/event?existing1=param1&existing2=param2\",\n-      allURLSearchParams: new URLSearchParams(\"foo=bar\"),\n-    });\n-    expect(result).toBe(\"https://user.cal.com/user/event?existing1=param1&existing2=param2&foo=bar\");\n-  });\n-\n-  it(\"should merge with '&' when no URL search params are present\", () => {\n-    const result = getAbsoluteEventTypeRedirectUrl({\n-      ...defaultParams,\n-      eventTypeRedirectUrl: \"user/event?existing=param\",\n-      allURLSearchParams: new URLSearchParams(),\n-    });\n-    expect(result).toBe(\"https://user.cal.com/user/event?existing=param&\");\n-  });\n-\n-  it(\"should merge when redirect URL ends with '/'\", () => {\n-    const result = getAbsoluteEventTypeRedirectUrl({\n-      ...defaultParams,\n-      eventTypeRedirectUrl: \"user/event/\",\n-      allURLSearchParams: new URLSearchParams(\"foo=bar\"),\n-    });\n-    expect(result).toBe(\"https://user.cal.com/user/event/?foo=bar\");\n-  });\n-\n-  it(\"should be able to merge when redirect URL ends with '?'\", () => {\n-    const result = getAbsoluteEventTypeRedirectUrl({\n-      ...defaultParams,\n-      eventTypeRedirectUrl: \"user/event?\",\n-      allURLSearchParams: new URLSearchParams(\"foo=bar\"),\n-    });\n-    expect(result).toBe(\"https://user.cal.com/user/event?&foo=bar\");\n-  });\n-});\n+});\n\\ No newline at end of file\ndiff --git a/packages/app-store/routing-forms/getEventTypeRedirectUrl.ts b/packages/app-store/routing-forms/getEventTypeRedirectUrl.ts\nindex 69f2f17..efa33d0 100644\n--- a/packages/app-store/routing-forms/getEventTypeRedirectUrl.ts\n+++ b/packages/app-store/routing-forms/getEventTypeRedirectUrl.ts\n@@ -86,8 +86,7 @@ export function getAbsoluteEventTypeRedirectUrl({\n   if (teamSlugInRedirectUrl && form.nonOrgTeamslug) {\n     const isEventTypeRedirectToOldTeamSlug = teamSlugInRedirectUrl === form.nonOrgTeamslug;\n     if (isEventTypeRedirectToOldTeamSlug) {\n-      const joiner = eventTypeRedirectUrl.includes(\"?\") ? \"&\" : \"?\";\n-      return `${WEBAPP_URL}/${eventTypeRedirectUrl}${joiner}${allURLSearchParams}`;\n+      return `${WEBAPP_URL}/${eventTypeRedirectUrl}?${allURLSearchParams}`;\n     }\n   }\n \n@@ -96,8 +95,7 @@ export function getAbsoluteEventTypeRedirectUrl({\n     const isEventTypeRedirectToOldUser =\n       !hasSameProfileUsername && usernameInRedirectUrl === form.nonOrgUsername;\n     if (isEventTypeRedirectToOldUser) {\n-      const joiner = eventTypeRedirectUrl.includes(\"?\") ? \"&\" : \"?\";\n-      return `${WEBAPP_URL}/${eventTypeRedirectUrl}${joiner}${allURLSearchParams}`;\n+      return `${WEBAPP_URL}/${eventTypeRedirectUrl}?${allURLSearchParams}`;\n     }\n   }\n \n@@ -108,12 +106,11 @@ export function getAbsoluteEventTypeRedirectUrl({\n     ? form.teamOrigin\n     : form.userOrigin;\n \n-  const joiner = eventTypeRedirectUrl.includes(\"?\") ? \"&\" : \"?\";\n-  return `${origin}/${eventTypeRedirectUrl}${joiner}${allURLSearchParams}`;\n+  return `${origin}/${eventTypeRedirectUrl}?${allURLSearchParams}`;\n }\n \n export function getAbsoluteEventTypeRedirectUrlWithEmbedSupport(\n   args: Ensure<Parameters<typeof getAbsoluteEventTypeRedirectUrl>[0], \"isEmbed\">\n ) {\n   return getAbsoluteEventTypeRedirectUrl({ ...args });\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/app-store/routing-forms/lib/substituteVariables.test.ts b/packages/app-store/routing-forms/lib/substituteVariables.test.ts\nindex b944a65..3c4d442 100644\n--- a/packages/app-store/routing-forms/lib/substituteVariables.test.ts\n+++ b/packages/app-store/routing-forms/lib/substituteVariables.test.ts\n@@ -60,7 +60,7 @@ describe(\"substituteVariables\", () => {\n \n     const result = substituteVariables(routeValue, response, fields);\n \n-    expect(result).toBe(\"/team/Sales%20Team/meeting\");\n+    expect(result).toBe(\"/team/sales-team/meeting\");\n     expect(result).not.toBe(\"/team/sales-123/meeting\");\n     expect(result).not.toBe(\"/team/department/meeting\");\n   });\n@@ -78,10 +78,10 @@ describe(\"substituteVariables\", () => {\n \n     const result = substituteVariables(routeValue, response, fields);\n \n-    expect(result).toBe(\"/Engineering/Backend%20Team/book\");\n+    expect(result).toBe(\"/engineering/backend-team/book\");\n   });\n \n-  it(\"should handle special characters in labels by encoding them\", () => {\n+  it(\"should handle special characters in labels by slugifying them\", () => {\n     const fields = [\n       createSelectField(\"field1\", \"department\", \"Department\", [{ id: \"hr_dept\", label: \"HR & Recruitment\" }]),\n     ];\n@@ -89,7 +89,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"hr_dept\", \"Department\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/meeting/HR%20%26%20Recruitment\");\n+    expect(result).toBe(\"/meeting/hr-recruitment\");\n   });\n \n   it(\"should handle case-insensitive variable matching\", () => {\n@@ -102,7 +102,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"support-001\", \"Department\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/team/Customer%20Support/schedule\");\n+    expect(result).toBe(\"/team/customer-support/schedule\");\n   });\n \n   it(\"should not substitute variables that don't have matching fields\", () => {\n@@ -125,7 +125,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field3\", [\"high\", \"urgent\"], \"Priority Level\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/priorities/High%2CUrgent\");\n+    expect(result).toBe(\"/priorities/high-urgent\");\n   });\n \n   it(\"should handle numeric labels\", () => {\n@@ -136,7 +136,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"room-id-123\", \"Department\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/room/Room%20404\");\n+    expect(result).toBe(\"/room/room-404\");\n   });\n \n   it(\"should not modify the URL if no variables are present\", () => {\n@@ -158,7 +158,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"marketing-789\", \"Department\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/event/Marketing%20%26%20PR?type=meeting&priority=high\");\n+    expect(result).toBe(\"/event/marketing-pr?type=meeting&priority=high\");\n   });\n \n   it(\"should substitute text field values directly\", () => {\n@@ -167,7 +167,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"John Doe\", \"Username\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/user/John%20Doe/profile\");\n+    expect(result).toBe(\"/user/john-doe/profile\");\n   });\n \n   it(\"should handle number field values\", () => {\n@@ -195,7 +195,7 @@ describe(\"substituteVariables\", () => {\n     };\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/Tower%20A/floor/404/Engineering\");\n+    expect(result).toBe(\"/tower-a/floor/404/engineering\");\n   });\n \n   it(\"should handle text fields with special characters\", () => {\n@@ -204,7 +204,7 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"Cal.com Platform & API\", \"Project Name\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/project/Cal.com%20Platform%20%26%20API/board\");\n+    expect(result).toBe(\"/project/cal.com-platform-api/board\");\n   });\n \n   it(\"should handle empty text field values\", () => {\n@@ -224,6 +224,6 @@ describe(\"substituteVariables\", () => {\n     const response = createFormResponse(\"field1\", \"Bug Report Summary\", \"Description\");\n \n     const result = substituteVariables(routeValue, response, fields);\n-    expect(result).toBe(\"/ticket/Bug%20Report%20Summary\");\n+    expect(result).toBe(\"/ticket/bug-report-summary\");\n   });\n-});\n+});\n\\ No newline at end of file\ndiff --git a/packages/app-store/routing-forms/lib/substituteVariables.ts b/packages/app-store/routing-forms/lib/substituteVariables.ts\nindex 8f2857f..2755e4e 100644\n--- a/packages/app-store/routing-forms/lib/substituteVariables.ts\n+++ b/packages/app-store/routing-forms/lib/substituteVariables.ts\n@@ -1,3 +1,5 @@\n+import slugify from \"@calcom/lib/slugify\";\n+\n import type { FormResponse, NonRouterRoute, Field } from \"../types/types\";\n import getFieldIdentifier from \"./getFieldIdentifier\";\n import { getHumanReadableFieldResponseValue } from \"./responseData/getHumanReadableFieldResponseValue\";\n@@ -16,7 +18,7 @@ export const substituteVariables = (\n   response: FormResponse,\n   fields: Field[]\n ) => {\n-  const regex = /\\{([^}]+)\\}/g;\n+  const regex = /\\{([^\\}]+)\\}/g;\n   const variables: string[] = routeValue.match(regex)?.map((match: string) => match.slice(1, -1)) || [];\n \n   let eventTypeUrl = routeValue;\n@@ -33,12 +35,12 @@ export const substituteVariables = (\n           field,\n           value: response[key].value,\n         });\n-        // ['abc', 'def'] ----toString---> 'abc,def' ----encode---> 'abc%2Cdef'\n-        const valueToSubstitute = encodeURIComponent(humanReadableValues.toString());\n+        // ['abc', 'def'] ----toString---> 'abc,def' ----slugify---> 'abc-def'\n+        const valueToSubstitute = slugify(humanReadableValues.toString());\n         eventTypeUrl = eventTypeUrl.replace(`{${variable}}`, valueToSubstitute);\n       }\n     }\n   });\n \n   return eventTypeUrl;\n-};\n+};\n\\ No newline at end of file\n",
    "pr_number": 25499,
    "title": "fix(routing-forms): correct variable encoding and URL construction in Routing Forms Event Redirect Custom URLs",
    "test_files": [
      "apps/web/components/apps/routing-forms/TestFormDialog.test.tsx",
      "packages/app-store/routing-forms/__tests__/getEventTypeRedirectUrl.test.ts",
      "packages/app-store/routing-forms/lib/substituteVariables.test.ts"
    ],
    "code_files": [
      "packages/app-store/routing-forms/getEventTypeRedirectUrl.ts",
      "packages/app-store/routing-forms/lib/substituteVariables.ts"
    ]
  },
  {
    "instance_id": "twentyhq__twenty.main.16335",
    "repo": "twentyhq/twenty",
    "base_commit": "0ced7da8e004b3cb7c9d2c2c56a5e75c6db83dc2",
    "bug_patch": "diff --git a/packages/create-twenty-app/src/cli.ts b/packages/create-twenty-app/src/cli.ts\nindex 9294a94a..027707d4 100644\n--- a/packages/create-twenty-app/src/cli.ts\n+++ b/packages/create-twenty-app/src/cli.ts\n@@ -1,7 +1,7 @@\n #!/usr/bin/env node\n import chalk from 'chalk';\n import { Command, CommanderError } from 'commander';\n-import { CreateAppCommand } from '@/create-app.command';\n+import { CreateAppCommand } from './create-app.command';\n import packageJson from '../package.json';\n \n const program = new Command(packageJson.name)\n@@ -37,4 +37,4 @@ try {\n     console.error(chalk.red('Error:'), error.message);\n     process.exit(1);\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/create-twenty-app/src/create-app.command.ts b/packages/create-twenty-app/src/create-app.command.ts\nindex 5c5ff4a7..b8165628 100644\n--- a/packages/create-twenty-app/src/create-app.command.ts\n+++ b/packages/create-twenty-app/src/create-app.command.ts\n@@ -2,11 +2,11 @@ import chalk from 'chalk';\n import * as fs from 'fs-extra';\n import inquirer from 'inquirer';\n import * as path from 'path';\n-import { copyBaseApplicationProject } from '@/utils/app-template';\n+import { copyBaseApplicationProject } from './utils/app-template';\n import kebabCase from 'lodash.kebabcase';\n-import { convertToLabel } from '@/utils/convert-to-label';\n-import { tryGitInit } from '@/utils/try-git-init';\n-import { install } from '@/utils/install';\n+import { convertToLabel } from './utils/convert-to-label';\n+import { tryGitInit } from './utils/try-git-init';\n+import { install } from './utils/install';\n \n const CURRENT_EXECUTION_DIRECTORY = process.env.INIT_CWD || process.cwd();\n \n@@ -125,4 +125,4 @@ export class CreateAppCommand {\n     console.log(`cd ${appDirectory.split('/').reverse()[0] ?? ''}`);\n     console.log('yarn auth');\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/create-twenty-app/src/utils/__tests__/convert-to-label.spec.ts b/packages/create-twenty-app/src/utils/__tests__/convert-to-label.spec.ts\nindex d7eeedfe..65890f3d 100644\n--- a/packages/create-twenty-app/src/utils/__tests__/convert-to-label.spec.ts\n+++ b/packages/create-twenty-app/src/utils/__tests__/convert-to-label.spec.ts\n@@ -1,4 +1,4 @@\n-import { convertToLabel } from '@/utils/convert-to-label';\n+import { convertToLabel } from '../convert-to-label';\n \n describe('convertToLabel', () => {\n   it('should convert to label', () => {\n@@ -7,4 +7,4 @@ describe('convertToLabel', () => {\n     expect(convertToLabel('totoTataTiti')).toBe('Toto tata titi');\n     expect(convertToLabel('toto-tata-titi')).toBe('Toto tata titi');\n   });\n-});\n+});\n\\ No newline at end of file\n",
    "pr_number": 16335,
    "title": "Use alias in create-twenty-app",
    "test_files": [
      "packages/create-twenty-app/src/utils/__tests__/convert-to-label.spec.ts"
    ],
    "code_files": [
      "packages/create-twenty-app/src/cli.ts",
      "packages/create-twenty-app/src/create-app.command.ts"
    ]
  },
  {
    "instance_id": "twentyhq__twenty.main.16326",
    "repo": "twentyhq/twenty",
    "base_commit": "8ee2efead7f10e125b45c9b0d4f1375d9231f51b",
    "bug_patch": "diff --git a/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/crons/jobs/calendar-event-list-fetch.cron.job.ts b/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/crons/jobs/calendar-event-list-fetch.cron.job.ts\nindex b56bbe59..2cc68007 100644\n--- a/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/crons/jobs/calendar-event-list-fetch.cron.job.ts\n+++ b/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/crons/jobs/calendar-event-list-fetch.cron.job.ts\n@@ -50,11 +50,8 @@ export class CalendarEventListFetchCronJob {\n       try {\n         const schemaName = getWorkspaceSchemaName(activeWorkspace.id);\n \n-        const now = new Date().toISOString();\n-\n         const [calendarChannels] = await this.coreDataSource.query(\n-          `UPDATE ${schemaName}.\"calendarChannel\" SET \"syncStage\" = '${CalendarChannelSyncStage.CALENDAR_EVENT_LIST_FETCH_SCHEDULED}', \"syncStageStartedAt\" = COALESCE(\"syncStageStartedAt\", '${now}')\n-          WHERE \"isSyncEnabled\" = true AND \"syncStage\" = '${CalendarChannelSyncStage.CALENDAR_EVENT_LIST_FETCH_PENDING}' RETURNING *`,\n+          `UPDATE ${schemaName}.\"calendarChannel\" SET \"syncStage\" = '${CalendarChannelSyncStage.CALENDAR_EVENT_LIST_FETCH_SCHEDULED}' WHERE \"isSyncEnabled\" = true AND \"syncStage\" = '${CalendarChannelSyncStage.CALENDAR_EVENT_LIST_FETCH_PENDING}' RETURNING *`,\n         );\n \n         for (const calendarChannel of calendarChannels) {\n@@ -75,4 +72,4 @@ export class CalendarEventListFetchCronJob {\n       }\n     }\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/crons/jobs/calendar-events-import.cron.job.ts b/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/crons/jobs/calendar-events-import.cron.job.ts\nindex d4a80356..b74b1e40 100644\n--- a/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/crons/jobs/calendar-events-import.cron.job.ts\n+++ b/packages/twenty-server/src/modules/calendar/calendar-event-import-manager/crons/jobs/calendar-events-import.cron.job.ts\n@@ -48,11 +48,8 @@ export class CalendarEventsImportCronJob {\n       try {\n         const schemaName = getWorkspaceSchemaName(activeWorkspace.id);\n \n-        const now = new Date().toISOString();\n-\n         const [calendarChannels] = await this.coreDataSource.query(\n-          `UPDATE ${schemaName}.\"calendarChannel\" SET \"syncStage\" = '${CalendarChannelSyncStage.CALENDAR_EVENTS_IMPORT_SCHEDULED}', \"syncStageStartedAt\" = COALESCE(\"syncStageStartedAt\", '${now}')\n-           WHERE \"isSyncEnabled\" = true AND \"syncStage\" = '${CalendarChannelSyncStage.CALENDAR_EVENTS_IMPORT_PENDING}' RETURNING *`,\n+          `UPDATE ${schemaName}.\"calendarChannel\" SET \"syncStage\" = '${CalendarChannelSyncStage.CALENDAR_EVENTS_IMPORT_SCHEDULED}' WHERE \"isSyncEnabled\" = true AND \"syncStage\" = '${CalendarChannelSyncStage.CALENDAR_EVENTS_IMPORT_PENDING}' RETURNING *`,\n         );\n \n         for (const calendarChannel of calendarChannels) {\n@@ -73,4 +70,4 @@ export class CalendarEventsImportCronJob {\n       }\n     }\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/twenty-server/src/modules/messaging/common/services/message-channel-sync-status.service.ts b/packages/twenty-server/src/modules/messaging/common/services/message-channel-sync-status.service.ts\nindex 29225c68..2afea5db 100644\n--- a/packages/twenty-server/src/modules/messaging/common/services/message-channel-sync-status.service.ts\n+++ b/packages/twenty-server/src/modules/messaging/common/services/message-channel-sync-status.service.ts\n@@ -137,27 +137,6 @@ export class MessageChannelSyncStatusService {\n     });\n   }\n \n-  public async markAsMessagesListFetchScheduled(\n-    messageChannelIds: string[],\n-    workspaceId: string,\n-  ) {\n-    if (!messageChannelIds.length) {\n-      return;\n-    }\n-\n-    const messageChannelRepository =\n-      await this.twentyORMGlobalManager.getRepositoryForWorkspace<MessageChannelWorkspaceEntity>(\n-        workspaceId,\n-        'messageChannel',\n-      );\n-\n-    await messageChannelRepository.update(messageChannelIds, {\n-      syncStage: MessageChannelSyncStage.MESSAGE_LIST_FETCH_SCHEDULED,\n-      syncStatus: MessageChannelSyncStatus.ONGOING,\n-      syncStageStartedAt: new Date().toISOString(),\n-    });\n-  }\n-\n   public async markAsMessagesListFetchOngoing(\n     messageChannelIds: string[],\n     workspaceId: string,\n@@ -175,6 +154,7 @@ export class MessageChannelSyncStatusService {\n     await messageChannelRepository.update(messageChannelIds, {\n       syncStage: MessageChannelSyncStage.MESSAGE_LIST_FETCH_ONGOING,\n       syncStatus: MessageChannelSyncStatus.ONGOING,\n+      syncStageStartedAt: new Date().toISOString(),\n     });\n   }\n \n@@ -206,25 +186,6 @@ export class MessageChannelSyncStatusService {\n     });\n   }\n \n-  public async markAsMessagesImportScheduled(\n-    messageChannelIds: string[],\n-    workspaceId: string,\n-  ) {\n-    if (!messageChannelIds.length) {\n-      return;\n-    }\n-\n-    const messageChannelRepository =\n-      await this.twentyORMGlobalManager.getRepositoryForWorkspace<MessageChannelWorkspaceEntity>(\n-        workspaceId,\n-        'messageChannel',\n-      );\n-\n-    await messageChannelRepository.update(messageChannelIds, {\n-      syncStage: MessageChannelSyncStage.MESSAGES_IMPORT_SCHEDULED,\n-    });\n-  }\n-\n   public async markAsMessagesImportOngoing(\n     messageChannelIds: string[],\n     workspaceId: string,\n@@ -344,4 +305,4 @@ export class MessageChannelSyncStatusService {\n       );\n     }\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/twenty-server/src/modules/messaging/message-import-manager/crons/jobs/messaging-message-list-fetch.cron.job.ts b/packages/twenty-server/src/modules/messaging/message-import-manager/crons/jobs/messaging-message-list-fetch.cron.job.ts\nindex 02933aa5..66828cd2 100644\n--- a/packages/twenty-server/src/modules/messaging/message-import-manager/crons/jobs/messaging-message-list-fetch.cron.job.ts\n+++ b/packages/twenty-server/src/modules/messaging/message-import-manager/crons/jobs/messaging-message-list-fetch.cron.job.ts\n@@ -48,11 +48,8 @@ export class MessagingMessageListFetchCronJob {\n       try {\n         const schemaName = getWorkspaceSchemaName(activeWorkspace.id);\n \n-        const now = new Date().toISOString();\n-\n         const [messageChannels] = await this.coreDataSource.query(\n-          `UPDATE ${schemaName}.\"messageChannel\" SET \"syncStage\" = '${MessageChannelSyncStage.MESSAGE_LIST_FETCH_SCHEDULED}', \"syncStageStartedAt\" = COALESCE(\"syncStageStartedAt\", '${now}')\n-           WHERE \"isSyncEnabled\" = true AND \"syncStage\" = '${MessageChannelSyncStage.MESSAGE_LIST_FETCH_PENDING}' RETURNING *`,\n+          `UPDATE ${schemaName}.\"messageChannel\" SET \"syncStage\" = '${MessageChannelSyncStage.MESSAGE_LIST_FETCH_SCHEDULED}' WHERE \"isSyncEnabled\" = true AND \"syncStage\" = '${MessageChannelSyncStage.MESSAGE_LIST_FETCH_PENDING}' RETURNING *`,\n         );\n \n         for (const messageChannel of messageChannels) {\n@@ -73,4 +70,4 @@ export class MessagingMessageListFetchCronJob {\n       }\n     }\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/twenty-server/src/modules/messaging/message-import-manager/crons/jobs/messaging-messages-import.cron.job.ts b/packages/twenty-server/src/modules/messaging/message-import-manager/crons/jobs/messaging-messages-import.cron.job.ts\nindex 0eda7682..656db44c 100644\n--- a/packages/twenty-server/src/modules/messaging/message-import-manager/crons/jobs/messaging-messages-import.cron.job.ts\n+++ b/packages/twenty-server/src/modules/messaging/message-import-manager/crons/jobs/messaging-messages-import.cron.job.ts\n@@ -53,11 +53,8 @@ export class MessagingMessagesImportCronJob {\n       try {\n         const schemaName = getWorkspaceSchemaName(activeWorkspace.id);\n \n-        const now = new Date().toISOString();\n-\n         const [messageChannels] = await this.coreDataSource.query(\n-          `UPDATE ${schemaName}.\"messageChannel\" SET \"syncStage\" = '${MessageChannelSyncStage.MESSAGES_IMPORT_SCHEDULED}', \"syncStageStartedAt\" = COALESCE(\"syncStageStartedAt\", '${now}')\n-          WHERE \"isSyncEnabled\" = true AND \"syncStage\" = '${MessageChannelSyncStage.MESSAGES_IMPORT_PENDING}' RETURNING *`,\n+          `UPDATE ${schemaName}.\"messageChannel\" SET \"syncStage\" = '${MessageChannelSyncStage.MESSAGES_IMPORT_SCHEDULED}' WHERE \"isSyncEnabled\" = true AND \"syncStage\" = '${MessageChannelSyncStage.MESSAGES_IMPORT_PENDING}' RETURNING *`,\n         );\n \n         for (const messageChannel of messageChannels) {\n@@ -102,4 +99,4 @@ export class MessagingMessagesImportCronJob {\n       }\n     }\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/twenty-server/src/modules/messaging/message-import-manager/services/__tests__/messaging-message-list-fetch.service.spec.ts b/packages/twenty-server/src/modules/messaging/message-import-manager/services/__tests__/messaging-message-list-fetch.service.spec.ts\nindex ec045ba1..c9010d45 100644\n--- a/packages/twenty-server/src/modules/messaging/message-import-manager/services/__tests__/messaging-message-list-fetch.service.spec.ts\n+++ b/packages/twenty-server/src/modules/messaging/message-import-manager/services/__tests__/messaging-message-list-fetch.service.spec.ts\n@@ -291,7 +291,7 @@ describe('MessagingMessageListFetchService', () => {\n     });\n     expect(\n       messageChannelSyncStatusService.markAsMessagesListFetchOngoing,\n-    ).toHaveBeenCalledWith([mockMicrosoftMessageChannel.id], workspaceId);\n+    ).toHaveBeenCalledWith([mockMicrosoftMessageChannel.id]);\n \n     expect(messagingGetMessageListService.getMessageLists).toHaveBeenCalledWith(\n       {\n@@ -332,7 +332,7 @@ describe('MessagingMessageListFetchService', () => {\n \n     expect(\n       messageChannelSyncStatusService.scheduleMessagesImport,\n-    ).toHaveBeenCalledWith([mockMicrosoftMessageChannel.id], workspaceId);\n+    ).toHaveBeenCalledWith([mockMicrosoftMessageChannel.id]);\n   });\n \n   it('should process Google message list fetch correctly', async () => {\n@@ -350,7 +350,7 @@ describe('MessagingMessageListFetchService', () => {\n     });\n     expect(\n       messageChannelSyncStatusService.markAsMessagesListFetchOngoing,\n-    ).toHaveBeenCalledWith([mockGoogleMessageChannel.id], workspaceId);\n+    ).toHaveBeenCalledWith([mockGoogleMessageChannel.id]);\n \n     expect(messagingGetMessageListService.getMessageLists).toHaveBeenCalledWith(\n       {\n@@ -391,6 +391,6 @@ describe('MessagingMessageListFetchService', () => {\n \n     expect(\n       messageChannelSyncStatusService.scheduleMessagesImport,\n-    ).toHaveBeenCalledWith([mockGoogleMessageChannel.id], workspaceId);\n+    ).toHaveBeenCalledWith([mockGoogleMessageChannel.id]);\n   });\n-});\n+});\n\\ No newline at end of file\ndiff --git a/packages/twenty-server/src/modules/messaging/message-import-manager/services/__tests__/messaging-messages-import.service.spec.ts b/packages/twenty-server/src/modules/messaging/message-import-manager/services/__tests__/messaging-messages-import.service.spec.ts\nindex f4e7cba4..4a01a0c8 100644\n--- a/packages/twenty-server/src/modules/messaging/message-import-manager/services/__tests__/messaging-messages-import.service.spec.ts\n+++ b/packages/twenty-server/src/modules/messaging/message-import-manager/services/__tests__/messaging-messages-import.service.spec.ts\n@@ -213,7 +213,7 @@ describe('MessagingMessagesImportService', () => {\n     );\n     expect(\n       messageChannelSyncStatusService.markAsMessagesImportOngoing,\n-    ).toHaveBeenCalledWith([mockMessageChannel.id], workspaceId);\n+    ).toHaveBeenCalledWith([mockMessageChannel.id]);\n \n     expect(\n       connectedAccountRefreshTokensService.refreshAndSaveTokens,\n@@ -296,4 +296,4 @@ describe('MessagingMessagesImportService', () => {\n       messageChannelSyncStatusService.scheduleMessagesImport,\n     ).toHaveBeenCalledTimes(1);\n   });\n-});\n+});\n\\ No newline at end of file\n",
    "pr_number": 16326,
    "title": "Fix Message/Calendar channel stuck in SCHEDULED syncStage",
    "test_files": [
      "packages/twenty-server/src/modules/messaging/message-import-manager/services/__tests__/messaging-message-list-fetch.service.spec.ts",
      "packages/twenty-server/src/modules/messaging/message-import-manager/services/__tests__/messaging-messages-import.service.spec.ts"
    ],
    "code_files": [
      "packages/twenty-server/src/modules/calendar/calendar-event-import-manager/crons/jobs/calendar-event-list-fetch.cron.job.ts",
      "packages/twenty-server/src/modules/calendar/calendar-event-import-manager/crons/jobs/calendar-events-import.cron.job.ts",
      "packages/twenty-server/src/modules/messaging/common/services/message-channel-sync-status.service.ts",
      "packages/twenty-server/src/modules/messaging/message-import-manager/crons/jobs/messaging-message-list-fetch.cron.job.ts",
      "packages/twenty-server/src/modules/messaging/message-import-manager/crons/jobs/messaging-messages-import.cron.job.ts"
    ]
  },
  {
    "instance_id": "twentyhq__twenty.main.16299",
    "repo": "twentyhq/twenty",
    "base_commit": "3a14fe8a76b6678c5de02ec0733eae6b0903753d",
    "bug_patch": "diff --git a/packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts b/packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts\nindex ecc0b47c..831d5aac 100644\n--- a/packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts\n+++ b/packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts\n@@ -17,7 +17,6 @@ describe('getOperandsForFilterType', () => {\n \n   const numberOperands = [\n     RecordFilterOperand.IS,\n-    RecordFilterOperand.IS_NOT,\n     RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n     RecordFilterOperand.LESS_THAN_OR_EQUAL,\n   ];\n@@ -90,4 +89,4 @@ describe('getOperandsForFilterType', () => {\n       expect(result).toEqual(expectedOperands);\n     });\n   });\n-});\n+});\n\\ No newline at end of file\ndiff --git a/packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts b/packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts\nindex 791f7835..b7d91984 100644\n--- a/packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts\n+++ b/packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts\n@@ -74,7 +74,6 @@ export const FILTER_OPERANDS_MAP = {\n   ],\n   NUMBER: [\n     RecordFilterOperand.IS,\n-    RecordFilterOperand.IS_NOT,\n     RecordFilterOperand.GREATER_THAN_OR_EQUAL,\n     RecordFilterOperand.LESS_THAN_OR_EQUAL,\n     ...emptyOperands,\n@@ -215,4 +214,4 @@ export const getRecordFilterOperands = ({\n     default:\n       assertUnreachable(filterType, `Unknown filter type ${filterType}`);\n   }\n-};\n+};\n\\ No newline at end of file\ndiff --git a/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts b/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts\nindex 9a238009..220c08dc 100644\n--- a/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts\n+++ b/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts\n@@ -139,11 +139,6 @@ describe('buildValueFromFilter', () => {\n         value: '5',\n         expected: 5,\n       },\n-      {\n-        operand: ViewFilterOperand.IS_NOT,\n-        value: '5',\n-        expected: undefined,\n-      },\n       {\n         operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n         value: '5',\n@@ -514,11 +509,4 @@ describe('buildValueFromFilter', () => {\n   describe('UUID field type', () => {\n     it('should return the value', () => {\n       const filter = createTestFilter(\n-        ViewFilterOperand.IS,\n-        'test-uuid',\n-        'UUID',\n-      );\n-      expect(buildValueFromFilter({ filter })).toBe('test-uuid');\n-    });\n-  });\n-});\n+        ViewFilterOperand.IS,\n\\ No newline at end of file\ndiff --git a/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts b/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts\nindex c5ad711e..ee22dffd 100644\n--- a/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts\n+++ b/packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts\n@@ -159,8 +159,6 @@ const computeValueFromFilterNumber = (\n       return Number(value);\n     case ViewFilterOperand.IS:\n       return Number(value);\n-    case ViewFilterOperand.IS_NOT:\n-      return undefined;\n     case ViewFilterOperand.IS_EMPTY:\n       return undefined;\n     default:\n@@ -331,4 +329,4 @@ const computeValueFromFilterUUID = (\n     default:\n       assertUnreachable(operand);\n   }\n-};\n+};\n\\ No newline at end of file\ndiff --git a/packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts b/packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts\nindex 96d95db4..252e83bb 100644\n--- a/packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts\n+++ b/packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts\n@@ -28,7 +28,6 @@ export const FILTER_OPERANDS_MAP = {\n   ],\n   NUMBER: [\n     ViewFilterOperand.IS,\n-    ViewFilterOperand.IS_NOT,\n     ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n     ViewFilterOperand.LESS_THAN_OR_EQUAL,\n     ...emptyOperands,\n@@ -65,7 +64,6 @@ export const FILTER_OPERANDS_MAP = {\n   UUID: [ViewFilterOperand.IS, ViewFilterOperand.IS_NOT],\n   NUMERIC: [\n     ViewFilterOperand.IS,\n-    ViewFilterOperand.IS_NOT,\n     ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n     ViewFilterOperand.LESS_THAN_OR_EQUAL,\n     ...emptyOperands,\n@@ -140,4 +138,4 @@ export const getStepFilterOperands = ({\n     default:\n       return defaultOperands;\n   }\n-};\n+};\n\\ No newline at end of file\ndiff --git a/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts b/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts\nindex 7fbb7efc..e8ae75e1 100644\n--- a/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts\n+++ b/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts\n@@ -472,1155 +472,4 @@ describe('evaluateFilterConditions', () => {\n \n         expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n         expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n-      });\n-\n-      it('should handle Is operand correctly', () => {\n-        const filter1 = createFilter(ViewFilterOperand.IS, 25, 25, 'NUMBER');\n-        const filter2 = createFilter(ViewFilterOperand.IS, 20, 25, 'NUMBER');\n-        const filter3 = createFilter(ViewFilterOperand.IS, 30, 25, 'NUMBER');\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n-      });\n-\n-      it('should handle IsNot operand correctly', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.IS_NOT,\n-          25,\n-          25,\n-          'NUMBER',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.IS_NOT,\n-          20,\n-          25,\n-          'NUMBER',\n-        );\n-        const filter3 = createFilter(\n-          ViewFilterOperand.IS_NOT,\n-          30,\n-          25,\n-          'NUMBER',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n-      });\n-    });\n-\n-    describe('string and array operands', () => {\n-      it('should handle Contains operand with strings', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          'Hello World',\n-          'World',\n-          'TEXT',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          'Hello',\n-          'World',\n-          'TEXT',\n-        );\n-\n-        const filter3 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          null,\n-          '',\n-          'TEXT',\n-        );\n-\n-        const filter4 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          '',\n-          null,\n-          'TEXT',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(true);\n-      });\n-\n-      it('should handle DoesNotContain operand with strings', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          'Hello World',\n-          'World',\n-          'TEXT',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          'Hello',\n-          'World',\n-          'TEXT',\n-        );\n-\n-        const filter3 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          null,\n-          '',\n-          'TEXT',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n-      });\n-\n-      it('should handle Contains operand with arrays', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          ['apple', 'banana', 'cherry'],\n-          ['apple'],\n-          'ARRAY',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          ['apple', 'banana', 'cherry'],\n-          ['grape'],\n-          'ARRAY',\n-        );\n-\n-        const filter3 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          null,\n-          [],\n-          'ARRAY',\n-        );\n-\n-        const filter4 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          [],\n-          null,\n-          'ARRAY',\n-        );\n-\n-        const filter5 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          null,\n-          ['apple'],\n-          'ARRAY',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter5] })).toBe(false);\n-      });\n-\n-      it('should handle DoesNotContain operand with arrays', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          ['apple', 'banana', 'cherry'],\n-          ['apple'],\n-          'ARRAY',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          ['apple', 'banana', 'cherry'],\n-          ['grape'],\n-          'ARRAY',\n-        );\n-\n-        const filter3 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          null,\n-          ['apple'],\n-          'ARRAY',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n-      });\n-    });\n-\n-    describe('empty operands', () => {\n-      it('should handle IsEmpty operand correctly', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.IS_EMPTY,\n-          null,\n-          '',\n-          'TEXT',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.IS_EMPTY,\n-          undefined,\n-          '',\n-          'TEXT',\n-        );\n-        const filter3 = createFilter(\n-          ViewFilterOperand.IS_EMPTY,\n-          '',\n-          '',\n-          'TEXT',\n-        );\n-        const filter4 = createFilter(\n-          ViewFilterOperand.IS_EMPTY,\n-          [],\n-          '',\n-          'ARRAY',\n-        );\n-        const filter5 = createFilter(\n-          ViewFilterOperand.IS_EMPTY,\n-          'not empty',\n-          '',\n-          'TEXT',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter5] })).toBe(false);\n-      });\n-\n-      it('should handle IsNotEmpty operand correctly', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          'not empty',\n-          '',\n-          'TEXT',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          ['item'],\n-          '',\n-          'ARRAY',\n-        );\n-        const filter3 = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          null,\n-          '',\n-          'TEXT',\n-        );\n-        const filter4 = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          '',\n-          '',\n-          'TEXT',\n-        );\n-        const filter5 = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          [],\n-          '',\n-          'ARRAY',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter5] })).toBe(false);\n-      });\n-    });\n-\n-    describe('date operands', () => {\n-      const now = new Date();\n-      const pastDate = new Date(now.getTime() - 24 * 60 * 60 * 1000); // 1 day ago\n-      const futureDate = new Date(now.getTime() + 24 * 60 * 60 * 1000); // 1 day from now\n-      const today = new Date();\n-\n-      it('should handle IsInPast operand correctly', () => {\n-        const filter = createFilter(\n-          ViewFilterOperand.IS_IN_PAST,\n-          pastDate,\n-          null,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter] })).toBe(true);\n-\n-        const futureFilter = createFilter(\n-          ViewFilterOperand.IS_IN_PAST,\n-          futureDate,\n-          null,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [futureFilter] })).toBe(\n-          false,\n-        );\n-      });\n-\n-      it('should handle IsInFuture operand correctly', () => {\n-        const filter = createFilter(\n-          ViewFilterOperand.IS_IN_FUTURE,\n-          futureDate,\n-          null,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter] })).toBe(true);\n-\n-        const pastFilter = createFilter(\n-          ViewFilterOperand.IS_IN_FUTURE,\n-          pastDate,\n-          null,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [pastFilter] })).toBe(false);\n-      });\n-\n-      it('should handle IsToday operand correctly', () => {\n-        const filter = createFilter(\n-          ViewFilterOperand.IS_TODAY,\n-          today,\n-          null,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter] })).toBe(true);\n-\n-        const pastFilter = createFilter(\n-          ViewFilterOperand.IS_TODAY,\n-          pastDate,\n-          null,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [pastFilter] })).toBe(false);\n-      });\n-\n-      it('should handle IsBefore operand correctly', () => {\n-        const filter = createFilter(\n-          ViewFilterOperand.IS_BEFORE,\n-          pastDate,\n-          now,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter] })).toBe(true);\n-\n-        const futureFilter = createFilter(\n-          ViewFilterOperand.IS_BEFORE,\n-          futureDate,\n-          now,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [futureFilter] })).toBe(\n-          false,\n-        );\n-      });\n-\n-      it('should handle IsAfter operand correctly', () => {\n-        const filter = createFilter(\n-          ViewFilterOperand.IS_AFTER,\n-          futureDate,\n-          now,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter] })).toBe(true);\n-\n-        const pastFilter = createFilter(\n-          ViewFilterOperand.IS_AFTER,\n-          pastDate,\n-          now,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [pastFilter] })).toBe(false);\n-      });\n-\n-      it('should handle Is operand for dates correctly', () => {\n-        const sameDate1 = new Date('2023-01-15');\n-        const sameDate2 = new Date('2023-01-15');\n-        const filter = createFilter(\n-          ViewFilterOperand.IS,\n-          sameDate1,\n-          sameDate2,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter] })).toBe(true);\n-\n-        const otherDate = new Date('2023-01-16');\n-        const differentFilter = createFilter(\n-          ViewFilterOperand.IS,\n-          sameDate1,\n-          otherDate,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [differentFilter] })).toBe(\n-          false,\n-        );\n-      });\n-\n-      it('should handle date IsEmpty and IsNotEmpty operands', () => {\n-        const emptyFilter = createFilter(\n-          ViewFilterOperand.IS_EMPTY,\n-          null,\n-          null,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [emptyFilter] })).toBe(true);\n-\n-        const notEmptyFilter = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          now,\n-          null,\n-          'DATE',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [notEmptyFilter] })).toBe(\n-          true,\n-        );\n-      });\n-    });\n-\n-    describe('currency operands', () => {\n-      it('should handle currency code operands', () => {\n-        const filter: ResolvedFilter = {\n-          id: 'filter1',\n-          type: 'CURRENCY',\n-          rightOperand: 'USD',\n-          operand: ViewFilterOperand.IS,\n-          stepFilterGroupId: 'group1',\n-          leftOperand: 'USD',\n-          compositeFieldSubFieldName: 'currencyCode',\n-        };\n-\n-        expect(evaluateFilterConditions({ filters: [filter] })).toBe(true);\n-      });\n-\n-      it('should handle currency amount operands', () => {\n-        const filter: ResolvedFilter = {\n-          id: 'filter1',\n-          type: 'CURRENCY',\n-          rightOperand: 100,\n-          operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-          stepFilterGroupId: 'group1',\n-          leftOperand: 150,\n-          compositeFieldSubFieldName: 'amountMicros',\n-        };\n-\n-        expect(evaluateFilterConditions({ filters: [filter] })).toBe(true);\n-      });\n-    });\n-\n-    describe('error cases', () => {\n-      it('should throw error for unknown operand', () => {\n-        const filter = createFilter(\n-          'unknown' as ViewFilterOperand,\n-          'value',\n-          'value',\n-          'TEXT',\n-        );\n-\n-        expect(() => evaluateFilterConditions({ filters: [filter] })).toThrow();\n-      });\n-\n-      it('should handle unsupported filter type with default filter logic', () => {\n-        const filter = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          'Hello World',\n-          'World',\n-          'UNSUPPORTED_TYPE',\n-        );\n-\n-        // Unsupported types fall through to default filter logic\n-        expect(evaluateFilterConditions({ filters: [filter] })).toBe(true);\n-      });\n-    });\n-\n-    describe('unknown type filters', () => {\n-      it('should handle Is operand with unknown type', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.IS,\n-          'test',\n-          'test',\n-          'unknown',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.IS,\n-          'test',\n-          'different',\n-          'unknown',\n-        );\n-        const filter3 = createFilter(\n-          ViewFilterOperand.IS,\n-          null,\n-          null,\n-          'unknown',\n-        );\n-        const filter4 = createFilter(\n-          ViewFilterOperand.IS,\n-          undefined,\n-          undefined,\n-          'unknown',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(true);\n-      });\n-\n-      it('should handle IsNot operand with unknown type', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.IS_NOT,\n-          'test',\n-          'different',\n-          'unknown',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.IS_NOT,\n-          'test',\n-          'test',\n-          'unknown',\n-        );\n-        const filter3 = createFilter(\n-          ViewFilterOperand.IS_NOT,\n-          null,\n-          null,\n-          'unknown',\n-        );\n-        const filter4 = createFilter(\n-          ViewFilterOperand.IS_NOT,\n-          undefined,\n-          undefined,\n-          'unknown',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(false);\n-      });\n-\n-      it('should handle Contains operand with unknown type', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          'Hello World',\n-          'World',\n-          'unknown',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          'Hello',\n-          'World',\n-          'unknown',\n-        );\n-        const filter3 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          [1, 2, 3],\n-          2,\n-          'unknown',\n-        );\n-        const filter4 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          [1, 2, 3],\n-          4,\n-          'unknown',\n-        );\n-        const filter5 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          null,\n-          null,\n-          'unknown',\n-        );\n-        const filter6 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          undefined,\n-          undefined,\n-          'unknown',\n-        );\n-        const filter7 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          'Hello World',\n-          undefined,\n-          'unknown',\n-        );\n-\n-        const filter8 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          'Hello World',\n-          null,\n-          'unknown',\n-        );\n-        const filter9 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          [1, 2, 3],\n-          null,\n-          'unknown',\n-        );\n-        const filter10 = createFilter(\n-          ViewFilterOperand.CONTAINS,\n-          [1, 2, 3],\n-          undefined,\n-          'unknown',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter5] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter6] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter7] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter8] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter9] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter10] })).toBe(false);\n-      });\n-\n-      it('should handle DoesNotContain operand with unknown type', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          'Hello',\n-          'World',\n-          'unknown',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          'Hello World',\n-          'World',\n-          'unknown',\n-        );\n-        const filter3 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          [1, 2, 3],\n-          2,\n-          'unknown',\n-        );\n-        const filter4 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          [1, 2, 3],\n-          4,\n-          'unknown',\n-        );\n-        const filter5 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          null,\n-          null,\n-          'unknown',\n-        );\n-        const filter6 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          undefined,\n-          undefined,\n-          'unknown',\n-        );\n-        const filter7 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          'Hello World',\n-          undefined,\n-          'unknown',\n-        );\n-\n-        const filter8 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          'Hello World',\n-          null,\n-          'unknown',\n-        );\n-        const filter9 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          [1, 2, 3],\n-          null,\n-          'unknown',\n-        );\n-        const filter10 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          [1, 2, 3],\n-          undefined,\n-          'unknown',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter5] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter6] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter7] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter8] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter9] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter10] })).toBe(true);\n-      });\n-\n-      it('should handle IsEmpty operand with unknown type', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.IS_EMPTY,\n-          null,\n-          '',\n-          'unknown',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.IS_EMPTY,\n-          'not empty',\n-          '',\n-          'unknown',\n-        );\n-        const filter3 = createFilter(\n-          ViewFilterOperand.IS_EMPTY,\n-          '',\n-          '',\n-          'unknown',\n-        );\n-        const filter4 = createFilter(\n-          ViewFilterOperand.DOES_NOT_CONTAIN,\n-          [],\n-          '',\n-          'unknown',\n-        );\n-        const filter5 = createFilter(\n-          ViewFilterOperand.IS_EMPTY,\n-          undefined,\n-          undefined,\n-          'unknown',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter5] })).toBe(true);\n-      });\n-\n-      it('should handle IsNotEmpty operand with unknown type', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          'not empty',\n-          '',\n-          'unknown',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          null,\n-          '',\n-          'unknown',\n-        );\n-        const filter3 = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          [],\n-          '',\n-          'unknown',\n-        );\n-        const filter4 = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          '',\n-          '',\n-          'unknown',\n-        );\n-        const filter5 = createFilter(\n-          ViewFilterOperand.IS_NOT_EMPTY,\n-          undefined,\n-          undefined,\n-          'unknown',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter5] })).toBe(false);\n-      });\n-\n-      it('should handle GreaterThanOrEqual operand with unknown type', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-          100,\n-          50,\n-          'unknown',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-          30,\n-          50,\n-          'unknown',\n-        );\n-        // strings are converted to numbers\n-        const filter3 = createFilter(\n-          ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-          '1234',\n-          '123',\n-          'unknown',\n-        );\n-        const filter4 = createFilter(\n-          ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-          undefined,\n-          undefined,\n-          'unknown',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(false);\n-      });\n-\n-      it('should handle LessThanOrEqual operand with unknown type', () => {\n-        const filter1 = createFilter(\n-          ViewFilterOperand.LESS_THAN_OR_EQUAL,\n-          30,\n-          50,\n-          'unknown',\n-        );\n-        const filter2 = createFilter(\n-          ViewFilterOperand.LESS_THAN_OR_EQUAL,\n-          100,\n-          50,\n-          'unknown',\n-        );\n-        const filter3 = createFilter(\n-          ViewFilterOperand.LESS_THAN_OR_EQUAL,\n-          '1234',\n-          '123',\n-          'unknown',\n-        );\n-        const filter4 = createFilter(\n-          ViewFilterOperand.LESS_THAN_OR_EQUAL,\n-          undefined,\n-          undefined,\n-          'unknown',\n-        );\n-\n-        expect(evaluateFilterConditions({ filters: [filter1] })).toBe(true);\n-        expect(evaluateFilterConditions({ filters: [filter2] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter3] })).toBe(false);\n-        expect(evaluateFilterConditions({ filters: [filter4] })).toBe(false);\n-      });\n-\n-      it('should throw error for unsupported operand with unknown type', () => {\n-        const filter = createFilter(\n-          ViewFilterOperand.VECTOR_SEARCH,\n-          'test',\n-          'search term',\n-          'unknown',\n-        );\n-\n-        expect(() => evaluateFilterConditions({ filters: [filter] })).toThrow();\n-      });\n-    });\n-  });\n-\n-  describe('multiple filters without groups', () => {\n-    it('should apply AND logic by default for multiple filters', () => {\n-      const filters: ResolvedFilter[] = [\n-        {\n-          id: 'filter1',\n-          type: 'RELATION',\n-          rightOperand: 'John',\n-          operand: ViewFilterOperand.IS,\n-          stepFilterGroupId: 'group1',\n-          leftOperand: 'John',\n-        },\n-        {\n-          id: 'filter2',\n-          type: 'NUMBER',\n-          rightOperand: 25,\n-          operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-          stepFilterGroupId: 'group1',\n-          leftOperand: 30,\n-        },\n-      ];\n-\n-      const result = evaluateFilterConditions({ filters });\n-\n-      expect(result).toBe(true);\n-    });\n-\n-    it('should return false when one filter fails in AND logic', () => {\n-      const filters: ResolvedFilter[] = [\n-        {\n-          id: 'filter1',\n-          type: 'RELATION',\n-          rightOperand: 'John',\n-          operand: ViewFilterOperand.IS,\n-          stepFilterGroupId: 'group1',\n-          leftOperand: 'John',\n-        },\n-        {\n-          id: 'filter2',\n-          type: 'NUMBER',\n-          rightOperand: 25,\n-          operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-          stepFilterGroupId: 'group1',\n-          leftOperand: 20, // This will fail\n-        },\n-      ];\n-\n-      const result = evaluateFilterConditions({ filters });\n-\n-      expect(result).toBe(false);\n-    });\n-  });\n-\n-  describe('filter groups', () => {\n-    describe('single group with AND logic', () => {\n-      it('should return true when all filters pass', () => {\n-        const filterGroups: StepFilterGroup[] = [\n-          {\n-            id: 'group1',\n-            logicalOperator: StepLogicalOperator.AND,\n-          },\n-        ];\n-\n-        const filters: ResolvedFilter[] = [\n-          {\n-            id: 'filter1',\n-            type: 'RELATION',\n-            rightOperand: 'John',\n-            operand: ViewFilterOperand.IS,\n-            stepFilterGroupId: 'group1',\n-            leftOperand: 'John',\n-          },\n-          {\n-            id: 'filter2',\n-            type: 'NUMBER',\n-            rightOperand: 25,\n-            operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-            stepFilterGroupId: 'group1',\n-            leftOperand: 30,\n-          },\n-        ];\n-\n-        const result = evaluateFilterConditions({ filterGroups, filters });\n-\n-        expect(result).toBe(true);\n-      });\n-\n-      it('should return false when one filter fails', () => {\n-        const filterGroups: StepFilterGroup[] = [\n-          {\n-            id: 'group1',\n-            logicalOperator: StepLogicalOperator.AND,\n-          },\n-        ];\n-\n-        const filters: ResolvedFilter[] = [\n-          {\n-            id: 'filter1',\n-            type: 'RELATION',\n-            rightOperand: 'John',\n-            operand: ViewFilterOperand.IS,\n-            stepFilterGroupId: 'group1',\n-            leftOperand: 'Jane', // This will fail\n-          },\n-          {\n-            id: 'filter2',\n-            type: 'NUMBER',\n-            rightOperand: 25,\n-            operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-            stepFilterGroupId: 'group1',\n-            leftOperand: 30,\n-          },\n-        ];\n-\n-        const result = evaluateFilterConditions({ filterGroups, filters });\n-\n-        expect(result).toBe(false);\n-      });\n-    });\n-\n-    describe('single group with OR logic', () => {\n-      it('should return true when at least one filter passes', () => {\n-        const filterGroups: StepFilterGroup[] = [\n-          {\n-            id: 'group1',\n-            logicalOperator: StepLogicalOperator.OR,\n-          },\n-        ];\n-\n-        const filters: ResolvedFilter[] = [\n-          {\n-            id: 'filter1',\n-            type: 'RELATION',\n-            rightOperand: 'John',\n-            operand: ViewFilterOperand.IS,\n-            stepFilterGroupId: 'group1',\n-            leftOperand: 'Jane', // This will fail\n-          },\n-          {\n-            id: 'filter2',\n-            type: 'NUMBER',\n-            rightOperand: 25,\n-            operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-            stepFilterGroupId: 'group1',\n-            leftOperand: 30, // This will pass\n-          },\n-        ];\n-\n-        const result = evaluateFilterConditions({ filterGroups, filters });\n-\n-        expect(result).toBe(true);\n-      });\n-\n-      it('should return false when all filters fail', () => {\n-        const filterGroups: StepFilterGroup[] = [\n-          {\n-            id: 'group1',\n-            logicalOperator: StepLogicalOperator.OR,\n-          },\n-        ];\n-\n-        const filters: ResolvedFilter[] = [\n-          {\n-            id: 'filter1',\n-            type: 'RELATION',\n-            rightOperand: 'John',\n-            operand: ViewFilterOperand.IS,\n-            stepFilterGroupId: 'group1',\n-            leftOperand: 'Jane', // This will fail\n-          },\n-          {\n-            id: 'filter2',\n-            type: 'NUMBER',\n-            rightOperand: 25,\n-            operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-            stepFilterGroupId: 'group1',\n-            leftOperand: 20, // This will fail\n-          },\n-        ];\n-\n-        const result = evaluateFilterConditions({ filterGroups, filters });\n-\n-        expect(result).toBe(false);\n-      });\n-    });\n-\n-    describe('multiple groups', () => {\n-      it('should handle multiple root groups with AND logic between them', () => {\n-        const filterGroups: StepFilterGroup[] = [\n-          {\n-            id: 'group1',\n-            logicalOperator: StepLogicalOperator.AND,\n-          },\n-          {\n-            id: 'group2',\n-            logicalOperator: StepLogicalOperator.OR,\n-          },\n-        ];\n-\n-        const filters: ResolvedFilter[] = [\n-          {\n-            id: 'filter1',\n-            type: 'RELATION',\n-            rightOperand: 'John',\n-            operand: ViewFilterOperand.IS,\n-            stepFilterGroupId: 'group1',\n-            leftOperand: 'John',\n-          },\n-          {\n-            id: 'filter2',\n-            type: 'NUMBER',\n-            rightOperand: 25,\n-            operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-            stepFilterGroupId: 'group2',\n-            leftOperand: 30,\n-          },\n-        ];\n-\n-        const result = evaluateFilterConditions({ filterGroups, filters });\n-\n-        expect(result).toBe(true);\n-      });\n-    });\n-\n-    describe('nested groups', () => {\n-      it('should handle nested filter groups correctly', () => {\n-        const filterGroups: StepFilterGroup[] = [\n-          {\n-            id: 'root',\n-            logicalOperator: StepLogicalOperator.AND,\n-          },\n-          {\n-            id: 'child1',\n-            logicalOperator: StepLogicalOperator.OR,\n-            parentStepFilterGroupId: 'root',\n-            positionInStepFilterGroup: 1,\n-          },\n-          {\n-            id: 'child2',\n-            logicalOperator: StepLogicalOperator.AND,\n-            parentStepFilterGroupId: 'root',\n-            positionInStepFilterGroup: 2,\n-          },\n-        ];\n-\n-        const filters: ResolvedFilter[] = [\n-          {\n-            id: 'filter1',\n-            type: 'RELATION',\n-            rightOperand: 'John',\n-            operand: ViewFilterOperand.IS,\n-            stepFilterGroupId: 'child1',\n-            leftOperand: 'Jane', // This will fail\n-          },\n-          {\n-            id: 'filter2',\n-            type: 'RELATION',\n-            rightOperand: 'Smith',\n-            operand: ViewFilterOperand.IS,\n-            stepFilterGroupId: 'child1',\n-            leftOperand: 'Smith', // This will pass (OR group passes)\n-          },\n-          {\n-            id: 'filter3',\n-            type: 'NUMBER',\n-            rightOperand: 25,\n-            operand: ViewFilterOperand.GREATER_THAN_OR_EQUAL,\n-            stepFilterGroupId: 'child2',\n-            leftOperand: 30, // This will pass (AND group passes)\n-          },\n-        ];\n-\n-        const result = evaluateFilterConditions({ filterGroups, filters });\n-\n-        expect(result).toBe(true); // child1 (OR) passes, child2 (AND) passes, root (AND) passes\n-      });\n-    });\n-\n-    describe('empty groups', () => {\n-      it('should return true for empty filter groups', () => {\n-        const filterGroups: StepFilterGroup[] = [\n-          {\n-            id: 'group1',\n-            logicalOperator: StepLogicalOperator.AND,\n-          },\n-        ];\n-\n-        const result = evaluateFilterConditions({ filterGroups, filters: [] });\n-\n-        expect(result).toBe(true);\n-      });\n-    });\n-\n-    describe('error cases', () => {\n-      it('should throw error when filter references non-existent group', () => {\n-        const filterGroups: StepFilterGroup[] = [\n-          {\n-            id: 'group1',\n-            logicalOperator: StepLogicalOperator.AND,\n-          },\n-        ];\n-\n-        const filters: ResolvedFilter[] = [\n-          {\n-            id: 'filter1',\n-            type: 'RELATION',\n-            rightOperand: 'John',\n-            operand: ViewFilterOperand.IS,\n-            stepFilterGroupId: 'nonexistent',\n-            leftOperand: 'John',\n-          },\n-        ];\n-\n-        expect(() =>\n-          evaluateFilterConditions({ filterGroups, filters }),\n-        ).toThrow('Filter group with id nonexistent not found');\n-      });\n-    });\n-  });\n-});\n+        expect(evaluateFilterConditions({ filters:\n\\ No newline at end of file\ndiff --git a/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts b/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts\nindex efebf74c..3839fc30 100644\n--- a/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts\n+++ b/packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts\n@@ -349,9 +349,6 @@ function evaluateNumberFilter(filter: ResolvedFilter): boolean {\n     case ViewFilterOperand.IS:\n       return Number(leftValue) === Number(rightValue);\n \n-    case ViewFilterOperand.IS_NOT:\n-      return Number(leftValue) !== Number(rightValue);\n-\n     default:\n       throw new Error(\n         `Operand ${filter.operand} not supported for number filter`,\n@@ -441,4 +438,4 @@ export function evaluateFilterConditions({\n   );\n \n   return rootResults.every((result) => result);\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts b/packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts\nindex dc517c6c..e33b5469 100644\n--- a/packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts\n+++ b/packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts\n@@ -416,14 +416,6 @@ export const turnRecordFilterIntoRecordGqlOperationFilter = ({\n               eq: parseFloat(recordFilter.value),\n             } as FloatFilter,\n           };\n-        case RecordFilterOperand.IS_NOT:\n-          return {\n-            not: {\n-              [correspondingFieldMetadataItem.name]: {\n-                eq: parseFloat(recordFilter.value),\n-              } as FloatFilter,\n-            },\n-          };\n         default:\n           throw new Error(\n             `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n@@ -489,844 +481,4 @@ export const turnRecordFilterIntoRecordGqlOperationFilter = ({\n           subFieldName,\n         )\n       ) {\n-        const parsedCurrencyCodes = arrayOfStringsOrVariablesSchema.parse(\n-          recordFilter.value,\n-        );\n-\n-        if (parsedCurrencyCodes.length === 0) return undefined;\n-\n-        const gqlFilter: RecordGqlOperationFilter = {\n-          [correspondingFieldMetadataItem.name]: {\n-            currencyCode: { in: parsedCurrencyCodes },\n-          } as CurrencyFilter,\n-        };\n-\n-        switch (recordFilter.operand) {\n-          case RecordFilterOperand.IS:\n-            return gqlFilter;\n-          case RecordFilterOperand.IS_NOT:\n-            return {\n-              not: gqlFilter,\n-            };\n-          default:\n-            throw new Error(\n-              `Unknown operand ${recordFilter.operand} for ${filterType} / ${subFieldName} filter`,\n-            );\n-        }\n-      } else if (\n-        isExpectedSubFieldName(\n-          FieldMetadataType.CURRENCY,\n-          'amountMicros',\n-          subFieldName,\n-        ) ||\n-        !isSubFieldFilter\n-      ) {\n-        switch (recordFilter.operand) {\n-          case RecordFilterOperand.GREATER_THAN_OR_EQUAL:\n-            return {\n-              [correspondingFieldMetadataItem.name]: {\n-                amountMicros: { gte: parseFloat(recordFilter.value) * 1000000 },\n-              } as CurrencyFilter,\n-            };\n-          case RecordFilterOperand.LESS_THAN_OR_EQUAL:\n-            return {\n-              [correspondingFieldMetadataItem.name]: {\n-                amountMicros: { lte: parseFloat(recordFilter.value) * 1000000 },\n-              } as CurrencyFilter,\n-            };\n-          case RecordFilterOperand.IS:\n-            return {\n-              [correspondingFieldMetadataItem.name]: {\n-                amountMicros: { eq: parseFloat(recordFilter.value) * 1000000 },\n-              } as CurrencyFilter,\n-            };\n-          case RecordFilterOperand.IS_NOT:\n-            return {\n-              not: {\n-                [correspondingFieldMetadataItem.name]: {\n-                  amountMicros: {\n-                    eq: parseFloat(recordFilter.value) * 1000000,\n-                  },\n-                } as CurrencyFilter,\n-              },\n-            };\n-          default:\n-            throw new Error(\n-              `Unknown operand ${recordFilter.operand} for ${filterType} / ${subFieldName}  filter`,\n-            );\n-        }\n-      } else {\n-        throw new Error(\n-          `Unknown subfield ${subFieldName} for ${filterType} filter`,\n-        );\n-      }\n-    }\n-    case 'LINKS': {\n-      return computeGqlOperationFilterForLinks({\n-        correspondingFieldMetadataItem,\n-        recordFilter,\n-        subFieldName,\n-      });\n-    }\n-    case 'FULL_NAME': {\n-      const fullNameFilters = generateILikeFiltersForCompositeFields(\n-        recordFilter.value,\n-        correspondingFieldMetadataItem.name,\n-        ['firstName', 'lastName'],\n-      );\n-      switch (recordFilter.operand) {\n-        case RecordFilterOperand.CONTAINS:\n-          if (!isSubFieldFilter) {\n-            return {\n-              or: fullNameFilters,\n-            };\n-          } else {\n-            return {\n-              [correspondingFieldMetadataItem.name]: {\n-                [subFieldName]: {\n-                  ilike: `%${recordFilter.value}%`,\n-                },\n-              },\n-            };\n-          }\n-        case RecordFilterOperand.DOES_NOT_CONTAIN:\n-          if (!isSubFieldFilter) {\n-            return {\n-              and: fullNameFilters.map((filter) => {\n-                return {\n-                  not: filter,\n-                };\n-              }),\n-            };\n-          } else {\n-            return {\n-              not: {\n-                [correspondingFieldMetadataItem.name]: {\n-                  [subFieldName]: {\n-                    ilike: `%${recordFilter.value}%`,\n-                  },\n-                },\n-              },\n-            };\n-          }\n-        default:\n-          throw new Error(\n-            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n-          );\n-      }\n-    }\n-    case 'ADDRESS':\n-      switch (recordFilter.operand) {\n-        case RecordFilterOperand.CONTAINS:\n-          if (!isSubFieldFilter) {\n-            return {\n-              or: [\n-                {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    addressStreet1: {\n-                      ilike: `%${recordFilter.value}%`,\n-                    },\n-                  } as AddressFilter,\n-                },\n-                {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    addressStreet2: {\n-                      ilike: `%${recordFilter.value}%`,\n-                    },\n-                  } as AddressFilter,\n-                },\n-                {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    addressCity: {\n-                      ilike: `%${recordFilter.value}%`,\n-                    },\n-                  } as AddressFilter,\n-                },\n-                {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    addressState: {\n-                      ilike: `%${recordFilter.value}%`,\n-                    },\n-                  } as AddressFilter,\n-                },\n-                {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    addressCountry: {\n-                      ilike: `%${recordFilter.value}%`,\n-                    },\n-                  } as AddressFilter,\n-                },\n-                {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    addressPostcode: {\n-                      ilike: `%${recordFilter.value}%`,\n-                    },\n-                  } as AddressFilter,\n-                },\n-              ],\n-            };\n-          } else {\n-            if (subFieldName === 'addressCountry') {\n-              const parsedCountryCodes = arrayOfStringsOrVariablesSchema.parse(\n-                recordFilter.value,\n-              );\n-\n-              if (parsedCountryCodes.length === 0) {\n-                return {};\n-              }\n-\n-              return {\n-                [correspondingFieldMetadataItem.name]: {\n-                  [subFieldName]: {\n-                    in: parsedCountryCodes,\n-                  } as AddressFilter,\n-                },\n-              };\n-            }\n-\n-            return {\n-              [correspondingFieldMetadataItem.name]: {\n-                [subFieldName]: {\n-                  ilike: `%${recordFilter.value}%`,\n-                } as AddressFilter,\n-              },\n-            };\n-          }\n-        case RecordFilterOperand.DOES_NOT_CONTAIN:\n-          if (!isSubFieldFilter) {\n-            return {\n-              and: [\n-                {\n-                  or: [\n-                    {\n-                      not: {\n-                        [correspondingFieldMetadataItem.name]: {\n-                          addressStreet1: {\n-                            ilike: `%${recordFilter.value}%`,\n-                          },\n-                        } as AddressFilter,\n-                      },\n-                    },\n-                    {\n-                      [correspondingFieldMetadataItem.name]: {\n-                        addressStreet1: {\n-                          is: 'NULL',\n-                        },\n-                      },\n-                    },\n-                  ],\n-                },\n-                {\n-                  or: [\n-                    {\n-                      not: {\n-                        [correspondingFieldMetadataItem.name]: {\n-                          addressStreet2: {\n-                            ilike: `%${recordFilter.value}%`,\n-                          },\n-                        } as AddressFilter,\n-                      },\n-                    },\n-                    {\n-                      [correspondingFieldMetadataItem.name]: {\n-                        addressStreet2: {\n-                          is: 'NULL',\n-                        },\n-                      },\n-                    },\n-                  ],\n-                },\n-                {\n-                  or: [\n-                    {\n-                      not: {\n-                        [correspondingFieldMetadataItem.name]: {\n-                          addressCity: {\n-                            ilike: `%${recordFilter.value}%`,\n-                          },\n-                        } as AddressFilter,\n-                      },\n-                    },\n-                    {\n-                      [correspondingFieldMetadataItem.name]: {\n-                        addressCity: {\n-                          is: 'NULL',\n-                        },\n-                      },\n-                    },\n-                  ],\n-                },\n-                {\n-                  or: [\n-                    {\n-                      not: {\n-                        [correspondingFieldMetadataItem.name]: {\n-                          addressState: {\n-                            ilike: `%${recordFilter.value}%`,\n-                          },\n-                        } as AddressFilter,\n-                      },\n-                    },\n-                    {\n-                      [correspondingFieldMetadataItem.name]: {\n-                        addressState: {\n-                          is: 'NULL',\n-                        },\n-                      },\n-                    },\n-                  ],\n-                },\n-                {\n-                  or: [\n-                    {\n-                      not: {\n-                        [correspondingFieldMetadataItem.name]: {\n-                          addressPostcode: {\n-                            ilike: `%${recordFilter.value}%`,\n-                          },\n-                        } as AddressFilter,\n-                      },\n-                    },\n-                    {\n-                      [correspondingFieldMetadataItem.name]: {\n-                        addressPostcode: {\n-                          is: 'NULL',\n-                        },\n-                      },\n-                    },\n-                  ],\n-                },\n-                {\n-                  or: [\n-                    {\n-                      not: {\n-                        [correspondingFieldMetadataItem.name]: {\n-                          addressCountry: {\n-                            ilike: `%${recordFilter.value}%`,\n-                          },\n-                        } as AddressFilter,\n-                      },\n-                    },\n-                    {\n-                      [correspondingFieldMetadataItem.name]: {\n-                        addressCountry: {\n-                          is: 'NULL',\n-                        },\n-                      },\n-                    },\n-                  ],\n-                },\n-              ],\n-            };\n-          } else {\n-            if (subFieldName === 'addressCountry') {\n-              const parsedCountryCodes = JSON.parse(\n-                recordFilter.value,\n-              ) as string[];\n-\n-              if (\n-                recordFilter.value === '[]' ||\n-                parsedCountryCodes.length === 0\n-              ) {\n-                return {};\n-              }\n-\n-              return {\n-                or: [\n-                  {\n-                    not: {\n-                      [correspondingFieldMetadataItem.name]: {\n-                        addressCountry: {\n-                          in: JSON.parse(recordFilter.value),\n-                        } as AddressFilter,\n-                      },\n-                    },\n-                  },\n-                  {\n-                    [correspondingFieldMetadataItem.name]: {\n-                      addressCountry: {\n-                        is: 'NULL',\n-                      } as AddressFilter,\n-                    },\n-                  },\n-                ],\n-              };\n-            }\n-\n-            return {\n-              or: [\n-                {\n-                  not: {\n-                    [correspondingFieldMetadataItem.name]: {\n-                      [subFieldName]: {\n-                        ilike: `%${recordFilter.value}%`,\n-                      } as AddressFilter,\n-                    },\n-                  },\n-                },\n-                {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    [subFieldName]: {\n-                      is: 'NULL',\n-                    } as AddressFilter,\n-                  },\n-                },\n-              ],\n-            };\n-          }\n-        default:\n-          throw new Error(\n-            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n-          );\n-      }\n-    case 'MULTI_SELECT': {\n-      const options = arrayOfStringsOrVariablesSchema.parse(recordFilter.value);\n-\n-      if (options.length === 0) return;\n-\n-      const emptyOptions = options.filter((option: string) => option === '');\n-      const nonEmptyOptions = options.filter((option: string) => option !== '');\n-\n-      switch (recordFilter.operand) {\n-        case RecordFilterOperand.CONTAINS: {\n-          const conditions = [];\n-\n-          if (nonEmptyOptions.length > 0) {\n-            conditions.push({\n-              [correspondingFieldMetadataItem.name]: {\n-                containsAny: nonEmptyOptions,\n-              } as MultiSelectFilter,\n-            });\n-          }\n-\n-          if (emptyOptions.length > 0) {\n-            conditions.push({\n-              [correspondingFieldMetadataItem.name]: {\n-                isEmptyArray: true,\n-              } as MultiSelectFilter,\n-            });\n-          }\n-\n-          return conditions.length === 1 ? conditions[0] : { or: conditions };\n-        }\n-        case RecordFilterOperand.DOES_NOT_CONTAIN:\n-          return {\n-            or: [\n-              {\n-                not: {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    containsAny: nonEmptyOptions,\n-                  } as MultiSelectFilter,\n-                },\n-              },\n-              {\n-                [correspondingFieldMetadataItem.name]: {\n-                  isEmptyArray: true,\n-                } as MultiSelectFilter,\n-              },\n-              {\n-                [correspondingFieldMetadataItem.name]: {\n-                  is: 'NULL',\n-                } as MultiSelectFilter,\n-              },\n-            ],\n-          };\n-        default:\n-          throw new Error(\n-            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n-          );\n-      }\n-    }\n-    case 'SELECT': {\n-      const options = arrayOfStringsOrVariablesSchema.parse(recordFilter.value);\n-\n-      if (options.length === 0) return;\n-\n-      const emptyOptions = options.filter((option: string) => option === '');\n-      const nonEmptyOptions = options.filter((option: string) => option !== '');\n-\n-      switch (recordFilter.operand) {\n-        case RecordFilterOperand.IS: {\n-          const conditions = [];\n-\n-          if (nonEmptyOptions.length > 0) {\n-            conditions.push({\n-              [correspondingFieldMetadataItem.name]: {\n-                in: nonEmptyOptions,\n-              } as SelectFilter,\n-            });\n-          }\n-\n-          if (emptyOptions.length > 0) {\n-            conditions.push({\n-              [correspondingFieldMetadataItem.name]: {\n-                is: 'NULL',\n-              } as SelectFilter,\n-            });\n-          }\n-\n-          return conditions.length === 1 ? conditions[0] : { or: conditions };\n-        }\n-        case RecordFilterOperand.IS_NOT: {\n-          const conditions = [];\n-\n-          if (nonEmptyOptions.length > 0) {\n-            conditions.push({\n-              not: {\n-                [correspondingFieldMetadataItem.name]: {\n-                  in: nonEmptyOptions,\n-                } as SelectFilter,\n-              },\n-            });\n-          }\n-\n-          if (emptyOptions.length > 0) {\n-            conditions.push({\n-              not: {\n-                [correspondingFieldMetadataItem.name]: {\n-                  is: 'NULL',\n-                } as SelectFilter,\n-              },\n-            });\n-          }\n-\n-          return conditions.length === 1 ? conditions[0] : { and: conditions };\n-        }\n-        default:\n-          throw new Error(\n-            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n-          );\n-      }\n-    }\n-    case 'ARRAY': {\n-      switch (recordFilter.operand) {\n-        case RecordFilterOperand.CONTAINS:\n-          return {\n-            [correspondingFieldMetadataItem.name]: {\n-              containsIlike: `%${recordFilter.value}%`,\n-            } as ArrayFilter,\n-          };\n-        case RecordFilterOperand.DOES_NOT_CONTAIN:\n-          return {\n-            not: {\n-              [correspondingFieldMetadataItem.name]: {\n-                containsIlike: `%${recordFilter.value}%`,\n-              } as ArrayFilter,\n-            },\n-          };\n-        default:\n-          throw new Error(\n-            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n-          );\n-      }\n-    }\n-    case 'ACTOR': {\n-      if (subFieldName === 'source') {\n-        switch (recordFilter.operand) {\n-          case RecordFilterOperand.IS: {\n-            if (recordFilter.value === '[]') {\n-              return;\n-            }\n-\n-            const parsedSources = JSON.parse(recordFilter.value) as string[];\n-\n-            return {\n-              [correspondingFieldMetadataItem.name]: {\n-                source: {\n-                  in: parsedSources,\n-                } satisfies RelationFilter,\n-              },\n-            };\n-          }\n-          case RecordFilterOperand.IS_NOT: {\n-            if (recordFilter.value === '[]') {\n-              return;\n-            }\n-\n-            const parsedSources = JSON.parse(recordFilter.value) as string[];\n-\n-            if (parsedSources.length === 0) return;\n-\n-            return {\n-              not: {\n-                [correspondingFieldMetadataItem.name]: {\n-                  source: {\n-                    in: parsedSources,\n-                  } satisfies RelationFilter,\n-                },\n-              },\n-            };\n-          }\n-          default: {\n-            const fieldForRecordFilter = fieldMetadataItems.find(\n-              (field) => field.id === recordFilter.fieldMetadataId,\n-            );\n-\n-            throw new Error(\n-              `Unknown operand ${recordFilter.operand} for ${fieldForRecordFilter?.label ?? ''} filter`,\n-            );\n-          }\n-        }\n-      }\n-\n-      switch (recordFilter.operand) {\n-        case RecordFilterOperand.CONTAINS:\n-          return {\n-            or: [\n-              {\n-                [correspondingFieldMetadataItem.name]: {\n-                  name: {\n-                    ilike: `%${recordFilter.value}%`,\n-                  },\n-                } satisfies ActorFilter,\n-              },\n-            ],\n-          };\n-        case RecordFilterOperand.DOES_NOT_CONTAIN:\n-          return {\n-            and: [\n-              {\n-                not: {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    name: {\n-                      ilike: `%${recordFilter.value}%`,\n-                    },\n-                  } satisfies ActorFilter,\n-                },\n-              },\n-            ],\n-          };\n-        default: {\n-          const fieldForRecordFilter = fieldMetadataItems.find(\n-            (field) => field.id === recordFilter.fieldMetadataId,\n-          );\n-\n-          throw new Error(\n-            `Unknown operand ${recordFilter.operand} for ${fieldForRecordFilter?.label ?? ''} filter`,\n-          );\n-        }\n-      }\n-    }\n-    case 'EMAILS': {\n-      return computeGqlOperationFilterForEmails({\n-        correspondingFieldMetadataItem,\n-        recordFilter,\n-        subFieldName,\n-      });\n-    }\n-    case 'PHONES': {\n-      if (!isSubFieldFilter) {\n-        const filterValue = recordFilter.value.replace(/[^0-9]/g, '');\n-\n-        if (!isNonEmptyString(filterValue)) {\n-          return;\n-        }\n-\n-        switch (recordFilter.operand) {\n-          case RecordFilterOperand.CONTAINS:\n-            return {\n-              or: [\n-                {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    primaryPhoneNumber: {\n-                      ilike: `%${filterValue}%`,\n-                    },\n-                  } as PhonesFilter,\n-                },\n-                {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    primaryPhoneCallingCode: {\n-                      ilike: `%${filterValue}%`,\n-                    },\n-                  } as PhonesFilter,\n-                },\n-                {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    additionalPhones: {\n-                      like: `%${filterValue}%`,\n-                    },\n-                  } as PhonesFilter,\n-                },\n-              ],\n-            };\n-          case RecordFilterOperand.DOES_NOT_CONTAIN:\n-            return {\n-              and: [\n-                {\n-                  not: {\n-                    [correspondingFieldMetadataItem.name]: {\n-                      primaryPhoneNumber: {\n-                        ilike: `%${filterValue}%`,\n-                      },\n-                    } as PhonesFilter,\n-                  },\n-                },\n-                {\n-                  not: {\n-                    [correspondingFieldMetadataItem.name]: {\n-                      primaryPhoneCallingCode: {\n-                        ilike: `%${filterValue}%`,\n-                      },\n-                    } as PhonesFilter,\n-                  },\n-                },\n-                {\n-                  or: [\n-                    {\n-                      not: {\n-                        [correspondingFieldMetadataItem.name]: {\n-                          additionalPhones: {\n-                            like: `%${filterValue}%`,\n-                          },\n-                        } as PhonesFilter,\n-                      },\n-                    },\n-                    {\n-                      [correspondingFieldMetadataItem.name]: {\n-                        additionalPhones: {\n-                          is: 'NULL',\n-                        } as PhonesFilter,\n-                      },\n-                    },\n-                  ],\n-                },\n-              ],\n-            };\n-          default:\n-            throw new Error(\n-              `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n-            );\n-        }\n-      }\n-\n-      const filterValue = recordFilter.value;\n-\n-      switch (subFieldName) {\n-        case 'additionalPhones': {\n-          switch (recordFilter.operand) {\n-            case RecordFilterOperand.CONTAINS:\n-              return {\n-                or: [\n-                  {\n-                    [correspondingFieldMetadataItem.name]: {\n-                      additionalPhones: {\n-                        like: `%${filterValue}%`,\n-                      },\n-                    } as PhonesFilter,\n-                  },\n-                ],\n-              };\n-            case RecordFilterOperand.DOES_NOT_CONTAIN:\n-              return {\n-                or: [\n-                  {\n-                    not: {\n-                      [correspondingFieldMetadataItem.name]: {\n-                        additionalPhones: {\n-                          like: `%${filterValue}%`,\n-                        },\n-                      } as PhonesFilter,\n-                    },\n-                  },\n-                  {\n-                    [correspondingFieldMetadataItem.name]: {\n-                      additionalPhones: {\n-                        is: 'NULL',\n-                      } as PhonesFilter,\n-                    },\n-                  },\n-                ],\n-              };\n-            default:\n-              throw new Error(\n-                `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n-              );\n-          }\n-        }\n-        case 'primaryPhoneNumber': {\n-          switch (recordFilter.operand) {\n-            case RecordFilterOperand.CONTAINS:\n-              return {\n-                [correspondingFieldMetadataItem.name]: {\n-                  primaryPhoneNumber: {\n-                    ilike: `%${filterValue}%`,\n-                  },\n-                } as PhonesFilter,\n-              };\n-            case RecordFilterOperand.DOES_NOT_CONTAIN:\n-              return {\n-                not: {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    primaryPhoneNumber: {\n-                      ilike: `%${filterValue}%`,\n-                    },\n-                  } as PhonesFilter,\n-                },\n-              };\n-            default:\n-              throw new Error(\n-                `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n-              );\n-          }\n-        }\n-        case 'primaryPhoneCallingCode': {\n-          switch (recordFilter.operand) {\n-            case RecordFilterOperand.CONTAINS:\n-              return {\n-                [correspondingFieldMetadataItem.name]: {\n-                  primaryPhoneCallingCode: {\n-                    ilike: `%${filterValue}%`,\n-                  },\n-                } as PhonesFilter,\n-              };\n-            case RecordFilterOperand.DOES_NOT_CONTAIN:\n-              return {\n-                not: {\n-                  [correspondingFieldMetadataItem.name]: {\n-                    primaryPhoneCallingCode: {\n-                      ilike: `%${filterValue}%`,\n-                    },\n-                  } as PhonesFilter,\n-                },\n-              };\n-            default:\n-              throw new Error(\n-                `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n-              );\n-          }\n-        }\n-        default:\n-          throw new Error(\n-            `Unknown subfield ${subFieldName} for ${filterType} filter`,\n-          );\n-      }\n-    }\n-    case 'BOOLEAN': {\n-      return {\n-        [correspondingFieldMetadataItem.name]: {\n-          eq: recordFilter.value === 'true',\n-        } as BooleanFilter,\n-      };\n-    }\n-    case 'UUID': {\n-      const recordIds = arrayOfUuidOrVariableSchema.parse(recordFilter.value);\n-\n-      if (!isDefined(recordIds) || recordIds.length === 0) return;\n-\n-      switch (recordFilter.operand) {\n-        case RecordFilterOperand.IS:\n-          return {\n-            [correspondingFieldMetadataItem.name]: {\n-              in: recordIds,\n-            } as UUIDFilter,\n-          };\n-        default:\n-          throw new Error(\n-            `Unknown operand ${recordFilter.operand} for ${filterType} filter`,\n-          );\n-      }\n-    }\n-    default:\n-      throw new Error('Unknown filter type');\n-  }\n-};\n+        const parsedCurrencyCodes = arrayOfStringsOrVariablesSchema.\n\\ No newline at end of file\n",
    "pr_number": 16299,
    "title": "add `is not` operand on numeric fields",
    "test_files": [
      "packages/twenty-front/src/modules/object-record/object-filter-dropdown/utils/__tests__/getOperandsForFilterType.test.ts",
      "packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.spec.ts",
      "packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/__tests__/evaluate-filter-conditions.util.spec.ts"
    ],
    "code_files": [
      "packages/twenty-front/src/modules/object-record/record-filter/utils/getRecordFilterOperands.ts",
      "packages/twenty-front/src/modules/object-record/record-table/utils/buildRecordInputFromFilter.ts",
      "packages/twenty-front/src/modules/workflow/workflow-steps/workflow-actions/filter-action/utils/getStepFilterOperands.ts",
      "packages/twenty-server/src/modules/workflow/workflow-executor/workflow-actions/filter/utils/evaluate-filter-conditions.util.ts",
      "packages/twenty-shared/src/utils/filter/turnRecordFilterIntoGqlOperationFilter.ts"
    ]
  },
  {
    "instance_id": "PostHog__posthog.main.42599",
    "repo": "PostHog/posthog",
    "base_commit": "9d66861e8cf6e1d81d7b371a79e565a1a6273357",
    "bug_patch": "diff --git a/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts b/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts\nindex fe056d7..691afa7 100644\n--- a/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts\n+++ b/plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts\n@@ -382,185 +382,4 @@ describe.each([\n                             app_source: 'hog_function',\n                             app_source_id: erroringFunction.id,\n                             count: 1,\n-                            metric_kind: 'other',\n-                            metric_name: 'filtering_failed',\n-                            team_id: 2,\n-                            timestamp: expect.any(String),\n-                        },\n-                    },\n-                    {\n-                        topic: 'log_entries_test',\n-                        value: {\n-                            message:\n-                                'Error filtering event b3a1fe86-b10c-43cc-acaf-d208977608d0: Invalid HogQL bytecode, stack is empty, can not pop',\n-                        },\n-                    },\n-                ])\n-            })\n-        })\n-    })\n-})\n-\n-describe('hog flow processing', () => {\n-    let processor: CdpEventsConsumer | CdpInternalEventsConsumer\n-    let hub: Hub\n-    let team: Team\n-\n-    const insertHogFlow = async (hogFlow: HogFlow) => {\n-        const teamId = hogFlow.team_id ?? team.id\n-\n-        const item = await _insertHogFlow(hub.postgres, hogFlow)\n-        // Trigger the reload that django would do\n-        processor['hogFunctionManager']['onHogFunctionsReloaded'](teamId, [item.id])\n-        return item\n-    }\n-\n-    beforeEach(async () => {\n-        await resetTestDatabase()\n-        hub = await createHub()\n-        team = await getFirstTeam(hub)\n-        processor = new CdpEventsConsumer(hub)\n-\n-        // NOTE: We don't want to actually connect to Kafka for these tests as it is slow and we are testing the core logic only\n-        processor['kafkaConsumer'] = {\n-            connect: jest.fn(),\n-            disconnect: jest.fn(),\n-            isHealthy: jest.fn(),\n-        } as any\n-\n-        processor['cyclotronJobQueue'] = {\n-            queueInvocations: jest.fn(),\n-            startAsProducer: jest.fn(() => Promise.resolve()),\n-            stop: jest.fn(),\n-        } as unknown as jest.Mocked<CyclotronJobQueue>\n-\n-        await processor.start()\n-    })\n-\n-    afterEach(async () => {\n-        jest.setTimeout(10000)\n-        await processor.stop()\n-        await closeHub(hub)\n-    })\n-\n-    afterAll(() => {\n-        jest.useRealTimers()\n-    })\n-\n-    describe('createHogFlowInvocations', () => {\n-        let globals: HogFunctionInvocationGlobals\n-\n-        beforeEach(() => {\n-            globals = createHogExecutionGlobals({\n-                project: {\n-                    id: team.id,\n-                } as any,\n-                event: {\n-                    uuid: 'b3a1fe86-b10c-43cc-acaf-d208977608d0',\n-                    event: '$pageview',\n-                    properties: {\n-                        $current_url: 'https://posthog.com',\n-                        $lib_version: '1.0.0',\n-                    },\n-                } as any,\n-            })\n-        })\n-\n-        it('should not create hog flow invocations with no filters', async () => {\n-            const hogFlow = new FixtureHogFlowBuilder().withTeamId(team.id).build()\n-            hogFlow.trigger = {} as any\n-            await insertHogFlow(hogFlow)\n-\n-            const invocations = await processor['createHogFlowInvocations']([globals])\n-            expect(invocations).toHaveLength(0)\n-        })\n-\n-        it('should not create hog flow invocations with webhook triggers', async () => {\n-            const hogFlow = new FixtureHogFlowBuilder()\n-                .withTeamId(team.id)\n-                .withSimpleWorkflow({\n-                    trigger: {\n-                        type: 'webhook',\n-                        template_id: 'test',\n-                        inputs: {},\n-                    },\n-                })\n-                .build()\n-            await insertHogFlow(hogFlow)\n-\n-            const invocations = await processor['createHogFlowInvocations']([globals])\n-            expect(invocations).toHaveLength(0)\n-        })\n-\n-        it('should create hog flow invocations with matching filters', async () => {\n-            const hogFlow = await insertHogFlow(\n-                new FixtureHogFlowBuilder()\n-                    .withTeamId(team.id)\n-                    .withSimpleWorkflow({\n-                        trigger: {\n-                            type: 'event',\n-                            filters: HOG_FILTERS_EXAMPLES.pageview_or_autocapture_filter.filters ?? {},\n-                        },\n-                    })\n-                    .build()\n-            )\n-\n-            const noInvocations = await processor['createHogFlowInvocations']([\n-                {\n-                    ...globals,\n-                    event: {\n-                        ...globals.event,\n-                        event: 'not-a-pageview',\n-                    },\n-                },\n-            ])\n-\n-            expect(noInvocations).toHaveLength(0)\n-\n-            const invocations = await processor['createHogFlowInvocations']([globals])\n-            expect(invocations).toHaveLength(1)\n-            expect(invocations[0]).toMatchObject({\n-                functionId: hogFlow.id,\n-                hogFlow: {\n-                    id: hogFlow.id,\n-                },\n-                id: expect.any(String),\n-                queue: 'hogflow',\n-                queuePriority: 1,\n-                state: {\n-                    event: globals.event,\n-                    actionStepCount: 0,\n-                },\n-                teamId: 2,\n-            })\n-        })\n-\n-        it('should not produce billable_invocation metrics for hog flow invocations', async () => {\n-            await insertHogFlow(\n-                new FixtureHogFlowBuilder()\n-                    .withTeamId(team.id)\n-                    .withSimpleWorkflow({\n-                        trigger: {\n-                            type: 'event',\n-                            filters: HOG_FILTERS_EXAMPLES.pageview_or_autocapture_filter.filters ?? {},\n-                        },\n-                    })\n-                    .build()\n-            )\n-\n-            await processor['createHogFlowInvocations']([globals])\n-\n-            const producedMetrics =\n-                mockProducerObserver.getProducedKafkaMessagesForTopic('clickhouse_app_metrics2_test')\n-            expect(producedMetrics).not.toEqual(\n-                expect.arrayContaining([\n-                    expect.objectContaining({\n-                        value: expect.objectContaining({\n-                            metric_name: 'billable_invocation',\n-                        }),\n-                    }),\n-                ])\n-            )\n-        })\n-    })\n-})\n+                            metric_kind: 'other\n\\ No newline at end of file\ndiff --git a/plugin-server/src/cdp/consumers/cdp-events.consumer.ts b/plugin-server/src/cdp/consumers/cdp-events.consumer.ts\nindex 5236d50..15d0e4f 100644\n--- a/plugin-server/src/cdp/consumers/cdp-events.consumer.ts\n+++ b/plugin-server/src/cdp/consumers/cdp-events.consumer.ts\n@@ -352,97 +352,4 @@ export class CdpEventsConsumer extends CdpConsumerBase {\n         })\n \n         // Now we can filter by masking configs\n-        const { masked, notMasked: notMaskedInvocations } = await this.hogMasker.filterByMasking(validInvocations)\n-\n-        this.hogFunctionMonitoringService.queueAppMetrics(\n-            masked.map((item) => ({\n-                team_id: item.teamId,\n-                app_source_id: item.functionId,\n-                metric_kind: 'other',\n-                metric_name: 'masked',\n-                count: 1,\n-            })),\n-            'hog_flow'\n-        )\n-\n-        const triggeredInvocationsMetrics: MinimalAppMetric[] = []\n-\n-        notMaskedInvocations.forEach((item) => {\n-            triggeredInvocationsMetrics.push({\n-                team_id: item.teamId,\n-                app_source_id: item.functionId,\n-                metric_kind: 'other',\n-                metric_name: 'triggered',\n-                count: 1,\n-            })\n-        })\n-\n-        this.hogFunctionMonitoringService.queueAppMetrics(triggeredInvocationsMetrics, 'hog_flow')\n-\n-        return notMaskedInvocations\n-    }\n-\n-    @instrumented('cdpConsumer.handleEachBatch.parseKafkaMessages')\n-    public async _parseKafkaBatch(messages: Message[]): Promise<HogFunctionInvocationGlobals[]> {\n-        const events: HogFunctionInvocationGlobals[] = []\n-\n-        await Promise.all(\n-            messages.map(async (message) => {\n-                try {\n-                    const clickHouseEvent = parseJSON(message.value!.toString()) as RawClickHouseEvent\n-\n-                    const [teamHogFunctions, teamHogFlows, team] = await Promise.all([\n-                        this.hogFunctionManager.getHogFunctionsForTeam(clickHouseEvent.team_id, this.hogTypes),\n-                        this.hogFlowManager.getHogFlowsForTeam(clickHouseEvent.team_id),\n-                        this.hub.teamManager.getTeam(clickHouseEvent.team_id),\n-                    ])\n-\n-                    if ((!teamHogFunctions.length && !teamHogFlows.length) || !team) {\n-                        return\n-                    }\n-\n-                    events.push(convertToHogFunctionInvocationGlobals(clickHouseEvent, team, this.hub.SITE_URL))\n-                } catch (e) {\n-                    logger.error('Error parsing message', e)\n-                    counterParseError.labels({ error: e.message }).inc()\n-                }\n-            })\n-        )\n-\n-        return events\n-    }\n-\n-    public async start(): Promise<void> {\n-        await super.start()\n-        // Make sure we are ready to produce to cyclotron first\n-        await this.cyclotronJobQueue.startAsProducer()\n-        // Start consuming messages\n-        await this.kafkaConsumer.connect(async (messages) => {\n-            logger.info('\ud83d\udd01', `${this.name} - handling batch`, {\n-                size: messages.length,\n-            })\n-\n-            return await instrumentFn('cdpConsumer.handleEachBatch', async () => {\n-                const invocationGlobals = await this._parseKafkaBatch(messages)\n-                const { backgroundTask } = await this.processBatch(invocationGlobals)\n-\n-                return { backgroundTask }\n-            })\n-        })\n-    }\n-\n-    public async stop(): Promise<void> {\n-        logger.info('\ud83d\udca4', 'Stopping consumer...')\n-        await this.kafkaConsumer.disconnect()\n-        logger.info('\ud83d\udca4', 'Stopping cyclotron job queue...')\n-        await this.cyclotronJobQueue.stop()\n-        logger.info('\ud83d\udca4', 'Stopping consumer...')\n-        // IMPORTANT: super always comes last\n-        await super.stop()\n-        logger.info('\ud83d\udca4', 'Consumer stopped!')\n-    }\n-\n-    public isHealthy(): HealthCheckResult {\n-        return this.kafkaConsumer.isHealthy()\n-    }\n-}\n+        const { masked, notMasked: notMaskedInvocations } = await this.hogMasker.filterByMasking(\n\\ No newline at end of file\n",
    "pr_number": 42599,
    "title": "fix(workflows): dont bill for hogflow invocations",
    "test_files": [
      "plugin-server/src/cdp/consumers/cdp-events-consumer.test.ts"
    ],
    "code_files": [
      "plugin-server/src/cdp/consumers/cdp-events.consumer.ts"
    ]
  },
  {
    "instance_id": "PostHog__posthog.main.42640",
    "repo": "PostHog/posthog",
    "base_commit": "e1ac9f97469f120f9b0c2b28a86a1c286189486e",
    "bug_patch": "diff --git a/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts b/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\nindex c71605038780d..d24ed895f3be4 100644\n--- a/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\n+++ b/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\n@@ -33,6 +33,30 @@ describe('CorsPlugin', () => {\n         CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n         expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/my-image.js`)\n     })\n+\n+    it('can replace a stylesheet css link', () => {\n+        const el = document.createElement('link')\n+        el.setAttribute('rel', 'stylesheet')\n+        el.href = 'https://app.posthog.com/assets/styles.css'\n+        CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n+        expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/assets/styles.css`)\n+    })\n+\n+    it('can replace a stylesheet css link with query parameters', () => {\n+        const el = document.createElement('link')\n+        el.setAttribute('rel', 'stylesheet')\n+        el.href = 'https://app.posthog.com/assets/styles.css?v=123'\n+        CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n+        expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/assets/styles.css?v=123`)\n+    })\n+\n+    it.each([\n+        'https://app.posthog.com/styles.css',\n+        'https://app.posthog.com/styles.css?v=123',\n+        'https://app.posthog.com/assets/main.css?t=1234567890',\n+    ])('should replace CSS urls', (cssUrl) => {\n+        expect(CorsPlugin._replaceCSSUrl(cssUrl)).toEqual(`https://replay.ph-proxy.com/proxy?url=${cssUrl}`)\n+    })\n })\n \n describe('WindowTitlePlugin', () => {\ndiff --git a/frontend/src/scenes/session-recordings/player/rrweb/index.ts b/frontend/src/scenes/session-recordings/player/rrweb/index.ts\nindex ee36a8be2ea11..8dd021ca88428 100644\n--- a/frontend/src/scenes/session-recordings/player/rrweb/index.ts\n+++ b/frontend/src/scenes/session-recordings/player/rrweb/index.ts\n@@ -12,6 +12,7 @@ export const CorsPlugin: ReplayPlugin & {\n     _replaceFontCssUrls: (value: string | null) => string | null\n     _replaceFontUrl: (value: string) => string\n     _replaceJSUrl: (value: string) => string\n+    _replaceCSSUrl: (value: string) => string\n } = {\n     _replaceFontCssUrls: (value: string | null): string | null => {\n         return (\n@@ -30,6 +31,10 @@ export const CorsPlugin: ReplayPlugin & {\n         return value.replace(/^(https:\\/\\/\\S*(?:\\.js)\\S*)$/i, `${PROXY_URL}/proxy?url=$1`)\n     },\n \n+    _replaceCSSUrl: (value: string): string => {\n+        return value.replace(/^(https:\\/\\/\\S*(?:\\.css)\\S*)$/i, `${PROXY_URL}/proxy?url=$1`)\n+    },\n+\n     onBuild: (node) => {\n         if (node.nodeName === 'STYLE') {\n             const styleElement = node as HTMLStyleElement\n@@ -55,8 +60,11 @@ export const CorsPlugin: ReplayPlugin & {\n             if (!href) {\n                 return\n             }\n-            if (linkElement.getAttribute('rel') == 'modulepreload') {\n+            const rel = linkElement.getAttribute('rel')\n+            if (rel === 'modulepreload') {\n                 linkElement.href = CorsPlugin._replaceJSUrl(href)\n+            } else if (rel === 'stylesheet') {\n+                linkElement.href = CorsPlugin._replaceCSSUrl(href)\n             } else {\n                 linkElement.href = CorsPlugin._replaceFontUrl(href)\n             }\n",
    "pr_number": 42640,
    "title": "fix(replay): account for css stylesheets",
    "test_files": [
      "frontend/src/scenes/session-recordings/player/rrweb/index.test.ts"
    ],
    "code_files": [
      "frontend/src/scenes/session-recordings/player/rrweb/index.ts"
    ]
  },
  {
    "instance_id": "PostHog__posthog.main.42716",
    "repo": "PostHog/posthog",
    "base_commit": "7ade7ab65f97207781f2fce296da071725e3e955",
    "bug_patch": "diff --git a/products/logs/frontend/LogsScene.tsx b/products/logs/frontend/LogsScene.tsx\nindex d48921c..8491afd 100644\n--- a/products/logs/frontend/LogsScene.tsx\n+++ b/products/logs/frontend/LogsScene.tsx\n@@ -9,11 +9,13 @@ import {\n     LemonSegmentedButton,\n     LemonSelect,\n     LemonTable,\n+    SpinnerOverlay,\n     Tooltip,\n } from '@posthog/lemon-ui'\n \n import { CopyToClipboardInline } from 'lib/components/CopyToClipboard'\n import { ProductIntroduction } from 'lib/components/ProductIntroduction/ProductIntroduction'\n+import { Sparkline } from 'lib/components/Sparkline'\n import { TZLabel, TZLabelProps } from 'lib/components/TZLabel'\n import { ListHog } from 'lib/components/hedgehogs'\n import { FEATURE_FLAGS } from 'lib/constants'\n@@ -34,7 +36,6 @@ import { LogMessage, ProductKey } from '~/queries/schema/schema-general'\n import { PropertyOperator } from '~/types'\n \n import { LogTag } from 'products/logs/frontend/components/LogTag'\n-import { LogsSparkline } from 'products/logs/frontend/components/LogsSparkline'\n import { LogsTableRowActions } from 'products/logs/frontend/components/LogsTable/LogsTableRowActions'\n import { VirtualizedLogsList } from 'products/logs/frontend/components/VirtualizedLogsList'\n import { LogsFilterGroup } from 'products/logs/frontend/components/filters/LogsFilters/FilterGroup'\n@@ -53,8 +54,9 @@ export const scene: SceneExport = {\n }\n \n export function LogsScene(): JSX.Element {\n-    const { logsLoading } = useValues(logsLogic)\n-    const { runQuery, highlightNextLog, highlightPreviousLog, toggleExpandLog } = useActions(logsLogic)\n+    const { sparklineData, sparklineLoading, logsLoading } = useValues(logsLogic)\n+    const { runQuery, setDateRangeFromSparkline, highlightNextLog, highlightPreviousLog, toggleExpandLog } =\n+        useActions(logsLogic)\n     const { highlightedLogId: sceneHighlightedLogId } = useValues(logsLogic)\n \n     useEffect(() => {\n@@ -79,6 +81,10 @@ export function LogsScene(): JSX.Element {\n         [sceneHighlightedLogId, logsLoading, runQuery]\n     )\n \n+    const onSelectionChange = (selection: { startIndex: number; endIndex: number }): void => {\n+        setDateRangeFromSparkline(selection.startIndex, selection.endIndex)\n+    }\n+\n     return (\n         <SceneContent>\n             <SceneTitleSection\n@@ -109,7 +115,21 @@ export function LogsScene(): JSX.Element {\n                 isEmpty={false}\n             />\n             <Filters />\n-            <LogsSparkline />\n+            <div className=\"relative h-40 flex flex-col\">\n+                {sparklineData.data.length > 0 ? (\n+                    <Sparkline\n+                        labels={sparklineData.labels}\n+                        data={sparklineData.data}\n+                        className=\"w-full flex-1\"\n+                        onSelectionChange={onSelectionChange}\n+                    />\n+                ) : !sparklineLoading ? (\n+                    <div className=\"flex-1 text-muted flex items-center justify-center\">\n+                        No results matching filters\n+                    </div>\n+                ) : null}\n+                {sparklineLoading && <SpinnerOverlay />}\n+            </div>\n             <SceneDivider />\n             <LogsListContainer />\n         </SceneContent>\n@@ -341,309 +361,4 @@ function LogsTable({\n                                             pinned\n                                                 ? 'text-primary opacity-100'\n                                                 : 'text-muted opacity-0 group-hover:opacity-100'\n-                                        )}\n-                                    />\n-                                    <LogsTableRowActions log={record} />\n-                                </div>\n-                            )\n-                        },\n-                    },\n-                    {\n-                        title: 'Timestamp',\n-                        key: 'timestamp',\n-                        dataIndex: 'timestamp',\n-                        width: 180,\n-                        render: (_, { timestamp }) => (\n-                            <TZLabel time={timestamp} {...tzLabelFormat} showNow={false} showToday={false} />\n-                        ),\n-                    },\n-                    {\n-                        title: 'Level',\n-                        key: 'severity_text',\n-                        dataIndex: 'severity_text',\n-                        width: 100,\n-                        render: (_, record) => <LogTag level={record.severity_text} />,\n-                    },\n-                    {\n-                        title: 'Message',\n-                        key: 'body',\n-                        dataIndex: 'body',\n-                        render: (_, { cleanBody, parsedBody }) => {\n-                            if (parsedBody && prettifyJson) {\n-                                return (\n-                                    <pre className={cn('text-xs m-0', wrapBody ? '' : 'whitespace-nowrap')}>\n-                                        {JSON.stringify(parsedBody, null, 2)}\n-                                    </pre>\n-                                )\n-                            }\n-\n-                            return <div className={cn(wrapBody ? '' : 'whitespace-nowrap')}>{cleanBody}</div>\n-                        },\n-                    },\n-                ]}\n-                expandable={{\n-                    noIndent: true,\n-                    expandedRowRender: (log) => <ExpandedLog log={log} />,\n-                    isRowExpanded: (record) => expandedLogIds.has(record.uuid),\n-                    onRowExpand: (record) => toggleExpandLog(record.uuid),\n-                    onRowCollapse: (record) => toggleExpandLog(record.uuid),\n-                }}\n-            />\n-        </div>\n-    )\n-}\n-\n-const ExpandedLog = ({ log }: { log: LogMessage }): JSX.Element => {\n-    const { expandedAttributeBreaksdowns, tabId } = useValues(logsLogic)\n-    const { addFilter, toggleAttributeBreakdown } = useActions(logsLogic)\n-\n-    const attributes = log.attributes\n-    const rows = Object.entries(attributes).map(([key, value]) => ({ key, value }))\n-\n-    return (\n-        <LemonTable\n-            embedded\n-            showHeader={false}\n-            columns={[\n-                {\n-                    key: 'actions',\n-                    width: 0,\n-                    render: (_, record) => (\n-                        <div className=\"flex gap-x-0\">\n-                            <LemonButton\n-                                tooltip=\"Add as filter\"\n-                                size=\"xsmall\"\n-                                onClick={() => addFilter(record.key, record.value)}\n-                            >\n-                                <IconPlusSquare />\n-                            </LemonButton>\n-                            <LemonButton\n-                                tooltip=\"Exclude as filter\"\n-                                size=\"xsmall\"\n-                                onClick={() => addFilter(record.key, record.value, PropertyOperator.IsNot)}\n-                            >\n-                                <IconMinusSquare />\n-                            </LemonButton>\n-                            <LemonButton\n-                                tooltip=\"Show breakdown\"\n-                                size=\"xsmall\"\n-                                onClick={() => toggleAttributeBreakdown(record.key)}\n-                            >\n-                                <IconFilter />\n-                            </LemonButton>\n-                        </div>\n-                    ),\n-                },\n-                {\n-                    title: 'Key',\n-                    key: 'key',\n-                    dataIndex: 'key',\n-                    width: 0,\n-                },\n-                {\n-                    title: 'Value',\n-                    key: 'value',\n-                    dataIndex: 'value',\n-                    render: (_, record) => (\n-                        <CopyToClipboardInline\n-                            explicitValue={String(record.value)}\n-                            description=\"attribute value\"\n-                            iconSize=\"xsmall\"\n-                            iconPosition=\"start\"\n-                            selectable\n-                            className=\"gap-1\"\n-                        >\n-                            {String(record.value)}\n-                        </CopyToClipboardInline>\n-                    ),\n-                },\n-            ]}\n-            dataSource={rows}\n-            expandable={{\n-                noIndent: true,\n-                showRowExpansionToggle: false,\n-                isRowExpanded: (record) => expandedAttributeBreaksdowns.includes(record.key),\n-                expandedRowRender: (record) => (\n-                    <AttributeBreakdowns attribute={record.key} addFilter={addFilter} tabId={tabId} />\n-                ),\n-            }}\n-        />\n-    )\n-}\n-\n-const Filters = (): JSX.Element => {\n-    const { logsLoading, liveTailRunning, liveTailDisabledReason } = useValues(logsLogic)\n-    const { runQuery, zoomDateRange, setLiveTailRunning } = useActions(logsLogic)\n-\n-    return (\n-        <div className=\"flex flex-col gap-y-1.5\">\n-            <div className=\"flex justify-between gap-y-2 flex-wrap-reverse\">\n-                <div className=\"flex gap-x-1 gap-y-2 flex-wrap\">\n-                    <SeverityLevelsFilter />\n-                    <ServiceFilter />\n-                </div>\n-                <div className=\"flex gap-x-1\">\n-                    <LemonButton\n-                        size=\"small\"\n-                        icon={<IconMinusSquare />}\n-                        type=\"secondary\"\n-                        onClick={() => zoomDateRange(2)}\n-                    />\n-                    <LemonButton\n-                        size=\"small\"\n-                        icon={<IconPlusSquare />}\n-                        type=\"secondary\"\n-                        onClick={() => zoomDateRange(0.5)}\n-                    />\n-                    <DateRangeFilter />\n-                    <LemonButton\n-                        size=\"small\"\n-                        icon={<IconRefresh />}\n-                        type=\"secondary\"\n-                        onClick={() => runQuery()}\n-                        loading={logsLoading || liveTailRunning}\n-                        disabledReason={liveTailRunning ? 'Disable live tail to manually refresh' : undefined}\n-                    >\n-                        {liveTailRunning ? 'Tailing...' : logsLoading ? 'Loading...' : 'Search'}\n-                    </LemonButton>\n-                    <LemonButton\n-                        size=\"small\"\n-                        type={liveTailRunning ? 'primary' : 'secondary'}\n-                        icon={liveTailRunning ? <IconPauseCircle /> : <IconPlayCircle />}\n-                        onClick={() => setLiveTailRunning(!liveTailRunning)}\n-                        disabledReason={liveTailRunning ? undefined : liveTailDisabledReason}\n-                    >\n-                        Live tail\n-                    </LemonButton>\n-                </div>\n-            </div>\n-            <LogsFilterGroup />\n-        </div>\n-    )\n-}\n-\n-const DisplayOptions = (): JSX.Element => {\n-    const { orderBy, wrapBody, prettifyJson, logsPageSize, totalLogsMatchingFilters, parsedLogs, sparklineLoading } =\n-        useValues(logsLogic)\n-    const { setOrderBy, setWrapBody, setPrettifyJson, setLogsPageSize } = useActions(logsLogic)\n-\n-    return (\n-        <div className=\"flex justify-between\">\n-            <div className=\"flex gap-2\">\n-                <LemonSegmentedButton\n-                    value={orderBy}\n-                    onChange={setOrderBy}\n-                    options={[\n-                        {\n-                            value: 'earliest',\n-                            label: 'Earliest',\n-                        },\n-                        {\n-                            value: 'latest',\n-                            label: 'Latest',\n-                        },\n-                    ]}\n-                    size=\"small\"\n-                />\n-                <LemonCheckbox checked={wrapBody} bordered onChange={setWrapBody} label=\"Wrap message\" size=\"small\" />\n-                <LemonCheckbox\n-                    checked={prettifyJson}\n-                    bordered\n-                    onChange={setPrettifyJson}\n-                    label=\"Prettify JSON\"\n-                    size=\"small\"\n-                />\n-            </div>\n-            <div className=\"flex items-center gap-4\">\n-                {!sparklineLoading && totalLogsMatchingFilters > 0 && (\n-                    <span className=\"text-muted text-xs\">\n-                        Showing {humanFriendlyNumber(parsedLogs.length)} of{' '}\n-                        {humanFriendlyNumber(totalLogsMatchingFilters)} logs\n-                    </span>\n-                )}\n-                <LemonField.Pure label=\"Page size\" inline className=\"items-center gap-2\">\n-                    <LemonSelect\n-                        value={logsPageSize}\n-                        onChange={(value: number) => setLogsPageSize(value)}\n-                        size=\"small\"\n-                        type=\"secondary\"\n-                        options={[\n-                            { value: 100, label: '100' },\n-                            { value: 200, label: '200' },\n-                            { value: 500, label: '500' },\n-                            { value: 1000, label: '1000' },\n-                        ]}\n-                    />\n-                </LemonField.Pure>\n-                <span className=\"text-muted text-xs flex items-center gap-1\">\n-                    <KeyboardShortcut arrowup />\n-                    <KeyboardShortcut arrowdown />\n-                    or\n-                    <KeyboardShortcut j />\n-                    <KeyboardShortcut k />\n-                    navigate\n-                    <span className=\"mx-1\">\u00b7</span>\n-                    <KeyboardShortcut enter />\n-                    expand\n-                    <span className=\"mx-1\">\u00b7</span>\n-                    <KeyboardShortcut r />\n-                    refresh\n-                </span>\n-            </div>\n-        </div>\n-    )\n-}\n-\n-const VirtualizedLogsListDisplayOptions = (): JSX.Element => {\n-    const { orderBy, wrapBody, prettifyJson, totalLogsMatchingFilters, sparklineLoading } = useValues(logsLogic)\n-    const { setOrderBy, setWrapBody, setPrettifyJson } = useActions(logsLogic)\n-\n-    return (\n-        <div className=\"flex justify-between\">\n-            <div className=\"flex gap-2\">\n-                <LemonSegmentedButton\n-                    value={orderBy}\n-                    onChange={setOrderBy}\n-                    options={[\n-                        {\n-                            value: 'earliest',\n-                            label: 'Earliest',\n-                        },\n-                        {\n-                            value: 'latest',\n-                            label: 'Latest',\n-                        },\n-                    ]}\n-                    size=\"small\"\n-                />\n-                <LemonCheckbox checked={wrapBody} bordered onChange={setWrapBody} label=\"Wrap message\" size=\"small\" />\n-                <LemonCheckbox\n-                    checked={prettifyJson}\n-                    bordered\n-                    onChange={setPrettifyJson}\n-                    label=\"Prettify JSON\"\n-                    size=\"small\"\n-                />\n-            </div>\n-            <div className=\"flex items-center gap-4\">\n-                {!sparklineLoading && totalLogsMatchingFilters > 0 && (\n-                    <span className=\"text-muted text-xs\">{humanFriendlyNumber(totalLogsMatchingFilters)} logs</span>\n-                )}\n-                <span className=\"text-muted text-xs flex items-center gap-1\">\n-                    <KeyboardShortcut arrowup />\n-                    <KeyboardShortcut arrowdown />\n-                    or\n-                    <KeyboardShortcut j />\n-                    <KeyboardShortcut k />\n-                    navigate\n-                    <span className=\"mx-1\">\u00b7</span>\n-                    <KeyboardShortcut enter />\n-                    expand\n-                    <span className=\"mx-1\">\u00b7</span>\n-                    <KeyboardShortcut r />\n-                    refresh\n-                </span>\n-            </div>\n-        </div>\n-    )\n-}\n+                                        )}\n\\ No newline at end of file\ndiff --git a/products/logs/frontend/components/LogsSparkline.tsx b/products/logs/frontend/components/LogsSparkline.tsx\ndeleted file mode 100644\nindex 0a75f25..0000000\n--- a/products/logs/frontend/components/LogsSparkline.tsx\n+++ /dev/null\n@@ -1,142 +0,0 @@\n-import { useActions, useValues } from 'kea'\n-import { useCallback, useMemo } from 'react'\n-\n-import { LemonSelect, SpinnerOverlay } from '@posthog/lemon-ui'\n-\n-import { AnyScaleOptions, Sparkline } from 'lib/components/Sparkline'\n-import { dayjs } from 'lib/dayjs'\n-import { shortTimeZone } from 'lib/utils'\n-import { teamLogic } from 'scenes/teamLogic'\n-\n-import { SparklineTimezone, logsLogic } from '../logsLogic'\n-\n-export function LogsSparkline(): JSX.Element {\n-    const { sparklineData, sparklineLoading, sparklineTimezone } = useValues(logsLogic)\n-    const { setDateRangeFromSparkline, setSparklineTimezone } = useActions(logsLogic)\n-    const { timezone: projectTimezone } = useValues(teamLogic)\n-\n-    const deviceTimezone = shortTimeZone()\n-\n-    // Determine which timezone string to use for formatting\n-    const activeTimezone = useMemo(() => {\n-        switch (sparklineTimezone) {\n-            case SparklineTimezone.UTC:\n-                return 'UTC'\n-            case SparklineTimezone.Project:\n-                return projectTimezone\n-            case SparklineTimezone.Device:\n-            default:\n-                return undefined // undefined means local\n-        }\n-    }, [sparklineTimezone, projectTimezone])\n-\n-    // Build timezone options, deduplicating if any match\n-    const timezoneOptions = useMemo(() => {\n-        const options: { value: SparklineTimezone; label: string }[] = [{ value: SparklineTimezone.UTC, label: 'UTC' }]\n-\n-        const projectTzLabel = shortTimeZone(projectTimezone) ?? projectTimezone\n-        if (projectTimezone !== 'UTC') {\n-            options.push({ value: SparklineTimezone.Project, label: `Project (${projectTzLabel})` })\n-        }\n-\n-        if (deviceTimezone && deviceTimezone !== 'UTC' && deviceTimezone !== projectTzLabel) {\n-            options.push({ value: SparklineTimezone.Device, label: `Device (${deviceTimezone})` })\n-        }\n-\n-        return options\n-    }, [projectTimezone, deviceTimezone])\n-\n-    const showTimezoneSelector = timezoneOptions.length > 1\n-\n-    const { timeUnit, tickFormat } = useMemo(() => {\n-        if (!sparklineData.dates.length) {\n-            return { timeUnit: 'hour' as const, tickFormat: 'HH:mm:ss' }\n-        }\n-        const firstDate = dayjs(sparklineData.dates[0])\n-        const lastDate = dayjs(sparklineData.dates[sparklineData.dates.length - 1])\n-        const hoursDiff = lastDate.diff(firstDate, 'hours')\n-\n-        if (hoursDiff <= 1) {\n-            return { timeUnit: 'second' as const, tickFormat: 'HH:mm:ss' }\n-        } else if (hoursDiff <= 6) {\n-            return { timeUnit: 'minute' as const, tickFormat: 'HH:mm:ss' }\n-        } else if (hoursDiff <= 48) {\n-            return { timeUnit: 'hour' as const, tickFormat: 'HH:mm' }\n-        }\n-        return { timeUnit: 'day' as const, tickFormat: 'D MMM HH:mm' }\n-    }, [sparklineData.dates])\n-\n-    const withXScale = useCallback(\n-        (scale: AnyScaleOptions): AnyScaleOptions => {\n-            return {\n-                ...scale,\n-                type: 'timeseries',\n-                ticks: {\n-                    display: true,\n-                    maxRotation: 0,\n-                    maxTicksLimit: 6,\n-                    font: {\n-                        size: 10,\n-                        lineHeight: 1,\n-                    },\n-                    callback: function (value: string | number) {\n-                        const d = activeTimezone ? dayjs(value).tz(activeTimezone) : dayjs(value)\n-                        return d.format(tickFormat)\n-                    },\n-                },\n-                time: {\n-                    unit: timeUnit,\n-                },\n-            } as AnyScaleOptions\n-        },\n-        [timeUnit, tickFormat, activeTimezone]\n-    )\n-\n-    const renderLabel = useCallback(\n-        (label: string): string => {\n-            const d = activeTimezone ? dayjs(label).tz(activeTimezone) : dayjs(label)\n-            const tz = activeTimezone === 'UTC' ? 'UTC' : (shortTimeZone(activeTimezone, d.toDate()) ?? 'Local')\n-            return `${d.format('D MMM YYYY HH:mm:ss')} ${tz}`\n-        },\n-        [activeTimezone]\n-    )\n-\n-    const sparklineLabels = useMemo(() => {\n-        return sparklineData.dates.map((date) => dayjs(date).toISOString())\n-    }, [sparklineData.dates])\n-\n-    const onSelectionChange = useCallback(\n-        (selection: { startIndex: number; endIndex: number }): void => {\n-            setDateRangeFromSparkline(selection.startIndex, selection.endIndex)\n-        },\n-        [setDateRangeFromSparkline]\n-    )\n-\n-    return (\n-        <div className=\"relative h-40 flex flex-col\">\n-            {showTimezoneSelector && (\n-                <div className=\"absolute top-1 right-1 z-10\">\n-                    <LemonSelect\n-                        size=\"xsmall\"\n-                        value={sparklineTimezone}\n-                        onChange={(value) => value && setSparklineTimezone(value)}\n-                        options={timezoneOptions}\n-                    />\n-                </div>\n-            )}\n-            {sparklineData.data.length > 0 ? (\n-                <Sparkline\n-                    labels={sparklineLabels}\n-                    data={sparklineData.data}\n-                    className=\"w-full flex-1\"\n-                    onSelectionChange={onSelectionChange}\n-                    withXScale={withXScale}\n-                    renderLabel={renderLabel}\n-                />\n-            ) : !sparklineLoading ? (\n-                <div className=\"flex-1 text-muted flex items-center justify-center\">No results matching filters</div>\n-            ) : null}\n-            {sparklineLoading && <SpinnerOverlay />}\n-        </div>\n-    )\n-}\ndiff --git a/products/logs/frontend/logsLogic.test.ts b/products/logs/frontend/logsLogic.test.ts\nindex d8a6a00..3a11b16 100644\n--- a/products/logs/frontend/logsLogic.test.ts\n+++ b/products/logs/frontend/logsLogic.test.ts\n@@ -3,7 +3,7 @@ import { expectLogic } from 'kea-test-utils'\n import { LogMessage } from '~/queries/schema/schema-general'\n import { initKeaTests } from '~/test/init'\n \n-import { SparklineTimezone, logsLogic } from './logsLogic'\n+import { logsLogic } from './logsLogic'\n \n const createMockLog = (uuid: string): LogMessage => ({\n     uuid,\n@@ -194,24 +194,4 @@ describe('logsLogic', () => {\n             })\n         })\n     })\n-\n-    describe('sparklineTimezone', () => {\n-        it('updates when setSparklineTimezone is called', async () => {\n-            await expectLogic(logic, () => {\n-                logic.actions.setSparklineTimezone(SparklineTimezone.Device)\n-            })\n-                .toDispatchActions(['setSparklineTimezone'])\n-                .toMatchValues({\n-                    sparklineTimezone: SparklineTimezone.Device,\n-                })\n-\n-            await expectLogic(logic, () => {\n-                logic.actions.setSparklineTimezone(SparklineTimezone.UTC)\n-            })\n-                .toDispatchActions(['setSparklineTimezone'])\n-                .toMatchValues({\n-                    sparklineTimezone: SparklineTimezone.UTC,\n-                })\n-        })\n-    })\n-})\n+})\n\\ No newline at end of file\ndiff --git a/products/logs/frontend/logsLogic.tsx b/products/logs/frontend/logsLogic.tsx\nindex a0b3774..670b943 100644\n--- a/products/logs/frontend/logsLogic.tsx\n+++ b/products/logs/frontend/logsLogic.tsx\n@@ -38,12 +38,6 @@ const NEW_QUERY_STARTED_ERROR_MESSAGE = 'new query started' as const\n const DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS = 1000\n const DEFAULT_LIVE_TAIL_POLL_INTERVAL_MAX_MS = 5000\n \n-export enum SparklineTimezone {\n-    UTC = 'utc',\n-    Project = 'project',\n-    Device = 'device',\n-}\n-\n const parseLogAttributes = (logs: LogMessage[]): void => {\n     logs.forEach((row) => {\n         Object.keys(row.attributes).forEach((key) => {\n@@ -53,6 +47,12 @@ const parseLogAttributes = (logs: LogMessage[]): void => {\n     })\n }\n \n+export enum SparklineTimezone {\n+    UTC = 'utc',\n+    Project = 'project',\n+    Device = 'device',\n+}\n+\n export interface LogsLogicProps {\n     tabId: string\n }\n@@ -263,7 +263,6 @@ export const logsLogic = kea<logsLogicType>([\n         expireLiveTail: () => true,\n         setLiveTailExpired: (liveTailExpired: boolean) => ({ liveTailExpired }),\n         addLogsToSparkline: (logs: LogMessage[]) => logs,\n-        setSparklineTimezone: (sparklineTimezone: SparklineTimezone) => ({ sparklineTimezone }),\n     }),\n \n     reducers({\n@@ -346,711 +345,4 @@ export const logsLogic = kea<logsLogicType>([\n         logsAbortController: [\n             null as AbortController | null,\n             {\n-                setLogsAbortController: (_, { logsAbortController }) => logsAbortController,\n-            },\n-        ],\n-        sparklineAbortController: [\n-            null as AbortController | null,\n-            {\n-                setSparklineAbortController: (_, { sparklineAbortController }) => sparklineAbortController,\n-            },\n-        ],\n-        liveTailAbortController: [\n-            null as AbortController | null,\n-            {\n-                setLiveTailAbortController: (_, { liveTailAbortController }) => liveTailAbortController,\n-            },\n-        ],\n-        hasRunQuery: [\n-            false as boolean,\n-            {\n-                fetchLogsSuccess: () => true,\n-                fetchLogsFailure: () => true,\n-            },\n-        ],\n-        logsLoading: [\n-            false as boolean,\n-            {\n-                fetchLogs: () => true,\n-                fetchLogsSuccess: () => false,\n-                fetchLogsFailure: () => true,\n-                fetchNextLogsPage: () => true,\n-                fetchNextLogsPageSuccess: () => false,\n-                fetchNextLogsPageFailure: () => true,\n-            },\n-        ],\n-\n-        sparklineLoading: [\n-            false as boolean,\n-            {\n-                fetchSparkline: () => true,\n-                fetchSparklineSuccess: () => false,\n-                fetchSparklineFailure: () => true,\n-            },\n-        ],\n-        openFilterOnInsert: [\n-            false as boolean,\n-            {\n-                setFilterGroup: (_, { openFilterOnInsert }) => openFilterOnInsert,\n-            },\n-        ],\n-        expandedAttributeBreaksdowns: [\n-            [] as string[],\n-            {\n-                setExpandedAttributeBreaksdowns: (_, { expandedAttributeBreaksdowns }) => expandedAttributeBreaksdowns,\n-            },\n-        ],\n-        pinnedLogs: [\n-            [] as LogMessage[],\n-            { persist: true },\n-            {\n-                pinLog: (state, { log }) => [...state, log],\n-                unpinLog: (state, { logId }) => state.filter((log) => log.uuid !== logId),\n-            },\n-        ],\n-        liveTailRunning: [\n-            false as boolean,\n-            {\n-                setLiveTailRunning: (_, { enabled }) => enabled,\n-                runQuery: () => false,\n-            },\n-        ],\n-        sparklineTimezone: [\n-            SparklineTimezone.UTC as SparklineTimezone,\n-            { persist: true },\n-            {\n-                setSparklineTimezone: (_, { sparklineTimezone }) => sparklineTimezone,\n-            },\n-        ],\n-        liveTailPollInterval: [\n-            DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS as number,\n-            {\n-                setLiveTailInterval: (_, { interval }) => interval,\n-            },\n-        ],\n-        highlightedLogId: [\n-            DEFAULT_HIGHLIGHTED_LOG_ID,\n-            {\n-                setHighlightedLogId: (_, { highlightedLogId }) => highlightedLogId,\n-            },\n-        ],\n-        hasMoreLogsToLoad: [\n-            true as boolean,\n-            {\n-                setHasMoreLogsToLoad: (_, { hasMoreLogsToLoad }) => hasMoreLogsToLoad,\n-                clearLogs: () => true,\n-            },\n-        ],\n-        expandedLogIds: [\n-            new Set<string>(),\n-            {\n-                toggleExpandLog: (state, { logId }) => {\n-                    const newSet = new Set(state)\n-                    if (newSet.has(logId)) {\n-                        newSet.delete(logId)\n-                    } else {\n-                        newSet.add(logId)\n-                    }\n-                    return newSet\n-                },\n-                clearLogs: () => new Set<string>(),\n-            },\n-        ],\n-    }),\n-\n-    loaders(({ values, actions }) => ({\n-        logs: [\n-            [] as LogMessage[],\n-            {\n-                clearLogs: () => [],\n-                truncateLogs: ({ limit }) => values.logs.slice(0, limit),\n-                fetchLogs: async () => {\n-                    const logsController = new AbortController()\n-                    const signal = logsController.signal\n-                    actions.cancelInProgressLogs(logsController)\n-\n-                    const response = await api.logs.query({\n-                        query: {\n-                            limit: values.initialLogsLimit ?? values.logsPageSize,\n-                            orderBy: values.orderBy,\n-                            dateRange: values.utcDateRange,\n-                            searchTerm: values.searchTerm,\n-                            filterGroup: values.filterGroup as PropertyGroupFilter,\n-                            severityLevels: values.severityLevels,\n-                            serviceNames: values.serviceNames,\n-                        },\n-                        signal,\n-                    })\n-                    actions.setLogsAbortController(null)\n-                    actions.setHasMoreLogsToLoad(!!response.hasMore)\n-                    parseLogAttributes(response.results)\n-                    return response.results\n-                },\n-                fetchNextLogsPage: async ({ limit }, breakpoint) => {\n-                    const logsController = new AbortController()\n-                    const signal = logsController.signal\n-                    actions.cancelInProgressLogs(logsController)\n-\n-                    let dateRange: DateRange\n-\n-                    if (values.orderBy === 'earliest') {\n-                        if (!values.newestLogTimestamp) {\n-                            return values.logs\n-                        }\n-                        dateRange = {\n-                            date_from: values.newestLogTimestamp,\n-                            date_to: values.utcDateRange.date_to,\n-                        }\n-                    } else {\n-                        if (!values.oldestLogTimestamp) {\n-                            return values.logs\n-                        }\n-                        dateRange = {\n-                            date_from: values.utcDateRange.date_from,\n-                            date_to: values.oldestLogTimestamp,\n-                        }\n-                    }\n-                    await breakpoint(300)\n-                    const response = await api.logs.query({\n-                        query: {\n-                            limit: limit ?? values.logsPageSize,\n-                            orderBy: values.orderBy,\n-                            dateRange,\n-                            searchTerm: values.searchTerm,\n-                            filterGroup: values.filterGroup as PropertyGroupFilter,\n-                            severityLevels: values.severityLevels,\n-                            serviceNames: values.serviceNames,\n-                        },\n-                        signal,\n-                    })\n-                    actions.setLogsAbortController(null)\n-                    actions.setHasMoreLogsToLoad(!!response.hasMore)\n-                    parseLogAttributes(response.results)\n-                    return [...values.logs, ...response.results]\n-                },\n-                setLogs: ({ logs }) => logs,\n-            },\n-        ],\n-        sparkline: [\n-            [] as any[],\n-            {\n-                fetchSparkline: async () => {\n-                    const sparklineController = new AbortController()\n-                    const signal = sparklineController.signal\n-                    actions.cancelInProgressSparkline(sparklineController)\n-\n-                    const response = await api.logs.sparkline({\n-                        query: {\n-                            orderBy: values.orderBy,\n-                            dateRange: values.utcDateRange,\n-                            searchTerm: values.searchTerm,\n-                            filterGroup: values.filterGroup as PropertyGroupFilter,\n-                            severityLevels: values.severityLevels,\n-                            serviceNames: values.serviceNames,\n-                        },\n-                        signal,\n-                    })\n-                    actions.setSparklineAbortController(null)\n-                    return response\n-                },\n-                setSparkline: ({ sparkline }) => sparkline,\n-            },\n-        ],\n-    })),\n-\n-    selectors({\n-        tabId: [(_, p) => [p.tabId], (tabId: string) => tabId],\n-        liveTailDisabledReason: [\n-            (s) => [s.orderBy, s.dateRange, s.logsLoading, s.liveTailExpired],\n-            (\n-                orderBy: LogsQuery['orderBy'],\n-                dateRange: DateRange,\n-                logsLoading: boolean,\n-                liveTailExpired: boolean\n-            ): string | undefined => {\n-                if (orderBy !== 'latest') {\n-                    return 'Live tail only works with \"Latest\" ordering'\n-                }\n-\n-                if (dateRange.date_to) {\n-                    return 'Live tail requires an open-ended time range'\n-                }\n-\n-                if (logsLoading) {\n-                    return 'Wait for query to finish'\n-                }\n-\n-                if (liveTailExpired) {\n-                    return 'Live tail has expired, run search again to live tail'\n-                }\n-\n-                return undefined\n-            },\n-        ],\n-        utcDateRange: [\n-            (s) => [s.dateRange],\n-            (dateRange) => ({\n-                date_from: dayjs(dateRange.date_from).isValid()\n-                    ? dayjs(dateRange.date_from).toISOString()\n-                    : dateRange.date_from,\n-                date_to: dayjs(dateRange.date_to).isValid()\n-                    ? dayjs(dateRange.date_to).toISOString()\n-                    : dateRange.date_to,\n-                explicitDate: dateRange.explicitDate,\n-            }),\n-        ],\n-        parsedLogs: [\n-            (s) => [s.logs],\n-            (logs: LogMessage[]): ParsedLogMessage[] => {\n-                const seen = new Set<string>()\n-                const result: ParsedLogMessage[] = []\n-\n-                for (const log of logs) {\n-                    if (seen.has(log.uuid)) {\n-                        continue\n-                    }\n-                    seen.add(log.uuid)\n-                    const cleanBody = colors.unstyle(log.body)\n-                    let parsedBody: JsonType | null = null\n-                    try {\n-                        parsedBody = JSON.parse(cleanBody)\n-                    } catch {\n-                        // Not JSON, that's fine\n-                    }\n-                    result.push({ ...log, cleanBody, parsedBody })\n-                }\n-\n-                return result\n-            },\n-        ],\n-        pinnedParsedLogs: [\n-            (s) => [s.pinnedLogs],\n-            (pinnedLogs: LogMessage[]): ParsedLogMessage[] => {\n-                return pinnedLogs.map((log: LogMessage) => {\n-                    const cleanBody = colors.unstyle(log.body)\n-                    let parsedBody: JsonType | null = null\n-                    try {\n-                        parsedBody = JSON.parse(cleanBody)\n-                    } catch {\n-                        // Not JSON, that's fine\n-                    }\n-                    return { ...log, cleanBody, parsedBody }\n-                })\n-            },\n-        ],\n-        isPinned: [\n-            (s) => [s.pinnedLogs],\n-            (pinnedLogs: LogMessage[]) => (logId: string) => pinnedLogs.some((log) => log.uuid === logId),\n-        ],\n-        visibleLogsTimeRange: [\n-            (s) => [s.parsedLogs, s.orderBy],\n-            (\n-                parsedLogs: ParsedLogMessage[],\n-                orderBy: LogsQuery['orderBy']\n-            ): { date_from: string; date_to: string } | null => {\n-                if (parsedLogs.length === 0) {\n-                    return null\n-                }\n-                const firstTimestamp = parsedLogs[0].timestamp\n-                const lastTimestamp = parsedLogs[parsedLogs.length - 1].timestamp\n-\n-                // When orderBy is 'latest', first log is newest, last log is oldest\n-                // When orderBy is 'earliest', first log is oldest, last log is newest\n-                if (orderBy === 'latest') {\n-                    return {\n-                        date_from: dayjs(lastTimestamp).toISOString(),\n-                        date_to: dayjs(firstTimestamp).toISOString(),\n-                    }\n-                }\n-                return {\n-                    date_from: dayjs(firstTimestamp).toISOString(),\n-                    date_to: dayjs(lastTimestamp).toISOString(),\n-                }\n-            },\n-        ],\n-        sparklineData: [\n-            (s) => [s.sparkline],\n-            (sparkline: any[]) => {\n-                let lastTime = ''\n-                let i = -1\n-                const labels: string[] = []\n-                const dates: string[] = []\n-                const data = Object.entries(\n-                    sparkline.reduce((accumulator, currentItem) => {\n-                        if (currentItem.time !== lastTime) {\n-                            labels.push(\n-                                humanFriendlyDetailedTime(currentItem.time, 'YYYY-MM-DD', 'HH:mm:ss', {\n-                                    showNow: false,\n-                                })\n-                            )\n-                            dates.push(currentItem.time)\n-                            lastTime = currentItem.time\n-                            i++\n-                        }\n-                        const key = currentItem.level\n-                        if (!accumulator[key]) {\n-                            accumulator[key] = [...Array(sparkline.length)].map(() => 0)\n-                        }\n-                        accumulator[key][i] += currentItem.count\n-                        return accumulator\n-                    }, {})\n-                )\n-                    .map(([level, data]) => ({\n-                        name: level,\n-                        values: data as number[],\n-                        color: {\n-                            fatal: 'danger-dark',\n-                            error: 'danger',\n-                            warn: 'warning',\n-                            info: 'brand-blue',\n-                            debug: 'muted',\n-                            trace: 'muted-alt',\n-                        }[level],\n-                    }))\n-                    .filter((series) => series.values.reduce((a, b) => a + b) > 0)\n-\n-                return { data, labels, dates }\n-            },\n-        ],\n-        oldestLogTimestamp: [\n-            (s) => [s.logs],\n-            (logs): string | null => {\n-                if (!logs.length) {\n-                    return null\n-                }\n-                const oldest = logs.reduce((min, log) => {\n-                    const logTime = dayjs(log.timestamp)\n-                    return !min || logTime.isBefore(dayjs(min)) ? log.timestamp : min\n-                }, logs[0].timestamp)\n-                return oldest\n-            },\n-        ],\n-        newestLogTimestamp: [\n-            (s) => [s.logs],\n-            (logs): string | null => {\n-                if (!logs.length) {\n-                    return null\n-                }\n-                const newest = logs.reduce((max, log) => {\n-                    const logTime = dayjs(log.timestamp)\n-                    return !max || logTime.isAfter(dayjs(max)) ? log.timestamp : max\n-                }, logs[0].timestamp)\n-                return newest\n-            },\n-        ],\n-        totalLogsMatchingFilters: [\n-            (s) => [s.sparkline],\n-            (sparkline): number => sparkline.reduce((sum, item) => sum + item.count, 0),\n-        ],\n-        logsRemainingToLoad: [\n-            (s) => [s.totalLogsMatchingFilters, s.logs],\n-            (totalLogsMatchingFilters, logs): number => totalLogsMatchingFilters - logs.length,\n-        ],\n-    }),\n-\n-    listeners(({ values, actions, cache }) => ({\n-        fetchLogsFailure: ({ error }) => {\n-            if (error !== NEW_QUERY_STARTED_ERROR_MESSAGE) {\n-                lemonToast.error(`Failed to load logs: ${error}`)\n-            }\n-        },\n-        fetchNextLogsPageFailure: ({ error }) => {\n-            if (error !== NEW_QUERY_STARTED_ERROR_MESSAGE) {\n-                lemonToast.error(`Failed to load more logs: ${error}`)\n-            }\n-        },\n-        runQuery: async ({ debounce }, breakpoint) => {\n-            if (debounce) {\n-                await breakpoint(debounce)\n-            }\n-            actions.clearLogs()\n-            actions.fetchLogs()\n-            actions.fetchSparkline()\n-            actions.cancelInProgressLiveTail(null)\n-        },\n-        cancelInProgressLogs: ({ logsAbortController }) => {\n-            if (values.logsAbortController !== null) {\n-                values.logsAbortController.abort(NEW_QUERY_STARTED_ERROR_MESSAGE)\n-            }\n-            actions.setLogsAbortController(logsAbortController)\n-        },\n-        cancelInProgressSparkline: ({ sparklineAbortController }) => {\n-            if (values.sparklineAbortController !== null) {\n-                values.sparklineAbortController.abort(NEW_QUERY_STARTED_ERROR_MESSAGE)\n-            }\n-            actions.setSparklineAbortController(sparklineAbortController)\n-        },\n-        cancelInProgressLiveTail: ({ liveTailAbortController }) => {\n-            if (values.liveTailAbortController !== null) {\n-                values.liveTailAbortController.abort('live tail request cancelled')\n-            }\n-            actions.setLiveTailAbortController(liveTailAbortController)\n-            cache.disposables.dispose('liveTailTimer')\n-        },\n-        toggleAttributeBreakdown: ({ key }) => {\n-            const breakdowns = [...values.expandedAttributeBreaksdowns]\n-            const index = breakdowns.indexOf(key)\n-            index >= 0 ? breakdowns.splice(index, 1) : breakdowns.push(key)\n-            actions.setExpandedAttributeBreaksdowns(breakdowns)\n-        },\n-        zoomDateRange: ({ multiplier }) => {\n-            const newDateRange = zoomDateRange(values.dateRange, multiplier)\n-            actions.setDateRange(newDateRange)\n-        },\n-        setDateRangeFromSparkline: ({ startIndex, endIndex }) => {\n-            const dates = values.sparklineData.dates\n-            const dateFrom = dates[startIndex]\n-            const dateTo = dates[endIndex + 1]\n-\n-            if (!dateFrom) {\n-                return\n-            }\n-\n-            // NOTE: I don't know how accurate this really is but its a good starting point\n-            const newDateRange = {\n-                date_from: dateFrom,\n-                date_to: dateTo,\n-            }\n-            actions.setDateRange(newDateRange)\n-        },\n-        expireLiveTail: async ({}, breakpoint) => {\n-            await breakpoint(30000)\n-            if (values.liveTailRunning) {\n-                return\n-            }\n-            actions.setLiveTailExpired(true)\n-        },\n-        addFilter: ({ key, value, operator }) => {\n-            const currentGroup = values.filterGroup.values[0] as UniversalFiltersGroup\n-\n-            const newGroup: UniversalFiltersGroup = {\n-                ...currentGroup,\n-                values: [\n-                    ...currentGroup.values,\n-                    {\n-                        key,\n-                        value: [value],\n-                        operator,\n-                        type: PropertyFilterType.Log,\n-                    },\n-                ],\n-            }\n-\n-            actions.setFilterGroup({ ...values.filterGroup, values: [newGroup] }, false)\n-        },\n-        togglePinLog: ({ logId }) => {\n-            const isPinned = values.pinnedLogs.some((log) => log.uuid === logId)\n-            if (isPinned) {\n-                actions.unpinLog(logId)\n-            } else {\n-                const logToPin = values.logs.find((log) => log.uuid === logId)\n-                if (logToPin) {\n-                    actions.pinLog(logToPin)\n-                }\n-            }\n-        },\n-        applyLogsPageSize: ({ logsPageSize }) => {\n-            const currentCount = values.logs.length\n-\n-            if (logsPageSize > currentCount && values.hasMoreLogsToLoad) {\n-                actions.fetchNextLogsPage(logsPageSize - currentCount)\n-            } else if (logsPageSize < currentCount) {\n-                actions.truncateLogs(logsPageSize)\n-                actions.setHasMoreLogsToLoad(true)\n-            }\n-        },\n-        highlightNextLog: () => {\n-            const logs = values.parsedLogs\n-            if (logs.length === 0) {\n-                return\n-            }\n-\n-            const currentIndex = values.highlightedLogId\n-                ? logs.findIndex((log) => log.uuid === values.highlightedLogId)\n-                : -1\n-\n-            if (currentIndex === -1) {\n-                actions.setHighlightedLogId(logs[0].uuid)\n-            } else if (currentIndex < logs.length - 1) {\n-                actions.setHighlightedLogId(logs[currentIndex + 1].uuid)\n-            } else if (values.hasMoreLogsToLoad && !values.logsLoading) {\n-                actions.fetchNextLogsPage()\n-            }\n-        },\n-        highlightPreviousLog: () => {\n-            const logs = values.parsedLogs\n-            if (logs.length === 0) {\n-                return\n-            }\n-\n-            const currentIndex = values.highlightedLogId\n-                ? logs.findIndex((log) => log.uuid === values.highlightedLogId)\n-                : -1\n-\n-            if (currentIndex === -1) {\n-                actions.setHighlightedLogId(logs[logs.length - 1].uuid)\n-            } else if (currentIndex > 0) {\n-                actions.setHighlightedLogId(logs[currentIndex - 1].uuid)\n-            }\n-        },\n-        setLiveTailRunning: async ({ enabled }) => {\n-            if (enabled) {\n-                actions.pollForNewLogs()\n-            } else {\n-                actions.cancelInProgressLiveTail(null)\n-                actions.expireLiveTail()\n-            }\n-        },\n-        pollForNewLogs: async () => {\n-            if (!values.liveTailRunning || values.orderBy !== 'latest' || document.hidden) {\n-                return\n-            }\n-\n-            const liveTailController = new AbortController()\n-            const signal = liveTailController.signal\n-            actions.cancelInProgressLiveTail(liveTailController)\n-            let duration = 0\n-\n-            try {\n-                const start = Date.now()\n-                const response = await api.logs.query({\n-                    query: {\n-                        limit: values.logsPageSize,\n-                        orderBy: values.orderBy,\n-                        dateRange: values.utcDateRange,\n-                        searchTerm: values.searchTerm,\n-                        filterGroup: values.filterGroup as PropertyGroupFilter,\n-                        severityLevels: values.severityLevels,\n-                        serviceNames: values.serviceNames,\n-                        liveLogsCheckpoint: values.liveLogsCheckpoint ?? undefined,\n-                    },\n-                    signal,\n-                })\n-                duration = Date.now() - start\n-\n-                if (response.results.length > 0) {\n-                    // the live_logs_checkpoint is the latest known timestamp for which we know we have all logs up to that point\n-                    // it's returned from clickhouse as a value on every log row - but the value is fixed per query\n-                    actions.setLiveLogsCheckpoint(response.results[0].live_logs_checkpoint ?? null)\n-                }\n-\n-                response.results.forEach((row) => {\n-                    Object.keys(row.attributes).forEach((key) => {\n-                        const value = row.attributes[key]\n-                        row.attributes[key] = typeof value === 'string' ? value : JSON.stringify(value)\n-                    })\n-                })\n-\n-                const existingUuids = new Set(values.logs.map((log) => log.uuid))\n-                const newLogs = response.results.filter((log) => !existingUuids.has(log.uuid))\n-\n-                if (newLogs.length > 0) {\n-                    actions.setLiveTailInterval(DEFAULT_LIVE_TAIL_POLL_INTERVAL_MS)\n-                    actions.setLogs(\n-                        [\n-                            ...newLogs.map((log) => ({ ...log, new: true })),\n-                            ...values.logs.map((log) => ({ ...log, new: false })),\n-                        ]\n-                            .sort((a, b) => Date.parse(b.timestamp) - Date.parse(a.timestamp))\n-                            .slice(0, values.logsPageSize)\n-                    )\n-                    actions.addLogsToSparkline(newLogs)\n-                } else {\n-                    const newInterval = Math.min(\n-                        values.liveTailPollInterval * 1.5,\n-                        DEFAULT_LIVE_TAIL_POLL_INTERVAL_MAX_MS\n-                    )\n-                    actions.setLiveTailInterval(newInterval)\n-                }\n-            } catch (error) {\n-                if (signal.aborted) {\n-                    return\n-                }\n-                console.error('Live tail polling error:', error)\n-                actions.setLiveTailRunning(false)\n-            } finally {\n-                actions.setLiveTailAbortController(null)\n-                if (values.liveTailRunning) {\n-                    cache.disposables.add(() => {\n-                        const timerId = setTimeout(\n-                            () => {\n-                                actions.pollForNewLogs()\n-                            },\n-                            Math.max(duration, values.liveTailPollInterval)\n-                        )\n-                        return () => clearTimeout(timerId)\n-                    }, 'liveTailTimer')\n-                }\n-            }\n-        },\n-        // insert logs into the sparkline data\n-        addLogsToSparkline: (logs: LogMessage[]) => {\n-            // if the sparkline hasn't loaded do nothing.\n-            if (!values.sparkline || values.sparkline.length < 2) {\n-                return\n-            }\n-\n-            const first_bucket = values.sparklineData.dates[0]\n-            const last_bucket = values.sparklineData.dates[values.sparklineData.dates.length - 1]\n-            const sparklineTimeWindow = dayjs(last_bucket).diff(first_bucket, 'seconds')\n-            const interval = dayjs(values.sparklineData.dates[1]).diff(first_bucket, 'seconds')\n-            let latest_time_bucket = dayjs(last_bucket)\n-\n-            const sparklineMap: Map<string, { time: string; level: string; count: number }> = new Map()\n-\n-            for (const bucket of values.sparkline) {\n-                const key = `${dayjs(bucket.time).toISOString()}_${bucket.level}`\n-                sparklineMap.set(key, { ...bucket })\n-            }\n-\n-            for (const log of logs) {\n-                const time_bucket = dayjs.unix(Math.floor(dayjs(log.timestamp).unix() / interval) * interval)\n-                if (time_bucket.isAfter(latest_time_bucket)) {\n-                    latest_time_bucket = time_bucket\n-                }\n-                const key = `${time_bucket.toISOString()}_${log.level}`\n-                if (sparklineMap.has(key)) {\n-                    sparklineMap.get(key)!.count += 1\n-                } else {\n-                    sparklineMap.set(key, { time: time_bucket.toISOString(), level: log.level, count: 1 })\n-                }\n-            }\n-            actions.setSparkline(\n-                Array.from(sparklineMap.values())\n-                    .sort((a, b) => dayjs(a.time).diff(dayjs(b.time)) || a.level.localeCompare(b.level))\n-                    .filter((item) => latest_time_bucket.diff(dayjs(item.time), 'seconds') <= sparklineTimeWindow)\n-            )\n-        },\n-        copyLinkToLog: ({ logId }: { logId: string }) => {\n-            const url = new URL(window.location.href)\n-            url.searchParams.set('highlightedLogId', logId)\n-            if (values.visibleLogsTimeRange) {\n-                url.searchParams.set(\n-                    'dateRange',\n-                    JSON.stringify({\n-                        date_from: values.visibleLogsTimeRange.date_from,\n-                        date_to: values.visibleLogsTimeRange.date_to,\n-                        explicitDate: true,\n-                    })\n-                )\n-            }\n-            if (values.logs.length > 0) {\n-                url.searchParams.set('initialLogsLimit', String(values.logs.length))\n-            }\n-            void copyToClipboard(url.toString(), 'link to log')\n-        },\n-    })),\n-\n-    events(({ values, actions }) => ({\n-        beforeUnmount: () => {\n-            actions.setLiveTailRunning(false)\n-            actions.cancelInProgressLiveTail(null)\n-            if (values.logsAbortController) {\n-                values.logsAbortController.abort('unmounting component')\n-            }\n-            if (values.sparklineAbortController) {\n-                values.sparklineAbortController.abort('unmounting component')\n-            }\n-        },\n-    })),\n-])\n+                setLogsAbortController: (_, { logsAbortController }) => logsAbort\n\\ No newline at end of file\n",
    "pr_number": 42716,
    "title": "feat(logs): add timezone support for sparkline and refactor component",
    "test_files": [
      "products/logs/frontend/logsLogic.test.ts"
    ],
    "code_files": [
      "products/logs/frontend/LogsScene.tsx",
      "products/logs/frontend/components/LogsSparkline.tsx",
      "products/logs/frontend/logsLogic.tsx"
    ]
  },
  {
    "instance_id": "PostHog__posthog.main.42729",
    "repo": "PostHog/posthog",
    "base_commit": "7e9060facaf104f63f506ff0ef5480d5704ea615",
    "bug_patch": "diff --git a/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts b/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\nindex c716050..56b25c1 100644\n--- a/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\n+++ b/frontend/src/scenes/session-recordings/player/rrweb/index.test.ts\n@@ -33,6 +33,30 @@ describe('CorsPlugin', () => {\n         CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n         expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/my-image.js`)\n     })\n+\n+    it('can replace a stylesheet css link', () => {\n+        const el = document.createElement('link')\n+        el.setAttribute('rel', 'stylesheet')\n+        el.href = 'https://app.posthog.com/assets/styles.css'\n+        CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n+        expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/assets/styles.css`)\n+    })\n+\n+    it('can replace a stylesheet css link with query parameters', () => {\n+        const el = document.createElement('link')\n+        el.setAttribute('rel', 'stylesheet')\n+        el.href = 'https://app.posthog.com/assets/styles.css?v=123'\n+        CorsPlugin.onBuild?.(el, { id: 1, replayer: null as unknown as any })\n+        expect(el.href).toEqual(`https://replay.ph-proxy.com/proxy?url=https://app.posthog.com/assets/styles.css?v=123`)\n+    })\n+\n+    it.each([\n+        'https://app.posthog.com/styles.css',\n+        'https://app.posthog.com/styles.css?v=123',\n+        'https://app.posthog.com/assets/main.css?t=1234567890',\n+    ])('should replace CSS urls', (cssUrl) => {\n+        expect(CorsPlugin._replaceCSSUrl(cssUrl)).toEqual(`https://replay.ph-proxy.com/proxy?url=${cssUrl}`)\n+    })\n })\n \n describe('WindowTitlePlugin', () => {\n@@ -230,4 +254,4 @@ describe('WindowTitlePlugin', () => {\n         )\n         expect(mockCallback).not.toHaveBeenCalled()\n     })\n-})\n+})\n\\ No newline at end of file\ndiff --git a/frontend/src/scenes/session-recordings/player/rrweb/index.ts b/frontend/src/scenes/session-recordings/player/rrweb/index.ts\nindex ee36a8b..c0da08d 100644\n--- a/frontend/src/scenes/session-recordings/player/rrweb/index.ts\n+++ b/frontend/src/scenes/session-recordings/player/rrweb/index.ts\n@@ -12,6 +12,7 @@ export const CorsPlugin: ReplayPlugin & {\n     _replaceFontCssUrls: (value: string | null) => string | null\n     _replaceFontUrl: (value: string) => string\n     _replaceJSUrl: (value: string) => string\n+    _replaceCSSUrl: (value: string) => string\n } = {\n     _replaceFontCssUrls: (value: string | null): string | null => {\n         return (\n@@ -30,6 +31,10 @@ export const CorsPlugin: ReplayPlugin & {\n         return value.replace(/^(https:\\/\\/\\S*(?:\\.js)\\S*)$/i, `${PROXY_URL}/proxy?url=$1`)\n     },\n \n+    _replaceCSSUrl: (value: string): string => {\n+        return value.replace(/^(https:\\/\\/\\S*(?:\\.css)\\S*)$/i, `${PROXY_URL}/proxy?url=$1`)\n+    },\n+\n     onBuild: (node) => {\n         if (node.nodeName === 'STYLE') {\n             const styleElement = node as HTMLStyleElement\n@@ -55,8 +60,11 @@ export const CorsPlugin: ReplayPlugin & {\n             if (!href) {\n                 return\n             }\n-            if (linkElement.getAttribute('rel') == 'modulepreload') {\n+            const rel = linkElement.getAttribute('rel')\n+            if (rel === 'modulepreload') {\n                 linkElement.href = CorsPlugin._replaceJSUrl(href)\n+            } else if (rel === 'stylesheet') {\n+                linkElement.href = CorsPlugin._replaceCSSUrl(href)\n             } else {\n                 linkElement.href = CorsPlugin._replaceFontUrl(href)\n             }\n@@ -241,4 +249,4 @@ export const makeLogger = (onIncrement: (count: number) => void): BuiltLogging =\n export const COMMON_REPLAYER_CONFIG: Partial<playerConfig> = {\n     triggerFocus: false,\n     insertStyleRules: [defaultStyleRules, shopifyShorthandCSSFix],\n-}\n+}\n\\ No newline at end of file\n",
    "pr_number": 42729,
    "title": "revert: \"fix(replay): account for css stylesheets\"",
    "test_files": [
      "frontend/src/scenes/session-recordings/player/rrweb/index.test.ts"
    ],
    "code_files": [
      "frontend/src/scenes/session-recordings/player/rrweb/index.ts"
    ]
  },
  {
    "instance_id": "PostHog__posthog.main.42628",
    "repo": "PostHog/posthog",
    "base_commit": "e0fc7f7a8bd41e0e75e494b9ac2356c6e4543a14",
    "bug_patch": "diff --git a/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts b/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts\nindex 757be6c..4f6cfe9 100644\n--- a/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts\n+++ b/frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts\n@@ -86,7 +86,7 @@ describe('topBarSettingsButtonLogic', () => {\n         it('returns other setting section IDs regardless of CRM feature flag state', async () => {\n             router.actions.push(urls.persons())\n             featureFlagLogic.actions.setFeatureFlags([], {\n-                [FEATURE_FLAGS.CUSTOMER_ANALYTICS]: false,\n+                [FEATURE_FLAGS.CRM_ITERATION_ONE]: false,\n             })\n \n             await expectLogic(logic).toMatchValues({\n@@ -94,7 +94,7 @@ describe('topBarSettingsButtonLogic', () => {\n             })\n \n             featureFlagLogic.actions.setFeatureFlags([], {\n-                [FEATURE_FLAGS.CUSTOMER_ANALYTICS]: true,\n+                [FEATURE_FLAGS.CRM_ITERATION_ONE]: true,\n             })\n \n             await expectLogic(logic).toMatchValues({\n@@ -102,4 +102,4 @@ describe('topBarSettingsButtonLogic', () => {\n             })\n         })\n     })\n-})\n+})\n\\ No newline at end of file\ndiff --git a/frontend/src/lib/constants.tsx b/frontend/src/lib/constants.tsx\nindex 49090d6..061af59 100644\n--- a/frontend/src/lib/constants.tsx\n+++ b/frontend/src/lib/constants.tsx\n@@ -223,228 +223,4 @@ export const FEATURE_FLAGS = {\n     BATCH_EXPORT_NEW_LOGS: 'batch-export-new-logs', // owner: #team-batch-exports\n     BATCH_EXPORTS_DATABRICKS: 'databricks-batch-exports', // owner: @rossgray #team-batch-exports\n     BING_ADS_SOURCE: 'bing-ads-source', // owner: @jabahamondes #team-web-analytics\n-    CDP_ACTIVITY_LOG_NOTIFICATIONS: 'cdp-activity-log-notifications', // owner: #team-workflows-cdp\n-    CDP_HOG_SOURCES: 'cdp-hog-sources', // owner #team-workflows-cdp\n-    CDP_NEW_PRICING: 'cdp-new-pricing', // owner: #team-workflows\n-    CDP_PERSON_UPDATES: 'cdp-person-updates', // owner: #team-workflows-cdp\n-    COHORT_CALCULATION_HISTORY: 'cohort-calculation-history', // owner: @gustavo #team-feature-flags\n-    COPY_WEB_ANALYTICS_DATA: 'copy-web-analytics-data', // owner: @lricoy  #team-web-analytics\n-    CREATE_FORM_TOOL: 'phai-create-form-tool', // owner: @kappa90 #team-posthog-ai\n-    CRM_ITERATION_ONE: 'crm-iteration-one', // owner: @arthurdedeus #team-customer-analytics\n-    CUSTOM_PRODUCTS_SIDEBAR: 'custom-products-sidebar', // owner: @rafaeelaudibert #team-growth\n-    CUSTOMER_ANALYTICS: 'customer-analytics-roadmap', // owner: @arthurdedeus #team-customer-analytics\n-    DASHBOARD_TILE_OVERRIDES: 'dashboard-tile-overrides', // owner: @gesh #team-product-analytics\n-    DATA_WAREHOUSE_SCENE: 'data-warehouse-scene', // owner: #team-data-stack\n-    DATE_PICKER_EXPLICIT_DATE_TOGGLE: 'date-picker-explicit-date-toggle', // owner: @gesh #team-product-analytics\n-    DEFAULT_EVALUATION_ENVIRONMENTS: 'default-evaluation-environments', // owner: @dmarticus #team-feature-flags\n-    DWH_FREE_SYNCS: 'dwh-free-syncs', // owner: @Gilbert09  #team-data-stack\n-    DWH_JOIN_TABLE_PREVIEW: 'dwh-join-table-preview', // owner: @arthurdedeus #team-customer-analytics\n-    EDITOR_DRAFTS: 'editor-drafts', // owner: @EDsCODE #team-data-stack\n-    ENDPOINTS: 'embedded-analytics', // owner: @sakce #team-clickhouse\n-    ERROR_TRACKING_ISSUE_CORRELATION: 'error-tracking-issue-correlation', // owner: @david #team-error-tracking\n-    ERROR_TRACKING_ISSUE_SPLITTING: 'error-tracking-issue-splitting', // owner: @david #team-error-tracking\n-    ERROR_TRACKING_RELATED_ISSUES: 'error-tracking-related-issues', // owner: #team-error-tracking\n-    ERROR_TRACKING_REVENUE_SORTING: 'error-tracking-revenue-sorting', // owner: @david #team-error-tracking\n-    EXPERIMENT_AI_SUMMARY: 'experiment-ai-summary', // owner: @jurajmajerik #team-experiments\n-    EXPERIMENTS_BREAKDOWN_FILTER: 'experiments-breakdown-filter', // owner: @rodrigoi #team-experiments\n-    EXPERIMENTS_NEW_CALCULATOR: 'experiments-new-calculator', // owner: @jurajmajerik #team-experiments\n-    EXPERIMENTS_RETENTION_METRICS: 'experiments-retention-metrics', // owner: @rodrigoi #team-experiments\n-    EXPERIMENTS_SHOW_SQL: 'experiments-show-sql', // owner: @jurajmajerik #team-experiments\n-    EXPERIMENTS_USE_NEW_QUERY_BUILDER: 'experiments-use-new-query-builder', // owner: @andehen #team-experiments\n-    EXTERNAL_SURVEYS: 'external-surveys', // owner: #team-surveys\n-    FLAG_EVALUATION_RUNTIMES: 'flag-evaluation-runtimes', // owner: @dmarticus #team-feature-flags\n-    FLAG_EVALUATION_TAGS: 'flag-evaluation-tags', // owner: @dmarticus #team-feature-flags\n-    FLAGGED_FEATURE_INDICATOR: 'flagged-feature-indicator', // owner: @benjackwhite\n-    HOME_FEED_TAB: 'home-feed-tab', // owner: @ksvat #team-replay\n-    INCIDENT_IO_STATUS_PAGE: 'incident-io-status-page', // owner: @benjackwhite\n-    LINKS: 'links', // owner: @marconlp #team-link (team doesn't exist for now, maybe will come back in the future)\n-    LIVE_DEBUGGER: 'live-debugger', // owner: @marcecoll\n-    LLM_ANALYTICS_CUSTOMIZABLE_DASHBOARD: 'llm-analytics-customizable-dashboard', // owner: #team-llm-analytics\n-    LLM_ANALYTICS_DATASETS: 'llm-analytics-datasets', // owner: #team-llm-analytics #team-posthog-ai\n-    LLM_ANALYTICS_DISCUSSIONS: 'llm-analytics-discussions', // owner: #team-llm-analytics\n-    LLM_ANALYTICS_EARLY_ADOPTERS: 'llm-analytics-early-adopters', // owner: #team-llm-analytics\n-    LLM_ANALYTICS_ERRORS_TAB: 'llm-analytics-errors-tab', // owner: #team-llm-analytics\n-    LLM_ANALYTICS_EVALUATIONS: 'llm-analytics-evaluations', // owner: #team-llm-analytics\n-    LLM_ANALYTICS_SESSION_SUMMARIZATION: 'llm-analytics-session-summarization', // owner: #team-llm-analytics\n-    LLM_ANALYTICS_SESSIONS_VIEW: 'llm-analytics-sessions-view', // owner: #team-llm-analytics\n-    LLM_ANALYTICS_SUMMARIZATION: 'llm-analytics-summarization', // owner: #team-llm-analytics\n-    LLM_ANALYTICS_TEXT_VIEW: 'llm-analytics-text-view', // owner: #team-llm-analytics\n-    LLM_OBSERVABILITY_SHOW_INPUT_OUTPUT: 'llm-observability-show-input-output', // owner: #team-llm-analytics\n-    LOGS_PRE_EARLY_ACCESS: 'logs-internal', // owner: #team-logs\n-    LOGS_VIRTUALIZED_LIST: 'logs-virtualized-list', // owner: #team-logs\n-    LOGS: 'logs', // owner: #team-logs\n-    MANAGED_VIEWSETS: 'managed-viewsets', // owner: @rafaeelaudibert #team-revenue-analytics\n-    MAX_AI_INSIGHT_SEARCH: 'max-ai-insight-search', // owner: #team-posthog-ai\n-    MAX_BILLING_CONTEXT: 'max-billing-context', // owner: @pawel-cebula #team-billing\n-    MAX_DEEP_RESEARCH: 'max-deep-research', // owner: @kappa90 #team-posthog-ai\n-    MAX_SESSION_SUMMARIZATION: 'max-session-summarization', // owner: #team-posthog-ai\n-    MESSAGING_SES: 'messaging-ses', // owner #team-workflows\n-    NOTEBOOKS_COLLAPSIBLE_SECTIONS: 'notebooks-collapsible-sections', // owner: @daibhin @benjackwhite\n-    ONBOARDING_AI_CONSENT_STEP: 'onboarding-ai-consent-step', // owner: @mattbro #team-growth\n-    ONBOARDING_TELL_US_MORE_STEP: 'onboarding-tell-us-more-step', // owner: @rafaeelaudibert #team-growth\n-    ONBOARDING_USE_CASE_SELECTION: 'onboarding-use-case-selection', // owner: @mattbro #team-growth\n-    PASSWORD_PROTECTED_SHARES: 'password-protected-shares', // owner: @aspicer\n-    PATHS_V2: 'paths-v2', // owner: @thmsobrmlr #team-product-analytics\n-    POSTHOG_AI_BILLING_DISPLAY: 'posthog-ai-billing-display', // owner: #team-posthog-ai\n-    POSTHOG_AI_BILLING_USAGE_COMMAND: 'posthog-ai-billing-usage-command', // owner: #team-posthog-ai\n-    POSTHOG_AI_BILLING_USAGE_REPORT: 'posthog-ai-billing-usage-report', // owner: #team-posthog-ai\n-    POSTHOG_AI_CONVERSATION_FEEDBACK_CONFIG: 'posthog-ai-conversation-feedback-config', // owner: #team-posthog-ai\n-    POSTHOG_AI_CONVERSATION_FEEDBACK_LLMA_SESSIONS: 'posthog-ai-conversation-feedback-llma-sessions', // owner: #team-posthog-ai\n-    POSTHOG_AI_GENERAL_AVAILABILITY: 'posthog-ai-general-availability', // owner: #team-posthog-ai\n-    QUERY_EXECUTION_DETAILS: 'query-execution-details', // owner: @sakce\n-    RECORDINGS_PLAYER_EVENT_PROPERTY_EXPANSION: 'recordings-player-event-property-expansion', // owner: @pauldambra #team-replay\n-    REMOTE_CONFIG: 'remote-config', // owner: #team-platform-features\n-    REPLAY_CLIENT_SIDE_DECOMPRESSION: 'replay-client-side-decompression', // owner: @pauldambra #team-replay\n-    REPLAY_DECOMPRESSION_WORKER: 'replay-decompression-worker', // owner: @pauldambra #team-replay\n-    REPLAY_FILTERS_REDESIGN: 'replay-filters-redesign', // owner: @ksvat #team-replay\n-    REPLAY_NEW_DETECTED_URL_COLLECTIONS: 'replay-new-detected-url-collections', // owner: @ksvat #team-replay multivariate\n-    REPLAY_WAIT_FOR_FULL_SNAPSHOT_PLAYBACK: 'replay-wait-for-full-snapshot-playback', // owner: @ksvat #team-replay\n-    REPLAY_X_LLM_ANALYTICS_CONVERSATION_VIEW: 'replay-x-llm-analytics-conversation-view', // owner: @pauldambra #team-replay\n-    SCHEDULE_FEATURE_FLAG_VARIANTS_UPDATE: 'schedule-feature-flag-variants-update', // owner: @gustavo #team-feature-flags\n-    SCHEMA_MANAGEMENT: 'schema-management', // owner: @aspicer\n-    SEEKBAR_PREVIEW_SCRUBBING: 'seekbar-preview-scrubbing', // owner: @pauldambra #team-replay\n-    SESSIONS_EXPLORER: 'sessions-explorer', // owner: @jabahamondes #team-web-analytics\n-    SHOPIFY_DWH: 'shopify-dwh', // owner: @andrew #team-data-stack\n-    SHOW_REFERRER_FAVICON: 'show-referrer-favicon', // owner: @jordanm-posthog #team-web-analytics\n-    SSE_DASHBOARDS: 'sse-dashboards', // owner: @aspicer #team-product-analytics\n-    SURVEY_ANALYSIS_MAX_TOOL: 'survey-analysis-max-tool', // owner: #team-surveys\n-    SURVEYS_EXPERIMENTS_CROSS_SELL: 'surveys-experiments-cross-sell', // owner: @adboio #team-surveys\n-    SURVEYS_FF_CROSS_SELL: 'surveys-ff-cross-sell', // owner: @adboio #team-surveys\n-    SURVEYS_FUNNELS_CROSS_SELL: 'survey-funnels-cross-sell', // owner: @adboio #team-surveys\n-    SURVEYS_INSIGHT_BUTTON_EXPERIMENT: 'ask-users-why-ai-vs-quickcreate', // owner: @adboio #team-surveys multivariate\n-    SWITCH_SUBSCRIPTION_PLAN: 'switch-subscription-plan', // owner: @a-lider #team-platform-features\n-    TASK_SUMMARIES: 'task-summaries', // owner: #team-llm-analytics\n-    TASKS: 'tasks', // owner: #team-llm-analytics\n-    TOGGLE_PROPERTY_ARRAYS: 'toggle-property-arrays', // owner: @arthurdedeus #team-customer-analytics\n-    USE_TEMPORAL_SUBSCRIPTIONS: 'use-temporal-subscriptions', // owner: @aspicer #team-product-analytics\n-    USER_INTERVIEWS: 'user-interviews', // owner: @Twixes @jurajmajerik\n-    WEB_ANALYTICS_CONVERSION_GOAL_PREAGG: 'web-analytics-conversion-goal-preagg', // owner: @lricoy #team-web-analytics\n-    WEB_ANALYTICS_EMPTY_ONBOARDING: 'web-analytics-empty-onboarding', // owner: @jordanm-posthog #team-web-analytics\n-    WEB_ANALYTICS_HIGHER_CONCURRENCY: 'web-analytics-higher-concurrency', // owner: @lricoy #team-web-analytics\n-    WEB_ANALYTICS_MARKETING: 'marketing-analytics', // owner: @jabahamondes #team-web-analytics\n-    WEB_ANALYTICS_OPEN_AS_INSIGHT: 'web-analytics-open-as-insight', // owner: @lricoy #team-web-analytics\n-    WEB_ANALYTICS_POSTHOG_AI: 'web-analytics-posthog-ai', // owner: @lricoy #team-web-analytics\n-    WEB_ANALYTICS_TILE_TOGGLES: 'web-analytics-tile-toggles', // owner: @lricoy #team-web-analytics\n-    WORKFLOWS_INTERNAL_EVENT_FILTERS: 'workflows-internal-event-filters', // owner: @haven #team-workflows\n-    WORKFLOWS_SCHEDULED_TRIGGERS: 'workflows-scheduled-triggers', // owner: #team-workflows\n-    WORKFLOWS: 'messaging', // owner @haven #team-workflows\n-    AVERAGE_PAGE_VIEW_COLUMN: 'average-page-view-column', // owner: @jordanm-posthog #team-web-analytics\n-} as const\n-export type FeatureFlagLookupKey = keyof typeof FEATURE_FLAGS\n-export type FeatureFlagKey = (typeof FEATURE_FLAGS)[keyof typeof FEATURE_FLAGS]\n-\n-export const STORYBOOK_FEATURE_FLAGS = Object.values(FEATURE_FLAGS).filter(\n-    (flag) => flag !== FEATURE_FLAGS.AI_ONLY_MODE\n-)\n-\n-export const INSIGHT_VISUAL_ORDER = {\n-    trends: 10,\n-    funnel: 20,\n-    retention: 30,\n-    paths: 40,\n-    stickiness: 50,\n-    lifecycle: 60,\n-    calendarHeatmap: 70,\n-    sql: 80,\n-    hog: 90,\n-}\n-\n-export const ENTITY_MATCH_TYPE = 'entities'\n-export const PROPERTY_MATCH_TYPE = 'properties'\n-\n-export enum FunnelLayout {\n-    horizontal = 'horizontal',\n-    vertical = 'vertical',\n-}\n-\n-export const BIN_COUNT_AUTO = 'auto' as const\n-\n-export const RETENTION_MEAN_NONE = 'none' as const\n-\n-// Cohort types\n-export enum CohortTypeEnum {\n-    Static = 'static',\n-    Dynamic = 'dynamic',\n-}\n-\n-/**\n- * Mock Node.js `process`, which is required by VFile that is used by ReactMarkdown.\n- * See https://github.com/remarkjs/react-markdown/issues/339.\n- */\n-export const MOCK_NODE_PROCESS = { cwd: () => '', env: {} } as unknown as NodeJS.Process\n-\n-export const SSO_PROVIDER_NAMES: Record<SSOProvider, string> = {\n-    'google-oauth2': 'Google',\n-    github: 'GitHub',\n-    gitlab: 'GitLab',\n-    saml: 'Single sign-on (SAML)',\n-}\n-\n-export const DOMAIN_REGEX = /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/\n-export const SECURE_URL_REGEX = /^(?:http(s)?:\\/\\/)[\\w.-]+(?:\\.[\\w.-]+)+[\\w\\-._~:/?#[\\]@!$&'()*+,;=]+$/gi\n-\n-export const CLOUD_HOSTNAMES = {\n-    [Region.US]: 'us.posthog.com',\n-    [Region.EU]: 'eu.posthog.com',\n-}\n-\n-export const SESSION_RECORDINGS_PLAYLIST_FREE_COUNT = 5\n-export const SESSION_RECORDINGS_TTL_WARNING_THRESHOLD_DAYS = 10 // days\n-\n-export const GENERATED_DASHBOARD_PREFIX = 'Generated Dashboard'\n-\n-export const ACTIVITY_PAGE_SIZE = 20\n-export const ADVANCED_ACTIVITY_PAGE_SIZE = 100\n-export const EVENT_DEFINITIONS_PER_PAGE = 50\n-export const PROPERTY_DEFINITIONS_PER_EVENT = 5\n-export const EVENT_PROPERTY_DEFINITIONS_PER_PAGE = 50\n-export const LOGS_PORTION_LIMIT = 50\n-\n-export const SESSION_REPLAY_MINIMUM_DURATION_OPTIONS: LemonSelectOptions<number | null> = [\n-    {\n-        label: 'no minimum',\n-        value: null,\n-    },\n-    {\n-        label: '1',\n-        value: 1000,\n-    },\n-    {\n-        label: '2',\n-        value: 2000,\n-    },\n-    {\n-        label: '5',\n-        value: 5000,\n-    },\n-    {\n-        label: '10',\n-        value: 10000,\n-    },\n-    {\n-        label: '15',\n-        value: 15000,\n-    },\n-    {\n-        label: '30',\n-        value: 30000,\n-    },\n-]\n-\n-export const UNSUBSCRIBE_SURVEY_ID = '018b6e13-590c-0000-decb-c727a2b3f462'\n-export const SESSION_RECORDING_OPT_OUT_SURVEY_ID = '01985c68-bd25-0000-b7e3-f1ccc987e979'\n-export const TRIAL_CANCELLATION_SURVEY_ID = '019923cd-461c-0000-27ed-ed8e422c596e'\n-\n-export const TAILWIND_BREAKPOINTS = {\n-    sm: 526,\n-    md: 768,\n-    lg: 992,\n-    xl: 1200,\n-    '2xl': 1600,\n-}\n-\n-export const INSIGHT_ALERT_FIRING_SUB_TEMPLATE_ID = 'insight-alert-firing'\n-export const INSIGHT_ALERT_DESTINATION_LOGIC_KEY = 'insightAlertDestination'\n-export const INSIGHT_ALERT_FIRING_EVENT_ID = '$insight_alert_firing'\n-\n-export const COHORT_PERSONS_QUERY_LIMIT = 10000\n+    CDP_\n\\ No newline at end of file\ndiff --git a/frontend/src/queries/nodes/DataTable/DataTable.tsx b/frontend/src/queries/nodes/DataTable/DataTable.tsx\nindex 2f99a9a..df3d8a5 100644\n--- a/frontend/src/queries/nodes/DataTable/DataTable.tsx\n+++ b/frontend/src/queries/nodes/DataTable/DataTable.tsx\n@@ -174,7 +174,6 @@ export function DataTable({\n \n     const canUseWebAnalyticsPreAggregatedTables = useFeatureFlag('SETTINGS_WEB_ANALYTICS_PRE_AGGREGATED_TABLES')\n     const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n-    const hasCustomerAnalyticsEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n     const usedWebAnalyticsPreAggregatedTables =\n         canUseWebAnalyticsPreAggregatedTables &&\n         response &&\n@@ -336,583 +335,4 @@ export function DataTable({\n                                                     source: {\n                                                         ...source,\n                                                         select: columns\n-                                                            .map((s, i) => (i === index ? hogQl : s))\n-                                                            .filter((c) =>\n-                                                                isAggregation\n-                                                                    ? c !== '*' && c !== 'person.$delete'\n-                                                                    : true\n-                                                            ),\n-                                                        orderBy:\n-                                                            isOrderBy || isDescOrderBy\n-                                                                ? [isDescOrderBy ? `${hogQl} DESC` : hogQl]\n-                                                                : source.orderBy,\n-                                                    },\n-                                                })\n-                                            }\n-                                        }}\n-                                    />\n-                                </>\n-                            )}\n-                            {canSort &&\n-                            key !== 'person.$delete' &&\n-                            key !== 'person' &&\n-                            columnFeatures.includes(ColumnFeature.canSort) ? (\n-                                <>\n-                                    <LemonDivider />\n-                                    <LemonButton\n-                                        fullWidth\n-                                        data-attr=\"datatable-sort-asc\"\n-                                        onClick={() => {\n-                                            const orderBy =\n-                                                query.source.kind === NodeKind.MarketingAnalyticsTableQuery\n-                                                    ? createMarketingAnalyticsOrderBy(key, 'ASC')\n-                                                    : [key]\n-                                            setQuery?.({\n-                                                ...query,\n-                                                source: {\n-                                                    ...query.source,\n-                                                    orderBy,\n-                                                } as EventsQuery,\n-                                            })\n-                                        }}\n-                                    >\n-                                        Sort ascending\n-                                    </LemonButton>\n-                                    <LemonButton\n-                                        fullWidth\n-                                        data-attr=\"datatable-sort-desc\"\n-                                        onClick={() => {\n-                                            const orderBy =\n-                                                query.source.kind === NodeKind.MarketingAnalyticsTableQuery\n-                                                    ? createMarketingAnalyticsOrderBy(key, 'DESC')\n-                                                    : [`${key}\\n DESC`]\n-                                            setQuery?.({\n-                                                ...query,\n-                                                source: {\n-                                                    ...query.source,\n-                                                    orderBy,\n-                                                } as EventsQuery,\n-                                            })\n-                                        }}\n-                                    >\n-                                        Sort descending\n-                                    </LemonButton>\n-                                    <LemonButton\n-                                        fullWidth\n-                                        data-attr=\"datatable-reset-sort\"\n-                                        onClick={() => {\n-                                            setQuery?.({\n-                                                ...query,\n-                                                source: {\n-                                                    ...query.source,\n-                                                    orderBy: [],\n-                                                } as EventsQuery,\n-                                            })\n-                                        }}\n-                                    >\n-                                        Reset sorting\n-                                    </LemonButton>\n-                                </>\n-                            ) : null}\n-\n-                            {columnFeatures.includes(ColumnFeature.canAddColumns) && (\n-                                <>\n-                                    <LemonDivider />\n-                                    <TaxonomicPopover\n-                                        groupType={TaxonomicFilterGroupType.HogQLExpression}\n-                                        value=\"\"\n-                                        groupTypes={groupTypes}\n-                                        metadataSource={query.source}\n-                                        placeholder={<span className=\"not-italic\">Add column left</span>}\n-                                        data-attr=\"datatable-add-column-left\"\n-                                        type=\"tertiary\"\n-                                        fullWidth\n-                                        onChange={(v, g) => {\n-                                            const hogQl = isActorsQuery(query.source)\n-                                                ? taxonomicPersonFilterToHogQL(g, v)\n-                                                : isGroupsQuery(query.source)\n-                                                  ? taxonomicGroupFilterToHogQL(g, v)\n-                                                  : taxonomicEventFilterToHogQL(g, v)\n-                                            if (\n-                                                setQuery &&\n-                                                hogQl &&\n-                                                sourceFeatures.has(QueryFeature.selectAndOrderByColumns)\n-                                            ) {\n-                                                const isAggregation = isHogQLAggregation(hogQl)\n-                                                const source = query.source as EventsQuery\n-                                                const columns = columnsInLemonTable ?? getDataNodeDefaultColumns(source)\n-                                                setQuery({\n-                                                    ...query,\n-                                                    source: {\n-                                                        ...source,\n-                                                        select: [\n-                                                            ...columns.slice(0, index),\n-                                                            hogQl,\n-                                                            ...columns.slice(index),\n-                                                        ].filter((c) =>\n-                                                            isAggregation ? c !== '*' && c !== 'person.$delete' : true\n-                                                        ),\n-                                                    } as EventsQuery | ActorsQuery,\n-                                                })\n-                                            }\n-                                        }}\n-                                    />\n-                                    <TaxonomicPopover\n-                                        groupType={TaxonomicFilterGroupType.HogQLExpression}\n-                                        value=\"\"\n-                                        groupTypes={groupTypes}\n-                                        metadataSource={query.source}\n-                                        placeholder={<span className=\"not-italic\">Add column right</span>}\n-                                        data-attr=\"datatable-add-column-right\"\n-                                        type=\"tertiary\"\n-                                        fullWidth\n-                                        onChange={(v, g) => {\n-                                            const hogQl = isActorsQuery(query.source)\n-                                                ? taxonomicPersonFilterToHogQL(g, v)\n-                                                : isGroupsQuery(query.source)\n-                                                  ? taxonomicGroupFilterToHogQL(g, v)\n-                                                  : taxonomicEventFilterToHogQL(g, v)\n-                                            if (\n-                                                setQuery &&\n-                                                hogQl &&\n-                                                sourceFeatures.has(QueryFeature.selectAndOrderByColumns)\n-                                            ) {\n-                                                const isAggregation = isHogQLAggregation(hogQl)\n-                                                const source = query.source as EventsQuery\n-                                                const columns = columnsInLemonTable ?? getDataNodeDefaultColumns(source)\n-                                                setQuery?.({\n-                                                    ...query,\n-                                                    source: {\n-                                                        ...source,\n-                                                        select: [\n-                                                            ...columns.slice(0, index + 1),\n-                                                            hogQl,\n-                                                            ...columns.slice(index + 1),\n-                                                        ].filter((c) =>\n-                                                            isAggregation ? c !== '*' && c !== 'person.$delete' : true\n-                                                        ),\n-                                                    } as EventsQuery | ActorsQuery,\n-                                                })\n-                                            }\n-                                        }}\n-                                    />\n-                                </>\n-                            )}\n-                            {columnsInQuery.filter((c) => c !== '*').length > 1 &&\n-                                columnFeatures.includes(ColumnFeature.canRemove) && (\n-                                    <>\n-                                        <LemonDivider />\n-                                        <LemonButton\n-                                            fullWidth\n-                                            status=\"danger\"\n-                                            data-attr=\"datatable-remove-column\"\n-                                            onClick={() => {\n-                                                const cleanColumnKey = removeExpressionComment(key)\n-                                                const newSource: EventsQuery = {\n-                                                    ...(query.source as EventsQuery),\n-                                                    select: (query.source as EventsQuery).select.filter(\n-                                                        (_, i) => i !== index\n-                                                    ),\n-                                                    // remove the current column from orderBy if it's there\n-                                                    orderBy: (\n-                                                        query.source as EventsQuery | MarketingAnalyticsTableQuery\n-                                                    ).orderBy?.find((orderKey) => {\n-                                                        if (\n-                                                            typeof orderKey === 'object' &&\n-                                                            isMarketingAnalyticsTableQuery(query.source)\n-                                                        ) {\n-                                                            return orderKey[0] === cleanColumnKey\n-                                                        } else if (typeof orderKey === 'string') {\n-                                                            return (\n-                                                                removeExpressionComment(orderKey) === cleanColumnKey ||\n-                                                                removeExpressionComment(orderKey) ===\n-                                                                    `-${cleanColumnKey}`\n-                                                            )\n-                                                        }\n-                                                    })\n-                                                        ? undefined\n-                                                        : (query.source as EventsQuery).orderBy,\n-                                                }\n-                                                const newPinnedColumns = query.pinnedColumns?.filter(\n-                                                    (column) => column !== key\n-                                                )\n-                                                setQuery?.({\n-                                                    ...query,\n-                                                    source: newSource,\n-                                                    pinnedColumns: newPinnedColumns,\n-                                                })\n-                                            }}\n-                                        >\n-                                            Remove column\n-                                        </LemonButton>\n-                                    </>\n-                                )}\n-                            {columnFeatures.includes(ColumnFeature.canPin) && (\n-                                <>\n-                                    <LemonDivider />\n-                                    <LemonButton\n-                                        fullWidth\n-                                        data-attr=\"datatable-pin-column\"\n-                                        onClick={() => {\n-                                            let newPinnedColumns = new Set(query.pinnedColumns ?? [])\n-                                            if (newPinnedColumns.has(key)) {\n-                                                newPinnedColumns.delete(key)\n-                                            } else {\n-                                                newPinnedColumns.add(key)\n-                                            }\n-                                            setQuery?.({\n-                                                ...query,\n-                                                pinnedColumns: Array.from(newPinnedColumns),\n-                                            })\n-                                        }}\n-                                    >\n-                                        {query.pinnedColumns?.includes(key) ? 'Unpin' : 'Pin column'}\n-                                    </LemonButton>\n-                                </>\n-                            )}\n-                        </>\n-                    ) : undefined,\n-            }\n-        }),\n-        ...(recordingColumnShown\n-            ? [\n-                  {\n-                      dataIndex: '__recording' as any,\n-                      title: '',\n-                      render: function RenderRecording(_: any, { label, result }: DataTableRow) {\n-                          if (label) {\n-                              return { props: { colSpan: 0 } }\n-                          }\n-                          if (result && columnsInResponse?.includes('*')) {\n-                              const event = result[columnsInResponse.indexOf('*')]\n-                              return (\n-                                  <ViewRecordingButton\n-                                      sessionId={event?.properties?.$session_id}\n-                                      recordingStatus={event?.properties?.$recording_status}\n-                                      timestamp={event?.timestamp}\n-                                      inModal\n-                                      size=\"xsmall\"\n-                                      type=\"secondary\"\n-                                  />\n-                              )\n-                          }\n-                          return null\n-                      },\n-                      width: 100,\n-                      align: 'center' as const,\n-                  },\n-              ]\n-            : []),\n-    ].filter((column) => !query.hiddenColumns?.includes(column.dataIndex) && column.dataIndex !== '*')\n-\n-    const setQuerySource = useCallback(\n-        (\n-            source:\n-                | EventsNode\n-                | EventsQuery\n-                | PersonsNode\n-                | ActorsQuery\n-                | GroupsQuery\n-                | HogQLQuery\n-                | SessionAttributionExplorerQuery\n-                | SessionsQuery\n-                | TracesQuery\n-                | MarketingAnalyticsTableQuery\n-        ) => setQuery?.({ ...query, source }),\n-        [setQuery, query]\n-    )\n-\n-    const firstRowLeft = [\n-        showSourceQueryOptions && backToSourceQuery ? <BackToSource key=\"return-to-source\" /> : null,\n-        showSourceQueryOptions &&\n-        backToSourceQuery &&\n-        isActorsQuery(query.source) &&\n-        isInsightActorsQuery(query.source.source) ? (\n-            <InsightActorsQueryOptions\n-                query={query.source.source}\n-                setQuery={(q) =>\n-                    setQuerySource({\n-                        ...query.source,\n-                        source: { ...(query.source as ActorsQuery).source, ...q },\n-                    } as ActorsQuery)\n-                }\n-                key=\"source-query-options\"\n-            />\n-        ) : null,\n-        showDateRange && sourceFeatures.has(QueryFeature.dateRangePicker) ? (\n-            <DateRange\n-                key=\"date-range\"\n-                query={\n-                    query.source as\n-                        | HogQLQuery\n-                        | EventsQuery\n-                        | SessionAttributionExplorerQuery\n-                        | SessionsQuery\n-                        | TracesQuery\n-                }\n-                setQuery={setQuerySource}\n-            />\n-        ) : null,\n-        showEventFilter && sourceFeatures.has(QueryFeature.eventNameFilter) ? (\n-            <EventName key=\"event-name\" query={query.source as EventsQuery | SessionsQuery} setQuery={setQuerySource} />\n-        ) : null,\n-        showSearch && sourceFeatures.has(QueryFeature.personsSearch) ? (\n-            <PersonsSearch key=\"persons-search\" query={query.source as PersonsNode} setQuery={setQuerySource} />\n-        ) : null,\n-        showSearch && sourceFeatures.has(QueryFeature.groupsSearch) ? (\n-            <GroupsSearch\n-                key=\"groups-search\"\n-                query={query.source as GroupsQuery}\n-                setQuery={setQuerySource}\n-                groupTypeLabel={context?.groupTypeLabel}\n-            />\n-        ) : null,\n-        showPropertyFilter &&\n-        sourceFeatures.has(QueryFeature.eventPropertyFilters) &&\n-        !isSessionsQuery(query.source) ? (\n-            <EventPropertyFilters\n-                key=\"event-property\"\n-                query={query.source as EventsQuery | HogQLQuery | SessionAttributionExplorerQuery | TracesQuery}\n-                setQuery={setQuerySource}\n-                taxonomicGroupTypes={Array.isArray(showPropertyFilter) ? showPropertyFilter : undefined}\n-            />\n-        ) : null,\n-        showSavedFilters && uniqueKey ? (\n-            <DataTableSavedFiltersButton\n-                key=\"saved-filters-button\"\n-                uniqueKey={String(uniqueKey)}\n-                query={query}\n-                setQuery={setQuery}\n-            />\n-        ) : null,\n-        showPropertyFilter && sourceFeatures.has(QueryFeature.personPropertyFilters) ? (\n-            <PersonPropertyFilters\n-                key=\"person-property\"\n-                query={query.source as PersonsNode}\n-                setQuery={setQuerySource}\n-            />\n-        ) : null,\n-        showPropertyFilter && sourceFeatures.has(QueryFeature.sessionPropertyFilters) ? (\n-            <SessionPropertyFilters\n-                key=\"session-property\"\n-                query={query.source as SessionsQuery}\n-                setQuery={setQuerySource}\n-            />\n-        ) : null,\n-        showPropertyFilter && sourceFeatures.has(QueryFeature.groupPropertyFilters) ? (\n-            <div className=\"flex gap-2\">\n-                <GroupPropertyFilters\n-                    key=\"group-property\"\n-                    query={query.source as GroupsQuery}\n-                    setQuery={setQuerySource}\n-                />\n-                {hasCrmIterationOneEnabled && (\n-                    <LemonButton\n-                        data-attr=\"save-group-view\"\n-                        type=\"primary\"\n-                        size=\"small\"\n-                        onClick={() => setSaveGroupViewModalOpen(true)}\n-                    >\n-                        Save view\n-                    </LemonButton>\n-                )}\n-            </div>\n-        ) : null,\n-    ].filter((x) => !!x)\n-\n-    const firstRowRight = [\n-        showTestAccountFilters && sourceFeatures.has(QueryFeature.testAccountFilters) ? (\n-            <TestAccountFilters key=\"test-account-filters\" query={query.source} setQuery={setQuerySource} />\n-        ) : null,\n-        showSavedQueries && sourceFeatures.has(QueryFeature.savedEventsQueries) ? (\n-            <SavedQueries key=\"saved-queries\" query={query} setQuery={setQuery} />\n-        ) : null,\n-    ].filter((x) => !!x)\n-\n-    const secondRowLeft = [\n-        showReload ? <Reload key=\"reload\" /> : null,\n-        showElapsedTime ? <ElapsedTime key=\"elapsed-time\" showTimings={showTimings} /> : null,\n-    ].filter((x) => !!x)\n-\n-    const secondRowRight = [\n-        sourceFeatures.has(QueryFeature.linkDataButton) &&\n-        (hasCrmIterationOneEnabled || hasCustomerAnalyticsEnabled) ? (\n-            <ViewLinkButton tableName=\"groups\" />\n-        ) : null,\n-        (showColumnConfigurator || showPersistentColumnConfigurator) &&\n-        sourceFeatures.has(QueryFeature.columnConfigurator) ? (\n-            <ColumnConfigurator key=\"column-configurator\" query={query} setQuery={setQuery} />\n-        ) : null,\n-        <DataTableViewReplays key=\"data-table-view-replays\" />,\n-        showExport ? (\n-            <DataTableExport\n-                key=\"data-table-export\"\n-                query={query}\n-                setQuery={setQuery}\n-                fileNameForExport={context?.fileNameForExport}\n-            />\n-        ) : null,\n-        showExport && showOpenEditorButton ? (\n-            <DataTableOpenEditor key=\"data-table-open-editor\" query={query} setQuery={setQuery} />\n-        ) : null,\n-    ].filter((x) => !!x)\n-\n-    const showFirstRow = !isReadOnly && (firstRowLeft.length > 0 || firstRowRight.length > 0)\n-    const showSecondRow = !isReadOnly && (secondRowLeft.length > 0 || secondRowRight.length > 0)\n-    const inlineEditorButtonOnRow = showFirstRow ? 1 : showSecondRow ? 2 : 0\n-\n-    const editorButton = (\n-        <>\n-            <OpenEditorButton query={query} />\n-            {response && 'hogql' in response && response?.hogql ? <EditHogQLButton hogql={response.hogql} /> : null}\n-        </>\n-    )\n-\n-    // The editor button moved under \"export\". Show only if there's no export button.\n-    if (!showExport && showOpenEditorButton && !isReadOnly) {\n-        if (inlineEditorButtonOnRow === 1) {\n-            firstRowRight.push(editorButton)\n-        } else if (inlineEditorButtonOnRow === 2) {\n-            secondRowRight.push(editorButton)\n-        }\n-    }\n-    return (\n-        <BindLogic logic={dataTableLogic} props={dataTableLogicProps}>\n-            <BindLogic logic={dataNodeLogic} props={dataNodeLogicProps}>\n-                <div className=\"relative w-full flex flex-col gap-2 flex-1 h-full\">\n-                    {showHogQLEditor && isHogQLQuery(query.source) && !isReadOnly ? (\n-                        <HogQLQueryEditor query={query.source} setQuery={setQuerySource} embedded={embedded} />\n-                    ) : null}\n-                    {showFirstRow && (\n-                        <div className=\"flex gap-2 items-center flex-wrap\">\n-                            {firstRowLeft}\n-                            {firstRowLeft.length > 0 && firstRowRight.length > 0 ? <div className=\"flex-1\" /> : null}\n-                            {firstRowRight}\n-                        </div>\n-                    )}\n-                    {showSavedFilters && uniqueKey && (\n-                        <DataTableSavedFilters uniqueKey={String(uniqueKey)} query={query} setQuery={setQuery} />\n-                    )}\n-                    {showFirstRow && showSecondRow && <LemonDivider className=\"my-0\" />}\n-                    {showSecondRow && (\n-                        <div className=\"flex gap-2 justify-between flex-wrap DataTable__second-row\">\n-                            <div className=\"flex gap-2 items-center\">{secondRowLeft}</div>\n-                            <div className=\"flex gap-2 items-center\">{secondRowRight}</div>\n-                        </div>\n-                    )}\n-                    {showOpenEditorButton && inlineEditorButtonOnRow === 0 && !isReadOnly ? (\n-                        <div className=\"absolute right-0 z-10 p-1\">{editorButton}</div>\n-                    ) : null}\n-                    {showResultsTable && (\n-                        <div className=\"relative\">\n-                            {usedWebAnalyticsPreAggregatedTables && <PreAggregatedBadge />}\n-                            <LemonTable\n-                                data-attr={dataAttr}\n-                                className=\"DataTable\"\n-                                loading={responseLoading && !nextDataLoading && !newDataLoading}\n-                                columns={lemonColumns}\n-                                embedded={embedded}\n-                                key={\n-                                    [...(columnsInResponse ?? []), ...columnsInQuery].join(\n-                                        '::'\n-                                    ) /* Bust the LemonTable cache when columns change */\n-                                }\n-                                dataSource={dataTableRows ?? []}\n-                                rowKey={(_, rowIndex) => {\n-                                    return rowIndex\n-                                }}\n-                                sorting={null}\n-                                useURLForSorting={false}\n-                                emptyState={\n-                                    responseError ? (\n-                                        sourceFeatures.has(QueryFeature.displayResponseError) ? (\n-                                            <InsightErrorState\n-                                                query={query}\n-                                                excludeDetail\n-                                                title={\n-                                                    queryCancelled\n-                                                        ? 'The query was cancelled'\n-                                                        : response && 'error' in response\n-                                                          ? response.error\n-                                                          : responseError\n-                                                }\n-                                            />\n-                                        ) : (\n-                                            <InsightErrorState query={query} />\n-                                        )\n-                                    ) : (\n-                                        <InsightEmptyState\n-                                            heading={context?.emptyStateHeading}\n-                                            detail={context?.emptyStateDetail}\n-                                        />\n-                                    )\n-                                }\n-                                expandable={\n-                                    context?.expandable\n-                                        ? context.expandable\n-                                        : expandable && columnsInResponse?.includes('*')\n-                                          ? {\n-                                                expandedRowRender: function renderExpand({ result }) {\n-                                                    if (\n-                                                        (isEventsQuery(query.source) ||\n-                                                            isRevenueExampleEventsQuery(query.source)) &&\n-                                                        Array.isArray(result)\n-                                                    ) {\n-                                                        return (\n-                                                            <EventDetails\n-                                                                event={result[columnsInResponse.indexOf('*')] ?? {}}\n-                                                            />\n-                                                        )\n-                                                    }\n-                                                    if (result && !Array.isArray(result)) {\n-                                                        return <EventDetails event={result as EventType} />\n-                                                    }\n-                                                },\n-                                                rowExpandable: ({ result }) => !!result,\n-                                                noIndent: true,\n-                                            }\n-                                          : undefined\n-                                }\n-                                rowClassName={({ result, label }) =>\n-                                    clsx('DataTable__row', {\n-                                        'DataTable__row--highlight_once': result && highlightedRows.has(result),\n-                                        'DataTable__row--category_row': !!label,\n-                                        'border border-x-danger-dark bg-danger-highlight':\n-                                            sourceFeatures.has(QueryFeature.highlightExceptionEventRows) &&\n-                                            result &&\n-                                            result[0] &&\n-                                            result[0]['event'] === '$exception',\n-                                        DataTable__has_pinned_columns: (query.pinnedColumns ?? []).length > 0,\n-                                    })\n-                                }\n-                                footer={\n-                                    (dataTableRows ?? []).length > 0 &&\n-                                    !sourceFeatures.has(QueryFeature.hideLoadNextButton) ? (\n-                                        <LoadNext query={query.source} />\n-                                    ) : null\n-                                }\n-                                onRow={onRow}\n-                                pinnedColumns={query.pinnedColumns}\n-                                rowActions={\n-                                    eventActionsColumnShown\n-                                        ? ({ result, label }) => {\n-                                              if (label) {\n-                                                  return null\n-                                              }\n-                                              if (result && columnsInResponse?.includes('*')) {\n-                                                  return eventRowActionsContent(result[columnsInResponse.indexOf('*')])\n-                                              }\n-                                              return null\n-                                          }\n-                                        : undefined\n-                                }\n-                            />\n-                        </div>\n-                    )}\n-                    {/* TODO: this doesn't seem like the right solution... */}\n-                    <PersonDeleteModal />\n-                </div>\n-            </BindLogic>\n-        </BindLogic>\n-    )\n-}\n+                                                            .map((s, i) => (i === index\n\\ No newline at end of file\ndiff --git a/frontend/src/scenes/groups/Group.tsx b/frontend/src/scenes/groups/Group.tsx\nindex 148c29e..9847681 100644\n--- a/frontend/src/scenes/groups/Group.tsx\n+++ b/frontend/src/scenes/groups/Group.tsx\n@@ -121,7 +121,7 @@ export function Group({ tabId }: { tabId?: string }): JSX.Element {\n                         label: <span data-attr=\"groups-overview-tab\">Overview</span>,\n                         content: <GroupOverview groupData={groupData} />,\n                     },\n-                    ...(featureFlags[FEATURE_FLAGS.CUSTOMER_ANALYTICS] && groupData.notebook\n+                    ...(featureFlags[FEATURE_FLAGS.CRM_ITERATION_ONE] && groupData.notebook\n                         ? [\n                               {\n                                   key: GroupsTabType.NOTES,\n@@ -270,4 +270,4 @@ export function Group({ tabId }: { tabId?: string }): JSX.Element {\n             />\n         </SceneContent>\n     )\n-}\n+}\n\\ No newline at end of file\ndiff --git a/frontend/src/scenes/groups/Groups.tsx b/frontend/src/scenes/groups/Groups.tsx\nindex a83a634..23b1151 100644\n--- a/frontend/src/scenes/groups/Groups.tsx\n+++ b/frontend/src/scenes/groups/Groups.tsx\n@@ -46,7 +46,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n \n     const { groupsAccessStatus } = useValues(groupsAccessLogic)\n     const { aggregationLabel } = useValues(groupsModel)\n-    const hasCustomerAnalyticsEnabled = useFeatureFlag('CUSTOMER_ANALYTICS')\n+    const hasCrmIterationOneEnabled = useFeatureFlag('CRM_ITERATION_ONE')\n \n     if (groupTypeIndex === undefined) {\n         throw new Error('groupTypeIndex is undefined')\n@@ -79,7 +79,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n         },\n     } as QueryContext['columns']\n     let hiddenColumns = [] as string[]\n-    if (hasCustomerAnalyticsEnabled) {\n+    if (hasCrmIterationOneEnabled) {\n         columns = getCRMColumns(groupTypeName, groupTypeIndex)\n         hiddenColumns.push('key')\n     }\n@@ -95,7 +95,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n                     type: 'cohort',\n                 }}\n                 actions={\n-                    hasCustomerAnalyticsEnabled ? (\n+                    hasCrmIterationOneEnabled ? (\n                         <LemonButton\n                             type=\"primary\"\n                             size=\"small\"\n@@ -135,7 +135,7 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n                 dataAttr=\"groups-table\"\n             />\n \n-            {hasCustomerAnalyticsEnabled && (\n+            {hasCrmIterationOneEnabled && (\n                 <LemonModal\n                     isOpen={saveGroupViewModalOpen}\n                     onClose={() => setSaveGroupViewModalOpen(false)}\n@@ -171,4 +171,4 @@ export function GroupsScene({ tabId }: { tabId?: string } = {}): JSX.Element {\n             )}\n         </SceneContent>\n     )\n-}\n+}\n\\ No newline at end of file\ndiff --git a/frontend/src/scenes/groups/groupsNewLogic.ts b/frontend/src/scenes/groups/groupsNewLogic.ts\nindex 15cf699..c5319a3 100644\n--- a/frontend/src/scenes/groups/groupsNewLogic.ts\n+++ b/frontend/src/scenes/groups/groupsNewLogic.ts\n@@ -213,8 +213,8 @@ export const groupsNewLogic = kea<groupsNewLogicType>([\n     })),\n \n     afterMount(({ props, values }) => {\n-        // Redirect if customer analytics is not enabled\n-        if (!values.featureFlags[FEATURE_FLAGS.CUSTOMER_ANALYTICS]) {\n+        // Redirect if the CRM feature flag is not enabled\n+        if (!values.featureFlags[FEATURE_FLAGS.CRM_ITERATION_ONE]) {\n             router.actions.push(urls.groups(props.groupTypeIndex))\n         }\n     }),\n@@ -252,4 +252,4 @@ export function flattenProperties(properties: GroupProperty[]): Record<string, a\n             },\n             {} as Record<string, any>\n         )\n-}\n+}\n\\ No newline at end of file\n",
    "pr_number": 42628,
    "title": "chore(customers): Gate customer analytics behind early access feature flag",
    "test_files": [
      "frontend/src/lib/components/TopBarSettingsButton/topBarSettingsButtonLogic.test.ts"
    ],
    "code_files": [
      "frontend/src/lib/constants.tsx",
      "frontend/src/queries/nodes/DataTable/DataTable.tsx",
      "frontend/src/scenes/groups/Group.tsx",
      "frontend/src/scenes/groups/Groups.tsx",
      "frontend/src/scenes/groups/groupsNewLogic.ts"
    ]
  },
  {
    "instance_id": "PostHog__posthog.main.42672",
    "repo": "PostHog/posthog",
    "base_commit": "3f92060317c7f47ed200f8300af0752c657769cb",
    "bug_patch": "diff --git a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts\nindex 5ef12bf..fe999e0 100644\n--- a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts\n+++ b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts\n@@ -64,7 +64,7 @@ describe('stepWaitUntilTimeWindowLogic', () => {\n             workflow: partial({\n                 actions: expect.arrayContaining([\n                     expect.objectContaining({\n-                        description: 'Wait until weekends between 09:00 and 17:00 (UTC).',\n+                        description: 'Wait until weekends at between 09:00 and 17:00 (UTC).',\n                     }),\n                 ]),\n             }),\n@@ -85,7 +85,7 @@ describe('stepWaitUntilTimeWindowLogic', () => {\n             workflow: partial({\n                 actions: expect.arrayContaining([\n                     expect.objectContaining({\n-                        description: 'Wait until weekdays between 10:00 and 18:00 (UTC).',\n+                        description: 'Wait until weekdays at between 10:00 and 18:00 (UTC).',\n                     }),\n                 ]),\n             }),\n@@ -106,7 +106,7 @@ describe('stepWaitUntilTimeWindowLogic', () => {\n             workflow: partial({\n                 actions: expect.arrayContaining([\n                     expect.objectContaining({\n-                        description: 'Wait until weekdays between 09:00 and 17:00 (America/New_York).',\n+                        description: 'Wait until weekdays at between 09:00 and 17:00 (America/New_York).',\n                     }),\n                 ]),\n             }),\n@@ -129,4 +129,4 @@ describe('stepWaitUntilTimeWindowLogic', () => {\n             }),\n         })\n     })\n-})\n+})\n\\ No newline at end of file\ndiff --git a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts\nindex db4b641..bed08a3 100644\n--- a/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts\n+++ b/products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts\n@@ -14,7 +14,7 @@ export type WaitUntilTimeWindowConfig = {\n     time?: TimeConfig\n }\n \n-const AUTO_DESCRIPTION_REGEX = /^Wait until .+ (at any time|between .+ and .+) \\(.+\\)\\.$/\n+const AUTO_DESCRIPTION_REGEX = /^Wait until .+ at .+ \\(.+\\)\\.$/\n const LEGACY_DEFAULT_DESCRIPTION = 'Wait until a specified time window.'\n \n function capitalize(str: string): string {\n@@ -54,9 +54,7 @@ export function getWaitUntilTimeWindowDescription(day: DayConfig, time: TimeConf\n     const dayDesc = getDayDescription(day)\n     const timeDesc = getTimeDescription(time)\n     const tz = timezone || 'UTC'\n-    // Use \"at\" only for \"any time\", otherwise use the time description directly (e.g., \"between X and Y\")\n-    const timeClause = time === 'any' ? `at ${timeDesc}` : timeDesc\n-    return `Wait until ${dayDesc} ${timeClause} (${tz}).`\n+    return `Wait until ${dayDesc} at ${timeDesc} (${tz}).`\n }\n \n export function shouldAutoUpdateDescription(description: string): boolean {\n@@ -116,4 +114,4 @@ export const stepWaitUntilTimeWindowLogic = kea<stepWaitUntilTimeWindowLogicType\n             }\n         },\n     })),\n-])\n+])\n\\ No newline at end of file\n",
    "pr_number": 42672,
    "title": "chore: Fix phrasing (\"at between time and time\" to \"between time and time\")",
    "test_files": [
      "products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.test.ts"
    ],
    "code_files": [
      "products/workflows/frontend/Workflows/hogflows/steps/stepWaitUntilTimeWindowLogic.ts"
    ]
  },
  {
    "instance_id": "appsmithorg__appsmith.main.41217",
    "repo": "appsmithorg/appsmith",
    "base_commit": "49dfbd233930187670f70430b5fdefe7351020db",
    "bug_patch": "diff --git a/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx b/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx\nindex b938f72..caf37fe 100644\n--- a/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx\n+++ b/app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx\n@@ -200,10 +200,7 @@ const HeaderCellComponent = (props: HeaderProps) => {\n   const isColumnEditable =\n     props.column.columnProperties.isCellEditable &&\n     props.column.columnProperties.isEditable &&\n-    isColumnTypeEditable(\n-      props.column.columnProperties.columnType,\n-      isInfiniteScrollEnabled,\n-    );\n+    isColumnTypeEditable(props.column.columnProperties.columnType);\n \n   const toggleColumnFreeze = (value: StickyType) => {\n     handleColumnFreeze &&\n@@ -378,4 +375,4 @@ const HeaderCellComponent = (props: HeaderProps) => {\n   );\n };\n \n-export const HeaderCell = memo(HeaderCellComponent);\n+export const HeaderCell = memo(HeaderCellComponent);\n\\ No newline at end of file\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts b/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts\nindex 160ab69..9b630e2 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts\n+++ b/app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts\n@@ -10,6 +10,7 @@ import {\n   updateCustomColumnAliasOnLabelChange,\n   selectColumnOptionsValidation,\n   allowedFirstDayOfWeekRange,\n+  updateCellEditabilityOnInfiniteScrollChange,\n   updateSearchSortFilterOnInfiniteScrollChange,\n } from \"../propertyUtils\";\n import _ from \"lodash\";\n@@ -570,584 +571,4 @@ describe(\"selectColumnOptionsValidation\", () => {\n \n     it(\"should check that value should be an array of objects\", () => {\n       expect(\n-        selectColumnOptionsValidation([1, 2], {} as TableWidgetProps, _),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [1, 2],\n-        messages: [\n-          `Invalid entry at index: 0. This value does not evaluate to type: { \"label\": string | number, \"value\": string | number | boolean }`,\n-        ],\n-      });\n-    });\n-\n-    it(\"should check that each value should have label key\", () => {\n-      expect(\n-        selectColumnOptionsValidation(\n-          [{ value: \"1\" }, { value: \"2\" }],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [{ value: \"1\" }, { value: \"2\" }],\n-        messages: [`Invalid entry at index: 0. Missing required key: label`],\n-      });\n-    });\n-\n-    it(\"should check that each value should have value key\", () => {\n-      expect(\n-        selectColumnOptionsValidation(\n-          [{ label: \"1\" }, { label: \"2\" }],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [{ label: \"1\" }, { label: \"2\" }],\n-        messages: [`Invalid entry at index: 0. Missing required key: value`],\n-      });\n-    });\n-\n-    it(\"should check that each value should have unique value\", () => {\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"1\" },\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [\n-          { label: \"1\", value: \"1\" },\n-          { label: \"2\", value: \"1\" },\n-        ],\n-        messages: [\n-          \"Duplicate values found for the following properties, in the array entries, that must be unique -- value.\",\n-        ],\n-      });\n-    });\n-\n-    it(\"should check that array of label, value witn invalid values\", () => {\n-      expect(\n-        selectColumnOptionsValidation(\n-          [{ label: \"1\", value: [] }],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [{ label: \"1\", value: [] }],\n-        messages: [\n-          \"Invalid entry at index: 0. value does not evaluate to type string | number | boolean\",\n-        ],\n-      });\n-\n-      expect(\n-        selectColumnOptionsValidation(\n-          [{ label: true, value: \"1\" }],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [{ label: true, value: \"1\" }],\n-        messages: [\n-          \"Invalid entry at index: 0. label does not evaluate to type string | number\",\n-        ],\n-      });\n-    });\n-\n-    it(\"should check that array of label, value is valid\", () => {\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: true,\n-        parsed: [\n-          { label: \"1\", value: \"1\" },\n-          { label: \"2\", value: \"2\" },\n-        ],\n-        messages: [\"\"],\n-      });\n-\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            { label: \"1\", value: 1 },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: true,\n-        parsed: [\n-          { label: \"1\", value: 1 },\n-          { label: \"2\", value: \"2\" },\n-        ],\n-        messages: [\"\"],\n-      });\n-\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            { label: \"1\", value: true },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: true,\n-        parsed: [\n-          { label: \"1\", value: true },\n-          { label: \"2\", value: \"2\" },\n-        ],\n-        messages: [\"\"],\n-      });\n-\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            { label: 1, value: true },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: true,\n-        parsed: [\n-          { label: 1, value: true },\n-          { label: \"2\", value: \"2\" },\n-        ],\n-        messages: [\"\"],\n-      });\n-    });\n-  });\n-\n-  describe(\"- Array of Array of label, values\", () => {\n-    it(\"should check that value should be an array of arrays\", () => {\n-      expect(\n-        selectColumnOptionsValidation([[1, 2], 1], {} as TableWidgetProps, _),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [],\n-        messages: [\n-          `This value does not evaluate to type Array<{ \"label\": string | number, \"value\": string | number | boolean }>`,\n-        ],\n-      });\n-    });\n-\n-    it(\"should check that value should be an array of arrays of object\", () => {\n-      expect(\n-        selectColumnOptionsValidation([[1, 2]], {} as TableWidgetProps, _),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [[1, 2]],\n-        messages: [\n-          `Invalid entry at Row: 0 index: 0. This value does not evaluate to type: { \"label\": string | number, \"value\": string | number | boolean }`,\n-        ],\n-      });\n-    });\n-\n-    it(\"should check that each value should have label key\", () => {\n-      expect(\n-        selectColumnOptionsValidation(\n-          [[{ value: \"1\" }, { value: \"2\" }]],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [[{ value: \"1\" }, { value: \"2\" }]],\n-        messages: [\n-          `Invalid entry at Row: 0 index: 0. Missing required key: label`,\n-        ],\n-      });\n-\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            [\n-              { label: \"1\", value: \"1\" },\n-              { label: \"2\", value: \"2\" },\n-            ],\n-            [{ value: \"1\" }, { value: \"2\" }],\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-          [{ value: \"1\" }, { value: \"2\" }],\n-        ],\n-        messages: [\n-          `Invalid entry at Row: 1 index: 0. Missing required key: label`,\n-        ],\n-      });\n-    });\n-\n-    it(\"should check that each value should have value key\", () => {\n-      expect(\n-        selectColumnOptionsValidation(\n-          [[{ label: \"1\" }, { label: \"2\" }]],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [[{ label: \"1\" }, { label: \"2\" }]],\n-        messages: [\n-          `Invalid entry at Row: 0 index: 0. Missing required key: value`,\n-        ],\n-      });\n-\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            [\n-              { label: \"1\", value: \"1\" },\n-              { label: \"2\", value: \"2\" },\n-            ],\n-            [{ label: \"1\" }, { label: \"2\" }],\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-          [{ label: \"1\" }, { label: \"2\" }],\n-        ],\n-        messages: [\n-          `Invalid entry at Row: 1 index: 0. Missing required key: value`,\n-        ],\n-      });\n-    });\n-\n-    it(\"should check that each value should have unique value\", () => {\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            [\n-              { label: \"1\", value: \"1\" },\n-              { label: \"2\", value: \"1\" },\n-            ],\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: false,\n-        parsed: [\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"1\" },\n-          ],\n-        ],\n-        messages: [\n-          \"Duplicate values found for the following properties, in the array entries, that must be unique -- value.\",\n-        ],\n-      });\n-\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            [\n-              { label: \"1\", value: \"1\" },\n-              { label: \"2\", value: \"2\" },\n-            ],\n-            [\n-              { label: \"1\", value: \"1\" },\n-              { label: \"2\", value: \"2\" },\n-            ],\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: true,\n-        parsed: [\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-        ],\n-        messages: [\"\"],\n-      });\n-    });\n-\n-    it(\"should check that array of arrays of label, value is valid\", () => {\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            [\n-              { label: \"1\", value: \"1\" },\n-              { label: \"2\", value: \"2\" },\n-            ],\n-            [\n-              { label: \"1\", value: \"1\" },\n-              { label: \"2\", value: \"2\" },\n-            ],\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: true,\n-        parsed: [\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-        ],\n-        messages: [\"\"],\n-      });\n-    });\n-\n-    it(\"should check that array of JSON is valid\", () => {\n-      expect(\n-        selectColumnOptionsValidation(\n-          [\n-            JSON.stringify([\n-              { label: \"1\", value: \"1\" },\n-              { label: \"2\", value: \"2\" },\n-            ]),\n-            JSON.stringify([\n-              { label: \"1\", value: \"1\" },\n-              { label: \"2\", value: \"2\" },\n-            ]),\n-          ],\n-          {} as TableWidgetProps,\n-          _,\n-        ),\n-      ).toEqual({\n-        isValid: true,\n-        parsed: [\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-          [\n-            { label: \"1\", value: \"1\" },\n-            { label: \"2\", value: \"2\" },\n-          ],\n-        ],\n-        messages: [\"\"],\n-      });\n-    });\n-  });\n-});\n-\n-describe(\"updateCustomColumnAliasOnLabelChange\", () => {\n-  it(\"should return the propertyToUpdate array to update alias for the given custom column\", () => {\n-    expect(\n-      updateCustomColumnAliasOnLabelChange(\n-        {} as TableWidgetProps,\n-        \"primaryColumns.customColumn1.label\",\n-        \"customColumn12\",\n-      ),\n-    ).toEqual([\n-      {\n-        propertyPath: \"primaryColumns.customColumn1.alias\",\n-        propertyValue: \"customColumn12\",\n-      },\n-    ]);\n-  });\n-\n-  it(\"should not return propertyToUpdate array to update alias for the given column\", () => {\n-    expect(\n-      updateCustomColumnAliasOnLabelChange(\n-        {} as TableWidgetProps,\n-        \"primaryColumns.resume_url.label\",\n-        \"customColumn12\",\n-      ),\n-    ).toEqual(undefined);\n-  });\n-\n-  it(\"should not return the propertyToUpdate array to update alias when any property other than label property of the custom column gets changed\", () => {\n-    expect(\n-      updateCustomColumnAliasOnLabelChange(\n-        {} as TableWidgetProps,\n-        \"primaryColumns.customColumn1.notlabel\",\n-        \"customColumn12\",\n-      ),\n-    ).toEqual(undefined);\n-  });\n-\n-  it(\"should return the propertyToUpdate array to update alias for any given custom column\", () => {\n-    expect(\n-      updateCustomColumnAliasOnLabelChange(\n-        {} as TableWidgetProps,\n-        \"primaryColumns.customColumn12345.label\",\n-        \"customColumn12\",\n-      ),\n-    ).toEqual([\n-      {\n-        propertyPath: \"primaryColumns.customColumn12345.alias\",\n-        propertyValue: \"customColumn12\",\n-      },\n-    ]);\n-  });\n-});\n-\n-describe(\"allowedFirstDayOfWeekRange\", () => {\n-  it(\"should return valid object value is within 0 to 6\", () => {\n-    expect(allowedFirstDayOfWeekRange(4)).toEqual({\n-      isValid: true,\n-      parsed: 4,\n-      messages: [],\n-    });\n-  });\n-\n-  it(\"should return valid object value is within 0 to 6\", () => {\n-    expect(allowedFirstDayOfWeekRange(0)).toEqual({\n-      isValid: true,\n-      parsed: 0,\n-      messages: [],\n-    });\n-  });\n-\n-  it(\"should return invalid object when value is not within 0 to 6\", () => {\n-    expect(allowedFirstDayOfWeekRange(8)).toEqual({\n-      isValid: false,\n-      parsed: 0,\n-      messages: [\"Number should be between 0-6.\"],\n-    });\n-  });\n-\n-  it(\"should return invalid object when value is not within 0 to 6\", () => {\n-    expect(allowedFirstDayOfWeekRange(-2)).toEqual({\n-      isValid: false,\n-      parsed: 0,\n-      messages: [\"Number should be between 0-6.\"],\n-    });\n-  });\n-});\n-\n-describe(\"Infinite Scroll Update Hooks - \", () => {\n-  it(\"updateAllowAddNewRowOnInfiniteScrollChange - should disable/enable add new row when infinite scroll is toggled\", () => {\n-    const props = {} as TableWidgetProps;\n-\n-    // When infinite scroll is enabled\n-    expect(\n-      updateAllowAddNewRowOnInfiniteScrollChange(\n-        props,\n-        \"infiniteScrollEnabled\",\n-        true,\n-      ),\n-    ).toEqual([\n-      {\n-        propertyPath: \"allowAddNewRow\",\n-        propertyValue: false,\n-      },\n-    ]);\n-\n-    // When infinite scroll is disabled\n-    expect(\n-      updateAllowAddNewRowOnInfiniteScrollChange(\n-        props,\n-        \"infiniteScrollEnabled\",\n-        false,\n-      ),\n-    ).toEqual([\n-      {\n-        propertyPath: \"allowAddNewRow\",\n-        propertyValue: true,\n-      },\n-    ]);\n-\n-    // When some other value is passed\n-    expect(\n-      updateAllowAddNewRowOnInfiniteScrollChange(\n-        props,\n-        \"infiniteScrollEnabled\",\n-        \"some-other-value\",\n-      ),\n-    ).toBeUndefined();\n-  });\n-\n-  it(\"updateSearchSortFilterOnInfiniteScrollChange - should disable/enable search, filter, sort when infinite scroll is toggled\", () => {\n-    const props = {} as TableWidgetProps;\n-\n-    // When infinite scroll is enabled\n-    expect(\n-      updateSearchSortFilterOnInfiniteScrollChange(\n-        props,\n-        \"infiniteScrollEnabled\",\n-        true,\n-      ),\n-    ).toEqual([\n-      {\n-        propertyPath: \"isVisibleSearch\",\n-        propertyValue: false,\n-      },\n-      {\n-        propertyPath: \"isVisibleFilters\",\n-        propertyValue: false,\n-      },\n-      {\n-        propertyPath: \"isSortable\",\n-        propertyValue: false,\n-      },\n-    ]);\n-\n-    // When infinite scroll is disabled\n-    expect(\n-      updateSearchSortFilterOnInfiniteScrollChange(\n-        props,\n-        \"infiniteScrollEnabled\",\n-        false,\n-      ),\n-    ).toEqual([\n-      {\n-        propertyPath: \"isVisibleFilters\",\n-        propertyValue: true,\n-      },\n-      {\n-        propertyPath: \"isVisibleSearch\",\n-        propertyValue: true,\n-      },\n-      {\n-        propertyPath: \"isSortable\",\n-        propertyValue: true,\n-      },\n-    ]);\n-\n-    // When some other value is passed\n-    expect(\n-      updateSearchSortFilterOnInfiniteScrollChange(\n-        props,\n-        \"infiniteScrollEnabled\",\n-        \"some-other-value\",\n-      ),\n-    ).toBeUndefined();\n-  });\n-});\n+        selectColumnOptionsValidation([1, 2], {} as TableWidgetProps, _),\n\\ No newline at end of file\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/index.tsx b/app/client/src/widgets/TableWidgetV2/widget/index.tsx\nindex 2e86578..07d1029 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/index.tsx\n+++ b/app/client/src/widgets/TableWidgetV2/widget/index.tsx\n@@ -448,2662 +448,4 @@ class TableWidgetV2 extends BaseWidget<TableWidgetProps, WidgetState> {\n     return (widget: TableWidgetProps, extraDefsToDefine?: ExtraDef) => {\n       const config: AutocompletionDefinitions = {\n         \"!doc\":\n-          \"The Table is the hero widget of Appsmith. You can display data from an API in a table, trigger an action when a user selects a row and even work with large paginated data sets\",\n-        \"!url\": \"https://docs.appsmith.com/widget-reference/table\",\n-        selectedRow: generateTypeDef(widget.selectedRow, extraDefsToDefine),\n-        selectedRows: generateTypeDef(widget.selectedRows, extraDefsToDefine),\n-        selectedRowIndices: generateTypeDef(widget.selectedRowIndices),\n-        triggeredRow: generateTypeDef(widget.triggeredRow),\n-        updatedRow: generateTypeDef(widget.updatedRow),\n-        selectedRowIndex: \"number\",\n-        tableData: generateTypeDef(widget.tableData, extraDefsToDefine),\n-        pageNo: \"number\",\n-        pageSize: \"number\",\n-        isVisible: DefaultAutocompleteDefinitions.isVisible,\n-        searchText: \"string\",\n-        totalRecordsCount: \"number\",\n-        sortOrder: {\n-          column: \"string\",\n-          order: [\"asc\", \"desc\"],\n-        },\n-        updatedRows: generateTypeDef(widget.updatedRows, extraDefsToDefine),\n-        updatedRowIndices: generateTypeDef(widget.updatedRowIndices),\n-        triggeredRowIndex: generateTypeDef(widget.triggeredRowIndex),\n-        pageOffset: generateTypeDef(widget.pageOffset),\n-        tableHeaders: generateTypeDef(widget.tableHeaders),\n-        newRow: generateTypeDef(widget.newRow),\n-        isAddRowInProgress: \"bool\",\n-        previousPageVisited: generateTypeDef(widget.previousPageVisited),\n-        nextPageVisited: generateTypeDef(widget.nextPageButtonClicked),\n-      };\n-\n-      if (this.getFeatureFlag(ALLOW_TABLE_WIDGET_SERVER_SIDE_FILTERING)) {\n-        config[\"filters\"] = generateTypeDef(widget.filters);\n-      }\n-\n-      return config;\n-    };\n-  }\n-\n-  static getDerivedPropertiesMap() {\n-    return {\n-      selectedRow: `{{(()=>{${derivedProperties.getSelectedRow}})()}}`,\n-      triggeredRow: `{{(()=>{${derivedProperties.getTriggeredRow}})()}}`,\n-      selectedRows: `{{(()=>{${derivedProperties.getSelectedRows}})()}}`,\n-      pageSize: `{{(()=>{${derivedProperties.getPageSize}})()}}`,\n-      triggerRowSelection: \"{{!!this.onRowSelected}}\",\n-      processedTableData: `{{(()=>{${derivedProperties.getProcessedTableData}})()}}`,\n-      orderedTableColumns: `{{(()=>{${derivedProperties.getOrderedTableColumns}})()}}`,\n-      filteredTableData: `{{(()=>{ ${derivedProperties.getFilteredTableData}})()}}`,\n-      updatedRows: `{{(()=>{ ${derivedProperties.getUpdatedRows}})()}}`,\n-      updatedRowIndices: `{{(()=>{ ${derivedProperties.getUpdatedRowIndices}})()}}`,\n-      updatedRow: `{{(()=>{ ${derivedProperties.getUpdatedRow}})()}}`,\n-      pageOffset: `{{(()=>{${derivedProperties.getPageOffset}})()}}`,\n-      isEditableCellsValid: `{{(()=>{ ${derivedProperties.getEditableCellValidity}})()}}`,\n-      tableHeaders: `{{(()=>{${derivedProperties.getTableHeaders}})()}}`,\n-    };\n-  }\n-\n-  static getDefaultPropertiesMap(): Record<string, string> {\n-    return {\n-      searchText: \"defaultSearchText\",\n-      selectedRowIndex: \"defaultSelectedRowIndex\",\n-      selectedRowIndices: \"defaultSelectedRowIndices\",\n-    };\n-  }\n-\n-  static getLoadingProperties(): Array<RegExp> | undefined {\n-    return [/\\.tableData$/];\n-  }\n-\n-  static getStylesheetConfig(): Stylesheet {\n-    return {\n-      accentColor: \"{{appsmith.theme.colors.primaryColor}}\",\n-      borderRadius: \"{{appsmith.theme.borderRadius.appBorderRadius}}\",\n-      boxShadow: \"{{appsmith.theme.boxShadow.appBoxShadow}}\",\n-      childStylesheet: {\n-        button: {\n-          buttonColor: \"{{appsmith.theme.colors.primaryColor}}\",\n-          borderRadius: \"{{appsmith.theme.borderRadius.appBorderRadius}}\",\n-          boxShadow: \"none\",\n-        },\n-        menuButton: {\n-          menuColor: \"{{appsmith.theme.colors.primaryColor}}\",\n-          borderRadius: \"{{appsmith.theme.borderRadius.appBorderRadius}}\",\n-          boxShadow: \"none\",\n-        },\n-        iconButton: {\n-          buttonColor: \"{{appsmith.theme.colors.primaryColor}}\",\n-          borderRadius: \"{{appsmith.theme.borderRadius.appBorderRadius}}\",\n-          boxShadow: \"none\",\n-        },\n-        editActions: {\n-          saveButtonColor: \"{{appsmith.theme.colors.primaryColor}}\",\n-          saveBorderRadius: \"{{appsmith.theme.borderRadius.appBorderRadius}}\",\n-          discardButtonColor: \"{{appsmith.theme.colors.primaryColor}}\",\n-          discardBorderRadius:\n-            \"{{appsmith.theme.borderRadius.appBorderRadius}}\",\n-        },\n-      },\n-    };\n-  }\n-\n-  static getSetterConfig(): SetterConfig {\n-    return {\n-      __setters: {\n-        setVisibility: {\n-          path: \"isVisible\",\n-          type: \"string\",\n-        },\n-        setSelectedRowIndex: {\n-          path: \"defaultSelectedRowIndex\",\n-          type: \"number\",\n-          disabled: \"return options.entity.multiRowSelection\",\n-        },\n-        setSelectedRowIndices: {\n-          path: \"defaultSelectedRowIndices\",\n-          type: \"array\",\n-          disabled: \"return !options.entity.multiRowSelection\",\n-        },\n-        setData: {\n-          path: \"tableData\",\n-          type: \"array\",\n-        },\n-      },\n-    };\n-  }\n-\n-  /*\n-   * Function to get the table columns with appropriate render functions\n-   * based on columnType\n-   */\n-  getTableColumns = () => {\n-    const {\n-      columnWidthMap,\n-      infiniteScrollEnabled,\n-      isPreviewMode,\n-      orderedTableColumns,\n-      renderMode,\n-      widgetId,\n-    } = this.props;\n-    const { componentWidth } = this.getPaddingAdjustedDimensions();\n-    const widgetLocalStorageState = getColumnOrderByWidgetIdFromLS(widgetId);\n-    const memoisdGetColumnsWithLocalStorage =\n-      this.memoiseGetColumnsWithLocalStorage(widgetLocalStorageState);\n-\n-    return memoisdGetColumnsWithLocalStorage(\n-      this.renderCell,\n-      columnWidthMap,\n-      orderedTableColumns,\n-      componentWidth,\n-      renderMode,\n-      isPreviewMode,\n-      infiniteScrollEnabled,\n-    );\n-  };\n-\n-  transformData = (\n-    tableData: Array<Record<string, unknown>>,\n-    columns: ReactTableColumnProps[],\n-  ) => {\n-    return this.memoiseTransformDataWithEditableCell(\n-      this.props.editableCell,\n-      tableData,\n-      columns,\n-    );\n-  };\n-\n-  updateDerivedColumnsIndex = (\n-    derivedColumns: Record<string, ColumnProperties>,\n-    tableColumnCount: number,\n-  ) => {\n-    if (!derivedColumns) {\n-      return [];\n-    }\n-\n-    //update index property of all columns in new derived columns\n-    return Object.values(derivedColumns).map(\n-      (column: ColumnProperties, index: number) => {\n-        return {\n-          ...column,\n-          index: index + tableColumnCount,\n-        };\n-      },\n-    );\n-  };\n-\n-  /*\n-   * Function to create new primary Columns from the tableData\n-   * gets called on component mount and on component update\n-   */\n-  createTablePrimaryColumns = ():\n-    | Record<string, ColumnProperties>\n-    | undefined => {\n-    const {\n-      infiniteScrollEnabled,\n-      primaryColumns = {},\n-      tableData = [],\n-    } = this.props;\n-\n-    if (!_.isArray(tableData) || tableData.length === 0) {\n-      return;\n-    }\n-\n-    const existingColumnIds = Object.keys(primaryColumns);\n-    const newTableColumns: Record<string, ColumnProperties> = {};\n-    const tableStyles = getTableStyles(this.props);\n-    const columnKeys: string[] = getAllTableColumnKeys(tableData);\n-\n-    /*\n-     * Generate default column properties for all columns\n-     * But do not replace existing columns with the same id\n-     */\n-    columnKeys.forEach((columnKey, index) => {\n-      const existingColumn = this.getColumnByOriginalId(columnKey);\n-\n-      if (!!existingColumn) {\n-        // Use the existing column properties\n-        newTableColumns[existingColumn.id] = existingColumn;\n-      } else {\n-        const hashedColumnKey = sanitizeKey(columnKey, {\n-          existingKeys: union(existingColumnIds, Object.keys(newTableColumns)),\n-        });\n-        // Create column properties for the new column\n-        const columnType = getColumnType(tableData, columnKey);\n-        const columnProperties = getDefaultColumnProperties(\n-          columnKey,\n-          hashedColumnKey,\n-          index,\n-          this.props.widgetName,\n-          false,\n-          columnType,\n-        );\n-\n-        newTableColumns[columnProperties.id] = {\n-          ...columnProperties,\n-          ...tableStyles,\n-        };\n-      }\n-    });\n-\n-    const derivedColumns: Record<string, ColumnProperties> =\n-      getDerivedColumns(primaryColumns);\n-\n-    const updatedDerivedColumns = this.updateDerivedColumnsIndex(\n-      derivedColumns,\n-      Object.keys(newTableColumns).length,\n-    );\n-\n-    //add derived columns to new Table columns\n-    updatedDerivedColumns.forEach((derivedColumn: ColumnProperties) => {\n-      newTableColumns[derivedColumn.id] = derivedColumn;\n-    });\n-\n-    const newColumnIds = Object.keys(newTableColumns);\n-\n-    /**\n-     * When infinite scroll is enabled, we need to merge the new columns with the existing ones.\n-     * Why?\n-     * The infinite scroll behavior differs from the existing server-side pagination in that it merges new incoming data with the existing data.\n-     * If the new page contains corrupted data with either more or fewer columns than the existing data, the current product behavior only considers the new columns, which is not ideal for infinite scroll.\n-     * Therefore, in this block, we are merging the new columns with the existing ones without removing any data.\n-     */\n-    if (infiniteScrollEnabled) {\n-      const mergedColumns = {\n-        ...primaryColumns,\n-        ...newTableColumns,\n-      };\n-\n-      if (_.xor(existingColumnIds, Object.keys(mergedColumns)).length > 0) {\n-        return mergedColumns;\n-      }\n-\n-      return;\n-    }\n-\n-    // For non-infinite scroll, keep existing logic\n-    // check if the columns ids differ\n-    if (_.xor(existingColumnIds, newColumnIds).length > 0) {\n-      return newTableColumns;\n-    } else {\n-      return;\n-    }\n-  };\n-\n-  /*\n-   * Function to update primaryColumns when the tablData schema changes\n-   */\n-  updateColumnProperties = (\n-    tableColumns?: Record<string, ColumnProperties>,\n-    shouldPersistLocalOrderWhenTableDataChanges = false,\n-  ) => {\n-    const { columnOrder = [], primaryColumns = {} } = this.props;\n-    const derivedColumns = getDerivedColumns(primaryColumns);\n-\n-    if (tableColumns) {\n-      const existingColumnIds = Object.keys(primaryColumns);\n-      const existingDerivedColumnIds = Object.keys(derivedColumns);\n-\n-      const newColumnIds = Object.keys(tableColumns);\n-\n-      //Check if there is any difference in the existing and new columns ids\n-      if (_.xor(existingColumnIds, newColumnIds).length > 0) {\n-        const newColumnIdsToAdd = _.without(newColumnIds, ...existingColumnIds);\n-\n-        const propertiesToAdd: Record<string, unknown> = {};\n-\n-        newColumnIdsToAdd.forEach((columnId: string) => {\n-          // id could be an empty string\n-          if (!!columnId) {\n-            Object.entries(tableColumns[columnId]).forEach(([key, value]) => {\n-              propertiesToAdd[`primaryColumns.${columnId}.${key}`] = value;\n-            });\n-          }\n-        });\n-\n-        /*\n-         * If new columnOrders have different values from the original columnOrders\n-         * Only update when there are new Columns(Derived or Primary)\n-         */\n-        if (\n-          !!newColumnIds.length &&\n-          !!_.xor(newColumnIds, columnOrder).length &&\n-          !equal(_.sortBy(newColumnIds), _.sortBy(existingDerivedColumnIds))\n-        ) {\n-          // Maintain original columnOrder and keep new columns at the end\n-          let newColumnOrder = _.intersection(columnOrder, newColumnIds);\n-\n-          newColumnOrder = _.union(newColumnOrder, newColumnIds);\n-\n-          const compareColumns = (a: string, b: string) => {\n-            const aSticky = tableColumns[a].sticky || \"none\";\n-            const bSticky = tableColumns[b].sticky || \"none\";\n-\n-            if (aSticky === bSticky) {\n-              return 0;\n-            }\n-\n-            return SORT_ORDER[aSticky] - SORT_ORDER[bSticky];\n-          };\n-\n-          // Sort the column order to retain the position of frozen columns\n-          newColumnOrder.sort(compareColumns);\n-\n-          propertiesToAdd[\"columnOrder\"] = newColumnOrder;\n-\n-          /**\n-           * As the table data changes in Deployed app, we also update the local storage.\n-           *\n-           * this.updateColumnProperties gets executed on mount and on update of the component.\n-           * On mount we get new tableColumns that may not have any sticky columns.\n-           * This will lead to loss of sticky column that were frozen by the user.\n-           * To avoid this and to maintain user's sticky columns we use shouldPersistLocalOrderWhenTableDataChanges below\n-           * so as to avoid updating the local storage on mount.\n-           **/\n-          if (\n-            this.props.renderMode === RenderModes.PAGE &&\n-            shouldPersistLocalOrderWhenTableDataChanges\n-          ) {\n-            const leftOrder = newColumnOrder.filter(\n-              (col: string) => tableColumns[col].sticky === StickyType.LEFT,\n-            );\n-            const rightOrder = newColumnOrder.filter(\n-              (col: string) => tableColumns[col].sticky === StickyType.RIGHT,\n-            );\n-\n-            this.persistColumnOrder(newColumnOrder, leftOrder, rightOrder);\n-          }\n-        }\n-\n-        const propertiesToUpdate: BatchPropertyUpdatePayload = {\n-          modify: propertiesToAdd,\n-        };\n-\n-        const pathsToDelete: string[] = [];\n-        const columnsIdsToDelete = without(existingColumnIds, ...newColumnIds);\n-\n-        if (!!columnsIdsToDelete.length) {\n-          columnsIdsToDelete.forEach((id: string) => {\n-            if (!primaryColumns[id].isDerived) {\n-              pathsToDelete.push(`primaryColumns.${id}`);\n-            }\n-          });\n-          propertiesToUpdate.remove = pathsToDelete;\n-        }\n-\n-        super.batchUpdateWidgetProperty(propertiesToUpdate, false);\n-      }\n-    }\n-  };\n-\n-  //no need to batch meta updates\n-  hydrateStickyColumns = () => {\n-    const localTableColumnOrder = getColumnOrderByWidgetIdFromLS(\n-      this.props.widgetId,\n-    );\n-    const leftLen: number = Object.keys(\n-      pickBy(this.props.primaryColumns, (col) => col.sticky === \"left\"),\n-    ).length;\n-\n-    const leftOrder = [...(this.props.columnOrder || [])].slice(0, leftLen);\n-\n-    const rightLen: number = Object.keys(\n-      pickBy(this.props.primaryColumns, (col) => col.sticky !== \"right\"),\n-    ).length;\n-\n-    const rightOrder: string[] = [...(this.props.columnOrder || [])].slice(\n-      rightLen,\n-    );\n-\n-    if (localTableColumnOrder) {\n-      const {\n-        columnOrder,\n-        columnUpdatedAt,\n-        leftOrder: localLeftOrder,\n-        rightOrder: localRightOrder,\n-      } = localTableColumnOrder;\n-\n-      if (this.props.columnUpdatedAt !== columnUpdatedAt) {\n-        // Delete and set the column orders defined by the developer\n-        deleteLocalTableColumnOrderByWidgetId(this.props.widgetId);\n-\n-        this.persistColumnOrder(\n-          this.props.columnOrder ?? [],\n-          leftOrder,\n-          rightOrder,\n-        );\n-      } else {\n-        const propertiesToAdd: Record<string, string> = {};\n-\n-        propertiesToAdd[\"columnOrder\"] = columnOrder;\n-\n-        /**\n-         * We reset the sticky values of the columns that were frozen by the developer.\n-         */\n-        if (Object.keys(this.props.primaryColumns).length > 0) {\n-          columnOrder.forEach((colName: string) => {\n-            if (\n-              this.props.primaryColumns[colName]?.sticky !== StickyType.NONE\n-            ) {\n-              propertiesToAdd[`primaryColumns.${colName}.sticky`] =\n-                StickyType.NONE;\n-            }\n-          });\n-        }\n-\n-        /**\n-         * We pickup the left and the right frozen columns from the localstorage\n-         * and update the sticky value of these columns respectively.\n-         */\n-\n-        if (localLeftOrder.length > 0) {\n-          localLeftOrder.forEach((colName: string) => {\n-            propertiesToAdd[`primaryColumns.${colName}.sticky`] =\n-              StickyType.LEFT;\n-          });\n-        }\n-\n-        if (localRightOrder.length > 0) {\n-          localRightOrder.forEach((colName: string) => {\n-            propertiesToAdd[`primaryColumns.${colName}.sticky`] =\n-              StickyType.RIGHT;\n-          });\n-        }\n-\n-        const propertiesToUpdate = {\n-          modify: propertiesToAdd,\n-        };\n-\n-        super.batchUpdateWidgetProperty(propertiesToUpdate);\n-      }\n-    } else {\n-      // If user deletes local storage or no column orders for the given table widget exists hydrate it with the developer changes.\n-      this.persistColumnOrder(\n-        this.props.columnOrder ?? [],\n-        leftOrder,\n-        rightOrder,\n-      );\n-    }\n-  };\n-\n-  componentDidMount() {\n-    const { canFreezeColumn, renderMode, tableData } = this.props;\n-\n-    if (_.isArray(tableData) && !!tableData.length) {\n-      const newPrimaryColumns = this.createTablePrimaryColumns();\n-\n-      // When the Table data schema changes\n-      if (newPrimaryColumns && !!Object.keys(newPrimaryColumns).length) {\n-        this.updateColumnProperties(newPrimaryColumns);\n-      }\n-    }\n-\n-    if (canFreezeColumn && renderMode === RenderModes.PAGE) {\n-      //dont neet to batch this since single action\n-      this.hydrateStickyColumns();\n-    }\n-\n-    // Commit Batch Updates property `true` is passed as commitBatchMetaUpdates is not called on componentDidMount and we need to call it for updating the batch updates\n-    this.updateInfiniteScrollProperties(true);\n-  }\n-\n-  componentDidUpdate(prevProps: TableWidgetProps) {\n-    const {\n-      commitBatchMetaUpdates,\n-      componentHeight,\n-      defaultSelectedRowIndex,\n-      defaultSelectedRowIndices,\n-      infiniteScrollEnabled,\n-      pageNo,\n-      pageSize,\n-      primaryColumns = {},\n-      pushBatchMetaUpdates,\n-      serverSidePaginationEnabled,\n-      totalRecordsCount,\n-    } = this.props;\n-\n-    // Bail out if tableData is a string. This signifies an error in evaluations\n-    if (isString(this.props.tableData)) {\n-      return;\n-    }\n-\n-    if (\n-      this.props.primaryColumns &&\n-      (!equal(prevProps.columnOrder, this.props.columnOrder) ||\n-        filter(prevProps.orderedTableColumns, { isVisible: false }).length !==\n-          filter(this.props.orderedTableColumns, { isVisible: false }).length ||\n-        getAllStickyColumnsCount(prevProps.orderedTableColumns) !==\n-          getAllStickyColumnsCount(this.props.orderedTableColumns))\n-    ) {\n-      if (this.props.renderMode === RenderModes.CANVAS) {\n-        super.batchUpdateWidgetProperty(\n-          {\n-            modify: {\n-              columnUpdatedAt: Date.now(),\n-            },\n-          },\n-          false,\n-        );\n-      }\n-    }\n-\n-    //check if necessary we are batching now updates\n-    // Check if tableData is modifed\n-    // const isTableDataModified = this.props.tableData !== prevProps.tableData;\n-    const isTableDataModified = !equal(\n-      this.props.tableData,\n-      prevProps.tableData,\n-    );\n-\n-    // If the user has changed the tableData OR\n-    // The binding has returned a new value\n-    if (isTableDataModified) {\n-      this.pushMetaRowDataUpdates(\n-        prevProps.filteredTableData,\n-        this.props.filteredTableData,\n-      );\n-\n-      pushBatchMetaUpdates(\"triggeredRowIndex\", -1);\n-\n-      const newColumnIds: string[] = getAllTableColumnKeys(\n-        this.props.tableData,\n-      );\n-      const primaryColumnIds = Object.keys(primaryColumns).filter(\n-        (id: string) => !primaryColumns[id].isDerived,\n-      );\n-\n-      if (xor(newColumnIds, primaryColumnIds).length > 0) {\n-        const newTableColumns = this.createTablePrimaryColumns();\n-\n-        if (newTableColumns) {\n-          this.updateColumnProperties(newTableColumns, isTableDataModified);\n-        }\n-\n-        pushBatchMetaUpdates(\"filters\", []);\n-      }\n-\n-      /*\n-       * Clear transient table data and editablecell when tableData changes\n-       */\n-      pushBatchMetaUpdates(\"transientTableData\", {});\n-      // reset updatedRowIndex whenever transientTableData is flushed.\n-      pushBatchMetaUpdates(\"updatedRowIndex\", -1);\n-\n-      /*\n-       * Updating the caching layer on table data modification\n-       * Commit Batch Updates property `false` is passed as commitBatchMetaUpdates is called on componentDidUpdate\n-       * and we need not to explicitly call it for updating the batch updates\n-       * */\n-      this.updateInfiniteScrollProperties();\n-\n-      this.pushClearEditableCellsUpdates();\n-      pushBatchMetaUpdates(\"selectColumnFilterText\", {});\n-    } else {\n-      // TODO: reset the widget on any property change, like if the toggle of infinite scroll is enabled and previously it was disabled, currently we update cachedTableData property to the current tableData at pageNo.\n-      /*\n-       * Commit Batch Updates property `false` is passed as commitBatchMetaUpdates is called on componentDidUpdate\n-       * and we need not to explicitly call it for updating the batch updates\n-       * */\n-      if (\n-        !prevProps.infiniteScrollEnabled &&\n-        this.props.infiniteScrollEnabled\n-      ) {\n-        this.updateInfiniteScrollProperties();\n-      }\n-    }\n-\n-    if (!pageNo) {\n-      pushBatchMetaUpdates(\"pageNo\", 1);\n-      this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);\n-    }\n-\n-    //check if pageNo does not excede the max Page no, due to change of totalRecordsCount\n-    if (serverSidePaginationEnabled !== prevProps.serverSidePaginationEnabled) {\n-      //reset pageNo when serverSidePaginationEnabled is toggled\n-      pushBatchMetaUpdates(\"pageNo\", 1);\n-      this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);\n-    } else {\n-      //check if pageNo does not excede the max Page no, due to change of totalRecordsCount or change of pageSize\n-      if (serverSidePaginationEnabled && totalRecordsCount) {\n-        const maxAllowedPageNumber = Math.ceil(totalRecordsCount / pageSize);\n-\n-        if (pageNo > maxAllowedPageNumber) {\n-          pushBatchMetaUpdates(\"pageNo\", maxAllowedPageNumber);\n-          this.updatePaginationDirectionFlags(PaginationDirection.NEXT_PAGE);\n-        }\n-      }\n-    }\n-\n-    // Reset widget state when infinite scroll is initially enabled\n-    // This should come after all updateInfiniteScrollProperties are done\n-    const didInfiniteScrollEnabledChange =\n-      prevProps.infiniteScrollEnabled !== infiniteScrollEnabled;\n-    const didComponentHeightChange =\n-      prevProps.componentHeight !== componentHeight;\n-\n-    if (\n-      didInfiniteScrollEnabledChange ||\n-      (infiniteScrollEnabled && didComponentHeightChange)\n-    ) {\n-      this.resetTableForInfiniteScroll();\n-    }\n-\n-    /*\n-     * When defaultSelectedRowIndex or defaultSelectedRowIndices\n-     * is changed from property pane\n-     */\n-    if (\n-      !equal(defaultSelectedRowIndex, prevProps.defaultSelectedRowIndex) ||\n-      !equal(defaultSelectedRowIndices, prevProps.defaultSelectedRowIndices)\n-    ) {\n-      this.pushUpdateSelectedRowIndexUpdates();\n-    }\n-\n-    this.pushResetPageNoUpdates(prevProps);\n-\n-    this.pushResetRowSelectionPropertiesUpdates(prevProps);\n-    commitBatchMetaUpdates();\n-  }\n-\n-  pushResetPageNoUpdates = (prevProps: TableWidgetProps) => {\n-    const { onPageSizeChange, pageSize, pushBatchMetaUpdates } = this.props;\n-\n-    if (pageSize !== prevProps.pageSize) {\n-      if (onPageSizeChange) {\n-        this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);\n-        pushBatchMetaUpdates(\"pageNo\", 1, {\n-          triggerPropertyName: \"onPageSizeChange\",\n-          dynamicString: onPageSizeChange,\n-          event: {\n-            type: EventType.ON_PAGE_SIZE_CHANGE,\n-          },\n-        });\n-      } else {\n-        pushBatchMetaUpdates(\"pageNo\", 1);\n-        this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);\n-      }\n-    }\n-  };\n-\n-  pushResetRowSelectionPropertiesUpdates = (prevProps: TableWidgetProps) => {\n-    const {\n-      defaultSelectedRowIndex,\n-      defaultSelectedRowIndices,\n-      multiRowSelection,\n-      pushBatchMetaUpdates,\n-    } = this.props;\n-\n-    // reset selectedRowIndices and selectedRowIndex to defaults\n-    if (multiRowSelection !== prevProps.multiRowSelection) {\n-      if (multiRowSelection) {\n-        if (\n-          defaultSelectedRowIndices &&\n-          _.isArray(defaultSelectedRowIndices) &&\n-          defaultSelectedRowIndices.every((i) => _.isFinite(i))\n-        ) {\n-          pushBatchMetaUpdates(\"selectedRowIndices\", defaultSelectedRowIndices);\n-        }\n-\n-        pushBatchMetaUpdates(\"selectedRowIndex\", -1);\n-      } else {\n-        if (\n-          !isNil(defaultSelectedRowIndex) &&\n-          parseInt(defaultSelectedRowIndex?.toString(), 10) > -1\n-        ) {\n-          pushBatchMetaUpdates(\"selectedRowIndex\", defaultSelectedRowIndex);\n-        }\n-\n-        pushBatchMetaUpdates(\"selectedRowIndices\", []);\n-      }\n-    }\n-  };\n-\n-  /*\n-   * Function to update selectedRowIndices & selectedRowIndex from\n-   * defaultSelectedRowIndices & defaultSelectedRowIndex respectively\n-   */\n-  pushUpdateSelectedRowIndexUpdates = () => {\n-    const {\n-      defaultSelectedRowIndex,\n-      defaultSelectedRowIndices,\n-      multiRowSelection,\n-      pushBatchMetaUpdates,\n-    } = this.props;\n-\n-    if (multiRowSelection) {\n-      pushBatchMetaUpdates(\"selectedRowIndices\", defaultSelectedRowIndices);\n-    } else {\n-      pushBatchMetaUpdates(\"selectedRowIndex\", defaultSelectedRowIndex);\n-    }\n-  };\n-\n-  /*\n-   * Function to update selectedRow details when order of tableData changes\n-   */\n-  pushMetaRowDataUpdates = (\n-    oldTableData: Array<Record<string, unknown>>,\n-    newTableData: Array<Record<string, unknown>>,\n-  ) => {\n-    const {\n-      defaultSelectedRowIndex,\n-      defaultSelectedRowIndices,\n-      multiRowSelection,\n-      primaryColumnId,\n-      pushBatchMetaUpdates,\n-      selectedRowIndex,\n-      selectedRowIndices,\n-    } = this.props;\n-\n-    if (multiRowSelection) {\n-      const indices = getSelectRowIndices(\n-        oldTableData,\n-        newTableData,\n-        defaultSelectedRowIndices,\n-        selectedRowIndices,\n-        primaryColumnId,\n-      );\n-\n-      pushBatchMetaUpdates(\"selectedRowIndices\", indices);\n-    } else {\n-      const index = getSelectRowIndex(\n-        oldTableData,\n-        newTableData,\n-        defaultSelectedRowIndex,\n-        selectedRowIndex,\n-        primaryColumnId,\n-      );\n-\n-      pushBatchMetaUpdates(\"selectedRowIndex\", index);\n-    }\n-  };\n-\n-  getSelectedRowIndices = () => {\n-    const { multiRowSelection, selectedRowIndices } = this.props;\n-\n-    let indices: number[] | undefined;\n-\n-    if (multiRowSelection) {\n-      if (_.isArray(selectedRowIndices)) {\n-        indices = selectedRowIndices;\n-      } else if (_.isNumber(selectedRowIndices)) {\n-        indices = [selectedRowIndices];\n-      } else {\n-        indices = [];\n-      }\n-    } else {\n-      indices = undefined;\n-    }\n-\n-    return indices;\n-  };\n-\n-  updateFilters = (filters: ReactTableFilter[]) => {\n-    const {\n-      commitBatchMetaUpdates,\n-      enableServerSideFiltering,\n-      onTableFilterUpdate,\n-      pushBatchMetaUpdates,\n-    } = this.props;\n-\n-    this.pushResetSelectedRowIndexUpdates();\n-\n-    if (enableServerSideFiltering) {\n-      pushBatchMetaUpdates(\"filters\", filters, {\n-        triggerPropertyName: \"onTableFilterUpdate\",\n-        dynamicString: onTableFilterUpdate,\n-        event: {\n-          type: EventType.ON_FILTER_UPDATE,\n-        },\n-      });\n-    } else {\n-      pushBatchMetaUpdates(\"filters\", filters);\n-    }\n-\n-    // Reset Page only when a filter is added\n-    if (!isEmpty(xorWith(filters, [DEFAULT_FILTER], equal))) {\n-      pushBatchMetaUpdates(\"pageNo\", 1);\n-      this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);\n-    }\n-\n-    commitBatchMetaUpdates();\n-  };\n-\n-  toggleDrag = (disable: boolean) => {\n-    this.disableDrag(disable);\n-  };\n-\n-  getPaddingAdjustedDimensions = () => {\n-    // eslint-disable-next-line prefer-const\n-    let { componentHeight, componentWidth } = this.props;\n-\n-    // (2 * WIDGET_PADDING) gives the total horizontal padding (i.e. paddingLeft + paddingRight)\n-    componentWidth = componentWidth - 2 * WIDGET_PADDING;\n-\n-    return { componentHeight, componentWidth };\n-  };\n-\n-  getWidgetView() {\n-    const {\n-      customIsLoading,\n-      customIsLoadingValue,\n-      customSortFunction: customSortFunctionData,\n-      delimiter,\n-      filteredTableData = [],\n-      isVisibleDownload,\n-      isVisibleFilters,\n-      isVisiblePagination,\n-      isVisibleSearch,\n-      pageSize,\n-      primaryColumns,\n-      totalRecordsCount,\n-    } = this.props;\n-\n-    const tableColumns = this.getTableColumns() || emptyArr;\n-    let data = filteredTableData;\n-\n-    if (customSortFunctionData && Array.isArray(customSortFunctionData)) {\n-      data = customSortFunctionData;\n-    }\n-\n-    const transformedData = this.transformData(data, tableColumns);\n-\n-    const isVisibleHeaderOptions =\n-      isVisibleDownload ||\n-      isVisibleFilters ||\n-      isVisiblePagination ||\n-      isVisibleSearch;\n-\n-    const { componentHeight, componentWidth } =\n-      this.getPaddingAdjustedDimensions();\n-    const finalTableData = this.memoisedAddNewRow(\n-      transformedData,\n-      this.props.isAddRowInProgress,\n-      this.props.newRowContent,\n-    );\n-\n-    return (\n-      <Suspense fallback={<Skeleton />}>\n-        <ReactTableComponent\n-          accentColor={this.props.accentColor}\n-          allowAddNewRow={this.props.allowAddNewRow}\n-          allowRowSelection={!this.props.isAddRowInProgress}\n-          allowSorting={!this.props.isAddRowInProgress}\n-          applyFilter={this.updateFilters}\n-          borderColor={this.props.borderColor}\n-          borderRadius={this.props.borderRadius}\n-          borderWidth={this.props.borderWidth}\n-          boxShadow={this.props.boxShadow}\n-          cachedTableData={this.props.cachedTableData}\n-          canFreezeColumn={this.props.canFreezeColumn}\n-          columnWidthMap={this.props.columnWidthMap}\n-          columns={tableColumns}\n-          compactMode={this.props.compactMode || CompactModeTypes.DEFAULT}\n-          delimiter={delimiter}\n-          disableDrag={this.toggleDrag}\n-          disabledAddNewRowSave={this.hasInvalidColumnCell()}\n-          editMode={this.props.renderMode === RenderModes.CANVAS}\n-          editableCell={this.props.editableCell}\n-          endOfData={this.props.endOfData}\n-          filters={this.props.filters}\n-          handleColumnFreeze={this.handleColumnFreeze}\n-          handleReorderColumn={this.handleReorderColumn}\n-          handleResizeColumn={this.handleResizeColumn}\n-          height={componentHeight}\n-          isAddRowInProgress={this.props.isAddRowInProgress}\n-          isEditableCellsValid={this.props.isEditableCellsValid}\n-          isInfiniteScrollEnabled={this.props.infiniteScrollEnabled}\n-          isLoading={\n-            customIsLoading\n-              ? customIsLoadingValue || this.props.isLoading\n-              : this.props.isLoading\n-          }\n-          isSortable={this.props.isSortable ?? true}\n-          isVisibleDownload={isVisibleDownload}\n-          isVisibleFilters={isVisibleFilters}\n-          isVisiblePagination={isVisiblePagination}\n-          isVisibleSearch={isVisibleSearch}\n-          multiRowSelection={\n-            this.props.multiRowSelection && !this.props.isAddRowInProgress\n-          }\n-          nextPageClick={this.handleNextPageClick}\n-          onAddNewRow={this.handleAddNewRowClick}\n-          onAddNewRowAction={this.handleAddNewRowAction}\n-          onBulkEditDiscard={this.onBulkEditDiscard}\n-          onBulkEditSave={this.onBulkEditSave}\n-          onConnectData={this.onConnectData}\n-          onRowClick={this.handleRowClick}\n-          pageNo={this.props.pageNo}\n-          pageSize={\n-            isVisibleHeaderOptions ? Math.max(1, pageSize) : pageSize + 1\n-          }\n-          prevPageClick={this.handlePrevPageClick}\n-          primaryColumnId={this.props.primaryColumnId}\n-          searchKey={this.props.searchText}\n-          searchTableData={this.handleSearchTable}\n-          selectAllRow={this.handleAllRowSelect}\n-          selectedRowIndex={\n-            this.props.selectedRowIndex === undefined\n-              ? -1\n-              : this.props.selectedRowIndex\n-          }\n-          selectedRowIndices={this.getSelectedRowIndices()}\n-          serverSidePaginationEnabled={!!this.props.serverSidePaginationEnabled}\n-          showConnectDataOverlay={\n-            primaryColumns &&\n-            !Object.keys(primaryColumns).length &&\n-            this.props.renderMode === RenderModes.CANVAS\n-          }\n-          sortTableColumn={this.handleColumnSorting}\n-          tableData={finalTableData}\n-          totalRecordsCount={totalRecordsCount}\n-          triggerRowSelection={this.props.triggerRowSelection}\n-          unSelectAllRow={this.unSelectAllRow}\n-          updatePageNo={this.updatePageNumber}\n-          variant={this.props.variant}\n-          widgetId={this.props.widgetId}\n-          widgetName={this.props.widgetName}\n-          width={componentWidth}\n-        />\n-      </Suspense>\n-    );\n-  }\n-\n-  /**\n-   * Function to update or add the tableWidgetColumnOrder key in the local storage\n-   * tableWidgetColumnOrder = {\n-   *  <widget-id>: {\n-   *    columnOrder: [],\n-   *    leftOrder: [],\n-   *    rightOrder: [],\n-   *  }\n-   * }\n-   */\n-  persistColumnOrder = (\n-    newColumnOrder: string[],\n-    leftOrder: string[],\n-    rightOrder: string[],\n-  ) => {\n-    const widgetId = this.props.widgetId;\n-    const localTableWidgetColumnOrder = localStorage.getItem(\n-      TABLE_COLUMN_ORDER_KEY,\n-    );\n-    let newTableColumnOrder;\n-\n-    if (localTableWidgetColumnOrder) {\n-      try {\n-        let parsedTableWidgetColumnOrder = JSON.parse(\n-          localTableWidgetColumnOrder,\n-        );\n-\n-        let columnOrder;\n-\n-        if (newColumnOrder) {\n-          columnOrder = newColumnOrder;\n-        } else if (parsedTableWidgetColumnOrder[widgetId]) {\n-          columnOrder = parsedTableWidgetColumnOrder[widgetId];\n-        } else {\n-          columnOrder = this.props.columnOrder;\n-        }\n-\n-        parsedTableWidgetColumnOrder = {\n-          ...parsedTableWidgetColumnOrder,\n-          [widgetId]: {\n-            columnOrder,\n-            columnUpdatedAt: this.props.columnUpdatedAt,\n-            leftOrder,\n-            rightOrder,\n-          },\n-        };\n-\n-        newTableColumnOrder = parsedTableWidgetColumnOrder;\n-      } catch (e) {\n-        log.debug(\"Unable to parse local column order:\", { e });\n-      }\n-    } else {\n-      const tableWidgetColumnOrder = {\n-        [widgetId]: {\n-          columnOrder: newColumnOrder,\n-          columnUpdatedAt: this.props.columnUpdatedAt,\n-          leftOrder,\n-          rightOrder,\n-        },\n-      };\n-\n-      newTableColumnOrder = tableWidgetColumnOrder;\n-    }\n-\n-    localStorage.setItem(\n-      TABLE_COLUMN_ORDER_KEY,\n-      JSON.stringify(newTableColumnOrder),\n-    );\n-  };\n-\n-  handleColumnFreeze = (columnName: string, sticky?: StickyType) => {\n-    if (this.props.columnOrder) {\n-      let newColumnOrder;\n-      const localTableColumnOrder = getColumnOrderByWidgetIdFromLS(\n-        this.props.widgetId,\n-      );\n-\n-      if (this.props.renderMode === RenderModes.CANVAS) {\n-        newColumnOrder = generateNewColumnOrderFromStickyValue(\n-          this.props.primaryColumns,\n-          this.props.columnOrder,\n-          columnName,\n-          sticky,\n-        );\n-\n-        // Updating these properties in batch so that undo/redo gets executed in a combined way.\n-        super.batchUpdateWidgetProperty(\n-          {\n-            modify: {\n-              [`primaryColumns.${columnName}.sticky`]: sticky,\n-              columnOrder: newColumnOrder,\n-            },\n-          },\n-          true,\n-        );\n-      } else if (\n-        localTableColumnOrder &&\n-        this.props.renderMode === RenderModes.PAGE\n-      ) {\n-        const { leftOrder, rightOrder } = localTableColumnOrder;\n-\n-        newColumnOrder = generateLocalNewColumnOrderFromStickyValue(\n-          localTableColumnOrder.columnOrder,\n-          columnName,\n-          sticky,\n-          leftOrder,\n-          rightOrder,\n-        );\n-        const updatedOrders = updateAndSyncTableLocalColumnOrders(\n-          columnName,\n-          leftOrder,\n-          rightOrder,\n-          sticky,\n-        );\n-\n-        this.persistColumnOrder(\n-          newColumnOrder,\n-          updatedOrders.leftOrder,\n-          updatedOrders.rightOrder,\n-        );\n-\n-        super.batchUpdateWidgetProperty(\n-          {\n-            modify: {\n-              [`primaryColumns.${columnName}.sticky`]: sticky,\n-              columnOrder: newColumnOrder,\n-            },\n-          },\n-          true,\n-        );\n-      }\n-    }\n-  };\n-\n-  handleReorderColumn = (columnOrder: string[]) => {\n-    columnOrder = columnOrder.map((alias) => this.getColumnIdByAlias(alias));\n-\n-    if (\n-      this.props.canFreezeColumn &&\n-      this.props.renderMode === RenderModes.PAGE\n-    ) {\n-      const localTableColumnOrder = getColumnOrderByWidgetIdFromLS(\n-        this.props.widgetId,\n-      );\n-\n-      if (localTableColumnOrder) {\n-        const { leftOrder, rightOrder } = localTableColumnOrder;\n-\n-        this.persistColumnOrder(columnOrder, leftOrder, rightOrder);\n-      } else {\n-        this.persistColumnOrder(columnOrder, [], []);\n-      }\n-    }\n-\n-    super.updateWidgetProperty(\"columnOrder\", columnOrder);\n-  };\n-\n-  handleColumnSorting = (columnAccessor: string, isAsc: boolean) => {\n-    const columnId = this.getColumnIdByAlias(columnAccessor);\n-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-    this.pushResetSelectedRowIndexUpdates(false);\n-\n-    let sortOrderProps;\n-\n-    if (columnId) {\n-      sortOrderProps = {\n-        column: columnId,\n-        order: isAsc ? SortOrderTypes.asc : SortOrderTypes.desc,\n-      };\n-    } else {\n-      sortOrderProps = {\n-        column: \"\",\n-        order: null,\n-      };\n-    }\n-\n-    pushBatchMetaUpdates(\"sortOrder\", sortOrderProps, {\n-      triggerPropertyName: \"onSort\",\n-      dynamicString: this.props.onSort,\n-      event: {\n-        type: EventType.ON_SORT,\n-      },\n-    });\n-    commitBatchMetaUpdates();\n-  };\n-\n-  handleResizeColumn = (columnWidthMap: { [key: string]: number }) => {\n-    if (this.props.renderMode === RenderModes.CANVAS) {\n-      super.updateWidgetProperty(\"columnWidthMap\", columnWidthMap);\n-    } else {\n-      //single action no need to batch\n-      this.props.updateWidgetMetaProperty(\"columnWidthMap\", columnWidthMap);\n-    }\n-  };\n-\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  handleSearchTable = (searchKey: any) => {\n-    const {\n-      commitBatchMetaUpdates,\n-      multiRowSelection,\n-      onSearchTextChanged,\n-      pushBatchMetaUpdates,\n-    } = this.props;\n-\n-    /*\n-     * Clear rowSelection to avoid selecting filtered rows\n-     * based on stale selection indices\n-     */\n-    if (multiRowSelection) {\n-      pushBatchMetaUpdates(\"selectedRowIndices\", []);\n-    } else {\n-      pushBatchMetaUpdates(\"selectedRowIndex\", -1);\n-    }\n-\n-    pushBatchMetaUpdates(\"pageNo\", 1);\n-    this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);\n-\n-    pushBatchMetaUpdates(\"searchText\", searchKey, {\n-      triggerPropertyName: \"onSearchTextChanged\",\n-      dynamicString: onSearchTextChanged,\n-      event: {\n-        type: EventType.ON_SEARCH,\n-      },\n-    });\n-\n-    commitBatchMetaUpdates();\n-  };\n-\n-  /**\n-   * This function just pushes the meta update\n-   */\n-  pushOnColumnEvent = ({\n-    action,\n-    additionalData = {},\n-    eventType,\n-    onComplete = noop,\n-    row,\n-    rowIndex,\n-    triggerPropertyName,\n-  }: OnColumnEventArgs) => {\n-    const { filteredTableData = [], pushBatchMetaUpdates } = this.props;\n-\n-    const currentRow = row || filteredTableData[rowIndex];\n-\n-    pushBatchMetaUpdates(\n-      \"triggeredRowIndex\",\n-      currentRow?.[ORIGINAL_INDEX_KEY],\n-      {\n-        triggerPropertyName: triggerPropertyName,\n-        dynamicString: action,\n-        event: {\n-          type: eventType,\n-          callback: onComplete,\n-        },\n-        globalContext: { currentRow, ...additionalData },\n-      },\n-    );\n-  };\n-  /*\n-   * Function to handle customColumn button type click interactions\n-   */\n-  onColumnEvent = ({\n-    action,\n-    additionalData = {},\n-    eventType,\n-    onComplete = noop,\n-    row,\n-    rowIndex,\n-    triggerPropertyName,\n-  }: OnColumnEventArgs) => {\n-    if (action) {\n-      const { commitBatchMetaUpdates } = this.props;\n-\n-      this.pushOnColumnEvent({\n-        rowIndex,\n-        action,\n-        onComplete,\n-        triggerPropertyName,\n-        eventType,\n-        row,\n-        additionalData,\n-      });\n-      commitBatchMetaUpdates();\n-    } else {\n-      onComplete();\n-    }\n-  };\n-\n-  onDropdownOptionSelect = (action: string) => {\n-    super.executeAction({\n-      dynamicString: action,\n-      event: {\n-        type: EventType.ON_OPTION_CHANGE,\n-      },\n-    });\n-  };\n-\n-  handleAllRowSelect = (pageData: Record<string, unknown>[]) => {\n-    if (this.props.multiRowSelection) {\n-      const selectedRowIndices = pageData.map(\n-        (row: Record<string, unknown>) => row.index,\n-      );\n-\n-      //single action no need to batch\n-      this.props.updateWidgetMetaProperty(\n-        \"selectedRowIndices\",\n-        selectedRowIndices,\n-      );\n-    }\n-  };\n-\n-  handleRowClick = (row: Record<string, unknown>, selectedIndex: number) => {\n-    const { multiRowSelection, selectedRowIndex, selectedRowIndices } =\n-      this.props;\n-    // no need to batch actions here because it a time only one will execute\n-\n-    if (multiRowSelection) {\n-      let indices: Array<number>;\n-\n-      if (_.isArray(selectedRowIndices)) {\n-        indices = [...selectedRowIndices];\n-      } else {\n-        indices = [];\n-      }\n-\n-      /*\n-       * Deselect if the index is already present\n-       */\n-      if (indices.includes(selectedIndex)) {\n-        indices.splice(indices.indexOf(selectedIndex), 1);\n-        this.props.updateWidgetMetaProperty(\"selectedRowIndices\", indices);\n-      } else {\n-        /*\n-         * select if the index is not present already\n-         */\n-        indices.push(selectedIndex);\n-\n-        this.props.updateWidgetMetaProperty(\"selectedRowIndices\", indices, {\n-          triggerPropertyName: \"onRowSelected\",\n-          dynamicString: this.props.onRowSelected,\n-          event: {\n-            type: EventType.ON_ROW_SELECTED,\n-          },\n-        });\n-      }\n-    } else {\n-      let index;\n-\n-      if (isNumber(selectedRowIndex)) {\n-        index = selectedRowIndex;\n-      } else {\n-        index = -1;\n-      }\n-\n-      if (index !== selectedIndex) {\n-        this.props.updateWidgetMetaProperty(\"selectedRowIndex\", selectedIndex, {\n-          triggerPropertyName: \"onRowSelected\",\n-          dynamicString: this.props.onRowSelected,\n-          event: {\n-            type: EventType.ON_ROW_SELECTED,\n-          },\n-        });\n-      } else {\n-        this.props.updateWidgetMetaProperty(\"selectedRowIndex\", -1);\n-      }\n-    }\n-  };\n-\n-  updatePageNumber = (pageNo: number, event?: EventType) => {\n-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-    const paginationDirection =\n-      event == EventType.ON_NEXT_PAGE\n-        ? PaginationDirection.NEXT_PAGE\n-        : PaginationDirection.PREVIOUS_PAGE;\n-\n-    this.updatePaginationDirectionFlags(paginationDirection);\n-\n-    if (event) {\n-      pushBatchMetaUpdates(\"pageNo\", pageNo, {\n-        triggerPropertyName: \"onPageChange\",\n-        dynamicString: this.props.onPageChange,\n-        event: {\n-          type: event,\n-        },\n-      });\n-    } else {\n-      pushBatchMetaUpdates(\"pageNo\", pageNo);\n-    }\n-\n-    if (this.props.onPageChange) {\n-      this.pushResetSelectedRowIndexUpdates();\n-    }\n-\n-    commitBatchMetaUpdates();\n-  };\n-\n-  updatePaginationDirectionFlags = (direction?: PaginationDirection) => {\n-    const { pushBatchMetaUpdates } = this.props;\n-\n-    let previousButtonFlag = false;\n-    let nextButtonFlag = false;\n-\n-    if (direction) {\n-      switch (direction) {\n-        case PaginationDirection.INITIAL: {\n-          previousButtonFlag = false;\n-          nextButtonFlag = false;\n-          break;\n-        }\n-        case PaginationDirection.NEXT_PAGE: {\n-          nextButtonFlag = true;\n-          break;\n-        }\n-        case PaginationDirection.PREVIOUS_PAGE: {\n-          previousButtonFlag = true;\n-          break;\n-        }\n-      }\n-    }\n-\n-    pushBatchMetaUpdates(\"previousPageVisited\", previousButtonFlag);\n-    pushBatchMetaUpdates(\"nextPageVisited\", nextButtonFlag);\n-  };\n-\n-  handleNextPageClick = () => {\n-    const pageNo = (this.props.pageNo || 1) + 1;\n-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-    this.updatePaginationDirectionFlags(PaginationDirection.NEXT_PAGE);\n-\n-    pushBatchMetaUpdates(\"pageNo\", pageNo, {\n-      triggerPropertyName: \"onPageChange\",\n-      dynamicString: this.props.onPageChange,\n-      event: {\n-        type: EventType.ON_NEXT_PAGE,\n-      },\n-    });\n-\n-    if (this.props.onPageChange) {\n-      this.pushResetSelectedRowIndexUpdates();\n-    }\n-\n-    commitBatchMetaUpdates();\n-  };\n-\n-  pushResetSelectedRowIndexUpdates = (skipDefault?: boolean) => {\n-    const { pushBatchMetaUpdates } = this.props;\n-\n-    const {\n-      defaultSelectedRowIndex,\n-      defaultSelectedRowIndices,\n-      multiRowSelection,\n-    } = this.props;\n-\n-    if (multiRowSelection) {\n-      pushBatchMetaUpdates(\n-        \"selectedRowIndices\",\n-        skipDefault ? [] : defaultSelectedRowIndices,\n-      );\n-    } else {\n-      pushBatchMetaUpdates(\n-        \"selectedRowIndex\",\n-        skipDefault ? -1 : defaultSelectedRowIndex,\n-      );\n-    }\n-  };\n-\n-  unSelectAllRow = () => {\n-    this.props.updateWidgetMetaProperty(\"selectedRowIndices\", []);\n-  };\n-\n-  handlePrevPageClick = () => {\n-    const pageNo = (this.props.pageNo || 1) - 1;\n-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-    if (pageNo >= 1) {\n-      this.updatePaginationDirectionFlags(PaginationDirection.PREVIOUS_PAGE);\n-      pushBatchMetaUpdates(\"pageNo\", pageNo, {\n-        triggerPropertyName: \"onPageChange\",\n-        dynamicString: this.props.onPageChange,\n-        event: {\n-          type: EventType.ON_PREV_PAGE,\n-        },\n-      });\n-\n-      if (this.props.onPageChange) {\n-        this.pushResetSelectedRowIndexUpdates();\n-      }\n-    }\n-\n-    commitBatchMetaUpdates();\n-  };\n-\n-  getColumnIdByAlias(alias: string) {\n-    const { primaryColumns } = this.props;\n-\n-    if (primaryColumns) {\n-      const column = Object.values(primaryColumns).find(\n-        (column) => column.alias === alias,\n-      );\n-\n-      if (column) {\n-        return column.id;\n-      }\n-    }\n-\n-    return alias;\n-  }\n-\n-  getColumnByOriginalId(originalId: string) {\n-    return Object.values(this.props.primaryColumns).find((column) => {\n-      return column.originalId === originalId;\n-    });\n-  }\n-\n-  pushTransientTableDataActionsUpdates = (data: TransientDataPayload) => {\n-    const { __originalIndex__, ...transientData } = data;\n-    const { pushBatchMetaUpdates } = this.props;\n-\n-    pushBatchMetaUpdates(\"transientTableData\", {\n-      ...this.props.transientTableData,\n-      [__originalIndex__]: {\n-        ...this.props.transientTableData[__originalIndex__],\n-        ...transientData,\n-      },\n-    });\n-\n-    pushBatchMetaUpdates(\"updatedRowIndex\", __originalIndex__);\n-  };\n-\n-  removeRowFromTransientTableData = (index: number) => {\n-    const newTransientTableData = klonaRegularWithTelemetry(\n-      this.props.transientTableData,\n-      \"TableWidgetV2.removeRowFromTransientTableData\",\n-    );\n-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-    if (newTransientTableData) {\n-      delete newTransientTableData[index];\n-\n-      pushBatchMetaUpdates(\"transientTableData\", newTransientTableData);\n-    }\n-\n-    pushBatchMetaUpdates(\"updatedRowIndex\", -1);\n-    commitBatchMetaUpdates();\n-  };\n-\n-  getRowOriginalIndex = (index: number) => {\n-    const { filteredTableData } = this.props;\n-\n-    if (filteredTableData) {\n-      const row = filteredTableData[index];\n-\n-      if (row) {\n-        return row[ORIGINAL_INDEX_KEY];\n-      }\n-    }\n-\n-    return -1;\n-  };\n-\n-  onBulkEditSave = () => {\n-    this.props.updateWidgetMetaProperty(\n-      \"transientTableData\",\n-      this.props.transientTableData,\n-      {\n-        triggerPropertyName: \"onBulkSave\",\n-        dynamicString: this.props.onBulkSave,\n-        event: {\n-          type: EventType.ON_BULK_SAVE,\n-        },\n-      },\n-    );\n-  };\n-\n-  onBulkEditDiscard = () => {\n-    this.props.updateWidgetMetaProperty(\n-      \"transientTableData\",\n-      {},\n-      {\n-        triggerPropertyName: \"onBulkDiscard\",\n-        dynamicString: this.props.onBulkDiscard,\n-        event: {\n-          type: EventType.ON_BULK_DISCARD,\n-        },\n-      },\n-    );\n-  };\n-\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  renderCell = (props: any) => {\n-    const column =\n-      this.getColumnByOriginalId(\n-        props.cell.column.columnProperties.originalId,\n-      ) || props.cell.column.columnProperties;\n-    const rowIndex = props.cell.row.index;\n-\n-    /*\n-     * We don't need to render cells that don't display data (button, iconButton, etc)\n-     */\n-    if (\n-      this.props.isAddRowInProgress &&\n-      rowIndex === 0 &&\n-      ActionColumnTypes.includes(column.columnType)\n-    ) {\n-      return <CellWrapper />;\n-    }\n-\n-    const isHidden = !column.isVisible;\n-    const {\n-      compactMode = CompactModeTypes.DEFAULT,\n-      filteredTableData = [],\n-      multiRowSelection,\n-      selectedRowIndex,\n-      selectedRowIndices,\n-    } = this.props;\n-    let row;\n-    let originalIndex: number;\n-\n-    /*\n-     * In add new row flow, a temporary row is injected at the top of the tableData, which doesn't\n-     * have original row index value. so we are using -1 as the value\n-     */\n-    if (this.props.isAddRowInProgress) {\n-      row = filteredTableData[rowIndex - 1];\n-      originalIndex =\n-        rowIndex === 0 ? -1 : row?.[ORIGINAL_INDEX_KEY] ?? rowIndex;\n-    } else {\n-      row = filteredTableData[rowIndex];\n-      originalIndex = row ? row[ORIGINAL_INDEX_KEY] ?? rowIndex : rowIndex;\n-    }\n-\n-    const isNewRow = this.props.isAddRowInProgress && rowIndex === 0;\n-\n-    /*\n-     * cellProperties order or size does not change when filter/sorting/grouping is applied\n-     * on the data thus original index is needed to identify the column's cell property.\n-     */\n-    const cellProperties = getCellProperties(column, originalIndex, isNewRow);\n-    let isSelected = false;\n-\n-    if (this.props.transientTableData) {\n-      cellProperties.hasUnsavedChanges =\n-        this.props.transientTableData.hasOwnProperty(originalIndex) &&\n-        this.props.transientTableData[originalIndex].hasOwnProperty(\n-          props.cell.column.columnProperties.alias,\n-        );\n-    }\n-\n-    if (multiRowSelection) {\n-      isSelected =\n-        _.isArray(selectedRowIndices) && selectedRowIndices.includes(rowIndex);\n-    } else {\n-      isSelected = selectedRowIndex === rowIndex;\n-    }\n-\n-    const isColumnEditable =\n-      column.isEditable &&\n-      isColumnTypeEditable(column.columnType, this.props.infiniteScrollEnabled);\n-    const alias = props.cell.column.columnProperties.alias;\n-\n-    const isCellEditable = isColumnEditable && cellProperties.isCellEditable;\n-\n-    const isCellEditMode =\n-      (props.cell.column.alias === this.props.editableCell?.column &&\n-        rowIndex === this.props.editableCell?.index) ||\n-      (isNewRow && isColumnEditable);\n-\n-    const shouldDisableEdit =\n-      (this.props.inlineEditingSaveOption ===\n-        InlineEditingSaveOptions.ROW_LEVEL &&\n-        this.props.updatedRowIndices.length &&\n-        this.props.updatedRowIndices.indexOf(originalIndex) === -1) ||\n-      (this.hasInvalidColumnCell() && !isNewRow);\n-\n-    const disabledEditMessage = `Save or discard the ${\n-      this.props.isAddRowInProgress ? \"newly added\" : \"unsaved\"\n-    } row to start editing here`;\n-\n-    if (this.props.isAddRowInProgress) {\n-      cellProperties.isCellDisabled = rowIndex !== 0;\n-\n-      if (rowIndex === 0) {\n-        cellProperties.cellBackground = \"\";\n-      }\n-    }\n-\n-    switch (column.columnType) {\n-      case ColumnTypes.BUTTON:\n-        return (\n-          <ButtonCell\n-            allowCellWrapping={cellProperties.allowCellWrapping}\n-            cellBackground={cellProperties.cellBackground}\n-            columnActions={[\n-              {\n-                backgroundColor:\n-                  cellProperties.buttonColor || this.props.accentColor,\n-                eventType: EventType.ON_CLICK,\n-                id: column.id,\n-                isVisible: true,\n-                label: cellProperties.buttonLabel || DEFAULT_BUTTON_LABEL,\n-                dynamicTrigger: column.onClick || \"\",\n-                variant: cellProperties.buttonVariant,\n-                borderRadius:\n-                  cellProperties.borderRadius || this.props.borderRadius,\n-                boxShadow: cellProperties.boxShadow,\n-              },\n-            ]}\n-            compactMode={compactMode}\n-            fontStyle={cellProperties.fontStyle}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isDisabled={!!cellProperties.isDisabled}\n-            isHidden={isHidden}\n-            isSelected={isSelected}\n-            onCommandClick={(action: string, onComplete: () => void) =>\n-              this.onColumnEvent({\n-                rowIndex,\n-                action,\n-                onComplete,\n-                triggerPropertyName: \"onClick\",\n-                eventType: EventType.ON_CLICK,\n-              })\n-            }\n-            textColor={cellProperties.textColor}\n-            textSize={cellProperties.textSize}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-          />\n-        );\n-\n-      case ColumnTypes.EDIT_ACTIONS:\n-        return (\n-          <EditActionCell\n-            allowCellWrapping={cellProperties.allowCellWrapping}\n-            cellBackground={cellProperties.cellBackground}\n-            columnActions={[\n-              {\n-                id: EditableCellActions.SAVE,\n-                label: cellProperties.saveActionLabel,\n-                dynamicTrigger: column.onSave || \"\",\n-                eventType: EventType.ON_ROW_SAVE,\n-                iconName: cellProperties.saveActionIconName,\n-                variant: cellProperties.saveButtonVariant,\n-                backgroundColor:\n-                  cellProperties.saveButtonColor || this.props.accentColor,\n-                iconAlign: cellProperties.saveIconAlign,\n-                borderRadius:\n-                  cellProperties.saveBorderRadius || this.props.borderRadius,\n-                isVisible: cellProperties.isSaveVisible,\n-                isDisabled:\n-                  cellProperties.isSaveDisabled || this.hasInvalidColumnCell(),\n-                boxShadow: cellProperties.boxShadow,\n-              },\n-              {\n-                id: EditableCellActions.DISCARD,\n-                label: cellProperties.discardActionLabel,\n-                dynamicTrigger: column.onDiscard || \"\",\n-                eventType: EventType.ON_ROW_DISCARD,\n-                iconName: cellProperties.discardActionIconName,\n-                variant: cellProperties.discardButtonVariant,\n-                backgroundColor:\n-                  cellProperties.discardButtonColor || this.props.accentColor,\n-                iconAlign: cellProperties.discardIconAlign,\n-                borderRadius:\n-                  cellProperties.discardBorderRadius || this.props.borderRadius,\n-                isVisible: cellProperties.isDiscardVisible,\n-                isDisabled:\n-                  cellProperties.isDiscardDisabled ||\n-                  this.hasInvalidColumnCell(),\n-                boxShadow: cellProperties.boxShadow,\n-              },\n-            ]}\n-            compactMode={compactMode}\n-            fontStyle={cellProperties.fontStyle}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellVisible={cellProperties.isCellVisible}\n-            isHidden={isHidden}\n-            isSelected={isSelected}\n-            onCommandClick={(\n-              action: string,\n-              onComplete: () => void,\n-              eventType: EventType,\n-            ) =>\n-              this.onColumnEvent({\n-                rowIndex,\n-                action,\n-                onComplete,\n-                triggerPropertyName: \"onClick\",\n-                eventType: eventType,\n-              })\n-            }\n-            onDiscard={() =>\n-              this.removeRowFromTransientTableData(originalIndex)\n-            }\n-            textColor={cellProperties.textColor}\n-            textSize={cellProperties.textSize}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-          />\n-        );\n-\n-      case ColumnTypes.SELECT:\n-        return (\n-          <SelectCell\n-            accentColor={this.props.accentColor}\n-            alias={props.cell.column.columnProperties.alias}\n-            allowCellWrapping={cellProperties.allowCellWrapping}\n-            autoOpen={!this.props.isAddRowInProgress}\n-            borderRadius={cellProperties.borderRadius}\n-            cellBackground={cellProperties.cellBackground}\n-            columnType={column.columnType}\n-            compactMode={compactMode}\n-            disabledEditIcon={\n-              shouldDisableEdit || this.props.isAddRowInProgress\n-            }\n-            disabledEditIconMessage={disabledEditMessage}\n-            filterText={\n-              this.props.selectColumnFilterText?.[\n-                this.props.editableCell?.column || column.alias\n-              ]\n-            }\n-            fontStyle={cellProperties.fontStyle}\n-            hasUnsavedChanges={cellProperties.hasUnsavedChanges}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellEditMode={isCellEditMode}\n-            isCellEditable={isCellEditable}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isEditable={isColumnEditable}\n-            isEditableCellValid={this.isColumnCellValid(alias)}\n-            isFilterable={cellProperties.isFilterable}\n-            isHidden={isHidden}\n-            isNewRow={isNewRow}\n-            key={props.key}\n-            onFilterChange={this.onSelectFilterChange}\n-            onFilterChangeActionString={column.onFilterUpdate}\n-            onItemSelect={this.onOptionSelect}\n-            onOptionSelectActionString={column.onOptionChange}\n-            options={cellProperties.selectOptions}\n-            placeholderText={cellProperties.placeholderText}\n-            resetFilterTextOnClose={cellProperties.resetFilterTextOnClose}\n-            rowIndex={rowIndex}\n-            serverSideFiltering={cellProperties.serverSideFiltering}\n-            tableWidth={this.props.componentWidth}\n-            textColor={cellProperties.textColor}\n-            textSize={cellProperties.textSize}\n-            toggleCellEditMode={this.toggleCellEditMode}\n-            value={props.cell.value}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-            width={\n-              this.props.columnWidthMap?.[column.id] || DEFAULT_COLUMN_WIDTH\n-            }\n-          />\n-        );\n-\n-      case ColumnTypes.IMAGE:\n-        const onClick = column.onClick\n-          ? () =>\n-              this.onColumnEvent({\n-                rowIndex,\n-                action: column.onClick,\n-                triggerPropertyName: \"onClick\",\n-                eventType: EventType.ON_CLICK,\n-              })\n-          : noop;\n-\n-        return (\n-          <ImageCell\n-            allowCellWrapping={cellProperties.allowCellWrapping}\n-            cellBackground={cellProperties.cellBackground}\n-            compactMode={compactMode}\n-            fontStyle={cellProperties.fontStyle}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            imageSize={cellProperties.imageSize}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isHidden={isHidden}\n-            isSelected={isSelected}\n-            onClick={onClick}\n-            textColor={cellProperties.textColor}\n-            textSize={cellProperties.textSize}\n-            value={props.cell.value}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-          />\n-        );\n-\n-      case ColumnTypes.MENU_BUTTON:\n-        const getVisibleItems = (rowIndex: number) => {\n-          const { configureMenuItems, menuItems, menuItemsSource, sourceData } =\n-            cellProperties;\n-\n-          if (menuItemsSource === MenuItemsSource.STATIC && menuItems) {\n-            const visibleItems = Object.values(menuItems)?.filter((item) =>\n-              getBooleanPropertyValue(item.isVisible, rowIndex),\n-            );\n-\n-            return visibleItems?.length\n-              ? orderBy(visibleItems, [\"index\"], [\"asc\"])\n-              : [];\n-          } else if (\n-            menuItemsSource === MenuItemsSource.DYNAMIC &&\n-            isArray(sourceData) &&\n-            sourceData?.length &&\n-            configureMenuItems?.config\n-          ) {\n-            const { config } = configureMenuItems;\n-\n-            const getValue = (\n-              propertyName: keyof MenuItem,\n-              index: number,\n-              rowIndex: number,\n-            ) => {\n-              const value = config[propertyName];\n-\n-              if (isArray(value) && isArray(value[rowIndex])) {\n-                return value[rowIndex][index];\n-              } else if (isArray(value)) {\n-                return value[index];\n-              }\n-\n-              return value ?? null;\n-            };\n-\n-            const visibleItems = sourceData\n-              .map((item, index) => ({\n-                ...item,\n-                id: index.toString(),\n-                isVisible: getValue(\"isVisible\", index, rowIndex),\n-                isDisabled: getValue(\"isDisabled\", index, rowIndex),\n-                index: index,\n-                widgetId: \"\",\n-                label: getValue(\"label\", index, rowIndex),\n-                onClick: config?.onClick,\n-                textColor: getValue(\"textColor\", index, rowIndex),\n-                backgroundColor: getValue(\"backgroundColor\", index, rowIndex),\n-                iconAlign: getValue(\"iconAlign\", index, rowIndex),\n-                iconColor: getValue(\"iconColor\", index, rowIndex),\n-                iconName: getValue(\"iconName\", index, rowIndex),\n-              }))\n-              .filter((item) => item.isVisible === true);\n-\n-            return visibleItems;\n-          }\n-\n-          return [];\n-        };\n-\n-        return (\n-          <MenuButtonCell\n-            allowCellWrapping={cellProperties.allowCellWrapping}\n-            borderRadius={\n-              cellProperties.borderRadius || this.props.borderRadius\n-            }\n-            boxShadow={cellProperties.boxShadow}\n-            cellBackground={cellProperties.cellBackground}\n-            compactMode={compactMode}\n-            configureMenuItems={cellProperties.configureMenuItems}\n-            fontStyle={cellProperties.fontStyle}\n-            getVisibleItems={getVisibleItems}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            iconAlign={cellProperties.iconAlign}\n-            iconName={cellProperties.menuButtoniconName || undefined}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isCompact={!!cellProperties.isCompact}\n-            isDisabled={!!cellProperties.isDisabled}\n-            isHidden={isHidden}\n-            isSelected={isSelected}\n-            label={cellProperties.menuButtonLabel ?? DEFAULT_MENU_BUTTON_LABEL}\n-            menuColor={\n-              cellProperties.menuColor || this.props.accentColor || Colors.GREEN\n-            }\n-            menuItems={cellProperties.menuItems}\n-            menuItemsSource={cellProperties.menuItemsSource}\n-            menuVariant={cellProperties.menuVariant ?? DEFAULT_MENU_VARIANT}\n-            onCommandClick={(\n-              action: string,\n-              index?: number,\n-              onComplete?: () => void,\n-            ) => {\n-              const additionalData: Record<\n-                string,\n-                string | number | Record<string, unknown>\n-              > = {};\n-\n-              if (cellProperties?.sourceData && _.isNumber(index)) {\n-                additionalData.currentItem = cellProperties.sourceData[index];\n-                additionalData.currentIndex = index;\n-              }\n-\n-              return this.onColumnEvent({\n-                rowIndex,\n-                action,\n-                onComplete,\n-                triggerPropertyName: \"onClick\",\n-                eventType: EventType.ON_CLICK,\n-                additionalData,\n-              });\n-            }}\n-            rowIndex={originalIndex}\n-            sourceData={cellProperties.sourceData}\n-            textColor={cellProperties.textColor}\n-            textSize={cellProperties.textSize}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-          />\n-        );\n-\n-      case ColumnTypes.ICON_BUTTON:\n-        return (\n-          <IconButtonCell\n-            allowCellWrapping={cellProperties.allowCellWrapping}\n-            borderRadius={\n-              cellProperties.borderRadius || this.props.borderRadius\n-            }\n-            boxShadow={cellProperties.boxShadow || \"NONE\"}\n-            buttonColor={\n-              cellProperties.buttonColor ||\n-              this.props.accentColor ||\n-              Colors.GREEN\n-            }\n-            buttonVariant={cellProperties.buttonVariant || \"PRIMARY\"}\n-            cellBackground={cellProperties.cellBackground}\n-            columnActions={[\n-              {\n-                id: column.id,\n-                dynamicTrigger: column.onClick || \"\",\n-              },\n-            ]}\n-            compactMode={compactMode}\n-            disabled={!!cellProperties.isDisabled}\n-            fontStyle={cellProperties.fontStyle}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            iconName={(cellProperties.iconName || IconNames.ADD) as IconName}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isHidden={isHidden}\n-            isSelected={isSelected}\n-            onCommandClick={(action: string, onComplete: () => void) =>\n-              this.onColumnEvent({\n-                rowIndex,\n-                action,\n-                onComplete,\n-                triggerPropertyName: \"onClick\",\n-                eventType: EventType.ON_CLICK,\n-              })\n-            }\n-            textColor={cellProperties.textColor}\n-            textSize={cellProperties.textSize}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-          />\n-        );\n-\n-      case ColumnTypes.VIDEO:\n-        return (\n-          <VideoCell\n-            allowCellWrapping={cellProperties.allowCellWrapping}\n-            cellBackground={cellProperties.cellBackground}\n-            compactMode={compactMode}\n-            fontStyle={cellProperties.fontStyle}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isHidden={isHidden}\n-            textColor={cellProperties.textColor}\n-            textSize={cellProperties.textSize}\n-            value={props.cell.value}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-          />\n-        );\n-\n-      case ColumnTypes.CHECKBOX:\n-        return (\n-          <CheckboxCell\n-            accentColor={this.props.accentColor}\n-            borderRadius={\n-              cellProperties.borderRadius || this.props.borderRadius\n-            }\n-            cellBackground={cellProperties.cellBackground}\n-            compactMode={compactMode}\n-            disabledCheckbox={\n-              shouldDisableEdit || (this.props.isAddRowInProgress && !isNewRow)\n-            }\n-            disabledCheckboxMessage={disabledEditMessage}\n-            hasUnSavedChanges={cellProperties.hasUnsavedChanges}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellEditable={isCellEditable}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isHidden={isHidden}\n-            onChange={() =>\n-              this.onCheckChange(\n-                column,\n-                props.cell.row.values,\n-                !props.cell.value,\n-                alias,\n-                originalIndex,\n-                rowIndex,\n-              )\n-            }\n-            value={props.cell.value}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-          />\n-        );\n-\n-      case ColumnTypes.SWITCH:\n-        return (\n-          <SwitchCell\n-            accentColor={this.props.accentColor}\n-            cellBackground={cellProperties.cellBackground}\n-            compactMode={compactMode}\n-            disabledSwitch={\n-              shouldDisableEdit || (this.props.isAddRowInProgress && !isNewRow)\n-            }\n-            disabledSwitchMessage={disabledEditMessage}\n-            hasUnSavedChanges={cellProperties.hasUnsavedChanges}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellEditable={isCellEditable}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isHidden={isHidden}\n-            onChange={() =>\n-              this.onCheckChange(\n-                column,\n-                props.cell.row.values,\n-                !props.cell.value,\n-                alias,\n-                originalIndex,\n-                rowIndex,\n-              )\n-            }\n-            value={props.cell.value}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-          />\n-        );\n-\n-      case ColumnTypes.DATE:\n-        return (\n-          <DateCell\n-            accentColor={this.props.accentColor}\n-            alias={props.cell.column.columnProperties.alias}\n-            borderRadius={this.props.borderRadius}\n-            cellBackground={cellProperties.cellBackground}\n-            closeOnSelection\n-            columnType={column.columnType}\n-            compactMode={compactMode}\n-            disabledEditIcon={\n-              shouldDisableEdit || this.props.isAddRowInProgress\n-            }\n-            disabledEditIconMessage={disabledEditMessage}\n-            firstDayOfWeek={props.cell.column.columnProperties.firstDayOfWeek}\n-            fontStyle={cellProperties.fontStyle}\n-            hasUnsavedChanges={cellProperties.hasUnsavedChanges}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            inputFormat={cellProperties.inputFormat}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellEditMode={isCellEditMode}\n-            isCellEditable={isCellEditable}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isEditableCellValid={this.isColumnCellValid(alias)}\n-            isHidden={isHidden}\n-            isNewRow={isNewRow}\n-            isRequired={\n-              props.cell.column.columnProperties.validation\n-                .isColumnEditableCellRequired\n-            }\n-            maxDate={props.cell.column.columnProperties.validation.maxDate}\n-            minDate={props.cell.column.columnProperties.validation.minDate}\n-            onCellTextChange={this.onCellTextChange}\n-            onDateSave={this.onDateSave}\n-            onDateSelectedString={\n-              props.cell.column.columnProperties.onDateSelected\n-            }\n-            outputFormat={cellProperties.outputFormat}\n-            rowIndex={rowIndex}\n-            shortcuts={cellProperties.shortcuts}\n-            tableWidth={this.props.componentWidth}\n-            textColor={cellProperties.textColor}\n-            textSize={cellProperties.textSize}\n-            timePrecision={cellProperties.timePrecision || TimePrecision.NONE}\n-            toggleCellEditMode={this.toggleCellEditMode}\n-            updateNewRowValues={this.updateNewRowValues}\n-            validationErrorMessage=\"This field is required\"\n-            value={props.cell.value}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-            widgetId={this.props.widgetId}\n-          />\n-        );\n-\n-      case ColumnTypes.HTML:\n-        return (\n-          <HTMLCell\n-            allowCellWrapping={cellProperties.allowCellWrapping}\n-            cellBackground={cellProperties.cellBackground}\n-            compactMode={compactMode}\n-            fontStyle={cellProperties.fontStyle}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isHidden={isHidden}\n-            renderMode={this.props.renderMode}\n-            textColor={cellProperties.textColor}\n-            textSize={cellProperties.textSize}\n-            value={props.cell.value}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-          />\n-        );\n-\n-      default:\n-        let validationErrorMessage;\n-\n-        if (isCellEditMode) {\n-          validationErrorMessage =\n-            column.validation.isColumnEditableCellRequired &&\n-            (isNil(props.cell.value) || props.cell.value === \"\")\n-              ? \"This field is required\"\n-              : column.validation?.errorMessage;\n-        }\n-\n-        return (\n-          <PlainTextCell\n-            accentColor={this.props.accentColor}\n-            alias={props.cell.column.columnProperties.alias}\n-            allowCellWrapping={cellProperties.allowCellWrapping}\n-            cellBackground={cellProperties.cellBackground}\n-            columnType={column.columnType}\n-            compactMode={compactMode}\n-            currencyCode={cellProperties.currencyCode}\n-            decimals={cellProperties.decimals}\n-            disabledEditIcon={\n-              shouldDisableEdit || this.props.isAddRowInProgress\n-            }\n-            disabledEditIconMessage={disabledEditMessage}\n-            displayText={cellProperties.displayText}\n-            fontStyle={cellProperties.fontStyle}\n-            hasUnsavedChanges={cellProperties.hasUnsavedChanges}\n-            horizontalAlignment={cellProperties.horizontalAlignment}\n-            isCellDisabled={cellProperties.isCellDisabled}\n-            isCellEditMode={isCellEditMode}\n-            isCellEditable={isCellEditable}\n-            isCellVisible={cellProperties.isCellVisible ?? true}\n-            isEditableCellValid={this.isColumnCellValid(alias)}\n-            isHidden={isHidden}\n-            isNewRow={isNewRow}\n-            notation={cellProperties.notation}\n-            onCellTextChange={this.onCellTextChange}\n-            onSubmitString={props.cell.column.columnProperties.onSubmit}\n-            rowIndex={rowIndex}\n-            tableWidth={this.props.componentWidth}\n-            textColor={cellProperties.textColor}\n-            textSize={cellProperties.textSize}\n-            thousandSeparator={cellProperties.thousandSeparator}\n-            toggleCellEditMode={this.toggleCellEditMode}\n-            validationErrorMessage={validationErrorMessage}\n-            value={props.cell.value}\n-            verticalAlignment={cellProperties.verticalAlignment}\n-            widgetId={this.props.widgetId}\n-          />\n-        );\n-    }\n-  };\n-\n-  onCellTextChange = (\n-    value: EditableCell[\"value\"],\n-    inputValue: string,\n-    alias: string,\n-  ) => {\n-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-    if (this.props.isAddRowInProgress) {\n-      this.updateNewRowValues(alias, inputValue, value);\n-    } else {\n-      pushBatchMetaUpdates(\"editableCell\", {\n-        ...this.props.editableCell,\n-        value: value,\n-        inputValue,\n-      });\n-\n-      if (this.props.editableCell?.column) {\n-        pushBatchMetaUpdates(\"columnEditableCellValue\", {\n-          ...this.props.columnEditableCellValue,\n-          [this.props.editableCell?.column]: value,\n-        });\n-      }\n-\n-      commitBatchMetaUpdates();\n-    }\n-  };\n-\n-  toggleCellEditMode = (\n-    enable: boolean,\n-    rowIndex: number,\n-    alias: string,\n-    value: string | number,\n-    onSubmit?: string,\n-    action?: EditableCellActions,\n-  ) => {\n-    if (this.props.isAddRowInProgress) {\n-      return;\n-    }\n-\n-    if (enable) {\n-      if (this.inlineEditTimer) {\n-        clearTimeout(this.inlineEditTimer);\n-      }\n-\n-      const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-      pushBatchMetaUpdates(\"editableCell\", {\n-        column: alias,\n-        index: rowIndex,\n-        value: value,\n-        // To revert back to previous on discard\n-        initialValue: value,\n-        inputValue: value,\n-        __originalIndex__: this.getRowOriginalIndex(rowIndex),\n-      });\n-      pushBatchMetaUpdates(\"columnEditableCellValue\", {\n-        ...this.props.columnEditableCellValue,\n-        [alias]: value,\n-      });\n-\n-      /*\n-       * We need to clear the selectedRowIndex and selectedRowIndices\n-       * if the rows are sorted, to avoid selectedRow jumping to\n-       * different page.\n-       */\n-      if (this.props.sortOrder.column) {\n-        if (this.props.multiRowSelection) {\n-          pushBatchMetaUpdates(\"selectedRowIndices\", []);\n-        } else {\n-          pushBatchMetaUpdates(\"selectedRowIndex\", -1);\n-        }\n-      }\n-\n-      commitBatchMetaUpdates();\n-    } else {\n-      if (\n-        this.isColumnCellValid(alias) &&\n-        action === EditableCellActions.SAVE &&\n-        value !== this.props.editableCell?.initialValue\n-      ) {\n-        const { commitBatchMetaUpdates } = this.props;\n-\n-        this.pushTransientTableDataActionsUpdates({\n-          [ORIGINAL_INDEX_KEY]: this.getRowOriginalIndex(rowIndex),\n-          [alias]: this.props.editableCell?.value,\n-        });\n-\n-        if (onSubmit && this.props.editableCell?.column) {\n-          //since onSubmit is truthy that makes action truthy as well, so we can push this event\n-          this.pushOnColumnEvent({\n-            rowIndex: rowIndex,\n-            action: onSubmit,\n-            triggerPropertyName: \"onSubmit\",\n-            eventType: EventType.ON_SUBMIT,\n-            row: {\n-              ...this.props.filteredTableData[rowIndex],\n-              [this.props.editableCell.column]: this.props.editableCell.value,\n-            },\n-          });\n-        }\n-\n-        commitBatchMetaUpdates();\n-\n-        this.clearEditableCell();\n-      } else if (\n-        action === EditableCellActions.DISCARD ||\n-        value === this.props.editableCell?.initialValue\n-      ) {\n-        this.clearEditableCell();\n-      }\n-    }\n-  };\n-\n-  onDateSave = (\n-    rowIndex: number,\n-    alias: string,\n-    value: string,\n-    onSubmit?: string,\n-  ) => {\n-    const { commitBatchMetaUpdates } = this.props;\n-\n-    this.pushTransientTableDataActionsUpdates({\n-      [ORIGINAL_INDEX_KEY]: this.getRowOriginalIndex(rowIndex),\n-      [alias]: value,\n-    });\n-\n-    if (onSubmit && this.props.editableCell?.column) {\n-      //since onSubmit is truthy this makes action truthy as well, so we can push this event\n-      this.pushOnColumnEvent({\n-        rowIndex: rowIndex,\n-        action: onSubmit,\n-        triggerPropertyName: \"onSubmit\",\n-        eventType: EventType.ON_SUBMIT,\n-        row: {\n-          ...this.props.filteredTableData[rowIndex],\n-          [this.props.editableCell.column]: value,\n-        },\n-      });\n-    }\n-\n-    commitBatchMetaUpdates();\n-    this.clearEditableCell();\n-  };\n-  pushClearEditableCellsUpdates = () => {\n-    const { pushBatchMetaUpdates } = this.props;\n-\n-    pushBatchMetaUpdates(\"editableCell\", defaultEditableCell);\n-    pushBatchMetaUpdates(\"columnEditableCellValue\", {});\n-  };\n-\n-  clearEditableCell = (skipTimeout?: boolean) => {\n-    const clear = () => {\n-      const { commitBatchMetaUpdates } = this.props;\n-\n-      this.pushClearEditableCellsUpdates();\n-      commitBatchMetaUpdates();\n-    };\n-\n-    if (skipTimeout) {\n-      clear();\n-    } else {\n-      /*\n-       * We need to let the evaulations compute derived property (filteredTableData)\n-       * before we clear the editableCell to avoid the text flickering\n-       */\n-      this.inlineEditTimer = setTimeout(clear, 100);\n-    }\n-  };\n-\n-  isColumnCellEditable = (column: ColumnProperties, rowIndex: number) => {\n-    return (\n-      column.alias === this.props.editableCell?.column &&\n-      rowIndex === this.props.editableCell?.index\n-    );\n-  };\n-\n-  onOptionSelect = (\n-    value: string | number,\n-    rowIndex: number,\n-    column: string,\n-    action?: string,\n-  ) => {\n-    if (this.props.isAddRowInProgress) {\n-      this.updateNewRowValues(column, value, value);\n-    } else {\n-      const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-      this.pushTransientTableDataActionsUpdates({\n-        [ORIGINAL_INDEX_KEY]: this.getRowOriginalIndex(rowIndex),\n-        [column]: value,\n-      });\n-      pushBatchMetaUpdates(\"editableCell\", defaultEditableCell);\n-\n-      if (action && this.props.editableCell?.column) {\n-        //since action is truthy we can push this event\n-        this.pushOnColumnEvent({\n-          rowIndex,\n-          action,\n-          triggerPropertyName: \"onOptionChange\",\n-          eventType: EventType.ON_OPTION_CHANGE,\n-          row: {\n-            ...this.props.filteredTableData[rowIndex],\n-            [this.props.editableCell.column]: value,\n-          },\n-        });\n-      }\n-\n-      commitBatchMetaUpdates();\n-    }\n-  };\n-\n-  onSelectFilterChange = (\n-    text: string,\n-    rowIndex: number,\n-    serverSideFiltering: boolean,\n-    alias: string,\n-    action?: string,\n-  ) => {\n-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-    pushBatchMetaUpdates(\"selectColumnFilterText\", {\n-      ...this.props.selectColumnFilterText,\n-      [alias]: text,\n-    });\n-\n-    if (action && serverSideFiltering) {\n-      //since action is truthy we can push this event\n-      this.pushOnColumnEvent({\n-        rowIndex,\n-        action,\n-        triggerPropertyName: \"onFilterUpdate\",\n-        eventType: EventType.ON_FILTER_UPDATE,\n-        row: {\n-          ...this.props.filteredTableData[rowIndex],\n-        },\n-        additionalData: {\n-          filterText: text,\n-        },\n-      });\n-    }\n-\n-    commitBatchMetaUpdates();\n-  };\n-\n-  onCheckChange = (\n-    // TODO: Fix this the next time the file is edited\n-    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-    column: any,\n-    row: Record<string, unknown>,\n-    value: boolean,\n-    alias: string,\n-    originalIndex: number,\n-    rowIndex: number,\n-  ) => {\n-    if (this.props.isAddRowInProgress) {\n-      this.updateNewRowValues(alias, value, value);\n-    } else {\n-      const { commitBatchMetaUpdates } = this.props;\n-\n-      this.pushTransientTableDataActionsUpdates({\n-        [ORIGINAL_INDEX_KEY]: originalIndex,\n-        [alias]: value,\n-      });\n-      commitBatchMetaUpdates();\n-      //cannot batch this update because we are not sure if it action is truthy or not\n-      this.onColumnEvent({\n-        rowIndex,\n-        action: column.onCheckChange,\n-        triggerPropertyName: \"onCheckChange\",\n-        eventType: EventType.ON_CHECK_CHANGE,\n-        row: {\n-          ...row,\n-          [alias]: value,\n-        },\n-      });\n-    }\n-  };\n-\n-  handleAddNewRowClick = () => {\n-    const defaultNewRow = this.props.defaultNewRow || {};\n-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-    pushBatchMetaUpdates(\"isAddRowInProgress\", true);\n-    pushBatchMetaUpdates(\"newRowContent\", defaultNewRow);\n-    pushBatchMetaUpdates(\"newRow\", defaultNewRow);\n-\n-    // New row gets added at the top of page 1 when client side pagination enabled\n-    if (!this.props.serverSidePaginationEnabled) {\n-      this.updatePaginationDirectionFlags(PaginationDirection.INITIAL);\n-    }\n-\n-    //Since we're adding a newRowContent thats not part of tableData, the index changes\n-    // so we're resetting the row selection\n-    pushBatchMetaUpdates(\"selectedRowIndex\", -1);\n-    pushBatchMetaUpdates(\"selectedRowIndices\", []);\n-    commitBatchMetaUpdates();\n-  };\n-\n-  handleAddNewRowAction = (\n-    type: AddNewRowActions,\n-    onActionComplete: () => void,\n-  ) => {\n-    let triggerPropertyName, action, eventType;\n-\n-    const onComplete = () => {\n-      const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-      pushBatchMetaUpdates(\"isAddRowInProgress\", false);\n-      pushBatchMetaUpdates(\"newRowContent\", undefined);\n-      pushBatchMetaUpdates(\"newRow\", undefined);\n-      commitBatchMetaUpdates();\n-\n-      onActionComplete();\n-    };\n-\n-    if (type === AddNewRowActions.SAVE) {\n-      triggerPropertyName = \"onAddNewRowSave\";\n-      action = this.props.onAddNewRowSave;\n-      eventType = EventType.ON_ADD_NEW_ROW_SAVE;\n-    } else {\n-      triggerPropertyName = \"onAddNewRowDiscard\";\n-      action = this.props.onAddNewRowDiscard;\n-      eventType = EventType.ON_ADD_NEW_ROW_DISCARD;\n-    }\n-\n-    if (action) {\n-      super.executeAction({\n-        triggerPropertyName: triggerPropertyName,\n-        dynamicString: action,\n-        event: {\n-          type: eventType,\n-          callback: onComplete,\n-        },\n-      });\n-    } else {\n-      onComplete();\n-    }\n-  };\n-\n-  isColumnCellValid = (columnsAlias: string) => {\n-    if (this.props.isEditableCellsValid?.hasOwnProperty(columnsAlias)) {\n-      return this.props.isEditableCellsValid[columnsAlias];\n-    }\n-\n-    return true;\n-  };\n-\n-  hasInvalidColumnCell = () => {\n-    if (isObject(this.props.isEditableCellsValid)) {\n-      return Object.values(this.props.isEditableCellsValid).some((d) => !d);\n-    } else {\n-      return false;\n-    }\n-  };\n-\n-  updateNewRowValues = (\n-    alias: string,\n-    value: unknown,\n-    parsedValue: unknown,\n-  ) => {\n-    const { commitBatchMetaUpdates, pushBatchMetaUpdates } = this.props;\n-\n-    /*\n-     * newRowContent holds whatever the user types while newRow holds the parsed value\n-     * newRowContent is being used to populate the cell while newRow is being used\n-     * for validations.\n-     */\n-    pushBatchMetaUpdates(\"newRowContent\", {\n-      ...this.props.newRowContent,\n-      [alias]: value,\n-    });\n-    pushBatchMetaUpdates(\"newRow\", {\n-      ...this.props.newRow,\n-      [alias]: parsedValue,\n-    });\n-    commitBatchMetaUpdates();\n-  };\n-\n-  onConnectData = () => {\n-    if (this.props.renderMode === RenderModes.CANVAS) {\n-      super.updateOneClickBindingOptionsVisibility(true);\n-    }\n-  };\n-\n-  updateInfiniteScrollProperties(shouldCommitBatchUpdates?: boolean) {\n-    const {\n-      cachedTableData,\n-      commitBatchMetaUpdates,\n-      infiniteScrollEnabled,\n-      pageNo,\n-      pageSize,\n-      processedTableData,\n-      pushBatchMetaUpdates,\n-      tableData,\n-      totalRecordsCount,\n-    } = this.props;\n-\n-    if (infiniteScrollEnabled) {\n-      // Update the cache key for a particular page whenever this function is called. The pageNo data is updated with the tableData.\n-      const updatedCachedTableData = {\n-        ...(cachedTableData || {}),\n-        [pageNo]: tableData,\n-      };\n-\n-      pushBatchMetaUpdates(\"cachedTableData\", updatedCachedTableData);\n-\n-      // The check (!!totalRecordsCount && processedTableData.length === totalRecordsCount) is added if the totalRecordsCount property is set then match the length with the processedTableData which has all flatted data from each page in a single array except the current tableData page i.e. [ ...array of page 1 data, ...array of page 2 data ]. Another 'or' check is if (tableData.length < pageSize) when totalRecordsCount is undefined. Table data has a single page data and if the data comes out to be lesser than the pageSize, it is assumed that the data is finished.\n-      if (window?.navigator?.onLine) {\n-        if (\n-          (!!totalRecordsCount &&\n-            processedTableData.length + tableData.length ===\n-              totalRecordsCount) ||\n-          (!totalRecordsCount && tableData.length < pageSize)\n-        ) {\n-          pushBatchMetaUpdates(\"endOfData\", true);\n-        } else {\n-          pushBatchMetaUpdates(\"endOfData\", false);\n-        }\n-      }\n-\n-      if (shouldCommitBatchUpdates) {\n-        commitBatchMetaUpdates();\n-      }\n-    }\n-  }\n-\n-  resetTableForInfiniteScroll = () => {\n-    resetWidget(this.props.widgetId, false);\n-    this.updatePageNumber(0, EventType.ON_NEXT_PAGE);\n-  };\n-}\n-\n-export default TableWidgetV2;\n+          \"The Table is the hero widget of Appsmith. You can display data from an API in a table, trigger an action when a user selects a row and even work with large\n\\ No newline at end of file\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts\nindex 96210b4..cc01e14 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts\n+++ b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts\n@@ -137,10 +137,7 @@ export default {\n         const columnType = get(props, `${baseProperty}.columnType`, \"\");\n         const isDerived = get(props, `${baseProperty}.isDerived`, false);\n \n-        return (\n-          !isColumnTypeEditable(columnType, props.infiniteScrollEnabled) ||\n-          isDerived\n-        );\n+        return !isColumnTypeEditable(columnType) || isDerived;\n       },\n     },\n     {\n@@ -296,4 +293,4 @@ export const GeneralStyle = {\n       },\n     },\n   ],\n-};\n+};\n\\ No newline at end of file\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts\nindex 48351f3..55e0acf 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts\n+++ b/app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts\n@@ -22,6 +22,7 @@ import {\n   totalRecordsCountValidation,\n   uniqueColumnNameValidation,\n   updateAllowAddNewRowOnInfiniteScrollChange,\n+  updateCellEditabilityOnInfiniteScrollChange,\n   updateColumnOrderHook,\n   updateCustomColumnAliasOnLabelChange,\n   updateInlineEditingOptionDropdownVisibilityHook,\n@@ -196,6 +197,7 @@ export default [\n         isTriggerProperty: false,\n         updateHook: composePropertyUpdateHook([\n           updateAllowAddNewRowOnInfiniteScrollChange,\n+          updateCellEditabilityOnInfiniteScrollChange,\n           updateSearchSortFilterOnInfiniteScrollChange,\n         ]),\n         dependencies: [\"primaryColumns\", \"serverSidePaginationEnabled\"],\n@@ -438,193 +440,4 @@ export default [\n       },\n       {\n         helperText:\n-          \"Client side only, custom sort function data(overrides default sorting)\",\n-        helpText:\n-          \"Function should expect three arguments: tableData, columnId, and order. Return the sorted tableData.\",\n-        propertyName: \"customSortFunction\",\n-        label: \"Custom sort function data\",\n-        controlType: \"TABLE_CUSTOM_SORT\",\n-        placeholderText:\n-          \"{{(tableData, columnId, order) => { /* Return sorted table data */ }}}\",\n-        controlConfig: {\n-          maxHeight: \"400px\",\n-          height: \"100px\",\n-        },\n-        isTriggerProperty: false,\n-        hidden: (props: TableWidgetProps) =>\n-          !props.isSortable ||\n-          !Widget.getFeatureFlag(CUSTOM_SORT_FUNCTION_ENABLED),\n-        dependencies: [\"isSortable\"],\n-      },\n-    ],\n-    expandedByDefault: false,\n-  },\n-\n-  {\n-    sectionName: \"Adding a row\",\n-    shouldDisableSection: (props: TableWidgetProps) =>\n-      props.infiniteScrollEnabled,\n-    disabledHelpText: INFINITE_SCROLL_DISABLED_HELP_TEXT,\n-    dependencies: [\"infiniteScrollEnabled\"],\n-    children: [\n-      {\n-        propertyName: \"allowAddNewRow\",\n-        helpText: \"Enables adding a new row\",\n-        isJSConvertible: true,\n-        label: \"Allow adding a row\",\n-        controlType: \"SWITCH\",\n-        isBindProperty: true,\n-        isTriggerProperty: false,\n-        validation: {\n-          type: ValidationTypes.BOOLEAN,\n-        },\n-      },\n-      {\n-        propertyName: \"onAddNewRowSave\",\n-        helpText: \"when a add new row save button is clicked\",\n-        label: \"onSave\",\n-        controlType: \"ACTION_SELECTOR\",\n-        hidden: (props: TableWidgetProps) => {\n-          return !props.allowAddNewRow;\n-        },\n-        dependencies: [\"allowAddNewRow\", \"primaryColumns\"],\n-        isJSConvertible: true,\n-        isBindProperty: true,\n-        isTriggerProperty: true,\n-        additionalAutoComplete: (props: TableWidgetProps) => {\n-          const newRow: Record<string, unknown> = {};\n-\n-          if (props.primaryColumns) {\n-            Object.values(props.primaryColumns)\n-              .filter((column) => !column.isDerived)\n-              .forEach((column) => {\n-                newRow[column.alias] = \"\";\n-              });\n-          }\n-\n-          return {\n-            newRow,\n-          };\n-        },\n-      },\n-      {\n-        propertyName: \"onAddNewRowDiscard\",\n-        helpText: \"when a add new row discard button is clicked\",\n-        label: \"onDiscard\",\n-        controlType: \"ACTION_SELECTOR\",\n-        hidden: (props: TableWidgetProps) => {\n-          return !props.allowAddNewRow;\n-        },\n-        dependencies: [\"allowAddNewRow\"],\n-        isJSConvertible: true,\n-        isBindProperty: true,\n-        isTriggerProperty: true,\n-      },\n-      {\n-        propertyName: \"defaultNewRow\",\n-        helpText: \"Default new row values\",\n-        label: \"Default values\",\n-        controlType: \"INPUT_TEXT\",\n-        dependencies: [\"allowAddNewRow\"],\n-        hidden: (props: TableWidgetProps) => {\n-          return !props.allowAddNewRow;\n-        },\n-        isBindProperty: true,\n-        isTriggerProperty: false,\n-        validation: {\n-          type: ValidationTypes.OBJECT,\n-          params: {\n-            default: {},\n-          },\n-        },\n-      },\n-    ],\n-    expandedByDefault: false,\n-  },\n-  {\n-    sectionName: \"General\",\n-    children: [\n-      {\n-        helpText: \"Controls the visibility of the widget\",\n-        propertyName: \"isVisible\",\n-        isJSConvertible: true,\n-        label: \"Visible\",\n-        controlType: \"SWITCH\",\n-        isBindProperty: true,\n-        isTriggerProperty: false,\n-        validation: {\n-          type: ValidationTypes.BOOLEAN,\n-        },\n-      },\n-      {\n-        propertyName: \"animateLoading\",\n-        label: \"Animate loading\",\n-        controlType: \"SWITCH\",\n-        helpText: \"Controls the animation loading of the widget\",\n-        defaultValue: true,\n-        isJSConvertible: true,\n-        isBindProperty: true,\n-        isTriggerProperty: false,\n-        validation: { type: ValidationTypes.BOOLEAN },\n-      },\n-      {\n-        propertyName: \"customIsLoading\",\n-        label: `Custom loading state`,\n-        controlType: \"SWITCH\",\n-        helpText: \"Defines a custom value for the loading state\",\n-        defaultValue: false,\n-        isBindProperty: true,\n-        isTriggerProperty: false,\n-        validation: { type: ValidationTypes.BOOLEAN },\n-      },\n-      {\n-        propertyName: \"customIsLoadingValue\",\n-        label: \"isLoading value\",\n-        controlType: \"INPUT_TEXT\",\n-        defaultValue: \"\",\n-        isBindProperty: true,\n-        isTriggerProperty: false,\n-        validation: { type: ValidationTypes.BOOLEAN },\n-        hidden: (props: TableWidgetProps) => !props.customIsLoading,\n-        dependencies: [\"customIsLoading\"],\n-      },\n-      {\n-        propertyName: \"isVisibleDownload\",\n-        helpText: \"Toggle visibility of the data download\",\n-        label: \"Allow download\",\n-        controlType: \"SWITCH\",\n-        isJSConvertible: true,\n-        isBindProperty: true,\n-        isTriggerProperty: false,\n-        validation: { type: ValidationTypes.BOOLEAN },\n-      },\n-      {\n-        propertyName: \"canFreezeColumn\",\n-        helpText: \"Controls whether the user can freeze columns\",\n-        label: \"Allow column freeze\",\n-        controlType: \"SWITCH\",\n-        defaultValue: true,\n-        isJSConvertible: true,\n-        isBindProperty: true,\n-        isTriggerProperty: false,\n-        validation: { type: ValidationTypes.BOOLEAN },\n-      },\n-      {\n-        propertyName: \"delimiter\",\n-        label: \"CSV separator\",\n-        controlType: \"INPUT_TEXT\",\n-        placeholderText: \"Enter CSV separator\",\n-        helpText: \"The character used for separating the CSV download file.\",\n-        isBindProperty: true,\n-        isTriggerProperty: false,\n-        defaultValue: \",\",\n-        validation: {\n-          type: ValidationTypes.TEXT,\n-        },\n-        hidden: (props: TableWidgetProps) => !props.isVisibleDownload,\n-        dependencies: [\"isVisibleDownload\"],\n-      },\n-    ],\n-    expandedByDefault: false,\n-  },\n-] as PropertyPaneConfig[];\n+          \"Client side\n\\ No newline at end of file\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts b/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts\nindex bf6bb16..52c206e 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts\n+++ b/app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts\n@@ -481,1035 +481,4 @@ export const SelectColumnOptionsValidations = (\n \n   if (typeof value === \"string\" && value.trim() !== \"\") {\n     /*\n-     * when value is a string\n-     */\n-    try {\n-      /*\n-       * when the value is an array of string\n-       */\n-      value = JSON.parse(value);\n-    } catch (e) {\n-      /*\n-       * when the value is an comma seperated strings\n-       */\n-      value = (value as string).split(\",\").map((str) => str.trim());\n-    }\n-  }\n-\n-  /*\n-   * when value is null, undefined and empty string\n-   */\n-  if (_.isNil(value) || value === \"\") {\n-    isValid = true;\n-    parsed = [];\n-  } else if (_.isArray(value)) {\n-    const hasStringOrNumber = (value as []).every(\n-      (item) => _.isString(item) || _.isFinite(item),\n-    );\n-\n-    isValid = hasStringOrNumber;\n-    parsed = value;\n-    message = hasStringOrNumber ? \"\" : expectedMessage;\n-  } else if (typeof value === \"number\") {\n-    isValid = true;\n-    parsed = [value];\n-  } else {\n-    isValid = false;\n-    parsed = value;\n-    message = expectedMessage;\n-  }\n-\n-  return {\n-    isValid,\n-    parsed,\n-    messages: [message],\n-  };\n-};\n-\n-/*\n- * Hook that updates column isDiabled binding when columnType is\n- * changed to ColumnTypes.EDIT_ACTIONS.\n- */\n-export const updateInlineEditingSaveOptionHook = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  propertyValue: any,\n-): Array<PropertyUpdates> | undefined => {\n-  if (propertyValue !== InlineEditingSaveOptions.ROW_LEVEL) {\n-    const columnsArray = Object.values(props.primaryColumns);\n-    const edtiActionColumn = columnsArray.find(\n-      (column) => column.columnType === ColumnTypes.EDIT_ACTIONS,\n-    );\n-\n-    if (edtiActionColumn && edtiActionColumn.id) {\n-      const newColumnOrder = _.difference(props.columnOrder, [\n-        edtiActionColumn.id,\n-      ]);\n-\n-      return [\n-        {\n-          propertyPath: `primaryColumns.${edtiActionColumn.id}`,\n-          shouldDeleteProperty: true,\n-        },\n-        {\n-          propertyPath: \"columnOrder\",\n-          propertyValue: newColumnOrder,\n-        },\n-      ];\n-    }\n-  } else {\n-    const columnIdMatcher = propertyPath.match(EDITABLITY_PATH_REGEX);\n-    const columnId = columnIdMatcher && columnIdMatcher[1];\n-    const isAtleastOneEditableColumnPresent = Object.values(\n-      props.primaryColumns,\n-    ).some((column) => column.id !== columnId && column.isEditable);\n-\n-    if (isAtleastOneEditableColumnPresent) {\n-      return createEditActionColumn(props);\n-    }\n-  }\n-};\n-\n-export const updateNumberColumnTypeTextAlignment = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  propertyValue: any,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-): Array<{ propertyPath: string; propertyValue: any }> | undefined => {\n-  const baseProperty = getBasePropertyPath(propertyPath);\n-\n-  if (propertyValue === ColumnTypes.NUMBER) {\n-    return [\n-      {\n-        propertyPath: `${baseProperty}.horizontalAlignment`,\n-        propertyValue: CellAlignmentTypes.RIGHT,\n-      },\n-    ];\n-  } else {\n-    return [\n-      {\n-        propertyPath: `${baseProperty}.horizontalAlignment`,\n-        propertyValue: CellAlignmentTypes.LEFT,\n-      },\n-    ];\n-  }\n-\n-  return;\n-};\n-\n-/**\n- * updates theme stylesheets\n- *\n- * @param props\n- * @param propertyPath\n- * @param propertyValue\n- */\n-export function updateThemeStylesheetsInColumns(\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  propertyValue: any,\n-): Array<PropertyUpdates> | undefined {\n-  const regex = /^primaryColumns\\.(\\w+)\\.(.*)$/;\n-  const matches = propertyPath.match(regex);\n-  const columnId = matches?.[1];\n-  const columnProperty = matches?.[2];\n-\n-  if (columnProperty === \"columnType\") {\n-    const propertiesToUpdate: Array<PropertyUpdates> = [];\n-    const oldColumnType = get(props, `primaryColumns.${columnId}.columnType`);\n-    const newColumnType = propertyValue;\n-\n-    const propertiesToRemove = Object.keys(\n-      props.childStylesheet[oldColumnType] || {},\n-    );\n-\n-    const propertiesToAdd = Object.keys(\n-      props.childStylesheet[newColumnType] || {},\n-    );\n-\n-    propertiesToRemove.forEach((propertyKey) => {\n-      propertiesToUpdate.push({\n-        propertyPath: `primaryColumns.${columnId}.${propertyKey}`,\n-        shouldDeleteProperty: true,\n-      });\n-    });\n-\n-    propertiesToAdd.forEach((propertyKey) => {\n-      const { jsSnippets, stringSegments } = getDynamicBindings(\n-        props.childStylesheet[newColumnType][propertyKey],\n-      );\n-\n-      const js = combineDynamicBindings(jsSnippets, stringSegments);\n-\n-      propertiesToUpdate.push({\n-        propertyPath: `primaryColumns.${columnId}.${propertyKey}`,\n-        propertyValue: `{{${props.widgetName}.processedTableData.map((currentRow, currentIndex) => ( ${js}))}}`,\n-      });\n-    });\n-\n-    if (propertiesToUpdate.length) {\n-      /*\n-       * Temporary patch to make evaluations to compute inverseDependencyMap when\n-       * column type is changed.\n-       * TODO(Balaji): remove once https://github.com/appsmithorg/appsmith/issues/14436 gets fixed\n-       */\n-      propertiesToUpdate.push({\n-        propertyPath: `primaryColumns.${columnId}.customAlias`,\n-        propertyValue: \"\",\n-      });\n-\n-      return propertiesToUpdate;\n-    }\n-  }\n-}\n-\n-/**\n- * A function for updateHook to remove the boxShadowColor property post migration.\n- * @param props\n- * @param propertyPath\n- * @param propertyValue\n- */\n-export const removeBoxShadowColorProp = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-) => {\n-  const boxShadowColorPath = replacePropertyName(\n-    propertyPath,\n-    \"boxShadowColor\",\n-  );\n-\n-  return [\n-    {\n-      propertyPath: boxShadowColorPath,\n-      propertyValue: undefined,\n-    },\n-  ];\n-};\n-\n-/**\n- * This function will replace the property present at the end of the propertyPath with the targetPropertyName.\n- * e.g.\n- * propertyPath = primaryColumns.action.boxShadow\n- * Running this function will give the new propertyPath like below:\n- * propertyPath = primaryColumns.action.boxShadowColor\n- *\n- * @param propertyPath The property path inside a widget\n- * @param targetPropertyName Target property name\n- * @returns New property path with target property name at the end.\n- */\n-export const replacePropertyName = (\n-  propertyPath: string,\n-  targetPropertyName: string,\n-) => {\n-  const path = propertyPath.split(\".\");\n-\n-  path.pop();\n-\n-  return `${path.join(\".\")}.${targetPropertyName}`;\n-};\n-\n-export const updateCustomColumnAliasOnLabelChange = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  propertyValue: unknown,\n-): Array<PropertyUpdates> | undefined => {\n-  // alias will be updated along with label change only for custom columns\n-  const regex = /^primaryColumns\\.(customColumn\\d+)\\.label$/;\n-\n-  if (propertyPath?.length && regex.test(propertyPath)) {\n-    return [\n-      {\n-        propertyPath: propertyPath.replace(\"label\", \"alias\"),\n-        propertyValue: propertyValue,\n-      },\n-    ];\n-  }\n-};\n-\n-export const allowedFirstDayOfWeekRange = (value: number) => {\n-  const allowedValues = [0, 1, 2, 3, 4, 5, 6];\n-  const isValid = allowedValues.includes(Number(value));\n-\n-  return {\n-    isValid: isValid,\n-    parsed: isValid ? Number(value) : 0,\n-    messages: isValid ? [] : [\"Number should be between 0-6.\"],\n-  };\n-};\n-\n-export const hideByMenuItemsSource = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  menuItemsSource: MenuItemsSource,\n-) => {\n-  const baseProperty = getBasePropertyPath(propertyPath);\n-  const currentMenuItemsSource = get(\n-    props,\n-    `${baseProperty}.menuItemsSource`,\n-    \"\",\n-  );\n-\n-  return currentMenuItemsSource === menuItemsSource;\n-};\n-\n-export const hideIfMenuItemsSourceDataIsFalsy = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-) => {\n-  const baseProperty = getBasePropertyPath(propertyPath);\n-  const sourceData = get(props, `${baseProperty}.sourceData`, \"\");\n-\n-  return !sourceData;\n-};\n-\n-export const updateMenuItemsSource = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  propertyValue: unknown,\n-): Array<{ propertyPath: string; propertyValue: unknown }> | undefined => {\n-  const propertiesToUpdate: Array<{\n-    propertyPath: string;\n-    propertyValue: unknown;\n-  }> = [];\n-  const baseProperty = getBasePropertyPath(propertyPath);\n-  const menuItemsSource = get(props, `${baseProperty}.menuItemsSource`);\n-\n-  if (propertyValue === ColumnTypes.MENU_BUTTON && !menuItemsSource) {\n-    // Sets the default value for menuItemsSource to static when\n-    // selecting the menu button column type for the first time\n-    propertiesToUpdate.push({\n-      propertyPath: `${baseProperty}.menuItemsSource`,\n-      propertyValue: MenuItemsSource.STATIC,\n-    });\n-  } else {\n-    const sourceData = get(props, `${baseProperty}.sourceData`);\n-    const configureMenuItems = get(props, `${baseProperty}.configureMenuItems`);\n-    const isMenuItemsSourceChangedFromStaticToDynamic =\n-      menuItemsSource === MenuItemsSource.STATIC &&\n-      propertyValue === MenuItemsSource.DYNAMIC;\n-\n-    if (isMenuItemsSourceChangedFromStaticToDynamic) {\n-      if (!sourceData) {\n-        propertiesToUpdate.push({\n-          propertyPath: `${baseProperty}.sourceData`,\n-          propertyValue: [],\n-        });\n-      }\n-\n-      if (!configureMenuItems) {\n-        propertiesToUpdate.push({\n-          propertyPath: `${baseProperty}.configureMenuItems`,\n-          propertyValue: {\n-            label: \"Configure menu items\",\n-            id: \"config\",\n-            config: {\n-              id: \"config\",\n-              label: \"Menu Item\",\n-              isVisible: true,\n-              isDisabled: false,\n-            },\n-          },\n-        });\n-      }\n-    }\n-  }\n-\n-  return propertiesToUpdate?.length ? propertiesToUpdate : undefined;\n-};\n-\n-export const updateCurrencyDefaultValues = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  propertyValue: unknown,\n-): Array<{ propertyPath: string; propertyValue: unknown }> | undefined => {\n-  const propertiesToUpdate: Array<{\n-    propertyPath: string;\n-    propertyValue: unknown;\n-  }> = [];\n-  const baseProperty = getBasePropertyPath(propertyPath);\n-\n-  if (propertyValue === ColumnTypes.CURRENCY) {\n-    if (!get(props, `${baseProperty}.currencyCode`)) {\n-      propertiesToUpdate.push({\n-        propertyPath: `${baseProperty}.currencyCode`,\n-        propertyValue: \"USD\",\n-      });\n-    }\n-\n-    if (get(props, `${baseProperty}.decimals`) === undefined) {\n-      propertiesToUpdate.push({\n-        propertyPath: `${baseProperty}.decimals`,\n-        propertyValue: 0,\n-      });\n-    }\n-\n-    if (get(props, `${baseProperty}.notation`) === undefined) {\n-      propertiesToUpdate.push({\n-        propertyPath: `${baseProperty}.notation`,\n-        propertyValue: \"standard\",\n-      });\n-    }\n-\n-    if (get(props, `${baseProperty}.thousandSeparator`) === undefined) {\n-      propertiesToUpdate.push({\n-        propertyPath: `${baseProperty}.thousandSeparator`,\n-        propertyValue: true,\n-      });\n-    }\n-  }\n-\n-  return propertiesToUpdate?.length ? propertiesToUpdate : undefined;\n-};\n-\n-export function selectColumnOptionsValidation(\n-  value: unknown,\n-  props: TableWidgetProps,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  _?: any,\n-) {\n-  let _isValid = true,\n-    _parsed,\n-    _message = \"\";\n-  let uniqueValues: Set<unknown>;\n-  const invalidArrayValueMessage = `This value does not evaluate to type: { \"label\": string | number, \"value\": string | number | boolean }`;\n-  const invalidMessage = `This value does not evaluate to type Array<{ \"label\": string | number, \"value\": string | number | boolean }>`;\n-  const allowedValueTypes = [\"string\", \"number\", \"boolean\"];\n-  const allowedLabelTypes = [\"string\", \"number\"];\n-\n-  const generateErrorMessagePrefix = (\n-    rowIndex: number | null,\n-    optionIndex: number,\n-  ) => {\n-    return `Invalid entry at${\n-      rowIndex !== null ? ` Row: ${rowIndex}` : \"\"\n-    } index: ${optionIndex}.`;\n-  };\n-\n-  const generateInvalidArrayValueMessage = (\n-    rowIndex: number | null,\n-    optionIndex: number,\n-  ) =>\n-    `${generateErrorMessagePrefix(\n-      rowIndex,\n-      optionIndex,\n-    )} ${invalidArrayValueMessage}`;\n-\n-  const validateOption = (\n-    // TODO: Fix this the next time the file is edited\n-    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-    option: any,\n-    rowIndex: number | null,\n-    optionIndex: number,\n-  ) => {\n-    /*\n-     *  Option should\n-     *    1. be an object\n-     *    2. have label property\n-     *    3. label should be of type string | number\n-     *    4. have value property\n-     *    5. value should be of type string | number | boolean\n-     *    6. value should be unique amoig the options array\n-     */\n-    if (!_.isObject(option)) {\n-      // 1\n-      return `${generateErrorMessagePrefix(\n-        rowIndex,\n-        optionIndex,\n-      )} This value does not evaluate to type: { \"label\": string | number, \"value\": string | number | boolean }`;\n-    }\n-\n-    if (!option.hasOwnProperty(\"label\")) {\n-      // 2\n-      return `${generateErrorMessagePrefix(\n-        rowIndex,\n-        optionIndex,\n-      )} Missing required key: label`;\n-    }\n-\n-    if (!allowedLabelTypes.includes(typeof option.label)) {\n-      // 3\n-      return `${generateErrorMessagePrefix(\n-        rowIndex,\n-        optionIndex,\n-      )} label does not evaluate to type ${allowedLabelTypes.join(\" | \")}`;\n-    }\n-\n-    if (!option.hasOwnProperty(\"value\")) {\n-      // 4\n-      return `${generateErrorMessagePrefix(\n-        rowIndex,\n-        optionIndex,\n-      )} Missing required key: value`;\n-    }\n-\n-    if (!allowedValueTypes.includes(typeof option.value)) {\n-      // 5\n-      return `${generateErrorMessagePrefix(\n-        rowIndex,\n-        optionIndex,\n-      )} value does not evaluate to type ${allowedValueTypes.join(\" | \")}`;\n-    }\n-\n-    if (uniqueValues.has(option.value)) {\n-      // 6\n-      return `Duplicate values found for the following properties, in the array entries, that must be unique -- value.`;\n-    } else {\n-      uniqueValues.add(option.value);\n-    }\n-\n-    return \"\";\n-  };\n-\n-  try {\n-    if (value === \"\" || _.isNil(value)) {\n-      // empty values\n-      return {\n-        isValid: true,\n-        parsed: [],\n-        messages: [\"\"],\n-      };\n-    } else if (typeof value === \"string\") {\n-      // json string\n-      const _value = JSON.parse(value);\n-\n-      if (Array.isArray(_value)) {\n-        value = _value;\n-      } else {\n-        _isValid = false;\n-        _message = invalidMessage;\n-      }\n-    }\n-\n-    if (Array.isArray(value)) {\n-      if (value.length) {\n-        //when value is array of option json string\n-        if (value.every((d) => _.isString(d))) {\n-          value = value.map((d) => JSON.parse(d));\n-        }\n-\n-        if (Array.isArray(value) && Array.isArray(value[0])) {\n-          // value is array of array of label, value\n-          //Value should be an array of array\n-          if (!value.every((d) => Array.isArray(d))) {\n-            _parsed = [];\n-            _isValid = false;\n-            _message = invalidMessage;\n-          } else {\n-            _parsed = value;\n-            _isValid = true;\n-\n-            for (let i = 0; i < value.length; i++) {\n-              uniqueValues = new Set();\n-\n-              for (let j = 0; j < value[i].length; j++) {\n-                if (_.isNil(value[i][j])) {\n-                  _isValid = false;\n-                  _message = generateInvalidArrayValueMessage(i, j);\n-                  _parsed = [];\n-                  break;\n-                }\n-\n-                if ((_message = validateOption(value[i][j], i, j))) {\n-                  _isValid = false;\n-                  break;\n-                }\n-              }\n-\n-              if (!_isValid) {\n-                break;\n-              }\n-            }\n-          }\n-        } else {\n-          uniqueValues = new Set();\n-          _parsed = value;\n-          _isValid = true;\n-\n-          for (let i = 0; i < (value as Array<unknown>).length; i++) {\n-            if (_.isNil((value as Array<unknown>)[i])) {\n-              _isValid = false;\n-              _message = generateInvalidArrayValueMessage(null, i);\n-              _parsed = [];\n-              break;\n-            }\n-\n-            if (\n-              (_message = validateOption((value as Array<unknown>)[i], null, i))\n-            ) {\n-              _isValid = false;\n-              break;\n-            }\n-          }\n-        }\n-      } else {\n-        _isValid = true;\n-        _parsed = [];\n-      }\n-    } else {\n-      _parsed = [];\n-      _isValid = false;\n-      _message = invalidMessage;\n-    }\n-  } catch (e) {\n-    _parsed = [];\n-    _isValid = false;\n-    _message = invalidMessage;\n-  }\n-\n-  return {\n-    isValid: _isValid,\n-    parsed: _parsed,\n-    messages: [_message],\n-  };\n-}\n-\n-export const getColumnPath = (propPath: string) =>\n-  propPath.split(\".\").slice(0, 2).join(\".\");\n-\n-export const tableDataValidation = (\n-  value: unknown,\n-  props: TableWidgetProps,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  _?: any,\n-) => {\n-  const invalidResponse = {\n-    isValid: false,\n-    parsed: [],\n-    messages: [\n-      {\n-        name: \"TypeError\",\n-        message: `Invalid value. This field expects an array of objects(Array<Object>) or the result of a Query such as \"{{query1.data}}\".`,\n-      },\n-    ],\n-  };\n-\n-  if (value === \"\") {\n-    return {\n-      isValid: true,\n-      parsed: [],\n-    };\n-  }\n-\n-  if (value === undefined || value === null) {\n-    return {\n-      isValid: false,\n-      parsed: [],\n-      messages: [\n-        {\n-          name: \"ValidationError\",\n-          message: \"Data is undefined, re-run your query or fix the data\",\n-        },\n-      ],\n-    };\n-  }\n-\n-  if (!_.isString(value) && !Array.isArray(value)) {\n-    return invalidResponse;\n-  }\n-\n-  let parsed = value;\n-\n-  if (_.isString(value)) {\n-    try {\n-      parsed = JSON.parse(value as string);\n-    } catch (e) {\n-      return invalidResponse;\n-    }\n-  }\n-\n-  if (Array.isArray(parsed)) {\n-    if (parsed.length === 0) {\n-      return {\n-        isValid: true,\n-        parsed: [],\n-      };\n-    }\n-\n-    for (let i = 0; i < parsed.length; i++) {\n-      if (!_.isPlainObject(parsed[i])) {\n-        return {\n-          isValid: false,\n-          parsed: [],\n-          messages: [\n-            {\n-              name: \"ValidationError\",\n-              message: `Invalid object at index ${i}`,\n-            },\n-          ],\n-        };\n-      }\n-    }\n-\n-    return { isValid: true, parsed };\n-  }\n-\n-  return invalidResponse;\n-};\n-\n-export function textForEachRowValidation(\n-  value: unknown,\n-  props: TableWidgetProps,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  _: any,\n-): ValidationResponse {\n-  const generateResponseAndReturn = (\n-    isValid = false,\n-    message = { name: \"\", message: \"\" },\n-  ) => {\n-    return {\n-      isValid,\n-      parsed: isValid ? value : [],\n-      messages: [message],\n-    };\n-  };\n-\n-  const DEFAULT_MESSAGE = {\n-    name: \"TypeError\",\n-    message: \"The evaluated value should be either a string or a number.\",\n-  };\n-\n-  if (\n-    _.isString(value) ||\n-    _.isNumber(value) ||\n-    Array.isArray(value) ||\n-    value === undefined\n-  ) {\n-    if (Array.isArray(value)) {\n-      const isValid = value.every((item) => {\n-        if (_.isString(item) || _.isNumber(item) || item === undefined) {\n-          return true;\n-        }\n-\n-        if (Array.isArray(item)) {\n-          return item.every(\n-            (subItem) =>\n-              _.isString(subItem) ||\n-              _.isNumber(subItem) ||\n-              subItem === undefined,\n-          );\n-        }\n-\n-        return false;\n-      });\n-\n-      return isValid\n-        ? generateResponseAndReturn(true)\n-        : generateResponseAndReturn(false, DEFAULT_MESSAGE);\n-    }\n-\n-    return generateResponseAndReturn(true);\n-  }\n-\n-  return generateResponseAndReturn(false, DEFAULT_MESSAGE);\n-}\n-\n-export function booleanForEachRowValidation(\n-  value: unknown,\n-): ValidationResponse {\n-  const generateResponseAndReturn = (\n-    isValid = false,\n-    message = { name: \"\", message: \"\" },\n-  ) => {\n-    return {\n-      isValid,\n-      parsed: isValid ? value : true,\n-      messages: [message],\n-    };\n-  };\n-\n-  const isBoolean = (value: unknown) => {\n-    const isABoolean = value === true || value === false;\n-    const isStringTrueFalse = value === \"true\" || value === \"false\";\n-\n-    return isABoolean || isStringTrueFalse || value === undefined;\n-  };\n-\n-  const DEFAULT_MESSAGE = {\n-    name: \"TypeError\",\n-    message: \"The evaluated value should be a boolean.\",\n-  };\n-\n-  if (isBoolean(value)) {\n-    return generateResponseAndReturn(true);\n-  }\n-\n-  if (Array.isArray(value)) {\n-    const isValid = value.every((item) => {\n-      if (isBoolean(item)) {\n-        return true;\n-      }\n-\n-      if (Array.isArray(item)) {\n-        return item.every((subItem) => isBoolean(subItem));\n-      }\n-\n-      return false;\n-    });\n-\n-    return isValid\n-      ? generateResponseAndReturn(true)\n-      : generateResponseAndReturn(false, DEFAULT_MESSAGE);\n-  }\n-\n-  return generateResponseAndReturn(false, DEFAULT_MESSAGE);\n-}\n-\n-export function iconNamesForEachRowValidation(\n-  value: unknown,\n-  props: TableWidgetProps,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  _: any,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  moment: any,\n-  propertyPath: string,\n-  config: ValidationConfig,\n-): ValidationResponse {\n-  const generateResponseAndReturn = (\n-    isValid = false,\n-    message = { name: \"\", message: \"\" },\n-  ) => {\n-    return {\n-      isValid,\n-      parsed: isValid ? value : true,\n-      messages: [message],\n-    };\n-  };\n-\n-  const DEFAULT_MESSAGE = {\n-    name: \"TypeError\",\n-    message:\n-      \"The evaluated value should either be an icon name, undefined, null, or an empty string. We currently use the icons from the Blueprint library. You can see the list of icons at https://blueprintjs.com/docs/#icons\",\n-  };\n-\n-  const isIconName = (value: unknown) => {\n-    return (\n-      config?.params?.allowedValues?.includes(value as string) ||\n-      value === undefined ||\n-      value === null ||\n-      value === \"\"\n-    );\n-  };\n-\n-  if (isIconName(value)) {\n-    return generateResponseAndReturn(true);\n-  }\n-\n-  if (Array.isArray(value)) {\n-    const isValid = value.every((item) => {\n-      if (isIconName(item)) {\n-        return true;\n-      }\n-\n-      if (Array.isArray(item)) {\n-        return item.every((subItem) => isIconName(subItem));\n-      }\n-\n-      return false;\n-    });\n-\n-    return isValid\n-      ? generateResponseAndReturn(true)\n-      : generateResponseAndReturn(false, DEFAULT_MESSAGE);\n-  }\n-\n-  return generateResponseAndReturn(false, DEFAULT_MESSAGE);\n-}\n-\n-export function iconPositionForEachRowValidation(\n-  value: unknown,\n-  props: TableWidgetProps,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  _: any,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  moment: any,\n-  propertyPath: string,\n-  config: ValidationConfig,\n-): ValidationResponse {\n-  const generateResponseAndReturn = (\n-    isValid = false,\n-    message = { name: \"\", message: \"\" },\n-  ) => {\n-    return {\n-      isValid,\n-      parsed: isValid ? value : true,\n-      messages: [message],\n-    };\n-  };\n-\n-  const DEFAULT_MESSAGE = {\n-    name: \"TypeError\",\n-    message: `The evaluated value should be one of the allowed values => ${config?.params?.allowedValues?.join(\n-      \", \",\n-    )}, undefined, null, or an empty string`,\n-  };\n-\n-  const isIconPosition = (value: unknown) => {\n-    return (\n-      config?.params?.allowedValues?.includes(value as string) ||\n-      value === undefined ||\n-      value === null ||\n-      value === \"\"\n-    );\n-  };\n-\n-  if (isIconPosition(value)) {\n-    return generateResponseAndReturn(true);\n-  }\n-\n-  if (Array.isArray(value)) {\n-    const isValid = value.every((item) => {\n-      if (isIconPosition(item)) {\n-        return true;\n-      }\n-\n-      if (Array.isArray(item)) {\n-        return item.every((subItem) => isIconPosition(subItem));\n-      }\n-\n-      return false;\n-    });\n-\n-    return isValid\n-      ? generateResponseAndReturn(true)\n-      : generateResponseAndReturn(false, DEFAULT_MESSAGE);\n-  }\n-\n-  return generateResponseAndReturn(false, DEFAULT_MESSAGE);\n-}\n-\n-export function colorForEachRowValidation(\n-  value: unknown,\n-  props: TableWidgetProps,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  _: any,\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  moment: any,\n-  propertyPath: string,\n-  config: ValidationConfig,\n-): ValidationResponse {\n-  const generateResponseAndReturn = (\n-    isValid = false,\n-    message = { name: \"\", message: \"\" },\n-  ) => {\n-    return {\n-      isValid,\n-      parsed: isValid ? value : true,\n-      messages: [message],\n-    };\n-  };\n-\n-  const DEFAULT_MESSAGE = {\n-    name: \"TypeError\",\n-    message: `The evaluated value should match ${config?.params?.regex}`,\n-  };\n-\n-  const isColor = (value: unknown) => {\n-    return config?.params?.regex?.test(value as string);\n-  };\n-\n-  if (isColor(value)) {\n-    return generateResponseAndReturn(true);\n-  }\n-\n-  if (Array.isArray(value)) {\n-    const isValid = value.every((item) => {\n-      if (isColor(item)) {\n-        return true;\n-      }\n-\n-      if (Array.isArray(item)) {\n-        return item.every((subItem) => isColor(subItem));\n-      }\n-\n-      return false;\n-    });\n-\n-    return isValid\n-      ? generateResponseAndReturn(true)\n-      : generateResponseAndReturn(false, DEFAULT_MESSAGE);\n-  }\n-\n-  return generateResponseAndReturn(false, DEFAULT_MESSAGE);\n-}\n-\n-// Infinite scroll not supported for add new row yet\n-export const updateAllowAddNewRowOnInfiniteScrollChange = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  propertyValue: unknown,\n-): Array<{ propertyPath: string; propertyValue: unknown }> | undefined => {\n-  if (propertyValue === true) {\n-    return [\n-      {\n-        propertyPath: \"allowAddNewRow\",\n-        propertyValue: false,\n-      },\n-    ];\n-  } else if (propertyValue === false) {\n-    return [\n-      {\n-        propertyPath: \"allowAddNewRow\",\n-        propertyValue: true,\n-      },\n-    ];\n-  }\n-\n-  return;\n-};\n-\n-// Infinite scroll not supported for search, sort and filters yet\n-export const updateSearchSortFilterOnInfiniteScrollChange = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  propertyValue: unknown,\n-): Array<{ propertyPath: string; propertyValue: unknown }> | undefined => {\n-  if (propertyValue === true) {\n-    return [\n-      {\n-        propertyPath: \"isVisibleSearch\",\n-        propertyValue: false,\n-      },\n-      {\n-        propertyPath: \"isVisibleFilters\",\n-        propertyValue: false,\n-      },\n-      {\n-        propertyPath: \"isSortable\",\n-        propertyValue: false,\n-      },\n-    ];\n-  } else if (propertyValue === false) {\n-    return [\n-      {\n-        propertyPath: \"isVisibleFilters\",\n-        propertyValue: true,\n-      },\n-      {\n-        propertyPath: \"isVisibleSearch\",\n-        propertyValue: true,\n-      },\n-      {\n-        propertyPath: \"isSortable\",\n-        propertyValue: true,\n-      },\n-    ];\n-  }\n-\n-  return;\n-};\n+     *\n\\ No newline at end of file\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx b/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx\nindex 769768d..514c00e 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx\n+++ b/app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx\n@@ -4,7 +4,6 @@ import { RenderModes } from \"constants/WidgetConstants\";\n import { StickyType } from \"../../component/Constants\";\n import {\n   COLUMN_MIN_WIDTH,\n-  ColumnTypes,\n   DEFAULT_COLUMN_WIDTH,\n   DEFAULT_COLUMN_NAME,\n } from \"../../constants\";\n@@ -22,7 +21,6 @@ export type getColumns = (\n   componentWidth: number,\n   renderMode: RenderMode,\n   isPreviewMode: boolean,\n-  infiniteScrollEnabled?: boolean,\n ) => ReactTableColumnProps[];\n \n //TODO: (Vamsi) need to unit test this function\n@@ -34,7 +32,6 @@ export const getColumnsPureFn: getColumns = (\n   componentWidth,\n   renderMode,\n   isPreviewMode,\n-  infiniteScrollEnabled = false,\n ) => {\n   let columns: ReactTableColumnProps[] = [];\n   const hiddenColumns: ReactTableColumnProps[] = [];\n@@ -45,14 +42,6 @@ export const getColumnsPureFn: getColumns = (\n     // TODO: Fix this the next time the file is edited\n     // eslint-disable-next-line @typescript-eslint/no-explicit-any\n     orderedTableColumns.forEach((column: any) => {\n-      // Skip EDIT_ACTIONS columns when infinite scroll is enabled\n-      if (\n-        infiniteScrollEnabled &&\n-        column.columnType === ColumnTypes.EDIT_ACTIONS\n-      ) {\n-        return;\n-      }\n-\n       const isHidden = !column.isVisible;\n \n       const columnData = {\n@@ -193,4 +182,4 @@ export const getMemoiseGetColumnsWithLocalStorageFn = () => {\n     },\n     isEqual,\n   );\n-};\n+};\n\\ No newline at end of file\ndiff --git a/app/client/src/widgets/TableWidgetV2/widget/utilities.ts b/app/client/src/widgets/TableWidgetV2/widget/utilities.ts\nindex 5b2cd64..15cea49 100644\n--- a/app/client/src/widgets/TableWidgetV2/widget/utilities.ts\n+++ b/app/client/src/widgets/TableWidgetV2/widget/utilities.ts\n@@ -510,670 +510,4 @@ export const getCellProperties = (\n       ),\n       timePrecision: getPropertyValue(\n         columnProperties.timePrecision,\n-        rowIndex,\n-        true,\n-      ),\n-      currencyCode: getPropertyValue(\n-        columnProperties.currencyCode,\n-        rowIndex,\n-        true,\n-      ),\n-      decimals: columnProperties.decimals,\n-      thousandSeparator: getBooleanPropertyValue(\n-        columnProperties.thousandSeparator,\n-        rowIndex,\n-      ),\n-      notation: getPropertyValue(columnProperties.notation, rowIndex, true),\n-    } as CellLayoutProperties;\n-  }\n-\n-  return {} as CellLayoutProperties;\n-};\n-\n-const EdtiableColumnTypes: string[] = [\n-  ColumnTypes.TEXT,\n-  ColumnTypes.NUMBER,\n-  ColumnTypes.SELECT,\n-  ColumnTypes.CHECKBOX,\n-  ColumnTypes.SWITCH,\n-  ColumnTypes.DATE,\n-  ColumnTypes.CURRENCY,\n-];\n-\n-export function isColumnTypeEditable(\n-  columnType: string,\n-  isInfiniteScrollEnabled = false,\n-) {\n-  return EdtiableColumnTypes.includes(columnType) && !isInfiniteScrollEnabled;\n-}\n-\n-/*\n- * Nested propeties are not validated when application is refreshed\n- * TODO(Balai): Should confirm and create an issue to address this.\n- */\n-export function getSelectColumnTypeOptions(value: unknown) {\n-  const result = SelectColumnOptionsValidations(value, {}, _);\n-\n-  return result.parsed;\n-}\n-\n-/**\n- * returns selected row bg color\n- *\n- * if the color is dark, use 80% lighter color for selected row\n- * if color is light, use 10% darker color for selected row\n- *\n- * @param accentColor\n- */\n-export const getSelectedRowBgColor = (accentColor: string) => {\n-  const tinyAccentColor = tinycolor(accentColor);\n-  const brightness = tinycolor(accentColor).greyscale().getBrightness();\n-\n-  const percentageBrightness = (brightness / 255) * 100;\n-  let nextBrightness = 0;\n-\n-  switch (true) {\n-    case percentageBrightness > 70:\n-      nextBrightness = 10;\n-      break;\n-    case percentageBrightness > 50:\n-      nextBrightness = 35;\n-      break;\n-    case percentageBrightness > 50:\n-      nextBrightness = 55;\n-      break;\n-    default:\n-      nextBrightness = 60;\n-  }\n-\n-  if (brightness > 180) {\n-    return tinyAccentColor.darken(10).toString();\n-  } else {\n-    return tinyAccentColor.lighten(nextBrightness).toString();\n-  }\n-};\n-\n-/**\n- * this is a getter function to get stylesheet value of the property from the config\n- *\n- * @param props\n- * @param propertyPath\n- * @param widgetStylesheet\n- * @returns\n- */\n-export const getStylesheetValue = (\n-  props: TableWidgetProps,\n-  propertyPath: string,\n-  widgetStylesheet?: Stylesheet,\n-) => {\n-  const propertyName = propertyPath.split(\".\").slice(-1)[0];\n-  const columnName = propertyPath.split(\".\").slice(-2)[0];\n-  const columnType = get(props, `primaryColumns.${columnName}.columnType`);\n-\n-  return get(widgetStylesheet, `childStylesheet.${columnType}.${propertyName}`);\n-};\n-\n-export const reorderColumns = (\n-  columns: Record<string, ColumnProperties>,\n-  columnOrder: string[],\n-) => {\n-  const newColumnsInOrder: Record<string, ColumnProperties> = {};\n-\n-  uniq(columnOrder).forEach((id: string, index: number) => {\n-    if (columns[id]) newColumnsInOrder[id] = { ...columns[id], index };\n-  });\n-  const remaining = without(\n-    Object.keys(columns),\n-    ...Object.keys(newColumnsInOrder),\n-  );\n-  const len = Object.keys(newColumnsInOrder).length;\n-\n-  if (remaining && remaining.length > 0) {\n-    remaining.forEach((id: string, index: number) => {\n-      newColumnsInOrder[id] = { ...columns[id], index: len + index };\n-    });\n-  }\n-\n-  return newColumnsInOrder;\n-};\n-\n-export const getEditActionColumnProperties = () => ({\n-  isSaveVisible: true,\n-  isDiscardVisible: true,\n-  saveIconAlign: \"left\",\n-  discardIconAlign: \"left\",\n-  saveActionLabel: \"Save\",\n-  discardActionLabel: \"Discard\",\n-  saveButtonColor: Colors.GREEN,\n-  discardButtonColor: Colors.GREEN,\n-});\n-\n-export const getEditActionColumnDynamicProperties = (widgetName: string) => ({\n-  isSaveDisabled: `{{${widgetName}.processedTableData.map((currentRow, currentIndex) => ( !${widgetName}.updatedRowIndices.includes(currentIndex)))}}`,\n-  isDiscardDisabled: `{{${widgetName}.processedTableData.map((currentRow, currentIndex) => ( !${widgetName}.updatedRowIndices.includes(currentIndex)))}}`,\n-});\n-\n-export const createColumn = (props: TableWidgetProps, baseName: string) => {\n-  const columns = props.primaryColumns || {};\n-  const columnsArray = Object.values(columns);\n-  const columnIds = columnsArray.map((column) => column.originalId);\n-  const newColumnName = getNextEntityName(baseName, columnIds);\n-  const lastItemIndex = columnsArray\n-    .map((column) => column.index)\n-    .sort()\n-    .pop();\n-\n-  const nextIndex = lastItemIndex ? lastItemIndex + 1 : columnIds.length;\n-\n-  return {\n-    ...getDefaultColumnProperties(\n-      newColumnName,\n-      newColumnName,\n-      nextIndex,\n-      props.widgetName,\n-      true,\n-    ),\n-    buttonStyle: DEFAULT_BUTTON_COLOR,\n-    isDisabled: false,\n-    ...getTableStyles(props),\n-  };\n-};\n-\n-export const createEditActionColumn = (props: TableWidgetProps) => {\n-  const themeProps: Record<string, string> = {};\n-\n-  if (props.childStylesheet[ColumnTypes.EDIT_ACTIONS]) {\n-    Object.entries(props.childStylesheet[ColumnTypes.EDIT_ACTIONS]).forEach(\n-      ([key, value]) => {\n-        const { jsSnippets, stringSegments } = getDynamicBindings(\n-          value as string,\n-        );\n-\n-        const js = combineDynamicBindings(jsSnippets, stringSegments);\n-\n-        themeProps[key] =\n-          `{{${props.widgetName}.processedTableData.map((currentRow, currentIndex) => ( ${js}))}}`;\n-      },\n-    );\n-  }\n-\n-  const column = {\n-    ...createColumn(props, \"EditActions\"),\n-    ...getEditActionColumnProperties(),\n-    ...themeProps,\n-    columnType: ColumnTypes.EDIT_ACTIONS,\n-    label: \"Save / Discard\",\n-    discardButtonVariant: ButtonVariantTypes.TERTIARY,\n-    discardButtonColor: Colors.DANGER_SOLID,\n-    sticky: StickyType.RIGHT,\n-  };\n-  const columnOrder = [...(props.columnOrder || [])];\n-  const editActionDynamicProperties = getEditActionColumnDynamicProperties(\n-    props.widgetName,\n-  );\n-\n-  const rightColumnIndex = columnOrder\n-    .map((column) => props.primaryColumns[column])\n-    .filter((col) => col.sticky !== StickyType.RIGHT).length;\n-\n-  columnOrder.splice(rightColumnIndex, 0, column.id);\n-\n-  return [\n-    {\n-      propertyPath: `primaryColumns.${column.id}`,\n-      propertyValue: {\n-        ...column,\n-        ...editActionDynamicProperties,\n-      },\n-    },\n-    {\n-      propertyPath: `columnOrder`,\n-      propertyValue: columnOrder,\n-    },\n-    ...Object.entries(editActionDynamicProperties).map(([key, value]) => ({\n-      propertyPath: `primaryColumns.${column.id}.${key}`,\n-      propertyValue: value,\n-      isDynamicPropertyPath: true,\n-    })),\n-  ];\n-};\n-\n-export const getColumnType = (\n-  tableData: Array<Record<string, unknown>>,\n-  columnKey: string,\n-): string => {\n-  if (!_.isArray(tableData) || tableData.length === 0 || !columnKey) {\n-    return ColumnTypes.TEXT;\n-  }\n-\n-  let columnValue: unknown = null,\n-    row = 0;\n-  const maxRowsToCheck = 5;\n-\n-  /*\n-    In below while loop we are trying to get a non-null value from\n-    subsequent rows in case first few rows are null\n-    Limited to checking upto maxRowsToCheck\n-  */\n-  while (_.isNil(columnValue) && row < maxRowsToCheck) {\n-    if (!_.isNil(tableData?.[row]?.[columnKey])) {\n-      columnValue = tableData[row][columnKey];\n-      break;\n-    }\n-\n-    row++;\n-  }\n-\n-  if (_.isNil(columnValue)) {\n-    return ColumnTypes.TEXT;\n-  }\n-\n-  switch (typeof columnValue) {\n-    case \"number\":\n-      return ColumnTypes.NUMBER;\n-    case \"boolean\":\n-      return ColumnTypes.CHECKBOX;\n-    case \"string\": {\n-      const isHTML = /<[^>]*>/.test(columnValue as string);\n-\n-      if (isHTML) {\n-        return ColumnTypes.HTML;\n-      }\n-\n-      const isAnyValidDate = dateFormatOptions.some(({ value: format }) =>\n-        moment(columnValue as string, format, true).isValid(),\n-      );\n-\n-      if (isAnyValidDate) {\n-        return ColumnTypes.DATE;\n-      }\n-\n-      return ColumnTypes.TEXT;\n-    }\n-    default:\n-      return ColumnTypes.TEXT;\n-  }\n-};\n-\n-export const generateLocalNewColumnOrderFromStickyValue = (\n-  columnOrder: string[],\n-  columnName: string,\n-  sticky?: string,\n-  leftOrder?: string[],\n-  rightOrder?: string[],\n-) => {\n-  let newColumnOrder = [...columnOrder];\n-\n-  newColumnOrder = without(newColumnOrder, columnName);\n-\n-  let columnIndex = -1;\n-\n-  if (sticky === StickyType.LEFT && leftOrder) {\n-    columnIndex = leftOrder.length;\n-  } else if (sticky === StickyType.RIGHT && rightOrder) {\n-    columnIndex =\n-      rightOrder.length !== 0\n-        ? columnOrder.indexOf(rightOrder[0]) - 1\n-        : columnOrder.length - 1;\n-  } else {\n-    if (leftOrder?.includes(columnName)) {\n-      columnIndex = leftOrder.length - 1;\n-    } else if (rightOrder?.includes(columnName)) {\n-      columnIndex =\n-        rightOrder.length !== 0\n-          ? columnOrder.indexOf(rightOrder[0])\n-          : columnOrder.length - 1;\n-    }\n-  }\n-\n-  newColumnOrder.splice(columnIndex, 0, columnName);\n-\n-  return newColumnOrder;\n-};\n-/**\n- * Function to get new column order when there is a change in column's sticky value.\n- */\n-export const generateNewColumnOrderFromStickyValue = (\n-  primaryColumns: Record<string, ColumnProperties>,\n-  columnOrder: string[],\n-  columnName: string,\n-  sticky?: string,\n-) => {\n-  let newColumnOrder = [...columnOrder];\n-\n-  newColumnOrder = without(newColumnOrder, columnName);\n-\n-  let columnIndex;\n-\n-  if (sticky === StickyType.LEFT) {\n-    columnIndex = columnOrder\n-      .map((column) => primaryColumns[column])\n-      .filter((column) => column.sticky === StickyType.LEFT).length;\n-  } else if (sticky === StickyType.RIGHT) {\n-    columnIndex =\n-      columnOrder\n-        .map((column) => primaryColumns[column])\n-        .filter((column) => column.sticky !== StickyType.RIGHT).length - 1;\n-  } else {\n-    /**\n-     * This block will manage the column order when column is unfrozen.\n-     * Unfreezing can happen in CANVAS or PAGE mode.\n-     * Logic:\n-     * --> If the column is unfrozen when its on the left, then it should be unfrozen after the last left frozen column.\n-     * --> If the column is unfrozen when its on the right, then it should be unfrozen before the first right frozen column.\n-     */\n-    columnIndex = -1;\n-\n-    const staleStickyValue = primaryColumns[columnName].sticky;\n-\n-    if (staleStickyValue === StickyType.LEFT) {\n-      columnIndex = columnOrder\n-        .map((column) => primaryColumns[column])\n-        .filter(\n-          (column) =>\n-            column.sticky === StickyType.LEFT && column.id !== columnName,\n-        ).length;\n-    } else if (staleStickyValue === StickyType.RIGHT) {\n-      columnIndex = columnOrder\n-        .map((column) => primaryColumns[column])\n-        .filter((column) => column.sticky !== StickyType.RIGHT).length;\n-    }\n-  }\n-\n-  newColumnOrder.splice(columnIndex, 0, columnName);\n-\n-  return newColumnOrder;\n-};\n-\n-export const getSourceDataAndCaluclateKeysForEventAutoComplete = (\n-  props: TableWidgetProps,\n-): unknown => {\n-  const { __evaluation__, primaryColumns } = props;\n-  const primaryColumnKeys = primaryColumns ? Object.keys(primaryColumns) : [];\n-  const columnName = primaryColumnKeys?.length ? primaryColumnKeys[0] : \"\";\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  const evaluatedColumns: any = __evaluation__?.evaluatedValues?.primaryColumns;\n-\n-  if (evaluatedColumns) {\n-    const result = getKeysFromSourceDataForEventAutocomplete(\n-      evaluatedColumns[columnName]?.sourceData || [],\n-    );\n-\n-    return result;\n-  } else {\n-    return {};\n-  }\n-};\n-\n-export const deleteLocalTableColumnOrderByWidgetId = (widgetId: string) => {\n-  try {\n-    const localData = localStorage.getItem(TABLE_COLUMN_ORDER_KEY);\n-\n-    if (localData) {\n-      const localColumnOrder = JSON.parse(localData);\n-\n-      delete localColumnOrder[widgetId];\n-      localStorage.setItem(\n-        TABLE_COLUMN_ORDER_KEY,\n-        JSON.stringify(localColumnOrder),\n-      );\n-    }\n-  } catch (e) {\n-    log.debug(\"Error in reading local data\", e);\n-  }\n-};\n-\n-export const updateAndSyncTableLocalColumnOrders = (\n-  columnName: string,\n-  leftOrder: string[],\n-  rightOrder: string[],\n-  sticky?: StickyType,\n-) => {\n-  if (sticky === StickyType.LEFT) {\n-    leftOrder.push(columnName);\n-\n-    if (rightOrder) {\n-      rightOrder = without(rightOrder, columnName);\n-    }\n-  } else if (sticky === StickyType.RIGHT) {\n-    rightOrder.unshift(columnName);\n-\n-    // When column is frozen to right from left. Remove the column name from leftOrder\n-    if (leftOrder) {\n-      leftOrder = without(leftOrder, columnName);\n-    }\n-  } else {\n-    // remove column from both orders:\n-    leftOrder = without(leftOrder, columnName);\n-    rightOrder = without(rightOrder, columnName);\n-  }\n-\n-  return { leftOrder, rightOrder };\n-};\n-\n-export const getColumnOrderByWidgetIdFromLS = (widgetId: string) => {\n-  const localTableWidgetColumnOrder = localStorage.getItem(\n-    TABLE_COLUMN_ORDER_KEY,\n-  );\n-\n-  if (localTableWidgetColumnOrder) {\n-    try {\n-      const parsedTableWidgetColumnOrder = JSON.parse(\n-        localTableWidgetColumnOrder,\n-      );\n-\n-      if (parsedTableWidgetColumnOrder[widgetId]) {\n-        const { columnOrder, columnUpdatedAt, leftOrder, rightOrder } =\n-          parsedTableWidgetColumnOrder[widgetId];\n-\n-        return {\n-          columnOrder,\n-          columnUpdatedAt,\n-          leftOrder,\n-          rightOrder,\n-        };\n-      }\n-    } catch (e) {\n-      log.debug(\"Unable to parse local column order:\", { e });\n-    }\n-  }\n-};\n-\n-export const getAllStickyColumnsCount = (columns: TableColumnProps[]) => {\n-  return (\n-    filter(columns, { sticky: StickyType.LEFT }).length +\n-    filter(columns, { sticky: StickyType.RIGHT }).length\n-  );\n-};\n-\n-/**\n- *\n- * @param currentIndex: current dragging item index\n- * @param targetIndex: Index poistion of of header that is being hovered\n- * @returns\n- */\n-export const getHeaderClassNameOnDragDirection = (\n-  currentIndex: number,\n-  targetIndex: number,\n-) => {\n-  let parentClasses = \"th header-reorder\";\n-\n-  if (currentIndex !== -1) {\n-    if (targetIndex > currentIndex) {\n-      parentClasses += \" highlight-right\";\n-    } else if (targetIndex < currentIndex) {\n-      parentClasses += \" highlight-left\";\n-    }\n-  }\n-\n-  return parentClasses;\n-};\n-\n-export const getIndexByColumnName = (\n-  columnName: string,\n-  columnOrder?: string[],\n-) => {\n-  let currentIndex = -1;\n-\n-  if (columnOrder) {\n-    currentIndex = columnOrder.indexOf(columnName);\n-  }\n-\n-  return currentIndex;\n-};\n-\n-/**\n- * A function to get all drag and drop handlers for HeaderCell component.\n- * @param columns: React table columns\n- * @param currentDraggedColumn: The Mutable ref object that references column being dragged\n- * @param handleReorderColumn : Function to handle column reordering.\n- * @param columnOrder\n- * @returns\n- */\n-export const getDragHandlers = (\n-  columns: ReactTableColumnProps[],\n-  currentDraggedColumn: React.MutableRefObject<string>,\n-  handleReorderColumn: (columnOrder: string[]) => void,\n-  columnOrder?: string[],\n-) => {\n-  const onDrag = (e: React.DragEvent<HTMLDivElement>) => {\n-    e.stopPropagation();\n-  };\n-\n-  const onDragEnter = (\n-    e: React.DragEvent<HTMLDivElement>,\n-    targetIndex: number,\n-  ) => {\n-    // We get the parent element(.th) so as to apply left and right highlighting\n-    const targetElem = e.target as HTMLDivElement;\n-    const parentTargetElem = targetElem.closest(\".th.header-reorder\");\n-\n-    const currentIndex = getIndexByColumnName(\n-      currentDraggedColumn.current,\n-      columnOrder,\n-    );\n-\n-    if (parentTargetElem) {\n-      parentTargetElem.className = getHeaderClassNameOnDragDirection(\n-        currentIndex,\n-        targetIndex,\n-      );\n-    }\n-\n-    e.stopPropagation();\n-    e.preventDefault();\n-  };\n-\n-  const onDragEnd = (e: React.DragEvent<HTMLDivElement>) => {\n-    const targetElem = e.target as HTMLDivElement;\n-\n-    targetElem.className = targetElem.className.replace(\n-      \" draggable-header--dragging\",\n-      \"\",\n-    );\n-    e.preventDefault();\n-  };\n-\n-  const onDragLeave = (e: React.DragEvent<HTMLDivElement>) => {\n-    const targetElem = e.target as HTMLDivElement;\n-    const parentTargetElem = targetElem.closest(\".th.header-reorder\");\n-\n-    if (parentTargetElem) {\n-      parentTargetElem.className = \"th header-reorder\";\n-    }\n-\n-    e.preventDefault();\n-  };\n-  const onDragOver = (\n-    e: React.DragEvent<HTMLDivElement>,\n-    targetIndex: number,\n-  ) => {\n-    // We get the parent element(.th) so as to apply left and right highlighting\n-    const targetElem = e.target as HTMLDivElement;\n-    const parentTargetElem = targetElem.closest(\".th.header-reorder\");\n-\n-    const currentIndex = getIndexByColumnName(\n-      currentDraggedColumn.current,\n-      columnOrder,\n-    );\n-\n-    if (parentTargetElem) {\n-      parentTargetElem.className = getHeaderClassNameOnDragDirection(\n-        currentIndex,\n-        targetIndex,\n-      );\n-    }\n-\n-    e.stopPropagation();\n-    e.preventDefault();\n-  };\n-\n-  const onDragStart = (e: React.DragEvent<HTMLDivElement>, index: number) => {\n-    currentDraggedColumn.current = columns[index].alias;\n-    const targetElem = e.target as HTMLDivElement;\n-\n-    targetElem.className = targetElem.className + \" draggable-header--dragging\";\n-    e.stopPropagation();\n-  };\n-\n-  const onDrop = (e: React.DragEvent<HTMLDivElement>, index: number) => {\n-    const targetElem = e.target as HTMLDivElement;\n-\n-    if (currentDraggedColumn.current) {\n-      const partialColumnOrder = without(\n-        columnOrder,\n-        currentDraggedColumn.current,\n-      );\n-\n-      partialColumnOrder.splice(index, 0, currentDraggedColumn.current);\n-      handleReorderColumn(partialColumnOrder);\n-    }\n-\n-    targetElem.className = targetElem.className.replace(\n-      \" draggable-header--dragging\",\n-      \"\",\n-    );\n-    e.stopPropagation();\n-  };\n-\n-  return {\n-    onDrag,\n-    onDragEnd,\n-    onDragEnter,\n-    onDragLeave,\n-    onDragOver,\n-    onDragStart,\n-    onDrop,\n-  };\n-};\n-\n-export const getSelectOptions = (\n-  isNewRow: boolean,\n-  rowIndex: number,\n-  columnProperties: ColumnProperties,\n-) => {\n-  if (isNewRow) {\n-    if (\n-      columnProperties.allowSameOptionsInNewRow &&\n-      columnProperties?.selectOptions\n-    ) {\n-      // Use select options from the first row\n-      return getArrayPropertyValue(columnProperties.selectOptions, 0);\n-    } else {\n-      return columnProperties.newRowSelectOptions;\n-    }\n-  } else {\n-    return getArrayPropertyValue(columnProperties.selectOptions, rowIndex);\n-  }\n-};\n-\n-export function convertNumToCompactString(num: number) {\n-  if (num >= 1e6) {\n-    return (num / 1e6).toFixed(1) + \"M\";\n-  } else if (num >= 1e3) {\n-    return (num / 1e3).toFixed(1) + \"K\";\n-  } else {\n-    return num.toString();\n-  }\n-}\n+        rowIndex,\n\\ No newline at end of file\n",
    "pr_number": 41217,
    "title": "fix: updates the logic to not interfere with DSL when infinitescroll is enabled",
    "test_files": [
      "app/client/src/widgets/TableWidgetV2/widget/__tests__/propertyUtils.test.ts"
    ],
    "code_files": [
      "app/client/src/widgets/TableWidgetV2/component/cellComponents/HeaderCell.tsx",
      "app/client/src/widgets/TableWidgetV2/widget/index.tsx",
      "app/client/src/widgets/TableWidgetV2/widget/propertyConfig/PanelConfig/General.ts",
      "app/client/src/widgets/TableWidgetV2/widget/propertyConfig/contentConfig.ts",
      "app/client/src/widgets/TableWidgetV2/widget/propertyUtils.ts",
      "app/client/src/widgets/TableWidgetV2/widget/reactTableUtils/getColumnsPureFn.tsx",
      "app/client/src/widgets/TableWidgetV2/widget/utilities.ts"
    ]
  },
  {
    "instance_id": "appsmithorg__appsmith.main.41370",
    "repo": "appsmithorg/appsmith",
    "base_commit": "f092c5df46c19cf24edebde095e1e6ea19c98c41",
    "bug_patch": "diff --git a/app/client/cypress/e2e/Regression/ClientSide/Widgets/TableV2/scrollbar_spec.ts b/app/client/cypress/e2e/Regression/ClientSide/Widgets/TableV2/scrollbar_spec.ts\nindex b15899b..0dcd6db 100644\n--- a/app/client/cypress/e2e/Regression/ClientSide/Widgets/TableV2/scrollbar_spec.ts\n+++ b/app/client/cypress/e2e/Regression/ClientSide/Widgets/TableV2/scrollbar_spec.ts\n@@ -24,11 +24,9 @@ describe(\n       });\n \n       cy.get(\".t--draggable-tablewidgetv2 .table .simplebar-content\").then(\n-        ($scrollBox) => {\n-          // +2 is because of the SCROLL_BAR_OFFSET, which got added to the table height in PR: https://github.com/appsmithorg/appsmith/pull/41370\n-          expect($scrollBox[0].clientHeight).to.be.equal(tableHeight + 2);\n-        },\n+        ($scrollBox) =>\n+          expect($scrollBox[0].clientHeight).to.be.equal(tableHeight),\n       );\n     });\n   },\n-);\n+);\n\\ No newline at end of file\ndiff --git a/app/client/src/widgets/TableWidgetV2/component/Constants.ts b/app/client/src/widgets/TableWidgetV2/component/Constants.ts\nindex 6896ccb..1aa9af6 100644\n--- a/app/client/src/widgets/TableWidgetV2/component/Constants.ts\n+++ b/app/client/src/widgets/TableWidgetV2/component/Constants.ts\n@@ -469,163 +469,4 @@ export const ConditionFunctions: {\n   },\n   // TODO: Fix this the next time the file is edited\n   // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  doesNotContain: (a: any, b: any) => {\n-    if (isString(a) && isString(b)) {\n-      return !a.includes(b);\n-    }\n-\n-    return false;\n-  },\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  startsWith: (a: any, b: any) => {\n-    if (isString(a) && isString(b)) {\n-      return a.indexOf(b) === 0;\n-    }\n-\n-    return false;\n-  },\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  endsWith: (a: any, b: any) => {\n-    if (isString(a) && isString(b)) {\n-      return a.length === a.lastIndexOf(b) + b.length;\n-    }\n-\n-    return false;\n-  },\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  is: (a: any, b: any) => {\n-    return moment(a).isSame(moment(b), \"d\");\n-  },\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  isNot: (a: any, b: any) => {\n-    return !moment(a).isSame(moment(b), \"d\");\n-  },\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  isAfter: (a: any, b: any) => {\n-    return !moment(a).isAfter(moment(b), \"d\");\n-  },\n-  // TODO: Fix this the next time the file is edited\n-  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n-  isBefore: (a: any, b: any) => {\n-    return !moment(a).isBefore(moment(b), \"d\");\n-  },\n-};\n-\n-export enum JUSTIFY_CONTENT {\n-  LEFT = \"flex-start\",\n-  CENTER = \"center\",\n-  RIGHT = \"flex-end\",\n-}\n-\n-export enum TEXT_ALIGN {\n-  LEFT = \"left\",\n-  CENTER = \"center\",\n-  RIGHT = \"right\",\n-}\n-\n-export enum ALIGN_ITEMS {\n-  TOP = \"flex-start\",\n-  CENTER = \"center\",\n-  BOTTOM = \"flex-end\",\n-}\n-\n-export enum IMAGE_HORIZONTAL_ALIGN {\n-  LEFT = \"flex-start\",\n-  CENTER = \"center\",\n-  RIGHT = \"flex-end\",\n-}\n-\n-export enum IMAGE_VERTICAL_ALIGN {\n-  TOP = \"flex-start\",\n-  CENTER = \"center\",\n-  BOTTOM = \"flex-end\",\n-}\n-\n-export interface BaseCellComponentProps {\n-  compactMode: CompactMode;\n-  isHidden: boolean;\n-  allowCellWrapping?: boolean;\n-  horizontalAlignment?: CellAlignment;\n-  verticalAlignment?: VerticalAlignment;\n-  cellBackground?: string;\n-  isCellVisible: boolean;\n-  fontStyle?: string;\n-  textColor?: string;\n-  textSize?: string;\n-  isCellDisabled?: boolean;\n-}\n-\n-export enum CheckboxState {\n-  UNCHECKED = 0,\n-  CHECKED = 1,\n-  PARTIAL = 2,\n-}\n-\n-export const scrollbarOnHoverCSS = `\n-  .track-horizontal {\n-    height: 6px;\n-    bottom: 1px;\n-    width: 100%;\n-    opacity: 0;\n-    transition: opacity 0.15s ease-in;\n-    &:active {\n-      opacity: 1;\n-    }\n-  }\n-  &:hover {\n-    .track-horizontal {\n-      opacity: 1;\n-    }\n-  }\n-  .thumb-horizontal {\n-    &:hover, &:active {\n-      height: 6px !important;\n-    }\n-  }\n-`;\n-\n-export const MULTISELECT_CHECKBOX_WIDTH = 40;\n-\n-export enum AddNewRowActions {\n-  SAVE = \"SAVE\",\n-  DISCARD = \"DISCARD\",\n-}\n-\n-export const EDITABLE_CELL_PADDING_OFFSET = 8;\n-\n-export const TABLE_SCROLLBAR_WIDTH = 10;\n-export const TABLE_SCROLLBAR_HEIGHT = 10;\n-\n-export const POPOVER_ITEMS_TEXT_MAP = {\n-  SORT_ASC: \"Sort column ascending\",\n-  SORT_DSC: \"Sort column descending\",\n-  FREEZE_LEFT: \"Freeze column left\",\n-  FREEZE_RIGHT: \"Freeze column right\",\n-};\n-\n-export const HEADER_MENU_PORTAL_CLASS = \".header-menu-portal\";\n-export const MENU_CONTENT_CLASS = \".menu-content\";\n-export const DEFAULT_FILTER = {\n-  id: generateReactKey(),\n-  column: \"\",\n-  operator: OperatorTypes.OR,\n-  value: \"\",\n-  condition: \"\",\n-};\n-\n-export const itemHeight = 45;\n-\n-export const noOfItemsToDisplay = 4;\n-\n-// 12px for the (noOfItemsToDisplay+ 1) item to let the user know there are more items to scroll\n-export const extraSpace = 12;\n-\n-export enum TableSelectColumnOptionKeys {\n-  LABEL = \"label\",\n-  VALUE = \"value\",\n-}\n+  doesNotContain: (a:\n\\ No newline at end of file\ndiff --git a/app/client/src/widgets/TableWidgetV2/component/TableContext.test.tsx b/app/client/src/widgets/TableWidgetV2/component/TableContext.test.tsx\nindex 6eb798b..0685b3e 100644\n--- a/app/client/src/widgets/TableWidgetV2/component/TableContext.test.tsx\n+++ b/app/client/src/widgets/TableWidgetV2/component/TableContext.test.tsx\n@@ -249,7 +249,7 @@ describe(\"TableContext\", () => {\n         .tableContext;\n \n       expect(context.scrollContainerStyles).toEqual({\n-        height: 350, // 400 - 40 - 10 (height - TABLE_HEADER_HEIGHT - TABLE_SCROLLBAR_HEIGHT)\n+        height: 352, // 400 - 40 - 8 (height - TABLE_HEADER_HEIGHT - TABLE_SCROLLBAR_HEIGHT)\n         width: 800,\n       });\n     });\n@@ -267,7 +267,7 @@ describe(\"TableContext\", () => {\n         .tableContext;\n \n       expect(context.scrollContainerStyles).toEqual({\n-        height: 388, // 400 - 10 - 2 (height - TABLE_SCROLLBAR_HEIGHT - SCROLL_BAR_OFFSET)\n+        height: 390, // 400 - 8 - 2 (height - TABLE_SCROLLBAR_HEIGHT - SCROLL_BAR_OFFSET)\n         width: 800,\n       });\n     });\n@@ -310,4 +310,4 @@ describe(\"TableContext\", () => {\n \n     expect(firstText).toBe(secondText);\n   });\n-});\n+});\n\\ No newline at end of file\ndiff --git a/app/client/src/widgets/TableWidgetV2/component/TableStyledWrappers.tsx b/app/client/src/widgets/TableWidgetV2/component/TableStyledWrappers.tsx\nindex f22db0b..e081928 100644\n--- a/app/client/src/widgets/TableWidgetV2/component/TableStyledWrappers.tsx\n+++ b/app/client/src/widgets/TableWidgetV2/component/TableStyledWrappers.tsx\n@@ -64,19 +64,21 @@ export const TableWrapper = styled.div<{\n   .simplebar-track {\n     opacity: 0.7;\n     &.simplebar-horizontal {\n-      /* this height moves the scrollbar up and down */\n+-      /* this height moves the scrollbar up and down */\n       height: ${TABLE_SCROLLBAR_HEIGHT}px;\n       .simplebar-scrollbar {\n-        /*this actual height of the scrollbar */\n-        height: 8px;\n-      }\n-      &.simplebar-hover {\n-        & .simplebar-scrollbar {\n-          transition: height 0.15s ease-in-out;\n-          height: 8px;\n-        }\n-      }\n-    }\n+-        /*this actual height of the scrollbar */\n+-        height: 8px;\n++        height: 5px;\n+       }\n+       &.simplebar-hover {\n++        height: 10px;\n+         & .simplebar-scrollbar {\n+-          transition: height 0.15s ease-in-out;\n+           height: 8px;\n+         }\n+       }\n+     }\n \n     &.simplebar-vertical {\n       direction: rtl;\n@@ -482,340 +484,4 @@ export const ActionWrapper = styled.div<{ disabled: boolean }>`\n       border: none;\n     }\n     .bp3-button span {\n-      font-weight: 400;\n-      text-decoration: none;\n-    }\n-    &&& .bp3-disabled {\n-      background: ${Colors.GREY_1};\n-      color: ${Colors.GREY_4};\n-    }\n-  }\n-`;\n-\n-export const IconButtonWrapper = styled.div<{ disabled: boolean }>`\n-  ${(props) => (props.disabled ? \"cursor: not-allowed;\" : null)}\n-  align-items: center;\n-  display: flex;\n-}\n-`;\n-\n-export const TableStyles = css<{\n-  cellProperties?: CellLayoutProperties;\n-  isTextType?: boolean;\n-}>``;\n-\n-export const CELL_WRAPPER_LINE_HEIGHT = 28;\n-\n-export const CellWrapper = styled.div<{\n-  isHidden?: boolean;\n-  isHyperLink?: boolean;\n-  isCellVisible?: boolean;\n-  isTextType?: boolean;\n-  compactMode?: string;\n-  allowCellWrapping?: boolean;\n-  horizontalAlignment?: CellAlignment;\n-  verticalAlignment?: VerticalAlignment;\n-  fontStyle?: string;\n-  textColor?: string;\n-  cellBackground?: string;\n-  textSize?: string;\n-  disablePadding?: boolean;\n-  imageSize?: ImageSize;\n-  isCellDisabled?: boolean;\n-}>`\n-  display: ${(props) => (props.isCellVisible !== false ? \"flex\" : \"none\")};\n-  align-items: center;\n-  justify-content: flex-start;\n-  width: 100%;\n-  height: 100%;\n-  ${(props) => (props.isHidden ? invisible : \"\")};\n-  font-weight: ${(props) =>\n-    props.fontStyle?.includes(FontStyleTypes.BOLD) ? \"bold\" : \"normal\"};\n-  color: ${(props) => props.textColor};\n-  font-style: ${(props) =>\n-    props.fontStyle?.includes(FontStyleTypes.ITALIC) ? \"italic\" : \"\"};\n-  text-decoration: ${(props) =>\n-    props.fontStyle?.includes(FontStyleTypes.UNDERLINE) && props.isTextType\n-      ? \"underline\"\n-      : \"\"};\n-  justify-content: ${(props) =>\n-    props.horizontalAlignment && JUSTIFY_CONTENT[props.horizontalAlignment]};\n-  text-align: ${(props) =>\n-    props.horizontalAlignment && TEXT_ALIGN[props.horizontalAlignment]};\n-  align-items: ${(props) =>\n-    props.verticalAlignment && ALIGN_ITEMS[props.verticalAlignment]};\n-\n-  background: ${(props) => {\n-    if (props.isCellDisabled) {\n-      return props.cellBackground\n-        ? lightenColor(props.cellBackground)\n-        : \"var(--wds-color-bg-disabled)\";\n-    } else {\n-      return props.cellBackground;\n-    }\n-  }};\n-\n-  &:hover,\n-  .selected-row & {\n-    background: ${(props) =>\n-      props.cellBackground && !props.isCellDisabled\n-        ? darkenColor(props.cellBackground, 5)\n-        : \"\"};\n-  }\n-  font-size: ${(props) => props.textSize};\n-\n-  padding: ${(props) =>\n-    props.disablePadding\n-      ? 0\n-      : `${\n-          props.compactMode\n-            ? `${TABLE_SIZES[props.compactMode].VERTICAL_PADDING}px 10px`\n-            : `${0}px 10px`\n-        }`};\n-  line-height: ${CELL_WRAPPER_LINE_HEIGHT}px;\n-  .${Classes.POPOVER_WRAPPER} {\n-    width: 100%;\n-    overflow: hidden;\n-    text-overflow: ellipsis;\n-  }\n-  ${(props) =>\n-    props.allowCellWrapping\n-      ? `\n-        white-space: break-spaces;\n-        word-break: break-word;\n-      `\n-      : `\n-      overflow: hidden;\n-      text-overflow: ellipsis;\n-      white-space: nowrap;`}\n-  .image-cell-wrapper {\n-    width: 100%;\n-    height: 100%;\n-    display: flex;\n-    align-items: ${(props) =>\n-      props.verticalAlignment && IMAGE_VERTICAL_ALIGN[props.verticalAlignment]};\n-    justify-content: ${(props) =>\n-      props.horizontalAlignment &&\n-      IMAGE_HORIZONTAL_ALIGN[props.horizontalAlignment]};\n-  }\n-  .image-cell {\n-    height: ${(props) =>\n-      props.imageSize ? ImageSizes[props.imageSize] : ImageSizes.DEFAULT};\n-    margin: 0 5px 0 0;\n-    ${BORDER_RADIUS}\n-    object-fit: contain;\n-  }\n-  video {\n-    ${BORDER_RADIUS}\n-  }\n-  ${(props) =>\n-    props.isHyperLink &&\n-    `\n-    cursor: pointer;\n-    &:hover {\n-      color: ${Colors.ROYAL_BLUE};\n-      text-decoration: underline;\n-    }`};\n-  &.video-cell {\n-    height: 100%;\n-    iframe {\n-      border: none;\n-      ${BORDER_RADIUS}\n-    }\n-  }\n-  .link-text {\n-    width: 100%;\n-    overflow: hidden;\n-    text-overflow: ellipsis;\n-    word-break: break-word;\n-    text-align: ${(props) =>\n-      props.horizontalAlignment && TEXT_ALIGN[props.horizontalAlignment]};\n-  }\n-  .hidden-icon {\n-    display: none;\n-  }\n-  &:hover {\n-    .hidden-icon {\n-      display: inline;\n-    }\n-  }\n-`;\n-\n-export const CellCheckboxWrapper = styled(CellWrapper)<{\n-  isChecked?: boolean;\n-  accentColor?: string;\n-  borderRadius?: string;\n-}>`\n-  left: 0;\n-  z-index: ${Layers.modalWidget};\n-  justify-content: center;\n-  width: ${MULTISELECT_CHECKBOX_WIDTH}px;\n-  height: auto;\n-  & > div {\n-    border-radius: ${({ borderRadius }) => borderRadius};\n-\n-    ${(props) =>\n-      props.isChecked\n-        ? `\n-          background: ${props.accentColor};\n-          &:hover {\n-            background: ${darkenColor(props.accentColor)};\n-          }\n-            `\n-        : `\n-          border: 1px solid ${Colors.GREY_3};\n-          &:hover {\n-            border: 1px solid ${Colors.GREY_5};\n-          }\n-        `};\n-  }\n-`;\n-\n-export const CellCheckbox = styled.div`\n-  height: 14px;\n-  width: 14px;\n-  background: ${Colors.WHITE};\n-  cursor: pointer;\n-  position: relative;\n-  .th-svg {\n-    display: block;\n-    position: absolute;\n-    left: 2px;\n-    top: 2px;\n-  }\n-`;\n-\n-const MIN_WIDTH_TO_SHOW_PAGE_ITEMS = 700;\n-\n-export const TableHeaderWrapper = styled.div<{\n-  serverSidePaginationEnabled: boolean;\n-  width: number;\n-  tableSizes: TableSizes;\n-  backgroundColor?: Color;\n-}>`\n-  position: relative;\n-  display: flex;\n-  width: 100%;\n-  .show-page-items {\n-    display: ${(props) =>\n-      props.width < MIN_WIDTH_TO_SHOW_PAGE_ITEMS ? \"none\" : \"flex\"};\n-  }\n-  height: ${(props) => props.tableSizes.TABLE_HEADER_HEIGHT}px;\n-  min-height: ${(props) => props.tableSizes.TABLE_HEADER_HEIGHT}px;\n-`;\n-\n-export const TableHeaderInnerWrapper = styled.div<{\n-  serverSidePaginationEnabled: boolean;\n-  width: number;\n-  tableSizes: TableSizes;\n-  backgroundColor?: Color;\n-  variant?: TableVariant;\n-}>`\n-  position: relative;\n-  display: flex;\n-  width: 100%;\n-  height: 100%;\n-  border-bottom: ${(props) =>\n-    props.variant !== \"VARIANT2\" &&\n-    `1px solid var(--wds-color-border-onaccent)`};\n-`;\n-\n-export const CommonFunctionsMenuWrapper = styled.div<{\n-  tableSizes: TableSizes;\n-}>`\n-  display: flex;\n-  align-items: center;\n-  height: 100%;\n-\n-  & .bp3-popover-target,\n-  & .bp3-popover-wrapper {\n-    height: 100%;\n-  }\n-\n-  & .bp3-popover-target {\n-    display: flex;\n-    align-items: center;\n-  }\n-`;\n-\n-export const TableHeaderContentWrapper = styled.div`\n-  display: flex;\n-  align-items: center;\n-  justify-content: center;\n-  font-size: ${HEADER_CONTROL_FONT_SIZE};\n-  line-height: 20px;\n-  color: ${Colors.GRAY};\n-  margin: 0 4px;\n-  white-space: nowrap;\n-`;\n-\n-export const TableIconWrapper = styled.div<{\n-  selected?: boolean;\n-  disabled?: boolean;\n-}>`\n-  background: ${(props) =>\n-    props.selected ? Colors.ATHENS_GRAY : \"transparent\"};\n-  box-shadow: ${(props) =>\n-    props.selected ? `inset 0px 4px 0px ${Colors.GREEN}` : \"none\"};\n-  width: 48px;\n-  height: 38px;\n-  display: flex;\n-  align-items: center;\n-  justify-content: center;\n-  ${(props) => (props.disabled ? invisible : \"\")};\n-  cursor: ${(props) => !props.disabled && \"pointer\"};\n-  position: relative;\n-  &:hover {\n-    background: ${Colors.ATHENS_GRAY};\n-  }\n-`;\n-\n-export const RenderOptionWrapper = styled.div<{ selected: boolean }>`\n-  display: flex;\n-  justify-content: space-between;\n-  align-items: center;\n-  width: 150px;\n-  position: relative;\n-  .title {\n-    color: ${Colors.GREY_10};\n-    width: 120px;\n-    white-space: nowrap;\n-    overflow: hidden;\n-    text-overflow: ellipsis;\n-  }\n-  .type {\n-    position: absolute;\n-    left: 135px;\n-    font-size: ${HEADER_CONTROL_FONT_SIZE} !important;\n-    color: ${Colors.GREY_10};\n-  }\n-`;\n-\n-export const MenuCategoryWrapper = styled.div`\n-  display: flex;\n-  width: 100%;\n-  align-items: center;\n-  justify-content: space-between;\n-  color: ${Colors.RIVER_BED};\n-`;\n-\n-export const MenuStyledOptionHeader = styled.div`\n-  font-weight: 600;\n-`;\n-\n-export const TooltipContentWrapper = styled.div<{ width?: number }>`\n-  word-break: break-all;\n-  max-width: ${(props) => props.width}px;\n-`;\n-\n-export const EmptyRow = styled.div`\n-  display: flex;\n-  flex: 1 0 auto;\n-`;\n-\n-export const EmptyCell = styled.div<{ width: number; sticky?: string }>`\n-  width: ${(props) => props.width}px;\n-  boxsizing: border-box;\n-  flex: ${(props) => props.width} 0 auto;\n-  z-index: ${(props) => (props.sticky ? Layers.dragPreview : 0)};\n-`;\n+      font-weight:\n\\ No newline at end of file\n",
    "pr_number": 41370,
    "title": "fix: make horizontal scroll bar thicker on tables",
    "test_files": [
      "app/client/src/widgets/TableWidgetV2/component/TableContext.test.tsx"
    ],
    "code_files": [
      "app/client/cypress/e2e/Regression/ClientSide/Widgets/TableV2/scrollbar_spec.ts",
      "app/client/src/widgets/TableWidgetV2/component/Constants.ts",
      "app/client/src/widgets/TableWidgetV2/component/TableStyledWrappers.tsx"
    ]
  },
  {
    "instance_id": "hoppscotch__hoppscotch.main.5533",
    "repo": "hoppscotch/hoppscotch",
    "base_commit": "98f07f8a4c002926e24676af45067d911b589b58",
    "bug_patch": "diff --git a/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts b/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts\nindex 4f8c974..67c7f59 100644\n--- a/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts\n+++ b/packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts\n@@ -471,85 +471,4 @@ describe(\"WorkspaceService\", () => {\n       service = container.bind(WorkspaceService)\n     })\n \n-    it(\"should return false when newWorkspace is undefined\", () => {\n-      const result = (service as any).areWorkspacesEqual(undefined, {\n-        type: \"personal\",\n-      })\n-      expect(result).toBe(false)\n-    })\n-\n-    it(\"should return false when oldWorkspace is undefined\", () => {\n-      const result = (service as any).areWorkspacesEqual(\n-        { type: \"personal\" },\n-        undefined\n-      )\n-      expect(result).toBe(false)\n-    })\n-\n-    it(\"should return true when both workspaces are personal\", () => {\n-      const result = (service as any).areWorkspacesEqual(\n-        { type: \"personal\" },\n-        { type: \"personal\" }\n-      )\n-      expect(result).toBe(true)\n-    })\n-\n-    it(\"should return true when both workspaces are team workspaces with same teamID\", () => {\n-      const workspace1 = {\n-        type: \"team\",\n-        teamID: \"team-123\",\n-        teamName: \"Team A\",\n-        role: null,\n-      }\n-      const workspace2 = {\n-        type: \"team\",\n-        teamID: \"team-123\",\n-        teamName: \"Team A Updated\",\n-        role: null,\n-      }\n-\n-      const result = (service as any).areWorkspacesEqual(workspace1, workspace2)\n-      expect(result).toBe(true)\n-    })\n-\n-    it(\"should return false when team workspaces have different teamIDs\", () => {\n-      const workspace1 = {\n-        type: \"team\",\n-        teamID: \"team-123\",\n-        teamName: \"Team A\",\n-        role: null,\n-      }\n-      const workspace2 = {\n-        type: \"team\",\n-        teamID: \"team-456\",\n-        teamName: \"Team B\",\n-        role: null,\n-      }\n-\n-      const result = (service as any).areWorkspacesEqual(workspace1, workspace2)\n-      expect(result).toBe(false)\n-    })\n-\n-    it(\"should return false when one is personal and other is team workspace\", () => {\n-      const personalWorkspace = { type: \"personal\" }\n-      const teamWorkspace = {\n-        type: \"team\",\n-        teamID: \"team-123\",\n-        teamName: \"Team A\",\n-        role: null,\n-      }\n-\n-      const result1 = (service as any).areWorkspacesEqual(\n-        personalWorkspace,\n-        teamWorkspace\n-      )\n-      const result2 = (service as any).areWorkspacesEqual(\n-        teamWorkspace,\n-        personalWorkspace\n-      )\n-\n-      expect(result1).toBe(false)\n-      expect(result2).toBe(false)\n-    })\n-  })\n-})\n+    it(\"should return false when newWorkspace is undefined\", () => {\n\\ No newline at end of file\ndiff --git a/packages/hoppscotch-common/src/services/team-collection.service.ts b/packages/hoppscotch-common/src/services/team-collection.service.ts\nindex dd47b04..ae639c5 100644\n--- a/packages/hoppscotch-common/src/services/team-collection.service.ts\n+++ b/packages/hoppscotch-common/src/services/team-collection.service.ts\n@@ -31,6 +31,7 @@ import { TeamCollection } from \"~/helpers/teams/TeamCollection\"\n import { TeamRequest } from \"~/helpers/teams/TeamRequest\"\n import { runGQLQuery, runGQLSubscription } from \"~/helpers/backend/GQLClient\"\n import { HoppInheritedProperty } from \"~/helpers/types/HoppInheritedProperties\"\n+import { WorkspaceService } from \"./workspace.service\"\n import { ref, watch } from \"vue\"\n import { Service } from \"dioc\"\n import { updateInheritedPropertiesForAffectedRequests } from \"~/helpers/collection/collection\"\n@@ -138,6 +139,8 @@ export class TeamCollectionsService extends Service<void> {\n   private secretEnvironmentService = this.bind(SecretEnvironmentService)\n   private currentEnvironmentValueService = this.bind(CurrentValueService)\n \n+  private workspaceService = this.bind(WorkspaceService)\n+\n   private teamID: string | null = null\n \n   public collections = ref<TeamCollection[]>([])\n@@ -173,13 +176,20 @@ export class TeamCollectionsService extends Service<void> {\n   private teamChildCollectionSortedSub: WSubscription | null = null\n \n   override onServiceInit() {\n-    this.collectionLoadingWatcher()\n-  }\n+    // Watch for team change and update the collections accordingly\n+    watch(\n+      () => this.workspaceService.currentWorkspace,\n+      (workspace) => {\n+        if (workspace.value.type === \"team\" && workspace.value.teamID) {\n+          this.changeTeamID(workspace.value.teamID)\n+        } else {\n+          this.clearCollections()\n+        }\n+      },\n+      { immediate: true, deep: true }\n+    )\n \n-  /**\n-   * Watches for loading collections and updates inherited properties once loading is done\n-   */\n-  private collectionLoadingWatcher() {\n+    // Watch for completion of loading (when all loading flags are cleared) to update inherited properties once\n     watch(\n       () => this.loadingCollections.value.length,\n       (loadingCount) => {\n@@ -198,11 +208,7 @@ export class TeamCollectionsService extends Service<void> {\n     )\n   }\n \n-  /**\n-   * Change the current team ID and resets the collections\n-   * @param newTeamID The new team ID to switch to\n-   */\n-  public changeTeamID(newTeamID: string | null) {\n+  changeTeamID(newTeamID: string | null) {\n     this.teamID = newTeamID\n     this.collections.value = []\n     this.entityIDs.clear()\n@@ -214,17 +220,6 @@ export class TeamCollectionsService extends Service<void> {\n     if (this.teamID) this.initialize()\n   }\n \n-  /**\n-   * Clears all collections and resets the service state\n-   */\n-  public clearCollections() {\n-    this.collections.value = []\n-    this.entityIDs.clear()\n-    this.loadingCollections.value = []\n-    this.unsubscribeSubscriptions()\n-    this.teamID = null\n-  }\n-\n   /**\n    * Unsubscribes from the subscriptions\n    * NOTE: Once this is called, no new updates to the tree will be detected\n@@ -297,6 +292,14 @@ export class TeamCollectionsService extends Service<void> {\n     this.collections.value = tree\n   }\n \n+  private clearCollections() {\n+    this.collections.value = []\n+    this.entityIDs.clear()\n+    this.loadingCollections.value = []\n+    this.unsubscribeSubscriptions()\n+    this.teamID = null\n+  }\n+\n   /**\n    * Loads the root collections of the current team\n    * @param replace Whether to replace the existing collections or append to them\n@@ -441,861 +444,4 @@ export class TeamCollectionsService extends Service<void> {\n   ) {\n     const tree = this.collections.value\n \n-    // Find request, if not present, don't update\n-    const req = findReqInTree(tree, requestUpdate.id)\n-    if (!req) return\n-\n-    Object.assign(req, requestUpdate)\n-\n-    this.collections.value = tree\n-  }\n-\n-  /**\n-   * Removes a request from the tree\n-   *\n-   * @param {string} requestID - ID of the request to remove\n-   */\n-  private removeRequest(requestID: string) {\n-    const tree = this.collections.value\n-\n-    // Find request in tree, don't attempt if no collection or no requests (expansion?)\n-    const coll = findCollWithReqIDInTree(tree, requestID)\n-    if (!coll || !coll.requests) return\n-\n-    // Remove the collection\n-    remove(coll.requests, (req: any) => req.id === requestID)\n-\n-    // Remove from entityIDs set\n-    this.entityIDs.delete(`request-${requestID}`)\n-\n-    // Publish new tree\n-    this.collections.value = tree\n-  }\n-\n-  /**\n-   * Moves a request from one collection to another\n-   *\n-   * @param {string} request - The request to move\n-   */\n-  private async moveRequest(request: TeamRequest) {\n-    const tree = this.collections.value\n-\n-    // Remove the request from the current collection\n-    this.removeRequest(request.id)\n-\n-    const currentRequest = request.request\n-\n-    if (currentRequest === null || currentRequest === undefined) return\n-\n-    // Find request in tree, don't attempt if no collection or no requests is found\n-    const collection = findCollInTree(tree, request.collectionID)\n-    if (!collection) return // Ignore add request\n-\n-    // Collection is not expanded\n-    if (!collection.requests) return\n-\n-    this.addRequest({\n-      id: request.id,\n-      collectionID: request.collectionID,\n-      request: translateToNewRequest(request.request),\n-      title: request.title,\n-    })\n-  }\n-\n-  /**\n-   * Moves a collection from one collection to another or to root\n-   *\n-   * @param {string} collectionID - The ID of the collection to move\n-   */\n-  private async moveCollection(\n-    collectionID: string,\n-    parentID: string | null,\n-    title: string,\n-    data?: string | null\n-  ) {\n-    // Remove the collection from the current position\n-    this.removeCollection(collectionID)\n-\n-    if (collectionID === null || parentID === undefined) return\n-\n-    // Expand the parent collection if it is not expanded\n-    // so that the old children is also visible when expanding\n-    if (parentID) this.expandCollection(parentID)\n-\n-    this.addCollection(\n-      {\n-        id: collectionID,\n-        children: null,\n-        requests: null,\n-        title: title,\n-        data,\n-      },\n-      parentID ?? null\n-    )\n-  }\n-\n-  private reorderItems = (array: unknown[], from: number, to: number) => {\n-    const item = array.splice(from, 1)[0]\n-    if (from < to) {\n-      array.splice(to - 1, 0, item)\n-    } else {\n-      array.splice(to, 0, item)\n-    }\n-  }\n-\n-  public updateRequestOrder(\n-    dragedRequestID: string,\n-    destinationRequestID: string | null,\n-    destinationCollectionID: string\n-  ) {\n-    const tree = this.collections.value\n-\n-    // If the destination request is null, then it is the last request in the collection\n-    if (destinationRequestID === null) {\n-      const collection = findCollInTree(tree, destinationCollectionID)\n-\n-      if (!collection) return // Ignore order update\n-\n-      // Collection is not expanded\n-      if (!collection.requests) return\n-\n-      const requestIndex = collection.requests.findIndex(\n-        (req) => req.id === dragedRequestID\n-      )\n-\n-      // If the collection index is not found, don't update\n-      if (requestIndex === -1) return\n-\n-      // Move the request to the end of the requests\n-      collection.requests.push(collection.requests.splice(requestIndex, 1)[0])\n-    } else {\n-      // Find collection in tree, don't attempt if no collection is found\n-      const collection = findCollInTree(tree, destinationCollectionID)\n-      if (!collection) return // Ignore order update\n-\n-      // Collection is not expanded\n-      if (!collection.requests) return\n-\n-      const requestIndex = collection.requests.findIndex(\n-        (req) => req.id === dragedRequestID\n-      )\n-      const destinationIndex = collection.requests.findIndex(\n-        (req) => req.id === destinationRequestID\n-      )\n-\n-      if (requestIndex === -1) return\n-\n-      this.reorderItems(collection.requests, requestIndex, destinationIndex)\n-    }\n-\n-    this.collections.value = tree\n-  }\n-\n-  public updateCollectionOrder = (\n-    collectionID: string,\n-    destinationCollectionID: string | null\n-  ) => {\n-    const tree = this.collections.value\n-\n-    // If the destination collection is null, then it is the last collection in the tree\n-    if (destinationCollectionID === null) {\n-      const collLast = findParentOfColl(tree, collectionID)\n-      if (collLast && collLast.children) {\n-        const collectionIndex = collLast.children.findIndex(\n-          (coll) => coll.id === collectionID\n-        )\n-\n-        // reorder the collection to the end of the collections\n-        collLast.children.push(collLast.children.splice(collectionIndex, 1)[0])\n-      } else {\n-        const collectionIndex = tree.findIndex(\n-          (coll) => coll.id === collectionID\n-        )\n-\n-        // If the collection index is not found, don't update\n-        if (collectionIndex === -1) return\n-\n-        // reorder the collection to the end of the collections in the root\n-        tree.push(tree.splice(collectionIndex, 1)[0])\n-      }\n-    } else {\n-      // Find collection in tree\n-      const coll = findParentOfColl(tree, destinationCollectionID)\n-\n-      // If the collection has a parent collection and check if it has children\n-      if (coll && coll.children) {\n-        const collectionIndex = coll.children.findIndex(\n-          (coll) => coll.id === collectionID\n-        )\n-\n-        const destinationIndex = coll.children.findIndex(\n-          (coll) => coll.id === destinationCollectionID\n-        )\n-\n-        // If the collection index is not found, don't update\n-        if (collectionIndex === -1) return\n-\n-        this.reorderItems(coll.children, collectionIndex, destinationIndex)\n-      } else {\n-        // If the collection has no parent collection, it is a root collection\n-        const collectionIndex = tree.findIndex(\n-          (coll) => coll.id === collectionID\n-        )\n-\n-        const destinationIndex = tree.findIndex(\n-          (coll) => coll.id === destinationCollectionID\n-        )\n-\n-        // If the collection index is not found, don't update\n-        if (collectionIndex === -1) return\n-\n-        this.reorderItems(tree, collectionIndex, destinationIndex)\n-      }\n-    }\n-\n-    this.collections.value = tree\n-  }\n-\n-  private registerSubscriptions() {\n-    if (!this.teamID) return\n-\n-    const [teamCollAdded$, teamCollAddedSub] = runGQLSubscription({\n-      query: TeamCollectionAddedDocument,\n-      variables: {\n-        teamID: this.teamID,\n-      },\n-    })\n-\n-    this.teamCollectionAddedSub = teamCollAddedSub\n-\n-    this.teamCollectionAdded$ = teamCollAdded$.subscribe((result: any) => {\n-      if (E.isLeft(result))\n-        throw new Error(\n-          `Team Collection Added Error: ${JSON.stringify(result.left)}`\n-        )\n-\n-      this.addCollection(\n-        {\n-          id: result.right.teamCollectionAdded.id,\n-          children: null,\n-          requests: null,\n-          title: result.right.teamCollectionAdded.title,\n-          data: result.right.teamCollectionAdded.data ?? null,\n-        },\n-        result.right.teamCollectionAdded.parent?.id ?? null\n-      )\n-    })\n-\n-    const [teamCollUpdated$, teamCollUpdatedSub] = runGQLSubscription({\n-      query: TeamCollectionUpdatedDocument,\n-      variables: {\n-        teamID: this.teamID,\n-      },\n-    })\n-\n-    this.teamCollectionUpdatedSub = teamCollUpdatedSub\n-    this.teamCollectionUpdated$ = teamCollUpdated$.subscribe((result: any) => {\n-      if (E.isLeft(result))\n-        throw new Error(\n-          `Team Collection Updated Error: ${JSON.stringify(result.left)}`\n-        )\n-\n-      this.updateCollection({\n-        id: result.right.teamCollectionUpdated.id,\n-        title: result.right.teamCollectionUpdated.title,\n-        data: result.right.teamCollectionUpdated.data,\n-      })\n-\n-      this.loadingCollections.value = this.loadingCollections.value.filter(\n-        (x) => x !== result.right.teamCollectionUpdated.id\n-      )\n-    })\n-\n-    const [teamCollRemoved$, teamCollRemovedSub] = runGQLSubscription({\n-      query: TeamCollectionRemovedDocument,\n-      variables: {\n-        teamID: this.teamID,\n-      },\n-    })\n-\n-    this.teamCollectionRemovedSub = teamCollRemovedSub\n-    this.teamCollectionRemoved$ = teamCollRemoved$.subscribe((result: any) => {\n-      if (E.isLeft(result))\n-        throw new Error(\n-          `Team Collection Removed Error: ${JSON.stringify(result.left)}`\n-        )\n-\n-      this.removeCollection(result.right.teamCollectionRemoved)\n-    })\n-\n-    const [teamReqAdded$, teamReqAddedSub] = runGQLSubscription({\n-      query: TeamRequestAddedDocument,\n-      variables: {\n-        teamID: this.teamID,\n-      },\n-    })\n-\n-    this.teamRequestAddedSub = teamReqAddedSub\n-    this.teamRequestAdded$ = teamReqAdded$.subscribe((result: any) => {\n-      if (E.isLeft(result))\n-        throw new Error(\n-          `Team Request Added Error: ${JSON.stringify(result.left)}`\n-        )\n-\n-      this.addRequest({\n-        id: result.right.teamRequestAdded.id,\n-        collectionID: result.right.teamRequestAdded.collectionID,\n-        request: translateToNewRequest(\n-          JSON.parse(result.right.teamRequestAdded.request)\n-        ),\n-        title: result.right.teamRequestAdded.title,\n-      })\n-    })\n-\n-    const [teamReqUpdated$, teamReqUpdatedSub] = runGQLSubscription({\n-      query: TeamRequestUpdatedDocument,\n-      variables: {\n-        teamID: this.teamID,\n-      },\n-    })\n-\n-    this.teamRequestUpdatedSub = teamReqUpdatedSub\n-    this.teamRequestUpdated$ = teamReqUpdated$.subscribe((result: any) => {\n-      if (E.isLeft(result))\n-        throw new Error(\n-          `Team Request Updated Error: ${JSON.stringify(result.left)}`\n-        )\n-\n-      this.updateRequest({\n-        id: result.right.teamRequestUpdated.id,\n-        collectionID: result.right.teamRequestUpdated.collectionID,\n-        request: JSON.parse(result.right.teamRequestUpdated.request),\n-        title: result.right.teamRequestUpdated.title,\n-      })\n-    })\n-\n-    const [teamReqDeleted$, teamReqDeletedSub] = runGQLSubscription({\n-      query: TeamRequestDeletedDocument,\n-      variables: {\n-        teamID: this.teamID,\n-      },\n-    })\n-\n-    this.teamRequestDeletedSub = teamReqDeletedSub\n-    this.teamRequestDeleted$ = teamReqDeleted$.subscribe((result: any) => {\n-      if (E.isLeft(result))\n-        throw new Error(\n-          `Team Request Deleted Error ${JSON.stringify(result.left)}`\n-        )\n-\n-      this.removeRequest(result.right.teamRequestDeleted)\n-    })\n-\n-    const [teamRequestMoved$, teamRequestMovedSub] = runGQLSubscription({\n-      query: TeamRequestMovedDocument,\n-      variables: {\n-        teamID: this.teamID,\n-      },\n-    })\n-\n-    this.teamRequestMovedSub = teamRequestMovedSub\n-    this.teamRequestMoved$ = teamRequestMoved$.subscribe((result: any) => {\n-      if (E.isLeft(result))\n-        throw new Error(\n-          `Team Request Move Error ${JSON.stringify(result.left)}`\n-        )\n-\n-      const { requestMoved } = result.right\n-\n-      const request = {\n-        id: requestMoved.id,\n-        collectionID: requestMoved.collectionID,\n-        title: requestMoved.title,\n-        request: JSON.parse(requestMoved.request),\n-      }\n-\n-      this.moveRequest(request)\n-    })\n-\n-    const [teamCollectionMoved$, teamCollectionMovedSub] = runGQLSubscription({\n-      query: TeamCollectionMovedDocument,\n-      variables: {\n-        teamID: this.teamID,\n-      },\n-    })\n-\n-    this.teamCollectionMovedSub = teamCollectionMovedSub\n-    this.teamCollectionMoved$ = teamCollectionMoved$.subscribe(\n-      (result: any) => {\n-        if (E.isLeft(result))\n-          throw new Error(\n-            `Team Collection Move Error ${JSON.stringify(result.left)}`\n-          )\n-\n-        const { teamCollectionMoved } = result.right\n-        const { id, parent, title, data } = teamCollectionMoved\n-\n-        const parentID = parent?.id ?? null\n-\n-        this.moveCollection(id, parentID, title, data)\n-      }\n-    )\n-\n-    const [teamRequestOrderUpdated$, teamRequestOrderUpdatedSub] =\n-      runGQLSubscription({\n-        query: TeamRequestOrderUpdatedDocument,\n-        variables: {\n-          teamID: this.teamID,\n-        },\n-      })\n-\n-    this.teamRequestOrderUpdatedSub = teamRequestOrderUpdatedSub\n-    this.teamRequestOrderUpdated$ = teamRequestOrderUpdated$.subscribe(\n-      (result: any) => {\n-        if (E.isLeft(result))\n-          throw new Error(\n-            `Team Request Order Update Error ${JSON.stringify(result.left)}`\n-          )\n-\n-        const { requestOrderUpdated } = result.right\n-        const { request } = requestOrderUpdated\n-        const { nextRequest } = requestOrderUpdated\n-\n-        this.updateRequestOrder(\n-          request.id,\n-          nextRequest ? nextRequest.id : null,\n-          nextRequest ? nextRequest.collectionID : request.collectionID\n-        )\n-      }\n-    )\n-\n-    const [teamCollectionOrderUpdated$, teamCollectionOrderUpdatedSub] =\n-      runGQLSubscription({\n-        query: TeamCollectionOrderUpdatedDocument,\n-        variables: {\n-          teamID: this.teamID,\n-        },\n-      })\n-\n-    this.teamCollectionOrderUpdatedSub = teamCollectionOrderUpdatedSub\n-    this.teamCollectionOrderUpdated$ = teamCollectionOrderUpdated$.subscribe(\n-      (result: any) => {\n-        if (E.isLeft(result))\n-          throw new Error(\n-            `Team Collection Order Update Error ${JSON.stringify(result.left)}`\n-          )\n-\n-        const { collectionOrderUpdated } = result.right\n-        const { collection } = collectionOrderUpdated\n-        const { nextCollection } = collectionOrderUpdated\n-\n-        this.updateCollectionOrder(\n-          collection.id,\n-          nextCollection ? nextCollection.id : null\n-        )\n-      }\n-    )\n-\n-    const [teamRootCollectionSorted$, teamRootCollectionSortedSub] =\n-      runGQLSubscription({\n-        query: TeamRootCollectionsSortedDocument,\n-        variables: {\n-          teamID: this.teamID,\n-        },\n-      })\n-\n-    this.teamRootCollectionSortedSub = teamRootCollectionSortedSub\n-    this.teamRootCollectionSorted$ = teamRootCollectionSorted$.subscribe(\n-      (result: any) => {\n-        if (E.isLeft(result))\n-          throw new Error(\n-            `Team Root Collection Sorted Error ${JSON.stringify(result.left)}`\n-          )\n-\n-        this.loadRootCollections(true)\n-      }\n-    )\n-\n-    const [teamChildCollectionSorted$, teamChildCollectionSortedSub] =\n-      runGQLSubscription({\n-        query: TeamChildCollectionSortedDocument,\n-        variables: {\n-          teamID: this.teamID,\n-        },\n-      })\n-\n-    this.teamChildCollectionSortedSub = teamChildCollectionSortedSub\n-    this.teamChildCollectionSorted$ = teamChildCollectionSorted$.subscribe(\n-      (result: any) => {\n-        if (E.isLeft(result))\n-          throw new Error(\n-            `Team Child Collection Sorted Error ${JSON.stringify(result.left)}`\n-          )\n-\n-        const { teamChildCollectionsSorted } = result.right\n-\n-        if (teamChildCollectionsSorted) {\n-          this.expandCollection(teamChildCollectionsSorted, true)\n-        }\n-      }\n-    )\n-  }\n-\n-  private async getCollectionChildren(\n-    collection: TeamCollection\n-  ): Promise<TeamCollection[]> {\n-    const collections: TeamCollection[] = []\n-\n-    while (true) {\n-      const data = await runGQLQuery({\n-        query: GetCollectionChildrenDocument,\n-        variables: {\n-          collectionID: collection.id,\n-          cursor:\n-            collections.length > 0\n-              ? collections[collections.length - 1].id\n-              : undefined,\n-        },\n-      })\n-\n-      if (E.isLeft(data)) {\n-        throw new Error(\n-          `Child Collection Fetch Error for ${collection.id}: ${data.left}`\n-        )\n-      }\n-\n-      collections.push(\n-        ...data.right.collection!.children.map(\n-          (el: any) =>\n-            <TeamCollection>{\n-              id: el.id,\n-              title: el.title,\n-              data: el.data,\n-              children: null,\n-              requests: null,\n-            }\n-        )\n-      )\n-\n-      if (data.right.collection!.children.length !== TEAMS_BACKEND_PAGE_SIZE)\n-        break\n-    }\n-\n-    return collections\n-  }\n-\n-  private async getCollectionRequests(\n-    collection: TeamCollection\n-  ): Promise<TeamRequest[]> {\n-    const requests: TeamRequest[] = []\n-\n-    while (true) {\n-      const data = await runGQLQuery({\n-        query: GetCollectionRequestsDocument,\n-        variables: {\n-          collectionID: collection.id,\n-          cursor:\n-            requests.length > 0 ? requests[requests.length - 1].id : undefined,\n-        },\n-      })\n-\n-      if (E.isLeft(data)) {\n-        throw new Error(`Child Request Fetch Error for ${data}: ${data.left}`)\n-      }\n-\n-      requests.push(\n-        ...data.right.requestsInCollection.map<TeamRequest>((el: any) => {\n-          return {\n-            id: el.id,\n-            collectionID: collection.id,\n-            title: el.title,\n-            request: translateToNewRequest(JSON.parse(el.request)),\n-          }\n-        })\n-      )\n-\n-      if (data.right.requestsInCollection.length !== TEAMS_BACKEND_PAGE_SIZE)\n-        break\n-    }\n-\n-    return requests\n-  }\n-\n-  /**\n-   * Expands a collection on the tree\n-   *\n-   * When a collection is loaded initially in the adapter, children and requests are not loaded (they will be set to null)\n-   * Upon expansion those two fields will be populated\n-   *\n-   * @param {string} collectionID - The ID of the collection to expand\n-   * @param {boolean} reFetch - Whether to re-fetch the children and requests even if they are already loaded (used in sorting scenarios where order might have changed)\n-   */\n-  async expandCollection(collectionID: string, reFetch = false): Promise<void> {\n-    if (this.loadingCollections.value.includes(collectionID)) return\n-\n-    const tree = this.collections.value\n-\n-    const collection = findCollInTree(tree, collectionID)\n-\n-    if (!collection) return\n-\n-    if (collection.children !== null && !reFetch) return\n-\n-    this.loadingCollections.value.push(collectionID)\n-\n-    try {\n-      const [collections, requests] = await Promise.all([\n-        this.getCollectionChildren(collection),\n-        this.getCollectionRequests(collection),\n-      ])\n-\n-      collection.children = collections\n-      collection.requests = requests\n-\n-      // Add to the entity ids set\n-      collections.forEach((coll) => this.entityIDs.add(`collection-${coll.id}`))\n-      requests.forEach((req) => this.entityIDs.add(`request-${req.id}`))\n-\n-      this.collections.value = [...tree]\n-    } catch (error) {\n-      console.error(`Error expanding collection ${collectionID}:`, error)\n-\n-      // Set empty arrays instead of leaving as null to prevent future expansion attempts\n-      // This prevents the infinite loop by ensuring the collection is marked as expanded\n-      collection.children = []\n-      collection.requests = []\n-\n-      this.collections.value = [...tree]\n-    } finally {\n-      this.loadingCollections.value = this.loadingCollections.value.filter(\n-        (x) => x !== collectionID\n-      )\n-    }\n-  }\n-\n-  private getCurrentValue = (\n-    env: HoppCollectionVariable,\n-    varIndex: number,\n-    collectionID: string\n-  ) => {\n-    if (env && env.secret) {\n-      return this.secretEnvironmentService.getSecretEnvironmentVariable(\n-        collectionID,\n-        varIndex\n-      )?.value\n-    }\n-    return this.currentEnvironmentValueService.getEnvironmentVariable(\n-      collectionID,\n-      varIndex\n-    )?.currentValue\n-  }\n-\n-  /**\n-   * This function populates the values of the variables with the current values or secrets.\n-   * @param variables Variables to populate\n-   * @returns Populated variables with current values or secrets\n-   */\n-  private populateValues(\n-    variables: HoppCollectionVariable[],\n-    parentID: string\n-  ) {\n-    return variables.map((v, index) => ({\n-      ...v,\n-      currentValue: this.getCurrentValue(v, index, parentID) ?? v.currentValue,\n-    }))\n-  }\n-\n-  /**\n-   * Used to obtain the inherited auth and headers for a given folder path, used for both REST and GraphQL team collections\n-   * @param folderPath the path of the folder to cascade the auth from\n-   * @returns the inherited auth and headers for the given folder path\n-   */\n-  public cascadeParentCollectionForProperties(folderPath: string) {\n-    let auth: HoppInheritedProperty[\"auth\"] = {\n-      parentID: folderPath ?? \"\",\n-      parentName: \"\",\n-      inheritedAuth: {\n-        authType: \"none\",\n-        authActive: true,\n-      },\n-    }\n-    const headers: HoppInheritedProperty[\"headers\"] = []\n-\n-    const variables: HoppInheritedProperty[\"variables\"] = []\n-\n-    if (!folderPath) return { auth, headers, variables }\n-\n-    const path = folderPath.split(\"/\")\n-\n-    // Check if the path is empty or invalid\n-    if (!path || path.length === 0) {\n-      console.error(\"Invalid path:\", folderPath)\n-      return { auth, headers, variables }\n-    }\n-\n-    // Loop through the path and get the last parent folder with authType other than 'inherit'\n-    for (let i = 0; i < path.length; i++) {\n-      const parentFolder = findCollInTree(this.collections.value, path[i])\n-\n-      // Check if parentFolder is undefined or null\n-      if (!parentFolder) {\n-        console.error(\"Parent folder not found for path:\", path)\n-        return { auth, headers, variables }\n-      }\n-\n-      const data: {\n-        auth: HoppRESTAuth\n-        headers: HoppRESTHeader[]\n-        variables: HoppCollectionVariable[]\n-      } = parentFolder.data\n-        ? JSON.parse(parentFolder.data)\n-        : {\n-            auth: null,\n-            headers: null,\n-            variables: null,\n-          }\n-\n-      if (!data.auth) {\n-        data.auth = {\n-          authType: \"inherit\",\n-          authActive: true,\n-        }\n-        auth.parentID = path.slice(0, i + 1).join(\"/\")\n-        auth.parentName = parentFolder.title\n-      }\n-\n-      if (!data.headers) data.headers = []\n-\n-      if (!data.variables) data.variables = []\n-\n-      const parentFolderAuth = data.auth\n-      const parentFolderHeaders = data.headers\n-      const parentFolderVariables = data.variables\n-\n-      if (\n-        parentFolderAuth?.authType === \"inherit\" &&\n-        path.slice(0, i + 1).length === 1\n-      ) {\n-        auth = {\n-          parentID: path.slice(0, i + 1).join(\"/\"),\n-          parentName: parentFolder.title,\n-          inheritedAuth: auth.inheritedAuth,\n-        }\n-      }\n-\n-      if (parentFolderAuth?.authType !== \"inherit\") {\n-        auth = {\n-          parentID: path.slice(0, i + 1).join(\"/\"),\n-          parentName: parentFolder.title,\n-          inheritedAuth: parentFolderAuth,\n-        }\n-      }\n-\n-      // Update headers, overwriting duplicates by key\n-      if (parentFolderHeaders) {\n-        const activeHeaders = parentFolderHeaders.filter((h) => h.active)\n-        activeHeaders.forEach((header) => {\n-          const index = headers.findIndex(\n-            (h) => h.inheritedHeader?.key === header.key\n-          )\n-          const currentPath = path.slice(0, i + 1).join(\"/\")\n-          if (index !== -1) {\n-            // Replace the existing header with the same key\n-            headers[index] = {\n-              parentID: currentPath,\n-              parentName: parentFolder.title,\n-              inheritedHeader: header,\n-            }\n-          } else {\n-            headers.push({\n-              parentID: currentPath,\n-              parentName: parentFolder.title,\n-              inheritedHeader: header,\n-            })\n-          }\n-        })\n-      }\n-\n-      // Update variables, overwriting duplicates by key\n-      if (parentFolderVariables) {\n-        const currentPath = [...path.slice(0, i + 1)].join(\"/\")\n-\n-        variables.push({\n-          parentPath: path.slice(0, i + 1).join(\"/\"),\n-          parentID: parentFolder.id ?? currentPath,\n-          parentName: parentFolder.title,\n-          inheritedVariables: this.populateValues(\n-            parentFolderVariables,\n-            parentFolder.id ?? currentPath\n-          ),\n-        })\n-      }\n-    }\n-\n-    return { auth, headers, variables }\n-  }\n-\n-  private async waitForCollectionLoading(collectionID: string) {\n-    while (this.loadingCollections.value.includes(collectionID)) {\n-      await new Promise((resolve) => setTimeout(resolve, 50))\n-    }\n-  }\n-\n-  /**\n-   * Used to obtain the inherited auth and headers for a given folder path\n-   * This function is async and will expand the collections if they are not expanded yet\n-   * @param folderPath the path of the folder to cascade the auth from\n-   * @returns the inherited auth and headers for the given folder path\n-   */\n-  public async cascadeParentCollectionForPropertiesAsync(folderPath: string) {\n-    if (!folderPath)\n-      return {\n-        auth: {\n-          parentID: \"\",\n-          parentName: \"\",\n-          inheritedAuth: {\n-            authType: \"none\",\n-            authActive: true,\n-          },\n-        },\n-        headers: [],\n-        variables: [],\n-      }\n-\n-    const path = folderPath.split(\"/\")\n-\n-    // Check if the path is empty or invalid\n-    if (!path || path.length === 0) {\n-      console.error(\"Invalid path:\", folderPath)\n-      return {\n-        auth: {\n-          parentID: \"\",\n-          parentName: \"\",\n-          inheritedAuth: {\n-            authType: \"none\",\n-            authActive: true,\n-          },\n-        },\n-        headers: [],\n-        variables: [],\n-      }\n-    }\n-\n-    // Loop through the path and expand the collections if they are not expanded\n-    for (let i = 0; i < path.length; i++) {\n-      const parentFolder = findCollInTree(this.collections.value, path[i])\n-\n-      if (parentFolder) {\n-        if (parentFolder.children === null) {\n-          if (this.loadingCollections.value.includes(parentFolder.id)) {\n-            await this.waitForCollectionLoading(parentFolder.id)\n-          } else {\n-            await this.expandCollection(parentFolder.id)\n-          }\n-        }\n-      }\n-    }\n-\n-    return this.cascadeParentCollectionForProperties(folderPath)\n-  }\n-}\n+    //\n\\ No newline at end of file\ndiff --git a/packages/hoppscotch-common/src/services/workspace.service.ts b/packages/hoppscotch-common/src/services/workspace.service.ts\nindex 6287bf3..62ed2c0 100644\n--- a/packages/hoppscotch-common/src/services/workspace.service.ts\n+++ b/packages/hoppscotch-common/src/services/workspace.service.ts\n@@ -225,4 +225,4 @@ export class WorkspaceService extends Service<WorkspaceServiceEvent> {\n \n     return this.managedTeamListAdapter\n   }\n-}\n+}\n\\ No newline at end of file\n",
    "pr_number": 5533,
    "title": "fix: team collection not loading on route change",
    "test_files": [
      "packages/hoppscotch-common/src/services/__tests__/workspace.service.spec.ts"
    ],
    "code_files": [
      "packages/hoppscotch-common/src/services/team-collection.service.ts",
      "packages/hoppscotch-common/src/services/workspace.service.ts"
    ]
  },
  {
    "instance_id": "hoppscotch__hoppscotch.main.5363",
    "repo": "hoppscotch/hoppscotch",
    "base_commit": "aac4c5b34b833b3bf463d20091c903c645de533c",
    "bug_patch": "diff --git a/packages/hoppscotch-backend/src/team/team.service.spec.ts b/packages/hoppscotch-backend/src/team/team.service.spec.ts\nindex 6126405..36cca93 100644\n--- a/packages/hoppscotch-backend/src/team/team.service.spec.ts\n+++ b/packages/hoppscotch-backend/src/team/team.service.spec.ts\n@@ -361,8 +361,8 @@ describe('renameTeam', () => {\n     ).resolves.toEqualLeft(TEAM_INVALID_ID);\n   });\n \n-  test('rejects for new team name empty with TEAM_NAME_INVALID', () => {\n-    const newTeamName = '';\n+  test('rejects for new team name length < 6 with TEAM_NAME_INVALID', () => {\n+    const newTeamName = 'smol';\n \n     // Prisma doesn't care about the team name length, so it will resolve\n     mockPrisma.team.update.mockResolvedValue({\n@@ -443,553 +443,4 @@ describe('updateTeamAccessRole', () => {\n     });\n \n     // Prisma doesn't care if it goes through\n-    mockPrisma.teamMember.update.mockResolvedValue(dbTeamMember);\n-\n-    return expect(\n-      teamService.updateTeamAccessRole(\n-        dbTeamMember.teamID,\n-        dbTeamMember.userUid,\n-        TeamAccessRole[dbTeamMember.role],\n-      ),\n-    ).resolves.toEqualLeft(TEAM_ONLY_ONE_OWNER);\n-  });\n-\n-  test('resolves if you change the status of the sole owner to owner status (no change)', () => {\n-    mockPrisma.teamMember.count.mockResolvedValue(1);\n-    mockPrisma.teamMember.findUnique.mockResolvedValue({\n-      ...dbTeamMember,\n-      role: TeamAccessRole.OWNER,\n-    });\n-    mockPrisma.teamMember.update.mockResolvedValue({\n-      ...dbTeamMember,\n-      role: TeamAccessRole.OWNER,\n-    });\n-\n-    return expect(\n-      teamService.updateTeamAccessRole(\n-        dbTeamMember.teamID,\n-        dbTeamMember.userUid,\n-        TeamAccessRole[TeamAccessRole.OWNER],\n-      ),\n-    ).resolves.toBeDefined();\n-  });\n-\n-  test('resolves if you change the status of an owner but there are other owners', async () => {\n-    mockPrisma.teamMember.count.mockResolvedValue(2);\n-    mockPrisma.teamMember.findUnique.mockResolvedValue({\n-      ...dbTeamMember,\n-      role: TeamAccessRole.OWNER,\n-    });\n-    mockPrisma.teamMember.update.mockResolvedValue(dbTeamMember);\n-\n-    // Set another user as the owner\n-    await teamService.updateTeamAccessRole(\n-      dbTeamMember.teamID,\n-      'testuid2',\n-      TeamAccessRole.OWNER,\n-    );\n-\n-    await expect(\n-      teamService.updateTeamAccessRole(\n-        dbTeamMember.teamID,\n-        dbTeamMember.userUid,\n-        TeamAccessRole[dbTeamMember.role],\n-      ),\n-    ).resolves.toBeDefined();\n-  });\n-\n-  test('fires \"team/<team_id>/member_updated\" pubsub message with correct payload', async () => {\n-    const newRole = TeamAccessRole.EDITOR;\n-\n-    mockPrisma.teamMember.count.mockResolvedValue(2);\n-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);\n-    mockPrisma.teamMember.update.mockResolvedValue({\n-      ...dbTeamMember,\n-      role: newRole,\n-    });\n-\n-    await teamService.updateTeamAccessRole(\n-      dbTeamMember.teamID,\n-      dbTeamMember.userUid,\n-      newRole,\n-    );\n-\n-    expect(mockPubSub.publish).toHaveBeenCalledWith(\n-      `team/${dbTeamMember.teamID}/member_updated`,\n-      {\n-        ...teamMember,\n-        role: newRole,\n-      },\n-    );\n-  });\n-});\n-\n-describe('leaveTeam', () => {\n-  /*\n-    Same scenario as above:\n-      3 users (testuid1 thru 3) with respectively\n-      OWNER, VIEWER and EDITOR roles in team with id 3170\n-  */\n-\n-  test('removes the user if valid credentials given', async () => {\n-    mockPrisma.teamMember.count.mockResolvedValue(2);\n-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);\n-    mockPrisma.teamMember.delete.mockResolvedValue(dbTeamMember);\n-\n-    await teamService.leaveTeam(dbTeamMember.teamID, dbTeamMember.userUid);\n-\n-    expect(mockPrisma.teamMember.delete).toHaveBeenCalledWith({\n-      where: {\n-        teamID_userUid: {\n-          teamID: dbTeamMember.teamID,\n-          userUid: dbTeamMember.userUid,\n-        },\n-      },\n-    });\n-  });\n-\n-  test('rejects if invalid teamId with TEAM_INVALID_ID_OR_USER', () => {\n-    // Invalid team id will return 0 count\n-    mockPrisma.teamMember.count.mockResolvedValue(0);\n-\n-    // getTeamMember returns null if no match\n-    mockPrisma.teamMember.findUnique.mockResolvedValue(null);\n-\n-    // Deletion rejects with RecordNotFound when no match\n-    mockPrisma.teamMember.delete.mockRejectedValue('RecordNotFound');\n-\n-    return expect(\n-      teamService.leaveTeam('31700', dbTeamMember.userUid),\n-    ).resolves.toEqualLeft(TEAM_INVALID_ID_OR_USER);\n-  });\n-\n-  test('rejects if invalid userUid with TEAM_INVALID_ID_OR_USER', () => {\n-    // Invalid team id will return proper count\n-    mockPrisma.teamMember.count.mockResolvedValue(1);\n-\n-    // getTeamMember returns null if no match\n-    mockPrisma.teamMember.findUnique.mockResolvedValue(null);\n-\n-    // Deletion rejects with RecordNotFound when no match\n-    mockPrisma.teamMember.delete.mockRejectedValue('RecordNotFound');\n-\n-    return expect(\n-      teamService.leaveTeam(dbTeamMember.teamID, 'testuid3'),\n-    ).resolves.toEqualLeft(TEAM_INVALID_ID_OR_USER);\n-  });\n-\n-  test('rejects if the removed user is the sole owner of the team with TEAM_ONLY_ONE_OWNER', () => {\n-    mockPrisma.teamMember.count.mockResolvedValue(1);\n-    mockPrisma.teamMember.findUnique.mockResolvedValue({\n-      ...dbTeamMember,\n-      role: TeamAccessRole.OWNER,\n-    });\n-\n-    // Prisma does not care\n-    mockPrisma.teamMember.delete.mockResolvedValue({\n-      ...dbTeamMember,\n-      role: TeamAccessRole.OWNER,\n-    });\n-\n-    return expect(\n-      teamService.leaveTeam(dbTeamMember.teamID, dbTeamMember.userUid),\n-    ).resolves.toEqualLeft(TEAM_ONLY_ONE_OWNER);\n-  });\n-\n-  test('resolves if the removed user is an owner (but not the sole) of the team', async () => {\n-    mockPrisma.teamMember.count.mockResolvedValue(2);\n-    mockPrisma.teamMember.findUnique.mockResolvedValue({\n-      ...dbTeamMember,\n-      role: TeamAccessRole.OWNER,\n-    });\n-    mockPrisma.teamMember.delete.mockResolvedValue({\n-      ...dbTeamMember,\n-      role: TeamAccessRole.OWNER,\n-    });\n-\n-    await expect(\n-      teamService.leaveTeam(dbTeamMember.teamID, dbTeamMember.userUid),\n-    ).resolves.toEqualRight(true);\n-  });\n-\n-  test('fires \"team/<team_id>/member_removed\" pubsub message with correct payload', async () => {\n-    mockPrisma.teamMember.count.mockResolvedValue(2);\n-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);\n-    mockPrisma.teamMember.delete.mockResolvedValue(dbTeamMember);\n-\n-    await teamService.leaveTeam(dbTeamMember.teamID, dbTeamMember.userUid);\n-\n-    expect(mockPubSub.publish).toHaveBeenCalledWith(\n-      `team/${dbTeamMember.teamID}/member_removed`,\n-      dbTeamMember.userUid,\n-    );\n-  });\n-});\n-\n-describe('createTeam', () => {\n-  test('adds the new team to the db', async () => {\n-    mockPrisma.team.create.mockResolvedValue(team);\n-\n-    await teamService.createTeam(team.name, dbTeamMember.userUid);\n-\n-    expect(mockPrisma.team.create).toHaveBeenCalledWith(\n-      expect.objectContaining({\n-        data: expect.objectContaining({\n-          name: team.name,\n-        }),\n-      }),\n-    );\n-  });\n-\n-  test('adds the creator to team and set them as OWNER', async () => {\n-    mockPrisma.team.create.mockResolvedValue(team);\n-\n-    await teamService.createTeam(team.name, dbTeamMember.userUid);\n-\n-    expect(mockPrisma.team.create).toHaveBeenCalledWith(\n-      expect.objectContaining({\n-        data: expect.objectContaining({\n-          members: {\n-            create: {\n-              userUid: dbTeamMember.userUid,\n-              role: TeamAccessRole.OWNER,\n-            },\n-          },\n-        }),\n-      }),\n-    );\n-  });\n-\n-  test('resolves with the team info', () => {\n-    mockPrisma.team.create.mockResolvedValue(team);\n-\n-    return expect(\n-      teamService.createTeam(team.name, dbTeamMember.userUid),\n-    ).resolves.toEqualRight(expect.objectContaining(team));\n-  });\n-\n-  test('rejects for team name empty with TEAM_NAME_INVALID', () => {\n-    const newName = '';\n-\n-    // Prisma doesn't care\n-    mockPrisma.team.create.mockResolvedValue({\n-      ...team,\n-      name: newName,\n-    });\n-\n-    return expect(\n-      teamService.createTeam(newName, dbTeamMember.userUid),\n-    ).resolves.toEqualLeft(TEAM_NAME_INVALID);\n-  });\n-});\n-\n-describe('getTeamWithID', () => {\n-  test('resolves for a proper team id with the proper details', () => {\n-    mockPrisma.team.findUnique.mockResolvedValue(team);\n-\n-    return expect(teamService.getTeamWithID(team.id)).resolves.toEqual(\n-      expect.objectContaining(team),\n-    );\n-  });\n-\n-  test('resolves for a invalid team id as null', () => {\n-    // Prisma would reject with RecordNotFound\n-    mockPrisma.team.findUnique.mockRejectedValue('RecordNotFound');\n-\n-    return expect(teamService.getTeamWithID('3171')).resolves.toBeNull();\n-  });\n-});\n-\n-describe('getTeamMember', () => {\n-  test('resolves for a proper team id and user uid and returns the info', () => {\n-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);\n-\n-    return expect(\n-      teamService.getTeamMember(dbTeamMember.teamID, dbTeamMember.userUid),\n-    ).resolves.toEqual(expect.objectContaining(teamMember));\n-  });\n-\n-  test('resolves for a invalid team id and proper uid and returns null', () => {\n-    // If not found, prisma rejects with RecordNotFound\n-    mockPrisma.teamMember.findUnique.mockRejectedValue('RecordNotFound');\n-\n-    return expect(\n-      teamService.getTeamMember(dbTeamMember.teamID, 'testuid'),\n-    ).resolves.toBeNull();\n-  });\n-});\n-\n-describe('getRoleOfUserInTeam', () => {\n-  test('resolves with the correct role value', () => {\n-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);\n-\n-    return expect(\n-      teamService.getRoleOfUserInTeam(\n-        dbTeamMember.teamID,\n-        dbTeamMember.userUid,\n-      ),\n-    ).resolves.toEqual(dbTeamMember.role);\n-  });\n-\n-  test('resolves with null if user is not found in team', () => {\n-    mockPrisma.teamMember.findUnique.mockRejectedValue('RecordNotFound');\n-\n-    return expect(\n-      teamService.getRoleOfUserInTeam(dbTeamMember.teamID, 'nottestuid'),\n-    ).resolves.toBeNull();\n-  });\n-\n-  test('resolves with null if team does not exist', () => {\n-    mockPrisma.teamMember.findUnique.mockRejectedValue('RecordNotFound');\n-\n-    return expect(\n-      teamService.getRoleOfUserInTeam('invalidteam', dbTeamMember.userUid),\n-    ).resolves.toBeNull();\n-  });\n-});\n-\n-describe('getMembersOfTeam', () => {\n-  test('resolves for the team id and null cursor with the first page', async () => {\n-    mockPrisma.teamMember.findMany.mockResolvedValue([]);\n-    await teamService.getMembersOfTeam(team.id, null);\n-\n-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({\n-      take: 10,\n-      where: {\n-        teamID: team.id,\n-      },\n-    });\n-  });\n-\n-  test('resolves for the team id and proper cursor with pagination', async () => {\n-    const cursor = 'secondpage';\n-\n-    mockPrisma.teamMember.findMany.mockResolvedValue([]);\n-    await teamService.getMembersOfTeam(team.id, cursor);\n-\n-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({\n-      take: 10,\n-      skip: 1,\n-      cursor: {\n-        id: cursor,\n-      },\n-      where: {\n-        teamID: team.id,\n-      },\n-    });\n-  });\n-\n-  test('resolves with an empty array for invalid team id and null cursor', () => {\n-    // findMany returns an empty array if no matches are found\n-    mockPrisma.teamMember.findMany.mockResolvedValue([]);\n-\n-    return expect(\n-      teamService.getMembersOfTeam('invalidteamid', null),\n-    ).resolves.toHaveLength(0);\n-  });\n-\n-  test('resolves with an empty array for an invalid team id and invalid cursor', () => {\n-    // findMany returns an empty array if no matches are found\n-    mockPrisma.teamMember.findMany.mockResolvedValue([]);\n-\n-    return expect(\n-      teamService.getMembersOfTeam('invalidteamid', 'invalidcursor'),\n-    ).resolves.toHaveLength(0);\n-  });\n-});\n-\n-describe('getTeamsOfUser', () => {\n-  test('resolves with the first 10 elements when no cursor is given', async () => {\n-    mockPrisma.teamMember.findMany.mockResolvedValue([]);\n-\n-    await teamService.getTeamsOfUser(dbTeamMember.userUid, null);\n-\n-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({\n-      take: 10,\n-      where: {\n-        userUid: dbTeamMember.userUid,\n-      },\n-      include: {\n-        team: true,\n-      },\n-    });\n-  });\n-\n-  test('resolves as expected for paginated requests with cursor', async () => {\n-    const cursor = 'secondpage';\n-\n-    mockPrisma.teamMember.findMany.mockResolvedValue([]);\n-    await teamService.getTeamsOfUser(dbTeamMember.userUid, cursor);\n-\n-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({\n-      take: 10,\n-      skip: 1,\n-      cursor: {\n-        teamID_userUid: {\n-          teamID: cursor,\n-          userUid: dbTeamMember.userUid,\n-        },\n-      },\n-      where: {\n-        userUid: dbTeamMember.userUid,\n-      },\n-      include: {\n-        team: true,\n-      },\n-    });\n-  });\n-\n-  test('resolves with an empty array for an invalid cursor', () => {\n-    // Invalid cursors return an empty array\n-    mockPrisma.teamMember.findMany.mockResolvedValue([]);\n-\n-    return expect(\n-      teamService.getTeamsOfUser(dbTeamMember.userUid, 'invalidcursor'),\n-    ).resolves.toHaveLength(0);\n-  });\n-\n-  test('resolves with an empty array for invalid user id and null cursor', () => {\n-    mockPrisma.teamMember.findMany.mockResolvedValue([]);\n-\n-    return expect(\n-      teamService.getTeamsOfUser('invalidid', null),\n-    ).resolves.toHaveLength(0);\n-  });\n-\n-  test('resolves with an empty array for invalid user id and invalid cursor', () => {\n-    mockPrisma.teamMember.findMany.mockResolvedValue([]);\n-\n-    return expect(\n-      teamService.getTeamsOfUser('invalidId', 'invalidCursor'),\n-    ).resolves.toHaveLength(0);\n-  });\n-});\n-\n-describe('deleteUserFromAllTeams', () => {\n-  test('should return undefined when a valid uid is passed and user is deleted from all teams', async () => {\n-    mockPrisma.teamMember.findMany.mockResolvedValue([dbTeamMember]);\n-    mockPrisma.teamMember.count.mockResolvedValue(2);\n-    mockPrisma.teamMember.findUnique.mockResolvedValue(dbTeamMember);\n-\n-    const result = await teamService.deleteUserFromAllTeams(\n-      dbTeamMember.userUid,\n-    )();\n-\n-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({\n-      where: {\n-        userUid: dbTeamMember.userUid,\n-      },\n-    });\n-\n-    expect(result).toBeUndefined();\n-  });\n-\n-  test('should return undefined when user has no data or the uid is invalid', async () => {\n-    mockPrisma.teamMember.findMany.mockResolvedValue([]);\n-\n-    const result = await teamService.deleteUserFromAllTeams(\n-      dbTeamMember.userUid,\n-    )();\n-\n-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({\n-      where: {\n-        userUid: dbTeamMember.userUid,\n-      },\n-    });\n-\n-    expect(result).toBeUndefined();\n-  });\n-\n-  test('should reject when user is an OWNER in a team with only 1 member', async () => {\n-    mockPrisma.teamMember.findMany.mockResolvedValue([dbTeamMember]);\n-    mockPrisma.teamMember.count.mockResolvedValue(1);\n-    mockPrisma.teamMember.findUnique.mockResolvedValue({\n-      ...dbTeamMember,\n-      role: TeamAccessRole.OWNER,\n-    });\n-\n-    const result = teamService.deleteUserFromAllTeams(dbTeamMember.userUid)();\n-\n-    await expect(result).rejects.toThrow(TEAM_ONLY_ONE_OWNER);\n-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({\n-      where: {\n-        userUid: dbTeamMember.userUid,\n-      },\n-    });\n-  });\n-\n-  test('should reject when a valid uid is passed but fetching teamMember details errors out', async () => {\n-    mockPrisma.teamMember.findMany.mockResolvedValue([\n-      {\n-        ...dbTeamMember,\n-        role: TeamAccessRole.OWNER,\n-      },\n-    ]);\n-    mockPrisma.teamMember.count.mockResolvedValue(2);\n-\n-    // findUnique while getTeamMember() is called errors out\n-    mockPrisma.teamMember.findUnique.mockRejectedValueOnce('NotFoundError');\n-\n-    const result = teamService.deleteUserFromAllTeams(dbTeamMember.userUid);\n-\n-    await expect(result).rejects.toThrow(TEAM_INVALID_ID_OR_USER);\n-    expect(mockPrisma.teamMember.findMany).toHaveBeenCalledWith({\n-      where: {\n-        userUid: dbTeamMember.userUid,\n-      },\n-    });\n-  });\n-});\n-\n-describe('fetchAllTeams', () => {\n-  test('should resolve right and return 20 teams when cursor is null', async () => {\n-    mockPrisma.team.findMany.mockResolvedValueOnce(teams);\n-\n-    const result = await teamService.fetchAllTeams(null, 20);\n-    expect(result).toEqual(teams);\n-  });\n-  test('should resolve right and return next 20 teams when cursor is provided', async () => {\n-    mockPrisma.team.findMany.mockResolvedValueOnce(teams);\n-\n-    const result = await teamService.fetchAllTeams('teamID', 20);\n-    expect(result).toEqual(teams);\n-  });\n-  test('should resolve left and return an empty array when users not found', async () => {\n-    mockPrisma.team.findMany.mockResolvedValueOnce([]);\n-\n-    const result = await teamService.fetchAllTeams(null, 20);\n-    expect(result).toEqual([]);\n-  });\n-});\n-\n-describe('getCountOfMembersInTeam', () => {\n-  test('should resolve right and return a total team member count ', async () => {\n-    mockPrisma.teamMember.count.mockResolvedValueOnce(2);\n-    const result = await teamService.getCountOfMembersInTeam(team.id);\n-    expect(mockPrisma.teamMember.count).toHaveBeenCalledWith({\n-      where: {\n-        teamID: team.id,\n-      },\n-    });\n-    expect(result).toEqual(2);\n-  });\n-  test('should resolve left and return an error when no team members found', async () => {\n-    mockPrisma.teamMember.count.mockResolvedValueOnce(0);\n-    const result = await teamService.getCountOfMembersInTeam(team.id);\n-    expect(mockPrisma.teamMember.count).toHaveBeenCalledWith({\n-      where: {\n-        teamID: team.id,\n-      },\n-    });\n-    expect(result).toEqual(0);\n-  });\n-\n-  describe('getTeamsCount', () => {\n-    test('should return count of all teams in the organization', async () => {\n-      mockPrisma.team.count.mockResolvedValueOnce(10);\n-\n-      const result = await teamService.getTeamsCount();\n-      expect(result).toEqual(10);\n-    });\n-  });\n-});\n+    mockPrisma.teamMember.update.\n\\ No newline at end of file\ndiff --git a/packages/hoppscotch-backend/src/team/team.service.ts b/packages/hoppscotch-backend/src/team/team.service.ts\nindex bad4bd1..4ea377a 100644\n--- a/packages/hoppscotch-backend/src/team/team.service.ts\n+++ b/packages/hoppscotch-backend/src/team/team.service.ts\n@@ -125,6 +125,11 @@ export class TeamService implements UserDataHandler, OnModuleInit {\n     return E.right(true);\n   }\n \n+  validateTeamName(title: string): E.Left<string> | E.Right<boolean> {\n+    if (!title || title.length < 6) return E.left(TEAM_NAME_INVALID);\n+    return E.right(true);\n+  }\n+\n   async renameTeam(\n     teamID: string,\n     newName: string,\n@@ -499,48 +504,4 @@ export class TeamService implements UserDataHandler, OnModuleInit {\n         cursor: {\n           id: cursor,\n         },\n-        where: {\n-          teamID,\n-        },\n-      });\n-    }\n-\n-    const members = teamMembers.map(\n-      (entry) =>\n-        <TeamMember>{\n-          membershipID: entry.id,\n-          userUid: entry.userUid,\n-          role: TeamAccessRole[entry.role],\n-        },\n-    );\n-\n-    return this.filterMismatchedUsers(teamID, members);\n-  }\n-\n-  /**\n-   * Fetch all the teams in the `Team` table based on cursor\n-   * @param cursorID string of teamID or undefined\n-   * @param take number of items to query\n-   * @returns an array of `Team` object\n-   */\n-  async fetchAllTeams(cursorID: string, take: number) {\n-    const options = {\n-      skip: cursorID ? 1 : 0,\n-      take: take,\n-      cursor: cursorID ? { id: cursorID } : undefined,\n-    };\n-\n-    const fetchedTeams = await this.prisma.team.findMany(options);\n-    return fetchedTeams;\n-  }\n-\n-  /**\n-   * Fetch list of all the Teams in the DB\n-   *\n-   * @returns number of teams in the org\n-   */\n-  async getTeamsCount() {\n-    const teamsCount = await this.prisma.team.count();\n-    return teamsCount;\n-  }\n-}\n+        where\n\\ No newline at end of file\ndiff --git a/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts b/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts\nindex 26182ec..eb6260a 100644\n--- a/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts\n+++ b/packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts\n@@ -6,8 +6,8 @@ interface TeamNameBrand {\n \n export const TeamNameCodec = t.brand(\n   t.string,\n-  (x): x is t.Branded<string, TeamNameBrand> => x.trim() !== \"\",\n+  (x): x is t.Branded<string, TeamNameBrand> => x.trim().length >= 6,\n   \"TeamName\"\n )\n \n-export type TeamName = t.TypeOf<typeof TeamNameCodec>\n+export type TeamName = t.TypeOf<typeof TeamNameCodec>\n\\ No newline at end of file\n",
    "pr_number": 5363,
    "title": "feat: remove minimum length restriction on shared workspace names",
    "test_files": [
      "packages/hoppscotch-backend/src/team/team.service.spec.ts"
    ],
    "code_files": [
      "packages/hoppscotch-backend/src/team/team.service.ts",
      "packages/hoppscotch-common/src/helpers/backend/types/TeamName.ts"
    ]
  },
  {
    "instance_id": "hoppscotch__hoppscotch.main.5624",
    "repo": "hoppscotch/hoppscotch",
    "base_commit": "217563e7ddf63ef83eea2b27762ea0d2113b8d2e",
    "bug_patch": "diff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts\nindex 11e72ec..363c04c 100644\n--- a/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts\n+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts\n@@ -34,7 +34,6 @@ export class PublishedDocsResolver {\n \n   @ResolveField(() => User, {\n     description: 'Returns the creator of the published document',\n-    nullable: true,\n   })\n   async creator(@Parent() publishedDocs: PublishedDocs): Promise<User> {\n     const creator = await this.publishedDocsService.getPublishedDocsCreator(\n@@ -42,11 +41,16 @@ export class PublishedDocsResolver {\n     );\n \n     if (E.isLeft(creator)) throwErr(creator.left);\n-    return creator.right;\n+    return {\n+      ...creator.right,\n+      currentGQLSession: JSON.stringify(creator.right.currentGQLSession),\n+      currentRESTSession: JSON.stringify(creator.right.currentRESTSession),\n+    };\n   }\n \n   @ResolveField(() => PublishedDocsCollection, {\n     description: 'Returns the collection of the published document',\n+    nullable: true,\n   })\n   async collection(\n     @Parent() publishedDocs: PublishedDocs,\n@@ -200,4 +204,4 @@ export class PublishedDocsResolver {\n     if (E.isLeft(result)) throwErr(result.left);\n     return result.right;\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts\nindex e532eb6..4c1fc4b 100644\n--- a/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts\n+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts\n@@ -47,8 +47,8 @@ const user: User = {\n   lastLoggedOn: currentTime,\n   lastActiveOn: currentTime,\n   createdOn: currentTime,\n-  currentGQLSession: {} as any,\n-  currentRESTSession: {} as any,\n+  currentGQLSession: JSON.stringify({}),\n+  currentRESTSession: JSON.stringify({}),\n };\n \n const userPublishedDoc: DBPublishedDocs = {\n@@ -179,9 +179,6 @@ describe('getPublishedDocByID', () => {\n describe('getAllUserPublishedDocs', () => {\n   test('should return a list of user published documents with pagination', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([userPublishedDoc]);\n-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n-      { id: 'collection_1' },\n-    ] as any);\n \n     const result = await publishedDocsService.getAllUserPublishedDocs(\n       user.uid,\n@@ -193,7 +190,6 @@ describe('getAllUserPublishedDocs', () => {\n \n   test('should return an empty array when no documents found', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);\n-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([]);\n \n     const result = await publishedDocsService.getAllUserPublishedDocs(\n       user.uid,\n@@ -205,9 +201,6 @@ describe('getAllUserPublishedDocs', () => {\n   test('should return paginated results correctly', async () => {\n     const docs = [userPublishedDoc, { ...userPublishedDoc, id: 'pub_doc_3' }];\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([docs[0]]);\n-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n-      { id: 'collection_1' },\n-    ] as any);\n \n     const result = await publishedDocsService.getAllUserPublishedDocs(\n       user.uid,\n@@ -215,94 +208,11 @@ describe('getAllUserPublishedDocs', () => {\n     );\n     expect(result).toHaveLength(1);\n   });\n-\n-  test('should filter out published docs with non-existent collections', async () => {\n-    const doc1 = {\n-      ...userPublishedDoc,\n-      id: 'pub_doc_1',\n-      collectionID: 'collection_1',\n-    };\n-    const doc2 = {\n-      ...userPublishedDoc,\n-      id: 'pub_doc_2',\n-      collectionID: 'collection_2',\n-    };\n-    const doc3 = {\n-      ...userPublishedDoc,\n-      id: 'pub_doc_3',\n-      collectionID: 'collection_3',\n-    };\n-\n-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2, doc3]);\n-    // Only collection_1 and collection_3 exist\n-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n-      { id: 'collection_1' },\n-      { id: 'collection_3' },\n-    ] as any);\n-\n-    const result = await publishedDocsService.getAllUserPublishedDocs(\n-      user.uid,\n-      { skip: 0, take: 10 },\n-    );\n-\n-    // Should only return docs with existing collections\n-    expect(result).toHaveLength(2);\n-    expect(result.map((d) => d.id)).toEqual(['pub_doc_1', 'pub_doc_3']);\n-  });\n-\n-  test('should delete published docs with non-existent collections', async () => {\n-    const doc1 = {\n-      ...userPublishedDoc,\n-      id: 'pub_doc_1',\n-      collectionID: 'collection_1',\n-    };\n-    const doc2 = {\n-      ...userPublishedDoc,\n-      id: 'pub_doc_2',\n-      collectionID: 'collection_deleted',\n-    };\n-\n-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2]);\n-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n-      { id: 'collection_1' },\n-    ] as any);\n-    mockPrisma.publishedDocs.deleteMany.mockResolvedValueOnce({\n-      count: 1,\n-    } as any);\n-\n-    await publishedDocsService.getAllUserPublishedDocs(user.uid, {\n-      skip: 0,\n-      take: 10,\n-    });\n-\n-    expect(mockPrisma.publishedDocs.deleteMany).toHaveBeenCalledWith({\n-      where: {\n-        id: { in: ['pub_doc_2'] },\n-      },\n-    });\n-  });\n-\n-  test('should not call deleteMany when all collections exist', async () => {\n-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([userPublishedDoc]);\n-    mockPrisma.userCollection.findMany.mockResolvedValueOnce([\n-      { id: 'collection_1' },\n-    ] as any);\n-\n-    await publishedDocsService.getAllUserPublishedDocs(user.uid, {\n-      skip: 0,\n-      take: 10,\n-    });\n-\n-    expect(mockPrisma.publishedDocs.deleteMany).not.toHaveBeenCalled();\n-  });\n });\n \n describe('getAllTeamPublishedDocs', () => {\n   test('should return a list of team published documents with pagination', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n-      { id: 'team_collection_1' },\n-    ] as any);\n \n     const result = await publishedDocsService.getAllTeamPublishedDocs(\n       'team_1',\n@@ -315,7 +225,6 @@ describe('getAllTeamPublishedDocs', () => {\n \n   test('should return an empty array when no team documents found', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([]);\n-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([]);\n \n     const result = await publishedDocsService.getAllTeamPublishedDocs(\n       'team_1',\n@@ -327,9 +236,6 @@ describe('getAllTeamPublishedDocs', () => {\n \n   test('should filter by teamID and collectionID correctly', async () => {\n     mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n-      { id: 'team_collection_1' },\n-    ] as any);\n \n     await publishedDocsService.getAllTeamPublishedDocs(\n       'team_1',\n@@ -350,88 +256,6 @@ describe('getAllTeamPublishedDocs', () => {\n       },\n     });\n   });\n-\n-  test('should filter out published docs with non-existent team collections', async () => {\n-    const doc1 = {\n-      ...teamPublishedDoc,\n-      id: 'pub_doc_1',\n-      collectionID: 'team_collection_1',\n-    };\n-    const doc2 = {\n-      ...teamPublishedDoc,\n-      id: 'pub_doc_2',\n-      collectionID: 'team_collection_2',\n-    };\n-    const doc3 = {\n-      ...teamPublishedDoc,\n-      id: 'pub_doc_3',\n-      collectionID: 'team_collection_3',\n-    };\n-\n-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2, doc3]);\n-    // Only team_collection_1 and team_collection_3 exist\n-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n-      { id: 'team_collection_1' },\n-      { id: 'team_collection_3' },\n-    ] as any);\n-\n-    const result = await publishedDocsService.getAllTeamPublishedDocs(\n-      'team_1',\n-      undefined,\n-      { skip: 0, take: 10 },\n-    );\n-\n-    // Should only return docs with existing collections\n-    expect(result).toHaveLength(2);\n-    expect(result.map((d) => d.id)).toEqual(['pub_doc_1', 'pub_doc_3']);\n-  });\n-\n-  test('should delete published docs with non-existent team collections', async () => {\n-    const doc1 = {\n-      ...teamPublishedDoc,\n-      id: 'pub_doc_1',\n-      collectionID: 'team_collection_1',\n-    };\n-    const doc2 = {\n-      ...teamPublishedDoc,\n-      id: 'pub_doc_2',\n-      collectionID: 'team_collection_deleted',\n-    };\n-\n-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([doc1, doc2]);\n-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n-      { id: 'team_collection_1' },\n-    ] as any);\n-    mockPrisma.publishedDocs.deleteMany.mockResolvedValueOnce({\n-      count: 1,\n-    } as any);\n-\n-    await publishedDocsService.getAllTeamPublishedDocs('team_1', undefined, {\n-      skip: 0,\n-      take: 10,\n-    });\n-\n-    expect(mockPrisma.publishedDocs.deleteMany).toHaveBeenCalledWith({\n-      where: {\n-        id: { in: ['pub_doc_2'] },\n-      },\n-    });\n-  });\n-\n-  test('should not call deleteMany when all team collections exist', async () => {\n-    mockPrisma.publishedDocs.findMany.mockResolvedValueOnce([teamPublishedDoc]);\n-    mockPrisma.teamCollection.findMany.mockResolvedValueOnce([\n-      { id: 'team_collection_1' },\n-    ] as any);\n-\n-    await publishedDocsService.getAllTeamPublishedDocs(\n-      'team_1',\n-      'team_collection_1',\n-      { skip: 0, take: 10 },\n-    );\n-\n-    expect(mockPrisma.publishedDocs.deleteMany).not.toHaveBeenCalled();\n-  });\n });\n \n describe('createPublishedDoc', () => {\n@@ -546,541 +370,4 @@ describe('createPublishedDoc', () => {\n   });\n \n   test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when collection does not belong to user', async () => {\n-    // When Prisma queries with where: { id: 'collection_1', userUid: user.uid }\n-    // and the collection doesn't belong to the user, it returns null\n-    mockPrisma.userCollection.findUnique.mockResolvedValueOnce(null);\n-\n-    const result = await publishedDocsService.createPublishedDoc(\n-      createArgs,\n-      user,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_INVALID_COLLECTION);\n-  });\n-\n-  test('should throw error when metadata is invalid JSON', async () => {\n-    mockPrisma.userCollection.findUnique.mockResolvedValueOnce({\n-      id: 'collection_1',\n-      userUid: user.uid,\n-    } as any);\n-\n-    const result = await publishedDocsService.createPublishedDoc(\n-      { ...createArgs, metadata: '{invalid' },\n-      user,\n-    );\n-    expect(E.isLeft(result)).toBe(true);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_CREATION_FAILED on database error', async () => {\n-    mockPrisma.userCollection.findUnique.mockResolvedValueOnce({\n-      id: 'collection_1',\n-      userUid: user.uid,\n-    } as any);\n-    mockPrisma.publishedDocs.create.mockRejectedValueOnce(\n-      new Error('Database error'),\n-    );\n-\n-    const result = await publishedDocsService.createPublishedDoc(\n-      createArgs,\n-      user,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_CREATION_FAILED);\n-  });\n-});\n-\n-describe('updatePublishedDoc', () => {\n-  const updateArgs: UpdatePublishedDocsArgs = {\n-    title: 'Updated API Documentation',\n-    version: '2.0.0',\n-    autoSync: false,\n-    metadata: '{\"key\": \"value\"}',\n-  };\n-\n-  test('should successfully update a published document with valid inputs', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n-    mockPrisma.publishedDocs.update.mockResolvedValueOnce({\n-      ...userPublishedDoc,\n-      title: updateArgs.title,\n-      version: updateArgs.version,\n-      autoSync: updateArgs.autoSync,\n-    });\n-\n-    const result = await publishedDocsService.updatePublishedDoc(\n-      userPublishedDoc.id,\n-      updateArgs,\n-      user,\n-    );\n-\n-    expect(E.isRight(result)).toBe(true);\n-    if (E.isRight(result)) {\n-      expect(result.right.title).toBe(updateArgs.title);\n-      expect(result.right.version).toBe(updateArgs.version);\n-      expect(result.right.autoSync).toBe(updateArgs.autoSync);\n-    }\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);\n-\n-    const result = await publishedDocsService.updatePublishedDoc(\n-      'invalid_id',\n-      updateArgs,\n-      user,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_UPDATE_FAILED when user does not have access', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({\n-      ...userPublishedDoc,\n-      creatorUid: 'different_user',\n-    });\n-\n-    const result = await publishedDocsService.updatePublishedDoc(\n-      userPublishedDoc.id,\n-      updateArgs,\n-      user,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_UPDATE_FAILED);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_UPDATE_FAILED when user is not OWNER or EDITOR of team', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n-    mockPrisma.team.findFirst.mockResolvedValueOnce(null);\n-\n-    const result = await publishedDocsService.updatePublishedDoc(\n-      teamPublishedDoc.id,\n-      updateArgs,\n-      user,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_UPDATE_FAILED);\n-  });\n-\n-  test('should successfully update team published document when user has OWNER role', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n-    mockPrisma.publishedDocs.update.mockResolvedValueOnce({\n-      ...teamPublishedDoc,\n-      title: updateArgs.title,\n-    });\n-\n-    const result = await publishedDocsService.updatePublishedDoc(\n-      teamPublishedDoc.id,\n-      updateArgs,\n-      user,\n-    );\n-\n-    expect(E.isRight(result)).toBe(true);\n-  });\n-\n-  test('should successfully update team published document when user has EDITOR role', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n-    mockPrisma.publishedDocs.update.mockResolvedValueOnce({\n-      ...teamPublishedDoc,\n-      title: updateArgs.title,\n-    });\n-\n-    const result = await publishedDocsService.updatePublishedDoc(\n-      teamPublishedDoc.id,\n-      updateArgs,\n-      user,\n-    );\n-\n-    expect(E.isRight(result)).toBe(true);\n-  });\n-\n-  test('should throw error when metadata is invalid JSON', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n-\n-    const result = await publishedDocsService.updatePublishedDoc(\n-      userPublishedDoc.id,\n-      { ...updateArgs, metadata: '{invalid' },\n-      user,\n-    );\n-    expect(E.isLeft(result)).toBe(true);\n-  });\n-\n-  test('should update only provided fields', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n-    mockPrisma.publishedDocs.update.mockResolvedValueOnce({\n-      ...userPublishedDoc,\n-      title: 'Only Title Updated',\n-    });\n-\n-    const result = await publishedDocsService.updatePublishedDoc(\n-      userPublishedDoc.id,\n-      { title: 'Only Title Updated' },\n-      user,\n-    );\n-\n-    expect(E.isRight(result)).toBe(true);\n-    if (E.isRight(result)) {\n-      expect(result.right.title).toBe('Only Title Updated');\n-    }\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_UPDATE_FAILED on database error', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n-    mockPrisma.publishedDocs.update.mockRejectedValueOnce(\n-      new Error('Database error'),\n-    );\n-\n-    const result = await publishedDocsService.updatePublishedDoc(\n-      userPublishedDoc.id,\n-      updateArgs,\n-      user,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_UPDATE_FAILED);\n-  });\n-});\n-\n-describe('deletePublishedDoc', () => {\n-  test('should successfully delete a user published document', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n-    mockPrisma.publishedDocs.delete.mockResolvedValueOnce(userPublishedDoc);\n-\n-    const result = await publishedDocsService.deletePublishedDoc(\n-      userPublishedDoc.id,\n-      user,\n-    );\n-    expect(result).toEqualRight(true);\n-  });\n-\n-  test('should successfully delete a team published document when user has OWNER role', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n-    mockPrisma.publishedDocs.delete.mockResolvedValueOnce(teamPublishedDoc);\n-\n-    const result = await publishedDocsService.deletePublishedDoc(\n-      teamPublishedDoc.id,\n-      user,\n-    );\n-    expect(result).toEqualRight(true);\n-  });\n-\n-  test('should successfully delete a team published document when user has EDITOR role', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n-    mockPrisma.publishedDocs.delete.mockResolvedValueOnce(teamPublishedDoc);\n-\n-    const result = await publishedDocsService.deletePublishedDoc(\n-      teamPublishedDoc.id,\n-      user,\n-    );\n-    expect(result).toEqualRight(true);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);\n-\n-    const result = await publishedDocsService.deletePublishedDoc(\n-      'invalid_id',\n-      user,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_DELETION_FAILED when user does not have access', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({\n-      ...userPublishedDoc,\n-      creatorUid: 'different_user',\n-    });\n-\n-    const result = await publishedDocsService.deletePublishedDoc(\n-      userPublishedDoc.id,\n-      user,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_DELETION_FAILED);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_DELETION_FAILED when user is not OWNER or EDITOR of team', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n-    mockPrisma.team.findFirst.mockResolvedValueOnce(null);\n-\n-    const result = await publishedDocsService.deletePublishedDoc(\n-      teamPublishedDoc.id,\n-      user,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_DELETION_FAILED);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_DELETION_FAILED on database error', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n-    mockPrisma.publishedDocs.delete.mockRejectedValueOnce(\n-      new Error('Database error'),\n-    );\n-\n-    const result = await publishedDocsService.deletePublishedDoc(\n-      userPublishedDoc.id,\n-      user,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_DELETION_FAILED);\n-  });\n-});\n-\n-describe('getPublishedDocsCreator', () => {\n-  test('should return the creator of a published document', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n-    mockPrisma.user.findUnique.mockResolvedValueOnce(user as any);\n-\n-    const result = await publishedDocsService.getPublishedDocsCreator(\n-      userPublishedDoc.id,\n-    );\n-\n-    const expectedUser = {\n-      ...user,\n-      currentGQLSession: JSON.stringify(user.currentGQLSession),\n-      currentRESTSession: JSON.stringify(user.currentRESTSession),\n-    };\n-\n-    expect(result).toEqualRight(expectedUser);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);\n-\n-    const result =\n-      await publishedDocsService.getPublishedDocsCreator('invalid_id');\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n-  });\n-});\n-\n-describe('getPublishedDocsCollection', () => {\n-  test('should return user collection for user workspace published document', async () => {\n-    const userCollection = {\n-      id: 'collection_1',\n-      userUid: user.uid,\n-      title: 'My Collection',\n-    };\n-\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n-    mockPrisma.userCollection.findUnique.mockResolvedValueOnce(\n-      userCollection as any,\n-    );\n-\n-    const result = await publishedDocsService.getPublishedDocsCollection(\n-      userPublishedDoc.id,\n-    );\n-    expect(result).toEqualRight(userCollection);\n-  });\n-\n-  test('should return team collection for team workspace published document', async () => {\n-    const teamCollection = {\n-      id: 'team_collection_1',\n-      teamID: 'team_1',\n-      title: 'Team Collection',\n-    };\n-\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n-    mockPrisma.teamCollection.findUnique.mockResolvedValueOnce(\n-      teamCollection as any,\n-    );\n-\n-    const result = await publishedDocsService.getPublishedDocsCollection(\n-      teamPublishedDoc.id,\n-    );\n-    expect(result).toEqualRight(teamCollection);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);\n-\n-    const result =\n-      await publishedDocsService.getPublishedDocsCollection('invalid_id');\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when user collection is not found', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(userPublishedDoc);\n-    mockPrisma.userCollection.findUnique.mockResolvedValueOnce(null);\n-\n-    const result = await publishedDocsService.getPublishedDocsCollection(\n-      userPublishedDoc.id,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_INVALID_COLLECTION);\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_INVALID_COLLECTION when team collection is not found', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(teamPublishedDoc);\n-    mockPrisma.teamCollection.findUnique.mockResolvedValueOnce(null);\n-\n-    const result = await publishedDocsService.getPublishedDocsCollection(\n-      teamPublishedDoc.id,\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_INVALID_COLLECTION);\n-  });\n-});\n-\n-describe('checkPublishedDocsAccess', () => {\n-  test('should return true for user workspace when user is the creator', async () => {\n-    const result = await publishedDocsService.checkPublishedDocsAccess(\n-      userPublishedDoc,\n-      user.uid,\n-    );\n-    expect(result).toBe(true);\n-  });\n-\n-  test('should return false for user workspace when user is not the creator', async () => {\n-    const result = await publishedDocsService.checkPublishedDocsAccess(\n-      userPublishedDoc,\n-      'different_user',\n-    );\n-    expect(result).toBe(false);\n-  });\n-\n-  test('should return true for team workspace when user has required role', async () => {\n-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n-\n-    const result = await publishedDocsService.checkPublishedDocsAccess(\n-      teamPublishedDoc,\n-      user.uid,\n-      [TeamAccessRole.OWNER],\n-    );\n-    expect(result).toBe(true);\n-  });\n-\n-  test('should return false for team workspace when user does not have required role', async () => {\n-    mockPrisma.team.findFirst.mockResolvedValueOnce(null);\n-\n-    const result = await publishedDocsService.checkPublishedDocsAccess(\n-      teamPublishedDoc,\n-      user.uid,\n-      [TeamAccessRole.OWNER],\n-    );\n-    expect(result).toBe(false);\n-  });\n-\n-  test('should check for VIEWER role by default', async () => {\n-    mockPrisma.team.findFirst.mockResolvedValueOnce({ id: 'team_1' } as any);\n-\n-    const result = await publishedDocsService.checkPublishedDocsAccess(\n-      teamPublishedDoc,\n-      user.uid,\n-    );\n-    expect(result).toBe(true);\n-\n-    expect(mockPrisma.team.findFirst).toHaveBeenCalledWith({\n-      where: {\n-        id: 'team_1',\n-        members: {\n-          some: {\n-            userUid: user.uid,\n-            role: {\n-              in: [\n-                TeamAccessRole.OWNER,\n-                TeamAccessRole.EDITOR,\n-                TeamAccessRole.VIEWER,\n-              ],\n-            },\n-          },\n-        },\n-      },\n-    });\n-  });\n-});\n-\n-describe('getPublishedDocByIDPublic', () => {\n-  test('should return collection data when autoSync is enabled for user workspace', async () => {\n-    const collectionData = {\n-      id: 'collection_1',\n-      name: 'Test Collection',\n-      folders: [],\n-      requests: [],\n-    };\n-\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({\n-      ...userPublishedDoc,\n-      autoSync: true,\n-    });\n-    mockUserCollectionService.exportUserCollectionToJSONObject.mockResolvedValueOnce(\n-      E.right(collectionData as any),\n-    );\n-\n-    const result = await publishedDocsService.getPublishedDocByIDPublic(\n-      userPublishedDoc.id,\n-      { tree: TreeLevel.FULL },\n-    );\n-\n-    expect(result).toMatchObject(\n-      E.right({\n-        ...userPublishedDocCasted,\n-        documentTree: JSON.stringify(collectionData),\n-      }),\n-    );\n-  });\n-\n-  test('should return collection data when autoSync is enabled for team workspace', async () => {\n-    const collectionData = {\n-      id: 'team_collection_1',\n-      name: 'Team Test Collection',\n-      folders: [],\n-      requests: [],\n-    };\n-\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({\n-      ...teamPublishedDoc,\n-      autoSync: true,\n-    });\n-    mockTeamCollectionService.exportCollectionToJSONObject.mockResolvedValueOnce(\n-      E.right(collectionData as any),\n-    );\n-\n-    const result = await publishedDocsService.getPublishedDocByIDPublic(\n-      teamPublishedDoc.id,\n-      { tree: TreeLevel.FULL },\n-    );\n-\n-    expect(result).toMatchObject(\n-      E.right({\n-        ...teamPublishedDocCasted,\n-        documentTree: JSON.stringify(collectionData),\n-      }),\n-    );\n-  });\n-\n-  test('should throw PUBLISHED_DOCS_NOT_FOUND when document ID is invalid', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce(null);\n-\n-    const result = await publishedDocsService.getPublishedDocByIDPublic(\n-      'invalid_id',\n-      { tree: TreeLevel.FULL },\n-    );\n-    expect(result).toEqualLeft(PUBLISHED_DOCS_NOT_FOUND);\n-  });\n-\n-  test('should call exportUserCollectionToJSONObject with correct parameters', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({\n-      ...userPublishedDoc,\n-      autoSync: true,\n-    });\n-    mockUserCollectionService.exportUserCollectionToJSONObject.mockResolvedValueOnce(\n-      E.right({} as any),\n-    );\n-\n-    await publishedDocsService.getPublishedDocByIDPublic(userPublishedDoc.id, {\n-      tree: TreeLevel.FULL,\n-    } as any);\n-\n-    expect(\n-      mockUserCollectionService.exportUserCollectionToJSONObject,\n-    ).toHaveBeenCalledWith(user.uid, 'collection_1', true);\n-  });\n-\n-  test('should call exportCollectionToJSONObject with correct parameters', async () => {\n-    mockPrisma.publishedDocs.findUnique.mockResolvedValueOnce({\n-      ...teamPublishedDoc,\n-      autoSync: true,\n-    });\n-    mockTeamCollectionService.exportCollectionToJSONObject.mockResolvedValueOnce(\n-      E.right({} as any),\n-    );\n-\n-    await publishedDocsService.getPublishedDocByIDPublic(teamPublishedDoc.id, {\n-      tree: TreeLevel.FULL,\n-    });\n-\n-    expect(\n-      mockTeamCollectionService.exportCollectionToJSONObject,\n-    ).toHaveBeenCalledWith('team_1', 'team_collection_1', true);\n-  });\n-});\n+    // When Prisma queries with\n\\ No newline at end of file\ndiff --git a/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts b/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts\nindex 43e5001..d162525 100644\n--- a/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts\n+++ b/packages/hoppscotch-backend/src/published-docs/published-docs.service.ts\n@@ -14,9 +14,8 @@ import {\n   PUBLISHED_DOCS_INVALID_COLLECTION,\n   PUBLISHED_DOCS_NOT_FOUND,\n   PUBLISHED_DOCS_UPDATE_FAILED,\n-  TEAM_INVALID_COLL_ID,\n   TEAM_INVALID_ID,\n-  USER_COLL_NOT_FOUND,\n+  USERS_NOT_FOUND,\n } from 'src/errors';\n import * as E from 'fp-ts/Either';\n import { PublishedDocs } from './published-docs.model';\n@@ -156,16 +155,9 @@ export class PublishedDocsService {\n     const user = await this.prisma.user.findUnique({\n       where: { uid: publishedDocs.creatorUid },\n     });\n+    if (!user) return E.left(USERS_NOT_FOUND);\n \n-    const creator = user\n-      ? {\n-          ...user,\n-          currentGQLSession: JSON.stringify(user.currentGQLSession),\n-          currentRESTSession: JSON.stringify(user.currentRESTSession),\n-        }\n-      : null;\n-\n-    return E.right(creator);\n+    return E.right(user);\n   }\n \n   /**\n@@ -243,20 +235,7 @@ export class PublishedDocsService {\n               query.tree === TreeLevel.FULL,\n             );\n \n-      if (E.isLeft(collectionResult)) {\n-        // Delete the published doc if its collection is missing\n-        const isCollectionNotFound =\n-          collectionResult.left === USER_COLL_NOT_FOUND ||\n-          collectionResult.left === TEAM_INVALID_COLL_ID;\n-\n-        if (isCollectionNotFound) {\n-          await this.prisma.publishedDocs.delete({\n-            where: { id: publishedDocs.id },\n-          });\n-        }\n-\n-        return E.left(collectionResult.left);\n-      }\n+      if (E.isLeft(collectionResult)) return E.left(collectionResult.left);\n \n       return E.right(\n         this.cast({\n@@ -269,26 +248,6 @@ export class PublishedDocsService {\n     return E.right(this.cast(publishedDocs));\n   }\n \n-  /**\n-   * Cleanup orphaned published documents whose collections no longer exist\n-   */\n-  private async cleanupOrphanedPublishedDocs<\n-    T extends { id: string; collectionID: string },\n-  >(docs: T[], existingCollectionIDs: Set<string>): Promise<T[]> {\n-    const docsToDelete = docs.filter(\n-      (doc) => !existingCollectionIDs.has(doc.collectionID),\n-    );\n-\n-    if (docsToDelete.length > 0) {\n-      const idsToDelete = docsToDelete.map((doc) => doc.id);\n-      this.prisma.publishedDocs.deleteMany({\n-        where: { id: { in: idsToDelete } },\n-      });\n-    }\n-\n-    return docs.filter((doc) => existingCollectionIDs.has(doc.collectionID));\n-  }\n-\n   /**\n    * Get all published documents for a user with pagination\n    * @param userUid - The UID of the user\n@@ -307,29 +266,7 @@ export class PublishedDocsService {\n       },\n     });\n \n-    if (docs.length === 0) return [];\n-\n-    // Cross-check if all collections exist\n-    const collectionIDs = docs.map((doc) => doc.collectionID);\n-    const existingCollections = await this.prisma.userCollection.findMany({\n-      where: {\n-        id: { in: collectionIDs },\n-        userUid,\n-      },\n-      select: { id: true },\n-    });\n-\n-    const existingCollectionIDs = new Set(\n-      existingCollections.map((col) => col.id),\n-    );\n-\n-    const validDocs = await this.cleanupOrphanedPublishedDocs<DbPublishedDocs>(\n-      docs,\n-      existingCollectionIDs,\n-    );\n-\n-    // Return only docs with existing collections\n-    return validDocs.map((doc) => this.cast(doc));\n+    return docs.map((doc) => this.cast(doc));\n   }\n \n   /**\n@@ -353,29 +290,7 @@ export class PublishedDocsService {\n       },\n     });\n \n-    if (docs.length === 0) return [];\n-\n-    // Cross-check if all collections exist\n-    const collectionIDs = docs.map((doc) => doc.collectionID);\n-    const existingCollections = await this.prisma.teamCollection.findMany({\n-      where: {\n-        id: { in: collectionIDs },\n-        teamID,\n-      },\n-      select: { id: true },\n-    });\n-\n-    const existingCollectionIDs = new Set(\n-      existingCollections.map((col) => col.id),\n-    );\n-\n-    const validDocs = await this.cleanupOrphanedPublishedDocs<DbPublishedDocs>(\n-      docs,\n-      existingCollectionIDs,\n-    );\n-\n-    // Return only docs with existing collections\n-    return validDocs.map((doc) => this.cast(doc));\n+    return docs.map((doc) => this.cast(doc));\n   }\n \n   /**\n@@ -503,13 +418,4 @@ export class PublishedDocsService {\n       if (!hasAccess) return E.left(PUBLISHED_DOCS_DELETION_FAILED);\n \n       await this.prisma.publishedDocs.delete({\n-        where: { id },\n-      });\n-\n-      return E.right(true);\n-    } catch (error) {\n-      console.error('Error deleting published document:', error);\n-      return E.left(PUBLISHED_DOCS_DELETION_FAILED);\n-    }\n-  }\n-}\n+        where: { id },\n\\ No newline at end of file\ndiff --git a/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts b/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts\nindex 270c441..69f850c 100644\n--- a/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts\n+++ b/packages/hoppscotch-backend/src/user-collection/user-collection.service.ts\n@@ -40,6 +40,7 @@ import {\n import { CollectionFolder } from 'src/types/CollectionFolder';\n import { PrismaError } from 'src/prisma/prisma-error-codes';\n import { SortOptions } from 'src/types/SortOptions';\n+import { UserRequest } from 'src/user-request/user-request.model';\n \n @Injectable()\n export class UserCollectionService {\n@@ -477,914 +478,4 @@ export class UserCollectionService {\n               // if parentCollectionID != null, collection becomes child collection\n               parentID: newParentID,\n               orderIndex: lastCollectionUnderNewParent\n-                ? lastCollectionUnderNewParent.orderIndex + 1\n-                : 1,\n-            },\n-          });\n-\n-          // decrement orderIndex of all next sibling collections from original collection\n-          await tx.userCollection.updateMany({\n-            where: {\n-              parentID: collection.parentID,\n-              orderIndex: { gt: collection.orderIndex },\n-            },\n-            data: { orderIndex: { decrement: 1 } },\n-          });\n-        } catch (error) {\n-          throw new ConflictException(error);\n-        }\n-      });\n-\n-      return E.right(updatedCollection);\n-    } catch (error) {\n-      console.error(\n-        'Error from UserCollectionService.changeParentAndUpdateOrderIndex:',\n-        error,\n-      );\n-      return E.left(USER_COLL_REORDERING_FAILED);\n-    }\n-  }\n-\n-  /**\n-   * Check if collection is parent of destCollection\n-   *\n-   * @param collection The ID of collection being moved\n-   * @param destCollection The ID of collection into which we are moving target collection into\n-   * @returns An Option of boolean, is parent or not\n-   */\n-  private async isParent(\n-    collection: UserCollection,\n-    destCollection: UserCollection,\n-  ): Promise<O.Option<boolean>> {\n-    // Check if collection and destCollection are same\n-    if (collection === destCollection) {\n-      return O.none;\n-    }\n-    if (destCollection.parentID !== null) {\n-      // Check if ID of collection is same as parent of destCollection\n-      if (destCollection.parentID === collection.id) {\n-        return O.none;\n-      }\n-      // Get collection details of collection one step above in the tree i.e the parent collection\n-      const parentCollection = await this.getUserCollection(\n-        destCollection.parentID,\n-      );\n-      if (E.isLeft(parentCollection)) {\n-        return O.none;\n-      }\n-      // Call isParent again now with parent collection\n-      return await this.isParent(collection, parentCollection.right);\n-    } else {\n-      return O.some(true);\n-    }\n-  }\n-\n-  /**\n-   * Delete collection and Update the OrderIndex of all collections in given parentID\n-   * @param collection The collection to delete\n-   * @param orderIndexCondition Condition to decide what collections will be updated\n-   * @param dataCondition Increment/Decrement OrderIndex condition\n-   * @returns A Collection with updated OrderIndexes\n-   */\n-  private async removeCollectionAndUpdateSiblingsOrderIndex(\n-    collection: UserCollection,\n-    orderIndexCondition: Prisma.IntFilter,\n-    dataCondition: Prisma.IntFieldUpdateOperationsInput,\n-  ) {\n-    let retryCount = 0;\n-    while (retryCount < this.MAX_RETRIES) {\n-      try {\n-        await this.prisma.$transaction(async (tx) => {\n-          try {\n-            // lock the rows\n-            await this.prisma.lockTableExclusive(tx, 'UserCollection');\n-\n-            await tx.userCollection.delete({\n-              where: { id: collection.id },\n-            });\n-\n-            // update orderIndexes\n-            await tx.userCollection.updateMany({\n-              where: {\n-                parentID: collection.parentID,\n-                orderIndex: orderIndexCondition,\n-              },\n-              data: { orderIndex: dataCondition },\n-            });\n-          } catch (error) {\n-            throw new ConflictException(error);\n-          }\n-        });\n-\n-        break;\n-      } catch (error) {\n-        console.error(\n-          'Error from UserCollectionService.updateOrderIndex:',\n-          error,\n-        );\n-        retryCount++;\n-        if (\n-          retryCount >= this.MAX_RETRIES ||\n-          (error.code !== PrismaError.UNIQUE_CONSTRAINT_VIOLATION &&\n-            error.code !== PrismaError.TRANSACTION_DEADLOCK &&\n-            error.code !== PrismaError.TRANSACTION_TIMEOUT) // return for all DB error except deadlocks, unique constraint violations, transaction timeouts\n-        )\n-          return E.left(USER_COLL_REORDERING_FAILED);\n-\n-        await delay(retryCount * 100);\n-        console.debug(`Retrying... (${retryCount})`);\n-      }\n-    }\n-\n-    return E.right(true);\n-  }\n-\n-  /**\n-   * Move UserCollection into root or another collection\n-   *\n-   * @param userCollectionID The ID of collection being moved\n-   * @param destCollectionID The ID of collection the target collection is being moved into or move target collection to root\n-   * @param userID The User UID\n-   * @returns An Either of the moved UserCollection\n-   */\n-  async moveUserCollection(\n-    userCollectionID: string,\n-    destCollectionID: string | null,\n-    userID: string,\n-  ) {\n-    // Get collection details of collectionID\n-    const collection = await this.getUserCollection(userCollectionID);\n-    if (E.isLeft(collection)) return E.left(USER_COLL_NOT_FOUND);\n-\n-    // Check to see is the collection belongs to the user\n-    if (collection.right.userUid !== userID) return E.left(USER_NOT_OWNER);\n-\n-    // destCollectionID == null i.e move collection to root\n-    if (!destCollectionID) {\n-      if (!collection.right.parentID) {\n-        // collection is a root collection\n-        // Throw error if collection is already a root collection\n-        return E.left(USER_COLL_ALREADY_ROOT);\n-      }\n-\n-      // Change parent from child to root i.e child collection becomes a root collection\n-      // Move child collection into root and update orderIndexes for child userCollections\n-      const updatedCollection = await this.changeParentAndUpdateOrderIndex(\n-        collection.right,\n-        null,\n-      );\n-      if (E.isLeft(updatedCollection)) return E.left(updatedCollection.left);\n-\n-      this.pubsub.publish(\n-        `user_coll/${collection.right.userUid}/moved`,\n-        this.cast(updatedCollection.right),\n-      );\n-\n-      return E.right(this.cast(updatedCollection.right));\n-    }\n-\n-    // destCollectionID != null i.e move into another collection\n-    if (userCollectionID === destCollectionID) {\n-      // Throw error if collectionID and destCollectionID are the same\n-      return E.left(USER_COLL_DEST_SAME);\n-    }\n-\n-    // Get collection details of destCollectionID\n-    const destCollection = await this.getUserCollection(destCollectionID);\n-    if (E.isLeft(destCollection)) return E.left(USER_COLL_NOT_FOUND);\n-\n-    // Check if collection and destCollection belong to the same collection type\n-    if (collection.right.type !== destCollection.right.type) {\n-      return E.left(USER_COLL_NOT_SAME_TYPE);\n-    }\n-\n-    // Check if collection and destCollection belong to the same user account\n-    if (collection.right.userUid !== destCollection.right.userUid) {\n-      return E.left(USER_COLL_NOT_SAME_USER);\n-    }\n-\n-    // Check if collection is present on the parent tree for destCollection\n-    const checkIfParent = await this.isParent(\n-      collection.right,\n-      destCollection.right,\n-    );\n-    if (O.isNone(checkIfParent)) {\n-      return E.left(USER_COLL_IS_PARENT_COLL);\n-    }\n-\n-    // Change parent from null to teamCollection i.e collection becomes a child collection\n-    // Move root/child collection into another child collection and update orderIndexes of the previous parent\n-    const updatedCollection = await this.changeParentAndUpdateOrderIndex(\n-      collection.right,\n-      destCollection.right.id,\n-    );\n-    if (E.isLeft(updatedCollection)) return E.left(updatedCollection.left);\n-\n-    this.pubsub.publish(\n-      `user_coll/${collection.right.userUid}/moved`,\n-      this.cast(updatedCollection.right),\n-    );\n-\n-    return E.right(this.cast(updatedCollection.right));\n-  }\n-\n-  /**\n-   * Find the number of child collections present in collectionID\n-   *\n-   * @param collectionID The Collection ID\n-   * @returns Number of collections\n-   */\n-  getCollectionCount(collectionID: string): Promise<number> {\n-    return this.prisma.userCollection.count({\n-      where: { parentID: collectionID },\n-    });\n-  }\n-\n-  /**\n-   * Update order of root or child collectionID's\n-   *\n-   * @param collectionID The ID of collection being re-ordered\n-   * @param nextCollectionID The ID of collection that is after the moved collection in its new position\n-   * @param userID The User UID\n-   * @returns If successful return an Either of true\n-   */\n-  async updateUserCollectionOrder(\n-    collectionID: string,\n-    nextCollectionID: string | null,\n-    userID: string,\n-  ) {\n-    // Throw error if collectionID and nextCollectionID are the same\n-    if (collectionID === nextCollectionID)\n-      return E.left(USER_COLL_SAME_NEXT_COLL);\n-\n-    // Get collection details of collectionID\n-    const collection = await this.getUserCollection(collectionID);\n-    if (E.isLeft(collection)) return E.left(USER_COLL_NOT_FOUND);\n-\n-    // Check to see is the collection belongs to the user\n-    if (collection.right.userUid !== userID) return E.left(USER_NOT_OWNER);\n-\n-    if (!nextCollectionID) {\n-      // nextCollectionID == null i.e move collection to the end of the list\n-      try {\n-        await this.prisma.$transaction(async (tx) => {\n-          try {\n-            // Step 0: lock the rows\n-            await this.prisma.acquireLocks(\n-              tx,\n-              'UserCollection',\n-              userID,\n-              collection.right.parentID,\n-            );\n-\n-            // Step 1: Decrement orderIndex of all items that come after collection.orderIndex till end of list of items\n-            const collectionInTx = await tx.userCollection.findFirst({\n-              where: { id: collectionID },\n-              select: { orderIndex: true },\n-            });\n-            await tx.userCollection.updateMany({\n-              where: {\n-                parentID: collection.right.parentID,\n-                orderIndex: { gte: collectionInTx.orderIndex + 1 },\n-              },\n-              data: { orderIndex: { decrement: 1 } },\n-            });\n-\n-            // Step 2: Update orderIndex of collection to length of list\n-            await tx.userCollection.update({\n-              where: { id: collection.right.id },\n-              data: {\n-                orderIndex: await this.getCollectionCount(\n-                  collection.right.parentID,\n-                ),\n-              },\n-            });\n-          } catch (error) {\n-            throw new ConflictException(error);\n-          }\n-        });\n-\n-        this.pubsub.publish(\n-          `user_coll/${collection.right.userUid}/order_updated`,\n-          {\n-            userCollection: this.cast(collection.right),\n-            nextUserCollection: null,\n-          },\n-        );\n-\n-        return E.right(true);\n-      } catch (error) {\n-        return E.left(USER_COLL_REORDERING_FAILED);\n-      }\n-    }\n-\n-    // nextCollectionID != null i.e move to a certain position\n-    // Get collection details of nextCollectionID\n-    const subsequentCollection = await this.getUserCollection(nextCollectionID);\n-    if (E.isLeft(subsequentCollection)) return E.left(USER_COLL_NOT_FOUND);\n-\n-    if (collection.right.userUid !== subsequentCollection.right.userUid)\n-      return E.left(USER_COLL_NOT_SAME_USER);\n-\n-    // Check if collection and subsequentCollection belong to the same collection type\n-    if (collection.right.type !== subsequentCollection.right.type) {\n-      return E.left(USER_COLL_NOT_SAME_TYPE);\n-    }\n-\n-    try {\n-      await this.prisma.$transaction(async (tx) => {\n-        try {\n-          // Step 0: lock the rows\n-          await this.prisma.acquireLocks(\n-            tx,\n-            'UserCollection',\n-            userID,\n-            subsequentCollection.right.parentID,\n-          );\n-\n-          // subsequentCollectionInTx and subsequentCollection are same, just to make sure, orderIndex value is concrete\n-          const collectionInTx = await tx.userCollection.findFirst({\n-            where: { id: collectionID },\n-            select: { orderIndex: true },\n-          });\n-          const subsequentCollectionInTx = await tx.userCollection.findFirst({\n-            where: { id: nextCollectionID },\n-            select: { orderIndex: true },\n-          });\n-\n-          // Step 1: Determine if we are moving collection up or down the list\n-          const isMovingUp =\n-            subsequentCollectionInTx.orderIndex < collectionInTx.orderIndex;\n-\n-          // Step 2: Update OrderIndex of items in list depending on moving up or down\n-          const updateFrom = isMovingUp\n-            ? subsequentCollectionInTx.orderIndex\n-            : collectionInTx.orderIndex + 1;\n-\n-          const updateTo = isMovingUp\n-            ? collectionInTx.orderIndex - 1\n-            : subsequentCollectionInTx.orderIndex - 1;\n-\n-          await tx.userCollection.updateMany({\n-            where: {\n-              parentID: collection.right.parentID,\n-              orderIndex: { gte: updateFrom, lte: updateTo },\n-            },\n-            data: {\n-              orderIndex: isMovingUp ? { increment: 1 } : { decrement: 1 },\n-            },\n-          });\n-\n-          // Step 3: Update OrderIndex of collection\n-          await tx.userCollection.update({\n-            where: { id: collection.right.id },\n-            data: {\n-              orderIndex: isMovingUp\n-                ? subsequentCollectionInTx.orderIndex\n-                : subsequentCollectionInTx.orderIndex - 1,\n-            },\n-          });\n-        } catch (error) {\n-          throw new ConflictException(error);\n-        }\n-      });\n-\n-      this.pubsub.publish(\n-        `user_coll/${collection.right.userUid}/order_updated`,\n-        {\n-          userCollection: this.cast(collection.right),\n-          nextUserCollection: this.cast(subsequentCollection.right),\n-        },\n-      );\n-\n-      return E.right(true);\n-    } catch (error) {\n-      return E.left(USER_COLL_REORDERING_FAILED);\n-    }\n-  }\n-\n-  /**\n-   * Generate a JSON containing all the contents of a collection\n-   *\n-   * @param userUID The User UID\n-   * @param collectionID The Collection ID\n-   * @param withChildren Whether to include child collections and their requests\n-   * @returns A JSON string containing all the contents of a collection\n-   */\n-  async exportUserCollectionToJSONObject(\n-    userUID: string,\n-    collectionID: string,\n-    withChildren: boolean = true,\n-  ): Promise<E.Left<string> | E.Right<CollectionFolder>> {\n-    // Get Collection details\n-    const collection = await this.getUserCollection(collectionID);\n-    if (E.isLeft(collection)) return E.left(collection.left);\n-\n-    const childrenCollectionObjects: CollectionFolder[] = [];\n-    if (withChildren) {\n-      // Get all child collections whose parentID === collectionID\n-      const childCollectionList = await this.prisma.userCollection.findMany({\n-        where: {\n-          parentID: collectionID,\n-          userUid: userUID,\n-        },\n-        orderBy: {\n-          orderIndex: 'asc',\n-        },\n-      });\n-\n-      // Create a list of child collection and request data ready for export\n-      for (const coll of childCollectionList) {\n-        const result = await this.exportUserCollectionToJSONObject(\n-          userUID,\n-          coll.id,\n-        );\n-        if (E.isLeft(result)) return E.left(result.left);\n-\n-        childrenCollectionObjects.push(result.right);\n-      }\n-    }\n-\n-    // Fetch all child requests that belong to collectionID\n-    const requests = await this.prisma.userRequest.findMany({\n-      where: {\n-        userUid: userUID,\n-        collectionID,\n-      },\n-      orderBy: {\n-        orderIndex: 'asc',\n-      },\n-    });\n-\n-    const data = transformCollectionData(collection.right.data);\n-\n-    const result: CollectionFolder = {\n-      id: collection.right.id,\n-      name: collection.right.title,\n-      folders: childrenCollectionObjects,\n-      requests: requests.map((x) => {\n-        return {\n-          id: x.id,\n-          name: x.title,\n-          ...(x.request as Record<string, unknown>), // type casting x.request of type Prisma.JSONValue to an object to enable spread\n-        };\n-      }),\n-      data,\n-    };\n-\n-    return E.right(result);\n-  }\n-\n-  /**\n-   * Generate a JSON containing all the contents of collections and requests of a team\n-   *\n-   * @param userUID The User UID\n-   * @returns A JSON string containing all the contents of collections and requests of a team\n-   */\n-  async exportUserCollectionsToJSON(\n-    userUID: string,\n-    collectionID: string | null,\n-    reqType: ReqType,\n-  ) {\n-    // Get all child collections details\n-    const childCollectionList = await this.prisma.userCollection.findMany({\n-      where: {\n-        userUid: userUID,\n-        parentID: collectionID,\n-        type: reqType,\n-      },\n-      orderBy: {\n-        orderIndex: 'asc',\n-      },\n-    });\n-\n-    // Create a list of child collection and request data ready for export\n-    const collectionListObjects: CollectionFolder[] = [];\n-    for (const coll of childCollectionList) {\n-      const result = await this.exportUserCollectionToJSONObject(\n-        userUID,\n-        coll.id,\n-      );\n-      if (E.isLeft(result)) return E.left(result.left);\n-\n-      collectionListObjects.push(result.right);\n-    }\n-\n-    // If collectionID is not null, return JSON stringified data for specific collection\n-    if (collectionID) {\n-      // Get Details of collection\n-      const parentCollection = await this.getUserCollection(collectionID);\n-      if (E.isLeft(parentCollection)) return E.left(parentCollection.left);\n-\n-      if (parentCollection.right.type !== reqType)\n-        return E.left(USER_COLL_NOT_SAME_TYPE);\n-\n-      // Fetch all child requests that belong to collectionID\n-      const requests = await this.prisma.userRequest.findMany({\n-        where: {\n-          userUid: userUID,\n-          collectionID: parentCollection.right.id,\n-        },\n-        orderBy: {\n-          orderIndex: 'asc',\n-        },\n-      });\n-\n-      return E.right(<UserCollectionExportJSONData>{\n-        exportedCollection: JSON.stringify({\n-          id: parentCollection.right.id,\n-          name: parentCollection.right.title,\n-          folders: collectionListObjects,\n-          requests: requests.map((x) => {\n-            return {\n-              id: x.id,\n-              name: x.title,\n-              ...(x.request as Record<string, unknown>), // type casting x.request of type Prisma.JSONValue to an object to enable spread\n-            };\n-          }),\n-          data: JSON.stringify(parentCollection.right.data),\n-        }),\n-        collectionType: parentCollection.right.type,\n-      });\n-    }\n-\n-    return E.right(<UserCollectionExportJSONData>{\n-      exportedCollection: JSON.stringify(collectionListObjects),\n-      collectionType: reqType,\n-    });\n-  }\n-\n-  /**\n-   * Generate a Prisma query object representation of a collection and its child collections and requests\n-   *\n-   * @param folder CollectionFolder from client\n-   * @param userID The User ID\n-   * @param orderIndex Initial OrderIndex of\n-   * @param reqType The Type of Collection\n-   * @returns A Prisma query object to create a collection, its child collections and requests\n-   */\n-  private generatePrismaQueryObj(\n-    folder: CollectionFolder,\n-    userID: string,\n-    orderIndex: number,\n-    reqType: DBReqType,\n-  ): Prisma.UserCollectionCreateInput {\n-    // Parse collection data if it exists\n-    let data = null;\n-    if (folder.data) {\n-      try {\n-        data =\n-          typeof folder.data === 'string'\n-            ? JSON.parse(folder.data)\n-            : folder.data;\n-      } catch (error) {\n-        // If data parsing fails, log error and continue without data\n-        console.error('Failed to parse collection data:', error);\n-      }\n-    }\n-\n-    return {\n-      title: folder.name,\n-      data,\n-      user: {\n-        connect: {\n-          uid: userID,\n-        },\n-      },\n-      requests: {\n-        create: folder.requests.map((r, index) => ({\n-          title: r.name,\n-          user: {\n-            connect: {\n-              uid: userID,\n-            },\n-          },\n-          type: reqType,\n-          request: r,\n-          orderIndex: index + 1,\n-        })),\n-      },\n-      orderIndex: orderIndex,\n-      type: reqType,\n-      children: {\n-        create: folder.folders.map((f, index) =>\n-          this.generatePrismaQueryObj(f, userID, index + 1, reqType),\n-        ),\n-      },\n-    };\n-  }\n-\n-  /**\n-   * Create new UserCollections and UserRequests from JSON string\n-   *\n-   * @param jsonString The JSON string of the content\n-   * @param userID The User ID\n-   * @param destCollectionID The Collection ID\n-   * @param reqType The Type of Collection\n-   * @param isCollectionDuplication Boolean to publish collection create event on designated channel\n-   * @returns An Either of a Boolean if the creation operation was successful\n-   */\n-  async importCollectionsFromJSON(\n-    jsonString: string,\n-    userID: string,\n-    destCollectionID: string | null,\n-    reqType: DBReqType,\n-    isCollectionDuplication = false,\n-  ) {\n-    // Check to see if jsonString is valid\n-    const collectionsList = stringToJson<CollectionFolder[]>(jsonString);\n-    if (E.isLeft(collectionsList)) return E.left(USER_COLL_INVALID_JSON);\n-\n-    // Check to see if parsed jsonString is an array\n-    if (!Array.isArray(collectionsList.right))\n-      return E.left(USER_COLL_INVALID_JSON);\n-\n-    // Check to see if destCollectionID belongs to this User\n-    if (destCollectionID) {\n-      const parentCollection = await this.getUserCollection(destCollectionID);\n-      if (E.isLeft(parentCollection)) return E.left(parentCollection.left);\n-\n-      // Check to see if parentUserCollectionID belongs to this User\n-      if (parentCollection.right.userUid !== userID)\n-        return E.left(USER_NOT_OWNER);\n-\n-      // Check to see if parent collection is of the same type of new collection being created\n-      if (parentCollection.right.type !== reqType)\n-        return E.left(USER_COLL_NOT_SAME_TYPE);\n-    }\n-\n-    let userCollections: UserCollection[] = [];\n-\n-    try {\n-      await this.prisma.$transaction(async (tx) => {\n-        try {\n-          // lock the rows\n-          await this.prisma.lockTableExclusive(tx, 'UserCollection');\n-\n-          // Get the last order index\n-          const lastCollection = await tx.userCollection.findFirst({\n-            where: { userUid: userID, parentID: destCollectionID },\n-            orderBy: { orderIndex: 'desc' },\n-          });\n-          let lastOrderIndex = lastCollection ? lastCollection.orderIndex : 0;\n-\n-          // Generate Prisma Query Object for all child collections in collectionsList\n-          const queryList = collectionsList.right.map((x) =>\n-            this.generatePrismaQueryObj(x, userID, ++lastOrderIndex, reqType),\n-          );\n-\n-          const parent = destCollectionID\n-            ? { connect: { id: destCollectionID } }\n-            : undefined;\n-\n-          const promises = queryList.map((query) =>\n-            tx.userCollection.create({\n-              data: { ...query, parent },\n-            }),\n-          );\n-\n-          userCollections = await Promise.all(promises);\n-        } catch (error) {\n-          throw new ConflictException(error);\n-        }\n-      });\n-    } catch (error) {\n-      return E.left(USER_COLLECTION_CREATION_FAILED);\n-    }\n-\n-    // Fetch nested collections after transaction is committed\n-    const importedCollectionsWithChildren: CollectionFolder[] = [];\n-    for (const userCollection of userCollections) {\n-      const exportedCollectionJSON =\n-        await this.exportUserCollectionToJSONObject(userID, userCollection.id);\n-      if (E.isLeft(exportedCollectionJSON))\n-        return E.left(exportedCollectionJSON.left);\n-      importedCollectionsWithChildren.push(exportedCollectionJSON.right);\n-    }\n-\n-    if (isCollectionDuplication) {\n-      const duplicatedCollectionData = await this.fetchCollectionData(\n-        userCollections[0].id,\n-      );\n-      if (E.isRight(duplicatedCollectionData)) {\n-        this.pubsub.publish(\n-          `user_coll/${userID}/duplicated`,\n-          duplicatedCollectionData.right,\n-        );\n-      }\n-    } else {\n-      userCollections.forEach((collection) =>\n-        this.pubsub.publish(\n-          `user_coll/${userID}/created`,\n-          this.cast(collection),\n-        ),\n-      );\n-    }\n-\n-    return E.right({\n-      exportedCollection: JSON.stringify(importedCollectionsWithChildren),\n-      collectionType: reqType,\n-    } as UserCollectionExportJSONData);\n-  }\n-\n-  /**\n-   * Update a UserCollection\n-   *\n-   * @param newTitle The new title of collection\n-   * @param userCollectionID The Collection Id\n-   * @param userID The User UID\n-   * @returns An Either of the updated UserCollection\n-   */\n-  async updateUserCollection(\n-    newTitle: string = null,\n-    collectionData: string | null = null,\n-    userCollectionID: string,\n-    userID: string,\n-  ) {\n-    if (collectionData === '') return E.left(USER_COLL_DATA_INVALID);\n-\n-    if (collectionData) {\n-      const jsonReq = stringToJson(collectionData);\n-      if (E.isLeft(jsonReq)) return E.left(USER_COLL_DATA_INVALID);\n-      collectionData = jsonReq.right;\n-    }\n-\n-    if (newTitle != null) {\n-      const isTitleValid = isValidLength(newTitle, this.TITLE_LENGTH);\n-      if (!isTitleValid) return E.left(USER_COLL_SHORT_TITLE);\n-    }\n-\n-    // Check to see is the collection belongs to the user\n-    const isOwner = await this.isOwnerCheck(userCollectionID, userID);\n-    if (O.isNone(isOwner)) return E.left(USER_NOT_OWNER);\n-\n-    try {\n-      const updatedUserCollection = await this.prisma.userCollection.update({\n-        where: {\n-          id: userCollectionID,\n-        },\n-        data: {\n-          data: collectionData ?? undefined,\n-          title: newTitle ?? undefined,\n-        },\n-      });\n-\n-      this.pubsub.publish(\n-        `user_coll/${updatedUserCollection.userUid}/updated`,\n-        this.cast(updatedUserCollection),\n-      );\n-\n-      return E.right(this.cast(updatedUserCollection));\n-    } catch (error) {\n-      return E.left(USER_COLL_NOT_FOUND);\n-    }\n-  }\n-\n-  /**\n-   * Duplicate a User Collection\n-   *\n-   * @param collectionID The Collection ID\n-   * @returns Boolean of duplication status\n-   */\n-  async duplicateUserCollection(\n-    collectionID: string,\n-    userID: string,\n-    reqType: DBReqType,\n-  ) {\n-    const collection = await this.getUserCollection(collectionID);\n-    if (E.isLeft(collection)) return E.left(USER_COLL_NOT_FOUND);\n-\n-    if (collection.right.userUid !== userID) return E.left(USER_NOT_OWNER);\n-    if (collection.right.type !== reqType)\n-      return E.left(USER_COLL_NOT_SAME_TYPE);\n-\n-    const collectionJSONObject = await this.exportUserCollectionToJSONObject(\n-      collection.right.userUid,\n-      collectionID,\n-    );\n-    if (E.isLeft(collectionJSONObject))\n-      return E.left(collectionJSONObject.left);\n-\n-    const result = await this.importCollectionsFromJSON(\n-      JSON.stringify([\n-        {\n-          ...collectionJSONObject.right,\n-          name: `${collection.right.title} - Duplicate`,\n-        },\n-      ]),\n-      userID,\n-      collection.right.parentID,\n-      reqType,\n-      true,\n-    );\n-    if (E.isLeft(result)) return E.left(result.left as string);\n-\n-    return E.right(true);\n-  }\n-\n-  /**\n-   * Generates a JSON containing all the contents of a collection\n-   *\n-   * @param collection Collection whose details we want to fetch\n-   * @returns A JSON string containing all the contents of a collection\n-   */\n-  private async fetchCollectionData(\n-    collectionID: string,\n-  ): Promise<E.Left<string> | E.Right<UserCollectionDuplicatedData>> {\n-    const collection = await this.getUserCollection(collectionID);\n-    if (E.isLeft(collection)) return E.left(collection.left);\n-\n-    const { id, title, data, type, parentID, userUid } = collection.right;\n-    const orderIndex = 'asc';\n-\n-    const [childCollections, requests] = await Promise.all([\n-      this.prisma.userCollection.findMany({\n-        where: { parentID: id },\n-        orderBy: { orderIndex },\n-      }),\n-      this.prisma.userRequest.findMany({\n-        where: { collectionID: id },\n-        orderBy: { orderIndex },\n-      }),\n-    ]);\n-\n-    const childCollectionDataList = await Promise.all(\n-      childCollections.map(({ id }) => this.fetchCollectionData(id)),\n-    );\n-\n-    const failedChildData = childCollectionDataList.find(E.isLeft);\n-    if (failedChildData) return E.left(failedChildData.left);\n-\n-    const childCollectionsJSONStr = JSON.stringify(\n-      (childCollectionDataList as E.Right<UserCollectionDuplicatedData>[]).map(\n-        (childCollection) => childCollection.right,\n-      ),\n-    );\n-\n-    const transformedRequests = requests.map((requestObj) => ({\n-      ...requestObj,\n-      request: JSON.stringify(requestObj.request),\n-    }));\n-\n-    return E.right(<UserCollectionDuplicatedData>{\n-      id,\n-      title,\n-      data,\n-      type,\n-      parentID,\n-      userID: userUid,\n-      childCollections: childCollectionsJSONStr,\n-      requests: transformedRequests,\n-    });\n-  }\n-\n-  /**\n-   * Sort collections in a parent collection\n-   * @param userID The User UID\n-   * @param parentID The ID of the parent collection or null for root collections\n-   * @param sortBy The sorting option\n-   * @returns An Either of a Boolean if the sorting operation was successful\n-   */\n-  async sortUserCollections(\n-    userID: string,\n-    parentID: string | null,\n-    sortBy: SortOptions,\n-  ) {\n-    // Handle all sort options, including a default\n-    let orderBy: Prisma.Enumerable<Prisma.UserCollectionOrderByWithRelationInput>;\n-    if (sortBy === SortOptions.TITLE_ASC) {\n-      orderBy = { title: 'asc' };\n-    } else if (sortBy === SortOptions.TITLE_DESC) {\n-      orderBy = { title: 'desc' };\n-    } else {\n-      orderBy = { orderIndex: 'asc' };\n-    }\n-\n-    try {\n-      await this.prisma.$transaction(async (tx) => {\n-        await this.prisma.acquireLocks(tx, 'UserCollection', userID, parentID);\n-\n-        const collections = await tx.userCollection.findMany({\n-          where: { userUid: userID, parentID },\n-          orderBy,\n-          select: { id: true },\n-        });\n-\n-        const promises = collections.map((coll, index) =>\n-          tx.userCollection.update({\n-            where: { id: coll.id },\n-            data: { orderIndex: index + 1 },\n-          }),\n-        );\n-        await Promise.all(promises);\n-      });\n-    } catch (error) {\n-      console.error('Error from UserCollectionService.sortUserCollections:', {\n-        error,\n-      });\n-      return E.left(USER_COLL_REORDERING_FAILED);\n-    }\n-\n-    return E.right(true);\n-  }\n-}\n+                ? lastCollectionUnderNewPar\n\\ No newline at end of file\n",
    "pr_number": 5624,
    "title": "hotfix: clean up published docs with deleted collections",
    "test_files": [
      "packages/hoppscotch-backend/src/published-docs/published-docs.service.spec.ts"
    ],
    "code_files": [
      "packages/hoppscotch-backend/src/published-docs/published-docs.resolver.ts",
      "packages/hoppscotch-backend/src/published-docs/published-docs.service.ts",
      "packages/hoppscotch-backend/src/user-collection/user-collection.service.ts"
    ]
  },
  {
    "instance_id": "dubinc__dub.main.3171",
    "repo": "dubinc/dub",
    "base_commit": "d126bfc73138f802e31d8f4a262cc32d683a3211",
    "bug_patch": "diff --git a/apps/web/lib/middleware/utils/get-identity-hash.ts b/apps/web/lib/middleware/utils/get-identity-hash.ts\nindex 4609fff..e40203a 100644\n--- a/apps/web/lib/middleware/utils/get-identity-hash.ts\n+++ b/apps/web/lib/middleware/utils/get-identity-hash.ts\n@@ -1,12 +1,25 @@\n import { LOCALHOST_IP, hashStringSHA256 } from \"@dub/utils\";\n import { ipAddress } from \"@vercel/functions\";\n import { userAgent } from \"next/server\";\n+import { DUB_TEST_IDENTITY_HEADER } from \"tests/utils/resource\";\n \n /**\n  * Combine IP + UA to create a unique identifier for the user (for deduplication)\n  */\n export async function getIdentityHash(req: Request) {\n+  // If provided, use this identity directly (for E2E)\n+  if (\n+    process.env.NODE_ENV === \"development\" ||\n+    process.env.VERCEL_ENV === \"preview\"\n+  ) {\n+    const testOverride = req.headers.get(DUB_TEST_IDENTITY_HEADER);\n+\n+    if (testOverride) {\n+      return await hashStringSHA256(testOverride);\n+    }\n+  }\n+\n   const ip = ipAddress(req) || LOCALHOST_IP;\n   const ua = userAgent(req);\n   return await hashStringSHA256(`${ip}-${ua.ua}`);\n-}\n+}\n\\ No newline at end of file\ndiff --git a/apps/web/tests/fraud/index.test.ts b/apps/web/tests/fraud/index.test.ts\nindex d784a54..ef1277e 100644\n--- a/apps/web/tests/fraud/index.test.ts\n+++ b/apps/web/tests/fraud/index.test.ts\n@@ -1,15 +1,14 @@\n-import { Customer, TrackLeadResponse } from \"@/lib/types\";\n-import { fraudEventSchemas } from \"@/lib/zod/schemas/fraud\";\n+import { Customer, fraudEventGroupProps, TrackLeadResponse } from \"@/lib/types\";\n import { FraudRuleType } from \"@prisma/client\";\n-import { randomCustomer, retry } from \"tests/utils/helpers\";\n+import { randomCustomer, randomId, retry } from \"tests/utils/helpers\";\n import { HttpClient } from \"tests/utils/http\";\n import {\n+  DUB_TEST_IDENTITY_HEADER,\n   E2E_FRAUD_PARTNER,\n   E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN,\n   E2E_TRACK_CLICK_HEADERS,\n } from \"tests/utils/resource\";\n import { describe, expect, test } from \"vitest\";\n-import { z } from \"zod\";\n import { IntegrationHarness } from \"../utils/integration\";\n \n describe.concurrent(\"/fraud/**\", async () => {\n@@ -17,13 +16,14 @@ describe.concurrent(\"/fraud/**\", async () => {\n   const { http } = await h.init();\n \n   test(\"FraudRuleType = customerEmailMatch\", async () => {\n-    const clickLink = E2E_FRAUD_PARTNER.links.customerEmailMatch;\n+    const clickLink = E2E_FRAUD_PARTNER.link;\n \n     // Track a click\n     const clickResponse = await http.post<{ clickId: string }>({\n       path: \"/track/click\",\n       headers: {\n         ...E2E_TRACK_CLICK_HEADERS,\n+        [DUB_TEST_IDENTITY_HEADER]: randomId(10),\n       },\n       body: {\n         domain: clickLink.domain,\n@@ -59,13 +59,14 @@ describe.concurrent(\"/fraud/**\", async () => {\n   });\n \n   test(\"FraudRuleType = customerEmailSuspiciousDomain\", async () => {\n-    const clickLink = E2E_FRAUD_PARTNER.links.customerEmailSuspiciousDomain;\n+    const clickLink = E2E_FRAUD_PARTNER.link;\n \n     // Track a click\n     const clickResponse = await http.post<{ clickId: string }>({\n       path: \"/track/click\",\n       headers: {\n         ...E2E_TRACK_CLICK_HEADERS,\n+        [DUB_TEST_IDENTITY_HEADER]: randomId(10),\n       },\n       body: {\n         domain: clickLink.domain,\n@@ -98,7 +99,7 @@ describe.concurrent(\"/fraud/**\", async () => {\n   });\n \n   test(\"FraudRuleType = referralSourceBanned\", async () => {\n-    const clickLink = E2E_FRAUD_PARTNER.links.referralSourceBanned;\n+    const clickLink = E2E_FRAUD_PARTNER.link;\n \n     // Track a click\n     const clickResponse = await http.post<{ clickId: string }>({\n@@ -106,6 +107,7 @@ describe.concurrent(\"/fraud/**\", async () => {\n       headers: {\n         ...E2E_TRACK_CLICK_HEADERS,\n         referer: `https://${E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN}`,\n+        [DUB_TEST_IDENTITY_HEADER]: randomId(10),\n       },\n       body: {\n         domain: clickLink.domain,\n@@ -138,13 +140,14 @@ describe.concurrent(\"/fraud/**\", async () => {\n   });\n \n   test(\"FraudRuleType = paidTrafficDetected\", async () => {\n-    const clickLink = E2E_FRAUD_PARTNER.links.paidTrafficDetected;\n+    const clickLink = E2E_FRAUD_PARTNER.link;\n \n     // Track a click\n     const clickResponse = await http.post<{ clickId: string }>({\n       path: \"/track/click\",\n       headers: {\n         ...E2E_TRACK_CLICK_HEADERS,\n+        [DUB_TEST_IDENTITY_HEADER]: randomId(10),\n       },\n       body: {\n         domain: clickLink.domain,\n@@ -237,7 +240,7 @@ async function waitForFraudEvent({\n   return await retry(\n     async () => {\n       const { data } = await http.get<\n-        z.infer<(typeof fraudEventSchemas)[keyof typeof fraudEventSchemas]>[]\n+        fraudEventGroupProps[]\n       >({\n         path: \"/fraud/events\",\n         query: {\n@@ -254,4 +257,4 @@ async function waitForFraudEvent({\n     },\n     { retries: 10, interval: 600 },\n   );\n-}\n+}\n\\ No newline at end of file\ndiff --git a/apps/web/tests/utils/resource.ts b/apps/web/tests/utils/resource.ts\nindex 94685c4..15b0dcc 100644\n--- a/apps/web/tests/utils/resource.ts\n+++ b/apps/web/tests/utils/resource.ts\n@@ -8,6 +8,16 @@ export const E2E_LINK = {\n   url: \"https://github.com/dubinc\",\n };\n \n+/**\n+ * Used exclusively in E2E tests to override the computed identity hash.\n+ * When this header is present, `getIdentityHash()` will use its value\n+ * as the hash input instead of relying on the real IP/User-Agent.\n+ *\n+ * This prevents deduplication during automated tests where multiple\n+ * requests originate from the same IP and UA.\n+ */\n+export const DUB_TEST_IDENTITY_HEADER = \"x-dub-test-identity\";\n+\n export const E2E_TRACK_CLICK_HEADERS = {\n   referer: \"https://dub.co\",\n   \"User-Agent\":\n@@ -210,25 +220,11 @@ export const E2E_CUSTOMERS = [\n export const E2E_FRAUD_PARTNER = {\n   id: \"pn_1K8ND11BZ4XPEX39QX3YMBGY0\",\n   email: \"kiran+e2e+1@dub.co\",\n-  links: {\n-    customerEmailMatch: {\n-      domain: \"getacme.link\",\n-      key: \"fraud-customer-match\",\n-    },\n-    customerEmailSuspiciousDomain: {\n-      domain: \"getacme.link\",\n-      key: \"fraud-customer-suspicious\",\n-    },\n-    referralSourceBanned: {\n-      domain: \"getacme.link\",\n-      key: \"fraud-referral-source-banned\",\n-    },\n-    paidTrafficDetected: {\n-      domain: \"getacme.link\",\n-      key: \"fraud-paid-traffic\",\n-    },\n+  link: {\n+    domain: \"getacme.link\",\n+    key: \"kiran-e2e-1\",\n   },\n } as const;\n \n export const E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN =\n-  \"test-hostname-for-referral-source-banned-do-not-delete.com\";\n+  \"test-hostname-for-referral-source-banned-do-not-delete.com\";\n\\ No newline at end of file\n",
    "pr_number": 3171,
    "title": "Fix the Fraud tests",
    "test_files": [
      "apps/web/tests/fraud/index.test.ts"
    ],
    "code_files": [
      "apps/web/lib/middleware/utils/get-identity-hash.ts",
      "apps/web/tests/utils/resource.ts"
    ]
  },
  {
    "instance_id": "dubinc__dub.main.2975",
    "repo": "dubinc/dub",
    "base_commit": "46a8b5aa9328c75c02054b66ba5879c4e2e82345",
    "bug_patch": "diff --git a/apps/web/tests/campaigns/index.test.ts b/apps/web/tests/campaigns/index.test.ts\ndeleted file mode 100644\nindex 1a668d6..0000000\n--- a/apps/web/tests/campaigns/index.test.ts\n+++ /dev/null\n@@ -1,208 +0,0 @@\n-import { Campaign, CampaignList } from \"@/lib/types\";\n-import { updateCampaignSchema } from \"@/lib/zod/schemas/campaigns\";\n-import { E2E_PARTNER_GROUP } from \"tests/utils/resource\";\n-import { describe, expect, onTestFinished, test } from \"vitest\";\n-import { z } from \"zod\";\n-import { IntegrationHarness } from \"../utils/integration\";\n-\n-const campaign: z.infer<typeof updateCampaignSchema> = {\n-  name: \"Updated Test Campaign\",\n-  subject: \"Updated Test Subject\",\n-  triggerCondition: {\n-    attribute: \"totalConversions\",\n-    operator: \"gte\",\n-    value: 50,\n-  },\n-  bodyJson: {\n-    type: \"doc\",\n-    content: [\n-      {\n-        type: \"paragraph\",\n-        content: [\n-          {\n-            type: \"text\",\n-            text: \"Test campaign body\",\n-          },\n-        ],\n-      },\n-    ],\n-  },\n-};\n-\n-const expectedCampaign: Partial<Campaign> = {\n-  ...campaign,\n-  type: \"transactional\",\n-  status: expect.any(String),\n-  preview: null,\n-  from: null,\n-  scheduledAt: null,\n-  groups: [{ id: E2E_PARTNER_GROUP.id }],\n-  createdAt: expect.any(String),\n-  updatedAt: expect.any(String),\n-};\n-\n-describe.sequential(\"/campaigns/**\", async () => {\n-  const h = new IntegrationHarness();\n-  const { http } = await h.init();\n-\n-  let campaignId = \"\";\n-\n-  test(\"POST /campaigns - create draft campaign\", async () => {\n-    const { status, data } = await http.post<{ id: string }>({\n-      path: \"/campaigns\",\n-      body: {\n-        type: \"transactional\",\n-      },\n-    });\n-\n-    expect(status).toEqual(201);\n-    expect(data).toMatchObject({\n-      id: expect.any(String),\n-    });\n-\n-    campaignId = data.id;\n-  });\n-\n-  test(\"PATCH /campaigns/[campaignId] - update campaign content\", async () => {\n-    const { status, data: updatedCampaign } = await http.patch<Campaign>({\n-      path: `/campaigns/${campaignId}`,\n-      body: {\n-        ...campaign,\n-        groupIds: [E2E_PARTNER_GROUP.id],\n-      },\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(updatedCampaign).toStrictEqual({\n-      ...expectedCampaign,\n-      id: campaignId,\n-      status: \"draft\",\n-    });\n-  });\n-\n-  test(\"GET /campaigns/[campaignId] - make sure the draft campaign is created\", async () => {\n-    const { status, data: fetchedCampaign } = await http.get<Campaign>({\n-      path: `/campaigns/${campaignId}`,\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(fetchedCampaign).toStrictEqual({\n-      ...expectedCampaign,\n-      id: campaignId,\n-      status: \"draft\",\n-    });\n-  });\n-\n-  test(\"PATCH /campaigns/[campaignId] - publish campaign\", async () => {\n-    const { status, data: publishedCampaign } = await http.patch<Campaign>({\n-      path: `/campaigns/${campaignId}`,\n-      body: {\n-        status: \"active\",\n-      },\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(publishedCampaign).toStrictEqual({\n-      ...expectedCampaign,\n-      id: campaignId,\n-      status: \"active\",\n-    });\n-  });\n-\n-  test(\"PATCH /campaigns/[campaignId] - pause campaign\", async () => {\n-    const { status, data: pausedCampaign } = await http.patch<Campaign>({\n-      path: `/campaigns/${campaignId}`,\n-      body: {\n-        status: \"paused\",\n-      },\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(pausedCampaign).toStrictEqual({\n-      ...expectedCampaign,\n-      id: campaignId,\n-      status: \"paused\",\n-    });\n-  });\n-\n-  test(\"PATCH /campaigns/[campaignId] - resume campaign\", async () => {\n-    const { status, data: resumedCampaign } = await http.patch<Campaign>({\n-      path: `/campaigns/${campaignId}`,\n-      body: {\n-        status: \"active\",\n-      },\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(resumedCampaign).toStrictEqual({\n-      ...expectedCampaign,\n-      id: campaignId,\n-      status: \"active\",\n-    });\n-  });\n-\n-  test(\"POST /campaigns/[campaignId]/duplicate - duplicate campaign\", async () => {\n-    const { status, data } = await http.post<{ id: string }>({\n-      path: `/campaigns/${campaignId}/duplicate`,\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(data.id).toBeDefined();\n-\n-    onTestFinished(async () => {\n-      await h.deleteCampaign(data.id);\n-    });\n-\n-    const { data: duplicatedCampaign } = await http.get<Campaign>({\n-      path: `/campaigns/${data.id}`,\n-    });\n-\n-    expect(duplicatedCampaign).toStrictEqual({\n-      ...expectedCampaign,\n-      id: data.id,\n-      name: `${expectedCampaign.name} (copy)`,\n-      status: \"draft\",\n-    });\n-  });\n-\n-  test(\"GET /campaigns - list campaigns\", async () => {\n-    const { status, data: campaigns } = await http.get<CampaignList[]>({\n-      path: \"/campaigns\",\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(Array.isArray(campaigns)).toBe(true);\n-    expect(campaigns.length).toBeGreaterThan(0);\n-\n-    const campaign = campaigns.find((c) => c.id === campaignId);\n-\n-    expect(campaign).toStrictEqual({\n-      ...expectedCampaign,\n-      id: campaignId,\n-    });\n-  });\n-\n-  test(\"GET /campaigns/[campaignId] - get single campaign\", async () => {\n-    const { status, data: fetchedCampaign } = await http.get<Campaign>({\n-      path: `/campaigns/${campaignId}`,\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(fetchedCampaign).toStrictEqual({\n-      ...expectedCampaign,\n-      id: campaignId,\n-      status: \"active\",\n-    });\n-  });\n-\n-  test(\"DELETE /campaigns/[campaignId] - delete campaign\", async () => {\n-    const { status, data } = await http.delete<{ id: string }>({\n-      path: `/campaigns/${campaignId}`,\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(data).toStrictEqual({\n-      id: campaignId,\n-    });\n-  });\n-});\ndiff --git a/apps/web/tests/utils/integration.ts b/apps/web/tests/utils/integration.ts\nindex f398609..52625bd 100644\n--- a/apps/web/tests/utils/integration.ts\n+++ b/apps/web/tests/utils/integration.ts\n@@ -106,13 +106,4 @@ export class IntegrationHarness {\n       path: `/bounties/${id}`,\n     });\n   }\n-\n-  // Delete campaign\n-  public async deleteCampaign(id: string) {\n-    if (!id) return;\n-\n-    await this.http.delete({\n-      path: `/campaigns/${id}`,\n-    });\n-  }\n-}\n+}\n\\ No newline at end of file\n",
    "pr_number": 2975,
    "title": "Add integration tests for `/campaigns/**` endpoints",
    "test_files": [
      "apps/web/tests/campaigns/index.test.ts"
    ],
    "code_files": [
      "apps/web/tests/utils/integration.ts"
    ]
  },
  {
    "instance_id": "dubinc__dub.main.3020",
    "repo": "dubinc/dub",
    "base_commit": "31d5d189c7760029408dbd5115b44fdcefd6bb0b",
    "bug_patch": "diff --git a/apps/web/tests/rewards/lead-reward.test.ts b/apps/web/tests/rewards/lead-reward.test.ts\ndeleted file mode 100644\nindex 9545635..0000000\n--- a/apps/web/tests/rewards/lead-reward.test.ts\n+++ /dev/null\n@@ -1,91 +0,0 @@\n-import { TrackLeadResponse } from \"@/lib/types\";\n-import { randomCustomer } from \"tests/utils/helpers\";\n-import {\n-  E2E_LEAD_REWARD,\n-  E2E_PARTNERS,\n-  E2E_TRACK_CLICK_HEADERS,\n-} from \"tests/utils/resource\";\n-import { verifyCommission } from \"tests/utils/verify-commission\";\n-import { describe, expect, test } from \"vitest\";\n-import { IntegrationHarness } from \"../utils/integration\";\n-\n-describe.concurrent(\"Lead rewards\", async () => {\n-  const h = new IntegrationHarness();\n-  const { http } = await h.init();\n-\n-  test(\"when customer country is US and partner country is US\", async () => {\n-    // Track the click\n-    const clickResponse = await http.post<{ clickId: string }>({\n-      path: \"/track/click\",\n-      headers: E2E_TRACK_CLICK_HEADERS,\n-      body: {\n-        ...E2E_PARTNERS[0].shortLink,\n-      },\n-    });\n-\n-    expect(clickResponse.status).toEqual(200);\n-\n-    const clickId = clickResponse.data.clickId;\n-    const customer = randomCustomer();\n-\n-    // Track the lead\n-    const trackLeadResponse = await http.post<TrackLeadResponse>({\n-      path: \"/track/lead\",\n-      body: {\n-        clickId,\n-        eventName: \"Signup\",\n-        customerExternalId: customer.externalId,\n-        customerName: customer.name,\n-        customerEmail: customer.email,\n-        customerAvatar: customer.avatar,\n-      },\n-    });\n-\n-    expect(trackLeadResponse.status).toEqual(200);\n-\n-    // Verify the commission\n-    await verifyCommission({\n-      http,\n-      customerExternalId: customer.externalId,\n-      expectedEarnings: E2E_LEAD_REWARD.modifiers[1].amountInCents,\n-    });\n-  });\n-\n-  test(\"when customer country is US and partner country is not US\", async () => {\n-    // Track the click\n-    const clickResponse = await http.post<{ clickId: string }>({\n-      path: \"/track/click\",\n-      headers: E2E_TRACK_CLICK_HEADERS,\n-      body: {\n-        ...E2E_PARTNERS[1].shortLink,\n-      },\n-    });\n-\n-    expect(clickResponse.status).toEqual(200);\n-\n-    const clickId = clickResponse.data.clickId;\n-    const customer = randomCustomer();\n-\n-    // Track the lead\n-    const trackLeadResponse = await http.post<TrackLeadResponse>({\n-      path: \"/track/lead\",\n-      body: {\n-        clickId,\n-        eventName: \"Signup\",\n-        customerExternalId: customer.externalId,\n-        customerName: customer.name,\n-        customerEmail: customer.email,\n-        customerAvatar: customer.avatar,\n-      },\n-    });\n-\n-    expect(trackLeadResponse.status).toEqual(200);\n-\n-    // Verify the commission\n-    await verifyCommission({\n-      http,\n-      customerExternalId: customer.externalId,\n-      expectedEarnings: E2E_LEAD_REWARD.modifiers[0].amountInCents,\n-    });\n-  });\n-});\ndiff --git a/apps/web/tests/rewards/sale-reward.test.ts b/apps/web/tests/rewards/sale-reward.test.ts\ndeleted file mode 100644\nindex 27bdf0c..0000000\n--- a/apps/web/tests/rewards/sale-reward.test.ts\n+++ /dev/null\n@@ -1,65 +0,0 @@\n-import { TrackSaleResponse } from \"@/lib/types\";\n-import { randomId } from \"tests/utils/helpers\";\n-import { E2E_CUSTOMERS, E2E_SALE_REWARD } from \"tests/utils/resource\";\n-import { verifyCommission } from \"tests/utils/verify-commission\";\n-import { describe, expect, test } from \"vitest\";\n-import { IntegrationHarness } from \"../utils/integration\";\n-\n-describe.concurrent(\"Sale rewards\", async () => {\n-  const h = new IntegrationHarness();\n-  const { http } = await h.init();\n-\n-  test(\"when {Customer} {Country} is {SG}\", async () => {\n-    const saleAmount = 10000; // $100 in cents\n-    const invoiceId = `INV_${randomId()}`;\n-\n-    // Track the sale\n-    const trackSaleResponse = await http.post<TrackSaleResponse>({\n-      path: \"/track/sale\",\n-      body: {\n-        customerExternalId: E2E_CUSTOMERS[0].externalId,\n-        eventName: \"Subscription\",\n-        amount: saleAmount,\n-        currency: \"usd\",\n-        invoiceId,\n-        paymentProcessor: \"stripe\",\n-      },\n-    });\n-\n-    expect(trackSaleResponse.status).toEqual(200);\n-\n-    // Verify the commission (10% of sale amount)\n-    await verifyCommission({\n-      http,\n-      invoiceId,\n-      expectedEarnings: saleAmount * 0.1,\n-    });\n-  });\n-\n-  test.skip(\"when {Customer} {Country} is {CA}\", async () => {\n-    const saleAmount = 10000; // $100 in cents\n-    const invoiceId = `INV_${randomId()}`;\n-\n-    // Track the sale\n-    const trackSaleResponse = await http.post<TrackSaleResponse>({\n-      path: \"/track/sale\",\n-      body: {\n-        customerExternalId: E2E_CUSTOMERS[1].externalId,\n-        eventName: \"Subscription\",\n-        amount: saleAmount,\n-        currency: \"usd\",\n-        invoiceId,\n-        paymentProcessor: \"stripe\",\n-      },\n-    });\n-\n-    expect(trackSaleResponse.status).toEqual(200);\n-\n-    // Verify the commission (base reward)\n-    await verifyCommission({\n-      http,\n-      invoiceId,\n-      expectedEarnings: E2E_SALE_REWARD.amountInCents,\n-    });\n-  });\n-});\ndiff --git a/apps/web/tests/tracks/track-lead.test.ts b/apps/web/tests/tracks/track-lead.test.ts\nindex a1e7a83..7842392 100644\n--- a/apps/web/tests/tracks/track-lead.test.ts\n+++ b/apps/web/tests/tracks/track-lead.test.ts\n@@ -1,6 +1,12 @@\n-import { TrackLeadResponse, TrackSaleResponse } from \"@/lib/types\";\n+import {\n+  CommissionResponse,\n+  Customer,\n+  TrackLeadResponse,\n+  TrackSaleResponse,\n+} from \"@/lib/types\";\n import { randomCustomer } from \"tests/utils/helpers\";\n-import { E2E_TRACK_CLICK_HEADERS } from \"tests/utils/resource\";\n+import { HttpClient } from \"tests/utils/http\";\n+import { E2E_LEAD_REWARD, E2E_TRACK_CLICK_HEADERS } from \"tests/utils/resource\";\n import { describe, expect, test } from \"vitest\";\n import { IntegrationHarness } from \"../utils/integration\";\n \n@@ -24,6 +30,39 @@ const expectValidLeadResponse = ({\n   });\n };\n \n+const verifyCommission = async ({\n+  http,\n+  customerExternalId,\n+  expectedEarnings,\n+}: {\n+  http: HttpClient;\n+  customerExternalId: string;\n+  expectedEarnings: number;\n+}) => {\n+  // Find the customer first\n+  const { data: customers } = await http.get<Customer[]>({\n+    path: \"/customers\",\n+    query: {\n+      externalId: customerExternalId,\n+    },\n+  });\n+\n+  const customer = customers[0];\n+\n+  // Find the commission for the customer\n+  const { status, data: commissions } = await http.get<CommissionResponse[]>({\n+    path: \"/commissions\",\n+    query: {\n+      customerId: customer.id,\n+    },\n+  });\n+\n+  expect(status).toEqual(200);\n+  expect(commissions).toHaveLength(1);\n+  expect(commissions[0].customer?.id).toEqual(customer.id);\n+  expect(commissions[0].earnings).toEqual(expectedEarnings);\n+};\n+\n describe(\"POST /track/lead\", async () => {\n   const h = new IntegrationHarness();\n   const { http } = await h.init();\n@@ -215,4 +254,44 @@ describe(\"POST /track/lead\", async () => {\n       clickId: trackedClickId,\n     });\n   });\n-});\n+\n+  test(\"track a lead and verify the reward based on the partner.country (US)\", async () => {\n+    const clickResponse = await http.post<{ clickId: string }>({\n+      path: \"/track/click\",\n+      headers: E2E_TRACK_CLICK_HEADERS,\n+      body: {\n+        domain: \"getacme.link\",\n+        key: \"marvin\",\n+      },\n+    });\n+\n+    const trackedClickId = clickResponse.data.clickId;\n+    const customer = randomCustomer();\n+\n+    const response = await http.post<TrackLeadResponse>({\n+      path: \"/track/lead\",\n+      body: {\n+        clickId: trackedClickId,\n+        customerId: customer.externalId,\n+        eventName: \"Signup\",\n+        customerName: customer.name,\n+        customerEmail: customer.email,\n+        customerAvatar: customer.avatar,\n+      },\n+    });\n+\n+    expectValidLeadResponse({\n+      response,\n+      customer: customer,\n+      clickId: trackedClickId,\n+    });\n+\n+    await new Promise((resolve) => setTimeout(resolve, 2000));\n+\n+    await verifyCommission({\n+      http,\n+      customerExternalId: customer.externalId,\n+      expectedEarnings: E2E_LEAD_REWARD.modifiers[0].amountInCents,\n+    });\n+  });\n+});\n\\ No newline at end of file\ndiff --git a/apps/web/tests/tracks/track-sale.test.ts b/apps/web/tests/tracks/track-sale.test.ts\nindex 2ab22be..45db2d7 100644\n--- a/apps/web/tests/tracks/track-sale.test.ts\n+++ b/apps/web/tests/tracks/track-sale.test.ts\n@@ -11,7 +11,6 @@ import {\n   E2E_SALE_REWARD,\n   E2E_TRACK_CLICK_HEADERS,\n } from \"tests/utils/resource\";\n-import { verifyCommission } from \"tests/utils/verify-commission\";\n import { describe, expect, test } from \"vitest\";\n import { IntegrationHarness } from \"../utils/integration\";\n \n@@ -39,6 +38,25 @@ const expectValidSaleResponse = (\n   });\n };\n \n+// Helper function to verify commission details\n+const verifyCommission = async (\n+  http: any,\n+  invoiceId: string,\n+  expectedAmount: number,\n+  expectedEarnings: number,\n+) => {\n+  const { status, data: commissions } = await http.get({\n+    path: \"/commissions\",\n+    query: { invoiceId },\n+  });\n+\n+  expect(status).toEqual(200);\n+  expect(commissions).toHaveLength(1);\n+  expect(commissions[0].invoiceId).toEqual(invoiceId);\n+  expect(commissions[0].amount).toEqual(expectedAmount);\n+  expect(commissions[0].earnings).toEqual(expectedEarnings);\n+};\n+\n describe(\"POST /track/sale\", async () => {\n   const h = new IntegrationHarness();\n   const { http } = await h.init();\n@@ -108,19 +126,22 @@ describe(\"POST /track/sale\", async () => {\n     });\n     expect(response2.status).toEqual(200);\n \n-    await verifyCommission({\n-      http,\n-      invoiceId: regularInvoiceId,\n-      expectedAmount: response1.data.sale?.amount!,\n-      expectedEarnings: E2E_SALE_REWARD.amountInCents,\n-    });\n+    // pause for 2 seconds for data to be fully processed\n+    await new Promise((resolve) => setTimeout(resolve, 2000));\n \n-    await verifyCommission({\n+    // Verify commissions\n+    await verifyCommission(\n       http,\n-      invoiceId: premiumInvoiceId,\n-      expectedAmount: response2.data.sale?.amount!,\n-      expectedEarnings: E2E_SALE_REWARD.modifiers[0].amountInCents!,\n-    });\n+      regularInvoiceId,\n+      response1.data.sale?.amount!,\n+      E2E_SALE_REWARD.amountInCents,\n+    );\n+    await verifyCommission(\n+      http,\n+      premiumInvoiceId,\n+      response2.data.sale?.amount!,\n+      E2E_SALE_REWARD.modifiers[0].amountInCents,\n+    );\n   });\n \n   test(\"track a sale with an externalId that does not exist (should return null customer and sale)\", async () => {\n@@ -287,18 +308,21 @@ describe(\"POST /track/sale\", async () => {\n     expect(response2.status).toEqual(200);\n     expect(response2.data.sale?.amount).toEqual(largeSaleAmount);\n \n-    await verifyCommission({\n+    // Pause for 2 seconds for data to be fully processed\n+    await new Promise((resolve) => setTimeout(resolve, 2000));\n+\n+    await verifyCommission(\n       http,\n-      invoiceId: smallSaleInvoiceId,\n-      expectedAmount: response1.data.sale?.amount!,\n-      expectedEarnings: E2E_SALE_REWARD.amountInCents,\n-    });\n+      smallSaleInvoiceId,\n+      response1.data.sale?.amount!,\n+      E2E_SALE_REWARD.amountInCents,\n+    );\n \n-    await verifyCommission({\n+    await verifyCommission(\n       http,\n-      invoiceId: largeSaleInvoiceId,\n-      expectedAmount: response2.data.sale?.amount!,\n-      expectedEarnings: E2E_SALE_REWARD.modifiers[1].amountInCents!,\n-    });\n+      largeSaleInvoiceId,\n+      response2.data.sale?.amount!,\n+      E2E_SALE_REWARD.modifiers[1].amountInCents,\n+    );\n   });\n-});\n+});\n\\ No newline at end of file\ndiff --git a/apps/web/tests/utils/resource.ts b/apps/web/tests/utils/resource.ts\nindex 94685c4..66d16cc 100644\n--- a/apps/web/tests/utils/resource.ts\n+++ b/apps/web/tests/utils/resource.ts\n@@ -46,72 +46,42 @@ export const E2E_SALE_REWARD = {\n   amountInCents: 1000,\n   modifiers: [\n     {\n-      type: \"flat\",\n       operator: \"AND\",\n+      type: \"flat\",\n+      amountInCents: 3000,\n       conditions: [\n         {\n-          value: \"premiumProductId\",\n           entity: \"sale\",\n-          operator: \"equals_to\",\n           attribute: \"productId\",\n+          operator: \"equals_to\",\n+          value: \"premiumProductId\",\n         },\n       ],\n-      maxDuration: null,\n-      amountInCents: 3000,\n     },\n     {\n-      type: \"flat\",\n       operator: \"AND\",\n+      type: \"flat\",\n+      amountInCents: 5000,\n       conditions: [\n         {\n-          value: 15000,\n           entity: \"sale\",\n-          operator: \"greater_than\",\n           attribute: \"amount\",\n+          operator: \"greater_than\",\n+          value: 15000,\n         },\n       ],\n-      maxDuration: null,\n-      amountInCents: 5000,\n-    },\n-    {\n-      type: \"percentage\",\n-      operator: \"AND\",\n-      conditions: [\n-        {\n-          value: \"US\",\n-          entity: \"customer\",\n-          operator: \"equals_to\",\n-          attribute: \"country\",\n-        },\n-      ],\n-      maxDuration: null,\n-      amountInPercentage: 10,\n-    },\n-    {\n-      type: \"flat\",\n-      operator: \"AND\",\n-      conditions: [\n-        {\n-          value: \"CA\",\n-          entity: \"customer\",\n-          operator: \"equals_to\",\n-          attribute: \"country\",\n-        },\n-      ],\n-      maxDuration: null,\n-      amountInCents: 50,\n     },\n   ],\n };\n-\n export const E2E_LEAD_REWARD = {\n   id: \"rw_1K82ESAT4YPY0STR20GKXZ7DR\",\n   event: \"lead\",\n   type: \"flat\",\n-  amountInCents: 100,\n+  amountInCents: 1000,\n   modifiers: [\n     {\n       type: \"flat\",\n+      amountInCents: 200,\n       operator: \"AND\",\n       conditions: [\n         {\n@@ -122,21 +92,6 @@ export const E2E_LEAD_REWARD = {\n         },\n       ],\n       maxDuration: null,\n-      amountInCents: 200,\n-    },\n-    {\n-      type: \"flat\",\n-      operator: \"AND\",\n-      conditions: [\n-        {\n-          value: \"US\",\n-          entity: \"partner\",\n-          operator: \"equals_to\",\n-          attribute: \"country\",\n-        },\n-      ],\n-      maxDuration: 0,\n-      amountInCents: 300,\n     },\n   ],\n };\n@@ -175,38 +130,6 @@ export const E2E_PARTNER_GROUP = {\n   url: \"https://acme.dub.sh/\",\n };\n \n-export const E2E_PARTNERS = [\n-  {\n-    id: \"pn_NNG3YjwhLhA7nCZSaXeLIsWu\",\n-    country: \"US\",\n-    shortLink: {\n-      domain: \"getacme.link\",\n-      key: \"marvin\",\n-    },\n-  },\n-  {\n-    id: \"pn_1K8ND11BZ4XPEX39QX3YMBGY0\",\n-    country: \"SG\",\n-    shortLink: {\n-      domain: \"getacme.link\",\n-      key: \"kiran-e2e-1\",\n-    },\n-  },\n-] as const;\n-\n-export const E2E_CUSTOMERS = [\n-  {\n-    id: \"cus_1K82FYFF7RANMCGRHRGMWDNEC\",\n-    externalId: \"cus_LnZbkb8boLsOn1YGLPxZGZMU\",\n-    country: \"SG\",\n-  },\n-  {\n-    id: \"cus_1K86CG1DZFW8EMSSWXX4AVZFA\",\n-    externalId: \"cus_vq3UgXINHS99MIon8vNvAO1n\",\n-    country: \"CA\",\n-  },\n-] as const;\n-\n export const E2E_FRAUD_PARTNER = {\n   id: \"pn_1K8ND11BZ4XPEX39QX3YMBGY0\",\n   email: \"kiran+e2e+1@dub.co\",\n@@ -231,4 +154,4 @@ export const E2E_FRAUD_PARTNER = {\n } as const;\n \n export const E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN =\n-  \"test-hostname-for-referral-source-banned-do-not-delete.com\";\n+  \"test-hostname-for-referral-source-banned-do-not-delete.com\";\n\\ No newline at end of file\ndiff --git a/apps/web/tests/utils/verify-commission.ts b/apps/web/tests/utils/verify-commission.ts\ndeleted file mode 100644\nindex 22ae6cf..0000000\n--- a/apps/web/tests/utils/verify-commission.ts\n+++ /dev/null\n@@ -1,72 +0,0 @@\n-import { CommissionResponse, Customer } from \"@/lib/types\";\n-import { expect } from \"vitest\";\n-import { HttpClient } from \"./http\";\n-\n-interface VerifyCommissionProps {\n-  http: HttpClient;\n-  customerExternalId?: string;\n-  invoiceId?: string;\n-  expectedAmount?: number;\n-  expectedEarnings: number;\n-}\n-\n-export const verifyCommission = async ({\n-  http,\n-  customerExternalId,\n-  invoiceId,\n-  expectedAmount,\n-  expectedEarnings,\n-}: VerifyCommissionProps) => {\n-  let customerId: string | undefined;\n-\n-  // Pause for 1.5 seconds for data to be fully processed\n-  await new Promise((resolve) => setTimeout(resolve, 1500));\n-\n-  // Optional: resolve customer ID if customerExternalId is given\n-  if (customerExternalId) {\n-    const { data: customers } = await http.get<Customer[]>({\n-      path: \"/customers\",\n-      query: { externalId: customerExternalId },\n-    });\n-\n-    expect(customers.length).toBeGreaterThan(0);\n-    customerId = customers[0].id;\n-\n-    // Small delay if necessary for async commission processing\n-    await new Promise((resolve) => setTimeout(resolve, 2000));\n-  }\n-\n-  const query: Record<string, string> = {};\n-\n-  if (invoiceId) {\n-    query.invoiceId = invoiceId;\n-  }\n-\n-  if (customerId) {\n-    query.customerId = customerId;\n-  }\n-\n-  const { status, data: commissions } = await http.get<CommissionResponse[]>({\n-    path: \"/commissions\",\n-    query,\n-  });\n-\n-  expect(status).toEqual(200);\n-  expect(commissions).toHaveLength(1);\n-\n-  const commission = commissions[0];\n-\n-  if (invoiceId) {\n-    expect(commission.invoiceId).toEqual(invoiceId);\n-  }\n-\n-  if (customerId) {\n-    expect(commission.customer?.id).toEqual(customerId);\n-  }\n-\n-  if (expectedAmount !== undefined) {\n-    expect(commission.amount).toEqual(expectedAmount);\n-  }\n-\n-  expect(commission.earnings).toEqual(expectedEarnings);\n-};\n",
    "pr_number": 3020,
    "title": "Reward modifiers tests",
    "test_files": [
      "apps/web/tests/rewards/lead-reward.test.ts",
      "apps/web/tests/rewards/sale-reward.test.ts",
      "apps/web/tests/tracks/track-lead.test.ts",
      "apps/web/tests/tracks/track-sale.test.ts"
    ],
    "code_files": [
      "apps/web/tests/utils/resource.ts",
      "apps/web/tests/utils/verify-commission.ts"
    ]
  },
  {
    "instance_id": "dubinc__dub.main.3027",
    "repo": "dubinc/dub",
    "base_commit": "5d86b60093e63dc01ab8ba41a7d06bd46c92cfba",
    "bug_patch": "diff --git a/apps/web/tests/rewards/lead-reward.test.ts b/apps/web/tests/rewards/lead-reward.test.ts\nindex 9545635..298887b 100644\n--- a/apps/web/tests/rewards/lead-reward.test.ts\n+++ b/apps/web/tests/rewards/lead-reward.test.ts\n@@ -13,7 +13,7 @@ describe.concurrent(\"Lead rewards\", async () => {\n   const h = new IntegrationHarness();\n   const { http } = await h.init();\n \n-  test(\"when customer country is US and partner country is US\", async () => {\n+  test(\"when {Partner} {Country} is {US}\", async () => {\n     // Track the click\n     const clickResponse = await http.post<{ clickId: string }>({\n       path: \"/track/click\",\n@@ -47,11 +47,11 @@ describe.concurrent(\"Lead rewards\", async () => {\n     await verifyCommission({\n       http,\n       customerExternalId: customer.externalId,\n-      expectedEarnings: E2E_LEAD_REWARD.modifiers[1].amountInCents,\n+      expectedEarnings: E2E_LEAD_REWARD.modifiers[0].amountInCents,\n     });\n   });\n \n-  test(\"when customer country is US and partner country is not US\", async () => {\n+  test(\"when {Partner} {Country} is not {US}\", async () => {\n     // Track the click\n     const clickResponse = await http.post<{ clickId: string }>({\n       path: \"/track/click\",\n@@ -85,7 +85,7 @@ describe.concurrent(\"Lead rewards\", async () => {\n     await verifyCommission({\n       http,\n       customerExternalId: customer.externalId,\n-      expectedEarnings: E2E_LEAD_REWARD.modifiers[0].amountInCents,\n+      expectedEarnings: E2E_LEAD_REWARD.amountInCents,\n     });\n   });\n-});\n+});\n\\ No newline at end of file\ndiff --git a/apps/web/tests/utils/resource.ts b/apps/web/tests/utils/resource.ts\nindex 94685c4..ca8f96a 100644\n--- a/apps/web/tests/utils/resource.ts\n+++ b/apps/web/tests/utils/resource.ts\n@@ -116,7 +116,7 @@ export const E2E_LEAD_REWARD = {\n       conditions: [\n         {\n           value: \"US\",\n-          entity: \"customer\",\n+          entity: \"partner\",\n           operator: \"equals_to\",\n           attribute: \"country\",\n         },\n@@ -130,13 +130,13 @@ export const E2E_LEAD_REWARD = {\n       conditions: [\n         {\n           value: \"US\",\n-          entity: \"partner\",\n+          entity: \"customer\",\n           operator: \"equals_to\",\n           attribute: \"country\",\n         },\n       ],\n-      maxDuration: 0,\n-      amountInCents: 300,\n+      maxDuration: null,\n+      amountInCents: 400,\n     },\n   ],\n };\n@@ -231,4 +231,4 @@ export const E2E_FRAUD_PARTNER = {\n } as const;\n \n export const E2E_FRAUD_REFERRAL_SOURCE_BANNED_DOMAIN =\n-  \"test-hostname-for-referral-source-banned-do-not-delete.com\";\n+  \"test-hostname-for-referral-source-banned-do-not-delete.com\";\n\\ No newline at end of file\n",
    "pr_number": 3027,
    "title": "Update rewards tests",
    "test_files": [
      "apps/web/tests/rewards/lead-reward.test.ts"
    ],
    "code_files": [
      "apps/web/tests/utils/resource.ts"
    ]
  },
  {
    "instance_id": "dubinc__dub.main.3036",
    "repo": "dubinc/dub",
    "base_commit": "6784533571d3339f600df223f9c3981d71a6b9a2",
    "bug_patch": "diff --git a/apps/web/lib/types.ts b/apps/web/lib/types.ts\nindex 83585fa..6342e41 100644\n--- a/apps/web/lib/types.ts\n+++ b/apps/web/lib/types.ts\n@@ -452,6 +452,7 @@ export type PartnerProps = z.infer<typeof PartnerSchema> & {\n };\n \n export type PartnerUserProps = z.infer<typeof partnerUserSchema>;\n+\n export type PartnerProfileCustomerProps = z.infer<\n   typeof PartnerProfileCustomerSchema\n >;\n@@ -491,237 +492,4 @@ export type ProgramApplicationFormDataWithValues = z.infer<\n >;\n \n export type ProgramApplicationFormFieldWithValues = z.infer<\n-  typeof programApplicationFormFieldWithValuesSchema\n->;\n-export type ProgramEnrollmentProps = z.infer<typeof ProgramEnrollmentSchema>;\n-\n-export type PayoutsCount = {\n-  status: PayoutStatus;\n-  count: number;\n-  amount: number;\n-};\n-\n-export type PayoutResponse = z.infer<typeof PayoutResponseSchema>;\n-\n-export type PartnerPayoutResponse = z.infer<typeof PartnerPayoutResponseSchema>;\n-\n-export type SegmentIntegrationCredentials = {\n-  writeKey?: string;\n-};\n-export type InvoiceProps = z.infer<typeof InvoiceSchema>;\n-\n-export type CustomerActivityResponse = z.infer<\n-  typeof customerActivityResponseSchema\n->;\n-\n-export type ClickEvent = z.infer<typeof clickEventResponseSchema>;\n-\n-export type SaleEvent = z.infer<typeof saleEventResponseSchema>;\n-\n-export type LeadEvent = z.infer<typeof leadEventResponseSchema>;\n-\n-// Folders\n-\n-export type Folder = z.infer<typeof FolderSchema>;\n-\n-export type FolderAccessLevel = keyof typeof FOLDER_WORKSPACE_ACCESS;\n-\n-export type FolderPermission = (typeof FOLDER_PERMISSIONS)[number];\n-\n-export type FolderUser = Pick<User, \"id\" | \"name\" | \"email\" | \"image\"> & {\n-  role: FolderUserRole;\n-  workspaceRole: WorkspaceRole;\n-};\n-\n-export type FolderWithPermissions = {\n-  id: string;\n-  permissions: FolderPermission[];\n-};\n-\n-export type FolderSummary = Pick<\n-  Folder,\n-  \"id\" | \"name\" | \"description\" | \"accessLevel\"\n->;\n-\n-export type RewardProps = z.infer<typeof RewardSchema>;\n-\n-export type CreatePartnerProps = z.infer<typeof createPartnerSchema>;\n-\n-export type ProgramData = z.infer<typeof programDataSchema>;\n-export type PaymentMethodOption = {\n-  currency?: string;\n-  mandate_options?: {\n-    payment_schedule?: string;\n-    transaction_type?: string;\n-  };\n-};\n-export interface FolderLinkCount {\n-  folderId: string;\n-  _count: number;\n-}\n-\n-export type RewardContext = z.infer<typeof rewardContextSchema>;\n-\n-export type RewardCondition = z.infer<typeof rewardConditionSchema>;\n-\n-export type RewardConditions = z.infer<typeof rewardConditionsSchema>;\n-\n-export type RewardConditionsArray = z.infer<typeof rewardConditionsArraySchema>;\n-\n-export type ClickEventTB = z.infer<typeof clickEventSchemaTB>;\n-\n-export type LeadEventTB = z.infer<typeof leadEventSchemaTB>;\n-\n-export type GroupProps = z.infer<typeof GroupSchema>;\n-\n-export type GroupWithFormDataProps = z.infer<typeof GroupWithFormDataSchema>;\n-\n-export type GroupWithProgramProps = z.infer<typeof GroupWithProgramSchema>;\n-\n-export type GroupExtendedProps = z.infer<typeof GroupSchemaExtended>;\n-\n-export type PartnerGroupDefaultLink = z.infer<\n-  typeof PartnerGroupDefaultLinkSchema\n->;\n-\n-export type PartnerGroupAdditionalLink = z.infer<\n-  typeof additionalPartnerLinkSchemaOptionalPath\n->;\n-\n-export type PartnerGroupProps = PartnerGroup & {\n-  additionalLinks: PartnerGroupAdditionalLink[];\n-};\n-\n-export type PartnerCommentProps = z.infer<typeof PartnerCommentSchema>;\n-\n-export type BountyProps = z.infer<typeof BountySchema>;\n-export type BountyListProps = z.infer<typeof BountyListSchema>;\n-\n-export type PartnerBountyProps = z.infer<typeof PartnerBountySchema>;\n-\n-export type BountySubmissionProps = z.infer<\n-  typeof BountySubmissionExtendedSchema\n->;\n-\n-export type BountySubmissionRequirement =\n-  (typeof BOUNTY_SUBMISSION_REQUIREMENTS)[number];\n-\n-export type WorkflowCondition = z.infer<typeof workflowConditionSchema>;\n-\n-export type WorkflowConditionAttribute = (typeof WORKFLOW_ATTRIBUTES)[number];\n-\n-export type WorkflowComparisonOperator =\n-  (typeof WORKFLOW_COMPARISON_OPERATORS)[number];\n-\n-export type WorkflowAction = z.infer<typeof workflowActionSchema>;\n-\n-export type OperatorFn = (a: number, b: number) => boolean;\n-\n-export interface WorkflowContext {\n-  programId: string;\n-  partnerId: string;\n-  groupId?: string;\n-  current?: {\n-    leads?: number;\n-    conversions?: number;\n-    saleAmount?: number;\n-    commissions?: number;\n-  };\n-  // Not using at the moment\n-  historical?: {\n-    leads?: number;\n-    conversions?: number;\n-    saleAmount?: number;\n-    commissions?: number;\n-  };\n-}\n-\n-export type BountySubmissionsQueryFilters = z.infer<\n-  typeof getBountySubmissionsQuerySchema\n->;\n-\n-export type Message = z.infer<typeof MessageSchema>;\n-\n-export type CampaignList = z.infer<typeof CampaignListSchema>;\n-\n-export type Campaign = z.infer<typeof CampaignSchema>;\n-\n-export type UpdateCampaignFormData = z.infer<typeof updateCampaignSchema>;\n-\n-export type CampaignSummary = z.infer<typeof campaignSummarySchema>;\n-\n-export type StripeMode = \"test\" | \"sandbox\" | \"live\";\n-\n-export type EmailTemplateVariables = Record<\n-  (typeof EMAIL_TEMPLATE_VARIABLES)[number],\n-  string | null | undefined\n->;\n-\n-export interface TiptapNode {\n-  type: string;\n-  text?: string;\n-  attrs?: Record<string, any>;\n-  content?: TiptapNode[];\n-  marks?: Array<{ type: string; attrs?: Record<string, any> }>;\n-}\n-\n-export interface CampaignWorkflowAttributeConfig {\n-  label: string;\n-  inputType: \"number\" | \"currency\" | \"dropdown\" | \"none\";\n-  dropdownValues?: number[];\n-}\n-\n-export type WorkflowAttribute = (typeof WORKFLOW_ATTRIBUTES)[number];\n-\n-export type EmailDomainProps = z.infer<typeof EmailDomainSchema>;\n-\n-export type FraudGroupProps = z.infer<typeof fraudGroupSchema>;\n-\n-export type ExtendedFraudRuleType =\n-  | FraudRuleType\n-  | \"partnerEmailDomainMismatch\"\n-  | \"partnerEmailMasked\"\n-  | \"partnerNoSocialLinks\"\n-  | \"partnerNoVerifiedSocialLinks\";\n-\n-export type FraudSeverity = \"low\" | \"medium\" | \"high\";\n-\n-export interface FraudTriggeredRule {\n-  triggered: boolean;\n-  metadata?: Record<string, unknown>;\n-}\n-\n-export interface FraudRuleInfo {\n-  type: ExtendedFraudRuleType;\n-  name: string;\n-  description: string;\n-  severity?: FraudSeverity;\n-  configurable: boolean;\n-  scope: \"partner\" | \"conversionEvent\";\n-}\n-\n-export type FraudRuleProps = z.infer<typeof fraudRuleSchema>;\n-\n-export type FraudEventContext = z.infer<typeof fraudEventContext>;\n-\n-export type PaidTrafficPlatform = (typeof PAID_TRAFFIC_PLATFORMS)[number];\n-\n-export type UpdateFraudRuleSettings = z.infer<\n-  typeof updateFraudRuleSettingsSchema\n->;\n-\n-export interface FraudGroupCountByPartner {\n-  partnerId: string;\n-  _count: number;\n-}\n-\n-export interface FraudGroupCountByType {\n-  type: FraudRuleType;\n-  _count: number;\n-}\n-\n-export type CreateFraudEventInput = Pick<\n-  FraudEventGroup,\n-  \"programId\" | \"partnerId\" | \"type\"\n-> &\n-  Partial<Pick<FraudEvent, \"linkId\" | \"eventId\" | \"customerId\" | \"metadata\">>;\n+  typeof programApplicationFormFieldWithValuesSchema\n\\ No newline at end of file\ndiff --git a/apps/web/tests/partner-groups/index.test.ts b/apps/web/tests/partner-groups/index.test.ts\ndeleted file mode 100644\nindex dfbf625..0000000\n--- a/apps/web/tests/partner-groups/index.test.ts\n+++ /dev/null\n@@ -1,195 +0,0 @@\n-import { generateRandomName } from \"@/lib/names\";\n-import {\n-  GroupExtendedProps,\n-  GroupProps,\n-  GroupWithProgramProps,\n-} from \"@/lib/types\";\n-import {\n-  DEFAULT_ADDITIONAL_PARTNER_LINKS,\n-  DEFAULT_PARTNER_GROUP,\n-  GroupSchema,\n-} from \"@/lib/zod/schemas/groups\";\n-import { RESOURCE_COLORS } from \"@/ui/colors\";\n-import { randomValue } from \"@dub/utils\";\n-import slugify from \"@sindresorhus/slugify\";\n-import { describe, expect, test } from \"vitest\";\n-import { IntegrationHarness } from \"../utils/integration\";\n-\n-const expectedGroup: Partial<GroupProps> = {\n-  id: expect.any(String),\n-  name: expect.any(String),\n-  slug: expect.any(String),\n-  color: expect.any(String),\n-  logo: expect.any(String),\n-  wordmark: expect.any(String),\n-  holdingPeriodDays: expect.any(Number),\n-  brandColor: null,\n-  autoApprovePartnersEnabledAt: null,\n-  clickReward: null,\n-  leadReward: null,\n-  saleReward: null,\n-  discount: null,\n-  maxPartnerLinks: DEFAULT_ADDITIONAL_PARTNER_LINKS,\n-  linkStructure: \"short\",\n-  additionalLinks: expect.any(Array),\n-};\n-\n-describe.sequential(\"/groups/**\", async () => {\n-  const h = new IntegrationHarness();\n-  const { http } = await h.init();\n-\n-  let group: GroupProps;\n-\n-  test(\"POST /groups - create group\", async () => {\n-    // Fetch the default group to get its default values\n-    const { data: defaultGroup } = await http.get<GroupWithProgramProps>({\n-      path: `/groups/${DEFAULT_PARTNER_GROUP.slug}`,\n-    });\n-\n-    const groupName = generateRandomName();\n-\n-    const newGroup = {\n-      name: `E2E-${groupName}`,\n-      slug: slugify(groupName),\n-      color: randomValue(RESOURCE_COLORS),\n-    };\n-\n-    const { status, data } = await http.post<GroupProps>({\n-      path: \"/groups\",\n-      body: newGroup,\n-    });\n-\n-    expect(status).toEqual(201);\n-    expect(() => GroupSchema.parse(data)).not.toThrow();\n-\n-    expect(data).toStrictEqual({\n-      ...expectedGroup,\n-      ...newGroup,\n-      logo: defaultGroup.logo,\n-      wordmark: defaultGroup.wordmark,\n-      brandColor: defaultGroup.brandColor,\n-      additionalLinks: defaultGroup.additionalLinks,\n-      maxPartnerLinks: defaultGroup.maxPartnerLinks,\n-      linkStructure: defaultGroup.linkStructure,\n-      holdingPeriodDays: defaultGroup.holdingPeriodDays,\n-      autoApprovePartnersEnabledAt: defaultGroup.autoApprovePartnersEnabledAt,\n-    });\n-\n-    group = data;\n-  });\n-\n-  test(\"GET /groups/[groupId] - fetch single group\", async () => {\n-    const { status, data } = await http.get<GroupWithProgramProps>({\n-      path: `/groups/${group.id}`,\n-    });\n-\n-    const {\n-      applicationFormData,\n-      applicationFormPublishedAt,\n-      landerData,\n-      landerPublishedAt,\n-      program,\n-      ...fetchedGroup\n-    } = data;\n-\n-    expect(status).toEqual(200);\n-    expect(fetchedGroup).toStrictEqual({\n-      ...group,\n-      utmTemplate: null,\n-    });\n-  });\n-\n-  test(\"PATCH /groups/[groupId] - update group\", async () => {\n-    const toUpdate = {\n-      name: `E2E-${generateRandomName()}`,\n-      color: randomValue(RESOURCE_COLORS),\n-      maxPartnerLinks: 5,\n-      linkStructure: \"query\",\n-      holdingPeriodDays: 30,\n-      additionalLinks: [\n-        {\n-          domain: \"example.com\",\n-          path: \"\",\n-          validationMode: \"domain\",\n-        },\n-        {\n-          domain: \"acme.com\",\n-          path: \"/products\",\n-          validationMode: \"exact\",\n-        },\n-      ],\n-    };\n-\n-    const { status, data: updatedGroup } = await http.patch<GroupProps>({\n-      path: `/groups/${group.id}`,\n-      body: {\n-        ...toUpdate,\n-        autoApprovePartners: true,\n-      },\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(updatedGroup).toStrictEqual({\n-      ...group,\n-      ...toUpdate,\n-      autoApprovePartnersEnabledAt: expect.any(String),\n-    });\n-\n-    group = updatedGroup;\n-  });\n-\n-  test(\"GET /groups - fetch all groups\", async () => {\n-    const { status, data: groups } = await http.get<GroupExtendedProps[]>({\n-      path: \"/groups\",\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(Array.isArray(groups)).toBe(true);\n-    expect(groups.length).toBeGreaterThan(0);\n-\n-    const fetchedGroup = groups.find((g) => g.id === group.id);\n-\n-    expect(fetchedGroup).toStrictEqual({\n-      id: group.id,\n-      name: group.name,\n-      slug: group.slug,\n-      color: group.color,\n-      additionalLinks: group.additionalLinks,\n-      maxPartnerLinks: group.maxPartnerLinks,\n-      linkStructure: group.linkStructure,\n-      logo: group.logo,\n-      wordmark: group.wordmark,\n-      brandColor: group.brandColor,\n-      holdingPeriodDays: group.holdingPeriodDays,\n-      autoApprovePartnersEnabledAt: group.autoApprovePartnersEnabledAt,\n-      totalPartners: 0,\n-      totalClicks: 0,\n-      totalLeads: 0,\n-      totalSales: 0,\n-      totalSaleAmount: 0,\n-      totalConversions: 0,\n-      totalCommissions: 0,\n-      netRevenue: 0,\n-    });\n-  });\n-\n-  test(\"DELETE /groups/[groupId] - delete group\", async () => {\n-    const { status, data } = await http.delete<{ id: string }>({\n-      path: `/groups/${group.id}`,\n-    });\n-\n-    expect(status).toEqual(200);\n-    expect(data).toStrictEqual({\n-      id: group.id,\n-    });\n-\n-    const { status: getStatus } = await http.get({\n-      path: `/groups/${group.id}`,\n-    });\n-\n-    expect(getStatus).toEqual(404);\n-  });\n-});\n-\n-// TODO(kiran):\n-// Add more test cases to test the default link creation and group move\ndiff --git a/apps/web/ui/modals/delete-group-modal.tsx b/apps/web/ui/modals/delete-group-modal.tsx\nindex 253b7c3..b08cef5 100644\n--- a/apps/web/ui/modals/delete-group-modal.tsx\n+++ b/apps/web/ui/modals/delete-group-modal.tsx\n@@ -98,7 +98,7 @@ const DeleteGroupModal = ({\n                 <p className=\"block text-sm text-neutral-500\">\n                   To verify, type{\" \"}\n                   <span className=\"font-medium text-neutral-700\">\n-                    confirm delete group\n+                    Delete group\n                   </span>{\" \"}\n                   below\n                 </p>\n@@ -113,7 +113,7 @@ const DeleteGroupModal = ({\n                     className=\"block w-full rounded-md border-neutral-300 text-neutral-900 placeholder-neutral-400 focus:border-neutral-500 focus:outline-none focus:ring-neutral-500 sm:text-sm\"\n                     aria-invalid=\"true\"\n                     autoFocus={!isMobile}\n-                    pattern=\"confirm delete group\"\n+                    pattern=\"Delete group\"\n                   />\n                 </div>\n               </div>\n@@ -167,4 +167,4 @@ export function useDeleteGroupModal(\n     }),\n     [setShowDeleteGroupModal, DeleteGroupModalCallback],\n   );\n-}\n+}\n\\ No newline at end of file\n",
    "pr_number": 3036,
    "title": "Groups tests",
    "test_files": [
      "apps/web/tests/partner-groups/index.test.ts"
    ],
    "code_files": [
      "apps/web/lib/types.ts",
      "apps/web/ui/modals/delete-group-modal.tsx"
    ]
  },
  {
    "instance_id": "dubinc__dub.main.3166",
    "repo": "dubinc/dub",
    "base_commit": "beac3b75f8feb4b1a78fd33801c5544adbfaaad9",
    "bug_patch": "diff --git a/apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts b/apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts\nindex cda1d85..c0d7135 100644\n--- a/apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts\n+++ b/apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts\n@@ -1,17 +1,12 @@\n import { detectDuplicatePayoutMethodFraud } from \"@/lib/api/fraud/detect-duplicate-payout-method-fraud\";\n-import { qstash } from \"@/lib/cron\";\n import { stripe } from \"@/lib/stripe\";\n import { sendBatchEmail, sendEmail } from \"@dub/email\";\n import ConnectedPayoutMethod from \"@dub/email/templates/connected-payout-method\";\n import DuplicatePayoutMethod from \"@dub/email/templates/duplicate-payout-method\";\n import { prisma } from \"@dub/prisma\";\n-import { APP_DOMAIN_WITH_NGROK, log } from \"@dub/utils\";\n+import { log } from \"@dub/utils\";\n import Stripe from \"stripe\";\n \n-const queue = qstash.queue({\n-  queueName: \"withdraw-stripe-balance\",\n-});\n-\n export async function accountUpdated(event: Stripe.Event) {\n   const account = event.data.object as Stripe.Account;\n \n@@ -132,26 +127,5 @@ export async function accountUpdated(event: Stripe.Event) {\n     }\n   }\n \n-  // Retry payouts that got stuck when the account was restricted (e.g: payout sent but paused\n-  // due to verification requirements). Once payouts are re-enabled, queue them for processing.\n-  const pendingPayouts = await prisma.payout.count({\n-    where: {\n-      partnerId: partner.id,\n-      status: \"sent\",\n-      mode: \"internal\",\n-    },\n-  });\n-\n-  if (pendingPayouts > 0) {\n-    await queue.enqueueJSON({\n-      url: `${APP_DOMAIN_WITH_NGROK}/api/cron/payouts/balance-available`,\n-      deduplicationId: event.id,\n-      method: \"POST\",\n-      body: {\n-        stripeAccount: partner.stripeConnectId,\n-      },\n-    });\n-  }\n-\n   return `Updated partner ${partner.email} (${partner.stripeConnectId}) with country ${country}, payoutsEnabledAt set, payoutMethodHash ${defaultExternalAccount.fingerprint}`;\n-}\n+}\n\\ No newline at end of file\ndiff --git a/apps/web/tests/fraud/index.test.ts b/apps/web/tests/fraud/index.test.ts\nindex d784a54..85376b6 100644\n--- a/apps/web/tests/fraud/index.test.ts\n+++ b/apps/web/tests/fraud/index.test.ts\n@@ -252,6 +252,6 @@ async function waitForFraudEvent({\n \n       return data[0];\n     },\n-    { retries: 10, interval: 600 },\n+    { retries: 10, interval: 300 },\n   );\n-}\n+}\n\\ No newline at end of file\n",
    "pr_number": 3166,
    "title": "Retry stripe payouts after account verification",
    "test_files": [
      "apps/web/tests/fraud/index.test.ts"
    ],
    "code_files": [
      "apps/web/app/(ee)/api/stripe/connect/webhook/account-updated.ts"
    ]
  },
  {
    "instance_id": "dubinc__dub.main.3157",
    "repo": "dubinc/dub",
    "base_commit": "63b1aa50622b3ebb8d0e25f8e808a3617ac8ecef",
    "bug_patch": "diff --git a/apps/web/app/(ee)/api/customers/[id]/route.ts b/apps/web/app/(ee)/api/customers/[id]/route.ts\nindex 6e15be6..ebad020 100644\n--- a/apps/web/app/(ee)/api/customers/[id]/route.ts\n+++ b/apps/web/app/(ee)/api/customers/[id]/route.ts\n@@ -96,30 +96,21 @@ export const PATCH = withWorkspace(\n \n       if (avatar && !isStored(avatar) && finalCustomerAvatar) {\n         waitUntil(\n-          storage\n-            .upload({\n+          Promise.allSettled([\n+            storage.upload({\n               key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n               body: avatar,\n               opts: {\n                 width: 128,\n                 height: 128,\n               },\n-            })\n-            .then(() => {\n-              if (oldCustomerAvatar && isStored(oldCustomerAvatar)) {\n-                storage.delete({\n-                  key: oldCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n-                });\n-              }\n-            })\n-            .catch(async (error) => {\n-              console.error(\"Error persisting customer avatar to R2\", error);\n-              // if the avatar fails to upload to R2, set the avatar to null in the database\n-              await prisma.customer.update({\n-                where: { id: customer.id },\n-                data: { avatar: null },\n-              });\n             }),\n+            oldCustomerAvatar &&\n+              isStored(oldCustomerAvatar) &&\n+              storage.delete({\n+                key: oldCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n+              }),\n+          ]),\n         );\n       }\n \n@@ -195,4 +186,4 @@ export const DELETE = withWorkspace(\n       \"enterprise\",\n     ],\n   },\n-);\n+);\n\\ No newline at end of file\ndiff --git a/apps/web/app/(ee)/api/customers/route.ts b/apps/web/app/(ee)/api/customers/route.ts\nindex ecdeb52..6ef3dad 100644\n--- a/apps/web/app/(ee)/api/customers/route.ts\n+++ b/apps/web/app/(ee)/api/customers/route.ts\n@@ -165,27 +165,14 @@ export const POST = withWorkspace(\n \n       if (avatar && !isStored(avatar) && finalCustomerAvatar) {\n         waitUntil(\n-          storage\n-            .upload({\n-              key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n-              body: avatar,\n-              opts: {\n-                width: 128,\n-                height: 128,\n-              },\n-            })\n-            .catch(async (error) => {\n-              console.error(\"Error persisting customer avatar to R2\", error);\n-              // if the avatar fails to upload to R2, set the avatar to null in the database\n-              await prisma.customer.update({\n-                where: {\n-                  id: customer.id,\n-                },\n-                data: {\n-                  avatar: null,\n-                },\n-              });\n-            }),\n+          storage.upload({\n+            key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n+            body: avatar,\n+            opts: {\n+              width: 128,\n+              height: 128,\n+            },\n+          }),\n         );\n       }\n \n@@ -219,4 +206,4 @@ export const POST = withWorkspace(\n       \"enterprise\",\n     ],\n   },\n-);\n+);\n\\ No newline at end of file\ndiff --git a/apps/web/lib/api/conversions/track-lead.ts b/apps/web/lib/api/conversions/track-lead.ts\nindex 1a6f2ad..1bfb398 100644\n--- a/apps/web/lib/api/conversions/track-lead.ts\n+++ b/apps/web/lib/api/conversions/track-lead.ts\n@@ -238,25 +238,14 @@ export const trackLead = async ({\n           finalCustomerAvatar\n         ) {\n           // persist customer avatar to R2\n-          await storage\n-            .upload({\n-              key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n-              body: customerAvatar,\n-              opts: {\n-                width: 128,\n-                height: 128,\n-              },\n-            })\n-            .catch(async (error) => {\n-              console.error(\"Error persisting customer avatar to R2\", error);\n-              // if the avatar fails to upload to R2, set the avatar to null in the database\n-              if (customer) {\n-                await prisma.customer.update({\n-                  where: { id: customer.id },\n-                  data: { avatar: null },\n-                });\n-              }\n-            });\n+          await storage.upload({\n+            key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n+            body: customerAvatar,\n+            opts: {\n+              width: 128,\n+              height: 128,\n+            },\n+          });\n         }\n \n         // if not deferred mode, process the following right away:\n@@ -374,4 +363,4 @@ export const trackLead = async ({\n       externalId: customerExternalId,\n     },\n   });\n-};\n+};\n\\ No newline at end of file\ndiff --git a/apps/web/lib/api/conversions/track-sale.ts b/apps/web/lib/api/conversions/track-sale.ts\nindex dabf756..f0e0ec0 100644\n--- a/apps/web/lib/api/conversions/track-sale.ts\n+++ b/apps/web/lib/api/conversions/track-sale.ts\n@@ -214,25 +214,14 @@ export const trackSale = async ({\n     if (customerAvatar && !isStored(customerAvatar) && finalCustomerAvatar) {\n       // persist customer avatar to R2 if it's not already stored\n       waitUntil(\n-        storage\n-          .upload({\n-            key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n-            body: customerAvatar,\n-            opts: {\n-              width: 128,\n-              height: 128,\n-            },\n-          })\n-          .catch(async (error) => {\n-            console.error(\"Error persisting customer avatar to R2\", error);\n-            // if the avatar fails to upload to R2, set the avatar to null in the database\n-            if (newCustomer) {\n-              await prisma.customer.update({\n-                where: { id: newCustomer.id },\n-                data: { avatar: null },\n-              });\n-            }\n-          }),\n+        storage.upload({\n+          key: finalCustomerAvatar.replace(`${R2_URL}/`, \"\"),\n+          body: customerAvatar,\n+          opts: {\n+            width: 128,\n+            height: 128,\n+          },\n+        }),\n       );\n     }\n \n@@ -523,127 +512,4 @@ const _trackSale = async ({\n         // Update customer sales count\n         prisma.customer.update({\n           where: {\n-            id: customer.id,\n-          },\n-          data: {\n-            sales: {\n-              increment: 1,\n-            },\n-            saleAmount: {\n-              increment: amount,\n-            },\n-          },\n-        }),\n-\n-        // Log conversion event\n-        logConversionEvent({\n-          workspace_id: workspace.id,\n-          link_id: saleData.link_id,\n-          path: \"/track/sale\",\n-          body: JSON.stringify(rawBody),\n-        }),\n-      ]);\n-\n-      let webhookPartner: WebhookPartner | undefined;\n-      // Create partner commission and execute workflows\n-      if (link.programId && link.partnerId) {\n-        const createdCommission = await createPartnerCommission({\n-          event: \"sale\",\n-          programId: link.programId,\n-          partnerId: link.partnerId,\n-          linkId: link.id,\n-          customerId: customer.id,\n-          eventId: saleData.event_id,\n-          amount: saleData.amount,\n-          quantity: 1,\n-          invoiceId,\n-          currency,\n-          context: {\n-            customer: {\n-              country: customer.country,\n-            },\n-            sale: {\n-              productId: metadata?.productId as string,\n-              amount: saleData.amount,\n-            },\n-          },\n-        });\n-\n-        webhookPartner = createdCommission?.webhookPartner;\n-\n-        await Promise.allSettled([\n-          executeWorkflows({\n-            trigger: WorkflowTrigger.saleRecorded,\n-            context: {\n-              programId: link.programId,\n-              partnerId: link.partnerId,\n-              current: {\n-                saleAmount: saleData.amount,\n-                conversions: firstConversionFlag ? 1 : 0,\n-              },\n-            },\n-          }),\n-\n-          syncPartnerLinksStats({\n-            partnerId: link.partnerId,\n-            programId: link.programId,\n-            eventType: \"sale\",\n-          }),\n-\n-          webhookPartner &&\n-            detectAndRecordFraudEvent({\n-              program: { id: link.programId },\n-              partner: pick(webhookPartner, [\"id\", \"email\", \"name\"]),\n-              customer: pick(customer, [\"id\", \"email\", \"name\"]),\n-              commission: { id: createdCommission.commission?.id },\n-              link: pick(link, [\"id\"]),\n-              click: pick(saleData, [\"url\", \"referer\"]),\n-              event: { id: saleData.event_id },\n-            }),\n-        ]);\n-      }\n-\n-      // Send workspace webhook\n-      const webhookPayload = transformSaleEventData({\n-        ...saleData,\n-        clickedAt: customer.clickedAt || customer.createdAt,\n-        link,\n-        customer,\n-        partner: webhookPartner,\n-        metadata,\n-      });\n-\n-      await sendWorkspaceWebhook({\n-        trigger: \"sale.created\",\n-        data: webhookPayload,\n-        workspace,\n-      });\n-    })(),\n-  );\n-\n-  const trackSaleResponse = trackSaleResponseSchema.parse({\n-    eventName,\n-    customer,\n-    sale: {\n-      amount,\n-      currency,\n-      invoiceId,\n-      paymentProcessor,\n-      metadata,\n-    },\n-  });\n-\n-  if (invoiceId) {\n-    waitUntil(\n-      redis.set(\n-        `trackSale:${workspace.id}:invoiceId:${invoiceId}`,\n-        trackSaleResponse,\n-        {\n-          ex: 60 * 60 * 24 * 7, // cache for 1 week\n-        },\n-      ),\n-    );\n-  }\n-\n-  return trackSaleResponse;\n-};\n+            id: customer.\n\\ No newline at end of file\ndiff --git a/apps/web/lib/openapi/customers/create-customer.ts b/apps/web/lib/openapi/customers/create-customer.ts\nnew file mode 100644\nindex 0000000..d80e6f7\n--- /dev/null\n+++ b/apps/web/lib/openapi/customers/create-customer.ts\n@@ -0,0 +1,35 @@\n+import { openApiErrorResponses } from \"@/lib/openapi/responses\";\n+import { ZodOpenApiOperationObject } from \"zod-openapi\";\n+import {\n+  createCustomerBodySchema,\n+  CustomerEnrichedSchema,\n+} from \"../../zod/schemas/customers\";\n+\n+export const createCustomer: ZodOpenApiOperationObject = {\n+  operationId: \"createCustomer\",\n+  \"x-speakeasy-name-override\": \"create\",\n+  summary: \"Create a customer\",\n+  description:\n+    \"[Deprecated]: Customer creation can only be done via tracking a lead event. Use the /track/lead endpoint instead.\",\n+  deprecated: true,\n+  requestBody: {\n+    content: {\n+      \"application/json\": {\n+        schema: createCustomerBodySchema,\n+      },\n+    },\n+  },\n+  responses: {\n+    \"201\": {\n+      description: \"The customer was created.\",\n+      content: {\n+        \"application/json\": {\n+          schema: CustomerEnrichedSchema,\n+        },\n+      },\n+    },\n+    ...openApiErrorResponses,\n+  },\n+  tags: [\"Customers\"],\n+  security: [{ token: [] }],\n+};\ndiff --git a/apps/web/lib/openapi/customers/index.ts b/apps/web/lib/openapi/customers/index.ts\nindex dd5015a..9b72385 100644\n--- a/apps/web/lib/openapi/customers/index.ts\n+++ b/apps/web/lib/openapi/customers/index.ts\n@@ -1,4 +1,5 @@\n import { ZodOpenApiPathsObject } from \"zod-openapi\";\n+import { createCustomer } from \"./create-customer\";\n import { deleteCustomer } from \"./delete-customer\";\n import { getCustomer } from \"./get-customer\";\n import { getCustomers } from \"./get-customers\";\n@@ -7,10 +8,11 @@ import { updateCustomer } from \"./update-customer\";\n export const customersPaths: ZodOpenApiPathsObject = {\n   \"/customers\": {\n     get: getCustomers,\n+    post: createCustomer,\n   },\n   \"/customers/{id}\": {\n     get: getCustomer,\n     patch: updateCustomer,\n     delete: deleteCustomer,\n   },\n-};\n+};\n\\ No newline at end of file\ndiff --git a/apps/web/tests/fraud/index.test.ts b/apps/web/tests/fraud/index.test.ts\nindex d784a54..d30e418 100644\n--- a/apps/web/tests/fraud/index.test.ts\n+++ b/apps/web/tests/fraud/index.test.ts\n@@ -254,4 +254,4 @@ async function waitForFraudEvent({\n     },\n     { retries: 10, interval: 600 },\n   );\n-}\n+}\n\\ No newline at end of file\n",
    "pr_number": 3157,
    "title": "Catch R2 upload error to avoid breaking conversion tracking",
    "test_files": [
      "apps/web/tests/fraud/index.test.ts"
    ],
    "code_files": [
      "apps/web/app/(ee)/api/customers/[id]/route.ts",
      "apps/web/app/(ee)/api/customers/route.ts",
      "apps/web/lib/api/conversions/track-lead.ts",
      "apps/web/lib/api/conversions/track-sale.ts",
      "apps/web/lib/openapi/customers/create-customer.ts",
      "apps/web/lib/openapi/customers/index.ts"
    ]
  },
  {
    "instance_id": "medusajs__medusa.56ed9cf9.14220",
    "repo": "medusajs/medusa",
    "base_commit": "b7adfb225b4e81bd388c01afe254e2de140266b9",
    "bug_patch": "diff --git a/packages/modules/providers/file-s3/integration-tests/__tests__/services.spec.ts b/packages/modules/providers/file-s3/integration-tests/__tests__/services.spec.ts\nindex d2059006..ec104891 100644\n--- a/packages/modules/providers/file-s3/integration-tests/__tests__/services.spec.ts\n+++ b/packages/modules/providers/file-s3/integration-tests/__tests__/services.spec.ts\n@@ -99,23 +99,6 @@ describe.skip(\"S3 File Plugin\", () => {\n     })\n   })\n \n-  it(\"uploads a file with special URL characters in the name\", async () => {\n-    const fileContent = await fs.readFile(fixtureImagePath)\n-    const fixtureAsBinary = fileContent.toString(\"base64\")\n-\n-    const resp = await s3Service.upload({\n-      filename: \"cat?photo.jpg\",\n-      mimeType: \"image/jpeg\",\n-      content: fixtureAsBinary,\n-      access: \"private\",\n-    })\n-\n-    expect(resp).toEqual({\n-      key: expect.stringMatching(/tests\\/catphoto.*\\.jpg/),\n-      url: expect.stringMatching(/https:\\/\\/.*\\/cat%3Fphoto.*\\.jpg/),\n-    })\n-  })\n-\n   it(\"gets a presigned upload URL and uploads a file successfully\", async () => {\n     const fileContent = await fs.readFile(fixtureImagePath)\n     const fixtureAsBinary = fileContent.toString(\"binary\")\n@@ -221,4 +204,4 @@ describe.skip(\"S3 File Plugin\", () => {\n       { fileKey: cat2.key },\n     ])\n   })\n-})\n+})\n\\ No newline at end of file\ndiff --git a/packages/modules/providers/file-s3/src/services/s3-file.ts b/packages/modules/providers/file-s3/src/services/s3-file.ts\nindex f617a722..ac178294 100644\n--- a/packages/modules/providers/file-s3/src/services/s3-file.ts\n+++ b/packages/modules/providers/file-s3/src/services/s3-file.ts\n@@ -160,7 +160,7 @@ export class S3FileService extends AbstractFileProviderService {\n     }\n \n     return {\n-      url: `${this.config_.fileUrl}/${encodeURIComponent(fileKey)}`,\n+      url: `${this.config_.fileUrl}/${encodeURI(fileKey)}`,\n       key: fileKey,\n     }\n   }\n@@ -288,4 +288,4 @@ export class S3FileService extends AbstractFileProviderService {\n \n     return Buffer.from(await response.Body!.transformToByteArray())\n   }\n-}\n+}\n\\ No newline at end of file\n",
    "pr_number": 14220,
    "title": "fix S3 URL escaping",
    "test_files": [
      "packages/modules/providers/file-s3/integration-tests/__tests__/services.spec.ts"
    ],
    "code_files": [
      "packages/modules/providers/file-s3/src/services/s3-file.ts"
    ]
  },
  {
    "instance_id": "medusajs__medusa.56ed9cf9.14209",
    "repo": "medusajs/medusa",
    "base_commit": "765232948900b7be98fb2cef1a9c8caf108a2d1e",
    "bug_patch": "diff --git a/.changeset/shiny-hounds-learn.md b/.changeset/shiny-hounds-learn.md\ndeleted file mode 100644\nindex df370ca6..00000000\n--- a/.changeset/shiny-hounds-learn.md\n+++ /dev/null\n@@ -1,5 +0,0 @@\n----\n-\"@medusajs/file-s3\": patch\n----\n-\n-URL-encode S3 object metadata and returned URL\ndiff --git a/packages/modules/providers/file-s3/integration-tests/__tests__/services.spec.ts b/packages/modules/providers/file-s3/integration-tests/__tests__/services.spec.ts\nindex d2059006..73d7f50e 100644\n--- a/packages/modules/providers/file-s3/integration-tests/__tests__/services.spec.ts\n+++ b/packages/modules/providers/file-s3/integration-tests/__tests__/services.spec.ts\n@@ -1,5 +1,5 @@\n-import axios from \"axios\"\n import fs from \"fs/promises\"\n+import axios from \"axios\"\n import { S3FileService } from \"../../src/services/s3-file\"\n jest.setTimeout(100000)\n \n@@ -221,4 +221,4 @@ describe.skip(\"S3 File Plugin\", () => {\n       { fileKey: cat2.key },\n     ])\n   })\n-})\n+})\n\\ No newline at end of file\ndiff --git a/packages/modules/providers/file-s3/src/services/s3-file.ts b/packages/modules/providers/file-s3/src/services/s3-file.ts\nindex f617a722..0f1de364 100644\n--- a/packages/modules/providers/file-s3/src/services/s3-file.ts\n+++ b/packages/modules/providers/file-s3/src/services/s3-file.ts\n@@ -148,7 +148,7 @@ export class S3FileService extends AbstractFileProviderService {\n       // Note: We could potentially set the content disposition when uploading,\n       // but storing the original filename as metadata should suffice.\n       Metadata: {\n-        \"original-filename\": encodeURIComponent(file.filename),\n+        \"x-amz-meta-original-filename\": file.filename,\n       },\n     })\n \n@@ -160,7 +160,7 @@ export class S3FileService extends AbstractFileProviderService {\n     }\n \n     return {\n-      url: `${this.config_.fileUrl}/${encodeURIComponent(fileKey)}`,\n+      url: `${this.config_.fileUrl}/${fileKey}`,\n       key: fileKey,\n     }\n   }\n@@ -288,4 +288,4 @@ export class S3FileService extends AbstractFileProviderService {\n \n     return Buffer.from(await response.Body!.transformToByteArray())\n   }\n-}\n+}\n\\ No newline at end of file\n",
    "pr_number": 14209,
    "title": "escape non-ascii characters in filenames in s3 file provider",
    "test_files": [
      "packages/modules/providers/file-s3/integration-tests/__tests__/services.spec.ts"
    ],
    "code_files": [
      "packages/modules/providers/file-s3/src/services/s3-file.ts"
    ]
  }
]