[
  {
    "instance_id": "keystonejs__keystone.052f5b1b.9700",
    "repo": "keystonejs__keystone.052f5b1b",
    "base_commit": "052f5b1bfdc76868125722ea385c59ffae7eb000",
    "patch": "diff --git a/examples/logging-opentelemetry/keystone.ts b/examples/logging-opentelemetry/keystone.ts\nindex 44155838a..df6e9d7d5 100644\n--- a/examples/logging-opentelemetry/keystone.ts\n+++ b/examples/logging-opentelemetry/keystone.ts\n@@ -28,13 +28,10 @@ export default config<TypeInfo>({\n \n             return {\n               async willSendResponse({ operation, request }) {\n-                span.setAttribute('graphql.operation.name', operation?.operation || 'unknown')\n-                span.setAttribute('graphql.operation.type', request.operationName || 'unknown')\n-                span.setAttribute(\n-                  'graphql.document.sha256',\n-                  request.query ? sha256(request.query) : 'empty'\n-                )\n-                // span.setAttribute('graphql.document', request.query?.replaceAll(/\\s+/g, ' ') || '') // WARNING: verbose\n+                span.setAttribute('type', operation?.operation || 'unknown')\n+                span.setAttribute('name', request.operationName || 'unknown')\n+                span.setAttribute('hash', request.query ? sha256(request.query) : 'empty')\n+                // span.setAttribute('query', request.query?.replaceAll(/\\s+/g, ' ') || '') // WARNING: verbose\n                 span.end()\n               },\n             }\n@@ -50,9 +47,9 @@ export default config<TypeInfo>({\n           'http request',\n           {\n             attributes: {\n-              'http.request.method': req.method,\n-              'http.request.path': req.path,\n-              'user_agent.original': req.headers['user-agent'] || '',\n+              method: req.method,\n+              path: req.path,\n+              userAgent: req.headers['user-agent'] || '',\n             },\n           },\n           span => {\n@@ -84,4 +81,4 @@ export default config<TypeInfo>({\n     ],\n   },\n   lists,\n-})\n+})\n\\ No newline at end of file\ndiff --git a/packages/core/src/lib/core/mutations/index.ts b/packages/core/src/lib/core/mutations/index.ts\nindex f4d76e3d5..5b48fde28 100644\n--- a/packages/core/src/lib/core/mutations/index.ts\n+++ b/packages/core/src/lib/core/mutations/index.ts\n@@ -79,7 +79,7 @@ async function createSingle__(\n ) {\n   return await withSpan(\n     `create ${list.graphql.names.outputTypeNameLower}`,\n-    async span => {\n+    async () => {\n       // throw an accessDeniedError if not allowed\n       await enforceListLevelAccessControl(context, 'create', list, inputData, undefined)\n       await enforceFieldLevelAccessControl(context, 'create', list, inputData, undefined)\n@@ -94,17 +94,13 @@ async function createSingle__(\n       await beforeOperation()\n \n       // operation\n-      const result = await context.prisma[list.listKey].create({\n+      const item = await context.prisma[list.listKey].create({\n         data: list.isSingleton ? { ...data, id: 1 } : data,\n       })\n \n-      span.setAttribute('keystone.result.id', result?.id ?? '')\n-      return { item: result, afterOperation }\n+      return { item, afterOperation }\n     },\n-    {\n-      'keystone.list': list.listKey,\n-      'keystone.operation': 'create',\n-    }\n+    { 'keystone.list': list.listKey, 'keystone.operation': 'create' }\n   )\n }\n \n@@ -147,7 +143,7 @@ async function updateSingle__(\n ) {\n   return await withSpan(\n     `update ${list.graphql.names.outputTypeNameLower}`,\n-    async span => {\n+    async () => {\n       // validate and resolve the input filter\n       const uniqueWhere = await resolveUniqueWhereInput(where, list, context)\n \n@@ -168,16 +164,15 @@ async function updateSingle__(\n       await beforeOperation()\n \n       // operation\n-      const result = await context.prisma[list.listKey].update({\n+      const updatedItem = await context.prisma[list.listKey].update({\n         where: { id: item.id },\n         data,\n       })\n-      span.setAttribute('keystone.result.id', result?.id ?? '')\n \n       // after operation\n-      await afterOperation(result)\n+      await afterOperation(updatedItem)\n \n-      return result\n+      return updatedItem\n     },\n     { 'keystone.list': list.listKey, 'keystone.operation': 'update' }\n   )\n@@ -191,7 +186,7 @@ async function deleteSingle__(\n ) {\n   return await withSpan(\n     `delete ${list.graphql.names.outputTypeNameLower}`,\n-    async span => {\n+    async () => {\n       // validate and resolve the input filter\n       const uniqueWhere = await resolveUniqueWhereInput(where, list, context)\n \n@@ -219,7 +214,6 @@ async function deleteSingle__(\n \n       // operation\n       const result = await context.prisma[list.listKey].delete({ where: { id: item.id } })\n-      span.setAttribute('keystone.result.id', result?.id ?? '')\n \n       // after operation\n       await runSideEffectOnlyHook(list, 'afterOperation', {\n@@ -242,7 +236,7 @@ async function actionSingle__(\n ) {\n   return await withSpan(\n     action.otel,\n-    async span => {\n+    async () => {\n       // no before operation hook for actions\n \n       // operation\n@@ -254,7 +248,6 @@ async function actionSingle__(\n         },\n         context\n       )\n-      span.setAttribute('keystone.result.id', (result?.id as string) ?? '')\n \n       // no after operation hook for actions\n       return result\n@@ -458,454 +451,4 @@ async function getResolvedData(\n         const inputResolver = field.input?.[operation]?.resolve\n         let input = resolvedData[fieldKey]\n         if (inputResolver && field.dbField.kind === 'relation') {\n-          const tag = `${list.listKey}.${fieldKey}`\n-          try {\n-            input = await inputResolver(\n-              input,\n-              context,\n-              // this third argument only applies to relationship fields\n-              (() => {\n-                if (input === undefined) {\n-                  // no-op: this is what we want\n-                  return () => undefined\n-                }\n-                if (input === null) {\n-                  // no-op: should this be userinputerror?\n-                  return () => undefined\n-                }\n-                const foreignList = list.lists[field.dbField.list]\n-                if (field.dbField.mode === 'many' && operation === 'create') {\n-                  return resolveRelateToManyForCreateInput(\n-                    nestedMutationState,\n-                    context,\n-                    foreignList,\n-                    tag\n-                  )\n-                }\n-\n-                if (field.dbField.mode === 'many' && operation === 'update') {\n-                  return resolveRelateToManyForUpdateInput(\n-                    nestedMutationState,\n-                    context,\n-                    foreignList,\n-                    tag\n-                  )\n-                }\n-\n-                if (field.dbField.mode === 'one' && operation === 'create') {\n-                  return resolveRelateToOneForCreateInput(nestedMutationState, context, foreignList)\n-                }\n-\n-                if (field.dbField.mode === 'one' && operation === 'update') {\n-                  return resolveRelateToOneForUpdateInput(nestedMutationState, context, foreignList)\n-                }\n-\n-                throw new Error('Unknown relationship field type input mode or operation')\n-              })()\n-            )\n-          } catch (error: any) {\n-            if (error instanceof RelationshipErrors) {\n-              relationshipErrors.push(...error.errors)\n-            } else {\n-              relationshipErrors.push({ error, tag })\n-            }\n-          }\n-        }\n-        return [fieldKey, input] as const\n-      })\n-    )\n-  )\n-\n-  if (relationshipErrors.length) throw relationshipError(relationshipErrors)\n-\n-  // field hooks\n-  const fieldsErrors: { error: Error; tag: string }[] = []\n-  resolvedData = Object.fromEntries(\n-    await Promise.all(\n-      Object.entries(list.fields).map(async ([fieldKey, field]) => {\n-        try {\n-          return [\n-            fieldKey,\n-            operation === 'create'\n-              ? await field.hooks.resolveInput.create({\n-                  ...hookArgs,\n-                  itemField: undefined,\n-                  inputFieldData: hookArgs.inputData[fieldKey],\n-                  resolvedData,\n-                  resolvedFieldData: resolvedData[fieldKey],\n-                  fieldKey,\n-                })\n-              : await field.hooks.resolveInput.update({\n-                  ...hookArgs,\n-                  itemField: hookArgs.item[fieldKey],\n-                  inputFieldData: hookArgs.inputData[fieldKey],\n-                  resolvedData,\n-                  resolvedFieldData: resolvedData[fieldKey],\n-                  fieldKey,\n-                }),\n-          ]\n-        } catch (error: any) {\n-          fieldsErrors.push({\n-            error,\n-            tag: `${list.listKey}.${fieldKey}.hooks.resolveInput`,\n-          })\n-          return [fieldKey, undefined]\n-        }\n-      })\n-    )\n-  )\n-\n-  if (fieldsErrors.length) throw extensionError('resolveInput', fieldsErrors)\n-\n-  // list hooks\n-  try {\n-    if (operation === 'create') {\n-      resolvedData = await list.hooks.resolveInput.create({ ...hookArgs, resolvedData })\n-    } else if (operation === 'update') {\n-      resolvedData = await list.hooks.resolveInput.update({ ...hookArgs, resolvedData })\n-    }\n-  } catch (error: any) {\n-    throw extensionError('resolveInput', [{ error, tag: `${list.listKey}.hooks.resolveInput` }])\n-  }\n-\n-  return resolvedData\n-}\n-\n-async function resolveInputForCreateOrUpdate(\n-  list: InitialisedList,\n-  context: KeystoneContext,\n-  inputData: Record<string, unknown>,\n-  item: BaseItem | undefined\n-) {\n-  const nestedMutationState = new NestedMutationState(context)\n-  const baseHookArgs = {\n-    context,\n-    listKey: list.listKey,\n-    inputData,\n-    resolvedData: {},\n-  }\n-  const hookArgs =\n-    item === undefined\n-      ? { ...baseHookArgs, operation: 'create' as const, item, originalItem: undefined }\n-      : { ...baseHookArgs, operation: 'update' as const, item, originalItem: item }\n-\n-  // Take the original input and resolve all the fields down to what\n-  // will be saved into the database.\n-  hookArgs.resolvedData = await getResolvedData(list, hookArgs, nestedMutationState)\n-\n-  // Apply all validation checks\n-  await validate({ list, hookArgs })\n-\n-  // Return the full resolved input (ready for prisma level operation),\n-  // and the afterOperation hook to be applied\n-  return {\n-    data: transformForPrismaClient(list, context, hookArgs.resolvedData),\n-    beforeOperation: async () => {\n-      // before operation\n-      await runSideEffectOnlyHook(list, 'beforeOperation', hookArgs)\n-    },\n-    afterOperation: async (updatedItem: BaseItem) => {\n-      await nestedMutationState.afterOperation()\n-\n-      // after operation\n-      await runSideEffectOnlyHook(list, 'afterOperation', {\n-        ...hookArgs,\n-        item: updatedItem,\n-      })\n-    },\n-  }\n-}\n-\n-function transformInnerDBField(\n-  dbField: Exclude<ResolvedDBField, { kind: 'multi' }>,\n-  context: KeystoneContext,\n-  value: unknown\n-) {\n-  if (dbField.kind === 'scalar' && dbField.scalar === 'Json' && value === null) {\n-    return context.__internal.prisma.DbNull\n-  }\n-  return value\n-}\n-\n-function transformForPrismaClient(\n-  list: InitialisedList,\n-  context: KeystoneContext,\n-  data: Record<string, any>\n-) {\n-  return Object.fromEntries([\n-    ...(function* () {\n-      for (const fieldKey in data) {\n-        if (!(fieldKey in list.fields)) {\n-          // either the types are wrong, or someone didnt use them, either way, bail out\n-          throw new Error(`Attempted to use unknown field \"${fieldKey}\"`)\n-        }\n-        const value = data[fieldKey]\n-        const { dbField } = list.fields[fieldKey]\n-\n-        if (dbField.kind === 'multi') {\n-          for (const innerFieldKey in value) {\n-            const innerFieldValue = value[innerFieldKey]\n-            yield [\n-              getDBFieldKeyForFieldOnMultiField(fieldKey, innerFieldKey),\n-              transformInnerDBField(dbField.fields[innerFieldKey], context, innerFieldValue),\n-            ]\n-          }\n-\n-          continue\n-        }\n-\n-        yield [fieldKey, transformInnerDBField(dbField, context, value)]\n-      }\n-    })(),\n-  ])\n-}\n-\n-// This is not a thing that I really agree with but it's to make the behaviour consistent with old keystone.\n-// Basically, old keystone uses Promise.allSettled and then after that maps that into promises that resolve and reject,\n-// whereas the new stuff is just like \"here are some promises\" with no guarantees about the order they will be settled in.\n-// That doesn't matter when they all resolve successfully because the order they resolve successfully in\n-// doesn't affect anything, If some reject though, the order that they reject in will be the order in the errors array\n-// and some of our tests rely on the order of the graphql errors array. They shouldn't, but they do.\n-function promisesButSettledWhenAllSettledAndInOrder<T extends Promise<unknown>[]>(promises: T): T {\n-  const resultsPromise = Promise.allSettled(promises)\n-  return promises.map(async (_, i) => {\n-    const result: PromiseSettledResult<Awaited<T>> = (await resultsPromise)[i] as any\n-    return result.status === 'fulfilled'\n-      ? Promise.resolve(result.value)\n-      : Promise.reject(result.reason)\n-  }) as T\n-}\n-\n-function nonNull<T extends GNullableInputType>(t: T) {\n-  if (t === g.Empty) return t\n-  return g.nonNull(t)\n-}\n-\n-export function getMutationsForList(list: InitialisedList) {\n-  const defaultUniqueWhereInput = list.isSingleton ? { id: '1' } : undefined\n-\n-  const createOne_ = g.field({\n-    type: list.graphql.types.output,\n-    args: {\n-      data: g.arg({ type: nonNull(list.graphql.types.create) }),\n-    },\n-    async resolve(_, { data }, context, info) {\n-      return await withSpan(\n-        `mutation ${info.fieldName}`,\n-        async () => {\n-          return createOne(data, list, context)\n-        },\n-        { 'keystone.list': list.listKey, 'keystone.operation': 'create' }\n-      )\n-    },\n-  })\n-\n-  const createMany_ = g.field({\n-    type: g.list(list.graphql.types.output),\n-    args: {\n-      data: g.arg({\n-        type: g.nonNull(g.list(nonNull(list.graphql.types.create))),\n-      }),\n-    },\n-    async resolve(_, { data }, context, info) {\n-      return await withSpan(\n-        `mutation ${info.fieldName}`,\n-        async () => {\n-          return promisesButSettledWhenAllSettledAndInOrder(await createMany(data, list, context))\n-        },\n-        { 'keystone.list': list.listKey, 'keystone.operation': 'create', 'keystone.many': true }\n-      )\n-    },\n-  })\n-\n-  const updateOne_ = g.field({\n-    type: list.graphql.types.output,\n-    args: {\n-      where: g.arg({\n-        type: g.nonNull(list.graphql.types.uniqueWhere),\n-        defaultValue: defaultUniqueWhereInput,\n-      }),\n-      data: g.arg({ type: nonNull(list.graphql.types.update) }),\n-    },\n-    async resolve(_, { where, data }, context, info) {\n-      return await withSpan(\n-        `mutation ${info.fieldName}`,\n-        async () => {\n-          return updateOne({ where, data }, list, context)\n-        },\n-        { 'keystone.list': list.listKey, 'keystone.operation': 'update' }\n-      )\n-    },\n-  })\n-\n-  const updateManyInput = g.inputObject({\n-    name: list.graphql.names.updateManyInputName,\n-    fields: {\n-      where: g.arg({\n-        type: g.nonNull(list.graphql.types.uniqueWhere),\n-        defaultValue: defaultUniqueWhereInput,\n-      }),\n-      data: g.arg({ type: nonNull(list.graphql.types.update) }),\n-    },\n-  })\n-  const updateMany_ = g.field({\n-    type: g.list(list.graphql.types.output),\n-    args: {\n-      data: g.arg({\n-        type: g.nonNull(g.list(g.nonNull(updateManyInput))),\n-      }),\n-    },\n-    async resolve(_, { data }, context, info) {\n-      return await withSpan(\n-        `mutation ${info.fieldName}`,\n-        async () => {\n-          return promisesButSettledWhenAllSettledAndInOrder(await updateMany(data, list, context))\n-        },\n-        { 'keystone.list': list.listKey, 'keystone.operation': 'update', 'keystone.many': true }\n-      )\n-    },\n-  })\n-\n-  const deleteOne_ = g.field({\n-    type: list.graphql.types.output,\n-    args: {\n-      where: g.arg({\n-        type: g.nonNull(list.graphql.types.uniqueWhere),\n-        defaultValue: defaultUniqueWhereInput,\n-      }),\n-    },\n-    async resolve(_, { where }, context, info) {\n-      return await withSpan(\n-        `mutation ${info.fieldName}`,\n-        async () => {\n-          return deleteOne(where, list, context)\n-        },\n-        { 'keystone.list': list.listKey, 'keystone.operation': 'delete' }\n-      )\n-    },\n-  })\n-\n-  const deleteMany_ = g.field({\n-    type: g.list(list.graphql.types.output),\n-    args: {\n-      where: g.arg({\n-        type: g.nonNull(g.list(g.nonNull(list.graphql.types.uniqueWhere))),\n-      }),\n-    },\n-    async resolve(_, { where }, context, info) {\n-      return await withSpan(\n-        `mutation ${info.fieldName}`,\n-        async () => {\n-          return promisesButSettledWhenAllSettledAndInOrder(await deleteMany(where, list, context))\n-        },\n-        { 'keystone.list': list.listKey, 'keystone.operation': 'delete', 'keystone.many': true }\n-      )\n-    },\n-  })\n-\n-  const collectedTypes: GraphQLNamedType[] = []\n-  const { isEnabled } = list.graphql\n-  if (isEnabled.type) {\n-    // adding all of these types explicitly isn't strictly necessary but we do it to create a certain order in the schema\n-    collectedTypes.push(list.graphql.types.output)\n-    if (isEnabled.query || isEnabled.update || isEnabled.delete) {\n-      collectedTypes.push(list.graphql.types.uniqueWhere)\n-    }\n-    if (isEnabled.query) {\n-      for (const field of Object.values(list.fields)) {\n-        if (\n-          isEnabled.query &&\n-          field.graphql.isEnabled.read &&\n-          field.unreferencedConcreteInterfaceImplementations\n-        ) {\n-          // this _IS_ actually necessary since they aren't implicitly referenced by other types, unlike the types above\n-          collectedTypes.push(...field.unreferencedConcreteInterfaceImplementations)\n-        }\n-      }\n-      collectedTypes.push(list.graphql.types.where)\n-      collectedTypes.push(list.graphql.types.orderBy)\n-    }\n-    if (isEnabled.update) {\n-      if (list.graphql.types.update instanceof GInputObjectType) {\n-        collectedTypes.push(list.graphql.types.update)\n-      }\n-      collectedTypes.push(updateManyInput)\n-    }\n-    if (isEnabled.create) {\n-      if (list.graphql.types.create instanceof GInputObjectType) {\n-        collectedTypes.push(list.graphql.types.create)\n-      }\n-    }\n-  }\n-\n-  return {\n-    mutations: {\n-      ...(list.graphql.isEnabled.create && {\n-        [list.graphql.names.createMutationName]: createOne_,\n-        [list.graphql.names.createManyMutationName]: createMany_,\n-      }),\n-      ...(list.graphql.isEnabled.update && {\n-        [list.graphql.names.updateMutationName]: updateOne_,\n-        [list.graphql.names.updateManyMutationName]: updateMany_,\n-      }),\n-      ...(list.graphql.isEnabled.delete && {\n-        [list.graphql.names.deleteMutationName]: deleteOne_,\n-        [list.graphql.names.deleteManyMutationName]: deleteMany_,\n-      }),\n-      ...Object.fromEntries(\n-        (function* () {\n-          for (const action of list.actions) {\n-            yield [\n-              action.graphql.names.one,\n-              g.field({\n-                type: list.graphql.types.output,\n-                args: {\n-                  where: g.arg({\n-                    type: g.nonNull(list.graphql.types.uniqueWhere),\n-                    defaultValue: defaultUniqueWhereInput,\n-                  }),\n-                },\n-                async resolve(_, { where }, context, info) {\n-                  return await withSpan(\n-                    `mutation ${info.fieldName}`,\n-                    async () => {\n-                      return actionOne(where, list, context, action)\n-                    },\n-                    { 'keystone.list': list.listKey, 'keystone.action': action.actionKey }\n-                  )\n-                },\n-              }),\n-            ]\n-            yield [\n-              action.graphql.names.many,\n-              g.field({\n-                type: g.list(list.graphql.types.output),\n-                args: {\n-                  where: g.arg({\n-                    type: g.nonNull(g.list(g.nonNull(list.graphql.types.uniqueWhere))),\n-                  }),\n-                },\n-                async resolve(_, { where }, context, info) {\n-                  return await withSpan(\n-                    `mutation ${info.fieldName}`,\n-                    async () => {\n-                      return promisesButSettledWhenAllSettledAndInOrder(\n-                        await actionMany(where, list, context, action)\n-                      )\n-                    },\n-                    {\n-                      'keystone.list': list.listKey,\n-                      'keystone.action': action.actionKey,\n-                      'keystone.many': true,\n-                    }\n-                  )\n-                },\n-              }),\n-            ]\n-          }\n-        })()\n-      ),\n-    },\n-    types: collectedTypes,\n-  }\n-}\n+          const tag = `${list.listKey}.\n\\ No newline at end of file\ndiff --git a/packages/core/src/lib/utils.ts b/packages/core/src/lib/utils.ts\nindex c28c531e0..089e87264 100644\n--- a/packages/core/src/lib/utils.ts\n+++ b/packages/core/src/lib/utils.ts\n@@ -1,21 +1,14 @@\n-// WARNING: this is an opinionated subject, with too many ways to do this\n-//   we went with a subset that we are happy with\n-//   see tests2/utils.test.ts for examples\n-export function humanize(s: string, capitalize: boolean = true) {\n-  // drop non-alphanumeric\n-  s = s.replace(/[^a-zA-Z0-9]+/g, ' ')\n+/**\n+ * Turns a passed in string into a human readable label\n+ * @param {String} str The string to convert.\n+ * @returns The new string\n+ */\n+export function humanize(str: string, capitalize: boolean = true) {\n+  str = str.replace(/[^a-zA-Z0-9]+/g, ' ').replace(/([a-z0-9])([A-Z]+)/g, '$1 $2')\n \n-  // insert spaces before camels of length > 1\n-  for (let i = 0; i < 24; i++) {\n-    // not unbounded, shouldnt happen\n-    const next = s.replace(/([a-z0-9])([A-Z][A-Za-z0-9])/, '$1 $2')\n-    if (next === s) break\n-    s = next\n-  }\n-\n-  if (!capitalize) return s\n-  return s\n+  if (!capitalize) return str\n+  return str\n     .split(' ')\n     .map(x => x.charAt(0).toUpperCase() + x.slice(1))\n     .join(' ')\n-}\n+}\n\\ No newline at end of file\ndiff --git a/tests2/utils.test.ts b/tests2/utils.test.ts\nindex 00ab8adc7..4ccbe8420 100644\n--- a/tests2/utils.test.ts\n+++ b/tests2/utils.test.ts\n@@ -11,19 +11,12 @@ describe('utils', () => {\n     assert.equal(humanize('kebab-case'), 'Kebab Case')\n     assert.equal(humanize('multiple words here'), 'Multiple Words Here')\n     assert.equal(humanize('Multiple Words Here'), 'Multiple Words Here')\n+    assert.equal(humanize('Thing42WithOther43'), 'Thing42 With Other43')\n+    assert.equal(humanize('Thing42_withOther43', false), 'Thing42 with Other43')\n     assert.equal(humanize('foo'), 'Foo')\n     assert.equal(humanize('Foo'), 'Foo')\n     assert.equal(humanize('fooBar'), 'Foo Bar')\n     assert.equal(humanize('FooBar'), 'Foo Bar')\n     assert.equal(humanize('Foo Bar'), 'Foo Bar')\n-    assert.equal(humanize('Foo11WithBar11'), 'Foo11 With Bar11')\n-    assert.equal(humanize('Foo1A_WithBar11'), 'Foo1A With Bar11')\n-    assert.equal(humanize('Foo1AA_WithBar11'), 'Foo1 AA With Bar11')\n-    assert.equal(humanize('Foo11_WithBar11'), 'Foo11 With Bar11')\n-    assert.equal(humanize('Foo11_WithBar11A'), 'Foo11 With Bar11A')\n-    assert.equal(humanize('Foo11_WithBar11AA'), 'Foo11 With Bar11 AA')\n-    assert.equal(humanize('Foo11_withBar11', false), 'Foo11 with Bar11')\n-    assert.equal(humanize('FOO1A_BAR11'), 'FOO1A BAR11')\n-    assert.equal(humanize('FOO1A1_BAR11'), 'FOO1 A1 BAR11')\n   })\n-})\n+})\n\\ No newline at end of file\n",
    "test_patch": "",
    "problem_statement": "",
    "hints_text": ""
  },
  {
    "instance_id": "keystonejs__keystone.052f5b1b.9730",
    "repo": "keystonejs__keystone.052f5b1b",
    "base_commit": "052f5b1bfdc76868125722ea385c59ffae7eb000",
    "patch": "diff --git a/examples/actions/schema.ts b/examples/actions/schema.ts\nindex 2ed99c523..ee46aaf15 100644\n--- a/examples/actions/schema.ts\n+++ b/examples/actions/schema.ts\n@@ -37,7 +37,9 @@ export const lists = {\n     fields: {\n       title: text(),\n       content: text(),\n-      hidden: checkbox({\n+      hidden: checkbox(),\n+      votes: integer({ defaultValue: 0 }),\n+      reportedAt: timestamp({\n         ui: {\n           itemView: {\n             fieldMode: ({ item, itemField }) => {\n@@ -49,8 +51,6 @@ export const lists = {\n           },\n         },\n       }),\n-      votes: integer({ defaultValue: 0, ...readOnly }),\n-      reportedAt: timestamp({ ...readOnly }),\n     },\n     actions: {\n       vote: {\n@@ -112,11 +112,11 @@ export const lists = {\n           messages: {\n             promptTitle: 'Report {singular}',\n             promptTitleMany: 'Report {count} {singular|plural}',\n-            prompt: 'Are you sure you want to report \u201c{itemLabel}\u201d?',\n+            prompt: 'Are you sure you want to report \"{itemLabel}\"?',\n             promptMany: 'Are you sure you want to report {count} {singular|plural}?',\n             promptConfirmLabel: 'Yes, report',\n             promptConfirmLabelMany: 'Yes, report {count} {singular|plural}',\n-            fail: 'Could not report {singular} \u201c{itemLabel}\u201d',\n+            fail: 'Could not report {singular} \"{itemLabel}\"',\n             failMany: 'Could not report {countFail} {singular|plural}',\n             success: '{Singular} reported',\n             successMany: 'Successfully reported {countSuccess} {singular|plural}',\n@@ -141,4 +141,4 @@ export const lists = {\n       },\n     },\n   }),\n-} satisfies Lists\n+} satisfies Lists\n\\ No newline at end of file\ndiff --git a/packages/core/src/fields/types/checkbox/views/index.tsx b/packages/core/src/fields/types/checkbox/views/index.tsx\nindex 7ccf76fba..b94b6a678 100644\n--- a/packages/core/src/fields/types/checkbox/views/index.tsx\n+++ b/packages/core/src/fields/types/checkbox/views/index.tsx\n@@ -3,7 +3,6 @@ import { Icon } from '@keystar/ui/icon'\n import { checkIcon } from '@keystar/ui/icon/icons/checkIcon'\n import { Text, VisuallyHidden } from '@keystar/ui/typography'\n \n-import { entriesTyped } from '../../../../lib/core/utils'\n import type {\n   CellComponent,\n   FieldController,\n@@ -11,6 +10,7 @@ import type {\n   FieldProps,\n   SimpleFieldTypeInfo,\n } from '../../../../types'\n+import { entriesTyped } from '../../../../lib/core/utils'\n \n export function Field({ field, value, onChange, autoFocus }: FieldProps<typeof controller>) {\n   return (\n@@ -94,4 +94,4 @@ export function controller(\n       },\n     },\n   }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/core/src/lib/admin-meta-graphql.ts b/packages/core/src/lib/admin-meta-graphql.ts\nindex 1695ccb72..3d5b06f19 100644\n--- a/packages/core/src/lib/admin-meta-graphql.ts\n+++ b/packages/core/src/lib/admin-meta-graphql.ts\n@@ -86,7 +86,7 @@ const KeystoneAdminUIFieldMeta = g.object<FieldMetaSource>()({\n           }),\n           isRequired: g.field({\n             type: g.nonNull(g.JSON),\n-            resolve({ listKey, fieldKey, itemView, item, itemField }, _, context) {\n+            resolve({ item, fieldKey, itemView, itemField, listKey }, _, context) {\n               const { isRequired } = itemView\n               if (typeof isRequired !== 'function') return isRequired\n               return isRequired({\n@@ -316,12 +316,7 @@ const KeystoneAdminUIListMeta = g.object<ListMetaSource>()({\n     path: g.field({ type: g.nonNull(g.String) }),\n \n     labelField: g.field({ type: g.nonNull(g.String) }),\n-    fields: g.field({\n-      resolve: ({ fields, item }) => {\n-        return fields.map(f => ({ ...f, item, itemField: item?.[f.key] ?? null }))\n-      },\n-      type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldMeta))),\n-    }),\n+    fields: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldMeta))) }),\n     groups: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIFieldGroupMeta))) }),\n     actions: g.field({ type: g.nonNull(g.list(g.nonNull(KeystoneAdminUIActionMeta))) }),\n     graphql: g.field({ type: g.nonNull(KeystoneAdminUIGraphQL) }),\n@@ -357,14 +352,8 @@ const adminMeta = g.object<AdminMetaSource>()({\n             item: null,\n           }\n         }\n-        // WARNING: do not use sudo\n         const item = await context.db[key].findOne({ where: { id: itemId } })\n-        if (!item) {\n-          return {\n-            ...source.listsByKey[key],\n-            item: null,\n-          }\n-        }\n+        if (!item) return null\n         return {\n           ...source.listsByKey[key],\n           item,\n@@ -390,4 +379,4 @@ export const KeystoneMeta = g.object<{ adminMeta: AdminMetaSource }>()({\n       },\n     }),\n   },\n-})\n+})\n\\ No newline at end of file\ndiff --git a/tests2/omit.test.ts b/tests2/omit.test.ts\nindex c5a21fcb7..ab61d8b01 100644\n--- a/tests2/omit.test.ts\n+++ b/tests2/omit.test.ts\n@@ -73,13 +73,13 @@ const fieldsMatrix = [\n \n function makeList({\n   fields,\n-  defaultIsFilterable,\n-  defaultIsOrderable,\n+  isFilterable,\n+  isOrderable,\n   omit,\n }: {\n   fields: typeof fieldsMatrix\n-  defaultIsFilterable: boolean\n-  defaultIsOrderable: boolean\n+  isFilterable: boolean\n+  isOrderable: boolean\n   omit:\n     | boolean\n     | {\n@@ -89,22 +89,21 @@ function makeList({\n         delete: boolean\n       }\n }) {\n-  const prefix =\n-    `List${fields.length}_Filt${yn(defaultIsFilterable)}_Ord${yn(defaultIsOrderable)}` as const\n-  const name__ = `${prefix}_Omit${\n+  const prefix = `List${fields.length}_Filt${yn(isFilterable)}_Ord${yn(isOrderable)}` as const\n+  const __name = `${prefix}_Omit${\n     typeof omit !== 'object'\n       ? yn(omit)\n       : [omit.query, omit.create, omit.update, omit.delete].map(yn).join('')\n   }`\n \n   return {\n-    name__,\n+    __name,\n     access: allowAll,\n     fields: Object.fromEntries(fields),\n-    defaultIsFilterable,\n-    defaultIsOrderable,\n+    defaultIsFilterable: isFilterable,\n+    defaultIsOrderable: isOrderable,\n     graphql: {\n-      plural: name__ + 's',\n+      plural: __name + 's',\n       omit,\n     },\n   } as const\n@@ -112,15 +111,10 @@ function makeList({\n \n const listsMatrix = [\n   ...(function* () {\n-    for (const defaultIsFilterable of [false, true]) {\n-      for (const defaultIsOrderable of [false, true]) {\n+    for (const isFilterable of [false, true]) {\n+      for (const isOrderable of [false, true]) {\n         for (const omit of [false, true]) {\n-          yield makeList({\n-            fields: fieldsMatrix,\n-            defaultIsFilterable,\n-            defaultIsOrderable,\n-            omit,\n-          })\n+          yield makeList({ fields: fieldsMatrix, isFilterable, isOrderable, omit })\n         }\n \n         for (const query of [false, true]) {\n@@ -129,8 +123,8 @@ const listsMatrix = [\n               for (const delete_ of [false, true]) {\n                 yield makeList({\n                   fields: fieldsMatrix,\n-                  defaultIsFilterable,\n-                  defaultIsOrderable,\n+                  isFilterable,\n+                  isOrderable,\n                   omit: {\n                     query,\n                     create,\n@@ -141,8 +135,8 @@ const listsMatrix = [\n \n                 yield makeList({\n                   fields: [],\n-                  defaultIsFilterable,\n-                  defaultIsOrderable,\n+                  isFilterable,\n+                  isOrderable,\n                   omit: {\n                     query,\n                     create,\n@@ -162,24 +156,24 @@ const listsMatrix = [\n // TODO: FIXME: skip for now, MySQL has a limit on the number of indexes\n if (dbProvider !== 'mysql') {\n   listsMatrix.push({\n-    name__: 'RelatedToAll',\n+    __name: 'RelatedToAll',\n     access: allowAll,\n     fields: Object.fromEntries(\n       (function* () {\n         for (const l of listsMatrix) {\n           // WARNING: if names exceed some length, expect duplicate _AB_unique index errors\n           yield [\n-            `R${l.name__}_one`,\n+            `R${l.__name}_one`,\n             relationship({\n-              ref: l.name__,\n+              ref: l.__name,\n               many: false,\n             }),\n           ] as const\n \n           yield [\n-            `R${l.name__}_many`,\n+            `R${l.__name}_many`,\n             relationship({\n-              ref: l.name__,\n+              ref: l.__name,\n               many: true,\n             }),\n           ] as const\n@@ -340,18 +334,15 @@ describe(`Omit (${dbProvider})`, () => {\n \n   const suite = setupTestSuite({\n     config: {\n-      lists: Object.fromEntries(listsMatrix.map(({ name__: __name, ...l }) => [__name, list(l)])),\n+      lists: Object.fromEntries(listsMatrix.map(({ __name, ...l }) => [__name, list(l)])),\n     },\n   })\n \n   const data = suite().then(async ({ context }) => await introspectSchema(context))\n-  const dataInternal = suite().then(\n-    async ({ context }) => await introspectSchema(context.internal())\n-  )\n-  const dataSudo = suite().then(async ({ context }) => await introspectSchema(context.sudo()))\n+  const sudoData = suite().then(async ({ context }) => await introspectSchema(context.sudo()))\n \n   for (const l of listsMatrix) {\n-    const listName = l.name__\n+    const listName = l.__name\n     const omit = l.graphql.omit\n \n     // common context is configurable\n@@ -404,4 +395,4 @@ describe(`Omit (${dbProvider})`, () => {\n       })\n     })\n   }\n-})\n+})\n\\ No newline at end of file\n",
    "test_patch": "",
    "problem_statement": "",
    "hints_text": ""
  },
  {
    "instance_id": "keystonejs__keystone.052f5b1b.9737",
    "repo": "keystonejs__keystone.052f5b1b",
    "base_commit": "052f5b1bfdc76868125722ea385c59ffae7eb000",
    "patch": "diff --git a/packages/core/src/fields/types/relationship/views/useApolloQuery.ts b/packages/core/src/fields/types/relationship/views/useApolloQuery.ts\nindex 5cf30b1c1..eafa69fbf 100644\n--- a/packages/core/src/fields/types/relationship/views/useApolloQuery.ts\n+++ b/packages/core/src/fields/types/relationship/views/useApolloQuery.ts\n@@ -1,5 +1,4 @@\n import { useEffect, useMemo, useState } from 'react'\n-import isDeepEqual from 'fast-deep-equal'\n \n import type { ListMeta, ListSortDescriptor } from '../../../../types'\n import {\n@@ -64,11 +63,14 @@ export function useApolloQuery(args: {\n   const manipulatedSearch =\n     state.kind === 'one' && state.value?.label === debouncedSearch ? '' : debouncedSearch\n \n-  const searchFilter = useSearchFilter(manipulatedSearch, list, searchFields)\n+  // TODO: rewrite\n   const _where = {\n-    OR: searchFilter,\n+    OR: useSearchFilter(manipulatedSearch, list, searchFields),\n   }\n-  const where = args.filter ? { AND: [_where, args.filter] } : _where\n+  // memo is used for referential stability, not for performance\n+  const where = useMemo(() => {\n+    return args.filter ? { AND: [_where, args.filter] } : _where\n+  }, [args.filter, _where])\n \n   const orderBy = useMemo(() => {\n     return args.sort ? { [args.sort.field]: args.sort.direction.toLowerCase() } : undefined\n@@ -127,7 +129,7 @@ export function useApolloQuery(args: {\n       !loading &&\n       skip &&\n       data.items.length < count &&\n-      (!isDeepEqual(lastFetchMore?.where, where) ||\n+      (lastFetchMore?.where !== where ||\n         lastFetchMore?.list !== list ||\n         lastFetchMore?.skip !== skip)\n     ) {\n@@ -182,4 +184,4 @@ function getLoadingState(options: { loading: boolean; search: string }): Loading\n   return 'idle'\n }\n \n-type LoadingState = 'loading' | 'sorting' | 'loadingMore' | 'error' | 'idle' | 'filtering'\n+type LoadingState = 'loading' | 'sorting' | 'loadingMore' | 'error' | 'idle' | 'filtering'\n\\ No newline at end of file\ndiff --git a/tests/admin-ui-tests/relations.test.ts b/tests/admin-ui-tests/relations.test.ts\nindex 3a3690868..00040e8ba 100644\n--- a/tests/admin-ui-tests/relations.test.ts\n+++ b/tests/admin-ui-tests/relations.test.ts\n@@ -1,6 +1,6 @@\n import type { Browser, Page } from 'playwright'\n import { expect } from 'playwright/test'\n-import { adminUITests, callGraphQL } from './utils'\n+import { adminUITests } from './utils'\n \n const gql = ([str]: TemplateStringsArray) => str\n \n@@ -79,33 +79,7 @@ adminUITests('./tests/test-projects/basic', browserType => {\n     await expect(page.getByText('A task')).toBeHidden()\n   })\n \n-  test(\"the combobox having to paginate doesn't break the page\", async () => {\n-    await callGraphQL(\n-      gql`\n-        mutation ($data: [PersonCreateInput!]!) {\n-          createPeople(data: $data) {\n-            id\n-          }\n-        }\n-      `,\n-      {\n-        data: [\n-          { name: 'User to pick' },\n-          ...Array.from({ length: 100 }, (_, i) => ({ name: `User ${i}` })),\n-        ],\n-      }\n-    )\n-\n-    await page.goto(`http://localhost:3000/tasks/create`)\n-    await page.getByRole('textbox', { name: 'Label' }).fill('some task')\n-    await page.getByRole('combobox', { name: 'Assigned To' }).click()\n-    await page.getByRole('button', { name: 'Show suggestions Assigned To' }).click()\n-    await page.getByText('User to pick').click()\n-    await page.getByRole('button', { name: 'Create' }).click()\n-    await expect(page.getByText('Task created')).toBeVisible()\n-  })\n-\n   afterAll(async () => {\n     await browser.close()\n   })\n-})\n+})\n\\ No newline at end of file\ndiff --git a/tests/admin-ui-tests/utils.ts b/tests/admin-ui-tests/utils.ts\nindex d74d8c7dd..dd78749ea 100644\n--- a/tests/admin-ui-tests/utils.ts\n+++ b/tests/admin-ui-tests/utils.ts\n@@ -160,18 +160,4 @@ export async function spawnCommand3(cwd: string, commands: string[], waitOn: str\n     },\n     exited: exitPromise,\n   }\n-}\n-\n-// TODO: use elsewhere in tests\n-export async function callGraphQL(query: string, variables?: Record<string, any>) {\n-  const result = await fetch('http://localhost:3000/api/graphql', {\n-    method: 'POST',\n-    headers: { 'Content-Type': 'application/json' },\n-    body: JSON.stringify({\n-      query,\n-      variables,\n-    }),\n-  }).then(res => res.json())\n-  expect(result.errors).toBeUndefined()\n-  return result.data\n-}\n+}\n\\ No newline at end of file\n",
    "test_patch": "",
    "problem_statement": "",
    "hints_text": ""
  },
  {
    "instance_id": "keystonejs__keystone.052f5b1b.9691",
    "repo": "keystonejs__keystone.052f5b1b",
    "base_commit": "052f5b1bfdc76868125722ea385c59ffae7eb000",
    "patch": "diff --git a/examples/actions/schema.ts b/examples/actions/schema.ts\nindex 2ed99c523..6b61dd140 100644\n--- a/examples/actions/schema.ts\n+++ b/examples/actions/schema.ts\n@@ -94,7 +94,6 @@ export const lists = {\n         access: allowAll,\n         async resolve({ actionKey, where }, context) {\n           console.log(`${actionKey}`, JSON.stringify({ where }))\n-          // throw new Error('Random failure, try again')\n           return await context.db.Post.updateOne({\n             where,\n             data: {\n@@ -112,11 +111,11 @@ export const lists = {\n           messages: {\n             promptTitle: 'Report {singular}',\n             promptTitleMany: 'Report {count} {singular|plural}',\n-            prompt: 'Are you sure you want to report \u201c{itemLabel}\u201d?',\n+            prompt: 'Are you sure you want to report \"{itemLabel}\"?',\n             promptMany: 'Are you sure you want to report {count} {singular|plural}?',\n             promptConfirmLabel: 'Yes, report',\n             promptConfirmLabelMany: 'Yes, report {count} {singular|plural}',\n-            fail: 'Could not report {singular} \u201c{itemLabel}\u201d',\n+            fail: 'Could not report {singular}',\n             failMany: 'Could not report {countFail} {singular|plural}',\n             success: '{Singular} reported',\n             successMany: 'Successfully reported {countSuccess} {singular|plural}',\n@@ -141,4 +140,4 @@ export const lists = {\n       },\n     },\n   }),\n-} satisfies Lists\n+} satisfies Lists\n\\ No newline at end of file\ndiff --git a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/CreateItemPage/index.tsx b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/CreateItemPage/index.tsx\nindex 9de55f204..0aed4f369 100644\n--- a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/CreateItemPage/index.tsx\n+++ b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/CreateItemPage/index.tsx\n@@ -25,7 +25,6 @@ function CreateItemPage({ listKey }: { listKey: string }) {\n       header={\n         <ItemPageHeader\n           list={list}\n-          actions={[]}\n           label=\"Create\"\n           title={`Create ${list.singular}`}\n           item={null}\n@@ -66,4 +65,4 @@ function CreateItemPage({ listKey }: { listKey: string }) {\n       </ColumnLayout>\n     </PageContainer>\n   )\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/common.tsx b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/common.tsx\nindex a197bb2c3..ee54e00c6 100644\n--- a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/common.tsx\n+++ b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/common.tsx\n@@ -18,20 +18,19 @@ import type { ActionMeta, ListMeta } from '../../../../types'\n \n export function ItemPageHeader({\n   list,\n-  actions,\n   item,\n   label,\n   title = label,\n   onAction,\n }: {\n   list: ListMeta\n-  actions: ActionMeta[]\n   item: Record<string, unknown> | null\n   label: string\n   title: string\n-  onAction: ((action: ActionMeta, resultId: string | null) => void) | null\n+  onAction: ((action: ActionMeta, resultId: string) => void) | null\n }) {\n   const router = useRouter()\n+  const actions = list.actions.filter(action => action.itemView.actionMode !== 'hidden')\n \n   return (\n     <Grid\n@@ -88,11 +87,6 @@ function replace(\n   return s\n }\n \n-type ActionError = {\n-  action: ActionMeta\n-  error: Error\n-}\n-\n function ItemActions({\n   list,\n   item,\n@@ -114,7 +108,7 @@ function ItemActions({\n       })),\n     [actions]\n   )\n-  const [actionError, setActionError] = useState<ActionError | null>(null)\n+  const [errorDialogValue, setErrorDialogValue] = useState<Error | null>(null)\n   const [activeAction, setActiveAction] = useState<ActionMeta | null>(null)\n   const itemLabel_ = item[list.labelField] ?? item.id\n   const itemLabel = typeof itemLabel_ === 'string' ? itemLabel_ : (item.id as string)\n@@ -148,11 +142,11 @@ function ItemActions({\n         toastQueue.neutral(replace(m.success, list, { itemLabel }), { timeout: 5000 })\n       }\n \n-      onAction(action, data.data?.result?.id ?? null)\n-    } catch (error: any) {\n+      onAction(action, data.data?.result?.id)\n+    } catch (err: any) {\n       toastQueue.critical(replace(m.fail, list, { itemLabel }), {\n         actionLabel: 'Details',\n-        onAction: () => setActionError({ action, error }),\n+        onAction: () => setErrorDialogValue(err),\n         shouldCloseOnAction: true,\n       })\n     }\n@@ -195,13 +189,8 @@ function ItemActions({\n         )}\n       </DialogContainer>\n \n-      <DialogContainer onDismiss={() => setActionError(null)} isDismissable>\n-        {actionError && (\n-          <ErrorDetailsDialog\n-            title={replace(actionError.action.messages.fail, list, { itemLabel })}\n-            error={actionError.error}\n-          />\n-        )}\n+      <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n+        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n       </DialogContainer>\n     </Fragment>\n   )\n@@ -289,4 +278,4 @@ export function BaseToolbar(props: { children: ReactNode }) {\n       </HStack>\n     </Grid>\n   )\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/index.tsx b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/index.tsx\nindex 562d63437..d13a6f89b 100644\n--- a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/index.tsx\n+++ b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ItemPage/index.tsx\n@@ -90,7 +90,7 @@ function DeleteButton({\n             try {\n               await deleteItem()\n             } catch (err: any) {\n-              toastQueue.critical('Unable to delete item', {\n+              toastQueue.critical('Unable to delete item.', {\n                 actionLabel: 'Details',\n                 onAction: () => setErrorDialogValue(err),\n                 shouldCloseOnAction: true,\n@@ -112,9 +112,7 @@ function DeleteButton({\n       </DialogTrigger>\n \n       <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n-        {errorDialogValue && (\n-          <ErrorDetailsDialog title=\"Unable to delete item\" error={errorDialogValue} />\n-        )}\n+        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n       </DialogContainer>\n     </Fragment>\n   )\n@@ -178,7 +176,7 @@ function ItemForm({\n }) {\n   const list = useList(listKey)\n   const itemId = initialValue.id as string\n-  const [updateError, setUpdateError] = useState<Error | null>(null)\n+  const [errorDialogValue, setErrorDialogValue] = useState<Error | null>(null)\n   const [update, { loading, error }] = useMutation(\n     gql`mutation ($id: ID!, $data: ${list.graphql.names.updateInputName}!) {\n       item: ${list.graphql.names.updateMutationName}(where: { id: $id }, data: $data) {\n@@ -216,13 +214,13 @@ function ItemForm({\n     if (error) {\n       toastQueue.critical('Unable to save item', {\n         actionLabel: 'Details',\n-        onAction: () => setUpdateError(new Error(error.message)),\n+        onAction: () => setErrorDialogValue(new Error(error.message)),\n         shouldCloseOnAction: true,\n       })\n       return\n     }\n \n-    toastQueue.positive(`Saved changes to ${list.singular.toLocaleLowerCase()}.`, {\n+    toastQueue.positive(`Saved changes to ${list.singular.toLocaleLowerCase()}`, {\n       timeout: 5000,\n     })\n \n@@ -296,8 +294,8 @@ function ItemForm({\n         </BaseToolbar>\n       </form>\n \n-      <DialogContainer onDismiss={() => setUpdateError(null)} isDismissable>\n-        {updateError && <ErrorDetailsDialog title=\"Unable to save item\" error={updateError} />}\n+      <DialogContainer onDismiss={() => setErrorDialogValue(null)} isDismissable>\n+        {errorDialogValue && <ErrorDetailsDialog error={errorDialogValue} />}\n       </DialogContainer>\n     </Fragment>\n   )\n@@ -322,55 +320,25 @@ function ItemPage({ listKey }: ItemPageProps) {\n     return deserializeItemToValue(list.fields, item)\n   }, [list.fields, data?.item])\n \n-  const { actionsInContext, fieldModes, fieldPositions, isRequireds } = useMemo(() => {\n-    const actionModes = Object.fromEntries(\n-      Object.entries(list.actions).map(([k, v]) => [k, v.itemView.actionMode])\n-    )\n+  const { fieldModes, fieldPositions, isRequireds } = useMemo(() => {\n     const fieldModes = Object.fromEntries(\n-      Object.entries(list.fields).map(([k, v]) => [k, v.itemView.fieldMode])\n+      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.fieldMode])\n     )\n     const fieldPositions = Object.fromEntries(\n-      Object.entries(list.fields).map(([k, v]) => [k, v.itemView.fieldPosition])\n+      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.fieldPosition])\n     )\n     const isRequireds = Object.fromEntries(\n-      Object.entries(list.fields).map(([k, v]) => [k, v.itemView.isRequired])\n+      Object.entries(list.fields).map(([key, val]) => [key, val.itemView.isRequired])\n     )\n-    for (const field of data?.keystone?.adminMeta?.list?.fields ?? []) {\n-      if (\n-        !field?.itemView ||\n-        !field.key ||\n-        !field.itemView.fieldMode ||\n-        !field.itemView.fieldPosition ||\n-        !field.itemView.isRequired\n-      )\n-        continue\n-      fieldModes[field.key] = field.itemView.fieldMode\n-      fieldPositions[field.key] = field.itemView.fieldPosition\n-      isRequireds[field.key] = field.itemView.isRequired\n-    }\n-    for (const action of data?.keystone?.adminMeta?.list?.actions ?? []) {\n-      if (!action?.itemView?.actionMode || !action.key) continue\n-      actionModes[action.key] = action.itemView.actionMode\n-    }\n-\n-    // actions within context of an item\n-    const actionsInContext = list.actions\n-      .map(action => ({\n-        ...action,\n-        itemView: {\n-          ...action.itemView,\n-          actionMode: actionModes[action.key],\n-        },\n-      }))\n-      .filter(action => action.itemView.actionMode !== 'hidden')\n-\n-    return {\n-      actionsInContext,\n-      fieldModes,\n-      fieldPositions,\n-      isRequireds,\n+    for (const field of data?.keystone.adminMeta.list?.fields ?? []) {\n+      if (field.itemView) {\n+        fieldModes[field.key] = field.itemView.fieldMode\n+        fieldPositions[field.key] = field.itemView.fieldPosition\n+        isRequireds[field.key] = field.itemView.isRequired\n+      }\n     }\n-  }, [data?.keystone?.adminMeta, list.fields])\n+    return { fieldModes, fieldPositions, isRequireds }\n+  }, [data?.keystone.adminMeta, list.fields])\n \n   function onAction(action: ActionMeta, resultId: string | null) {\n     const { navigation } = action.itemView\n@@ -390,7 +358,6 @@ function ItemPage({ listKey }: ItemPageProps) {\n       header={\n         <ItemPageHeader\n           list={list}\n-          actions={actionsInContext}\n           label={typeof pageLabel !== 'string' ? 'Loading...' : pageLabel}\n           title={pageTitle}\n           item={item ?? null}\n@@ -410,20 +377,20 @@ function ItemPage({ listKey }: ItemPageProps) {\n               (list.isSingleton ? (\n                 itemId === '1' ? (\n                   <ItemNotFound>\n-                    <Text>\u201c{list.label}\u201d doesn\u2019t exist, or you don\u2019t have access to it.</Text>\n+                    <Text>\"{list.label}\" doesn't exist, or you don't have access to it.</Text>\n                     {!list.hideCreate && <CreateButtonLink list={list} />}\n                   </ItemNotFound>\n                 ) : (\n                   <ItemNotFound>\n                     <Text>\n-                      An item with ID <strong>\u201c{itemId}\u201d</strong> does not exist.\n+                      An item with ID <strong>\"{itemId}\"</strong> does not exist.\n                     </Text>\n                   </ItemNotFound>\n                 )\n               ) : (\n                 <ItemNotFound>\n                   <Text>\n-                    The item with ID <strong>\u201c{itemId}\u201d</strong> doesn\u2019t exist, or you don\u2019t have\n+                    The item with ID <strong>\"{itemId}\"</strong> doesn't exist, or you don't have\n                     access to it.\n                   </Text>\n                 </ItemNotFound>\n@@ -444,4 +411,4 @@ function ItemPage({ listKey }: ItemPageProps) {\n       )}\n     </PageContainer>\n   )\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/index.tsx b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/index.tsx\nindex 803fa0596..78e3b1e82 100644\n--- a/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/index.tsx\n+++ b/packages/core/src/___internal-do-not-use-will-break-in-patch/admin-ui/pages/ListPage/index.tsx\n@@ -1,5 +1,4 @@\n import isDeepEqual from 'fast-deep-equal'\n-import type { GraphQLFormattedError } from 'graphql'\n import { useRouter } from 'next/router'\n import type { ParsedUrlQuery, ParsedUrlQueryInput } from 'querystring'\n import { type FormEvent, type Key, Fragment, useEffect, useId, useMemo, useState } from 'react'\n@@ -13,7 +12,7 @@ import { chevronDownIcon } from '@keystar/ui/icon/icons/chevronDownIcon'\n import { searchXIcon } from '@keystar/ui/icon/icons/searchXIcon'\n import { textSelectIcon } from '@keystar/ui/icon/icons/textSelectIcon'\n import { undo2Icon } from '@keystar/ui/icon/icons/undo2Icon'\n-import { Box, Flex, HStack, VStack } from '@keystar/ui/layout'\n+import { Flex, HStack, VStack } from '@keystar/ui/layout'\n import { Menu, MenuTrigger } from '@keystar/ui/menu'\n import { ProgressCircle } from '@keystar/ui/progress'\n import { SearchField } from '@keystar/ui/search-field'\n@@ -32,10 +31,8 @@ import { toastQueue } from '@keystar/ui/toast'\n import { Tooltip, TooltipTrigger } from '@keystar/ui/tooltip'\n import { Heading, Text } from '@keystar/ui/typography'\n \n-import { TextLink } from '@keystar/ui/link'\n-import { Notice } from '@keystar/ui/notice'\n import type { TypedDocumentNode } from '../../../../admin-ui/apollo'\n-import { CombinedGraphQLErrors, gql, useMutation, useQuery } from '../../../../admin-ui/apollo'\n+import { gql, useMutation, useQuery } from '../../../../admin-ui/apollo'\n import { CreateButtonLink } from '../../../../admin-ui/components/CreateButtonLink'\n import { EmptyState } from '../../../../admin-ui/components/EmptyState'\n import { GraphQLErrorNotice } from '../../../../admin-ui/components/GraphQLErrorNotice'\n@@ -254,8 +251,7 @@ function ListPage({ listKey }: ListPageProps) {\n   const localStorageListKey = `keystone.list.${listKey}.list.page.info`\n \n   const list = useList(listKey)\n-  const { query, replace: routerReplace, isReady } = useRouter()\n-  const [loaded, setLoaded] = useState(false)\n+  const { query, replace, isReady } = useRouter()\n   const [sort, setSort] = useState<SortDescriptor | null>(() => getSort(list, {}))\n   const [columns, setColumns] = useState<string[]>(list.initialColumns)\n   const [filters, setFilters] = useState<Filter[]>(() => getFilters(list, {}))\n@@ -264,7 +260,6 @@ function ListPage({ listKey }: ListPageProps) {\n   const [searchString, setSearchString] = useState('')\n   const [selectedItems, setSelectedItems] = useState<Selection>(() => new Set([]))\n   const [activeAction, setActiveAction] = useState<Key | null>(null)\n-  const [actionResult, setActionResult] = useState<ActionErrorResult | null>(null)\n   const dirty = useMemo(() => {\n     const defaultFilters = getFilters(list, {})\n     const defaultSort = getSort(list, {})\n@@ -321,8 +316,8 @@ function ListPage({ listKey }: ListPageProps) {\n     }\n \n     localStorage.setItem(localStorageListKey, JSON.stringify(updatedQuery))\n-    routerReplace({ query: updatedQuery })\n-  }, [columns, sort, filters, currentPage, pageSize, searchString, list, loaded])\n+    replace({ query: updatedQuery })\n+  }, [columns, sort, filters, currentPage, pageSize, searchString, list])\n \n   const allowCreate = !(list.hideCreate ?? true)\n   const isConstrained = Boolean(filters.length || query.search)\n@@ -412,481 +407,4 @@ function ListPage({ listKey }: ListPageProps) {\n   const isEmpty = Boolean(data?.count === 0 && !isConstrained)\n   const headers = shownFields.map(field => {\n     return {\n-      id: field.key,\n-      label: field.label,\n-      allowsSorting: !isConstrained && !data?.items?.length ? false : field.isOrderable,\n-    }\n-  })\n-\n-  function onAddFilter(newFilter: Filter) {\n-    setFilters(prevFilters => [...prevFilters, newFilter])\n-  }\n-\n-  function resetToDefaults() {\n-    const defaultFilters = getFilters(list, {})\n-    const defaultSort = getSort(list, {})\n-    setSearchString('')\n-    setColumns(list.initialColumns)\n-    setFilters(defaultFilters)\n-    setSort(defaultSort)\n-  }\n-\n-  const actions = list.actions.filter(action => action.listView.actionMode === 'enabled')\n-  const actionsForList = list.hideDelete\n-    ? actions\n-    : [\n-        ...actions,\n-        {\n-          key: 'delete',\n-          label: 'Delete',\n-          icon: 'trash2Icon',\n-          graphql: {\n-            names: {\n-              one: list.graphql.names.deleteMutationName,\n-              many: list.graphql.names.deleteManyMutationName,\n-            },\n-          },\n-          messages: {\n-            promptTitle: 'Delete {singular}?',\n-            promptTitleMany: 'Delete {count} {singular|plural}?',\n-            prompt: 'Are you sure you want to delete {singular}? This action cannot be undone.',\n-            promptMany:\n-              'Are you sure you want to delete {count} {singular|plural}? This action cannot be undone.',\n-            promptConfirmLabel: 'Yes, delete',\n-            promptConfirmLabelMany: 'Yes, delete',\n-            success: 'Deleted {singular}.',\n-            successMany: 'Deleted {countSuccess} {singular|plural}.',\n-            fail: 'Unable to delete {singular}.',\n-            failMany: 'Unable to delete {countFail} {singular|plural}.',\n-          },\n-          itemView: null as any, // unusud\n-          listView: { actionMode: list.hideDelete ? 'hidden' : 'enabled' },\n-        } as const,\n-      ]\n-  const selectionMode = actionsForList.length > 0 ? 'multiple' : 'none'\n-\n-  return (\n-    <PageContainer\n-      header={<ListPageHeader listKey={listKey} showCreate={allowCreate} />}\n-      title={list.label}\n-    >\n-      <VStack flex gap=\"large\" paddingY=\"xlarge\" minHeight={0} minWidth={0}>\n-        <HStack gap=\"regular\" alignItems=\"center\">\n-          <SearchField\n-            aria-label=\"Search\"\n-            isDisabled={isEmpty}\n-            onClear={() => setSearchString('')}\n-            onChange={v => setSearchString(v)}\n-            placeholder=\"Search\u2026\"\n-            value={searchString}\n-            width=\"alias.singleLineWidth\"\n-            flexGrow={{ mobile: 1, tablet: 0 }}\n-          />\n-          <FilterAdd listKey={listKey} onAdd={onAddFilter} isDisabled={isEmpty} />\n-          <MenuTrigger>\n-            <ActionButton isDisabled={isEmpty}>\n-              <Text>Columns</Text>\n-              <Icon src={chevronDownIcon} />\n-            </ActionButton>\n-            <Menu\n-              items={readableFields}\n-              disallowEmptySelection\n-              onSelectionChange={selection => {\n-                if (selection === 'all') {\n-                  setColumns(readableFields.map(field => field.id))\n-                } else {\n-                  setColumns(readableFields.filter(f => selection.has(f.id)).map(f => f.id))\n-                }\n-              }}\n-              selectionMode=\"multiple\"\n-              selectedKeys={columns}\n-            >\n-              {item => <Item key={item.value}>{item.label}</Item>}\n-            </Menu>\n-          </MenuTrigger>\n-          {dirty ? (\n-            <TooltipTrigger>\n-              <ActionButton aria-label=\"reset\" onPress={resetToDefaults} prominence=\"low\">\n-                <Icon src={undo2Icon} />\n-              </ActionButton>\n-              <Tooltip>Reset to defaults</Tooltip>\n-            </TooltipTrigger>\n-          ) : null}\n-          {isReady && loading && (\n-            <ProgressCircle aria-label=\"Loading\u2026\" size=\"small\" isIndeterminate />\n-          )}\n-        </HStack>\n-\n-        {filters.length ? (\n-          <Flex gap=\"small\" wrap>\n-            {filters.map((filter, i) => {\n-              const field = list.fields[filter.field]\n-              function onRemove() {\n-                setFilters(prevFilters => prevFilters.filter(f => f !== filter))\n-              }\n-              function onChange(updatedFilter: Filter) {\n-                setFilters(prevFilters => [...prevFilters.filter(f => f !== filter), updatedFilter])\n-              }\n-\n-              return (\n-                <FilterTag\n-                  key={i}\n-                  field={field}\n-                  filter={filter}\n-                  onChange={onChange}\n-                  onRemove={onRemove}\n-                />\n-              )\n-            })}\n-          </Flex>\n-        ) : null}\n-\n-        <GraphQLErrorNotice errors={[error]} />\n-\n-        <ActionBarContainer flex minHeight=\"scale.3000\">\n-          <TableView\n-            aria-labelledby={LIST_PAGE_TITLE_ID}\n-            selectionMode={selectionMode}\n-            onSortChange={setSort}\n-            sortDescriptor={sort ?? undefined}\n-            density=\"spacious\"\n-            overflowMode=\"truncate\"\n-            onSelectionChange={setSelectedItems}\n-            selectedKeys={selectedItems}\n-            renderEmptyState={() =>\n-              loading ? (\n-                <ProgressCircle aria-label=\"Preparing items\" isIndeterminate />\n-              ) : isConstrained ? (\n-                <EmptyState\n-                  icon={searchXIcon}\n-                  title=\"No results\"\n-                  message=\"No items found. Try adjusting your search or filters.\"\n-                />\n-              ) : (\n-                <EmptyState\n-                  icon={textSelectIcon}\n-                  title=\"Empty list\"\n-                  message=\"Add the first item to see it here.\"\n-                />\n-              )\n-            }\n-            flex\n-            UNSAFE_style={{\n-              opacity: loading && !!data ? 0.5 : undefined,\n-            }}\n-          >\n-            <TableHeader columns={headers}>\n-              {({ label, id, ...options }) => (\n-                <Column key={id} isRowHeader {...options}>\n-                  {label}\n-                </Column>\n-              )}\n-            </TableHeader>\n-            <TableBody items={data?.items ?? []}>\n-              {row => {\n-                return (\n-                  <Row href={`/${list.path}/${row?.id}`}>\n-                    {key => {\n-                      const field = list.fields[key]\n-                      const value = row[key]\n-                      const CellContent = field.views.Cell\n-                      return (\n-                        <Cell>\n-                          {CellContent ? (\n-                            <CellContent value={value} field={field.controller} item={row} />\n-                          ) : (\n-                            <Text>{value?.toString()}</Text>\n-                          )}\n-                        </Cell>\n-                      )\n-                    }}\n-                  </Row>\n-                )\n-              }}\n-            </TableBody>\n-          </TableView>\n-\n-          <ActionBar\n-            selectedItemCount={selectedItemIds.length}\n-            onClearSelection={() => setSelectedItems(new Set())}\n-            UNSAFE_className={css({\n-              // TODO: update in @keystar/ui package\n-              // make `tokenSchema.size.shadow.regular` token \"0 1px 4px\"\n-              'div:has([data-focus-scope-start])': {\n-                backgroundColor: tokenSchema.color.background.canvas,\n-                border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.emphasis}`,\n-                borderRadius: tokenSchema.size.radius.regular,\n-                boxShadow: `0 1px 4px ${tokenSchema.color.shadow.regular}`,\n-              },\n-            })}\n-            onAction={setActiveAction}\n-          >\n-            {[\n-              ...(function* () {\n-                for (const action of actionsForList) {\n-                  const iconComponent = action.icon ? KeystarIcons[action.icon] : null\n-                  yield (\n-                    <Item key={action.key} textValue={action.label}>\n-                      {iconComponent ? <Icon src={iconComponent} /> : null}\n-                      <Text>{action.label}</Text>\n-                    </Item>\n-                  )\n-                }\n-              })(),\n-            ]}\n-          </ActionBar>\n-        </ActionBarContainer>\n-\n-        {!!data?.count && (\n-          <PaginationControls\n-            singular={list.singular}\n-            plural={list.plural}\n-            currentPage={currentPage}\n-            pageSize={pageSize}\n-            total={data.count}\n-            onChangePage={(page: number) => setCurrentPage(page)}\n-            onChangePageSize={(pageSize: number) => setPageSize(pageSize)}\n-            defaultPageSize={list.pageSize}\n-          />\n-        )}\n-\n-        <DialogContainer\n-          onDismiss={() => {\n-            setActiveAction(null)\n-          }}\n-        >\n-          {actionsForList\n-            .filter(action => action.key === activeAction)\n-            .map(action => {\n-              return (\n-                <ActionItemsDialog\n-                  itemIds={selectedItemIds}\n-                  action={action}\n-                  list={list}\n-                  onSuccess={remaining => {\n-                    refetch()\n-                    setSelectedItems(remaining)\n-                  }}\n-                  onErrors={setActionResult}\n-                />\n-              )\n-            })\n-            .pop()}\n-        </DialogContainer>\n-        <DialogContainer onDismiss={() => setActionResult(null)} isDismissable>\n-          {actionResult ? (\n-            <Dialog>\n-              <Heading>Error details for {actionResult.action.label} action</Heading>\n-              <Content>\n-                <VStack gap=\"large\">\n-                  {[\n-                    ...(function* () {\n-                      const { action, errors: actionErrors } = actionResult\n-                      for (const [itemId, itemActionErrors] of Object.entries(actionErrors)) {\n-                        const item = data?.items?.find(i => i.id === itemId) ?? null\n-                        const itemLabel = (item?.[list.labelField] as string | null) ?? itemId\n-                        const href = `/${list.path}/${itemId}`\n-\n-                        for (const error of itemActionErrors) {\n-                          yield (\n-                            <VStack key={itemId} gap=\"regular\">\n-                              <Notice tone=\"critical\">\n-                                <Content>\n-                                  <Text>\n-                                    You might try running the action again from{' '}\n-                                    <TextLink href={href}>\n-                                      the {list.singular.toLowerCase()}.\n-                                    </TextLink>\n-                                  </Text>\n-                                  <Box\n-                                    elementType=\"pre\"\n-                                    backgroundColor=\"critical\"\n-                                    borderRadius=\"regular\"\n-                                    maxHeight=\"100%\"\n-                                    overflow=\"auto\"\n-                                  >\n-                                    <Text\n-                                      color=\"critical\"\n-                                      UNSAFE_className={css({\n-                                        fontFamily: tokenSchema.typography.fontFamily.code,\n-                                      })}\n-                                    >\n-                                      {error.message}\n-                                    </Text>\n-                                  </Box>\n-                                </Content>\n-                                <div>\n-                                  <Heading>\n-                                    {replace(action.messages.fail, list, { itemLabel }, false)}\n-                                  </Heading>\n-                                </div>\n-                              </Notice>\n-                            </VStack>\n-                          )\n-                        }\n-                      }\n-                    })(),\n-                  ]}\n-                </VStack>\n-              </Content>\n-            </Dialog>\n-          ) : null}\n-        </DialogContainer>\n-      </VStack>\n-    </PageContainer>\n-  )\n-}\n-\n-const LIST_PAGE_TITLE_ID = 'keystone-list-page-title'\n-\n-function ListPageHeader({ listKey, showCreate }: { listKey: string; showCreate?: boolean }) {\n-  const list = useList(listKey)\n-  return (\n-    <Fragment>\n-      <Heading id={LIST_PAGE_TITLE_ID} elementType=\"h1\" size=\"small\">\n-        {list.label}\n-      </Heading>\n-      {showCreate && (\n-        <CreateButtonLink\n-          list={list}\n-        >{`New ${list.singular.toLocaleLowerCase()}`}</CreateButtonLink>\n-      )}\n-    </Fragment>\n-  )\n-}\n-\n-function replace(\n-  s: string,\n-  list: ListMeta,\n-  args: {\n-    itemLabel?: string\n-    count?: number\n-    countFail?: number\n-    countSuccess?: number\n-  },\n-  many: boolean\n-) {\n-  if (s.includes('{singular|plural}'))\n-    s = s.replaceAll('{singular|plural}', many ? '{plural}' : '{singular}')\n-  if (s.includes('{Singular}')) s = s.replaceAll('{Singular}', list.singular)\n-  if (s.includes('{Plural}')) s = s.replaceAll('{Plural}', list.plural)\n-  if (s.includes('{singular}')) s = s.replaceAll('{singular}', list.singular.toLowerCase())\n-  if (s.includes('{plural}')) s = s.replaceAll('{plural}', list.plural.toLowerCase())\n-  if ('count' in args) s = s.replaceAll('{count}', String(args.count))\n-  if ('countFail' in args) s = s.replaceAll('{countFail}', String(args.countFail))\n-  if ('countSuccess' in args) s = s.replaceAll('{countSuccess}', String(args.countSuccess))\n-  if ('itemLabel' in args) s = s.replaceAll('{itemLabel}', args.itemLabel ?? '')\n-  return s\n-}\n-\n-type ActionErrors = Record<string, GraphQLFormattedError[]>\n-type ActionErrorResult = {\n-  action: ActionMeta\n-  errors: ActionErrors\n-}\n-\n-function ActionItemsDialog({\n-  list,\n-  itemIds,\n-  onSuccess,\n-  onErrors,\n-  action,\n-}: {\n-  list: ListMeta\n-  itemIds: string[]\n-  onSuccess: (remaining: Set<string>) => void\n-  onErrors: (result: ActionErrorResult) => void\n-  action: ActionMeta\n-}) {\n-  const [actionOnItems] = useMutation<{ results?: ({ id: string } | null)[] }>(\n-    gql`mutation($where: [${list.graphql.names.whereUniqueInputName}!]!) {\n-      results: ${action.graphql.names.many}(where: $where) {\n-        id\n-      }\n-    }`,\n-    {\n-      variables: { where: itemIds.map(id => ({ id })) },\n-      errorPolicy: 'all',\n-    }\n-  )\n-  const { messages: m } = action\n-\n-  async function onTryAction() {\n-    try {\n-      const { error } = await actionOnItems()\n-      const failed = new Set<string>()\n-      const actionErrors: ActionErrors = {}\n-      let countFail = 0\n-      if (CombinedGraphQLErrors.is(error)) {\n-        countFail = error.errors.length\n-        for (const err of error.errors ?? []) {\n-          const i = err.path?.[1]\n-          if (typeof i !== 'number') continue\n-          const itemId = itemIds[i]\n-\n-          failed.add(itemId)\n-          actionErrors[itemId] ??= []\n-          actionErrors[itemId].push(err)\n-        }\n-      }\n-      const countSuccess = itemIds.length - countFail\n-\n-      if (countSuccess) {\n-        toastQueue.neutral(\n-          replace(\n-            m.successMany,\n-            list,\n-            {\n-              count: itemIds.length,\n-              countFail,\n-              countSuccess,\n-            },\n-            countSuccess > 1\n-          ),\n-          { timeout: 5000 }\n-        )\n-      }\n-\n-      if (countFail) {\n-        toastQueue.critical(\n-          replace(\n-            m.failMany,\n-            list,\n-            {\n-              count: itemIds.length,\n-              countFail,\n-              countSuccess,\n-            },\n-            countFail > 1\n-          ),\n-          {\n-            actionLabel: 'Details',\n-            onAction: () => onErrors({ action, errors: actionErrors }),\n-            shouldCloseOnAction: true,\n-          }\n-        )\n-      }\n-\n-      return onSuccess(failed)\n-    } catch (error) {\n-      console.error(error)\n-    }\n-  }\n-\n-  return (\n-    <AlertDialog\n-      tone={action.key === 'delete' ? 'critical' : 'neutral'}\n-      title={replace(m.promptTitleMany, list, { count: itemIds.length }, itemIds.length > 1)}\n-      cancelLabel=\"Cancel\"\n-      primaryActionLabel={replace(\n-        m.promptConfirmLabelMany,\n-        list,\n-        { count: itemIds.length },\n-        itemIds.length > 1\n-      )}\n-      onPrimaryAction={onTryAction}\n-    >\n-      <Text>{replace(m.promptMany, list, { count: itemIds.length }, itemIds.length > 1)}</Text>\n-    </AlertDialog>\n-  )\n-}\n+      id: field.\n\\ No newline at end of file\ndiff --git a/packages/core/src/admin-ui/components/Errors.tsx b/packages/core/src/admin-ui/components/Errors.tsx\nindex 493a480e7..58240fabd 100644\n--- a/packages/core/src/admin-ui/components/Errors.tsx\n+++ b/packages/core/src/admin-ui/components/Errors.tsx\n@@ -5,7 +5,6 @@ import { Dialog } from '@keystar/ui/dialog'\n import { Icon } from '@keystar/ui/icon'\n import { alertTriangleIcon } from '@keystar/ui/icon/icons/alertTriangleIcon'\n import { Box, Grid, VStack } from '@keystar/ui/layout'\n-import { Notice } from '@keystar/ui/notice'\n import { Content, SlotProvider } from '@keystar/ui/slots'\n import { css, tokenSchema } from '@keystar/ui/style'\n import { Heading, Text } from '@keystar/ui/typography'\n@@ -84,34 +83,26 @@ export function ErrorContainer({ children }: ErrorContainerProps) {\n   )\n }\n \n-export function ErrorDetailsDialog({ title, error }: { title: string; error: Error }) {\n+export function ErrorDetailsDialog({ error }: { error: Error }) {\n   const { message, stack } = error\n   return (\n     <Dialog>\n       <Heading>Error details</Heading>\n       <Content>\n-        <Notice tone=\"critical\">\n-          <Content>\n-            <Text weight=\"medium\">{message}</Text>\n+        <VStack gap=\"large\">\n+          <Text weight=\"medium\">{message}</Text>\n+          {stack && (\n             <Box\n               elementType=\"pre\"\n               backgroundColor=\"critical\"\n               borderRadius=\"regular\"\n               maxHeight=\"100%\"\n+              padding=\"medium\"\n               overflow=\"auto\"\n             >\n               <Text\n                 color=\"critical\"\n-                UNSAFE_className={css({\n-                  fontFamily: tokenSchema.typography.fontFamily.code,\n-                })}\n-              >\n-                {message}\n-              </Text>\n-              <Text\n-                color=\"critical\"\n-                marginTop=\"small\"\n-                size=\"small\"\n+                trim={false}\n                 UNSAFE_className={css({\n                   fontFamily: tokenSchema.typography.fontFamily.code,\n                 })}\n@@ -119,12 +110,9 @@ export function ErrorDetailsDialog({ title, error }: { title: string; error: Err\n                 {stack}\n               </Text>\n             </Box>\n-          </Content>\n-          <div>\n-            <Heading>{title}</Heading>\n-          </div>\n-        </Notice>\n+          )}\n+        </VStack>\n       </Content>\n     </Dialog>\n   )\n-}\n+}\n\\ No newline at end of file\ndiff --git a/packages/core/src/admin-ui/context.tsx b/packages/core/src/admin-ui/context.tsx\nindex d7908821f..6b5ba14c3 100644\n--- a/packages/core/src/admin-ui/context.tsx\n+++ b/packages/core/src/admin-ui/context.tsx\n@@ -242,12 +242,6 @@ export function useListItem(\n               isRequired: ConditionalFilterCase<BaseListTypeInfo>\n             } | null\n           }[]\n-          actions: {\n-            key: string\n-            itemView: {\n-              actionMode: ConditionalFilter<'enabled' | 'disabled' | 'hidden', BaseListTypeInfo>\n-            } | null\n-          }[]\n         } | null\n       }\n     }\n@@ -300,4 +294,4 @@ export function useListItem(\n       id: itemId,\n     },\n   })\n-}\n+}\n\\ No newline at end of file\ndiff --git a/tests/admin-ui-tests/list-view-crud.test.ts b/tests/admin-ui-tests/list-view-crud.test.ts\nindex 18fb2def1..51b3a51b3 100644\n--- a/tests/admin-ui-tests/list-view-crud.test.ts\n+++ b/tests/admin-ui-tests/list-view-crud.test.ts\n@@ -89,7 +89,7 @@ adminUITests('./tests/test-projects/crud-notifications', browserType => {\n     const alertDialog = page.locator('[role=alertdialog][aria-modal=false]')\n     await alertDialog.waitFor()\n \n-    expect(await alertDialog.innerText()).toBe('Unable to delete 25 tasks.\\nDetails')\n+    expect(await alertDialog.innerText()).toBe('Unable to delete 25 tasks.')\n \n     await alertDialog.getByRole('button', { name: 'Close' }).click()\n     await page\n@@ -99,4 +99,4 @@ adminUITests('./tests/test-projects/crud-notifications', browserType => {\n   afterAll(async () => {\n     await browser.close()\n   })\n-})\n+})\n\\ No newline at end of file\n",
    "test_patch": "",
    "problem_statement": "",
    "hints_text": ""
  }
]