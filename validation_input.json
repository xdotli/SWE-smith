[
    {
        "instance_id": "pylint-dev__astroid.b114f6b5.2496",
        "patch": "diff --git a/astroid/nodes/node_classes.py b/astroid/nodes/node_classes.py\nindex fde3239..561c453 100644\n--- a/astroid/nodes/node_classes.py\n+++ b/astroid/nodes/node_classes.py\n@@ -4695,23 +4695,19 @@ class FormattedValue(NodeNG):\n                     uninferable_already_generated = True\n                 continue\n             for value in self.value.infer(context, **kwargs):\n-                value_to_format = value\n-                if isinstance(value, Const):\n-                    value_to_format = value.value\n-                try:\n-                    formatted = format(value_to_format, format_spec.value)\n-                    yield Const(\n-                        formatted,\n-                        lineno=self.lineno,\n-                        col_offset=self.col_offset,\n-                        end_lineno=self.end_lineno,\n-                        end_col_offset=self.end_col_offset,\n-                    )\n+                if not isinstance(value, Const):\n+                    if not uninferable_already_generated:\n+                        yield util.Uninferable\n+                        uninferable_already_generated = True\n                     continue\n-                except (ValueError, TypeError):\n-                    # happens when format_spec.value is invalid\n-                    yield util.Uninferable\n-                    uninferable_already_generated = True\n+                formatted = format(value.value, format_spec.value)\n+                yield Const(\n+                    formatted,\n+                    lineno=self.lineno,\n+                    col_offset=self.col_offset,\n+                    end_lineno=self.end_lineno,\n+                    end_col_offset=self.end_col_offset,\n+                )\n                 continue\n \n \n@@ -5552,4 +5548,4 @@ def const_factory(value: Any) -> ConstFactoryResult:\n         )\n         instance.postinit(_create_dict_items(value, instance))\n         return instance\n-    return Const(value)\n+    return Const(value)\n\\ No newline at end of file\n",
        "repo": "pylint-dev__astroid.b114f6b5",
        "instance_ref": {
            "test_patch": "diff --git a/tests/test_inference.py b/tests/test_inference.py\nindex 61378043c3..a8b11b1614 100644\n--- a/tests/test_inference.py\n+++ b/tests/test_inference.py\n@@ -666,21 +666,6 @@ def test_fstring_inference(self) -> None:\n         self.assertIsInstance(value_node, Const)\n         self.assertEqual(value_node.value, \"Hello John!\")\n \n-    def test_formatted_fstring_inference(self) -> None:\n-        code = \"\"\"\n-            width = 10\n-            precision = 4\n-            value = 12.34567\n-            result = f\"result: {value:{width}.{precision}}!\"\n-            \"\"\"\n-        ast = parse(code, __name__)\n-        node = ast[\"result\"]\n-        inferred = node.inferred()\n-        self.assertEqual(len(inferred), 1)\n-        value_node = inferred[0]\n-        self.assertIsInstance(value_node, Const)\n-        self.assertEqual(value_node.value, \"result:      12.35!\")\n-\n     def test_float_complex_ambiguity(self) -> None:\n         code = '''\n             def no_conjugate_member(magic_flag):  #@\n@@ -5517,6 +5502,51 @@ class instance(object):\n         self.assertIsInstance(inferred, Instance)\n \n \n+@pytest.mark.parametrize(\n+    \"code, result\",\n+    [\n+        # regular f-string\n+        (\n+            \"\"\"width = 10\n+precision = 4\n+value = 12.34567\n+result = f\"result: {value:{width}.{precision}}!\"\n+\"\"\",\n+            \"result:      12.35!\",\n+        ),\n+        # unsupported format\n+        (\n+            \"\"\"width = None\n+precision = 4\n+value = 12.34567\n+result = f\"result: {value:{width}.{precision}}!\"\n+\"\"\",\n+            None,\n+        ),\n+        # unsupported value\n+        (\n+            \"\"\"width = 10\n+precision = 4\n+value = None\n+result = f\"result: {value:{width}.{precision}}!\"\n+\"\"\",\n+            None,\n+        ),\n+    ],\n+)\n+def test_formatted_fstring_inference(code, result) -> None:\n+    ast = parse(code, __name__)\n+    node = ast[\"result\"]\n+    inferred = node.inferred()\n+    assert len(inferred) == 1\n+    value_node = inferred[0]\n+    if result is None:\n+        assert value_node is util.Uninferable\n+    else:\n+        assert isinstance(value_node, Const)\n+        assert value_node.value == result\n+\n+\n def test_augassign_recursion() -> None:\n     \"\"\"Make sure inference doesn't throw a RecursionError.\n \n"
        }
    }
]